uint64_t VCPGetVersion()
{
  return 109;
}

uint64_t VCPRateControlSessionCopySupportedPropertyDictionary(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t result;
  _BOOL4 v4;
  unint64_t v6;
  const void *v7;
  CFTypeRef v8;
  NSObject *v9;
  const char *v10;
  uint64_t *v11;
  uint64_t v12;
  uint8_t *v13;
  uint8_t buf[24];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    v4 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v4)
      return result;
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "NULL session\n", buf, 2u);
    return 0;
  }
  v2 = *(_QWORD *)(a1 + 16);
  v12 = v2;
  if (!v2)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v9 = MEMORY[0x1E0C81028];
      v10 = "Empty session storage\n";
      goto LABEL_25;
    }
    return 4294954392;
  }
  if (!*(_BYTE *)(v2 + 232))
  {
    if (*(_BYTE *)(v2 + 244))
    {
      v11 = &v12;
      v6 = atomic_load(&qword_1EF1386F8);
      if (v6 != -1)
      {
        *(_QWORD *)buf = &v11;
        v13 = buf;
        std::__call_once(&qword_1EF1386F8, &v13, (void (__cdecl *)(void *))sub_1B6771334);
      }
      v7 = (const void *)qword_1EF138700;
      if (qword_1EF138700)
      {
        if (!a2)
          return 0;
LABEL_20:
        v8 = CFRetain(v7);
        result = 0;
        *a2 = v8;
        return result;
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        v9 = MEMORY[0x1E0C81028];
        v10 = "CFDictionaryCreate failed\n";
LABEL_25:
        _os_log_error_impl(&dword_1B676B000, v9, OS_LOG_TYPE_ERROR, v10, buf, 2u);
        return 4294954392;
      }
      return 4294954392;
    }
    if (a2)
    {
      v7 = *(const void **)(v2 + 184);
      goto LABEL_20;
    }
    return 0;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v2 + 256;
    _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: RC session is invalid\n", buf, 0xCu);
  }
  return 4294954393;
}

uint64_t VCPRateControlSessionSetProperty(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  uint64_t v3;
  uint64_t v4;
  std::__shared_mutex_base *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t **v13;
  CFTypeID TypeID;
  const void *v16;
  CFTypeRef *v17;
  CFTypeID v18;
  uint64_t v19;
  char v20;
  const __CFString *v21;
  _BYTE buf[12];
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 16);
    if (v3)
    {
      if (*(_BYTE *)(v3 + 232))
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v3 + 256;
          _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: RC session is invalid\n", buf, 0xCu);
        }
        return 4294954393;
      }
      v7 = (std::__shared_mutex_base *)(v3 + 2368);
      if (*(_BYTE *)(v3 + 244))
      {
        *(_QWORD *)buf = v3 + 2368;
        buf[8] = 1;
        std::__shared_mutex_base::lock(v7);
        v4 = sub_1B6777FAC(v3, a2, a3);
        v8 = (uint64_t *)buf;
LABEL_26:
        sub_1B6771360((uint64_t)v8);
        return v4;
      }
      v19 = v3 + 2368;
      v20 = 1;
      std::__shared_mutex_base::lock(v7);
      v21 = a2;
      if (!sub_1B67782D8(*(_QWORD **)(v3 + 2544), (CFTypeRef *)&v21))
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          v10 = *(_QWORD *)(v3 + 2536);
          v11 = *(_DWORD *)(v3 + 212);
          v12 = *(_DWORD *)(v3 + 216);
          *(_DWORD *)buf = 134218496;
          *(_QWORD *)&buf[4] = v10;
          v23 = 1024;
          v24 = v11;
          v25 = 1024;
          v26 = v12;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): unrecognised property key", buf, 0x18u);
        }
        v4 = 4294966630;
        goto LABEL_25;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED180]))
      {
        v9 = sub_1B6777D4C(v3, a3);
        goto LABEL_22;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED000]))
      {
        v9 = sub_1B6777B04(v3, a3);
        goto LABEL_22;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF78]))
      {
        if (!a3)
          goto LABEL_23;
        TypeID = CFArrayGetTypeID();
        if (TypeID != CFGetTypeID(a3))
          goto LABEL_23;
        v17 = (CFTypeRef *)(v3 + 136);
        v16 = *(const void **)(v3 + 136);
        if (!v16)
          goto LABEL_38;
      }
      else
      {
        if (!CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECED0]))
        {
          v9 = sub_1B6778420(v3, a2, a3);
LABEL_22:
          v4 = v9;
          if ((_DWORD)v9)
          {
LABEL_25:
            v8 = &v19;
            goto LABEL_26;
          }
LABEL_23:
          v13 = sub_1B67782D8(*(_QWORD **)(v3 + 2544), (CFTypeRef *)&v21);
          if (!v13)
            sub_1B67783D0("unordered_map::at: key not found");
          v4 = 0;
          *((_BYTE *)v13 + 48) = 1;
          goto LABEL_25;
        }
        if (!a3)
          goto LABEL_23;
        v18 = CFStringGetTypeID();
        if (v18 != CFGetTypeID(a3))
          goto LABEL_23;
        v17 = (CFTypeRef *)(v3 + 168);
        v16 = *(const void **)(v3 + 168);
        if (!v16)
        {
LABEL_38:
          *v17 = CFRetain(a3);
          goto LABEL_23;
        }
      }
      CFRelease(v16);
      goto LABEL_38;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Empty session storage\n", buf, 2u);
    }
    return 4294954392;
  }
  else
  {
    v4 = 0;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "NULL session\n", buf, 2u);
      return 0;
    }
  }
  return v4;
}

void sub_1B676D12C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  sub_1B6771360((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t VCPRateControlSessionBeforePrepareToEncodeFrames(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  double v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  CFTypeRef **v26;
  __CFDictionary *Mutable;
  __CFDictionary *v28;
  int v29;
  int v30;
  const void *v31;
  CFNumberRef v32;
  CFNumberRef v33;
  int v34;
  const void *v35;
  double v36;
  int v37;
  int v38;
  const void *v39;
  CFNumberRef v40;
  uint64_t v41;
  uint64_t v42;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  NSObject *v50;
  const char *v51;
  int v52;
  int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  double v58;
  double v60;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  uint64_t v65;
  char v66;
  uint64_t valuePtr;
  _BYTE buf[1320];
  int v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    v3 = 0;
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      return v3;
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "NULL session\n", buf, 2u);
    return 0;
  }
  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    if (*(_BYTE *)(v2 + 232))
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v2 + 256;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: RC session is invalid\n", buf, 0xCu);
      }
      return 4294954393;
    }
    if (*(_BYTE *)(v2 + 244))
    {
      std::mutex::lock((std::mutex *)(v2 + 2304));
      v65 = v2 + 2368;
      v66 = 1;
      std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v2 + 2368));
      if (*(int *)(v2 + 100) >= 1)
      {
        v5 = *(double *)(v2 + 40);
        v6 = *(_DWORD *)(v2 + 76);
        v7 = *(_DWORD *)(v2 + 212);
        v8 = *(_DWORD *)(v2 + 216);
        v9 = sub_1B67EE3C8();
        if ((v7 + 15) >> 4 <= 12)
          v10 = 12;
        else
          v10 = (v7 + 15) >> 4;
        if ((v8 + 15) >> 4 <= 6)
          v11 = 6;
        else
          v11 = (v8 + 15) >> 4;
        if (v9)
          v12 = v11;
        else
          v12 = (v8 + 15) >> 4;
        if (v9)
          v13 = v10;
        else
          v13 = (v7 + 15) >> 4;
        v14 = sub_1B6890AE8((uint64_t)buf, (int)(v5 + 0.5), v6, v13, v12, *(_DWORD *)(v2 + 16), *(_DWORD *)(v2 + 20), *(_DWORD *)(v2 + 100));
        if ((_DWORD)v14)
        {
          v3 = v14;
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v2 + 256;
            _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: failed to verify max reference buffer count\n", buf, 0xCu);
          }
          goto LABEL_117;
        }
        *(_DWORD *)(v2 + 100) = v69;
      }
      if (*(_BYTE *)(v2 + 233))
      {
        Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v28 = Mutable;
        if (Mutable)
        {
          v29 = *(_DWORD *)(v2 + 236);
          if (v29 >= 2 && *(_BYTE *)(v2 + 244))
            sub_1B6771DF8(Mutable, (const void *)*MEMORY[0x1E0CED120], v29);
          v30 = *(_DWORD *)(v2 + 240);
          if (v30 >= 2 && *(_BYTE *)(v2 + 244))
            sub_1B6771DF8(v28, CFSTR("MinNumberOfTemporalLayers"), v30);
          v31 = (const void *)*MEMORY[0x1E0C9AE40];
          CFDictionarySetValue(v28, CFSTR("AllowQpModulation"), (const void *)*MEMORY[0x1E0C9AE40]);
          valuePtr = *(_QWORD *)(v2 + 40);
          v32 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
          *(_QWORD *)buf = v32;
          if (v32)
            CFDictionarySetValue(v28, (const void *)*MEMORY[0x1E0CECFD0], v32);
          sub_1B6770598((const void **)buf);
          LODWORD(valuePtr) = *(_DWORD *)(v2 + 76);
          v33 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
          *(_QWORD *)buf = v33;
          if (v33)
            CFDictionarySetValue(v28, (const void *)*MEMORY[0x1E0CECEF0], v33);
          sub_1B6770598((const void **)buf);
          v34 = *(_DWORD *)(v2 + 208);
          if (v34 != 1718908520 && v34 != 1752589105)
          {
            v35 = *(const void **)(v2 + 24);
            if (v35)
              CFDictionarySetValue(v28, (const void *)*MEMORY[0x1E0CED000], v35);
          }
          v36 = *(double *)(v2 + 48);
          if (v36 >= 0.0)
          {
            sub_1B6771E68(v28, (const void *)*MEMORY[0x1E0CECF10], v36);
            if (*(double *)(v2 + 48) != 1.0)
              sub_1B6771E68(v28, (const void *)*MEMORY[0x1E0CECF00], *(double *)(v2 + 56));
          }
          CFDictionarySetValue(v28, (const void *)*MEMORY[0x1E0CED180], *(const void **)v2);
          v37 = *(_DWORD *)(v2 + 100);
          if (v37 >= 1)
            sub_1B6771DF8(v28, (const void *)*MEMORY[0x1E0CED1A8], v37);
          v38 = *(_DWORD *)(v2 + 80);
          if (v38 >= 1)
            sub_1B6771DF8(v28, (const void *)*MEMORY[0x1E0CED098], v38);
          if (*(_BYTE *)(v2 + 97))
            v39 = (const void *)*MEMORY[0x1E0C9AE50];
          else
            v39 = v31;
          CFDictionarySetValue(v28, (const void *)*MEMORY[0x1E0CECF20], v39);
          valuePtr = *(_QWORD *)(v2 + 2536);
          v40 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
          *(_QWORD *)buf = v40;
          if (v40)
            CFDictionarySetValue(v28, CFSTR("CallerID"), v40);
          sub_1B6770598((const void **)buf);
          v3 = 0;
          *a2 = v28;
          goto LABEL_117;
        }
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          goto LABEL_116;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v2 + 256;
        v50 = MEMORY[0x1E0C81028];
        v51 = "%s: Failed to allocate session properties\n";
        goto LABEL_115;
      }
      if (!*(_QWORD *)(v2 + 2296) && sub_1B6771640(v2, 0))
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v2 + 256;
          v50 = MEMORY[0x1E0C81028];
          v51 = "%s: Failed to initialize sequence\n";
LABEL_115:
          _os_log_error_impl(&dword_1B676B000, v50, OS_LOG_TYPE_ERROR, v51, buf, 0xCu);
          goto LABEL_116;
        }
        goto LABEL_116;
      }
      if (a2 && (v41 = *(_QWORD *)(*(_QWORD *)(v2 + 2296) + 13272)) != 0)
      {
        v42 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v41 + 72))(v41);
        if (!v42)
        {
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v2 + 256;
            v50 = MEMORY[0x1E0C81028];
            v51 = "%s: Failed to create session properties\n";
            goto LABEL_115;
          }
LABEL_116:
          v3 = 4294954392;
          goto LABEL_117;
        }
        v3 = 0;
        *a2 = v42;
      }
      else
      {
        v3 = 0;
      }
LABEL_117:
      sub_1B677160C((uint64_t)&v65);
      std::mutex::unlock((std::mutex *)(v2 + 2304));
      return v3;
    }
    v15 = sub_1B677D1C8(*(_QWORD *)(a1 + 16), (const void *)*MEMORY[0x1E0CECEF0]);
    v16 = sub_1B677D1C8(v2, (const void *)*MEMORY[0x1E0CECF78]);
    v17 = sub_1B677D1C8(v2, (const void *)*MEMORY[0x1E0CECF58]);
    v18 = sub_1B677D1C8(v2, (const void *)*MEMORY[0x1E0CECFD0]);
    if (v17)
    {
      if ((v15 | v16) == 1)
        sub_1B677D228("ConstantBitRate can't be set with AverageBitRate or DataRateLimits\n");
      if ((v18 & 1) == 0)
        sub_1B677D228("ConstantBitRate needs ExpectedFrameRate to ensure effective CBR rate control\n");
    }
    v63 = v18;
    v19 = sub_1B677D1C8(v2, (const void *)*MEMORY[0x1E0CED180]);
    v20 = sub_1B677D1C8(v2, (const void *)*MEMORY[0x1E0CECEC8]);
    v64 = sub_1B677D1C8(v2, (const void *)*MEMORY[0x1E0CECEB0]);
    v62 = sub_1B677D1C8(v2, (const void *)*MEMORY[0x1E0CED1A8]);
    sub_1B677D1C8(v2, (const void *)*MEMORY[0x1E0CED128]);
    v21 = sub_1B677D1C8(v2, (const void *)*MEMORY[0x1E0CED000]);
    v22 = sub_1B677D1C8(v2, (const void *)*MEMORY[0x1E0CED0A8]);
    v23 = sub_1B677D1C8(v2, (const void *)*MEMORY[0x1E0CED0B0]);
    if (v19)
    {
      v24 = v23;
      v25 = 0;
      v26 = (CFTypeRef **)qword_1E6A165D8;
      while (!CFEqual(*(CFTypeRef *)v2, **v26))
      {
        ++v25;
        v26 += 5;
        if (v25 == 24)
          goto LABEL_127;
      }
      if (v21)
      {
        if (*(_DWORD *)(v2 + 32) == 1 && (unint64_t)(v25 - 14) <= 0xFFFFFFFFFFFFFFFCLL)
          sub_1B677D228("H264EntropyMode is not supported for %s\n", *(const char **)(v2 + 8));
      }
      if (v20 && !*(_BYTE *)(v2 + 64))
      {
        if (v22 && *(_DWORD *)(v2 + 68) != 1)
          sub_1B677D228("MaxKeyFrameInterval (%d) must be 1 when AllowTemporalCompression is set to 0\n", *(_DWORD *)(v2 + 68));
        if (v24)
          sub_1B677D228("No need to set MaxKeyFrameIntervalDuration when AllowTemporalCompression is set to 0\n");
      }
      if (v64 && ((0xFFC300uLL >> v25) & 1) != 0)
        sub_1B677D228("AllowFrameReordering is not supported for %s\n", *(const char **)(v2 + 8));
      if (v15)
      {
        v44 = *(_DWORD *)(v2 + 76);
        if (1000 * LODWORD(qword_1E6A165D8[5 * v25 + 3]) < v44)
          sub_1B677D228("AverageBitrate (%d bps) exceeds the level limit of %d kbps for %s\n", v44, LODWORD(qword_1E6A165D8[5 * v25 + 3]), *(const char **)(v2 + 8));
      }
      if (v17)
      {
        v45 = *(_DWORD *)(v2 + 144);
        if (1000 * LODWORD(qword_1E6A165D8[5 * v25 + 3]) < v45)
          sub_1B677D228("ConstantBitrate (%d bps) exceeds the level limit of %d kbps for %s\n", v45, LODWORD(qword_1E6A165D8[5 * v25 + 3]), *(const char **)(v2 + 8));
      }
      v46 = *(_DWORD *)(v2 + 212);
      v47 = *(_DWORD *)(v2 + 216);
      v48 = ((v47 + 15) >> 4) * ((v46 + 15) >> 4);
      v49 = HIDWORD(qword_1E6A165D8[5 * v25 + 3]);
      if (v48 <= v49)
      {
        if (v48 >= 1)
        {
          if (v63 && *(double *)(v2 + 40) > fmin((double)SLODWORD(qword_1E6A165D8[5 * v25 + 4]) / (double)v48, 300.0))
          {
            sub_1B677D228("Frame rate (%.1f fps) exceeds the level limit of %.1f fps for %s\n");
          }
          else if (v62)
          {
            if ((v25 & 0xFFFFFFF8) != 0)
            {
              v52 = SHIDWORD(qword_1E6A165D8[5 * v25 + 4]) / v48;
              if (v52 >= 16)
                v52 = 16;
            }
            else
            {
              v53 = v47 * v46;
              if (v53 <= v49 << 6)
              {
                v52 = 16;
              }
              else if (v53 <= v49 << 7)
              {
                v52 = 12;
              }
              else if (v53 <= (768 * v49) >> 2)
              {
                v52 = 8;
              }
              else
              {
                v52 = 6;
              }
            }
            if (*(_DWORD *)(v2 + 100) > v52)
              sub_1B677D228("Reference count (%d) exceeds the level limit of %d for %s\n");
          }
        }
      }
      else
      {
        sub_1B677D228("Frame size (%dx%d) exceeds the level limit of %d MBs for %s\n");
      }
    }
LABEL_127:
    v54 = sub_1B677D1C8(v2, (const void *)*MEMORY[0x1E0CED190]);
    v55 = sub_1B677D1C8(v2, (const void *)*MEMORY[0x1E0CECED0]);
    v56 = sub_1B677D1C8(v2, (const void *)*MEMORY[0x1E0CED160]);
    v57 = sub_1B677D1C8(v2, (const void *)*MEMORY[0x1E0CED210]);
    if (v54)
    {
      v58 = *(double *)(v2 + 152);
      if (v58 < 0.0 || v58 > 1.0)
        sub_1B677D228("Quality value (%f) is out of bounds (0,1)\n", *(double *)(v2 + 152));
    }
    if (v56 && *(_DWORD *)(v2 + 208) != 1752589105)
      sub_1B677D228("PreserveAlphaChannel requires HEVC\n");
    if (v55 && *(_DWORD *)(v2 + 208) != 1752589105)
      sub_1B677D228("AlphaChannelMode requires HEVC\n");
    if (v57)
    {
      if (*(_DWORD *)(v2 + 208) == 1752589105)
      {
        v60 = *(double *)(v2 + 176);
        if (v60 < 0.0 || v60 > 1.0)
          sub_1B677D228("Alpha quality value (%f) is out of bounds (0, 1)\n");
      }
      else
      {
        sub_1B677D228("TargetQualityForAlpha requires HEVC\n");
      }
    }
    if (a2)
    {
      v3 = 0;
      *a2 = 0;
      return v3;
    }
    return 0;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Empty session storage\n", buf, 2u);
  }
  return 4294954392;
}

void sub_1B676DC64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  std::mutex *v8;
  va_list va;

  va_start(va, a8);
  sub_1B677160C((uint64_t)va);
  std::mutex::unlock(v8);
  _Unwind_Resume(a1);
}

uint64_t VCPRateControlSessionCreate(int a1, int a2, int a3, int a4, CFDictionaryRef theDict, const __CFDictionary *a6, int a7, uint64_t a8, uint64_t a9, uint64_t a10, _QWORD *a11)
{
  const void *v17;
  const __CFBoolean *Value;
  BOOL v19;
  const void *v20;
  const __CFBoolean *v21;
  int v22;
  char v23;
  _QWORD *Instance;
  CFNumberRef v25;
  char *v26;
  uint64_t v27;
  char *v28;
  const void *v29;
  const __CFNumber *v30;
  int v31;
  uint64_t v32;
  _QWORD *v33;
  char *v34;
  uint64_t v35;
  char *v36;
  float *v37;
  float *v38;
  CFTypeID v39;
  CFTypeID v40;
  CFTypeID v41;
  CFTypeID v42;
  CFTypeID v43;
  CFTypeID v44;
  CFTypeID v45;
  CFTypeID v46;
  CFTypeID v47;
  CFTypeID v48;
  CFTypeID v49;
  CFTypeID v50;
  CFTypeID v51;
  CFTypeID v52;
  CFTypeID v53;
  CFTypeID v54;
  CFDictionaryRef v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  _QWORD *v60;
  void *v61;
  void *v62;
  _OWORD *v63;
  uint64_t v65;
  int v66;
  int v67;
  unint64_t v68;
  int v69;
  const void *v70;
  unsigned int v71;
  const void *v72;
  _BOOL4 v73;
  NSObject *v74;
  const char *v75;
  uint32_t v76;
  uint64_t v77;
  int v78;
  int v79;
  const void *v80;
  NSObject *v81;
  const char *v82;
  float *v83;
  float *v84;
  unsigned __int8 v85;
  unsigned __int8 v86;
  CFTypeID TypeID;
  CFTypeID v88;
  CFTypeID v89;
  CFTypeID v90;
  CFTypeID v91;
  CFTypeID v92;
  CFTypeID v93;
  CFTypeID v94;
  CFTypeID v95;
  CFTypeID v96;
  CFTypeID v97;
  CFTypeID v98;
  CFTypeID v99;
  CFTypeID v100;
  CFTypeID v101;
  const __CFString *v102;
  const __CFString *v103;
  const void *v104;
  const __CFString *v105;
  uint64_t v106;
  int v107;
  int v108;
  unsigned int v109;
  _BOOL4 v110;
  const void *v111;
  char v112;
  _BYTE *valuePtr;
  _BYTE buf[32];
  char v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  if (!theDict)
    goto LABEL_25;
  v17 = (const void *)*MEMORY[0x1E0CEDD28];
  v19 = CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E0CEDD28])
     && (Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, v17)) != 0
     && CFBooleanGetValue(Value) != 0;
  v20 = (const void *)*MEMORY[0x1E0CEDD40];
  if (!CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E0CEDD40])
    || (v21 = (const __CFBoolean *)CFDictionaryGetValue(theDict, v20)) == 0)
  {
    if (!v19)
      goto LABEL_25;
    v110 = 0;
LABEL_15:
    v111 = 0;
    if (a4 != 1635148593 && a4 != 1752589105)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109888;
        *(_DWORD *)&buf[4] = a4 >> 24;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = a4 << 8 >> 24;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&buf[16] = (__int16)a4 >> 8;
        *(_WORD *)&buf[20] = 1024;
        *(_DWORD *)&buf[22] = (char)a4;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VCPRateControlSession: codec type '%c%c%c%c' is not supported\n", buf, 0x1Au);
      }
      Instance = 0;
      v56 = 4294954394;
      goto LABEL_70;
    }
    pthread_once(&stru_1EF137C70, (void (*)(void))sub_1B67711D0);
    Instance = (_QWORD *)_CFRuntimeCreateInstance();
    if (!Instance)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Failed to create VCPRateControlSession\n", buf, 2u);
      }
      v56 = 4294954392;
      goto LABEL_71;
    }
    LODWORD(valuePtr) = 1;
    v25 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    *(_QWORD *)buf = v25;
    if (v25)
      CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E0CED248], v25);
    sub_1B6770598((const void **)buf);
    v26 = (char *)operator new(0x9F8uLL, MEMORY[0x1E0DE4E10]);
    if (!v26)
    {
      Instance[2] = 0;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        v74 = MEMORY[0x1E0C81028];
        v75 = "Failed to create private storage\n";
        v76 = 2;
LABEL_89:
        _os_log_error_impl(&dword_1B676B000, v74, OS_LOG_TYPE_ERROR, v75, buf, v76);
      }
LABEL_52:
      v56 = 4294967188;
LABEL_69:
      CFRelease(Instance);
      Instance = 0;
LABEL_70:
      *a11 = Instance;
LABEL_71:
      sub_1B6771304(&v111);
      return v56;
    }
    v27 = (uint64_t)v26;
    v28 = v26 + 2304;
    bzero(v26, 0x9F8uLL);
    *(_QWORD *)(v27 + 2304) = 850045863;
    *(_OWORD *)(v28 + 8) = 0u;
    *(_OWORD *)(v28 + 24) = 0u;
    *(_OWORD *)(v28 + 40) = 0u;
    *(_QWORD *)(v27 + 2360) = 0;
    std::__shared_mutex_base::__shared_mutex_base((std::__shared_mutex_base *)(v27 + 2368));
    *(_QWORD *)(v27 + 2536) = 0;
    Instance[2] = v27;
    if (!a6)
    {
      v31 = 0;
      goto LABEL_57;
    }
    v29 = (const void *)*MEMORY[0x1E0CA9040];
    *(_DWORD *)buf = 0;
    v30 = (const __CFNumber *)CFDictionaryGetValue(a6, v29);
    if (v30)
    {
      CFNumberGetValue(v30, kCFNumberSInt32Type, buf);
      v31 = *(_DWORD *)buf;
      if ((*(_DWORD *)buf & 0xFFFFFFEF) == 0x34323066)
        goto LABEL_57;
    }
    else
    {
      v31 = 0;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v57 = *(_QWORD *)(v27 + 2536);
      v58 = *(_DWORD *)(v27 + 212);
      v59 = *(_DWORD *)(v27 + 216);
      *(_DWORD *)buf = 134218752;
      *(_QWORD *)&buf[4] = v57;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v58;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v59;
      *(_WORD *)&buf[24] = 1024;
      *(_DWORD *)&buf[26] = v31;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): Source image buffer attributes contain pixel format %d\n", buf, 0x1Eu);
    }
LABEL_57:
    if (a4 == 1752589105)
      v60 = (_QWORD *)MEMORY[0x1E0CED9B0];
    else
      v60 = (_QWORD *)MEMORY[0x1E0CED930];
    *(_QWORD *)v27 = *v60;
    *(_QWORD *)(v27 + 24) = 0;
    *(_DWORD *)(v27 + 32) = 0;
    *(_QWORD *)(v27 + 136) = 0;
    *(_QWORD *)(v27 + 168) = 0;
    *(_QWORD *)(v27 + 184) = 0;
    v61 = operator new(0x88uLL, MEMORY[0x1E0DE4E10]);
    if (v61)
    {
      v62 = v61;
      sub_1B6872CF8((uint64_t)v61, (uint64_t)sub_1B6778750, v27);
      *(_QWORD *)(v27 + 2256) = v62;
      *(_QWORD *)(v27 + 2536) = mach_absolute_time();
      *(_DWORD *)(v27 + 208) = a4;
      *(_DWORD *)(v27 + 212) = a2;
      *(_DWORD *)(v27 + 216) = a3;
      *(_WORD *)(v27 + 64) = 1;
      *(_BYTE *)(v27 + 66) = 1;
      *(_DWORD *)(v27 + 192) = 1;
      *(_OWORD *)(v27 + 40) = xmmword_1B6917350;
      *(_QWORD *)(v27 + 56) = 0x3FE3333333333333;
      *(_QWORD *)(v27 + 68) = 0;
      *(_DWORD *)(v27 + 76) = 7 * a2 * a3 / 10;
      *(_QWORD *)(v27 + 112) = 0;
      *(_QWORD *)(v27 + 120) = 0;
      *(_QWORD *)(v27 + 104) = 0;
      *(_QWORD *)(v27 + 2272) = a8;
      *(_QWORD *)(v27 + 2280) = a9;
      *(_QWORD *)(v27 + 2288) = a10;
      *(_DWORD *)(v27 + 232) = 256;
      *(_QWORD *)(v27 + 236) = 0x200000002;
      *(_BYTE *)(v27 + 244) = 0;
      *(_DWORD *)(v27 + 200) = 2;
      *(_DWORD *)(v27 + 204) = v31;
      *(_QWORD *)(v27 + 248) = 0x200000000;
      *(_QWORD *)(v27 + 80) = -1;
      *(_DWORD *)(v27 + 92) = -1;
      *(_WORD *)(v27 + 96) = 0;
      *(_BYTE *)(v27 + 88) = 0;
      *(_DWORD *)(v27 + 100) = -1;
      *(_BYTE *)(v27 + 128) = a4 == 1635148593;
      *(_QWORD *)(v27 + 2544) = 0;
      if (!sub_1B6777D4C(v27, *(const __CFString **)v27))
      {
        *(_QWORD *)(v27 + 224) = 0;
        v63 = operator new(0x28uLL, MEMORY[0x1E0DE4E10]);
        if (v63)
        {
          *v63 = 0u;
          v63[1] = 0u;
          *((_BYTE *)v63 + 24) = 1;
          *((_QWORD *)v63 + 4) = 0;
          *(_QWORD *)(v27 + 2264) = v63;
          sub_1B67813AC((uint64_t *)v63, *(_QWORD *)(v27 + 2536));
        }
        else
        {
          *(_QWORD *)(v27 + 2264) = 0;
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          {
            v65 = *(_QWORD *)(v27 + 2536);
            v66 = *(_DWORD *)(v27 + 212);
            v67 = *(_DWORD *)(v27 + 216);
            *(_DWORD *)buf = 134218496;
            *(_QWORD *)&buf[4] = v65;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v66;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v67;
            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): failed to create reaction listener\n", buf, 0x18u);
          }
        }
        snprintf((char *)(v27 + 256), 0x7D0uLL, "VCPRateControlSession %p (%dx%d)", Instance, a2, a3);
        *(_BYTE *)(v27 + 244) = 1;
        v68 = atomic_load(&qword_1EF139168);
        if (v68 != -1)
        {
          *(_QWORD *)buf = &v112;
          valuePtr = buf;
          std::__call_once(&qword_1EF139168, &valuePtr, (void (__cdecl *)(void *))sub_1B67EE1B4);
        }
        *(_BYTE *)(v27 + 235) = byte_1EF139160;
        v69 = sub_1B67EE3C8();
        *(_BYTE *)(v27 + 234) = v69;
        if (*(_BYTE *)(v27 + 235))
        {
          v70 = (const void *)*MEMORY[0x1E0CEDD20];
          if (CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E0CEDD20]))
            v71 = sub_1B67712E0(theDict, v70);
          else
            v71 = 1;
          if (CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E0CEDCF8]))
          {
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
              goto LABEL_123;
            goto LABEL_125;
          }
          *(_BYTE *)(v27 + 233) = 0;
          v73 = v71 != 0;
        }
        else
        {
          if (!v69)
          {
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
            {
              v77 = *(_QWORD *)(v27 + 2536);
              v78 = *(_DWORD *)(v27 + 212);
              v79 = *(_DWORD *)(v27 + 216);
              *(_DWORD *)buf = 134218496;
              *(_QWORD *)&buf[4] = v77;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v78;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v79;
              _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): Hardware support is not available\n", buf, 0x18u);
            }
            v80 = (const void *)*MEMORY[0x1E0CEDD38];
            if (CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E0CEDD38])
              && sub_1B67712E0(theDict, v80))
            {
              if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                goto LABEL_125;
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = v27 + 256;
              v81 = MEMORY[0x1E0C81028];
              v82 = "%s: Cannot require hardware accelerated encoder\n";
              goto LABEL_124;
            }
            v109 = 0;
            *(_BYTE *)(v27 + 233) = 1;
LABEL_99:
            v83 = (float *)operator new(0x28uLL, MEMORY[0x1E0DE4E10]);
            if (v83)
            {
              v84 = v83;
              *(_OWORD *)v83 = 0u;
              *((_OWORD *)v83 + 1) = 0u;
              v83[8] = 1.0;
              *(_QWORD *)(v27 + 2544) = v83;
              v85 = atomic_load((unsigned __int8 *)&qword_1EF138790);
              if ((v85 & 1) == 0 && __cxa_guard_acquire(&qword_1EF138790))
              {
                qword_1EF138788 = (uint64_t)CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &unk_1B691FE30);
                __cxa_guard_release(&qword_1EF138790);
              }
              v86 = atomic_load((unsigned __int8 *)&qword_1EF1387A0);
              if ((v86 & 1) == 0 && __cxa_guard_acquire(&qword_1EF1387A0))
              {
                qword_1EF138798 = (uint64_t)CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloat32Type, &unk_1B691FE34);
                __cxa_guard_release(&qword_1EF1387A0);
              }
              TypeID = CFNumberGetTypeID();
              *(_QWORD *)buf = *MEMORY[0x1E0CECFD0];
              *(_QWORD *)&buf[8] = TypeID;
              *(_QWORD *)&buf[16] = "ExpectedFrameRate";
              *(_QWORD *)&buf[24] = v27 + 40;
              v115 = 0;
              v116 = 13;
              v117 = qword_1EF138798;
              sub_1B6778EB4(v84, (CFTypeRef *)buf, (uint64_t)buf);
              v88 = CFBooleanGetTypeID();
              *(_QWORD *)buf = *MEMORY[0x1E0CED208];
              *(_QWORD *)&buf[8] = v88;
              *(_QWORD *)&buf[16] = "SupportsBaseFrameQP";
              *(_QWORD *)&buf[24] = v27 + 66;
              v115 = 0;
              v116 = 16;
              v117 = 0;
              sub_1B6778EB4(v84, (CFTypeRef *)buf, (uint64_t)buf);
              v89 = CFNumberGetTypeID();
              *(_QWORD *)buf = *MEMORY[0x1E0CECEF0];
              *(_QWORD *)&buf[8] = v89;
              *(_QWORD *)&buf[16] = "AverageBitRate";
              *(_QWORD *)&buf[24] = v27 + 76;
              v115 = 0;
              v116 = 3;
              v117 = qword_1EF138788;
              sub_1B6778EB4(v84, (CFTypeRef *)buf, (uint64_t)buf);
              v90 = CFStringGetTypeID();
              *(_QWORD *)buf = *MEMORY[0x1E0CED000];
              *(_QWORD *)&buf[8] = v90;
              *(_QWORD *)&buf[16] = "H264EntropyMode";
              *(_QWORD *)&buf[24] = v27 + 24;
              v115 = 0;
              v116 = 16;
              v117 = 0;
              sub_1B6778EB4(v84, (CFTypeRef *)buf, (uint64_t)buf);
              v91 = CFNumberGetTypeID();
              *(_QWORD *)buf = *MEMORY[0x1E0CECF10];
              *(_QWORD *)&buf[8] = v91;
              *(_QWORD *)&buf[16] = "BaseLayerFrameRateFraction";
              *(_QWORD *)&buf[24] = v27 + 48;
              v115 = 0;
              v116 = 13;
              v117 = qword_1EF138798;
              sub_1B6778EB4(v84, (CFTypeRef *)buf, (uint64_t)buf);
              v92 = CFNumberGetTypeID();
              *(_QWORD *)buf = *MEMORY[0x1E0CECF00];
              *(_QWORD *)&buf[8] = v92;
              *(_QWORD *)&buf[16] = "BaseLayerBitRateFraction";
              *(_QWORD *)&buf[24] = v27 + 56;
              v115 = 0;
              v116 = 13;
              v117 = qword_1EF138798;
              sub_1B6778EB4(v84, (CFTypeRef *)buf, (uint64_t)buf);
              v93 = CFNumberGetTypeID();
              *(_QWORD *)buf = *MEMORY[0x1E0CED1A8];
              *(_QWORD *)&buf[8] = v93;
              *(_QWORD *)&buf[16] = "ReferenceBufferCount";
              *(_QWORD *)&buf[24] = v27 + 100;
              v115 = 0;
              v116 = 3;
              v117 = qword_1EF138788;
              sub_1B6778EB4(v84, (CFTypeRef *)buf, (uint64_t)buf);
              v94 = CFStringGetTypeID();
              *(_QWORD *)buf = *MEMORY[0x1E0CED180];
              *(_QWORD *)&buf[8] = v94;
              *(_QWORD *)&buf[16] = "ProfileLevel";
              *(_QWORD *)&buf[24] = v27;
              v115 = 0;
              v116 = 16;
              v117 = 0;
              sub_1B6778EB4(v84, (CFTypeRef *)buf, (uint64_t)buf);
              v95 = CFNumberGetTypeID();
              *(_QWORD *)buf = *MEMORY[0x1E0CED098];
              *(_QWORD *)&buf[8] = v95;
              *(_QWORD *)&buf[16] = "MaxAllowedFrameQP";
              *(_QWORD *)&buf[24] = v27 + 80;
              v115 = 0;
              v116 = 3;
              v117 = 0;
              sub_1B6778EB4(v84, (CFTypeRef *)buf, (uint64_t)buf);
              v96 = CFBooleanGetTypeID();
              *(_QWORD *)buf = *MEMORY[0x1E0CECEA8];
              *(_QWORD *)&buf[8] = v96;
              *(_QWORD *)&buf[16] = "AVCaptureDeviceReactionEffectsInProgress";
              *(_QWORD *)&buf[24] = v27 + 96;
              v115 = 0;
              v116 = 16;
              v117 = 0;
              sub_1B6778EB4(v84, (CFTypeRef *)buf, (uint64_t)buf);
              if (*(_BYTE *)(v27 + 234))
              {
                v97 = CFBooleanGetTypeID();
                *(_QWORD *)buf = *MEMORY[0x1E0CECF20];
                *(_QWORD *)&buf[8] = v97;
                *(_QWORD *)&buf[16] = "CalculateMeanSquaredError";
                *(_QWORD *)&buf[24] = v27 + 97;
                v115 = 0;
                v116 = 16;
                v117 = 0;
                sub_1B6778EB4(v84, (CFTypeRef *)buf, (uint64_t)buf);
              }
              if (!*(_BYTE *)(v27 + 233))
              {
                v98 = CFNumberGetTypeID();
                *(_QWORD *)buf = *MEMORY[0x1E0CED0A8];
                *(_QWORD *)&buf[8] = v98;
                *(_QWORD *)&buf[16] = "MaxKeyFrameInterval";
                *(_QWORD *)&buf[24] = v27 + 68;
                v115 = 0;
                v116 = 3;
                v117 = qword_1EF138788;
                sub_1B6778EB4(v84, (CFTypeRef *)buf, (uint64_t)buf);
                v99 = CFNumberGetTypeID();
                *(_QWORD *)buf = *MEMORY[0x1E0CED0B0];
                *(_QWORD *)&buf[8] = v99;
                *(_QWORD *)&buf[16] = "MaxKeyFrameIntervalDuration";
                *(_QWORD *)&buf[24] = v27 + 72;
                v115 = 0;
                v116 = 5;
                v117 = qword_1EF138798;
                sub_1B6778EB4(v84, (CFTypeRef *)buf, (uint64_t)buf);
                v100 = CFNumberGetTypeID();
                *(_QWORD *)buf = *MEMORY[0x1E0CED0C0];
                *(_QWORD *)&buf[8] = v100;
                *(_QWORD *)&buf[16] = "MinAllowedFrameQP";
                *(_QWORD *)&buf[24] = v27 + 92;
                v115 = 0;
                v116 = 3;
                v117 = 0;
                sub_1B6778EB4(v84, (CFTypeRef *)buf, (uint64_t)buf);
                v101 = CFBooleanGetTypeID();
                *(_QWORD *)buf = *MEMORY[0x1E0CECF90];
                *(_QWORD *)&buf[8] = v101;
                *(_QWORD *)&buf[16] = "EnableLTR";
                *(_QWORD *)&buf[24] = v27 + 128;
                v115 = 0;
                v116 = 16;
                v117 = 0;
                sub_1B6778EB4(v84, (CFTypeRef *)buf, (uint64_t)buf);
              }
              if (((v110 | v109) & 1) != 0)
              {
                if ((v109 & 1) != 0)
                {
                  CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E0CEDD38], (const void *)*MEMORY[0x1E0C9AE50]);
                  if (!*(_BYTE *)(v27 + 233))
                    goto LABEL_129;
                  v102 = CFSTR("com.apple.videotoolbox.videoencoder.h264.rtvc");
                }
                else if (*(_BYTE *)(v27 + 233))
                {
                  v102 = CFSTR("com.apple.videotoolbox.videoencoder.h264.rtvc");
                }
                else
                {
                  v102 = CFSTR("com.apple.videotoolbox.videoencoder.h264.rtvc.sw");
                }
                if (a4 == 1752589105)
                  v103 = CFSTR("com.apple.videotoolbox.videoencoder.hevc.rtvc");
                else
                  v103 = v102;
                v104 = (const void *)*MEMORY[0x1E0CEDCF8];
                if (CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E0CEDCF8]))
                {
                  v105 = (const __CFString *)CFDictionaryGetValue(theDict, v104);
                  if (CFStringCompare(v103, v105, 0))
                  {
                    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                    {
LABEL_123:
                      *(_DWORD *)buf = 136315138;
                      *(_QWORD *)&buf[4] = v27 + 256;
                      v81 = MEMORY[0x1E0C81028];
                      v82 = "%s: encoder id is not supported\n";
                      goto LABEL_124;
                    }
LABEL_125:
                    v56 = 4294954394;
                    goto LABEL_69;
                  }
                }
                if (qword_1EDBB4C38 != -1)
                  dispatch_once(&qword_1EDBB4C38, &unk_1E6A16A60);
                CFDictionarySetValue(theDict, v104, v103);
LABEL_129:
                if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                {
                  v106 = *(_QWORD *)(v27 + 2536);
                  v107 = *(_DWORD *)(v27 + 212);
                  v108 = *(_DWORD *)(v27 + 216);
                  *(_DWORD *)buf = 134218752;
                  *(_QWORD *)&buf[4] = v106;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v107;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v108;
                  *(_WORD *)&buf[24] = 1024;
                  *(_DWORD *)&buf[26] = v109;
                  _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): VCPRateControlSession is created, use_hw: %d\n", buf, 0x1Eu);
                }
                v56 = 0;
                goto LABEL_70;
              }
              if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                goto LABEL_125;
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = v27 + 256;
              v81 = MEMORY[0x1E0C81028];
              v82 = "%s: Low latency RC mode requires hardware encoder\n";
LABEL_124:
              _os_log_error_impl(&dword_1B676B000, v81, OS_LOG_TYPE_ERROR, v82, buf, 0xCu);
              goto LABEL_125;
            }
            *(_QWORD *)(v27 + 2544) = 0;
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = v27 + 256;
              v74 = MEMORY[0x1E0C81028];
              v75 = "%s: failed to register supported keys\n";
              v76 = 12;
              goto LABEL_89;
            }
            goto LABEL_52;
          }
          v72 = (const void *)*MEMORY[0x1E0CEDD20];
          if (CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E0CEDD20]))
          {
            v109 = sub_1B67712E0(theDict, v72);
            goto LABEL_99;
          }
          v73 = 1;
        }
        v109 = v73;
        goto LABEL_99;
      }
    }
    else
    {
      *(_QWORD *)(v27 + 2256) = 0;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Failed to create stats monitor\n", buf, 2u);
      }
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Failed to initialize VCPRateControlSession\n", buf, 2u);
    }
    v56 = 4294954392;
    goto LABEL_69;
  }
  v22 = CFBooleanGetValue(v21);
  v110 = v22 != 0;
  if (v22)
    v23 = 1;
  else
    v23 = v19;
  if ((v23 & 1) != 0)
    goto LABEL_15;
LABEL_25:
  pthread_once(&stru_1EDBB4C08, (void (*)(void))sub_1B677D0FC);
  v32 = _CFRuntimeCreateInstance();
  if (v32)
  {
    v33 = (_QWORD *)v32;
    v34 = (char *)operator new(0x9F8uLL, MEMORY[0x1E0DE4E10]);
    if (v34)
    {
      v35 = (uint64_t)v34;
      v36 = v34 + 2304;
      bzero(v34, 0x9F8uLL);
      *(_QWORD *)(v35 + 2304) = 850045863;
      *(_OWORD *)(v36 + 8) = 0u;
      *(_OWORD *)(v36 + 24) = 0u;
      *(_OWORD *)(v36 + 40) = 0u;
      *(_QWORD *)(v35 + 2360) = 0;
      std::__shared_mutex_base::__shared_mutex_base((std::__shared_mutex_base *)(v35 + 2368));
      *(_QWORD *)(v35 + 2536) = 0;
      v33[2] = v35;
      *(_BYTE *)(v35 + 244) = 0;
      *(_QWORD *)(v35 + 2536) = mach_absolute_time();
      *(_DWORD *)(v35 + 208) = a4;
      *(_DWORD *)(v35 + 212) = a2;
      *(_DWORD *)(v35 + 216) = a3;
      *(_BYTE *)(v35 + 232) = 0;
      *(_QWORD *)(v35 + 184) = 0;
      *(_QWORD *)(v35 + 224) = 0;
      snprintf((char *)(v35 + 256), 0x7D0uLL, "VCPRateControlSession(NonLowLatency) %p (%dx%d)", v33, a2, a3);
      v37 = (float *)operator new(0x28uLL, MEMORY[0x1E0DE4E10]);
      if (v37)
      {
        v38 = v37;
        *(_OWORD *)v37 = 0u;
        *((_OWORD *)v37 + 1) = 0u;
        v37[8] = 1.0;
        *(_QWORD *)(v35 + 2544) = v37;
        v39 = CFNumberGetTypeID();
        *(_QWORD *)buf = *MEMORY[0x1E0CECEF0];
        *(_QWORD *)&buf[8] = v39;
        *(_QWORD *)&buf[16] = "AverageBitRate";
        *(_QWORD *)&buf[24] = v35 + 76;
        v115 = 0;
        v116 = 3;
        v117 = 0;
        sub_1B6778EB4(v38, (CFTypeRef *)buf, (uint64_t)buf);
        v40 = CFNumberGetTypeID();
        *(_QWORD *)buf = *MEMORY[0x1E0CECF78];
        *(_QWORD *)&buf[8] = v40;
        *(_QWORD *)&buf[16] = "DataRateLimits";
        *(_QWORD *)&buf[24] = v35 + 136;
        v115 = 0;
        v116 = 16;
        v117 = 0;
        sub_1B6778EB4(v38, (CFTypeRef *)buf, (uint64_t)buf);
        v41 = CFNumberGetTypeID();
        *(_QWORD *)buf = *MEMORY[0x1E0CECF58];
        *(_QWORD *)&buf[8] = v41;
        *(_QWORD *)&buf[16] = "ConstantBitRate";
        *(_QWORD *)&buf[24] = v35 + 144;
        v115 = 0;
        v116 = 3;
        v117 = 0;
        sub_1B6778EB4(v38, (CFTypeRef *)buf, (uint64_t)buf);
        v42 = CFNumberGetTypeID();
        *(_QWORD *)buf = *MEMORY[0x1E0CECFD0];
        *(_QWORD *)&buf[8] = v42;
        *(_QWORD *)&buf[16] = "ExpectedFrameRate";
        *(_QWORD *)&buf[24] = v35 + 40;
        v115 = 0;
        v116 = 13;
        v117 = 0;
        sub_1B6778EB4(v38, (CFTypeRef *)buf, (uint64_t)buf);
        v43 = CFStringGetTypeID();
        *(_QWORD *)buf = *MEMORY[0x1E0CED180];
        *(_QWORD *)&buf[8] = v43;
        *(_QWORD *)&buf[16] = "ProfileLevel";
        *(_QWORD *)&buf[24] = v35;
        v115 = 0;
        v116 = 16;
        v117 = 0;
        sub_1B6778EB4(v38, (CFTypeRef *)buf, (uint64_t)buf);
        v44 = CFBooleanGetTypeID();
        *(_QWORD *)buf = *MEMORY[0x1E0CECEC8];
        *(_QWORD *)&buf[8] = v44;
        *(_QWORD *)&buf[16] = "AllowTemporalCompression";
        *(_QWORD *)&buf[24] = v35 + 64;
        v115 = 0;
        v116 = 16;
        v117 = 0;
        sub_1B6778EB4(v38, (CFTypeRef *)buf, (uint64_t)buf);
        v45 = CFBooleanGetTypeID();
        *(_QWORD *)buf = *MEMORY[0x1E0CECEB0];
        *(_QWORD *)&buf[8] = v45;
        *(_QWORD *)&buf[16] = "AllowFrameReordering";
        *(_QWORD *)&buf[24] = v35 + 65;
        v115 = 0;
        v116 = 16;
        v117 = 0;
        sub_1B6778EB4(v38, (CFTypeRef *)buf, (uint64_t)buf);
        v46 = CFNumberGetTypeID();
        *(_QWORD *)buf = *MEMORY[0x1E0CED1A8];
        *(_QWORD *)&buf[8] = v46;
        *(_QWORD *)&buf[16] = "ReferenceBufferCount";
        *(_QWORD *)&buf[24] = v35 + 100;
        v115 = 0;
        v116 = 3;
        v117 = 0;
        sub_1B6778EB4(v38, (CFTypeRef *)buf, (uint64_t)buf);
        v47 = CFNumberGetTypeID();
        *(_QWORD *)buf = *MEMORY[0x1E0CED0A8];
        *(_QWORD *)&buf[8] = v47;
        *(_QWORD *)&buf[16] = "ReferenceBufferCount";
        *(_QWORD *)&buf[24] = v35 + 68;
        v115 = 0;
        v116 = 3;
        v117 = 0;
        sub_1B6778EB4(v38, (CFTypeRef *)buf, (uint64_t)buf);
        v48 = CFNumberGetTypeID();
        *(_QWORD *)buf = *MEMORY[0x1E0CED0B0];
        *(_QWORD *)&buf[8] = v48;
        *(_QWORD *)&buf[16] = "MaxKeyFrameIntervalDuration";
        *(_QWORD *)&buf[24] = v35 + 72;
        v115 = 0;
        v116 = 5;
        v117 = 0;
        sub_1B6778EB4(v38, (CFTypeRef *)buf, (uint64_t)buf);
        v49 = CFNumberGetTypeID();
        *(_QWORD *)buf = *MEMORY[0x1E0CED128];
        *(_QWORD *)&buf[8] = v49;
        *(_QWORD *)&buf[16] = "OutputBitDepth";
        *(_QWORD *)&buf[24] = v35 + 148;
        v115 = 0;
        v116 = 3;
        v117 = 0;
        sub_1B6778EB4(v38, (CFTypeRef *)buf, (uint64_t)buf);
        v50 = CFStringGetTypeID();
        *(_QWORD *)buf = *MEMORY[0x1E0CED000];
        *(_QWORD *)&buf[8] = v50;
        *(_QWORD *)&buf[16] = "H264EntropyMode";
        *(_QWORD *)&buf[24] = v35 + 24;
        v115 = 0;
        v116 = 16;
        v117 = 0;
        sub_1B6778EB4(v38, (CFTypeRef *)buf, (uint64_t)buf);
        v51 = CFNumberGetTypeID();
        *(_QWORD *)buf = *MEMORY[0x1E0CED190];
        *(_QWORD *)&buf[8] = v51;
        *(_QWORD *)&buf[16] = "Quality";
        *(_QWORD *)&buf[24] = v35 + 152;
        v115 = 0;
        v116 = 13;
        v117 = 0;
        sub_1B6778EB4(v38, (CFTypeRef *)buf, (uint64_t)buf);
        v52 = CFBooleanGetTypeID();
        *(_QWORD *)buf = *MEMORY[0x1E0CED160];
        *(_QWORD *)&buf[8] = v52;
        *(_QWORD *)&buf[16] = "PreserveAlphaChannel";
        *(_QWORD *)&buf[24] = v35 + 160;
        v115 = 0;
        v116 = 16;
        v117 = 0;
        sub_1B6778EB4(v38, (CFTypeRef *)buf, (uint64_t)buf);
        v53 = CFStringGetTypeID();
        *(_QWORD *)buf = *MEMORY[0x1E0CECED0];
        *(_QWORD *)&buf[8] = v53;
        *(_QWORD *)&buf[16] = "AlphaChannelMode";
        *(_QWORD *)&buf[24] = v35 + 168;
        v115 = 0;
        v116 = 16;
        v117 = 0;
        sub_1B6778EB4(v38, (CFTypeRef *)buf, (uint64_t)buf);
        v54 = CFNumberGetTypeID();
        *(_QWORD *)buf = *MEMORY[0x1E0CED210];
        *(_QWORD *)&buf[8] = v54;
        *(_QWORD *)&buf[16] = "TargetQualityForAlpha";
        *(_QWORD *)&buf[24] = v35 + 176;
        v115 = 0;
        v116 = 13;
        v117 = 0;
        sub_1B6778EB4(v38, (CFTypeRef *)buf, (uint64_t)buf);
        v55 = sub_1B67792C8(v35);
        *(_QWORD *)(v35 + 184) = v55;
        if (v55)
        {
          v56 = 0;
LABEL_50:
          *a11 = v33;
          return v56;
        }
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v35 + 256;
          _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: failed to create supported-key dictionary\n", buf, 0xCu);
        }
        v56 = 1;
      }
      else
      {
        *(_QWORD *)(v35 + 2544) = 0;
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v35 + 256;
          _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: failed to register supported keys\n", buf, 0xCu);
        }
        v56 = 4294967188;
      }
      *(_BYTE *)(v35 + 232) = 1;
      sub_1B6778D98(v35);
      std::condition_variable::~condition_variable((std::condition_variable *)(v35 + 2480));
      std::condition_variable::~condition_variable((std::condition_variable *)(v35 + 2432));
      std::mutex::~mutex((std::mutex *)(v35 + 2368));
      std::mutex::~mutex((std::mutex *)v36);
      MEMORY[0x1BCC9814C](v35, 0x10F0C40EEABCC0CLL);
    }
    else
    {
      v33[2] = 0;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Failed to create private storage\n", buf, 2u);
      }
      v56 = 4294967188;
    }
    CFRelease(v33);
    v33 = 0;
    goto LABEL_50;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Failed to create VCPRateControlSession\n", buf, 2u);
  }
  return 4294954392;
}

void sub_1B676F410(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  __cxa_guard_abort(&qword_1EF1387A0);
  sub_1B6771304((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t Filter8tapV_neon64(uint64_t result, _QWORD *a2, int a3, int16x8_t *a4, unsigned int a5)
{
  int16x8_t v5;
  _OWORD *v6;
  uint8x16_t *v7;
  _OWORD *v8;
  uint8x16_t *v9;
  _OWORD *v10;
  uint8x16_t *v11;
  _OWORD *v12;
  uint8x16_t *v13;
  int16x8_t v14;
  _OWORD *v15;
  uint8x16_t v16;
  uint8x16_t v17;
  int16x8_t v18;
  int16x8_t v19;
  _OWORD *v20;
  uint8x16_t v21;
  uint8x16_t v22;
  int16x8_t v23;
  int16x8_t v24;
  _OWORD *v25;
  uint8x16_t v26;
  uint8x16_t v27;
  int16x8_t v28;
  int16x8_t v29;
  _OWORD *v30;
  uint8x16_t v31;
  uint8x16_t v32;
  BOOL v33;
  uint8x16_t v34;
  uint8x16_t v35;
  int16x8_t v36;
  int16x8_t v37;
  int16x8_t v38;
  int16x8_t v39;
  uint8x16_t v40;
  uint8x16_t v41;
  int16x8_t v42;
  int16x8_t v43;
  int16x8_t v44;
  int16x8_t v45;
  uint8x16_t v46;
  uint8x16_t v47;
  int16x8_t v48;
  int16x8_t v49;
  int16x8_t v50;
  int16x8_t v51;
  uint8x16_t v52;
  uint8x16_t v53;
  int16x8_t v54;
  int16x8_t v55;
  int16x8_t v56;
  int16x8_t v57;
  uint8x16_t v58;
  uint8x16_t v59;
  int16x8_t v60;
  int16x8_t v61;
  int16x8_t v62;
  int16x8_t v63;
  uint8x16_t v64;
  uint8x16_t v65;
  int16x8_t v66;
  int16x8_t v67;
  int16x8_t v68;
  int16x8_t v69;
  uint8x16_t v70;
  uint8x16_t v71;
  int16x8_t v72;
  int16x8_t v73;
  int16x8_t v74;
  int16x8_t v75;
  uint8x16_t v76;
  uint8x16_t v77;

  v5 = *a4;
  v6 = (_OWORD *)*a2;
  v7 = (uint8x16_t *)a2[1];
  v8 = (_OWORD *)a2[2];
  v9 = (uint8x16_t *)a2[3];
  v10 = (_OWORD *)a2[4];
  v11 = (uint8x16_t *)a2[5];
  v12 = (_OWORD *)a2[6];
  v13 = (uint8x16_t *)a2[7];
  v14 = vnegq_s16(vdupq_n_s16(a5));
  if ((a3 & 0x10000) != 0)
  {
    a3 -= 16;
    v16 = *(uint8x16_t *)v6;
    v15 = v6 + 1;
    v17 = *(uint8x16_t *)v15;
    v6 = v15 + 1;
    v18 = vmlaq_lane_s16(vmulq_n_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v16.i8), v5.i16[0]), (int16x8_t)vmovl_u8(*(uint8x8_t *)v17.i8), *(int16x4_t *)v5.i8, 1);
    v19 = vmlaq_lane_s16(vmulq_n_s16((int16x8_t)vmovl_high_u8(v16), v5.i16[0]), (int16x8_t)vmovl_high_u8(v17), *(int16x4_t *)v5.i8, 1);
    v21 = *(uint8x16_t *)v8;
    v20 = v8 + 1;
    v22 = *(uint8x16_t *)v20;
    v8 = v20 + 1;
    v23 = vmlaq_lane_s16(vmlaq_lane_s16(v18, (int16x8_t)vmovl_u8(*(uint8x8_t *)v21.i8), *(int16x4_t *)v5.i8, 2), (int16x8_t)vmovl_u8(*(uint8x8_t *)v22.i8), *(int16x4_t *)v5.i8, 3);
    v24 = vmlaq_lane_s16(vmlaq_lane_s16(v19, (int16x8_t)vmovl_high_u8(v21), *(int16x4_t *)v5.i8, 2), (int16x8_t)vmovl_high_u8(v22), *(int16x4_t *)v5.i8, 3);
    v26 = *(uint8x16_t *)v10;
    v25 = v10 + 1;
    v27 = *(uint8x16_t *)v25;
    v10 = v25 + 1;
    v28 = vmlaq_laneq_s16(vmlaq_laneq_s16(v23, (int16x8_t)vmovl_u8(*(uint8x8_t *)v26.i8), v5, 4), (int16x8_t)vmovl_u8(*(uint8x8_t *)v27.i8), v5, 5);
    v29 = vmlaq_laneq_s16(vmlaq_laneq_s16(v24, (int16x8_t)vmovl_high_u8(v26), v5, 4), (int16x8_t)vmovl_high_u8(v27), v5, 5);
    v31 = *(uint8x16_t *)v12;
    v30 = v12 + 1;
    v32 = *(uint8x16_t *)v30;
    v12 = v30 + 1;
    *(int8x8_t *)result = vqmovun_s16(vrshlq_s16(vmlaq_laneq_s16(vmlaq_laneq_s16(v28, (int16x8_t)vmovl_u8(*(uint8x8_t *)v31.i8), v5, 6), (int16x8_t)vmovl_u8(*(uint8x8_t *)v32.i8), v5, 7), v14));
    *(int8x8_t *)(result + 8) = vqmovun_s16(vrshlq_s16(vmlaq_laneq_s16(vmlaq_laneq_s16(v29, (int16x8_t)vmovl_high_u8(v31), v5, 6), (int16x8_t)vmovl_high_u8(v32), v5, 7), v14));
    result += 16;
  }
  do
  {
    v33 = __OFSUB__(a3, 32);
    a3 -= 32;
    v34 = *(uint8x16_t *)v6;
    v35 = *((uint8x16_t *)v6 + 1);
    v6 += 2;
    v36 = vmulq_n_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v34.i8), v5.i16[0]);
    v37 = vmulq_n_s16((int16x8_t)vmovl_high_u8(v34), v5.i16[0]);
    v38 = vmulq_n_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v35.i8), v5.i16[0]);
    v39 = vmulq_n_s16((int16x8_t)vmovl_high_u8(v35), v5.i16[0]);
    v40 = *v7;
    v41 = v7[1];
    v7 += 2;
    v42 = vmlaq_lane_s16(v36, (int16x8_t)vmovl_u8(*(uint8x8_t *)v40.i8), *(int16x4_t *)v5.i8, 1);
    v43 = vmlaq_lane_s16(v37, (int16x8_t)vmovl_high_u8(v40), *(int16x4_t *)v5.i8, 1);
    v44 = vmlaq_lane_s16(v38, (int16x8_t)vmovl_u8(*(uint8x8_t *)v41.i8), *(int16x4_t *)v5.i8, 1);
    v45 = vmlaq_lane_s16(v39, (int16x8_t)vmovl_high_u8(v41), *(int16x4_t *)v5.i8, 1);
    v46 = *(uint8x16_t *)v8;
    v47 = *((uint8x16_t *)v8 + 1);
    v8 += 2;
    v48 = vmlaq_lane_s16(v42, (int16x8_t)vmovl_u8(*(uint8x8_t *)v46.i8), *(int16x4_t *)v5.i8, 2);
    v49 = vmlaq_lane_s16(v43, (int16x8_t)vmovl_high_u8(v46), *(int16x4_t *)v5.i8, 2);
    v50 = vmlaq_lane_s16(v44, (int16x8_t)vmovl_u8(*(uint8x8_t *)v47.i8), *(int16x4_t *)v5.i8, 2);
    v51 = vmlaq_lane_s16(v45, (int16x8_t)vmovl_high_u8(v47), *(int16x4_t *)v5.i8, 2);
    v52 = *v9;
    v53 = v9[1];
    v9 += 2;
    v54 = vmlaq_lane_s16(v48, (int16x8_t)vmovl_u8(*(uint8x8_t *)v52.i8), *(int16x4_t *)v5.i8, 3);
    v55 = vmlaq_lane_s16(v49, (int16x8_t)vmovl_high_u8(v52), *(int16x4_t *)v5.i8, 3);
    v56 = vmlaq_lane_s16(v50, (int16x8_t)vmovl_u8(*(uint8x8_t *)v53.i8), *(int16x4_t *)v5.i8, 3);
    v57 = vmlaq_lane_s16(v51, (int16x8_t)vmovl_high_u8(v53), *(int16x4_t *)v5.i8, 3);
    v58 = *(uint8x16_t *)v10;
    v59 = *((uint8x16_t *)v10 + 1);
    v10 += 2;
    v60 = vmlaq_laneq_s16(v54, (int16x8_t)vmovl_u8(*(uint8x8_t *)v58.i8), v5, 4);
    v61 = vmlaq_laneq_s16(v55, (int16x8_t)vmovl_high_u8(v58), v5, 4);
    v62 = vmlaq_laneq_s16(v56, (int16x8_t)vmovl_u8(*(uint8x8_t *)v59.i8), v5, 4);
    v63 = vmlaq_laneq_s16(v57, (int16x8_t)vmovl_high_u8(v59), v5, 4);
    v64 = *v11;
    v65 = v11[1];
    v11 += 2;
    v66 = vmlaq_laneq_s16(v60, (int16x8_t)vmovl_u8(*(uint8x8_t *)v64.i8), v5, 5);
    v67 = vmlaq_laneq_s16(v61, (int16x8_t)vmovl_high_u8(v64), v5, 5);
    v68 = vmlaq_laneq_s16(v62, (int16x8_t)vmovl_u8(*(uint8x8_t *)v65.i8), v5, 5);
    v69 = vmlaq_laneq_s16(v63, (int16x8_t)vmovl_high_u8(v65), v5, 5);
    v70 = *(uint8x16_t *)v12;
    v71 = *((uint8x16_t *)v12 + 1);
    v12 += 2;
    v72 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v70.i8);
    v73 = (int16x8_t)vmovl_high_u8(v70);
    v74 = vmlaq_laneq_s16(v68, (int16x8_t)vmovl_u8(*(uint8x8_t *)v71.i8), v5, 6);
    v75 = vmlaq_laneq_s16(v69, (int16x8_t)vmovl_high_u8(v71), v5, 6);
    v76 = *v13;
    v77 = v13[1];
    v13 += 2;
    *(int8x16_t *)result = vqmovun_high_s16(vqmovun_s16(vrshlq_s16(vmlaq_laneq_s16(vmlaq_laneq_s16(v66, v72, v5, 6), (int16x8_t)vmovl_u8(*(uint8x8_t *)v76.i8), v5, 7), v14)), vrshlq_s16(vmlaq_laneq_s16(vmlaq_laneq_s16(v67, v73, v5, 6), (int16x8_t)vmovl_high_u8(v76), v5, 7), v14));
    *(int8x16_t *)(result + 16) = vqmovun_high_s16(vqmovun_s16(vrshlq_s16(vmlaq_laneq_s16(v74, (int16x8_t)vmovl_u8(*(uint8x8_t *)v77.i8), v5, 7), v14)), vrshlq_s16(vmlaq_laneq_s16(v75, (int16x8_t)vmovl_high_u8(v77), v5, 7), v14));
    result += 32;
  }
  while (!((a3 < 0) ^ v33 | (a3 == 0)));
  return result;
}

int8x8_t *Filter8tapH_neon64(int8x8_t *result, uint64_t a2, int a3, uint64_t a4, unsigned __int16 *a5, _BYTE *a6, unsigned int a7)
{
  int16x8_t v7;
  unsigned __int16 *v8;
  unsigned __int16 v9;
  uint8x8_t *v10;
  BOOL v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  uint8x8_t *v20;
  uint8x8_t v21;
  uint8x8_t *v22;
  uint8x8_t v23;
  uint8x8_t *v24;
  uint8x8_t v25;
  uint8x8_t *v26;
  uint8x8_t v27;
  _BYTE *v28;
  int16x8_t v29;
  int16x8_t v30;
  int16x8_t v31;
  int16x8_t v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  unsigned int v38;
  unsigned int v39;
  uint8x8_t *v40;
  uint8x8_t v41;
  uint8x8_t *v42;
  uint8x8_t v43;
  uint8x8_t *v44;
  uint8x8_t v45;
  uint8x8_t v46;

  v7 = vnegq_s16(vdupq_n_s16(a7));
  v9 = *a5;
  v8 = a5 + 1;
  v10 = (uint8x8_t *)(a2 - 3 + v9);
  do
  {
    v11 = __OFSUB__(a3, 8);
    a3 -= 8;
    v14 = *v8;
    v12 = v8 + 1;
    v13 = v14;
    v16 = *v12++;
    v15 = v16;
    v18 = *v12++;
    v17 = v18;
    v19 = *v12++;
    v21 = *v10;
    v20 = (uint8x8_t *)((char *)v10 + v13);
    v23 = *v20;
    v22 = (uint8x8_t *)((char *)v20 + v15);
    v25 = *v22;
    v24 = (uint8x8_t *)((char *)v22 + v17);
    v27 = *v24;
    v26 = (uint8x8_t *)((char *)v24 + v19);
    LOBYTE(v19) = *a6;
    v28 = a6 + 1;
    LOBYTE(v13) = v19;
    LOBYTE(v19) = *v28++;
    LOBYTE(v15) = v19;
    LOBYTE(v19) = *v28++;
    LOBYTE(v17) = v19;
    LOBYTE(v19) = *v28++;
    v29 = vmulq_s16((int16x8_t)vmovl_u8(v21), *(int16x8_t *)(a4 + v13));
    v30 = vmulq_s16((int16x8_t)vmovl_u8(v23), *(int16x8_t *)(a4 + v15));
    v31 = vmulq_s16((int16x8_t)vmovl_u8(v25), *(int16x8_t *)(a4 + v17));
    v32 = vmulq_s16((int16x8_t)vmovl_u8(v27), *(int16x8_t *)(a4 + v19));
    v34 = *v12++;
    v33 = v34;
    v36 = *v12++;
    v35 = v36;
    v38 = *v12++;
    v37 = v38;
    v39 = *v12;
    v8 = v12 + 1;
    v41 = *v26;
    v40 = (uint8x8_t *)((char *)v26 + v33);
    v43 = *v40;
    v42 = (uint8x8_t *)((char *)v40 + v35);
    v45 = *v42;
    v44 = (uint8x8_t *)((char *)v42 + v37);
    v46 = *v44;
    v10 = (uint8x8_t *)((char *)v44 + v39);
    LOBYTE(v39) = *v28++;
    LOBYTE(v33) = v39;
    LOBYTE(v39) = *v28++;
    LOBYTE(v35) = v39;
    LOBYTE(v39) = *v28++;
    LOBYTE(v37) = v39;
    LOBYTE(v39) = *v28;
    a6 = v28 + 1;
    *result++ = vqmovun_s16(vrshlq_s16(vpaddq_s16(vpaddq_s16(vpaddq_s16(v29, v30), vpaddq_s16(v31, v32)), vpaddq_s16(vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(v41), *(int16x8_t *)(a4 + v33)), vmulq_s16((int16x8_t)vmovl_u8(v43), *(int16x8_t *)(a4 + v35))), vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(v45), *(int16x8_t *)(a4 + v37)), vmulq_s16((int16x8_t)vmovl_u8(v46), *(int16x8_t *)(a4 + v39))))), v7));
  }
  while (!((a3 < 0) ^ v11 | (a3 == 0)));
  return result;
}

int8x8_t *Filter8tapH_chroma_neon64(int8x8_t *result, uint64_t a2, int a3, uint64_t a4, unsigned __int16 *a5, _BYTE *a6, unsigned int a7)
{
  int16x8_t v7;
  unsigned __int16 *v8;
  unsigned __int16 v9;
  const char *v10;
  BOOL v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  const char *v21;
  const char *v22;
  const char *v23;
  _BYTE *v24;
  int8x8x2_t v25;
  int8x8x2_t v26;
  int8x8x2_t v27;
  int8x8x2_t v28;

  v7 = vnegq_s16(vdupq_n_s16(a7));
  v9 = *a5;
  v8 = a5 + 1;
  v10 = (const char *)(a2 - 6 + v9);
  do
  {
    v11 = __OFSUB__(a3, 8);
    a3 -= 8;
    v14 = *v8;
    v12 = v8 + 1;
    v13 = v14;
    v16 = *v12++;
    v15 = v16;
    v18 = *v12++;
    v17 = v18;
    v20 = *v12;
    v8 = v12 + 1;
    v19 = v20;
    v25 = vld2_s8(v10);
    v21 = &v10[v13];
    v26 = vld2_s8(v21);
    v22 = &v21[v15];
    v27 = vld2_s8(v22);
    v23 = &v22[v17];
    v28 = vld2_s8(v23);
    v10 = &v23[v19];
    LOBYTE(v20) = *a6;
    v24 = a6 + 1;
    LOBYTE(v13) = v20;
    LOBYTE(v20) = *v24++;
    LOBYTE(v15) = v20;
    LOBYTE(v20) = *v24++;
    LOBYTE(v17) = v20;
    LOBYTE(v20) = *v24;
    a6 = v24 + 1;
    *result++ = vqmovun_s16(vrshlq_s16(vpaddq_s16(vpaddq_s16(vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8((uint8x8_t)v25.val[0]), *(int16x8_t *)(a4 + v13)), vmulq_s16((int16x8_t)vmovl_u8((uint8x8_t)v25.val[1]), *(int16x8_t *)(a4 + v13))), vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8((uint8x8_t)v26.val[0]), *(int16x8_t *)(a4 + v15)), vmulq_s16((int16x8_t)vmovl_u8((uint8x8_t)v26.val[1]), *(int16x8_t *)(a4 + v15)))), vpaddq_s16(vpaddq_s16(
                          vmulq_s16((int16x8_t)vmovl_u8((uint8x8_t)v27.val[0]), *(int16x8_t *)(a4 + v17)), vmulq_s16((int16x8_t)vmovl_u8((uint8x8_t)v27.val[1]), *(int16x8_t *)(a4 + v17))), vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8((uint8x8_t)v28.val[0]), *(int16x8_t *)(a4 + v20)), vmulq_s16((int16x8_t)vmovl_u8((uint8x8_t)v28.val[1]), *(int16x8_t *)(a4 + v20))))), v7));
  }
  while (!((a3 < 0) ^ v11 | (a3 == 0)));
  return result;
}

uint16x8_t *BilinearFilterV_swift_neon(uint16x8_t *result, uint8x16_t *a2, uint8x16_t *a3, int a4, unsigned int a5)
{
  int8x16_t v5;
  int8x16_t v6;
  uint8x16_t v7;
  int v8;
  signed int v9;
  BOOL v10;
  uint8x16_t *v11;
  uint8x16_t v12;
  uint8x16_t v13;
  uint8x16_t *v14;
  uint8x16_t v15;
  uint8x16_t v16;
  uint8x16_t v17;
  uint8x16_t v18;
  uint8x16_t v19;
  uint8x16_t v20;
  uint16x8_t *v21;
  uint8x16_t v22;
  uint8x16_t v23;

  v5 = vdupq_n_s8(a5);
  v6.i64[0] = 0x1010101010101010;
  v6.i64[1] = 0x1010101010101010;
  v7 = (uint8x16_t)vsubq_s8(v6, v5);
  v8 = a4 & 0x3F;
  v9 = a4 & 0xFFFFFFC0;
  if (!v9)
    goto LABEL_6;
  do
  {
    v10 = __OFSUB__(v9, 64);
    v9 -= 64;
    v12 = *a2;
    v13 = a2[1];
    v11 = a2 + 2;
    v15 = *a3;
    v16 = a3[1];
    v14 = a3 + 2;
    v17 = *v11;
    v18 = v11[1];
    a2 = v11 + 2;
    v19 = *v14;
    v20 = v14[1];
    a3 = v14 + 2;
    *result = vmlal_u8(vmull_u8(*(uint8x8_t *)v12.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v15.i8, *(uint8x8_t *)v5.i8);
    result[1] = vmlal_high_u8(vmull_high_u8(v12, v7), v15, (uint8x16_t)v5);
    v21 = result + 2;
    *v21 = vmlal_u8(vmull_u8(*(uint8x8_t *)v13.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v16.i8, *(uint8x8_t *)v5.i8);
    v21[1] = vmlal_high_u8(vmull_high_u8(v13, v7), v16, (uint8x16_t)v5);
    v21 += 2;
    *v21 = vmlal_u8(vmull_u8(*(uint8x8_t *)v17.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v19.i8, *(uint8x8_t *)v5.i8);
    v21[1] = vmlal_high_u8(vmull_high_u8(v17, v7), v19, (uint8x16_t)v5);
    v21 += 2;
    *v21 = vmlal_u8(vmull_u8(*(uint8x8_t *)v18.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v20.i8, *(uint8x8_t *)v5.i8);
    v21[1] = vmlal_high_u8(vmull_high_u8(v18, v7), v20, (uint8x16_t)v5);
    result = v21 + 2;
  }
  while (!((v9 < 0) ^ v10 | (v9 == 0)));
  if (v8)
  {
LABEL_6:
    do
    {
      v10 = __OFSUB__(v8, 16);
      v8 -= 16;
      v22 = *a2++;
      v23 = *a3++;
      *result = vmlal_u8(vmull_u8(*(uint8x8_t *)v22.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v23.i8, *(uint8x8_t *)v5.i8);
      result[1] = vmlal_high_u8(vmull_high_u8(v22, v7), v23, (uint8x16_t)v5);
      result += 2;
    }
    while (!((v8 < 0) ^ v10 | (v8 == 0)));
  }
  return result;
}

int8x16_t *BilinearFilterH_swift_neon(int8x16_t *result, uint64_t a2, int a3, unsigned int a4, int8x16_t *a5, uint64_t a6)
{
  int8x16_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  int8x16_t v12;
  int8x16_t v13;
  uint8x16_t v14;
  uint8x16_t v15;
  const float *v16;
  __int32 *v17;
  __int32 *v18;
  __int32 *v19;
  unint64_t v20;
  int16x8_t v21;
  const float *v22;
  __int32 *v23;
  __int32 *v24;
  __int32 *v25;
  unint64_t v26;
  int16x8_t v27;
  const float *v28;
  __int32 *v29;
  __int32 *v30;
  __int32 *v31;
  unint64_t v32;
  int16x8_t v33;
  const float *v34;
  __int32 *v35;
  __int32 *v36;
  __int32 *v37;
  int16x8_t v38;

  v6.i64[0] = 0x1010101010101010;
  v6.i64[1] = 0x1010101010101010;
  v7 = 0;
  v8 = 2 * a4;
  v9 = 3 * a4;
  v10 = 4 * a4;
  do
  {
    v11 = __OFSUB__(a3, 16);
    a3 -= 16;
    v12 = *a5++;
    v13 = vsubq_s8(v6, v12);
    v14 = (uint8x16_t)vzip1q_s8(v13, v12);
    v15 = (uint8x16_t)vzip2q_s8(v13, v12);
    v16 = (const float *)(((v7 >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v17 = (__int32 *)((((v7 + a4) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v18 = (__int32 *)((((v7 + v8) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v19 = (__int32 *)((((v7 + v9) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v20 = v7 + v10;
    v21.i32[0] = vld1q_dup_f32(v16).u32[0];
    v21.i32[1] = *v17;
    v21.i32[2] = *v18;
    v21.i32[3] = *v19;
    v22 = (const float *)(((v20 >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v23 = (__int32 *)((((v20 + a4) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v24 = (__int32 *)((((v20 + v8) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v25 = (__int32 *)((((v20 + v9) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v26 = v20 + v10;
    v27.i32[0] = vld1q_dup_f32(v22).u32[0];
    v27.i32[1] = *v23;
    v27.i32[2] = *v24;
    v27.i32[3] = *v25;
    v28 = (const float *)(((v26 >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v29 = (__int32 *)((((v26 + a4) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v30 = (__int32 *)((((v26 + v8) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v31 = (__int32 *)((((v26 + v9) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v32 = v26 + v10;
    v33.i32[0] = vld1q_dup_f32(v28).u32[0];
    v33.i32[1] = *v29;
    v33.i32[2] = *v30;
    v33.i32[3] = *v31;
    v34 = (const float *)(((v32 >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v35 = (__int32 *)((((v32 + a4) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v36 = (__int32 *)((((v32 + v8) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v37 = (__int32 *)((((v32 + v9) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v7 = v32 + v10;
    v38.i32[0] = vld1q_dup_f32(v34).u32[0];
    v38.i32[1] = *v35;
    v38.i32[2] = *v36;
    v38.i32[3] = *v37;
    *result = vrshrn_high_n_s16(vrshrn_n_s16(vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v14.i8), v21), vmulq_s16((int16x8_t)vmovl_high_u8(v14), v27)), 8uLL), vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v15.i8), v33), vmulq_s16((int16x8_t)vmovl_high_u8(v15), v38)), 8uLL);
    result = (int8x16_t *)((char *)result + a6);
  }
  while (!((a3 < 0) ^ v11 | (a3 == 0)));
  return result;
}

int8x16_t *BilinearFilterH_swift_chroma_neon(int8x16_t *result, uint64_t a2, int a3, unsigned int a4, int8x16_t *a5, uint64_t a6)
{
  int8x16_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  BOOL v12;
  const float *v13;
  __int32 *v14;
  __int32 *v15;
  __int32 *v16;
  unint64_t v17;
  const float *v18;
  __int32 *v19;
  __int32 *v20;
  __int32 *v21;
  unint64_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  uint8x16_t v26;
  uint8x16_t v27;
  const float *v28;
  __int32 *v29;
  __int32 *v30;
  __int32 *v31;
  unint64_t v32;
  const float *v33;
  __int32 *v34;
  __int32 *v35;
  __int32 *v36;
  int8x16_t *v37;
  const float *v38;
  __int32 *v39;
  __int32 *v40;
  __int32 *v41;
  unint64_t v42;
  const float *v43;
  __int32 *v44;
  __int32 *v45;
  __int32 *v46;
  int8x16_t v47;
  uint8x16_t v48;
  float32x4x2_t v49;
  float32x4x2_t v50;
  float32x4x2_t v51;
  float32x4x2_t v52;
  float32x4x2_t v53;
  float32x4x2_t v54;

  v6.i64[0] = 0x1010101010101010;
  v6.i64[1] = 0x1010101010101010;
  v7 = 0;
  v8 = 2 * a4;
  v9 = 3 * a4;
  v10 = 4 * a4;
  v11 = a3 - 8;
  if (!v11)
    goto LABEL_5;
  do
  {
    v12 = __OFSUB__(v11, 16);
    v11 -= 16;
    v13 = (const float *)(((v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v14 = (__int32 *)((((v7 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v15 = (__int32 *)((((v7 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v16 = (__int32 *)((((v7 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v17 = v7 + v10;
    v49 = vld2q_dup_f32(v13);
    v49.val[0].i32[1] = *v14;
    v49.val[1].i32[1] = v14[1];
    v49.val[0].i32[2] = *v15;
    v49.val[1].i32[2] = v15[1];
    v49.val[0].i32[3] = *v16;
    v49.val[1].i32[3] = v16[1];
    v18 = (const float *)(((v17 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v19 = (__int32 *)((((v17 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v20 = (__int32 *)((((v17 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v21 = (__int32 *)((((v17 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v22 = v17 + v10;
    v51 = vld2q_dup_f32(v18);
    v51.val[0].i32[1] = *v19;
    v51.val[1].i32[1] = v19[1];
    v51.val[0].i32[2] = *v20;
    v51.val[1].i32[2] = v20[1];
    v51.val[0].i32[3] = *v21;
    v51.val[1].i32[3] = v21[1];
    v23 = *a5++;
    v24 = vzip1q_s8(v23, v23);
    v25 = vzip2q_s8(v23, v23);
    v26 = (uint8x16_t)vsubq_s8(v6, v24);
    v27 = (uint8x16_t)vsubq_s8(v6, v25);
    v28 = (const float *)(((v22 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v29 = (__int32 *)((((v22 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v30 = (__int32 *)((((v22 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v31 = (__int32 *)((((v22 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v32 = v22 + v10;
    v53 = vld2q_dup_f32(v28);
    v53.val[0].i32[1] = *v29;
    v53.val[1].i32[1] = v29[1];
    v53.val[0].i32[2] = *v30;
    v53.val[1].i32[2] = v30[1];
    v53.val[0].i32[3] = *v31;
    v53.val[1].i32[3] = v31[1];
    v33 = (const float *)(((v32 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v34 = (__int32 *)((((v32 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v35 = (__int32 *)((((v32 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v36 = (__int32 *)((((v32 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v7 = v32 + v10;
    v54 = vld2q_dup_f32(v33);
    v54.val[0].i32[1] = *v34;
    v54.val[1].i32[1] = v34[1];
    v54.val[0].i32[2] = *v35;
    v54.val[1].i32[2] = v35[1];
    v54.val[0].i32[3] = *v36;
    v54.val[1].i32[3] = v36[1];
    *result = vraddhn_high_s16(vraddhn_s16(vmulq_s16((int16x8_t)v49.val[0], (int16x8_t)vmovl_u8(*(uint8x8_t *)v26.i8)), vmulq_s16((int16x8_t)v49.val[1], (int16x8_t)vmovl_u8(*(uint8x8_t *)v24.i8))), vmulq_s16((int16x8_t)v51.val[0], (int16x8_t)vmovl_high_u8(v26)), vmulq_s16((int16x8_t)v51.val[1], (int16x8_t)vmovl_high_u8((uint8x16_t)v24)));
    v37 = (int8x16_t *)((char *)result + a6);
    *v37 = vraddhn_high_s16(vraddhn_s16(vmulq_s16((int16x8_t)v53.val[0], (int16x8_t)vmovl_u8(*(uint8x8_t *)v27.i8)), vmulq_s16((int16x8_t)v53.val[1], (int16x8_t)vmovl_u8(*(uint8x8_t *)v25.i8))), vmulq_s16((int16x8_t)v54.val[0], (int16x8_t)vmovl_high_u8(v27)), vmulq_s16((int16x8_t)v54.val[1], (int16x8_t)vmovl_high_u8((uint8x16_t)v25)));
    result = (int8x16_t *)((char *)v37 + a6);
  }
  while (!((v11 < 0) ^ v12 | (v11 == 0)));
  if (v11 < 0 == v12)
  {
LABEL_5:
    v38 = (const float *)(((v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v39 = (__int32 *)((((v7 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v40 = (__int32 *)((((v7 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v41 = (__int32 *)((((v7 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v42 = v7 + v10;
    v50 = vld2q_dup_f32(v38);
    v50.val[0].i32[1] = *v39;
    v50.val[1].i32[1] = v39[1];
    v50.val[0].i32[2] = *v40;
    v50.val[1].i32[2] = v40[1];
    v50.val[0].i32[3] = *v41;
    v50.val[1].i32[3] = v41[1];
    v43 = (const float *)(((v42 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v44 = (__int32 *)((((v42 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v45 = (__int32 *)((((v42 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v46 = (__int32 *)((((v42 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v52 = vld2q_dup_f32(v43);
    v52.val[0].i32[1] = *v44;
    v52.val[1].i32[1] = v44[1];
    v52.val[0].i32[2] = *v45;
    v52.val[1].i32[2] = v45[1];
    v52.val[0].i32[3] = *v46;
    v52.val[1].i32[3] = v46[1];
    v47 = vzip1q_s8(*a5, *a5);
    v48 = (uint8x16_t)vsubq_s8(v6, v47);
    *result = vraddhn_high_s16(vraddhn_s16(vmulq_s16((int16x8_t)v50.val[0], (int16x8_t)vmovl_u8(*(uint8x8_t *)v48.i8)), vmulq_s16((int16x8_t)v50.val[1], (int16x8_t)vmovl_u8(*(uint8x8_t *)v47.i8))), vmulq_s16((int16x8_t)v52.val[0], (int16x8_t)vmovl_high_u8(v48)), vmulq_s16((int16x8_t)v52.val[1], (int16x8_t)vmovl_high_u8((uint8x16_t)v47)));
    return (int8x16_t *)((char *)result + a6);
  }
  return result;
}

int8x16_t *BilinearFilterH_vperm2_neon64(int8x16_t *result, uint64_t a2, int a3, unsigned int *a4, int8x16_t *a5, int8x16_t *a6, uint64_t a7)
{
  int8x16_t v7;
  BOOL v8;
  int8x16_t v9;
  int8x16_t v10;
  uint8x16_t v11;
  uint8x16_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;

  v7.i64[0] = 0x1010101010101010;
  v7.i64[1] = 0x1010101010101010;
  do
  {
    v8 = __OFSUB__(a3, 16);
    a3 -= 16;
    v9 = *a5++;
    v10 = vsubq_s8(v7, v9);
    v11 = (uint8x16_t)vzip1q_s8(v10, v9);
    v12 = (uint8x16_t)vzip2q_s8(v10, v9);
    v13 = a4[2];
    v14 = a4[3];
    v15 = *a4;
    v16 = a4[1];
    a4 += 4;
    v17 = a6[3];
    v18 = a6[2];
    v19 = a6[1];
    v20 = *a6;
    a6 += 4;
    *result = vrshrn_high_n_s16(vrshrn_n_s16(vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v11.i8), (int16x8_t)vqtbl1q_s8(*(int8x16_t *)(a2 + v15), v20)), vmulq_s16((int16x8_t)vmovl_high_u8(v11), (int16x8_t)vqtbl1q_s8(*(int8x16_t *)(a2 + v16), v19))), 8uLL), vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v12.i8), (int16x8_t)vqtbl1q_s8(*(int8x16_t *)(a2 + v13), v18)), vmulq_s16((int16x8_t)vmovl_high_u8(v12), (int16x8_t)vqtbl1q_s8(*(int8x16_t *)(a2 + v14), v17))), 8uLL);
    result = (int8x16_t *)((char *)result + a7);
  }
  while (!((a3 < 0) ^ v8 | (a3 == 0)));
  return result;
}

int8x16_t *BilinearFilterH_chroma_vperm2_neon64(int8x16_t *result, uint64_t a2, int a3, unsigned int *a4, int8x16_t *a5, int8x16_t *a6, uint64_t a7)
{
  int8x16_t v7;
  uint64_t v8;
  BOOL v9;
  int8x16_t v10;
  uint8x16_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  uint64_t v16;
  uint64_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16x2_t v22;
  int8x16x2_t v23;

  v7.i64[0] = 0x1010101010101010;
  v7.i64[1] = 0x1010101010101010;
  v8 = a2 + 16;
  do
  {
    v9 = __OFSUB__(a3, 8);
    a3 -= 8;
    v10 = *a5++;
    v11 = (uint8x16_t)vsubq_s8(v7, v10);
    v12 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v11.i8);
    v13 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v10.i8);
    v14 = (int16x8_t)vmovl_high_u8(v11);
    v15 = (int16x8_t)vmovl_high_u8((uint8x16_t)v10);
    v16 = *a4;
    v17 = a4[1];
    a4 += 2;
    v18 = a6[3];
    v19 = a6[2];
    v20 = a6[1];
    v21 = *a6;
    a6 += 4;
    v22.val[0] = *(int8x16_t *)(a2 + v16);
    v22.val[1] = *(int8x16_t *)(v8 + v16);
    v23.val[0] = *(int8x16_t *)(a2 + v17);
    v23.val[1] = *(int8x16_t *)(v8 + v17);
    *result = vraddhn_high_s16(vraddhn_s16(vmulq_s16((int16x8_t)vqtbl2q_s8(v22, v21), v12), vmulq_s16((int16x8_t)vqtbl2q_s8(v22, v20), v13)), vmulq_s16((int16x8_t)vqtbl2q_s8(v23, v19), v14), vmulq_s16((int16x8_t)vqtbl2q_s8(v23, v18), v15));
    result = (int8x16_t *)((char *)result + a7);
  }
  while (!((a3 < 0) ^ v9 | (a3 == 0)));
  return result;
}

_OWORD *DetileRow_neon(_OWORD *result, __int128 *a2, int a3, uint64_t a4)
{
  BOOL v4;
  __int128 v5;

  do
  {
    v4 = __OFSUB__(a3, 16);
    a3 -= 16;
    v5 = *a2;
    a2 = (__int128 *)((char *)a2 + a4);
    *result++ = v5;
  }
  while (!((a3 < 0) ^ v4 | (a3 == 0)));
  return result;
}

_OWORD *Detile2Rows_neon(_OWORD *result, _OWORD *a2, __int128 *a3, int a4, uint64_t a5)
{
  BOOL v5;
  __int128 v6;
  __int128 v7;

  do
  {
    v5 = __OFSUB__(a4, 16);
    a4 -= 16;
    v6 = *a3;
    v7 = a3[1];
    a3 = (__int128 *)((char *)a3 + a5);
    *result++ = v6;
    *a2++ = v7;
  }
  while (!((a4 < 0) ^ v5 | (a4 == 0)));
  return result;
}

uint16x8_t *BilinearFilterV_swift_neon_h264(uint16x8_t *result, uint8x16_t *a2, uint8x16_t *a3, int a4, unsigned int a5)
{
  int8x16_t v5;
  int8x16_t v6;
  uint8x16_t v7;
  int v8;
  signed int v9;
  BOOL v10;
  uint8x16_t *v11;
  uint8x16_t v12;
  uint8x16_t v13;
  uint8x16_t *v14;
  uint8x16_t v15;
  uint8x16_t v16;
  uint8x16_t v17;
  uint8x16_t v18;
  uint8x16_t v19;
  uint8x16_t v20;
  uint16x8_t *v21;
  uint8x16_t v22;
  uint8x16_t v23;

  v5 = vdupq_n_s8(a5);
  v6.i64[0] = 0x1010101010101010;
  v6.i64[1] = 0x1010101010101010;
  v7 = (uint8x16_t)vsubq_s8(v6, v5);
  v8 = a4 & 0x3F;
  v9 = a4 & 0xFFFFFFC0;
  if (!v9)
    goto LABEL_6;
  do
  {
    v10 = __OFSUB__(v9, 64);
    v9 -= 64;
    v12 = *a2;
    v13 = a2[1];
    v11 = a2 + 2;
    v15 = *a3;
    v16 = a3[1];
    v14 = a3 + 2;
    v17 = *v11;
    v18 = v11[1];
    a2 = v11 + 2;
    v19 = *v14;
    v20 = v14[1];
    a3 = v14 + 2;
    *result = vmlal_u8(vmull_u8(*(uint8x8_t *)v12.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v15.i8, *(uint8x8_t *)v5.i8);
    result[1] = vmlal_high_u8(vmull_high_u8(v12, v7), v15, (uint8x16_t)v5);
    v21 = result + 2;
    *v21 = vmlal_u8(vmull_u8(*(uint8x8_t *)v13.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v16.i8, *(uint8x8_t *)v5.i8);
    v21[1] = vmlal_high_u8(vmull_high_u8(v13, v7), v16, (uint8x16_t)v5);
    v21 += 2;
    *v21 = vmlal_u8(vmull_u8(*(uint8x8_t *)v17.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v19.i8, *(uint8x8_t *)v5.i8);
    v21[1] = vmlal_high_u8(vmull_high_u8(v17, v7), v19, (uint8x16_t)v5);
    v21 += 2;
    *v21 = vmlal_u8(vmull_u8(*(uint8x8_t *)v18.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v20.i8, *(uint8x8_t *)v5.i8);
    v21[1] = vmlal_high_u8(vmull_high_u8(v18, v7), v20, (uint8x16_t)v5);
    result = v21 + 2;
  }
  while (!((v9 < 0) ^ v10 | (v9 == 0)));
  if (v8)
  {
LABEL_6:
    do
    {
      v10 = __OFSUB__(v8, 16);
      v8 -= 16;
      v22 = *a2++;
      v23 = *a3++;
      *result = vmlal_u8(vmull_u8(*(uint8x8_t *)v22.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v23.i8, *(uint8x8_t *)v5.i8);
      result[1] = vmlal_high_u8(vmull_high_u8(v22, v7), v23, (uint8x16_t)v5);
      result += 2;
    }
    while (!((v8 < 0) ^ v10 | (v8 == 0)));
  }
  return result;
}

int8x16_t *BilinearFilterH_swift_neon_h264(int8x16_t *result, uint64_t a2, int a3, unsigned int a4, int8x16_t *a5, uint64_t a6)
{
  int8x16_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  int8x16_t v12;
  int8x16_t v13;
  uint8x16_t v14;
  uint8x16_t v15;
  const float *v16;
  __int32 *v17;
  __int32 *v18;
  __int32 *v19;
  unint64_t v20;
  int16x8_t v21;
  const float *v22;
  __int32 *v23;
  __int32 *v24;
  __int32 *v25;
  unint64_t v26;
  int16x8_t v27;
  const float *v28;
  __int32 *v29;
  __int32 *v30;
  __int32 *v31;
  unint64_t v32;
  int16x8_t v33;
  const float *v34;
  __int32 *v35;
  __int32 *v36;
  __int32 *v37;
  int16x8_t v38;

  v6.i64[0] = 0x1010101010101010;
  v6.i64[1] = 0x1010101010101010;
  v7 = 0;
  v8 = 2 * a4;
  v9 = 3 * a4;
  v10 = 4 * a4;
  do
  {
    v11 = __OFSUB__(a3, 16);
    a3 -= 16;
    v12 = *a5++;
    v13 = vsubq_s8(v6, v12);
    v14 = (uint8x16_t)vzip1q_s8(v13, v12);
    v15 = (uint8x16_t)vzip2q_s8(v13, v12);
    v16 = (const float *)(((v7 >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v17 = (__int32 *)((((v7 + a4) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v18 = (__int32 *)((((v7 + v8) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v19 = (__int32 *)((((v7 + v9) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v20 = v7 + v10;
    v21.i32[0] = vld1q_dup_f32(v16).u32[0];
    v21.i32[1] = *v17;
    v21.i32[2] = *v18;
    v21.i32[3] = *v19;
    v22 = (const float *)(((v20 >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v23 = (__int32 *)((((v20 + a4) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v24 = (__int32 *)((((v20 + v8) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v25 = (__int32 *)((((v20 + v9) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v26 = v20 + v10;
    v27.i32[0] = vld1q_dup_f32(v22).u32[0];
    v27.i32[1] = *v23;
    v27.i32[2] = *v24;
    v27.i32[3] = *v25;
    v28 = (const float *)(((v26 >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v29 = (__int32 *)((((v26 + a4) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v30 = (__int32 *)((((v26 + v8) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v31 = (__int32 *)((((v26 + v9) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v32 = v26 + v10;
    v33.i32[0] = vld1q_dup_f32(v28).u32[0];
    v33.i32[1] = *v29;
    v33.i32[2] = *v30;
    v33.i32[3] = *v31;
    v34 = (const float *)(((v32 >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v35 = (__int32 *)((((v32 + a4) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v36 = (__int32 *)((((v32 + v8) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v37 = (__int32 *)((((v32 + v9) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    v7 = v32 + v10;
    v38.i32[0] = vld1q_dup_f32(v34).u32[0];
    v38.i32[1] = *v35;
    v38.i32[2] = *v36;
    v38.i32[3] = *v37;
    *result = vrshrn_high_n_s16(vrshrn_n_s16(vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v14.i8), v21), vmulq_s16((int16x8_t)vmovl_high_u8(v14), v27)), 8uLL), vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v15.i8), v33), vmulq_s16((int16x8_t)vmovl_high_u8(v15), v38)), 8uLL);
    result = (int8x16_t *)((char *)result + a6);
  }
  while (!((a3 < 0) ^ v11 | (a3 == 0)));
  return result;
}

int8x16_t *BilinearFilterH_swift_chroma_neon_h264(int8x16_t *result, uint64_t a2, int a3, unsigned int a4, int8x16_t *a5, uint64_t a6)
{
  int8x16_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  BOOL v12;
  const float *v13;
  __int32 *v14;
  __int32 *v15;
  __int32 *v16;
  unint64_t v17;
  const float *v18;
  __int32 *v19;
  __int32 *v20;
  __int32 *v21;
  unint64_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  uint8x16_t v26;
  uint8x16_t v27;
  const float *v28;
  __int32 *v29;
  __int32 *v30;
  __int32 *v31;
  unint64_t v32;
  const float *v33;
  __int32 *v34;
  __int32 *v35;
  __int32 *v36;
  int8x16_t *v37;
  const float *v38;
  __int32 *v39;
  __int32 *v40;
  __int32 *v41;
  unint64_t v42;
  const float *v43;
  __int32 *v44;
  __int32 *v45;
  __int32 *v46;
  int8x16_t v47;
  uint8x16_t v48;
  float32x4x2_t v49;
  float32x4x2_t v50;
  float32x4x2_t v51;
  float32x4x2_t v52;
  float32x4x2_t v53;
  float32x4x2_t v54;

  v6.i64[0] = 0x1010101010101010;
  v6.i64[1] = 0x1010101010101010;
  v7 = 0;
  v8 = 2 * a4;
  v9 = 3 * a4;
  v10 = 4 * a4;
  v11 = a3 - 8;
  if (!v11)
    goto LABEL_5;
  do
  {
    v12 = __OFSUB__(v11, 16);
    v11 -= 16;
    v13 = (const float *)(((v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v14 = (__int32 *)((((v7 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v15 = (__int32 *)((((v7 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v16 = (__int32 *)((((v7 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v17 = v7 + v10;
    v49 = vld2q_dup_f32(v13);
    v49.val[0].i32[1] = *v14;
    v49.val[1].i32[1] = v14[1];
    v49.val[0].i32[2] = *v15;
    v49.val[1].i32[2] = v15[1];
    v49.val[0].i32[3] = *v16;
    v49.val[1].i32[3] = v16[1];
    v18 = (const float *)(((v17 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v19 = (__int32 *)((((v17 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v20 = (__int32 *)((((v17 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v21 = (__int32 *)((((v17 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v22 = v17 + v10;
    v51 = vld2q_dup_f32(v18);
    v51.val[0].i32[1] = *v19;
    v51.val[1].i32[1] = v19[1];
    v51.val[0].i32[2] = *v20;
    v51.val[1].i32[2] = v20[1];
    v51.val[0].i32[3] = *v21;
    v51.val[1].i32[3] = v21[1];
    v23 = *a5++;
    v24 = vzip1q_s8(v23, v23);
    v25 = vzip2q_s8(v23, v23);
    v26 = (uint8x16_t)vsubq_s8(v6, v24);
    v27 = (uint8x16_t)vsubq_s8(v6, v25);
    v28 = (const float *)(((v22 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v29 = (__int32 *)((((v22 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v30 = (__int32 *)((((v22 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v31 = (__int32 *)((((v22 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v32 = v22 + v10;
    v53 = vld2q_dup_f32(v28);
    v53.val[0].i32[1] = *v29;
    v53.val[1].i32[1] = v29[1];
    v53.val[0].i32[2] = *v30;
    v53.val[1].i32[2] = v30[1];
    v53.val[0].i32[3] = *v31;
    v53.val[1].i32[3] = v31[1];
    v33 = (const float *)(((v32 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v34 = (__int32 *)((((v32 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v35 = (__int32 *)((((v32 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v36 = (__int32 *)((((v32 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v7 = v32 + v10;
    v54 = vld2q_dup_f32(v33);
    v54.val[0].i32[1] = *v34;
    v54.val[1].i32[1] = v34[1];
    v54.val[0].i32[2] = *v35;
    v54.val[1].i32[2] = v35[1];
    v54.val[0].i32[3] = *v36;
    v54.val[1].i32[3] = v36[1];
    *result = vraddhn_high_s16(vraddhn_s16(vmulq_s16((int16x8_t)v49.val[0], (int16x8_t)vmovl_u8(*(uint8x8_t *)v26.i8)), vmulq_s16((int16x8_t)v49.val[1], (int16x8_t)vmovl_u8(*(uint8x8_t *)v24.i8))), vmulq_s16((int16x8_t)v51.val[0], (int16x8_t)vmovl_high_u8(v26)), vmulq_s16((int16x8_t)v51.val[1], (int16x8_t)vmovl_high_u8((uint8x16_t)v24)));
    v37 = (int8x16_t *)((char *)result + a6);
    *v37 = vraddhn_high_s16(vraddhn_s16(vmulq_s16((int16x8_t)v53.val[0], (int16x8_t)vmovl_u8(*(uint8x8_t *)v27.i8)), vmulq_s16((int16x8_t)v53.val[1], (int16x8_t)vmovl_u8(*(uint8x8_t *)v25.i8))), vmulq_s16((int16x8_t)v54.val[0], (int16x8_t)vmovl_high_u8(v27)), vmulq_s16((int16x8_t)v54.val[1], (int16x8_t)vmovl_high_u8((uint8x16_t)v25)));
    result = (int8x16_t *)((char *)v37 + a6);
  }
  while (!((v11 < 0) ^ v12 | (v11 == 0)));
  if (v11 < 0 == v12)
  {
LABEL_5:
    v38 = (const float *)(((v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v39 = (__int32 *)((((v7 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v40 = (__int32 *)((((v7 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v41 = (__int32 *)((((v7 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v42 = v7 + v10;
    v50 = vld2q_dup_f32(v38);
    v50.val[0].i32[1] = *v39;
    v50.val[1].i32[1] = v39[1];
    v50.val[0].i32[2] = *v40;
    v50.val[1].i32[2] = v40[1];
    v50.val[0].i32[3] = *v41;
    v50.val[1].i32[3] = v41[1];
    v43 = (const float *)(((v42 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v44 = (__int32 *)((((v42 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v45 = (__int32 *)((((v42 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v46 = (__int32 *)((((v42 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    v52 = vld2q_dup_f32(v43);
    v52.val[0].i32[1] = *v44;
    v52.val[1].i32[1] = v44[1];
    v52.val[0].i32[2] = *v45;
    v52.val[1].i32[2] = v45[1];
    v52.val[0].i32[3] = *v46;
    v52.val[1].i32[3] = v46[1];
    v47 = vzip1q_s8(*a5, *a5);
    v48 = (uint8x16_t)vsubq_s8(v6, v47);
    *result = vraddhn_high_s16(vraddhn_s16(vmulq_s16((int16x8_t)v50.val[0], (int16x8_t)vmovl_u8(*(uint8x8_t *)v48.i8)), vmulq_s16((int16x8_t)v50.val[1], (int16x8_t)vmovl_u8(*(uint8x8_t *)v47.i8))), vmulq_s16((int16x8_t)v52.val[0], (int16x8_t)vmovl_high_u8(v48)), vmulq_s16((int16x8_t)v52.val[1], (int16x8_t)vmovl_high_u8((uint8x16_t)v47)));
    return (int8x16_t *)((char *)result + a6);
  }
  return result;
}

int8x8_t *BilinearFilterH_vperm2_neon64_h264(int8x8_t *result, uint64_t a2, int a3, unsigned int *a4, int8x16_t *a5, int8x16_t *a6, uint64_t a7)
{
  int8x16_t v7;
  BOOL v8;
  int8x16_t v9;
  int8x16_t v10;
  uint8x16_t v11;
  uint8x16_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x8_t v21;

  v7.i64[0] = 0x1010101010101010;
  v7.i64[1] = 0x1010101010101010;
  do
  {
    v8 = __OFSUB__(a3, 16);
    a3 -= 16;
    v9 = *a5++;
    v10 = vsubq_s8(v7, v9);
    v11 = (uint8x16_t)vzip1q_s8(v10, v9);
    v12 = (uint8x16_t)vzip2q_s8(v10, v9);
    v13 = a4[2];
    v14 = a4[3];
    v15 = *a4;
    v16 = a4[1];
    a4 += 4;
    v17 = a6[2];
    v18 = a6[3];
    v19 = *a6;
    v20 = a6[1];
    a6 += 4;
    v21 = vrshrn_n_s16(vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v12.i8), (int16x8_t)vqtbl1q_s8(*(int8x16_t *)(a2 + v13), v17)), vmulq_s16((int16x8_t)vmovl_high_u8(v12), (int16x8_t)vqtbl1q_s8(*(int8x16_t *)(a2 + v14), v18))), 8uLL);
    *result = vrshrn_n_s16(vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v11.i8), (int16x8_t)vqtbl1q_s8(*(int8x16_t *)(a2 + v15), v19)), vmulq_s16((int16x8_t)vmovl_high_u8(v11), (int16x8_t)vqtbl1q_s8(*(int8x16_t *)(a2 + v16), v20))), 8uLL);
    result[1] = v21;
    result = (int8x8_t *)((char *)result + a7);
  }
  while (!((a3 < 0) ^ v8 | (a3 == 0)));
  return result;
}

int8x8_t *BilinearFilterH_chroma_vperm2_neon64_h264(int8x8_t *result, uint64_t a2, int a3, unsigned int *a4, int8x16_t *a5, int8x16_t *a6, uint64_t a7)
{
  int8x16_t v7;
  uint64_t v8;
  BOOL v9;
  int8x16_t v10;
  uint8x16_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  uint64_t v16;
  uint64_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16x2_t v22;
  int8x16x2_t v23;

  v7.i64[0] = 0x1010101010101010;
  v7.i64[1] = 0x1010101010101010;
  v8 = a2 + 16;
  do
  {
    v9 = __OFSUB__(a3, 8);
    a3 -= 8;
    v10 = *a5++;
    v11 = (uint8x16_t)vsubq_s8(v7, v10);
    v12 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v11.i8);
    v13 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v10.i8);
    v14 = (int16x8_t)vmovl_high_u8(v11);
    v15 = (int16x8_t)vmovl_high_u8((uint8x16_t)v10);
    v16 = *a4;
    v17 = a4[1];
    a4 += 2;
    v18 = a6[2];
    v19 = a6[3];
    v20 = *a6;
    v21 = a6[1];
    a6 += 4;
    v22.val[0] = *(int8x16_t *)(a2 + v16);
    v22.val[1] = *(int8x16_t *)(v8 + v16);
    v23.val[0] = *(int8x16_t *)(a2 + v17);
    v23.val[1] = *(int8x16_t *)(v8 + v17);
    *result = vraddhn_s16(vmulq_s16((int16x8_t)vqtbl2q_s8(v22, v20), v12), vmulq_s16((int16x8_t)vqtbl2q_s8(v22, v21), v13));
    result[1] = vraddhn_s16(vmulq_s16((int16x8_t)vqtbl2q_s8(v23, v18), v14), vmulq_s16((int16x8_t)vqtbl2q_s8(v23, v19), v15));
    result = (int8x8_t *)((char *)result + a7);
  }
  while (!((a3 < 0) ^ v9 | (a3 == 0)));
  return result;
}

_OWORD *DetileRow_neon_h264(_OWORD *result, __int128 *a2, int a3, uint64_t a4)
{
  BOOL v4;
  __int128 v5;

  do
  {
    v4 = __OFSUB__(a3, 16);
    a3 -= 16;
    v5 = *a2;
    a2 = (__int128 *)((char *)a2 + a4);
    *result++ = v5;
  }
  while (!((a3 < 0) ^ v4 | (a3 == 0)));
  return result;
}

_OWORD *Detile2Rows_neon_h264(_OWORD *result, _OWORD *a2, __int128 *a3, int a4, uint64_t a5)
{
  BOOL v5;
  __int128 v6;
  __int128 v7;

  do
  {
    v5 = __OFSUB__(a4, 16);
    a4 -= 16;
    v6 = *a3;
    v7 = a3[1];
    a3 = (__int128 *)((char *)a3 + a5);
    *result++ = v6;
    *a2++ = v7;
  }
  while (!((a4 < 0) ^ v5 | (a4 == 0)));
  return result;
}

__n128 Detile4Rows_neon_h264(__n128 **a1, __n128 *a2, int a3, uint64_t a4)
{
  __n128 *v4;
  __n128 *v5;
  __n128 *v6;
  __n128 *v7;
  __n128 v8;
  __n128 v9;
  __n128 v10;
  __n128 v11;
  BOOL v12;
  __n128 *v13;
  __n128 result;
  __n128 v15;
  __n128 v16;
  __n128 v17;
  __n128 v18;
  __n128 v19;
  __n128 v20;
  __n128 v21;

  v4 = *a1;
  v5 = a1[1];
  v6 = a1[2];
  v7 = a1[3];
  if ((a3 & 0xF) != 0)
  {
    a3 -= 16;
    v8 = *a2;
    v9 = a2[1];
    v10 = a2[2];
    v11 = a2[3];
    a2 = (__n128 *)((char *)a2 + a4);
    *v4++ = v8;
    *v5++ = v9;
    *v6++ = v10;
    *v7++ = v11;
  }
  do
  {
    v12 = __OFSUB__(a3, 32);
    a3 -= 32;
    result = *a2;
    v15 = a2[1];
    v16 = a2[2];
    v17 = a2[3];
    v13 = (__n128 *)((char *)a2 + a4);
    v18 = *v13;
    v19 = v13[1];
    v20 = v13[2];
    v21 = v13[3];
    a2 = (__n128 *)((char *)v13 + a4);
    *v4 = result;
    v4[1] = v18;
    v4 += 2;
    *v5 = v15;
    v5[1] = v19;
    v5 += 2;
    *v6 = v16;
    v6[1] = v20;
    v6 += 2;
    *v7 = v17;
    v7[1] = v21;
    v7 += 2;
  }
  while (!((a3 < 0) ^ v12 | (a3 == 0)));
  return result;
}

void sub_1B67704C8(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

const void **sub_1B67704D8(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **sub_1B6770508(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **sub_1B6770538(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **sub_1B6770568(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **sub_1B6770598(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **sub_1B67705C8(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **sub_1B67705F8(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t sub_1B6770628(uint64_t a1, int *a2, int a3, int a4, int a5)
{
  int v10;
  int v11;
  _BYTE *v12;
  _BYTE *v13;
  int v14;
  BOOL v16;
  _OWORD *v17;
  _OWORD *v18;
  _OWORD *v19;
  _OWORD *v20;
  uint64_t v21;
  int v22;
  int v23;
  float v24;
  float v25;
  float v26;
  unsigned __int8 v27;
  unsigned __int8 v28;
  int v29;
  uint64_t v30;
  char v31;
  char v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  __int16 *v37;
  uint64_t result;
  const char *v39;
  int v40;
  char *v41;
  unsigned int v42;
  void *v43;
  const CFDictionaryKeyCallBacks *v44;
  const CFDictionaryValueCallBacks *v45;
  __CFDictionary *Mutable;
  CFMutableDictionaryRef v47;
  CFNumberRef v48;
  CFNumberRef v49;
  CFNumberRef v50;
  CFNumberRef v51;
  CFNumberRef v52;
  CFNumberRef v53;
  CFNumberRef v54;
  CFNumberRef v55;
  CFNumberRef v56;
  CFNumberRef v57;
  int v58;
  void *v59;
  char **v60;
  float v61;
  float v62;
  float v63;
  float v64;
  int valuePtr;
  char v66[20];
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  if (qword_1EDBB4CB8 != -1)
    dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
  v10 = dword_1EDBB4CC4;
  v11 = *a2;
  if ((*a2 & 0xC) == 0)
  {
    if (a3 == a4)
    {
      *a2 = v11 | 4;
      if (a3 > 96)
      {
        *(_DWORD *)(a1 + 32) = v11 | 4;
        v12 = (_BYTE *)(a1 + 32);
        *(_BYTE *)(a1 + 124) = v10 > 12;
        v13 = (_BYTE *)(a1 + 124);
        goto LABEL_40;
      }
      v14 = 6;
    }
    else
    {
      v14 = 8;
    }
    v11 |= v14;
    *a2 = v11;
  }
  v16 = a3 > 96 && v10 > 12;
  *(_BYTE *)(a1 + 124) = v16;
  v13 = (_BYTE *)(a1 + 124);
  *(_DWORD *)(a1 + 32) = v11;
  v12 = (_BYTE *)(a1 + 32);
  if ((v11 & 4) == 0)
  {
    if ((v11 & 8) != 0 && sub_1B67EE434())
    {
      if (qword_1EDBB4CB8 != -1)
        dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
      if (dword_1EDBB4CC4 >= 13 && _os_feature_enabled_impl())
      {
        v17 = (_OWORD *)operator new[]();
        v18 = v17 + 78;
        *v17 = xmmword_1B6917330;
        v19 = v17 + 1;
        v20 = v19;
        do
        {
          *(_QWORD *)v20 = 0;
          *((_QWORD *)v20 + 1) = 0;
          *((_QWORD *)v20 + 2) = 0;
          *((_QWORD *)v20 + 68) = 850045863;
          v21 = (uint64_t)v20 + 552;
          *(_OWORD *)((char *)v20 + 552) = 0uLL;
          *(_OWORD *)((char *)v20 + 568) = 0uLL;
          *(_OWORD *)((char *)v20 + 584) = 0uLL;
          v20 = (_OWORD *)((char *)v20 + 616);
          *(_OWORD *)(v21 + 41) = 0uLL;
        }
        while (v20 != v18);
        *(_QWORD *)a1 = v19;
        *(_DWORD *)(a1 + 112) = a3;
        *(_DWORD *)(a1 + 116) = a4;
        if (a3 <= a4)
          v22 = a4;
        else
          v22 = a3;
        if (a3 >= a4)
          v23 = a4;
        else
          v23 = a3;
        v24 = (float)v22 / (float)v23;
        v25 = fabsf(v24 + -1.77);
        v26 = fabsf(v24 + -1.33);
        v27 = atomic_load((unsigned __int8 *)&qword_1EF1386D8);
        if ((v27 & 1) == 0)
        {
          v61 = v26;
          v63 = v25;
          v58 = __cxa_guard_acquire(&qword_1EF1386D8);
          v26 = v61;
          v25 = v63;
          if (v58)
          {
            v59 = &unk_1B6918DD6;
            if (v63 < v61)
              v59 = &unk_1B6918DCA;
            qword_1EF1386D0 = (uint64_t)v59;
            __cxa_guard_release(&qword_1EF1386D8);
            v26 = v61;
            v25 = v63;
          }
        }
        v28 = atomic_load((unsigned __int8 *)&qword_1EF1386E8);
        if ((v28 & 1) == 0)
        {
          v62 = v26;
          v64 = v25;
          if (__cxa_guard_acquire(&qword_1EF1386E8))
          {
            v60 = &off_1EF137C60;
            if (v64 < v62)
              v60 = &off_1EF137C50;
            qword_1EF1386E0 = (uint64_t)v60;
            __cxa_guard_release(&qword_1EF1386E8);
          }
        }
        v29 = *(char *)qword_1EF1386D0;
        if (v29 * *(__int16 *)(qword_1EF1386D0 + 2) == a3 && *(__int16 *)(qword_1EF1386D0 + 4) * v29 == a4)
        {
          v30 = 0;
          v31 = 1;
          while (1)
          {
            v32 = v31;
            sprintf(v66, "%s_%dx%d", "res", *(__int16 *)(qword_1EF1386D0 + 6 * v30 + 2), *(__int16 *)(qword_1EF1386D0 + 6 * v30 + 4));
            v33 = *(_QWORD *)a1 + 616 * v30;
            *(_BYTE *)(v33 + 608) = *(_BYTE *)(a1 + 124);
            if (sub_1B6781770(v33, *(const char **)(qword_1EF1386E0 + 8 * v30), (uint64_t)v66))
              break;
            v31 = 0;
            v30 = 1;
            if ((v32 & 1) == 0)
            {
              *(_DWORD *)(a1 + 120) = 2;
              v34 = *(_DWORD *)(qword_1EF1386D0 + 8);
              qword_1EF1386C0 = *(_QWORD *)qword_1EF1386D0;
              dword_1EF1386C8 = v34;
              goto LABEL_60;
            }
          }
        }
      }
    }
    return 4294954386;
  }
  if (a3 >= 97)
  {
LABEL_40:
    if ((a3 == 480 || a3 == 320) && dword_1EDBB4CC4 > 12 || sub_1B67EE434())
      goto LABEL_44;
    return 4294954386;
  }
LABEL_44:
  v35 = operator new[]();
  *(_OWORD *)v35 = xmmword_1B6917340;
  *(_QWORD *)(v35 + 24) = 0;
  *(_QWORD *)(v35 + 32) = 0;
  *(_QWORD *)(v35 + 560) = 850045863;
  *(_BYTE *)(v35 + 624) = *(_BYTE *)(a1 + 124);
  *(_QWORD *)(v35 + 16) = 0;
  *(_QWORD *)(v35 + 616) = 0;
  *(_OWORD *)(v35 + 568) = 0u;
  *(_OWORD *)(v35 + 584) = 0u;
  *(_OWORD *)(v35 + 600) = 0u;
  *(_QWORD *)a1 = v35 + 16;
  sprintf(v66, "%s_%dx%d", "res", a3, a4);
  v36 = 0;
  v37 = &word_1B6918DB0;
  while (*(v37 - 1) != a3 || *v37 != a4)
  {
    ++v36;
    v37 += 3;
    if (v36 == 4)
    {
      result = 4294954386;
      if (a3 != 1088 || a4 != 1088)
        return result;
      v39 = "cnn_frame_enhancer_544p.espresso.net";
      v36 = 4;
      goto LABEL_52;
    }
  }
  v39 = off_1E6A16120[v36];
  if (a3 < 97)
    goto LABEL_54;
LABEL_52:
  if (!*v13)
    v39 = off_1E6A16148[v36];
LABEL_54:
  if (sub_1B6781770(*(_QWORD *)a1, v39, (uint64_t)v66))
    return 4294954386;
  v40 = 2 * a4;
  if (v36 == 4)
    v40 = a3;
  *(_DWORD *)(a1 + 112) = a3 << (v36 != 4);
  *(_DWORD *)(a1 + 116) = v40;
  *(_DWORD *)(a1 + 120) = 1;
  v41 = (char *)&unk_1B6918DAC + 6 * v36;
  LODWORD(qword_1EF1386C0) = *(_DWORD *)v41;
  WORD2(qword_1EF1386C0) = *((_WORD *)v41 + 2);
LABEL_60:
  if ((*v12 & 2) != 0)
  {
    v42 = time(0);
    srand(v42);
    v43 = (void *)operator new[]();
    *(_QWORD *)(a1 + 40) = v43;
    bzero(v43, 4 * (3 * *(_DWORD *)(a1 + 112) * *(_DWORD *)(a1 + 116) / 2));
  }
  v44 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v45 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v47 = CFDictionaryCreateMutable(0, 0, v44, v45);
  valuePtr = *(_DWORD *)(a1 + 112);
  v48 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  if (v48)
  {
    v49 = v48;
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CA90E0], v48);
    CFRelease(v49);
  }
  valuePtr = *(_DWORD *)(a1 + 116);
  v50 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  if (v50)
  {
    v51 = v50;
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CA8FD8], v50);
    CFRelease(v51);
  }
  valuePtr = a5;
  v52 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  if (v52)
  {
    v53 = v52;
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CA9040], v52);
    CFRelease(v53);
  }
  valuePtr = 64;
  v54 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  if (v54)
  {
    v55 = v54;
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CA8F68], v54);
    CFRelease(v55);
  }
  valuePtr = 64;
  v56 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  if (v56)
  {
    v57 = v56;
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CA9048], v56);
    CFRelease(v57);
  }
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA8FF0], v47);
  if (!CVPixelBufferPoolCreate(0, 0, Mutable, (CVPixelBufferPoolRef *)(a1 + 24)))
    *(_BYTE *)(a1 + 16) = 1;
  if (Mutable)
    CFRelease(Mutable);
  if (v47)
    CFRelease(v47);
  return 0;
}

uint64_t sub_1B6770D9C(uint64_t a1, CVPixelBufferRef pixelBuffer)
{
  uint64_t result;
  int v5;
  int v6;
  const float *v7;
  int BytesPerRowOfPlane;
  unsigned __int8 *BaseAddressOfPlane;
  uint64_t v10;
  float *v11;
  vDSP_Length v12;
  int v13;
  int v14;
  uint64_t i;
  int v16;
  float v17;
  uint64_t v18;
  float *v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  unsigned __int8 *v23;
  unsigned int j;
  unsigned int v25;
  uint64_t v26;
  int v27;
  float v28;
  __CVBuffer *pixelBuffera;
  float __B;
  float __C;

  result = CVPixelBufferLockBaseAddress(pixelBuffer, 0);
  if (!(_DWORD)result)
  {
    v5 = rand();
    if (v5 <= 0)
      v6 = -(-v5 & 0xFFF);
    else
      v6 = v5 & 0xFFF;
    v7 = *(const float **)(a1 + 40);
    BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
    BaseAddressOfPlane = (unsigned __int8 *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 0);
    v10 = *(_QWORD *)(a1 + 8);
    v11 = *(float **)(v10 + 208);
    v12 = *(unsigned int *)(v10 + 288);
    v13 = *(_DWORD *)(v10 + 296);
    __B = 0.0;
    __C = 255.0;
    pixelBuffera = pixelBuffer;
    if ((*(_BYTE *)(a1 + 32) & 2) != 0)
    {
      if (v13)
      {
        v14 = 0;
        do
        {
          if (v12)
          {
            for (i = 0; i != v12; ++i)
            {
              if (v6 + (int)i <= 0)
                v16 = -(-(v6 + i) & 0xFFF);
              else
                v16 = (v6 + i) & 0xFFF;
              v17 = (float)(v7[i] * 0.3) + flt_1B6918DE4[v16] * 0.699999988;
              v7[i] = v17;
            }
            v6 += i;
          }
          vDSP_vadd(v11, 1, v7, 1, v11, 1, v12);
          vDSP_vclip(v11, 1, &__B, &__C, v11, 1, v12);
          vDSP_vfixru8(v11, 1, BaseAddressOfPlane, 1, v12);
          ++v14;
          v7 += v12;
          v11 += v12;
          BaseAddressOfPlane += BytesPerRowOfPlane;
        }
        while (v14 != v13);
      }
    }
    else
    {
      for (; v13; --v13)
      {
        vDSP_vfixru8(v11, 1, BaseAddressOfPlane, 1, v12);
        BaseAddressOfPlane += BytesPerRowOfPlane;
        v11 += v12;
      }
    }
    v18 = *(_QWORD *)(a1 + 8);
    v19 = *(float **)(v18 + 376);
    v20 = *(_QWORD *)(v18 + 456);
    v21 = *(_DWORD *)(v18 + 464);
    v22 = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 1uLL);
    v23 = (unsigned __int8 *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 1uLL);
    if ((*(_BYTE *)(a1 + 32) & 2) != 0)
    {
      if (v21)
      {
        v25 = 0;
        do
        {
          if ((_DWORD)v20)
          {
            v26 = 0;
            do
            {
              if (v6 + (int)v26 <= 0)
                v27 = -(-(v6 + v26) & 0xFFF);
              else
                v27 = (v6 + v26) & 0xFFF;
              v28 = (float)(v7[v26] * 0.3) + flt_1B6918DE4[v27] * 0.699999988;
              v7[v26++] = v28;
            }
            while (v20 != v26);
            v6 += v26;
          }
          vDSP_vadd(v19, 1, v7, 1, v19, 1, v20);
          vDSP_vclip(v19, 1, &__B, &__C, v19, 1, v20);
          vDSP_vfixru8(v19, 1, v23, 1, v20);
          v25 += 2;
          v7 += v20;
          v19 += (2 * v20);
          v23 += v22;
        }
        while (v25 < v21);
      }
    }
    else if (v21)
    {
      for (j = 0; j < v21; j += 2)
      {
        vDSP_vfixru8(v19, 1, v23, 1, v20);
        v23 += v22;
        v19 += 2 * (v20 & 0x7FFFFFFF);
      }
    }
    return CVPixelBufferUnlockBaseAddress(pixelBuffera, 0);
  }
  return result;
}

void VCPRateControlSessionInvalidate(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  int v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = *(_QWORD *)(a1 + 16);
    if (v1)
    {
      if (!*(_BYTE *)(v1 + 232))
      {
        *(_BYTE *)(v1 + 232) = 1;
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          v2 = *(_QWORD *)(v1 + 2536);
          v3 = *(_DWORD *)(v1 + 212);
          v4 = *(_DWORD *)(v1 + 216);
          v5 = 134218496;
          v6 = v2;
          v7 = 1024;
          v8 = v3;
          v9 = 1024;
          v10 = v4;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): VCPRateControlSession is invalidated\n", (uint8_t *)&v5, 0x18u);
        }
      }
    }
  }
}

uint64_t sub_1B67711D0()
{
  uint64_t result;

  qword_1EF138708 = 0;
  unk_1EF138710 = "VCPRateControlSession";
  qword_1EF138718 = 0;
  unk_1EF138720 = 0;
  qword_1EF138728 = (uint64_t)sub_1B677121C;
  unk_1EF138730 = 0u;
  unk_1EF138740 = 0u;
  result = _CFRuntimeRegisterClass();
  qword_1EF1386F0 = result;
  return result;
}

void sub_1B677121C(uint64_t a1)
{
  uint64_t v2;
  uint8_t v3[16];

  if (a1)
  {
    v2 = *(_QWORD *)(a1 + 16);
    VCPRateControlSessionInvalidate(a1);
    if (v2)
    {
      sub_1B6778D98(v2);
      std::condition_variable::~condition_variable((std::condition_variable *)(v2 + 2480));
      std::condition_variable::~condition_variable((std::condition_variable *)(v2 + 2432));
      std::mutex::~mutex((std::mutex *)(v2 + 2368));
      std::mutex::~mutex((std::mutex *)(v2 + 2304));
      MEMORY[0x1BCC9814C](v2, 0x10F0C40EEABCC0CLL);
      *(_QWORD *)(a1 + 16) = 0;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v3 = 0;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession is finalized\n", v3, 2u);
      }
    }
  }
}

const __CFBoolean *sub_1B67712E0(const __CFDictionary *a1, const void *a2)
{
  const __CFBoolean *result;

  result = (const __CFBoolean *)CFDictionaryGetValue(a1, a2);
  if (result)
    return (const __CFBoolean *)(CFBooleanGetValue(result) != 0);
  return result;
}

const void **sub_1B6771304(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

CFDictionaryRef sub_1B6771334(uint64_t ****a1)
{
  CFDictionaryRef result;

  result = sub_1B67792C8(****a1);
  qword_1EF138700 = (uint64_t)result;
  return result;
}

uint64_t sub_1B6771360(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
    std::__shared_mutex_base::unlock(*(std::__shared_mutex_base **)a1);
  return a1;
}

uint64_t VCPRateControlSessionCopyProperty(uint64_t a1, const void *a2, uint64_t a3, CFNumberRef *a4)
{
  uint64_t v4;
  uint64_t v5;
  const void *v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v13;
  char v14;
  CFTypeRef v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = *(_QWORD *)(a1 + 16);
    if (v4)
    {
      if (*(_BYTE *)(v4 + 232))
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315138;
          v17 = v4 + 256;
          _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: RC session is invalid\n", buf, 0xCu);
        }
        return 4294954393;
      }
      else if (*(_BYTE *)(v4 + 244))
      {
        v13 = v4 + 2368;
        v14 = 1;
        std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v4 + 2368));
        v15 = a2;
        if (sub_1B67782D8(*(_QWORD **)(v4 + 2544), &v15))
        {
          if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED000]))
          {
            v8 = *(const void **)(v4 + 24);
            v5 = 0;
            if (v8)
              *a4 = (CFNumberRef)CFRetain(v8);
          }
          else
          {
            v5 = sub_1B6779610(v4, a2, a4);
          }
        }
        else
        {
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          {
            v9 = *(_QWORD *)(v4 + 2536);
            v10 = *(_DWORD *)(v4 + 212);
            v11 = *(_DWORD *)(v4 + 216);
            *(_DWORD *)buf = 134218496;
            v17 = v9;
            v18 = 1024;
            v19 = v10;
            v20 = 1024;
            v21 = v11;
            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): unrecognised property key", buf, 0x18u);
          }
          v5 = 4294966630;
        }
        sub_1B677160C((uint64_t)&v13);
      }
      else
      {
        return 4294967278;
      }
    }
    else
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Empty session storage\n", buf, 2u);
      }
      return 4294954392;
    }
  }
  else
  {
    v5 = 0;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "NULL session\n", buf, 2u);
      return 0;
    }
  }
  return v5;
}

void sub_1B67715F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1B677160C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1B677160C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
    std::__shared_mutex_base::unlock_shared(*(std::__shared_mutex_base **)a1);
  return a1;
}

uint64_t sub_1B6771640(uint64_t a1, int a2)
{
  int IntegerCodePointForString;
  int v5;
  int v6;
  int v7;
  int v8;
  BOOL v9;
  int v10;
  _DWORD *v11;
  _DWORD *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  int v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t result;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint8_t buf[4];
  uint64_t v44;
  __int16 v45;
  int v46;
  __int16 v47;
  int v48;
  __int16 v49;
  char *v50;
  char __s[32];
  char v52[32];
  char v53[32];
  char __str[32];
  _BYTE v55[14];
  __int16 v56;
  __int16 v57;
  uint64_t v58;
  int v59;
  int v60;
  int v61;
  char v62;
  int v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  IntegerCodePointForString = CVColorPrimariesGetIntegerCodePointForString(*(CFStringRef *)(a1 + 104));
  snprintf(__str, 0x20uLL, "%d", IntegerCodePointForString);
  v5 = CVTransferFunctionGetIntegerCodePointForString(*(CFStringRef *)(a1 + 112));
  snprintf(v53, 0x20uLL, "%d", v5);
  v6 = CVYCbCrMatrixGetIntegerCodePointForString(*(CFStringRef *)(a1 + 120));
  snprintf(v52, 0x20uLL, "%d", v6);
  bzero(v55, 0x460uLL);
  v55[12] = *(_DWORD *)(a1 + 192);
  v7 = *(_DWORD *)(a1 + 76);
  v58 = *(_QWORD *)(a1 + 40);
  v57 = *(_DWORD *)(a1 + 216);
  v8 = *(_DWORD *)(a1 + 208);
  v56 = *(_DWORD *)(a1 + 212);
  v9 = v8 == 1718908520 || v8 == 1752589105;
  v63 = 1;
  v10 = !v9;
  v59 = v7;
  v60 = v10;
  v62 = 1;
  v61 = 2;
  v11 = *(_DWORD **)(a1 + 2296);
  if (!v11)
  {
    v12 = operator new(0x33F8uLL, MEMORY[0x1E0DE4E10]);
    if (!v12)
    {
      *(_QWORD *)(a1 + 2296) = 0;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Failed to allocate sequence enc\n", buf, 2u);
      }
      return 4294954392;
    }
    v11 = v12;
    sub_1B68050D0((uint64_t)v12);
    *(_QWORD *)(a1 + 2296) = v11;
  }
  v11[250] = a2;
  if (a2 > 1278226735)
  {
    if (a2 > 2016687155)
    {
      if (a2 == 2016687156 || a2 == 2019963956)
        goto LABEL_23;
      v13 = 2019963440;
    }
    else
    {
      if (a2 == 1278226736 || a2 == 1496395842)
        goto LABEL_23;
      v13 = 2016686640;
    }
    if (a2 == v13)
    {
LABEL_23:
      v15 = 10;
      v14 = 1;
      goto LABEL_28;
    }
LABEL_27:
    v14 = 0;
    v15 = 0;
    goto LABEL_28;
  }
  v14 = 0;
  v15 = 8;
  if (a2 <= 875836517)
  {
    if (a2 == 875704422)
      goto LABEL_28;
    v16 = 875704438;
    goto LABEL_26;
  }
  if (a2 != 875836518 && a2 != 875836534)
  {
    v16 = 1278226488;
LABEL_26:
    if (a2 == v16)
      goto LABEL_28;
    goto LABEL_27;
  }
LABEL_28:
  v11[251] = v15;
  v17 = CVYCbCrMatrixGetIntegerCodePointForString(*(CFStringRef *)(a1 + 120));
  v18 = *(_QWORD *)(a1 + 2296);
  if (v17 != 9 && *(_DWORD *)(v18 + 1004) == 10)
    v17 = 248;
  *(_DWORD *)(v18 + 1008) = v17;
  v20 = *(_DWORD *)(a1 + 16);
  if (v20)
    sub_1B680C408(v18, 0x8ADD349E618BA10ELL, v20);
  v21 = *(_DWORD *)(a1 + 20);
  if (v21)
    sub_1B680C408(*(_QWORD *)(a1 + 2296), 0xE8DDC90A9D7C709DLL, v21);
  v22 = *(_DWORD *)(a1 + 100);
  v23 = v22 - 1;
  if (v22 >= 1)
  {
    if (v22 <= 2)
    {
      if (*(_BYTE *)(a1 + 128))
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          v24 = *(_QWORD *)(a1 + 2536);
          v25 = *(_DWORD *)(a1 + 212);
          v26 = *(_DWORD *)(a1 + 216);
          *(_DWORD *)buf = 134218752;
          v44 = v24;
          v45 = 1024;
          v46 = v25;
          v47 = 1024;
          v48 = v26;
          v49 = 1024;
          LODWORD(v50) = v23;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): Number of LTR %d is too small. Disable LTR\n", buf, 0x1Eu);
        }
        sub_1B6777FAC(a1, (const __CFString *)*MEMORY[0x1E0CECF90], (const __CFString *)*MEMORY[0x1E0C9AE40]);
        v23 = 0;
        v22 = *(_DWORD *)(a1 + 100);
      }
      else
      {
        v23 = 0;
      }
    }
    snprintf(__s, 0x20uLL, "%d:%d:%d:%d", v22 - v23, v23, 1, 1);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v28 = *(_QWORD *)(a1 + 2536);
      v29 = *(_DWORD *)(a1 + 212);
      v30 = *(_DWORD *)(a1 + 216);
      *(_DWORD *)buf = 134218754;
      v44 = v28;
      v45 = 1024;
      v46 = v29;
      v47 = 1024;
      v48 = v30;
      v49 = 2080;
      v50 = __s;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): setting reference %s\n", buf, 0x22u);
    }
    v31 = *(_QWORD *)(a1 + 2296);
    buf[0] = 0;
    sub_1B67EF12C(*(_QWORD *)(v31 + 3192), 0x89E9C01960F4C582, __s, 0, (uint64_t)buf);
  }
  if (v14)
  {
    v32 = *(_QWORD *)(a1 + 2296);
    buf[0] = 0;
    sub_1B67EF12C(*(_QWORD *)(v32 + 3192), 0x8C49EF6ED9F28EA0, "10", 0, (uint64_t)buf);
  }
  if (*(_BYTE *)(a1 + 128))
    sub_1B680C408(*(_QWORD *)(a1 + 2296), 0xBE39025BC18BBD08, 1);
  if (sub_1B680C1A8(*(_QWORD *)(a1 + 2296), (uint64_t)v55))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      v44 = a1 + 256;
      v33 = MEMORY[0x1E0C81028];
      v34 = "%s: ParseCompressParams failed\n";
LABEL_70:
      _os_log_error_impl(&dword_1B676B000, v33, OS_LOG_TYPE_ERROR, v34, buf, 0xCu);
      return 3;
    }
    return 3;
  }
  if (a2 == 875704422 || a2 == 2019963440 || a2 == 875836518)
  {
    v35 = *(_QWORD *)(a1 + 2296);
    buf[0] = 0;
    sub_1B67EF12C(*(_QWORD *)(v35 + 3192), 0x3BEB44829B7A4FABLL, "true", 0, (uint64_t)buf);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v36 = *(_QWORD *)(a1 + 2536);
      v37 = *(_DWORD *)(a1 + 212);
      v38 = *(_DWORD *)(a1 + 216);
      *(_DWORD *)buf = 134218496;
      v44 = v36;
      v45 = 1024;
      v46 = v37;
      v47 = 1024;
      v48 = v38;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): get full range pixel buffer\n", buf, 0x18u);
    }
  }
  v39 = *(_QWORD *)(a1 + 2296);
  buf[0] = 0;
  sub_1B67EF12C(*(_QWORD *)(v39 + 3192), 0x9FFE593DC10E7CC4, __str, 0, (uint64_t)buf);
  v40 = *(_QWORD *)(a1 + 2296);
  buf[0] = 0;
  sub_1B67EF12C(*(_QWORD *)(v40 + 3192), 0x2660BA38B42FDFB5, v53, 0, (uint64_t)buf);
  v41 = *(_QWORD *)(a1 + 2296);
  buf[0] = 0;
  sub_1B67EF12C(*(_QWORD *)(v41 + 3192), 0xE961BACE8A163BCBLL, v52, 0, (uint64_t)buf);
  sub_1B680C408(*(_QWORD *)(a1 + 2296), 0xDFF2FE5D542EA31BLL, 0);
  sub_1B680C408(*(_QWORD *)(a1 + 2296), 0x70A12C1952D5628BLL, 0);
  sub_1B680C408(*(_QWORD *)(a1 + 2296), 0xF890AF2C24C4A032, *(_DWORD *)(a1 + 32));
  if (*(_BYTE *)(a1 + 244))
  {
    sub_1B680C408(*(_QWORD *)(a1 + 2296), 0x3B036542BE80F4D6, *(_DWORD *)(a1 + 236));
    sub_1B680C408(*(_QWORD *)(a1 + 2296), 0xDE9D01B25B989E98, *(_DWORD *)(a1 + 240));
  }
  v42 = *(_QWORD *)(a1 + 2296);
  *(_QWORD *)(v42 + 1120) = sub_1B6771ED8;
  *(_QWORD *)(v42 + 1128) = sub_1B67720B8;
  *(_QWORD *)(v42 + 1136) = a1;
  result = sub_1B680C5A0((char **)v42);
  if ((_DWORD)result)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      v44 = a1 + 256;
      v33 = MEMORY[0x1E0C81028];
      v34 = "%s: Encoder initialization failed\n";
      goto LABEL_70;
    }
    return 3;
  }
  return result;
}

void sub_1B6771DD4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC98134](v1, MEMORY[0x1E0DE4E10]);
  _Unwind_Resume(a1);
}

const void **sub_1B6771DF8(__CFDictionary *a1, const void *a2, int a3)
{
  CFNumberRef v5;
  int valuePtr;
  CFNumberRef v8;

  valuePtr = a3;
  v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v8 = v5;
  if (v5)
    CFDictionarySetValue(a1, a2, v5);
  return sub_1B6770598((const void **)&v8);
}

void sub_1B6771E54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1B6770598((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1B6771E68(__CFDictionary *a1, const void *a2, double a3)
{
  CFNumberRef v5;
  double v7;
  CFNumberRef v8;

  v7 = a3;
  v5 = CFNumberCreate(0, kCFNumberDoubleType, &v7);
  v8 = v5;
  if (v5)
    CFDictionarySetValue(a1, a2, v5);
  return sub_1B6770598((const void **)&v8);
}

void sub_1B6771EC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1B6770598((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6771ED8(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  __int128 *v10;
  _BOOL4 v11;
  NSObject *v12;
  const char *v13;
  uint32_t v14;
  uint64_t (*v15)(uint64_t, uint64_t, uint64_t, __int128 *, __int128 *, uint64_t, uint64_t, uint64_t *, _BOOL4);
  uint64_t v16;
  uint64_t (*v18)(uint64_t, _QWORD, uint64_t, __int128 *, __int128 *, _QWORD, _QWORD, uint64_t *, int);
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  uint8_t buf[4];
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v30 = *MEMORY[0x1E0CA2E18];
  v31 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  v28 = v30;
  v29 = v31;
  if (!a1)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
LABEL_11:
      v18 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t, __int128 *, __int128 *, _QWORD, _QWORD, uint64_t *, int))(a1 + 2272);
      v19 = *(_QWORD *)(a1 + 2288);
      v22 = v30;
      v23 = v31;
      v20 = v28;
      v21 = v29;
      return v18(v19, 0, a4, &v22, &v20, 0, 0, a2, 1);
    }
    *(_WORD *)buf = 0;
    v12 = MEMORY[0x1E0C81028];
    v13 = "Invalid rate control session\n";
    v14 = 2;
LABEL_14:
    _os_log_error_impl(&dword_1B676B000, v12, OS_LOG_TYPE_ERROR, v13, buf, v14);
    goto LABEL_11;
  }
  if (!a2)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_11;
    *(_DWORD *)buf = 136315138;
    v33 = a1 + 256;
    v12 = MEMORY[0x1E0C81028];
    v13 = "%s: Invalid frame context\n";
    v14 = 12;
    goto LABEL_14;
  }
  v10 = (__int128 *)((char *)a2 + 36);
  v9 = *a2;
  v11 = !a4 || (a2[1] & 2) != 0;
  a2[8] = a3;
  v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, __int128 *, __int128 *, uint64_t, uint64_t, uint64_t *, _BOOL4))(a1 + 2272);
  v16 = *(_QWORD *)(a1 + 2288);
  v26 = *(_OWORD *)((char *)a2 + 12);
  v27 = *(uint64_t *)((char *)a2 + 28);
  v24 = *v10;
  v25 = *(uint64_t *)((char *)a2 + 52);
  return v15(v16, v9, a4, &v26, &v24, a5, a6, a2, v11);
}

uint64_t sub_1B67720B8(uint64_t a1, __int128 *a2)
{
  uint64_t (*v2)(uint64_t, __int128 *);
  uint64_t v3;
  __int128 v5;
  uint64_t v6;

  v2 = *(uint64_t (**)(uint64_t, __int128 *))(a1 + 2280);
  v3 = *(_QWORD *)(a1 + 2288);
  v5 = *a2;
  v6 = *((_QWORD *)a2 + 2);
  return v2(v3, &v5);
}

uint64_t VCPRateControlSessionBeforeEncodeFrame(uint64_t a1, uint64_t a2, __CVBuffer *a3, __int128 *a4, __int128 *a5, const __CFDictionary *a6, unsigned int *a7)
{
  uint64_t v7;
  uint64_t v9;
  uint64_t v15;
  CFMutableDictionaryRef MutableCopy;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  int v29;
  __CFDictionary *Mutable;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  unsigned int v38;
  void (*v39)(uint64_t, uint64_t, __CVBuffer *, __int128 *, __int128 *, uint64_t, _QWORD, uint64_t, unsigned int, std::mutex *);
  uint64_t v40;
  OSType PixelFormatType;
  std::mutex *v43;
  __int128 v44;
  uint64_t v45;
  __int128 v46;
  uint64_t v47;
  uint64_t v48[2];
  __int128 v49;
  uint64_t v50;
  __int128 v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char v55;
  _BYTE v56[12];
  _BYTE buf[18];
  __int16 v58;
  int v59;
  __int16 v60;
  int v61;
  __int16 v62;
  int v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v7 = *(_QWORD *)(a1 + 16);
    if (v7)
    {
      if (a7)
      {
        if (*(_BYTE *)(v7 + 232))
        {
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v7 + 256;
            _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: RC session is invalid\n", buf, 0xCu);
          }
          return 4294954393;
        }
        if (!*(_BYTE *)(v7 + 244))
          return 4294967278;
        std::mutex::lock((std::mutex *)(v7 + 2304));
        v54 = v7 + 2368;
        v55 = 1;
        v43 = (std::mutex *)(v7 + 2304);
        std::__shared_mutex_base::lock((std::__shared_mutex_base *)(v7 + 2368));
        v15 = *(_QWORD *)(v7 + 2256);
        if (v15)
          sub_1B6872E44(v15, (uint64_t *)"input_frames", 1.0);
        if (a6)
          MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a6);
        else
          MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v53 = (uint64_t)MutableCopy;
        v17 = operator new(0x70uLL, MEMORY[0x1E0DE4E10]);
        if (!v17)
        {
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v7 + 256;
            _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: Failed to allocate frame context\n", buf, 0xCu);
          }
          v9 = 4294954392;
          goto LABEL_74;
        }
        v18 = (uint64_t)v17;
        v17[9] = 0;
        v19 = (uint64_t)(v17 + 9);
        *((_BYTE *)v17 + 104) = 0;
        v17[10] = 0;
        v17[11] = 0;
        v20 = *(_QWORD *)(v7 + 2264);
        if (v20)
        {
          if (sub_1B67814D0(v20, a3, *(unsigned __int8 *)(v7 + 96)))
          {
            v21 = *(_DWORD *)(v7 + 80);
            if (v21 > 39)
              goto LABEL_38;
            *(_DWORD *)(v7 + 80) = 40;
            *(_DWORD *)(v7 + 84) = v21;
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
            {
              v22 = *(_QWORD *)(v7 + 2536);
              v23 = *(_DWORD *)(v7 + 212);
              v24 = *(_DWORD *)(v7 + 216);
              *(_DWORD *)buf = 134219008;
              *(_QWORD *)&buf[4] = v22;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v23;
              v58 = 1024;
              v59 = v24;
              v60 = 1024;
              v61 = v21;
              v62 = 1024;
              v63 = 40;
              _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): boosting maxAllowedQp %d -> %d\n", buf, 0x24u);
            }
            *(_QWORD *)buf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, (const void *)(v7 + 80));
            sub_1B6777FAC(v7, (const __CFString *)*MEMORY[0x1E0CED098], *(const __CFString **)buf);
            *(_BYTE *)(v7 + 88) = 1;
          }
          else
          {
            if (!*(_BYTE *)(v7 + 88))
              goto LABEL_38;
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
            {
              v25 = *(_QWORD *)(v7 + 2536);
              v26 = *(_DWORD *)(v7 + 212);
              v27 = *(_DWORD *)(v7 + 216);
              v28 = *(_DWORD *)(v7 + 80);
              v29 = *(_DWORD *)(v7 + 84);
              *(_DWORD *)buf = 134219008;
              *(_QWORD *)&buf[4] = v25;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v26;
              v58 = 1024;
              v59 = v27;
              v60 = 1024;
              v61 = v28;
              v62 = 1024;
              v63 = v29;
              _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): reset maxAllowedQp %d -> %d\n", buf, 0x24u);
            }
            *(_DWORD *)(v7 + 80) = *(_DWORD *)(v7 + 84);
            *(_QWORD *)buf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, (const void *)(v7 + 80));
            sub_1B6777FAC(v7, (const __CFString *)*MEMORY[0x1E0CED098], *(const __CFString **)buf);
            *(_BYTE *)(v7 + 88) = 0;
          }
          sub_1B6770598((const void **)buf);
        }
LABEL_38:
        *(_QWORD *)v18 = a2;
        *(_DWORD *)(v18 + 8) = *a7;
        *(_OWORD *)(v18 + 12) = *a4;
        *(_QWORD *)(v18 + 28) = *((_QWORD *)a4 + 2);
        *(_OWORD *)(v18 + 36) = *a5;
        *(_QWORD *)(v18 + 52) = *((_QWORD *)a5 + 2);
        sub_1B67ED940(v19);
        if (*(_BYTE *)(v7 + 233))
        {
          Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          *(_QWORD *)v56 = Mutable;
          if (!Mutable)
          {
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = v7 + 256;
              _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: Failed to allocate session properties\n", buf, 0xCu);
            }
            v9 = 4294954392;
            goto LABEL_58;
          }
          v9 = sub_1B67797BC(v7, Mutable);
          if ((_DWORD)v9)
          {
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = v7 + 256;
              _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: Failed to set session properties\n", buf, 0xCu);
            }
LABEL_58:
            sub_1B67705C8((const void **)v56);
LABEL_73:
            MEMORY[0x1BCC9814C](v18, 0x10A0C40583E35ACLL);
LABEL_74:
            sub_1B6772C48((uint64_t)&v54);
            goto LABEL_75;
          }
          v38 = *a7;
          sub_1B6772C48((uint64_t)&v54);
          v39 = *(void (**)(uint64_t, uint64_t, __CVBuffer *, __int128 *, __int128 *, uint64_t, _QWORD, uint64_t, unsigned int, std::mutex *))(v7 + 2272);
          v40 = *(_QWORD *)(v7 + 2288);
          v46 = *a4;
          v47 = *((_QWORD *)a4 + 2);
          v44 = *a5;
          v45 = *((_QWORD *)a5 + 2);
          v39(v40, a2, a3, &v46, &v44, v53, *(_QWORD *)v56, v18, (v38 >> 1) & 1, v43);
          sub_1B67705C8((const void **)v56);
LABEL_60:
          v9 = 0;
          ++*(_DWORD *)(v7 + 196);
LABEL_75:
          sub_1B67705C8((const void **)&v53);
          sub_1B6771360((uint64_t)&v54);
          std::mutex::unlock(v43);
          return v9;
        }
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = 0;
        if (!a3)
        {
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)v56 = 136315138;
            *(_QWORD *)&v56[4] = v7 + 256;
            _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: empty image buffer\n", v56, 0xCu);
          }
          v9 = 4294954394;
          goto LABEL_72;
        }
        v31 = *(_QWORD *)(v7 + 2296);
        if (!v31)
        {
          PixelFormatType = CVPixelBufferGetPixelFormatType(a3);
          if (sub_1B6771640(v7, PixelFormatType))
          {
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v56 = 136315138;
              *(_QWORD *)&v56[4] = v7 + 256;
              _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: Failed to initialize sequence\n", v56, 0xCu);
            }
            v9 = 4294954392;
            goto LABEL_72;
          }
          v31 = *(_QWORD *)(v7 + 2296);
        }
        v51 = *a4;
        v52 = *((_QWORD *)a4 + 2);
        v49 = *a5;
        v50 = *((_QWORD *)a5 + 2);
        v9 = sub_1B6772AA0(v7, a3, &v51, &v49, v53, v31 + 120);
        if (!(_DWORD)v9)
        {
          v32 = *(_QWORD *)(*(_QWORD *)(v7 + 2296) + 12728);
          if (v32)
          {
            v9 = (*(uint64_t (**)(uint64_t, _BYTE *, __CVBuffer *))(*(_QWORD *)v32 + 16))(v32, buf, a3);
            if (!(_DWORD)v9)
            {
              v33 = *(_QWORD *)(v7 + 2296);
              v34 = *(_QWORD *)buf;
              *(_DWORD *)(*(_QWORD *)buf + 8) = *(_DWORD *)(v7 + 196);
              *(_OWORD *)(v34 + 16) = *(_OWORD *)(v33 + 904);
              *(_DWORD *)(v34 + 32) = *(_DWORD *)(v33 + 920);
              *(_OWORD *)(v34 + 256) = *(_OWORD *)(v33 + 960);
              sub_1B6772C48((uint64_t)&v54);
              v35 = *(_QWORD *)(v7 + 2296);
              v48[0] = *(_QWORD *)buf;
              v48[1] = *(_QWORD *)&buf[8];
              if (*(_QWORD *)&buf[8])
              {
                v36 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
                do
                  v37 = __ldxr(v36);
                while (__stxr(v37 + 1, v36));
              }
              v9 = sub_1B680F980(v35, v48, v18);
              sub_1B6772C88((uint64_t)v48);
              if ((_DWORD)v9)
              {
                if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)v56 = 136315138;
                  *(_QWORD *)&v56[4] = v7 + 256;
                  _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: Failed to push frame\n", v56, 0xCu);
                }
                sub_1B6772C88((uint64_t)buf);
                goto LABEL_75;
              }
              sub_1B6772C88((uint64_t)buf);
              goto LABEL_60;
            }
          }
          else
          {
            v9 = 4294954385;
          }
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)v56 = 136315138;
            *(_QWORD *)&v56[4] = v7 + 256;
            _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: Failed to allocate source frame\n", v56, 0xCu);
          }
        }
LABEL_72:
        sub_1B6772C88((uint64_t)buf);
        goto LABEL_73;
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "NULL infoFlagsOut pointer\n", buf, 2u);
      }
      return 4294954394;
    }
    else
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Empty session storage\n", buf, 2u);
      }
      return 4294954392;
    }
  }
  else
  {
    v9 = 0;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "NULL session\n", buf, 2u);
      return 0;
    }
  }
  return v9;
}

void sub_1B6772A14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,const void *a28,__int16 a29,char a30,char a31)
{
  uint64_t v31;

  sub_1B6772C88((uint64_t)&a19);
  sub_1B6772C88(v31 - 144);
  sub_1B67705C8(&a28);
  sub_1B6771360((uint64_t)&a29);
  std::mutex::unlock(a10);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6772AA0(uint64_t a1, __CVBuffer *a2, __int128 *a3, __int128 *a4, uint64_t a5, uint64_t a6)
{
  double v8;
  int v9;
  uint64_t v10;
  double v13;
  NSObject *v15;
  const char *v16;
  __int128 v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  uint8_t buf[16];

  v8 = *(double *)(a1 + 48);
  if (v8 < 0.0)
    goto LABEL_2;
  if (v8 != 0.5 && v8 != 1.0)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      return 4294954394;
    *(_WORD *)buf = 0;
    v15 = MEMORY[0x1E0C81028];
    v16 = "Baselayer framerate fraction should be either 0.5 or 1";
    goto LABEL_22;
  }
  if (v8 != 1.0)
  {
    v13 = *(double *)(a1 + 56);
    if (v13 <= 0.0 || v13 >= 1.0)
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        return 4294954394;
      *(_WORD *)buf = 0;
      v15 = MEMORY[0x1E0C81028];
      v16 = "Baselayer bitrate fraction should be between 0 (exclusive) and 1 (inclusive)";
LABEL_22:
      _os_log_error_impl(&dword_1B676B000, v15, OS_LOG_TYPE_ERROR, v16, buf, 2u);
      return 4294954394;
    }
  }
LABEL_2:
  *(_QWORD *)(a6 + 824) = a5;
  *(_DWORD *)a6 = *(_DWORD *)(a1 + 192);
  *(_QWORD *)(a6 + 8) = *(_QWORD *)(a1 + 40);
  *(double *)(a6 + 16) = v8;
  *(_QWORD *)(a6 + 24) = *(_QWORD *)(a1 + 56);
  v9 = *(_DWORD *)(a1 + 76) & ~(*(int *)(a1 + 76) >> 31);
  *(_DWORD *)(a6 + 32) = v9;
  *(_DWORD *)(a6 + 864) = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a6 + 868) = *(_DWORD *)(a1 + 92);
  *(_BYTE *)(a6 + 874) = *(_BYTE *)(a1 + 97);
  if (*(int *)(a1 + 236) >= 1)
  {
    v10 = 0;
    do
      *(_DWORD *)(a6 + 36 + 4 * v10++) = v9;
    while (v10 < *(int *)(a1 + 236));
  }
  v20 = *a3;
  v21 = *((_QWORD *)a3 + 2);
  v18 = *a4;
  v19 = *((_QWORD *)a4 + 2);
  sub_1B67ABDE8((_DWORD *)a6, (uint64_t *)&v20, (uint64_t *)&v18, *(_DWORD *)(a1 + 196), *(_DWORD *)(a1 + 196), *(_DWORD *)(a1 + 68), 1, *(float *)(a1 + 72), 0.0);
  sub_1B67ACB64(a6, a2);
  return 0;
}

void sub_1B6772C48(uint64_t a1)
{
  uint64_t v2;

  if (*(_BYTE *)(a1 + 8))
  {
    std::__shared_mutex_base::unlock(*(std::__shared_mutex_base **)a1);
    *(_BYTE *)(a1 + 8) = 0;
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    sub_1B6772C88(v2);
  }
}

uint64_t sub_1B6772C88(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

uint64_t VCPRateControlSessionBeforeEmitEncodedFrame(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, CMSampleBufferRef *a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v12;
  int v13;
  double v14;
  _BOOL4 v15;
  const __CFArray *SampleAttachmentsArray;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v18;
  _BOOL4 v19;
  _BOOL4 v20;
  NSObject *v21;
  const char *v22;
  uint64_t v23;
  _BYTE *v24;
  uint64_t v25;
  OpaqueCMBlockBuffer *DataBuffer;
  uint64_t v27;
  int v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    v8 = 0;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v30) = 0;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "NULL session\n", (uint8_t *)&v30, 2u);
      return 0;
    }
    return v8;
  }
  v6 = *(_QWORD *)(a1 + 16);
  if (!*(_BYTE *)(v6 + 244))
    return 4294967278;
  if (*(_BYTE *)(v6 + 232))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v30 = 136315138;
      v31 = v6 + 256;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: RC session is invalid\n", (uint8_t *)&v30, 0xCu);
    }
    v8 = 4294954393;
    if (!a6)
      return v8;
LABEL_54:
    MEMORY[0x1BCC9814C](a6, 0x10A0C40583E35ACLL);
    return v8;
  }
  v12 = *(_QWORD *)(v6 + 2256);
  if (v12)
    sub_1B6872E44(v12, (uint64_t *)"encoded_frames", 1.0);
  if (!a4)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_25;
    LOWORD(v30) = 0;
    v21 = MEMORY[0x1E0C81028];
    v22 = "NULL infoFlags pointer\n";
    goto LABEL_59;
  }
  if (!a5)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_25;
    LOWORD(v30) = 0;
    v21 = MEMORY[0x1E0C81028];
    v22 = "NULL sampleBuffer pointer\n";
LABEL_59:
    _os_log_error_impl(&dword_1B676B000, v21, OS_LOG_TYPE_ERROR, v22, (uint8_t *)&v30, 2u);
LABEL_25:
    v8 = 4294954394;
    if (!a6)
      return v8;
    goto LABEL_54;
  }
  if (a6)
  {
    if (!*(_BYTE *)(v6 + 233))
    {
      v23 = *(_QWORD *)(v6 + 2296);
      if (!v23)
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          LOWORD(v30) = 0;
          _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "empty sequence\n", (uint8_t *)&v30, 2u);
        }
        v8 = 4294954394;
        goto LABEL_54;
      }
      v24 = *(_BYTE **)(a6 + 64);
      if (v24)
      {
        v25 = *(_QWORD *)(v23 + 13272);
        if (v25)
        {
          v8 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD, CMSampleBufferRef))(*(_QWORD *)v25 + 80))(v25, *(_QWORD *)(a6 + 64), a3, *a4, *a5);
          if ((_DWORD)v8)
            goto LABEL_54;
        }
        if (*v24)
          *a4 |= 2u;
      }
      else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v30) = 0;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "empty frame context\n", (uint8_t *)&v30, 2u);
      }
    }
    v13 = *a4;
    v14 = 0.0;
    if ((*a4 & 2) != 0 || !*a5)
    {
      v19 = 0;
      v20 = 0;
      v15 = 1;
    }
    else
    {
      v15 = 1;
      SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(*a5, 1u);
      if (SampleAttachmentsArray
        && (ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0)) != 0)
      {
        v18 = ValueAtIndex;
        v19 = !sub_1B677319C(ValueAtIndex, (const void *)*MEMORY[0x1E0CA25C8], 1);
        v20 = sub_1B677319C(v18, (const void *)*MEMORY[0x1E0CEDA90], 0);
        v15 = sub_1B677319C(v18, (const void *)*MEMORY[0x1E0CA2618], 1);
      }
      else
      {
        v19 = 0;
        v20 = 0;
      }
      DataBuffer = CMSampleBufferGetDataBuffer(*a5);
      v14 = (double)(8 * CMBlockBufferGetDataLength(DataBuffer));
    }
    sub_1B67ED98C(a6 + 72);
    v8 = 0;
    if ((v13 & 2) == 0)
    {
      v27 = *(_QWORD *)(v6 + 2256);
      if (v27)
      {
        sub_1B6872E44(v27, (uint64_t *)"transmit_frames", 1.0);
        sub_1B6872E44(*(_QWORD *)(v6 + 2256), (uint64_t *)"encoded_bits", v14);
        sub_1B6872E44(*(_QWORD *)(v6 + 2256), (uint64_t *)"encoding_time", *(double *)(a6 + 72));
        if (v19)
          sub_1B6872E44(*(_QWORD *)(v6 + 2256), (uint64_t *)"idr_frames", 1.0);
        if (v20)
          sub_1B6872E44(*(_QWORD *)(v6 + 2256), (uint64_t *)"refresh_frames", 1.0);
        if (*(double *)(v6 + 48) > 0.0 && v15)
        {
          sub_1B6872E44(*(_QWORD *)(v6 + 2256), (uint64_t *)"base_layer_frames", 1.0);
          sub_1B6872E44(*(_QWORD *)(v6 + 2256), (uint64_t *)"base_layer_encoded_bits", v14);
        }
        v8 = 0;
      }
    }
    goto LABEL_54;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    LOWORD(v30) = 0;
    _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "NULL frameRefCon pointer\n", (uint8_t *)&v30, 2u);
  }
  return 4294954394;
}

BOOL sub_1B677319C(const __CFDictionary *a1, const void *a2, uint64_t a3)
{
  const __CFBoolean *Value;

  Value = (const __CFBoolean *)CFDictionaryGetValue(a1, a2);
  if (Value)
    return CFBooleanGetValue(Value) != 0;
  return a3;
}

uint64_t VCPRateControlSessionCompleteFrames(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  std::mutex *v3;
  uint64_t v4;
  int v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = *(_QWORD *)(a1 + 16);
    if (v1)
    {
      if (*(_BYTE *)(v1 + 232))
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          v6 = 136315138;
          v7 = v1 + 256;
          _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: RC session is invalid\n", (uint8_t *)&v6, 0xCu);
        }
        return 4294954393;
      }
      else if (*(_BYTE *)(v1 + 244))
      {
        v3 = (std::mutex *)(v1 + 2304);
        std::mutex::lock((std::mutex *)(v1 + 2304));
        if (*(_BYTE *)(v1 + 233))
        {
          v2 = 0;
        }
        else
        {
          v4 = *(_QWORD *)(v1 + 2296);
          if (v4)
          {
            v2 = sub_1B6806E70(v4);
          }
          else
          {
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
            {
              LOWORD(v6) = 0;
              _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "empty sequence\n", (uint8_t *)&v6, 2u);
            }
            v2 = 4294954394;
          }
        }
        std::mutex::unlock(v3);
      }
      else
      {
        return 4294967278;
      }
    }
    else
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        LOWORD(v6) = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Empty session storage\n", (uint8_t *)&v6, 2u);
      }
      return 4294954392;
    }
  }
  else
  {
    v2 = 0;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v6) = 0;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "NULL session\n", (uint8_t *)&v6, 2u);
      return 0;
    }
  }
  return v2;
}

void sub_1B67733B8(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B67733CC(uint64_t a1)
{
  void *v2;
  void *v3;

  *(_QWORD *)a1 = &off_1E6A15498;
  v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(_QWORD *)(a1 + 64) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 32);
  if (v3)
  {
    *(_QWORD *)(a1 + 40) = v3;
    operator delete(v3);
  }
  sub_1B6773DB4((const void **)(a1 + 24));
  sub_1B6773DE4((const void **)(a1 + 16));
  return a1;
}

void sub_1B6773428(uint64_t a1)
{
  void *v2;
  void *v3;

  *(_QWORD *)a1 = &off_1E6A15498;
  v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(_QWORD *)(a1 + 64) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 32);
  if (v3)
  {
    *(_QWORD *)(a1 + 40) = v3;
    operator delete(v3);
  }
  sub_1B6773DB4((const void **)(a1 + 24));
  sub_1B6773DE4((const void **)(a1 + 16));
  JUMPOUT(0x1BCC9814CLL);
}

uint64_t sub_1B6773494(uint64_t a1)
{
  const CFDictionaryKeyCallBacks *v2;
  const CFDictionaryValueCallBacks *v3;
  CFMutableDictionaryRef Mutable;
  BOOL v5;
  uint64_t v6;
  int v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  const __CFDictionary *v12;
  const void *v13;
  const void *v14;
  VTSessionRef *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  char *v32;
  char *v33;
  int v34;
  uint64_t v35;
  CFMutableDictionaryRef v37;
  CFMutableDictionaryRef v38;
  CFDictionaryRef pixelBufferAttributes;
  uint64_t valuePtr;

  v2 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v3 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  pixelBufferAttributes = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  Mutable = CFDictionaryCreateMutable(0, 0, v2, v3);
  v38 = Mutable;
  if (pixelBufferAttributes)
    v5 = Mutable == 0;
  else
    v5 = 1;
  if (v5)
  {
    v6 = 4294954392;
    goto LABEL_43;
  }
  v7 = *(_DWORD *)(a1 + 12);
  valuePtr = (4 * *(_DWORD *)(a1 + 8));
  v8 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  v9 = v8;
  if (v8)
  {
    CFDictionarySetValue(pixelBufferAttributes, (const void *)*MEMORY[0x1E0CA90E0], v8);
    CFRelease(v9);
  }
  valuePtr = (4 * v7);
  v10 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  if (v10)
  {
    CFDictionarySetValue(pixelBufferAttributes, (const void *)*MEMORY[0x1E0CA8FD8], v10);
    CFRelease(v10);
  }
  valuePtr = 1111970369;
  v11 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  if (v11)
  {
    CFDictionarySetValue(pixelBufferAttributes, (const void *)*MEMORY[0x1E0CA9040], v11);
    CFRelease(v11);
  }
  v37 = v38;
  if (v38)
    CFRetain(v38);
  CFDictionarySetValue(pixelBufferAttributes, (const void *)*MEMORY[0x1E0CA8FF0], v38);
  sub_1B67705C8((const void **)&v37);
  v12 = pixelBufferAttributes;
  v13 = *(const void **)(a1 + 16);
  if (v13)
  {
    CFRelease(v13);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v6 = CVPixelBufferPoolCreate(0, 0, v12, (CVPixelBufferPoolRef *)(a1 + 16));
  if (!(_DWORD)v6)
  {
    v15 = (VTSessionRef *)(a1 + 24);
    v14 = *(const void **)(a1 + 24);
    if (v14)
    {
      CFRelease(v14);
      *v15 = 0;
    }
    v6 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (VTPixelTransferSessionRef *)(a1 + 24));
    if (!(_DWORD)v6)
    {
      v6 = VTSessionSetProperty(*v15, (CFStringRef)*MEMORY[0x1E0CED7E0], (CFTypeRef)*MEMORY[0x1E0CA8F18]);
      if (!(_DWORD)v6)
      {
        v16 = *(_QWORD *)(a1 + 32);
        v17 = 4 * *(_DWORD *)(a1 + 8) * *(_DWORD *)(a1 + 12);
        v18 = *(_QWORD *)(a1 + 40) - v16;
        if (v17 <= v18)
        {
          if (v17 < v18)
            *(_QWORD *)(a1 + 40) = v16 + v17;
        }
        else
        {
          sub_1B6773C90((unint64_t *)(a1 + 32), v17 - v18);
        }
        v19 = *(_QWORD *)(a1 + 56);
        v20 = *(_QWORD *)(a1 + 64);
        v21 = v20 - v19;
        if ((unint64_t)(v20 - v19) >> 14)
        {
          if (v21 == 0x4000)
          {
LABEL_42:
            v6 = 0;
            goto LABEL_43;
          }
          v6 = 0;
          v35 = v19 + 0x4000;
        }
        else
        {
          v22 = 4096 - (v21 >> 2);
          v23 = *(_QWORD *)(a1 + 72);
          if (v22 > (v23 - v20) >> 2)
          {
            v24 = v23 - v19;
            v25 = v24 >> 1;
            if ((unint64_t)(v24 >> 1) <= 0x1000)
              v25 = 4096;
            if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL)
              v26 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v26 = v25;
            v27 = (char *)sub_1B6773BC0(v26);
            v28 = v21 >> 2;
            v6 = *(_QWORD *)(a1 + 56);
            v29 = *(_QWORD *)(a1 + 64);
            v30 = &v27[4 * v28];
            v32 = &v27[4 * v31];
            bzero(v30, 4 * v22);
            v33 = &v30[4 * v22];
            while (v29 != v6)
            {
              v34 = *(_DWORD *)(v29 - 4);
              v29 -= 4;
              *((_DWORD *)v30 - 1) = v34;
              v30 -= 4;
            }
            *(_QWORD *)(a1 + 56) = v30;
            *(_QWORD *)(a1 + 64) = v33;
            *(_QWORD *)(a1 + 72) = v32;
            if (v6)
            {
              operator delete((void *)v6);
              goto LABEL_42;
            }
            goto LABEL_43;
          }
          bzero(*(void **)(a1 + 64), 4 * v22);
          v6 = 0;
          v35 = v20 + 4 * v22;
        }
        *(_QWORD *)(a1 + 64) = v35;
      }
    }
  }
LABEL_43:
  sub_1B67705C8((const void **)&v38);
  sub_1B67705C8((const void **)&pixelBufferAttributes);
  return v6;
}

void sub_1B67737D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  sub_1B67705C8((const void **)va);
  sub_1B67705C8((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6773818(uint64_t a1, __CVBuffer *a2)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  __CVBuffer *v9;
  int Width;
  int v11;
  void *v12;
  uint64_t v13;
  char *BaseAddress;
  unsigned int v15;
  unsigned int v16;
  signed int v17;
  char *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  int v22;
  BOOL v23;
  char v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unsigned int v30;
  uint64_t v31;
  CFDataRef v32;
  CFDataRef v34;
  CVPixelBufferRef pixelBufferOut;

  pixelBufferOut = 0;
  v4 = CVPixelBufferPoolCreatePixelBuffer(0, *(CVPixelBufferPoolRef *)(a1 + 16), &pixelBufferOut);
  if (!(_DWORD)v4)
  {
    v4 = VTPixelTransferSessionTransferImage(*(VTPixelTransferSessionRef *)(a1 + 24), a2, pixelBufferOut);
    if (!(_DWORD)v4)
    {
      v4 = CVPixelBufferLockBaseAddress(pixelBufferOut, 1uLL);
      if (!(_DWORD)v4)
      {
        v5 = *(_DWORD *)(a1 + 12);
        if (v5 < 1)
        {
LABEL_26:
          v4 = CVPixelBufferUnlockBaseAddress(pixelBufferOut, 1uLL);
          if (!(_DWORD)v4)
          {
            v32 = CFDataCreate(0, *(const UInt8 **)(a1 + 32), 4 * *(_DWORD *)(a1 + 8) * *(_DWORD *)(a1 + 12));
            v34 = v32;
            if (v32)
            {
              CVBufferSetAttachment(a2, CFSTR("Spillmap"), v32, kCVAttachmentMode_ShouldPropagate);
              v4 = 0;
            }
            else
            {
              v4 = 4294954392;
            }
            sub_1B67704D8((const void **)&v34);
          }
        }
        else
        {
          v6 = 0;
          v7 = *(_DWORD *)(a1 + 8);
          while (v7 < 1)
          {
LABEL_25:
            v6 += 4;
            if (v6 >= 4 * v5)
              goto LABEL_26;
          }
          v8 = 0;
          while (1)
          {
            v9 = pixelBufferOut;
            if (CVPixelBufferGetPixelFormatType(pixelBufferOut) != 1111970369)
              break;
            Width = CVPixelBufferGetWidth(v9);
            v11 = *(_DWORD *)(a1 + 8);
            v12 = *(void **)(a1 + 56);
            v13 = *(_QWORD *)(a1 + 64) - (_QWORD)v12;
            if (v13 >= 1)
              bzero(v12, 4 * (((unint64_t)v13 >> 2) - ((unint64_t)v13 > 3)) + 4);
            BaseAddress = (char *)CVPixelBufferGetBaseAddress(v9);
            v15 = 0;
            v16 = 0;
            v17 = v8 + 4 * v11 * (v6 >> 2);
            v18 = &BaseAddress[4 * (v8 + v6 * Width)];
            v19 = *(_QWORD *)(a1 + 56);
            do
            {
              v20 = 0;
              do
              {
                v21 = v18[v20 + 1] & 0xF0 | ((((unint64_t)v18[v20] >> 4) & 0xF) << 8) | ((unint64_t)v18[v20 + 2] >> 4);
                v22 = *(_DWORD *)(v19 + 4 * v21);
                *(_DWORD *)(v19 + 4 * v21) = v22 + 1;
                if (v22 + 1 > v15)
                  v15 = v22 + 1;
                v23 = v20 >= 0xC;
                v20 += 4;
              }
              while (!v23);
              v18 += (4 * Width);
              v23 = v16 >= 0xC;
              v16 += 4;
            }
            while (!v23);
            v24 = 0;
            v25 = 0;
            v26 = 0;
            v27 = 0;
            v28 = 0;
            v29 = 0;
            v30 = ((double)v15 * 0.8);
            do
            {
              v31 = *(unsigned int *)(v19 + 4 * v25);
              if (v31 >= v30)
              {
                v26 += v31;
                v27 += v31 * ((v25 >> 4) & 0xF0 | 8);
                v28 += v31 * (v25 & 0xF0 | 8);
                v29 += v31 * (v24 & 0xF0 | 8);
              }
              ++v25;
              v24 += 16;
            }
            while (v25 != 4096);
            *(_BYTE *)(*(_QWORD *)(a1 + 32) + v17) = (int)((float)((float)v27 / (float)v26) + 0.5);
            *(_BYTE *)(*(_QWORD *)(a1 + 32) + (v17 | 1)) = (int)((float)((float)v28 / (float)v26) + 0.5);
            *(_BYTE *)(*(_QWORD *)(a1 + 32) + (v17 | 2)) = (int)((float)((float)v29 / (float)v26) + 0.5);
            *(_BYTE *)(*(_QWORD *)(a1 + 32) + (v17 | 3)) = -1;
            v8 += 4;
            v7 = *(_DWORD *)(a1 + 8);
            if (v8 >= 4 * v7)
            {
              v5 = *(_DWORD *)(a1 + 12);
              goto LABEL_25;
            }
          }
          v4 = 4294943593;
        }
      }
    }
  }
  sub_1B6773B7C((const void **)&pixelBufferOut);
  return v4;
}

void sub_1B6773B44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  sub_1B67704D8(&a9);
  sub_1B6773B7C(&a10);
  _Unwind_Resume(a1);
}

const void **sub_1B6773B7C(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void sub_1B6773BAC()
{
  sub_1B6773C1C("vector");
}

void *sub_1B6773BC0(unint64_t a1)
{
  if (a1 >> 62)
    sub_1B6773BF4();
  return operator new(4 * a1);
}

void sub_1B6773BF4()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, (struct type_info *)&unk_1E6A14B58, MEMORY[0x1E0DE4390]);
}

void sub_1B6773C1C(const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1B6773C6C(exception, a1);
  __cxa_throw(exception, (struct type_info *)&unk_1E6A14B20, MEMORY[0x1E0DE42D0]);
}

void sub_1B6773C58(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_1B6773C6C(std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5020] + 16);
  return result;
}

void sub_1B6773C90(unint64_t *a1, size_t a2)
{
  char *v4;
  char *v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char v15;

  v5 = (char *)a1[1];
  v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    v6 = *a1;
    v7 = &v5[-*a1];
    v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0)
      sub_1B6773BAC();
    v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8)
      v8 = 2 * v9;
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if (v10)
      v11 = (unint64_t)operator new(v10);
    else
      v11 = 0;
    v12 = &v7[v11];
    v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      v11 = (unint64_t)v12;
    }
    else
    {
      v14 = &v5[~v6];
      do
      {
        v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
      operator delete(v5);
  }
}

const void **sub_1B6773DB4(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **sub_1B6773DE4(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t sub_1B6773E14(unsigned int a1, int *a2, _BYTE *a3, int a4, int a5, int a6)
{
  uint64_t v6;
  unsigned int v7;
  char *v8;
  unsigned int v9;
  char *v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  char *v16;
  int v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t result;
  _BYTE v23[3];

  v6 = *a2;
  if (v6 >= 0x1000)
    exit(1);
  v7 = (a1 >> 20) & 0x3FF;
  v8 = (char *)&unk_1B691CDE4;
  v9 = (a1 >> 10) & 0x3FF;
  if (v9 <= 0x43)
    v10 = (char *)&unk_1B691CDE4;
  else
    v10 = (char *)&unk_1B691DDE4;
  v11 = (int)(v9 + v10[v6]) >> 2;
  if (v11 >= 255)
    LOBYTE(v11) = -1;
  if (v11 > 0x11u)
  {
    v14 = a1 & 0x3FF;
    v15 = 512 - v14;
    if (v14 >= 0x200)
      v15 = v14 - 512;
    if (v15 <= 3)
      v16 = (char *)&unk_1B691CDE4;
    else
      v16 = (char *)&unk_1B691DDE4;
    v17 = v16[((_WORD)v6 + 1) & 0xFFF];
    v12 = ((v14 + v17) & ~((int)(v14 + v17) >> 31)) >> 2;
    if (v12 >= 0xFF)
      LOBYTE(v12) = -1;
    v6 = ((_WORD)v6 + 2) & 0xFFF;
    v18 = 512 - v7;
    if (v7 >= 0x200)
      v18 = v7 - 512;
    if (v18 > 3)
      v8 = (char *)&unk_1B691DDE4;
    v19 = ((v7 + v8[v6]) & ~((int)(v7 + v8[v6]) >> 31)) >> 2;
    if (v19 >= 0xFF)
      LOBYTE(v13) = -1;
    else
      LOBYTE(v13) = v19;
  }
  else
  {
    v12 = a1 >> 2;
    LOWORD(v6) = (v6 + 2) & 0xFFF;
    v13 = v7 >> 2;
  }
  v20 = 0;
  result = 0;
  v23[0] = v12;
  v23[1] = v11;
  *a2 = ((_WORD)v6 + 1) & 0xFFF;
  v23[2] = v13;
  do
  {
    if (a4 + (int)v20 >= a5 && a4 + (int)v20 <= a6)
    {
      *a3++ = v23[v20];
      result = (result + 1);
    }
    ++v20;
  }
  while (v20 != 3);
  dword_1EF138768 = ((_WORD)dword_1EF138768 + (v11 & 1)) & 0xFFF;
  return result;
}

float sub_1B6773F70(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7, _WORD *a8, float result, float a10, double a11, float a12)
{
  uint64_t v12;
  float v13;
  float v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  unsigned __int16 *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  float v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  unsigned __int16 *v43;
  int v44;
  int v45;
  char v46;
  _QWORD v47[32];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v12 = a1[1];
  LOWORD(a12) = a1[3];
  v13 = (float)LODWORD(a12);
  v14 = (float)v12 / v13;
  if (a6)
  {
    v15 = a6;
    do
    {
      a10 = v14 + a10;
      --v15;
    }
    while (v15);
  }
  if (a6 < a7)
  {
    LOWORD(v13) = *a1;
    v16 = a1[2];
    v17 = v12 - 1;
    v18 = a4 + a6 * a5;
    v19 = v17 * a3;
    v20 = (float)LODWORD(v13) / (float)v16;
    v21 = ((unsigned __int16)*((_DWORD *)a1 + 4) + (_WORD)v16 * (_WORD)a6) & 0xFFF;
    do
    {
      v22 = ((int)a10 * a3) & ~(((int)a10 * a3) >> 63);
      v23 = a1[6];
      v24 = &v47[v23];
      *(v24 - 1) = v22;
      v25 = v22 + a3;
      if (v19 < v25)
        v25 = v17 * a3;
      *v24 = v25;
      if (v23 >= 2)
      {
        v26 = v23;
        v27 = &v47[v23 + 1];
        do
        {
          v47[v26 - 2] = (v47[v26 - 1] - a3) & ~((v47[v26 - 1] - a3) >> 63);
          v28 = *(v27 - 1) + a3;
          if (v19 < v28)
            v28 = v17 * a3;
          *v27++ = v28;
          --v26;
        }
        while (v26 != 1);
      }
      if (*a1)
      {
        v29 = 0;
        v30 = &a1[32 * (uint64_t)(int)vcvts_n_s32_f32(a10 - (float)(int)a10, 7uLL)];
        do
        {
          v31 = a1[6];
          if (a1[6])
          {
            v32 = 0;
            v33 = a1[6];
            do
            {
              v32 += v30[v33 + 15] * *(unsigned __int8 *)(a2 + ((2 * v29) | 1) + v47[v33 - 1])
                   + v30[v31 + 16] * *(unsigned __int8 *)(a2 + ((2 * v29) | 1) + v47[v31]);
              ++v31;
              --v33;
            }
            while (v33);
          }
          else
          {
            v32 = 0;
          }
          a8[v29++] = v32;
        }
        while (v29 < *a1);
        LODWORD(v23) = a1[6];
      }
      if ((_DWORD)v23)
      {
        v34 = 0;
        v35 = 0x7FFFFFFFFFFFFFFFLL;
        do
        {
          a8[v35] = *a8;
          a8[v34 + *a1] = a8[*a1 - 1];
          ++v34;
          --v35;
        }
        while (v34 < a1[6]);
      }
      if (a1[2])
      {
        v36 = 0;
        v37 = result;
        do
        {
          v38 = a1[6];
          if (a1[6])
          {
            v39 = 0;
            v40 = 0;
            v41 = 0;
            v42 = -v38;
            v43 = &a1[32 * (uint64_t)(int)vcvts_n_s32_f32(v37 - (float)(int)v37, 7uLL) + v38];
            do
            {
              v41 += (__int16)a8[(int)v37 + v40] * (__int16)v43[v40 + 15]
                   + (__int16)a8[(int)v37 + 1 + v39] * (__int16)v43[v39 + 16];
              --v40;
              ++v39;
            }
            while (v42 != v40);
          }
          else
          {
            v41 = 0;
          }
          v44 = byte_1B691EDE4[v21] + ((v41 + 512) >> 10);
          v21 = ((_WORD)v21 + 1) & 0xFFF;
          v45 = v44 >> 2;
          if (v44 >> 2 >= 255)
            LOBYTE(v45) = -1;
          if (v44 >= 0)
            v46 = v45;
          else
            v46 = 0;
          *(_BYTE *)(v18 + 2 * v36 + 1) = v46;
          v37 = v20 + v37;
          ++v36;
        }
        while (v36 < a1[2]);
      }
      a10 = v14 + a10;
      v18 += a5;
      ++a6;
    }
    while (a6 != a7);
  }
  return result;
}

float sub_1B6774274(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7, uint64_t a8, float result, float a10)
{
  uint64_t v10;
  unsigned int v11;
  float v12;
  float v13;
  unsigned int v14;
  uint64_t v15;
  _WORD *v16;
  uint64_t v17;
  uint64_t v18;
  float v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  unsigned __int16 *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  unint64_t v34;
  _WORD *v35;
  uint64_t v36;
  unint64_t v37;
  float v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  int v42;
  int v43;
  signed int v44;
  uint64_t v45;
  int v46;
  int v47;
  unsigned __int8 *v48;
  int v49;
  int v50;
  int v51;
  char v52;
  _BYTE *v53;
  _BYTE *v54;
  int v55;
  int v56;
  char v57;
  _BYTE v58[8];
  _QWORD *v59;
  _BYTE v60[256];
  _QWORD v61[33];

  v61[31] = *MEMORY[0x1E0C80C00];
  v10 = a1[1];
  v11 = a1[3];
  v12 = (float)v11;
  v13 = (float)v10 / (float)v11;
  if (a6)
  {
    v14 = a6;
    do
    {
      a10 = v13 + a10;
      --v14;
    }
    while (v14);
  }
  if (a6 < a7)
  {
    LOWORD(v12) = *a1;
    v15 = v10 - 2;
    v16 = (_WORD *)(a8 + 2 * a1[4112]);
    v17 = a4 + 2 * a5 * a6;
    v18 = v15 * a3;
    v19 = (float)LODWORD(v12) / (float)a1[2];
    v20 = ((_WORD)v11 * a1[2] + (a1[2] >> 1) * (_WORD)a6 + (unsigned __int16)*((_DWORD *)a1 + 4)) & 0xFFF;
    v21 = 2 * a3;
    v59 = v61;
    do
    {
      v22 = (2 * (int)a10 * a3) & ~((2 * (int)a10 * a3) >> 63);
      v23 = a1[6];
      v24 = &v60[8 * v23];
      *(v24 - 1) = v22;
      v25 = v22 + v21;
      if (v18 < v25)
        v25 = v18;
      *v24 = v25;
      if (v23 >= 2)
      {
        v26 = 8 * v23;
        v27 = &v59[v23];
        do
        {
          *(_QWORD *)&v58[v26] = (*(_QWORD *)&v58[v26 + 8] - v21) & ~((*(_QWORD *)&v58[v26 + 8] - v21) >> 63);
          v28 = *(v27 - 1) + v21;
          if (v18 < v28)
            v28 = v18;
          *v27++ = v28;
          v26 -= 8;
        }
        while (v26 != 8);
      }
      if (*a1)
      {
        v29 = 0;
        v30 = &a1[32 * (uint64_t)(int)vcvts_n_s32_f32(a10 - (float)(int)a10, 7uLL)];
        do
        {
          v31 = a1[6];
          if (a1[6])
          {
            v32 = 0;
            v33 = a1[6];
            do
            {
              v32 += v30[v33 + 15] * *(unsigned __int8 *)(a2 + a3 + *(_QWORD *)&v60[8 * v33 - 8] + 2 * v29)
                   + v30[v31 + 16] * *(unsigned __int8 *)(a2 + a3 + *(_QWORD *)&v60[8 * v31] + 2 * v29);
              ++v31;
              --v33;
            }
            while (v33);
          }
          else
          {
            v32 = 0;
          }
          v16[v29++] = v32;
        }
        while (v29 < *a1);
        LODWORD(v23) = a1[6];
      }
      if ((_DWORD)v23)
      {
        v34 = 0;
        v35 = v16 - 1;
        v36 = 1;
        do
        {
          *(v35 - 1) = *v16;
          *v35 = v16[1];
          v35 -= 2;
          v16[v36 - 1 + *a1] = v16[*a1 - 2];
          v16[v36 + *a1] = v16[*a1 - 1];
          ++v34;
          v36 += 2;
        }
        while (v34 < a1[6]);
      }
      if (a1[2] >= 2u)
      {
        v37 = 0;
        v38 = result;
        do
        {
          v39 = a1[6];
          if (a1[6])
          {
            v40 = 0;
            v41 = 0;
            v42 = 0;
            v43 = (int)v38;
            v44 = vcvts_n_s32_f32(v38 - (float)(int)v38, 7uLL);
            do
            {
              v45 = (uint64_t)&a1[32 * (uint64_t)v44 + 16];
              v46 = *(__int16 *)(v45 + 2 * (v39 + ~v40));
              LODWORD(v45) = *(__int16 *)(v45 + 2 * (v40 + v39));
              v47 = 2 * (v40 + v43);
              v42 += (__int16)v16[2 * (v43 - (int)v40)] * v46 + (__int16)v16[v47 + 2] * (_DWORD)v45;
              v41 += (__int16)v16[2 * (v43 - (int)v40++) + 1] * v46 + (__int16)v16[v47 + 3] * (_DWORD)v45;
            }
            while (v40 != v39);
          }
          else
          {
            v42 = 0;
            v41 = 0;
          }
          v48 = &byte_1B691EDE4[v20];
          v49 = (v41 << 6) + (v48[1] << 16);
          v20 = ((_WORD)v20 + 2) & 0xFFF;
          v50 = (v42 << 6) + (*v48 << 16) + 0x8000;
          v51 = v50 >> 18;
          if (v50 >> 18 >= 255)
            LOBYTE(v51) = -1;
          if (v50 >= 0)
            v52 = v51;
          else
            v52 = 0;
          v53 = (_BYTE *)(v17 + 4 * v37);
          *v53 = v52;
          v54 = (_BYTE *)(v17 + a5 + 4 * v37);
          *v54 = v52;
          v55 = v49 + 0x8000;
          v56 = v55 >> 18;
          if (v55 >> 18 >= 255)
            LOBYTE(v56) = -1;
          if (v55 >= 0)
            v57 = v56;
          else
            v57 = 0;
          v53[2] = v57;
          v54[2] = v57;
          v38 = v19 + v38;
          ++v37;
        }
        while (v37 < (unint64_t)a1[2] >> 1);
      }
      a10 = v13 + a10;
      v17 += 2 * a5;
      ++a6;
    }
    while (a6 != a7);
  }
  return result;
}

void sub_1B677463C(uint64_t a1)
{
  unsigned __int16 *v2;
  unsigned int v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;

  v2 = (unsigned __int16 *)(a1 + 8224);
  if (!*(_QWORD *)(a1 + 8280))
  {
    *(_WORD *)(a1 + 8226) = 0;
    goto LABEL_12;
  }
  v3 = *(unsigned __int16 *)(a1 + 8226);
  if (!*(_WORD *)(a1 + 8226))
  {
    *(_WORD *)(a1 + 8226) = 0;
LABEL_11:
    MEMORY[0x1BCC9811C]();
    goto LABEL_12;
  }
  v4 = 0;
  v5 = 16;
  do
  {
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8280) + v5);
    if (v6)
    {
      MEMORY[0x1BCC9811C](v6 - 2 * *v2, 0x1000C80BDFB0063);
      v3 = v2[1];
    }
    ++v4;
    v5 += 24;
  }
  while (v4 < v3);
  v7 = *(_QWORD *)(a1 + 8280);
  v2[1] = 0;
  if (v7)
    goto LABEL_11;
LABEL_12:
  *(_QWORD *)(a1 + 8280) = 0;
  v8 = *(NSObject **)(a1 + 8296);
  if (v8)
  {
    dispatch_release(v8);
    *(_QWORD *)(a1 + 8296) = 0;
  }
}

uint64_t sub_1B6774700(float **a1)
{
  float *v2;
  uint64_t v3;
  void (*v4)(_QWORD *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, float *, float, float);
  uint64_t v5;
  _QWORD *v6;
  uint64_t (*v7)(_QWORD *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, float *, float, float);
  uint64_t v8;
  _QWORD *v9;

  v2 = *a1;
  v3 = *(_QWORD *)*a1;
  v4 = *(void (**)(_QWORD *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, float *, float, float))(v3 + 8304);
  v5 = *(_QWORD *)(v3 + 8312);
  v6 = (_QWORD *)(v3 + (v5 >> 1));
  if ((v5 & 1) != 0)
    v4 = *(void (**)(_QWORD *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, float *, float, float))(*v6 + v4);
  v4(v6, *((_QWORD *)v2 + 1), *((_QWORD *)v2 + 2), *((_QWORD *)v2 + 3), *((_QWORD *)v2 + 4), *((unsigned __int16 *)a1 + 4), *((unsigned __int16 *)a1 + 5), a1[2], v2[10], v2[11]);
  v7 = *(uint64_t (**)(_QWORD *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, float *, float, float))(*(_QWORD *)v2 + 8320);
  v8 = *(_QWORD *)(*(_QWORD *)v2 + 8328);
  v9 = (_QWORD *)(*(_QWORD *)v2 + (v8 >> 1));
  if ((v8 & 1) != 0)
    v7 = *(uint64_t (**)(_QWORD *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, float *, float, float))(*v9 + v7);
  return v7(v9, *((_QWORD *)v2 + 1), *((_QWORD *)v2 + 2), *((_QWORD *)v2 + 3), *((_QWORD *)v2 + 4), *((unsigned __int16 *)a1 + 4) >> 1, *((unsigned __int16 *)a1 + 5) >> 1, a1[2], v2[10], v2[11]);
}

uint64_t PassthroughEncoder_CreateInstance(int a1, const __CFAllocator *a2, CFTypeRef *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t DerivedStorage;
  dispatch_semaphore_t v9;
  uint8_t v11[16];
  uint8_t buf[8];
  CFTypeRef cf;

  cf = 0;
  VTVideoEncoderGetClassID();
  v6 = CMDerivedObjectCreate();
  if ((_DWORD)v6)
  {
    v7 = v6;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "PT: failed to create derived object\n", buf, 2u);
    }
  }
  else
  {
    DerivedStorage = CMBaseObjectGetDerivedStorage();
    *(_DWORD *)(DerivedStorage + 48) = a1;
    *(_QWORD *)DerivedStorage = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v9 = dispatch_semaphore_create(1);
    *(_QWORD *)(DerivedStorage + 64) = v9;
    if (v9)
    {
      if (a2)
      {
        CFRetain(a2);
        v7 = 0;
        *(_QWORD *)(DerivedStorage + 16) = a2;
      }
      else
      {
        v7 = 0;
      }
      goto LABEL_13;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v11 = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "PT: Failed to create fig semaphore\n", v11, 2u);
    }
    v7 = 4294954510;
  }
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
LABEL_13:
  *a3 = cf;
  return v7;
}

uint64_t sub_1B6774904(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  _QWORD *DerivedStorage;

  VTVideoEncoderGetCMBaseObject();
  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
  DerivedStorage[4] = a2;
  DerivedStorage[5] = a3;
  DerivedStorage[7] = a4;
  if (a4)
    CFRetain(a4);
  return sub_1B6775A74((uint64_t)DerivedStorage);
}

uint64_t sub_1B6774954(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, __int128 *a5, uint64_t a6, uint64_t a7)
{
  uint64_t DerivedStorage;
  uint64_t v14;
  unsigned int (*v15)(uint64_t, uint64_t, uint64_t, uint8_t *, __int128 *, uint64_t, uint64_t);
  __int128 v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint8_t buf[16];
  uint64_t v24;

  VTVideoEncoderGetCMBaseObject();
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(DerivedStorage + 64), 0xFFFFFFFFFFFFFFFFLL);
  if (*(_BYTE *)(DerivedStorage + 25) || (v14 = sub_1B6774FD8(DerivedStorage), !(_DWORD)v14))
  {
    v14 = *(_QWORD *)(DerivedStorage + 8);
    if (v14)
    {
      v19 = *a4;
      v20 = *((_QWORD *)a4 + 2);
      v17 = *a5;
      v18 = *((_QWORD *)a5 + 2);
      v15 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint8_t *, __int128 *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 16);
      if (v15 && (*(_OWORD *)buf = v19, v24 = v20, v21 = v17, v22 = v18, !v15(v14, a2, a3, buf, &v21, a6, a7)))
      {
        v14 = 0;
      }
      else
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "PT: No real codec!!\n", buf, 2u);
        }
        v14 = 4294954514;
      }
    }
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(DerivedStorage + 64));
  return v14;
}

uint64_t sub_1B6774AB4(uint64_t a1, __int128 *a2)
{
  uint64_t DerivedStorage;
  uint64_t v4;
  uint64_t (*v5)(uint64_t, __int128 *);
  uint64_t v6;
  __int128 v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;

  VTVideoEncoderGetCMBaseObject();
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(DerivedStorage + 64), 0xFFFFFFFFFFFFFFFFLL);
  v4 = *(_QWORD *)(DerivedStorage + 8);
  if (v4)
  {
    v8 = *a2;
    v9 = *((_QWORD *)a2 + 2);
    v5 = *(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
    if (v5)
    {
      v10 = v8;
      v11 = v9;
      v6 = v5(v4, &v10);
    }
    else
    {
      v6 = 4294954514;
    }
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(DerivedStorage + 64));
  }
  else
  {
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(DerivedStorage + 64));
    return 4294954514;
  }
  return v6;
}

uint64_t sub_1B6774B68(uint64_t a1, _QWORD *a2)
{
  uint64_t DerivedStorage;
  uint64_t v4;
  uint64_t (*v5)(uint64_t, _QWORD *);
  uint64_t result;
  int context;

  VTVideoEncoderGetCMBaseObject();
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v4 = *(_QWORD *)(DerivedStorage + 8);
  if (v4)
  {
    v5 = *(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
    if (v5)
      return v5(v4, a2);
    else
      return 4294954514;
  }
  else
  {
    context = *(_DWORD *)(DerivedStorage + 48);
    if (qword_1EF138778 != -1)
      dispatch_once_f(&qword_1EF138778, &context, (dispatch_function_t)sub_1B6774CF4);
    result = 4294954514;
    if (a2 && qword_1EF138770)
    {
      CFRetain((CFTypeRef)qword_1EF138770);
      result = 0;
      *a2 = qword_1EF138770;
    }
  }
  return result;
}

uint64_t sub_1B6774C2C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t);

  VTVideoEncoderGetCMBaseObject();
  v5 = *(_QWORD *)(CMBaseObjectGetDerivedStorage() + 8);
  if (v5
    && (v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 48)) != 0)
  {
    return v6(v5, a2, a3);
  }
  else
  {
    return 4294954514;
  }
}

uint64_t sub_1B6774C98()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t (*v2)(uint64_t);

  VTVideoEncoderGetCMBaseObject();
  v0 = *(_QWORD *)(CMBaseObjectGetDerivedStorage() + 8);
  if (v0
    && (v1 = *(_QWORD **)(CMBaseObjectGetVTable() + 16), *v1 >= 2uLL)
    && (v2 = (uint64_t (*)(uint64_t))v1[7]) != 0)
  {
    return v2(v0);
  }
  else
  {
    return 4294954514;
  }
}

void sub_1B6774CF4(int *a1)
{
  int v1;
  const __CFString *v4;
  __CFDictionary *Mutable;
  int v6;
  int v7;
  CFTypeRef v8;
  void (*v9)(CFTypeRef, CFDictionaryRef *);
  CFMutableDictionaryRef v10;
  CFTypeRef v11;
  CFDictionaryRef v12;
  CFDictionaryRef theDict;

  v1 = *a1;
  v12 = 0;
  theDict = 0;
  v11 = 0;
  if (v1 == 1684632424 || v1 == 1752589105 || v1 == 1718908520)
    v4 = CFSTR("com.apple.videotoolbox.videoencoder.hevc");
  else
    v4 = CFSTR("com.apple.videotoolbox.videoencoder.h264");
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CEDCF8], v4);
  if (sub_1B6774F60())
  {
    if (v1 == 1684632424 || v1 == 1752589105 || v1 == 1718908520)
      VTVPParavirtualizedHEVCVideoEncoder_CreateInstance();
    else
      VTVPParavirtualizedH264VideoEncoder_CreateInstance();
  }
  else
  {
    VTSelectAndCreateVideoEncoderInstance();
  }
  if (Mutable)
    CFRelease(Mutable);
  v6 = 1718908515;
  if (v1 == 1684632424 || v1 == 1752589105 || v1 == 1718908520)
    v6 = 1718908520;
  v7 = sub_1B67A0F84(v6, 0, &v11);
  v8 = v11;
  if (!v7)
  {
    if (v11)
    {
      v9 = *(void (**)(CFTypeRef, CFDictionaryRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
      if (v9)
        v9(v8, &theDict);
    }
  }
  if (v8)
    CFRelease(v8);
  v10 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (theDict)
  {
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_1B6774FC4, v10);
    CFRelease(theDict);
  }
  if (v12)
  {
    CFDictionaryApplyFunction(v12, (CFDictionaryApplierFunction)sub_1B6774FC4, v10);
    CFRelease(v12);
  }
  qword_1EF138770 = (uint64_t)v10;
}

uint64_t sub_1B6774F60()
{
  uint64_t result;

  result = _os_feature_enabled_impl();
  if ((_DWORD)result)
  {
    if (qword_1EDBB4CB8 != -1)
      dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
    return dword_1EDBB4CC4 == 255;
  }
  return result;
}

void sub_1B6774FC4(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionarySetValue(theDict, key, value);
}

uint64_t sub_1B6774FD8(uint64_t a1)
{
  _QWORD *v1;
  uint64_t Instance;
  const __CFNumber *Value;
  const __CFNumber *v5;
  CFTypeID TypeID;
  int v7;
  int v8;
  NSObject *v9;
  const char *v10;
  int v11;
  int v12;
  const __CFString *v13;
  int v14;
  NSObject *v15;
  const char *v16;
  uint32_t v17;
  const __CFString *v19;
  const __CFString *v20;
  int v21;
  __CFDictionary *Mutable;
  __CFDictionary *v23;
  int v24;
  int v25;
  uint64_t VideoEncoderInstance;
  int v27;
  int v28;
  const char *v29;
  int v30;
  const char *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  size_t v36;
  uint64_t valuePtr;
  uint8_t buf[4];
  int v39;
  __int16 v40;
  _BYTE v41[14];
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v1 = (_QWORD *)(a1 + 8);
  if (*(_QWORD *)(a1 + 8))
    return 0;
  v36 = 4;
  valuePtr = 0;
  sysctlbyname("hw.cpufamily", &valuePtr, &v36, 0, 0);
  Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)a1, (const void *)*MEMORY[0x1E0CED248]);
  if (Value)
  {
    v5 = Value;
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v5))
      CFNumberGetValue(v5, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  }
  LODWORD(valuePtr) = 1176831186;
  if (HIDWORD(valuePtr) <= 0x2B)
  {
    if (((1 << SBYTE4(valuePtr)) & 0xC8000000002) != 0)
    {
      v7 = *(_DWORD *)(a1 + 48);
      if (v7 == 1684632424 || v7 == 1752589105 || v7 == 1718908520)
      {
        Instance = sub_1B67A0F84(1718908520, *(_QWORD *)(a1 + 16), v1);
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          goto LABEL_34;
        v8 = HIDWORD(valuePtr);
        if (qword_1EDBB4CB8 == -1)
          goto LABEL_13;
        goto LABEL_99;
      }
      if (HIDWORD(valuePtr) == 43)
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          v39 = 43;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "PT: TrafficLight usage (%d) only supported in HEVC\n", buf, 8u);
        }
        return 4294954381;
      }
      if (qword_1EDBB4CB8 != -1)
        dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
      if ((dword_1EDBB4CC4 - 7) >= 0xB)
      {
        if (dword_1EDBB4CC4 == 6)
        {
          Instance = H264VideoEncoder_CreateInstance(1718908515, *(_QWORD *)(a1 + 16), v1);
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          {
            v32 = HIDWORD(valuePtr);
            if (qword_1EDBB4CB8 != -1)
              dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
            *(_DWORD *)buf = 67109376;
            v39 = v32;
            v40 = 1024;
            *(_DWORD *)v41 = dword_1EDBB4CC4;
            v9 = MEMORY[0x1E0C81028];
            v10 = "PT: Usage = %d, use 'ftvc' codec with VCP_H264_Legacy path,                                           "
                  "              device type = %d\n";
            goto LABEL_33;
          }
          goto LABEL_34;
        }
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "PT: Unknown device type\n", buf, 2u);
        }
      }
      v19 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("ForceBaroloDoupi"), CFSTR("com.apple.VideoProcessing"));
      v20 = v19;
      if (v19 && CFStringCompare(v19, CFSTR("1"), 0) == kCFCompareEqualTo)
      {
        Instance = H264VideoEncoder_CreateInstance(1718908515, *(_QWORD *)(a1 + 16), v1);
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          v27 = HIDWORD(valuePtr);
          if (qword_1EDBB4CB8 != -1)
          {
            v35 = HIDWORD(valuePtr);
            dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
            v27 = v35;
          }
          *(_DWORD *)buf = 67109376;
          v39 = v27;
          v40 = 1024;
          *(_DWORD *)v41 = dword_1EDBB4CC4;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "PT: Usage = %d, use 'ftvc' codec with VCP_H264_Legacy path,                                                            device type = %d\n", buf, 0xEu);
        }
        goto LABEL_50;
      }
      Instance = sub_1B67A0F84(1718908515, *(_QWORD *)(a1 + 16), v1);
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        v21 = HIDWORD(valuePtr);
        if (qword_1EDBB4CB8 != -1)
        {
          v34 = HIDWORD(valuePtr);
          dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
          v21 = v34;
        }
        *(_DWORD *)buf = 67109376;
        v39 = v21;
        v40 = 1024;
        *(_DWORD *)v41 = dword_1EDBB4CC4;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "PT: Usage = %d, use 'ftvc' codec with VCP_H264 path,                                                             device type = %d\n", buf, 0xEu);
      }
      if (v20)
LABEL_50:
        CFRelease(v20);
LABEL_34:
      if ((_DWORD)Instance)
      {
LABEL_35:
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
LABEL_38:
          *v1 = 0;
          return Instance;
        }
        *(_DWORD *)buf = 67109120;
        v39 = Instance;
        v15 = MEMORY[0x1E0C81028];
        v16 = "PT: Error %d opening real codec!\n";
        v17 = 8;
LABEL_37:
        _os_log_impl(&dword_1B676B000, v15, OS_LOG_TYPE_DEFAULT, v16, buf, v17);
        goto LABEL_38;
      }
      goto LABEL_93;
    }
    if (((1 << SBYTE4(valuePtr)) & 0x4000100000) != 0)
    {
      v11 = *(_DWORD *)(a1 + 48);
      if (v11 != 1684632424 && v11 != 1752589105 && v11 != 1718908520)
      {
        Instance = H264VideoEncoder_CreateInstance(1718908515, *(_QWORD *)(a1 + 16), v1);
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          goto LABEL_34;
        v14 = HIDWORD(valuePtr);
        if (qword_1EDBB4CB8 != -1)
          dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
        *(_DWORD *)buf = 67109376;
        v39 = v14;
        v40 = 1024;
        *(_DWORD *)v41 = dword_1EDBB4CC4;
        v9 = MEMORY[0x1E0C81028];
        v10 = "PT: Usage = %d, use 'ftvc' codec with VCP_H264_Legacy path,                                               "
              "  device type = %d\n";
        goto LABEL_33;
      }
      Instance = sub_1B67A0F84(1718908520, *(_QWORD *)(a1 + 16), v1);
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        goto LABEL_34;
      v8 = HIDWORD(valuePtr);
      if (qword_1EDBB4CB8 == -1)
        goto LABEL_13;
LABEL_99:
      dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
LABEL_13:
      *(_DWORD *)buf = 67109376;
      v39 = v8;
      v40 = 1024;
      *(_DWORD *)v41 = dword_1EDBB4CC4;
      v9 = MEMORY[0x1E0C81028];
      v10 = "PT: Usage = %d, use 'ftvh' codec with VCP_HEVC path,                                                 device type = %d\n";
LABEL_33:
      _os_log_impl(&dword_1B676B000, v9, OS_LOG_TYPE_DEFAULT, v10, buf, 0xEu);
      goto LABEL_34;
    }
  }
  v12 = *(_DWORD *)(a1 + 48);
  if (v12 == 1684632424 || v12 == 1752589105 || v12 == 1718908520)
    v13 = CFSTR("com.apple.videotoolbox.videoencoder.hevc");
  else
    v13 = CFSTR("com.apple.videotoolbox.videoencoder.h264");
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v23 = Mutable;
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CEDCF8], v13);
    v24 = sub_1B6774F60();
    v25 = *(_DWORD *)(a1 + 48);
    if (v24)
    {
      if (v25 == 1684632424 || v25 == 1752589105 || v25 == 1718908520)
        VideoEncoderInstance = VTVPParavirtualizedHEVCVideoEncoder_CreateInstance();
      else
        VideoEncoderInstance = VTVPParavirtualizedH264VideoEncoder_CreateInstance();
    }
    else
    {
      VideoEncoderInstance = VTSelectAndCreateVideoEncoderInstance();
    }
    Instance = VideoEncoderInstance;
    CFRelease(v23);
    if (!(_DWORD)Instance)
    {
      if (*v1)
      {
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
LABEL_94:
          Instance = sub_1B6775A74(a1);
          if ((_DWORD)Instance)
          {
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 67109120;
              v39 = Instance;
              _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "PT: Error %d starting real codec!\n", buf, 8u);
            }
          }
          else
          {
            CFDictionaryApplyFunction(*(CFDictionaryRef *)a1, (CFDictionaryApplierFunction)sub_1B6775B04, (void *)a1);
          }
          return Instance;
        }
        v30 = *(_DWORD *)(a1 + 48);
        if (v30 == 1684632424 || v30 == 1752589105 || v30 == 1718908520)
          v31 = "hvc1";
        else
          v31 = "avc1";
        v33 = HIDWORD(valuePtr);
        if (qword_1EDBB4CB8 != -1)
          dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
        *(_DWORD *)buf = 67109634;
        v39 = v33;
        v40 = 2080;
        *(_QWORD *)v41 = v31;
        *(_WORD *)&v41[8] = 1024;
        *(_DWORD *)&v41[10] = dword_1EDBB4CC4;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "PT: Usage = %d, passthrough to '%s' codec, device type = %d\n", buf, 0x18u);
LABEL_93:
        if (!*v1)
        {
          Instance = 4294954510;
          goto LABEL_35;
        }
        goto LABEL_94;
      }
      Instance = 4294954510;
    }
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      goto LABEL_38;
    v28 = *(_DWORD *)(a1 + 48);
    if (v28 == 1684632424 || v28 == 1752589105 || v28 == 1718908520)
      v29 = "hvc1";
    else
      v29 = "avc1";
    *(_DWORD *)buf = 67109634;
    v39 = HIDWORD(valuePtr);
    v40 = 1024;
    *(_DWORD *)v41 = Instance;
    *(_WORD *)&v41[4] = 2080;
    *(_QWORD *)&v41[6] = v29;
    v15 = MEMORY[0x1E0C81028];
    v16 = "PT: Usage = %d, Error %d opening real passthrough %s' codec!\n";
    v17 = 24;
    goto LABEL_37;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "PT: OpenActualCodec() failed to create encoderSpecification\n", buf, 2u);
  }
  return 4294954510;
}

uint64_t sub_1B6775A74(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t (*v7)(uint64_t, uint64_t, uint64_t, uint64_t);

  if (*(_BYTE *)(a1 + 25))
    return 0;
  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return 0;
  v4 = *(_QWORD *)(a1 + 32);
  if (!v4)
    return 0;
  v5 = *(_QWORD *)(a1 + 40);
  v6 = *(_QWORD *)(a1 + 56);
  v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
  if (!v7)
    return 4294954514;
  result = v7(v3, v4, v5, v6);
  if (!(_DWORD)result)
    *(_BYTE *)(a1 + 25) = 1;
  return result;
}

void sub_1B6775B04(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  void (*v6)(uint64_t, CFDictionaryRef *);
  uint64_t CMBaseObject;
  void (*v8)(uint64_t, const void *, uint64_t);
  CFDictionaryRef theDict;

  theDict = 0;
  v5 = *(_QWORD *)(a3 + 8);
  v6 = *(void (**)(uint64_t, CFDictionaryRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
  if (v6)
  {
    v6(v5, &theDict);
    if (theDict)
    {
      if (CFDictionaryContainsKey(theDict, a1))
      {
        CMBaseObject = VTVideoEncoderGetCMBaseObject();
        v8 = *(void (**)(uint64_t, const void *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
        if (v8)
          v8(CMBaseObject, a1, a2);
      }
      if (theDict)
        CFRelease(theDict);
    }
  }
}

uint64_t sub_1B6775BAC(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t CMBaseObject;
  uint64_t (*v6)(uint64_t, uint64_t);

  if (!*(_QWORD *)(CMBaseObjectGetDerivedStorage() + 8))
    return 0;
  VTVideoEncoderGetCMBaseObject();
  v3 = *(_QWORD *)(CMBaseObjectGetVTable() + 8);
  if (!*(_QWORD *)(v3 + 16))
    return 0;
  v6 = *(uint64_t (**)(uint64_t, uint64_t))(v3 + 16);
  CMBaseObject = VTVideoEncoderGetCMBaseObject();
  return v6(CMBaseObject, a2);
}

uint64_t sub_1B6775C1C(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v3;
  uint64_t v4;
  NSObject *v6;
  uint64_t CMBaseObject;
  uint64_t v8;
  uint64_t (*v9)(uint64_t);
  const void *v10;
  const void *v11;
  NSObject *v12;
  __int128 v13;
  uint64_t v14;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!DerivedStorage)
    return 0;
  v3 = DerivedStorage;
  if (*(_BYTE *)(DerivedStorage + 24))
    return 0;
  v13 = *MEMORY[0x1E0CA2E18];
  v14 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  v4 = sub_1B6774AB4(a1, &v13);
  v6 = *(NSObject **)(v3 + 64);
  if (v6)
    dispatch_semaphore_wait(v6, 0xFFFFFFFFFFFFFFFFLL);
  if (*(_QWORD *)(v3 + 8))
  {
    CMBaseObject = VTVideoEncoderGetCMBaseObject();
    if (CMBaseObject)
    {
      v8 = CMBaseObject;
      v9 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 24);
      if (v9)
        v4 = v9(v8);
      else
        v4 = 4294954514;
    }
    else
    {
      v4 = 4294954516;
    }
    CFRelease(*(CFTypeRef *)(v3 + 8));
    *(_QWORD *)(v3 + 8) = 0;
  }
  v10 = *(const void **)(v3 + 16);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(v3 + 16) = 0;
  }
  v11 = *(const void **)(v3 + 56);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(v3 + 56) = 0;
  }
  if (*(_QWORD *)v3)
  {
    CFRelease(*(CFTypeRef *)v3);
    *(_QWORD *)v3 = 0;
  }
  *(_BYTE *)(v3 + 24) = 1;
  v12 = *(NSObject **)(v3 + 64);
  if (v12)
  {
    dispatch_semaphore_signal(v12);
    dispatch_release(*(dispatch_object_t *)(v3 + 64));
  }
  return v4;
}

uint64_t sub_1B6775D34(uint64_t a1)
{
  uint64_t v2;
  uint64_t CMBaseObject;
  __CFString *Mutable;
  uint64_t (*v6)(uint64_t);

  if (*(_QWORD *)(CMBaseObjectGetDerivedStorage() + 8)
    && (VTVideoEncoderGetCMBaseObject(), v2 = *(_QWORD *)(CMBaseObjectGetVTable() + 8), *(_QWORD *)(v2 + 40)))
  {
    v6 = *(uint64_t (**)(uint64_t))(v2 + 40);
    CMBaseObject = VTVideoEncoderGetCMBaseObject();
    return v6(CMBaseObject);
  }
  else
  {
    Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    CFStringAppendFormat(Mutable, 0, CFSTR("<PassthroughEncoder %p>"), a1);
    return (uint64_t)Mutable;
  }
}

uint64_t sub_1B6775DCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t CMBaseObject;
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t, uint64_t);

  if (*(_QWORD *)(CMBaseObjectGetDerivedStorage() + 8)
    && (CMBaseObject = VTVideoEncoderGetCMBaseObject(),
        (v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                           + 48)) != 0))
  {
    return v8(CMBaseObject, a2, a3, a4);
  }
  else
  {
    return 4294954514;
  }
}

uint64_t sub_1B6775E40(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage;
  __CFString *Mutable;
  const void *v7;
  uint64_t CMBaseObject;
  uint64_t (*v9)(uint64_t, const void *, const void *);
  uint64_t result;
  int v11;
  CFTypeID TypeID;
  int v13;
  const void *v14;
  __int16 v15;
  const void *v16;
  __int16 v17;
  __CFString *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  sub_1B685548C(Mutable, a3);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(const void **)(DerivedStorage + 8);
    v13 = 134218498;
    v14 = v7;
    v15 = 2112;
    v16 = a2;
    v17 = 2114;
    v18 = Mutable;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "PT (%p): Encoder got %@ property = %{public}@\n", (uint8_t *)&v13, 0x20u);
  }
  CFRelease(Mutable);
  if (*(_QWORD *)(DerivedStorage + 8))
  {
    CMBaseObject = VTVideoEncoderGetCMBaseObject();
    v9 = *(uint64_t (**)(uint64_t, const void *, const void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 56);
    if (v9)
      return v9(CMBaseObject, a2, a3);
    return 4294954514;
  }
  if (!*(_QWORD *)DerivedStorage)
    return 4294954514;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)DerivedStorage, a2, a3);
  v11 = CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED248]);
  result = 0;
  if (a3 && v11)
  {
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(a3))
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        v13 = 138412290;
        v14 = a3;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "PT: Got usage property: %@\n", (uint8_t *)&v13, 0xCu);
      }
      sub_1B6774FD8(DerivedStorage);
    }
    return 0;
  }
  return result;
}

uint64_t sub_1B6776018()
{
  uint64_t CMBaseObject;
  _QWORD *v1;
  uint64_t (*v2)(uint64_t);

  if (*(_QWORD *)(CMBaseObjectGetDerivedStorage() + 8)
    && (CMBaseObject = VTVideoEncoderGetCMBaseObject(), v1 = *(_QWORD **)(CMBaseObjectGetVTable() + 8), *v1 >= 2uLL)
    && (v2 = (uint64_t (*)(uint64_t))v1[8]) != 0)
  {
    return v2(CMBaseObject);
  }
  else
  {
    return 4294954514;
  }
}

void sub_1B6776074(int a1, int a2, const void *a3, int a4)
{
  CFNumberRef v7;
  CFNumberRef v8;
  __CFDictionary *Mutable;
  __CFDictionary *v10;
  int valuePtr;

  valuePtr = a2;
  v7 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  if (v7)
  {
    v8 = v7;
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v10 = Mutable;
      CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CEDD60], v8);
      CFDictionaryAddValue(v10, (const void *)*MEMORY[0x1E0CEDD50], (const void *)*MEMORY[0x1E0C9AE50]);
      if (a3)
        CFDictionaryAddValue(v10, CFSTR("CMClassImplementationID"), a3);
      if ((a1 == 1752589105 || a1 == 1635148593) && a4 != -1)
        CFDictionaryAddValue(v10, (const void *)*MEMORY[0x1E0CEDD58], (const void *)*MEMORY[0x1E0C9AE40]);
      VTRegisterVideoEncoderWithInfo();
      CFRelease(v10);
    }
    CFRelease(v8);
  }
}

void VCPRegisterDecoders()
{
  unint64_t v0;
  char v1;
  char **v2;
  char *v3;

  v0 = atomic_load(&qword_1EF138780);
  if (v0 != -1)
  {
    v3 = &v1;
    v2 = &v3;
    std::__call_once(&qword_1EF138780, &v2, (void (__cdecl *)(void *))nullsub_1);
  }
}

void sub_1B6776264(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B6776A40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  sub_1B67705C8((const void **)va);
  sub_1B67705C8((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_1B6776C7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  sub_1B6773B7C((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1B6777328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

const void **sub_1B677747C(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **sub_1B67774AC(const void **a1, const void **a2)
{
  const void *v4;

  v4 = *a1;
  if (v4)
    CFRelease(v4);
  *a1 = *a2;
  *a2 = 0;
  return a1;
}

void sub_1B67774EC(__CFDictionary *a1, const void *a2)
{
  CFNumberRef v4;
  CFNumberRef v5;
  uint64_t valuePtr;

  valuePtr = 7;
  v4 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  if (v4)
  {
    v5 = v4;
    CFDictionarySetValue(a1, a2, v4);
    CFRelease(v5);
  }
}

void sub_1B6777558(uint64_t a1)
{
  sub_1B6777AC0(a1);
  JUMPOUT(0x1BCC9814CLL);
}

uint64_t sub_1B677757C(uint64_t a1)
{
  void *v2;
  void *v3;
  void **v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  uint8_t v14[8];
  uint64_t v15;

  v2 = (void *)MEMORY[0x1BCC98608]();
  v4 = (void **)(a1 + 16);
  v3 = *(void **)(a1 + 16);
  if (v3
    || (v15 = objc_opt_new(),
        sub_1B6777A50((const void **)(a1 + 16), (const void **)&v15),
        sub_1B6777A90((const void **)&v15),
        (v3 = *v4) != 0))
  {
    v5 = *(_DWORD *)(a1 + 48);
    v6 = *(_DWORD *)(a1 + 52);
    v7 = *(_DWORD *)(a1 + 8);
    v8 = *(_DWORD *)(a1 + 12);
    if ((int)v5 <= (int)v7)
      v9 = v7;
    else
      v9 = v5;
    if ((int)v6 <= (int)v8)
      v10 = v8;
    else
      v10 = v6;
    v11 = *(double *)(a1 + 56);
    *(float *)&v11 = v11;
    v12 = objc_msgSend(v3, "configureIntermediateTextureProcessing:setHeight:setSigma:", v9, v10, v11);
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v14 = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Unable to initialize VCPSpillmap metal session", v14, 2u);
    }
    v12 = 4294966630;
  }
  objc_autoreleasePoolPop(v2);
  return v12;
}

uint64_t sub_1B6777668(uint64_t a1, __CVBuffer *a2, CVPixelBufferRef *a3)
{
  void *v6;
  void *v7;
  id v8;
  char *BaseAddress;
  size_t Width;
  size_t Height;
  size_t BytesPerRowOfPlane;
  size_t v14;
  const __CFString *v15;
  id v16;
  void *v17;
  void *v18;
  id v19;
  uint8_t buf[16];
  uint8_t v21[8];

  if (!*(_BYTE *)(a1 + 24))
  {
    v7 = (void *)MEMORY[0x1BCC98608]();
    v8 = *(id *)(a1 + 16);
    if (objc_msgSend(v8, "configureSession:setWidth:setHeight:", CVPixelBufferGetIOSurface(a2), *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12)))
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v21 = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Unable to configure light spill session", v21, 2u);
      }

      objc_autoreleasePoolPop(v7);
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v21 = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Unable to initialize textures", v21, 2u);
      }
      return 4294940771;
    }

    objc_autoreleasePoolPop(v7);
    *(_BYTE *)(a1 + 24) = 1;
    v15 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("EnableSpillmapLogging"), CFSTR("com.apple.VideoProcessing"));
    *(_QWORD *)v21 = v15;
    if (v15)
    {
      *(_BYTE *)(a1 + 32) = CFStringGetIntValue(v15) != 0;
      CVPixelBufferGetIOSurface(a2);
      if (IOSurfaceGetProtectionOptions())
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Light spill dumping is enabled from defaults write but deactivated due to content protection", buf, 2u);
        }
        *(_BYTE *)(a1 + 32) = 0;
      }
      else if (*(_BYTE *)(a1 + 32))
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Light spill dumping is enabled and activated for this unprotected content", buf, 2u);
        }
        v16 = objc_alloc_init(MEMORY[0x1E0CB3578]);
        objc_msgSend(v16, "setDateFormat:", CFSTR("yyyy-MM-dd-HH-mm-ss"));
        objc_msgSend(MEMORY[0x1E0C99D68], "date");
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v16, "stringFromDate:", v17);
        v18 = (void *)objc_claimAutoreleasedReturnValue();

        objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("/tmp/vcpls_dump_%dx%d_%@.bgra"), *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), v18);
        v19 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        *(_QWORD *)(a1 + 40) = fopen((const char *)objc_msgSend(v19, "UTF8String"), "wb");

      }
    }
    sub_1B6770508((const void **)v21);
  }
  v6 = (void *)MEMORY[0x1BCC98608]();
  if (objc_msgSend(*(id *)(a1 + 16), "calculateDrmSpillmapMetal:emitSpillmap:setLayout:", a2, a3, *(unsigned int *)(a1 + 28)))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v21 = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Unable to compute light spill", v21, 2u);
    }
    objc_autoreleasePoolPop(v6);
    return 4294940771;
  }
  objc_autoreleasePoolPop(v6);
  if (*(_BYTE *)(a1 + 32))
  {
    CVPixelBufferLockBaseAddress(*a3, 1uLL);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*a3);
    Width = CVPixelBufferGetWidth(*a3);
    Height = CVPixelBufferGetHeight(*a3);
    BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(*a3, 0);
    if (Height)
    {
      v14 = BytesPerRowOfPlane;
      do
      {
        fwrite(BaseAddress, 4uLL, Width, *(FILE **)(a1 + 40));
        BaseAddress += v14;
        --Height;
      }
      while (Height);
    }
    fflush(*(FILE **)(a1 + 40));
    CVPixelBufferUnlockBaseAddress(*a3, 1uLL);
  }
  return 0;
}

void sub_1B67779F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  void *v8;
  va_list va;

  va_start(va, a7);

  sub_1B6770508((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1B6777A50(const void **a1, const void **a2)
{
  const void *v4;

  v4 = *a1;
  if (v4)
    CFRelease(v4);
  *a1 = *a2;
  *a2 = 0;
  return a1;
}

const void **sub_1B6777A90(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t sub_1B6777AC0(uint64_t a1)
{
  FILE *v2;

  *(_QWORD *)a1 = &off_1E6A15148;
  v2 = *(FILE **)(a1 + 40);
  if (v2)
  {
    fclose(v2);
    *(_QWORD *)(a1 + 40) = 0;
  }
  sub_1B6777A90((const void **)(a1 + 16));
  return a1;
}

uint64_t sub_1B6777B04(uint64_t a1, const __CFString *cf)
{
  CFTypeID v4;
  const void *v5;
  uint64_t v6;
  CFTypeRef *v7;
  uint64_t *v8;
  CFTypeRef *v9;
  uint64_t result;
  char *v11;
  int v12;
  const char *v13;
  _BOOL4 v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  const char *CStringPtr;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (!cf)
    return 0;
  v4 = CFGetTypeID(cf);
  if (v4 == CFStringGetTypeID())
  {
    v5 = *(const void **)(a1 + 24);
    if (v5)
      CFRelease(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 24) = CFRetain(cf);
    *(_DWORD *)(a1 + 32) = 0;
    v7 = (CFTypeRef *)MEMORY[0x1E0CED678];
    v8 = &qword_1E6A16190;
    while (!CFEqual(cf, *v7))
    {
      ++v6;
      v9 = (CFTypeRef *)*v8;
      v8 += 3;
      v7 = v9;
      if (!v9)
      {
        if (*(_DWORD *)(a1 + 32))
          return 0;
        goto LABEL_19;
      }
    }
    v11 = (char *)&unk_1E6A16178 + 24 * v6;
    v12 = *((_DWORD *)v11 + 4);
    *(_DWORD *)(a1 + 32) = v12;
    if (!v12)
    {
LABEL_19:
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        v18 = *(_QWORD *)(a1 + 2536);
        v20 = *(_DWORD *)(a1 + 212);
        v19 = *(_DWORD *)(a1 + 216);
        v21 = 134218754;
        v22 = v18;
        v23 = 1024;
        v24 = v20;
        v25 = 1024;
        v26 = v19;
        v27 = 2080;
        CStringPtr = CFStringGetCStringPtr(cf, 0x8000100u);
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): Unsupported entropy coding mode %s\n", (uint8_t *)&v21, 0x22u);
      }
      return 4294954394;
    }
    v13 = (const char *)*((_QWORD *)v11 + 1);
    if (!v13)
      return 0;
    v14 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v14)
    {
      v15 = *(_QWORD *)(a1 + 2536);
      v16 = *(_DWORD *)(a1 + 212);
      v17 = *(_DWORD *)(a1 + 216);
      v21 = 134218754;
      v22 = v15;
      v23 = 1024;
      v24 = v16;
      v25 = 1024;
      v26 = v17;
      v27 = 2080;
      CStringPtr = v13;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): entropy mode: %s\n", (uint8_t *)&v21, 0x22u);
      return 0;
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v21) = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Entropy coding argument not a string\n", (uint8_t *)&v21, 2u);
    }
    return 4294954394;
  }
  return result;
}

uint64_t sub_1B6777D4C(uint64_t a1, const __CFString *cf)
{
  CFTypeID v4;
  CFTypeRef **v5;
  CFTypeRef *v6;
  uint64_t v7;
  CFTypeRef **v8;
  CFTypeRef *v9;
  uint64_t result;
  CFTypeRef **v11;
  const char *v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  const char *CStringPtr;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!cf)
    return 0;
  v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID())
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19) = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Profile argument not a string\n", (uint8_t *)&v19, 2u);
    }
    return 4294954394;
  }
  if (*(_QWORD *)a1)
    CFRelease(*(CFTypeRef *)a1);
  *(_QWORD *)a1 = CFRetain(cf);
  if (*(_DWORD *)(a1 + 208) == 1752589105)
    v5 = (CFTypeRef **)&unk_1E6A161A8;
  else
    v5 = (CFTypeRef **)&unk_1E6A16280;
  v6 = *v5;
  if (*v5)
  {
    v7 = 0;
    v8 = v5 + 3;
    while (!CFEqual(cf, *v6))
    {
      ++v7;
      v9 = *v8;
      v8 += 3;
      v6 = v9;
      if (!v9)
        goto LABEL_17;
    }
    v11 = &v5[3 * v7];
    *(_QWORD *)(a1 + 16) = v11[2];
    *(_QWORD *)(a1 + 8) = v11[1];
  }
LABEL_17:
  if (!*(_DWORD *)(a1 + 16))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v16 = *(_QWORD *)(a1 + 2536);
      v18 = *(_DWORD *)(a1 + 212);
      v17 = *(_DWORD *)(a1 + 216);
      v19 = 134218754;
      v20 = v16;
      v21 = 1024;
      v22 = v18;
      v23 = 1024;
      v24 = v17;
      v25 = 2080;
      CStringPtr = CFStringGetCStringPtr(cf, 0x8000100u);
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): Unsupported profile %s\n", (uint8_t *)&v19, 0x22u);
    }
    return 4294954394;
  }
  v12 = *(const char **)(a1 + 8);
  if (v12)
  {
    result = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG);
    if (!(_DWORD)result)
      return result;
    v13 = *(_QWORD *)(a1 + 2536);
    v14 = *(_DWORD *)(a1 + 212);
    v15 = *(_DWORD *)(a1 + 216);
    v19 = 134218754;
    v20 = v13;
    v21 = 1024;
    v22 = v14;
    v23 = 1024;
    v24 = v15;
    v25 = 2080;
    CStringPtr = v12;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "VCPRateControlSession (0x%llx) (%dx%d): profile level: %s\n", (uint8_t *)&v19, 0x22u);
  }
  return 0;
}

uint64_t sub_1B6777FAC(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  uint64_t **v6;
  _BOOL4 v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t **v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;
  int v15;
  NSObject *v16;
  const char *v17;
  uint32_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t **v25;
  uint64_t v26;
  double v27;
  const __CFString *v28;
  uint8_t buf[4];
  uint64_t v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  const __CFString *v36;
  __int16 v37;
  const __CFString *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v28 = a2;
  v6 = sub_1B67782D8(*(_QWORD **)(a1 + 2544), (CFTypeRef *)&v28);
  v7 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT);
  if (!v6)
  {
    if (v7)
    {
      v19 = *(_QWORD *)(a1 + 2536);
      v20 = *(_DWORD *)(a1 + 212);
      v21 = *(_DWORD *)(a1 + 216);
      *(_DWORD *)buf = 134218496;
      v30 = v19;
      v31 = 1024;
      v32 = v20;
      v33 = 1024;
      v34 = v21;
      v16 = MEMORY[0x1E0C81028];
      v17 = "VCPRateControlSession (0x%llx) (%dx%d): unrecognised property key";
      v18 = 24;
      goto LABEL_10;
    }
    return 4294966630;
  }
  if (v7)
  {
    v8 = *(_QWORD *)(a1 + 2536);
    v10 = *(_DWORD *)(a1 + 212);
    v9 = *(_DWORD *)(a1 + 216);
    v11 = sub_1B67782D8(*(_QWORD **)(a1 + 2544), (CFTypeRef *)&v28);
    if (!v11)
      goto LABEL_28;
    v12 = v11[4];
    *(_DWORD *)buf = 134219010;
    v30 = v8;
    v31 = 1024;
    v32 = v10;
    v33 = 1024;
    v34 = v9;
    v35 = 2080;
    v36 = (const __CFString *)v12;
    v37 = 2112;
    v38 = a3;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): %s property = %@\n", buf, 0x2Cu);
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED208]))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v13 = *(_QWORD *)(a1 + 2536);
      v14 = *(_DWORD *)(a1 + 212);
      v15 = *(_DWORD *)(a1 + 216);
      *(_DWORD *)buf = 134218754;
      v30 = v13;
      v31 = 1024;
      v32 = v14;
      v33 = 1024;
      v34 = v15;
      v35 = 2112;
      v36 = a2;
      v16 = MEMORY[0x1E0C81028];
      v17 = "VCPRateControlSession (0x%llx) (%dx%d): %@ is read-only";
      v18 = 34;
LABEL_10:
      _os_log_impl(&dword_1B676B000, v16, OS_LOG_TYPE_DEFAULT, v17, buf, v18);
      return 4294966630;
    }
    return 4294966630;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED180]))
  {
    v24 = sub_1B6777D4C(a1, a3);
  }
  else if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED000]))
  {
    v24 = sub_1B6777B04(a1, a3);
  }
  else
  {
    v24 = sub_1B6778420(a1, a2, a3);
  }
  v22 = v24;
  if (!(_DWORD)v24)
  {
    v25 = sub_1B67782D8(*(_QWORD **)(a1 + 2544), (CFTypeRef *)&v28);
    if (v25)
    {
      *((_BYTE *)v25 + 48) = 1;
      goto LABEL_21;
    }
LABEL_28:
    sub_1B67783D0("unordered_map::at: key not found");
  }
LABEL_21:
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECEF0])
    || CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF10])
    || CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF00]))
  {
    v26 = *(_QWORD *)(a1 + 2256);
    if (v26)
    {
      sub_1B6872FAC(v26, (uint64_t *)"target_bitrate", (double)*(int *)(a1 + 76));
      v27 = *(double *)(a1 + 48);
      if (v27 > 0.0 && v27 < 1.0)
        sub_1B6872FAC(*(_QWORD *)(a1 + 2256), (uint64_t *)"base_layer_target_bitrate", *(double *)(a1 + 56) * (double)*(int *)(a1 + 76));
    }
  }
  return v22;
}

uint64_t **sub_1B67782D8(_QWORD *a1, CFTypeRef *a2)
{
  CFHashCode v4;
  int8x8_t v5;
  CFHashCode v6;
  uint8x8_t v7;
  unint64_t v8;
  CFHashCode v9;
  uint64_t ***v10;
  uint64_t **i;
  unint64_t v12;

  v4 = CFHash(*a2);
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  for (i = *v10; i; i = (uint64_t **)*i)
  {
    v12 = (unint64_t)i[1];
    if (v12 == v6)
    {
      if (CFEqual(i[2], *a2))
        return i;
    }
    else
    {
      if (v8 > 1)
      {
        if (v12 >= *(_QWORD *)&v5)
          v12 %= *(_QWORD *)&v5;
      }
      else
      {
        v12 &= *(_QWORD *)&v5 - 1;
      }
      if (v12 != v9)
        return 0;
    }
  }
  return i;
}

void sub_1B67783D0(const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1B677872C(exception, a1);
  __cxa_throw(exception, (struct type_info *)&unk_1E6A14B40, MEMORY[0x1E0DE42E0]);
}

void sub_1B677840C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6778420(uint64_t a1, CFStringRef theString, const void *a3)
{
  const char *CStringPtr;
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  BOOL *v9;
  uint64_t **v10;
  CFNumberType v11;
  CFTypeID v12;
  uint64_t **v13;
  const __CFNumber *v14;
  uint64_t result;
  CFTypeID v16;
  BOOL v17;
  NSObject *v18;
  const char *v19;
  CFTypeRef v20;
  const char *v21;
  int v22;
  int v23;
  CFTypeRef v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v24 = theString;
  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  v6 = sub_1B67782D8(*(_QWORD **)(a1 + 2544), &v24);
  if (!v6)
    goto LABEL_35;
  v7 = v6[3];
  v8 = sub_1B67782D8(*(_QWORD **)(a1 + 2544), &v24);
  if (!v8)
    goto LABEL_35;
  if (!a3 || (v9 = (BOOL *)v8[5], (uint64_t *)CFGetTypeID(a3) != v7))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      v26 = CStringPtr;
      v18 = MEMORY[0x1E0C81028];
      v19 = "(key '%s'): bad\n";
      goto LABEL_27;
    }
    return 4294967246;
  }
  if (v7 == (uint64_t *)CFNumberGetTypeID())
  {
    v10 = sub_1B67782D8(*(_QWORD **)(a1 + 2544), &v24);
    if (!v10)
      goto LABEL_35;
    v11 = (CFNumberType)v10[7];
    v12 = CFGetTypeID(a3);
    if (v12 == CFNumberGetTypeID() && CFNumberGetValue((CFNumberRef)a3, v11, v9))
    {
      v13 = sub_1B67782D8(*(_QWORD **)(a1 + 2544), &v24);
      if (v13)
      {
        v14 = (const __CFNumber *)v13[8];
        if (!v14 || CFNumberCompare((CFNumberRef)a3, v14, 0) != kCFCompareLessThan)
          return 0;
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          return 4294967246;
        *(_DWORD *)buf = 136315138;
        v26 = CStringPtr;
        v18 = MEMORY[0x1E0C81028];
        v19 = "bad (key '%s') (out of range)\n";
        goto LABEL_27;
      }
LABEL_35:
      sub_1B67783D0("unordered_map::at: key not found");
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      v26 = CStringPtr;
      v18 = MEMORY[0x1E0C81028];
      v19 = "(key '%s'): bad\n";
LABEL_27:
      _os_log_error_impl(&dword_1B676B000, v18, OS_LOG_TYPE_ERROR, v19, buf, 0xCu);
      return 4294967246;
    }
    return 4294967246;
  }
  if (v7 == (uint64_t *)CFBooleanGetTypeID())
  {
    v16 = CFGetTypeID(a3);
    v17 = v16 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)a3) != 0;
    result = 0;
    *v9 = v17;
  }
  else if (v7 == (uint64_t *)CFStringGetTypeID() || v7 == (uint64_t *)CFDataGetTypeID())
  {
    if (*(_QWORD *)v9)
      CFRelease(*(CFTypeRef *)v9);
    v20 = CFRetain(a3);
    result = 0;
    *(_QWORD *)v9 = v20;
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v21 = *(const char **)(a1 + 2536);
      v22 = *(_DWORD *)(a1 + 212);
      v23 = *(_DWORD *)(a1 + 216);
      *(_DWORD *)buf = 134218496;
      v26 = v21;
      v27 = 1024;
      v28 = v22;
      v29 = 1024;
      v30 = v23;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): unsupported CFTypeID for SetCommonProperty()\n", buf, 0x18u);
    }
    return 4294940771;
  }
  return result;
}

std::logic_error *sub_1B677872C(std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
  return result;
}

void sub_1B6778750(uint64_t a1, double a2)
{
  uint64_t v4;
  double v5;
  _BOOL4 v6;
  double *v7;
  _QWORD *v8;
  _QWORD *v9;
  double *v10;
  _QWORD *v11;
  unint64_t v12;
  BOOL v13;
  _QWORD *v14;
  double v15;
  double *v16;
  _QWORD *v17;
  unint64_t v18;
  BOOL v19;
  _QWORD *v20;
  double v21;
  double *v22;
  _QWORD *v23;
  unint64_t v24;
  BOOL v25;
  _QWORD *v26;
  double v27;
  double *v28;
  _QWORD *v29;
  unint64_t v30;
  BOOL v31;
  _QWORD *v32;
  double v33;
  double *v34;
  _QWORD *v35;
  unint64_t v36;
  BOOL v37;
  _QWORD *v38;
  double v39;
  double *v40;
  _QWORD *v41;
  unint64_t v42;
  BOOL v43;
  _QWORD *v44;
  double v45;
  double *v46;
  _QWORD *v47;
  unint64_t v48;
  BOOL v49;
  _QWORD *v50;
  uint64_t v51;
  double *v52;
  _QWORD *v53;
  unint64_t v54;
  BOOL v55;
  _QWORD *v56;
  double v57;
  double v58;
  double *v59;
  _QWORD *v60;
  unint64_t v61;
  BOOL v62;
  _QWORD *v63;
  unint64_t v64;
  NSObject *v65;
  const char *v66;
  uint32_t v67;
  double v68;
  double v69;
  double v70;
  double *v71;
  unint64_t v72;
  BOOL v73;
  _QWORD *v74;
  uint64_t v75;
  int v76;
  int v77;
  double v78;
  double v79;
  unint64_t v80;
  double *v81;
  _QWORD *v82;
  unint64_t v83;
  BOOL v84;
  _QWORD *v85;
  uint64_t v86;
  double v87;
  double v88;
  double v89;
  uint8_t buf[4];
  uint64_t v91;
  __int16 v92;
  int v93;
  __int16 v94;
  int v95;
  __int16 v96;
  double v97;
  __int16 v98;
  double v99;
  __int16 v100;
  double v101;
  __int16 v102;
  double v103;
  __int16 v104;
  double v105;
  __int16 v106;
  double v107;
  __int16 v108;
  double v109;
  __int16 v110;
  unint64_t v111;
  __int16 v112;
  double v113;
  __int16 v114;
  uint64_t v115;
  __int16 v116;
  double v117;
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  if (a2 <= 0.0)
    return;
  if (!a1)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      return;
    *(_WORD *)buf = 0;
    v65 = MEMORY[0x1E0C81028];
    v66 = "Empty callback refcon in VCPRateControlSessionStatsMonitorCallback()\n";
    v67 = 2;
    goto LABEL_136;
  }
  v4 = *(_QWORD *)(a1 + 2256);
  v5 = *(double *)(a1 + 48);
  v6 = v5 < 1.0 && v5 > 0.0;
  v9 = *(_QWORD **)(v4 + 32);
  v7 = (double *)(v4 + 32);
  v8 = v9;
  if (!v9)
  {
    v64 = 0;
    v58 = 0.0;
    v87 = 0.0;
    v88 = 0.0;
    v21 = 0.0;
    v15 = 0.0;
LABEL_111:
    v27 = 0.0;
    v89 = 0.0;
    v86 = 0;
    v68 = 0.0;
    goto LABEL_114;
  }
  v10 = v7;
  v11 = v8;
  do
  {
    v12 = v11[4];
    v13 = v12 >= (unint64_t)"input_frames";
    if (v12 >= (unint64_t)"input_frames")
      v14 = v11;
    else
      v14 = v11 + 1;
    if (v13)
      v10 = (double *)v11;
    v11 = (_QWORD *)*v14;
  }
  while (*v14);
  v15 = 0.0;
  if (v10 != v7 && *((_QWORD *)v10 + 4) <= (unint64_t)"input_frames")
    v15 = v10[5];
  if (!v8)
  {
    v58 = 0.0;
    v64 = 0;
    v87 = 0.0;
    v88 = 0.0;
    v21 = 0.0;
    goto LABEL_111;
  }
  v16 = v7;
  v17 = v8;
  do
  {
    v18 = v17[4];
    v19 = v18 >= (unint64_t)"encoded_frames";
    if (v18 >= (unint64_t)"encoded_frames")
      v20 = v17;
    else
      v20 = v17 + 1;
    if (v19)
      v16 = (double *)v17;
    v17 = (_QWORD *)*v20;
  }
  while (*v20);
  v21 = 0.0;
  if (v16 != v7 && *((_QWORD *)v16 + 4) <= (unint64_t)"encoded_frames")
    v21 = v16[5];
  v22 = v7;
  v23 = v8;
  do
  {
    v24 = v23[4];
    v25 = v24 >= (unint64_t)"transmit_frames";
    if (v24 >= (unint64_t)"transmit_frames")
      v26 = v23;
    else
      v26 = v23 + 1;
    if (v25)
      v22 = (double *)v23;
    v23 = (_QWORD *)*v26;
  }
  while (*v26);
  v27 = 0.0;
  if (v22 != v7 && *((_QWORD *)v22 + 4) <= (unint64_t)"transmit_frames")
    v27 = v22[5];
  v28 = v7;
  v29 = v8;
  do
  {
    v30 = v29[4];
    v31 = v30 >= (unint64_t)"idr_frames";
    if (v30 >= (unint64_t)"idr_frames")
      v32 = v29;
    else
      v32 = v29 + 1;
    if (v31)
      v28 = (double *)v29;
    v29 = (_QWORD *)*v32;
  }
  while (*v32);
  v33 = 0.0;
  if (v28 != v7 && *((_QWORD *)v28 + 4) <= (unint64_t)"idr_frames")
    v33 = v28[5];
  v87 = v33;
  v34 = v7;
  v35 = v8;
  do
  {
    v36 = v35[4];
    v37 = v36 >= (unint64_t)"refresh_frames";
    if (v36 >= (unint64_t)"refresh_frames")
      v38 = v35;
    else
      v38 = v35 + 1;
    if (v37)
      v34 = (double *)v35;
    v35 = (_QWORD *)*v38;
  }
  while (*v38);
  v39 = 0.0;
  if (v34 != v7 && *((_QWORD *)v34 + 4) <= (unint64_t)"refresh_frames")
    v39 = v34[5];
  v89 = v39;
  v40 = v7;
  v41 = v8;
  do
  {
    v42 = v41[4];
    v43 = v42 >= (unint64_t)"encoded_bits";
    if (v42 >= (unint64_t)"encoded_bits")
      v44 = v41;
    else
      v44 = v41 + 1;
    if (v43)
      v40 = (double *)v41;
    v41 = (_QWORD *)*v44;
  }
  while (*v44);
  v45 = 0.0;
  if (v40 != v7 && *((_QWORD *)v40 + 4) <= (unint64_t)"encoded_bits")
    v45 = v40[5];
  v88 = v45;
  v46 = v7;
  v47 = v8;
  do
  {
    v48 = v47[4];
    v49 = v48 >= (unint64_t)"target_bitrate";
    if (v48 >= (unint64_t)"target_bitrate")
      v50 = v47;
    else
      v50 = v47 + 1;
    if (v49)
      v46 = (double *)v47;
    v47 = (_QWORD *)*v50;
  }
  while (*v50);
  v51 = 0;
  if (v46 != v7 && *((_QWORD *)v46 + 4) <= (unint64_t)"target_bitrate")
    v51 = *((_QWORD *)v46 + 5);
  v86 = v51;
  v52 = v7;
  v53 = v8;
  do
  {
    v54 = v53[4];
    v55 = v54 >= (unint64_t)"base_layer_encoded_bits";
    if (v54 >= (unint64_t)"base_layer_encoded_bits")
      v56 = v53;
    else
      v56 = v53 + 1;
    if (v55)
      v52 = (double *)v53;
    v53 = (_QWORD *)*v56;
  }
  while (*v56);
  v57 = 0.0;
  v58 = 0.0;
  if (v52 != v7 && *((_QWORD *)v52 + 4) <= (unint64_t)"base_layer_encoded_bits")
    v58 = v52[5];
  v59 = v7;
  v60 = v8;
  do
  {
    v61 = v60[4];
    v62 = v61 >= (unint64_t)"base_layer_target_bitrate";
    if (v61 >= (unint64_t)"base_layer_target_bitrate")
      v63 = v60;
    else
      v63 = v60 + 1;
    if (v62)
      v59 = (double *)v60;
    v60 = (_QWORD *)*v63;
  }
  while (*v63);
  if (v59 == v7 || *((_QWORD *)v59 + 4) > (unint64_t)"base_layer_target_bitrate")
    v64 = 0;
  else
    v64 = *((_QWORD *)v59 + 5);
  v81 = v7;
  v82 = v8;
  do
  {
    v83 = v82[4];
    v84 = v83 >= (unint64_t)"encoding_time";
    if (v83 >= (unint64_t)"encoding_time")
      v85 = v82;
    else
      v85 = v82 + 1;
    if (v84)
      v81 = (double *)v82;
    v82 = (_QWORD *)*v85;
  }
  while (*v85);
  if (v81 != v7 && *((_QWORD *)v81 + 4) <= (unint64_t)"encoding_time")
    v57 = v81[5];
  v68 = 0.0;
  if (v21 > 0.0)
    v68 = v57 / v21 * 1000.0;
LABEL_114:
  v69 = -1.0;
  if (v5 > 0.0 && v27 != 0.0)
  {
    v70 = 0.0;
    if (v8)
    {
      v71 = v7;
      do
      {
        v72 = v8[4];
        v73 = v72 >= (unint64_t)"base_layer_frames";
        if (v72 >= (unint64_t)"base_layer_frames")
          v74 = v8;
        else
          v74 = v8 + 1;
        if (v73)
          v71 = (double *)v8;
        v8 = (_QWORD *)*v74;
      }
      while (*v74);
      if (v71 != v7 && *((_QWORD *)v71 + 4) <= (unint64_t)"base_layer_frames")
        v70 = v71[5];
    }
    v69 = v70 / v27;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v75 = *(_QWORD *)(a1 + 2536);
    v76 = *(_DWORD *)(a1 + 212);
    v77 = *(_DWORD *)(a1 + 216);
    v78 = -1.0;
    if (v5 > 0.0)
      v78 = v69;
    v79 = v58 / a2;
    v80 = 0xBFF0000000000000;
    if (v6)
      v80 = v64;
    else
      v79 = -1.0;
    *(_DWORD *)buf = 134221312;
    v91 = v75;
    v92 = 1024;
    v93 = v76;
    v94 = 1024;
    v95 = v77;
    v96 = 2048;
    v97 = v15 / a2;
    v98 = 2048;
    v99 = v21 / a2;
    v100 = 2048;
    v101 = v27 / a2;
    v102 = 2048;
    v103 = v87 / a2;
    v104 = 2048;
    v105 = v89 / a2;
    v106 = 2048;
    v107 = v78;
    v108 = 2048;
    v109 = v79;
    v110 = 2048;
    v111 = v80;
    v112 = 2048;
    v113 = v88 / a2;
    v114 = 2048;
    v115 = v86;
    v116 = 2048;
    v117 = v68;
    v65 = MEMORY[0x1E0C81028];
    v66 = "VCPRateControlSession (0x%llx) (%dx%d): input_fps=%.2f, enc_fps=%.2f, tx_fps=%.2f, idr_fps=%.2f, refresh_fps=%"
          ".2f, baselayer_fraction=%.1f, bit_rate (video/target)=%.0f/%.0f, %.0f/%.0f, enc_time=%.2f ms";
    v67 = 134;
LABEL_136:
    _os_log_impl(&dword_1B676B000, v65, OS_LOG_TYPE_DEFAULT, v66, buf, v67);
  }
}

_QWORD *sub_1B6778D98(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *result;
  _QWORD *v14;

  v2 = *(const void **)a1;
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)a1 = 0;
  }
  v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v4 = *(const void **)(a1 + 136);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 136) = 0;
  }
  v5 = *(const void **)(a1 + 168);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 168) = 0;
  }
  v6 = *(const void **)(a1 + 184);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 184) = 0;
  }
  v7 = *(_QWORD *)(a1 + 2544);
  if (v7)
  {
    v8 = *(_QWORD **)(v7 + 16);
    if (v8)
    {
      do
      {
        v9 = (_QWORD *)*v8;
        operator delete(v8);
        v8 = v9;
      }
      while (v9);
    }
    v10 = *(void **)v7;
    *(_QWORD *)v7 = 0;
    if (v10)
      operator delete(v10);
    MEMORY[0x1BCC9814C](v7, 0x10A0C408EF24B1CLL);
    *(_QWORD *)(a1 + 2544) = 0;
  }
  v11 = *(_QWORD *)(a1 + 2256);
  if (v11)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
    *(_QWORD *)(a1 + 2256) = 0;
  }
  v12 = *(_QWORD *)(a1 + 2264);
  if (v12)
  {
    MEMORY[0x1BCC9814C](v12, 0x1060C405A861112);
    *(_QWORD *)(a1 + 2264) = 0;
  }
  result = *(_QWORD **)(a1 + 2296);
  if (result)
  {
    v14 = sub_1B680B410(result);
    result = (_QWORD *)MEMORY[0x1BCC9814C](v14, 0x10F0C4026B0C2FCLL);
    *(_QWORD *)(a1 + 2296) = 0;
  }
  return result;
}

void sub_1B6778EB4(float *a1, CFTypeRef *a2, uint64_t a3)
{
  CFHashCode v3;
  CFHashCode v7;
  CFHashCode v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  uint64_t ***v12;
  uint64_t **i;
  unint64_t v14;
  _QWORD *v15;
  __int128 v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  int8x8_t prime;
  void *v23;
  _QWORD *v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  uint8x8_t v28;
  unint64_t v29;
  uint8x8_t v30;
  uint64_t v31;
  _QWORD *v32;
  unint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  unint64_t v36;
  _QWORD *v37;

  v7 = CFHash(*a2);
  v8 = v7;
  v9 = *((_QWORD *)a1 + 1);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v9)
        v3 = v7 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v7;
    }
    v12 = *(uint64_t ****)(*(_QWORD *)a1 + 8 * v3);
    if (v12)
    {
      for (i = *v12; i; i = (uint64_t **)*i)
      {
        v14 = (unint64_t)i[1];
        if (v14 == v8)
        {
          if (CFEqual(i[2], *a2))
            return;
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9)
              v14 %= v9;
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3)
            break;
        }
      }
    }
  }
  v15 = operator new(0x48uLL);
  *v15 = 0;
  v15[1] = v8;
  v16 = *(_OWORD *)(a3 + 16);
  *((_OWORD *)v15 + 1) = *(_OWORD *)a3;
  *((_OWORD *)v15 + 2) = v16;
  *((_OWORD *)v15 + 3) = *(_OWORD *)(a3 + 32);
  v15[8] = *(_QWORD *)(a3 + 48);
  v17 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v18 = a1[8];
  if (!v9 || (float)(v18 * (float)v9) < v17)
  {
    v19 = 1;
    if (v9 >= 3)
      v19 = (v9 & (v9 - 1)) != 0;
    v20 = v19 | (2 * v9);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      prime = (int8x8_t)v21;
    else
      prime = (int8x8_t)v20;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v9 = *((_QWORD *)a1 + 1);
    if (*(_QWORD *)&prime > v9)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v9)
    {
      v29 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v9 < 3 || (v30 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v30.i16[0] = vaddlv_u8(v30), v30.u32[0] > 1uLL))
      {
        v29 = std::__next_prime(v29);
      }
      else
      {
        v31 = 1 << -(char)__clz(v29 - 1);
        if (v29 >= 2)
          v29 = v31;
      }
      if (*(_QWORD *)&prime <= v29)
        prime = (int8x8_t)v29;
      if (*(_QWORD *)&prime >= v9)
      {
        v9 = *((_QWORD *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            sub_1B6773BF4();
          v23 = operator new(8 * *(_QWORD *)&prime);
          v24 = *(_QWORD **)a1;
          *(_QWORD *)a1 = v23;
          if (v24)
            operator delete(v24);
          v25 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v25++) = 0;
          while (*(_QWORD *)&prime != v25);
          v26 = (_QWORD *)*((_QWORD *)a1 + 2);
          if (v26)
          {
            v27 = v26[1];
            v28 = (uint8x8_t)vcnt_s8(prime);
            v28.i16[0] = vaddlv_u8(v28);
            if (v28.u32[0] > 1uLL)
            {
              if (v27 >= *(_QWORD *)&prime)
                v27 %= *(_QWORD *)&prime;
            }
            else
            {
              v27 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v27) = a1 + 4;
            v32 = (_QWORD *)*v26;
            if (*v26)
            {
              do
              {
                v33 = v32[1];
                if (v28.u32[0] > 1uLL)
                {
                  if (v33 >= *(_QWORD *)&prime)
                    v33 %= *(_QWORD *)&prime;
                }
                else
                {
                  v33 &= *(_QWORD *)&prime - 1;
                }
                if (v33 != v27)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v33))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v33) = v26;
                    goto LABEL_55;
                  }
                  *v26 = *v32;
                  *v32 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v33);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v33) = v32;
                  v32 = v26;
                }
                v33 = v27;
LABEL_55:
                v26 = v32;
                v32 = (_QWORD *)*v32;
                v27 = v33;
              }
              while (v32);
            }
          }
          v9 = (unint64_t)prime;
          goto LABEL_59;
        }
        v37 = *(_QWORD **)a1;
        *(_QWORD *)a1 = 0;
        if (v37)
          operator delete(v37);
        v9 = 0;
        *((_QWORD *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v34 = *(_QWORD **)a1;
  v35 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v35)
  {
    *v15 = *v35;
LABEL_72:
    *v35 = v15;
    goto LABEL_73;
  }
  *v15 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v15;
  v34[v3] = a1 + 4;
  if (*v15)
  {
    v36 = *(_QWORD *)(*v15 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v36 >= v9)
        v36 %= v9;
    }
    else
    {
      v36 &= v9 - 1;
    }
    v35 = (_QWORD *)(*(_QWORD *)a1 + 8 * v36);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
}

void sub_1B67792B4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

CFDictionaryRef sub_1B67792C8(uint64_t a1)
{
  const __CFAllocator *v2;
  CFDictionaryRef v3;
  CFDictionaryRef v4;
  int v5;
  CFMutableArrayRef Mutable;
  __CFArray *v7;
  const void **v8;
  uint64_t v9;
  CFDictionaryRef Copy;
  CFDictionaryRef v11;
  const void **v12;
  uint64_t v13;
  void *v14;
  __CFDictionary *v15;
  uint64_t **v16;
  const void *v17;
  CFDictionaryRef v18;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v3 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v3)
  {
    v4 = v3;
    v5 = *(_DWORD *)(a1 + 208);
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    if (!Mutable)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        LOWORD(keys[0]) = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "CFArrayCreate (CreateProfileLevelDict) failed!", (uint8_t *)keys, 2u);
      }
      v11 = 0;
      goto LABEL_21;
    }
    v7 = Mutable;
    if (v5 == 1752589105)
    {
      v12 = (const void **)MEMORY[0x1E0CED9B0];
      v13 = 0x18u;
      do
      {
        CFArrayAppendValue(v7, *v12);
        v12 = *(const void ***)((char *)&unk_1E6A161A8 + v13);
        v13 += 24;
      }
      while (v13 != 216);
    }
    else
    {
      if (v5 != 1635148593)
        goto LABEL_19;
      v8 = (const void **)MEMORY[0x1E0CED870];
      v9 = 0x18u;
      do
      {
        CFArrayAppendValue(v7, *v8);
        v8 = *(const void ***)((char *)&unk_1E6A16280 + v9);
        v9 += 24;
      }
      while (v9 != 816);
    }
    v14 = (void *)*MEMORY[0x1E0CED9F0];
    values = v7;
    keys[0] = v14;
    v11 = CFDictionaryCreate(v2, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (v11)
    {
LABEL_20:
      CFRelease(v7);
LABEL_21:
      v15 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v15)
      {
        if (v11)
        {
          v16 = *(uint64_t ***)(*(_QWORD *)(a1 + 2544) + 16);
          if (v16)
          {
            v17 = (const void *)*MEMORY[0x1E0CED180];
            do
            {
              if (CFEqual(v16[2], v17))
                v18 = v11;
              else
                v18 = v4;
              CFDictionaryAddValue(v15, v16[2], v18);
              v16 = (uint64_t **)*v16;
            }
            while (v16);
          }
        }
        Copy = CFDictionaryCreateCopy(v2, v15);
      }
      else
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          LOWORD(keys[0]) = 0;
          _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "CFDictionaryCreate failed", (uint8_t *)keys, 2u);
        }
        Copy = 0;
      }
      CFRelease(v4);
      if (v11)
        CFRelease(v11);
      if (v15)
        CFRelease(v15);
      return Copy;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      LOWORD(keys[0]) = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "CFDictionaryCreate (CreateProfileLevelDict) failed!", (uint8_t *)keys, 2u);
    }
LABEL_19:
    v11 = 0;
    goto LABEL_20;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    LOWORD(keys[0]) = 0;
    _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "CFDictionaryCreate failed", (uint8_t *)keys, 2u);
  }
  return 0;
}

uint64_t sub_1B6779610(uint64_t a1, const void *a2, CFNumberRef *a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t *v8;
  uint64_t **v9;
  CFNumberRef v10;
  uint64_t result;
  CFNumberRef *v12;
  uint64_t v13;
  int v14;
  int v15;
  CFTypeRef v16;
  uint8_t buf[4];
  uint64_t v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v16 = a2;
  v5 = sub_1B67782D8(*(_QWORD **)(a1 + 2544), &v16);
  if (!v5)
    goto LABEL_22;
  v6 = v5[3];
  v7 = sub_1B67782D8(*(_QWORD **)(a1 + 2544), &v16);
  if (!v7)
    goto LABEL_22;
  v8 = v7[5];
  *a3 = 0;
  if (v6 == (uint64_t *)CFNumberGetTypeID())
  {
    v9 = sub_1B67782D8(*(_QWORD **)(a1 + 2544), &v16);
    if (v9)
    {
      v10 = CFNumberCreate(0, (CFNumberType)v9[7], v8);
LABEL_15:
      result = 0;
LABEL_16:
      *a3 = v10;
      return result;
    }
LABEL_22:
    sub_1B67783D0("unordered_map::at: key not found");
  }
  if (v6 == (uint64_t *)CFBooleanGetTypeID())
  {
    result = 0;
    if (*(_BYTE *)v8)
      v12 = (CFNumberRef *)MEMORY[0x1E0C9AE50];
    else
      v12 = (CFNumberRef *)MEMORY[0x1E0C9AE40];
    v10 = *v12;
    goto LABEL_16;
  }
  if (v6 == (uint64_t *)CFStringGetTypeID()
    || v6 == (uint64_t *)CFDataGetTypeID()
    || v6 == (uint64_t *)CFDictionaryGetTypeID())
  {
    v10 = (CFNumberRef)*v8;
    if (!*v8)
      return 0;
    goto LABEL_15;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v13 = *(_QWORD *)(a1 + 2536);
    v14 = *(_DWORD *)(a1 + 212);
    v15 = *(_DWORD *)(a1 + 216);
    *(_DWORD *)buf = 134218496;
    v18 = v13;
    v19 = 1024;
    v20 = v14;
    v21 = 1024;
    v22 = v15;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): unsupported CFTypeID for CopyCommonProperty()", buf, 0x18u);
  }
  return 4294940771;
}

uint64_t sub_1B67797BC(uint64_t a1, __CFDictionary *a2)
{
  uint64_t v3;
  uint64_t *v4;
  const void *v6;
  NSObject *v7;
  const void *v8;
  BOOL v9;
  uint64_t v10;
  int v11;
  int v12;
  void *value;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  const void *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 2544);
  if (v3)
  {
    v4 = *(uint64_t **)(v3 + 16);
    if (v4)
    {
      v6 = (const void *)*MEMORY[0x1E0CED208];
      v7 = MEMORY[0x1E0C81028];
      do
      {
        if (!CFEqual((CFTypeRef)v4[2], v6) && *((_BYTE *)v4 + 48))
        {
          v8 = (const void *)v4[2];
          value = 0;
          if (sub_1B6779610(a1, v8, (CFNumberRef *)&value))
            v9 = 1;
          else
            v9 = value == 0;
          if (v9)
          {
            if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
            {
              v10 = *(_QWORD *)(a1 + 2536);
              v11 = *(_DWORD *)(a1 + 212);
              v12 = *(_DWORD *)(a1 + 216);
              *(_DWORD *)buf = 134218754;
              v16 = v10;
              v17 = 1024;
              v18 = v11;
              v19 = 1024;
              v20 = v12;
              v21 = 2112;
              v22 = v8;
              _os_log_impl(&dword_1B676B000, v7, OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): failed to set property %@\n", buf, 0x22u);
            }
          }
          else
          {
            CFDictionarySetValue(a2, v8, value);
            *((_BYTE *)v4 + 48) = 0;
          }
        }
        v4 = (uint64_t *)*v4;
      }
      while (v4);
    }
    return 0;
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      v16 = a1 + 256;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: empty property attributes\n", buf, 0xCu);
    }
    return 4294954392;
  }
}

BOOL sub_1B6779994(uint64_t a1, int a2, int a3, char a4, int a5, CMTime *a6, CMTime *a7)
{
  std::mutex *v14;
  uint64_t **v15;
  uint64_t **v16;
  uint64_t *v17;
  unsigned __int8 v18;
  _BOOL8 v19;
  uint64_t *v20;
  BOOL v21;
  char v22;
  int v23;
  int v24;
  CMTime v26;
  CMTime rhs;
  CMTime lhs;
  CMTime time1;
  int v30;

  v30 = a2;
  v14 = (std::mutex *)(a1 + 208);
  std::mutex::lock((std::mutex *)(a1 + 208));
  v15 = sub_1B6779B8C((uint64_t **)(a1 + 184), a2, &v30);
  v16 = v15;
  if (!a3 || !a5 || (v17 = v15[9]) == 0 || (int)(*((double *)v17 + 1) + 0.5) > 16)
  {
    if (a3)
    {
      v20 = v15[9];
      if (v20)
      {
        v21 = (int)(*((double *)v20 + 1) + 0.5) > 16 || *((_DWORD *)v15 + 30) < 4;
        v22 = v21;
        if (v21 || (a4 & 1) != 0)
        {
          if ((v22 & 1) == 0)
            goto LABEL_20;
        }
        else if (*((_BYTE *)v15 + 64))
        {
LABEL_20:
          v23 = *((_DWORD *)v15 + 31);
          v19 = v23 < 1000;
          if (v23 < 1000)
            v24 = v23 + 1;
          else
            v24 = 0;
          *((_DWORD *)v15 + 31) = v24;
          goto LABEL_26;
        }
      }
    }
    v19 = 0;
    goto LABEL_26;
  }
  v18 = atomic_load((unsigned __int8 *)&qword_1EF1387C0);
  if ((v18 & 1) == 0 && __cxa_guard_acquire(&qword_1EF1387C0))
  {
    CMTimeMake((CMTime *)byte_1EF1387A8, 1000, 1000);
    __cxa_guard_release(&qword_1EF1387C0);
  }
  lhs = *a6;
  rhs = *a7;
  CMTimeSubtract(&time1, &lhs, &rhs);
  v26 = *(CMTime *)byte_1EF1387A8;
  if (CMTimeCompare(&time1, &v26) > 0 || *((_BYTE *)v16 + 128))
  {
    v19 = 0;
    *((_BYTE *)v16 + 128) = 1;
  }
  else
  {
    *((_BYTE *)v16 + 128) = 0;
    v19 = 1;
  }
LABEL_26:
  std::mutex::unlock(v14);
  return v19;
}

void sub_1B6779B60(_Unwind_Exception *a1)
{
  std::mutex *v1;

  __cxa_guard_abort(&qword_1EF1387C0);
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t **sub_1B6779B8C(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  int v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x88uLL);
    *((_DWORD *)v7 + 8) = *a3;
    *((_OWORD *)v7 + 4) = 0u;
    *((_OWORD *)v7 + 5) = 0u;
    *((_OWORD *)v7 + 7) = 0u;
    *((_OWORD *)v7 + 6) = 0u;
    v7[16] = 0;
    v7[5] = (uint64_t *)(v7 + 5);
    v7[6] = (uint64_t *)(v7 + 5);
    v7[7] = 0;
    v7[9] = 0;
    v7[10] = 0;
    v7[11] = 0;
    v7[12] = (uint64_t *)(v7 + 12);
    v7[13] = (uint64_t *)(v7 + 12);
    *((_DWORD *)v7 + 30) = -1;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)v7;
    v11 = (uint64_t *)**a1;
    if (v11)
    {
      *a1 = v11;
      v10 = *v6;
    }
    sub_1B6779C90(a1[1], v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t *sub_1B6779C90(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void sub_1B6779E28(uint64_t a1, int a2, int a3, char a4, uint64_t a5, int a6, int a7, int a8)
{
  uint64_t **v16;
  char *v17;
  char *v18;
  _OWORD *v19;
  uint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  int **v23;
  int *v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  uint64_t v32;
  double v33;
  uint64_t v34;
  double v35;
  unint64_t v36;
  char **v37;
  char *v38;
  char *v39;
  uint64_t v40;
  int v41;
  int v42;
  int v43;
  char *v44;
  double v45;
  int v46;
  double v47;
  BOOL v48;
  double v49;
  double v50;
  double v51;
  double v52;
  int v53;
  int v54;
  uint64_t v55;
  unint64_t v56;
  int v57;
  CMTimeValue v58;
  _QWORD *v59;
  double v60;
  double v61;
  double v62;
  uint64_t v63;
  std::__shared_weak_count *v64;
  unint64_t *p_shared_owners;
  unint64_t v66;
  CMTimeValue v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  double v72;
  int32_t v73;
  unint64_t v74;
  unint64_t *v75;
  unint64_t v76;
  int v77;
  double v78;
  _QWORD *v79;
  unint64_t *v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t *v83;
  unint64_t v84;
  int v85;
  std::mutex *v86;
  uint64_t v87;
  char *v88;
  std::__shared_weak_count *v89;
  int v90;
  __int128 v91;
  uint64_t v92;
  std::__shared_weak_count *v93;
  __int128 v94;
  CMTime time2;
  CMTime time1;
  CMTime rhs;
  CMTime lhs;
  CMTime v99;

  v90 = a2;
  v86 = (std::mutex *)(a1 + 208);
  std::mutex::lock((std::mutex *)(a1 + 208));
  v16 = sub_1B6779B8C((uint64_t **)(a1 + 184), a2, &v90);
  v87 = a1;
  v17 = (char *)operator new(0x60uLL);
  *((_QWORD *)v17 + 1) = 0;
  *((_QWORD *)v17 + 2) = 0;
  *(_QWORD *)v17 = &off_1E6A15B50;
  *(_OWORD *)(v17 + 24) = 0u;
  v18 = v17 + 24;
  *(_OWORD *)(v17 + 56) = 0u;
  v19 = (_OWORD *)MEMORY[0x1E0CA2E68];
  *((_QWORD *)v17 + 7) = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
  *(_OWORD *)(v17 + 40) = *v19;
  *((_QWORD *)v17 + 10) = 0;
  *((_QWORD *)v17 + 11) = 0;
  *((_QWORD *)v17 + 9) = 0;
  v88 = v17 + 24;
  v89 = (std::__shared_weak_count *)v17;
  if ((a4 & 1) == 0)
  {
    *((_DWORD *)v16 + 30) = -1;
    sub_1B677A398(v16 + 5);
    *((_BYTE *)v16 + 64) = 0;
  }
  *((_DWORD *)v17 + 6) = a3;
  v17[28] = a4;
  *(_OWORD *)(v17 + 40) = *(_OWORD *)a5;
  *((_QWORD *)v17 + 7) = *(_QWORD *)(a5 + 16);
  v20 = (uint64_t *)v87;
  v21 = *(_QWORD *)(v87 + 120);
  v22 = *(_QWORD *)(v87 + 96);
  if (*(_QWORD *)(v87 + 104) == v22)
  {
    v28 = 0;
    v26 = *(_QWORD *)(v87 + 128);
  }
  else
  {
    v23 = (int **)(v22 + 8 * (v21 >> 10));
    v24 = *v23;
    v25 = &(*v23)[*(_QWORD *)(v87 + 120) & 0x3FFLL];
    v26 = *(_QWORD *)(v87 + 128);
    v27 = *(_QWORD *)(v22 + (((v26 + v21) >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * ((v26 + v21) & 0x3FF);
    if (v25 == (int *)v27)
    {
      v28 = 0;
    }
    else
    {
      LODWORD(v28) = 0;
      do
      {
        v30 = *v25++;
        v29 = v30;
        if ((char *)v25 - (char *)v24 == 4096)
        {
          v31 = v23[1];
          ++v23;
          v24 = v31;
          v25 = v31;
        }
        v28 = v29 + (int)v28;
      }
      while (v25 != (int *)v27);
    }
  }
  v32 = a7;
  if (v26)
    v32 = v28
        + a7
        - *(int *)(*(_QWORD *)(v22 + (((v21 + v26 - 1) >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * ((v21 + v26 - 1) & 0x3FF));
  v33 = *(double *)(v87 + 32);
  v34 = *(_QWORD *)(v87 + 48);
  v35 = 0.0;
  if (*(_QWORD *)(v87 + 56) != v34)
  {
    v36 = *(_QWORD *)(v87 + 72);
    v37 = (char **)(v34 + 8 * (v36 >> 10));
    v38 = *v37;
    v39 = &(*v37)[4 * (v36 & 0x3FF)];
    v40 = *(_QWORD *)(v34 + (((*(_QWORD *)(v87 + 80) + v36) >> 7) & 0x1FFFFFFFFFFFFF8))
        + 4 * ((*(_QWORD *)(v87 + 80) + v36) & 0x3FF);
    if (v39 != (char *)v40)
    {
      v41 = 0;
      do
      {
        v43 = *(_DWORD *)v39;
        v39 += 4;
        v42 = v43;
        if (v39 - v38 == 4096)
        {
          v44 = v37[1];
          ++v37;
          v38 = v44;
          v39 = v44;
        }
        v41 += v42;
      }
      while (v39 != (char *)v40);
      if (v41 >= 1)
        v35 = (double)v32 / (double)v41;
    }
  }
  v45 = v35 + 1.0;
  v46 = a8 + a6;
  v47 = (double)(a8 + a6);
  v48 = v35 < 3.3;
  v49 = 4.3;
  if (v48)
    v49 = v45;
  v50 = v33 * 0.5 / (v49 + 0.5);
  if (v50 >= v47)
    v50 = (double)v46;
  v51 = (v33 - v50) / v49;
  v52 = (double)a8;
  if (a8 && v46 && v50 != v47)
    v52 = v50 * v52 / v47;
  v53 = *(_DWORD *)(v87 + 24);
  v54 = *(_DWORD *)(v87 + 28);
  *((_DWORD *)v17 + 16) = (int)fmax(v50 - v52, 0.0);
  *((_DWORD *)v17 + 17) = a7;
  *((_DWORD *)v17 + 18) = (int)v52;
  *((_QWORD *)v17 + 4) = (unint64_t)v51;
  v56 = *(_QWORD *)(v87 + 136);
  v55 = *(_QWORD *)(v87 + 144);
  v57 = *(_DWORD *)(v87 + 152);
  v58 = *(_QWORD *)(v87 + 156);
  v94 = *(_OWORD *)(v87 + 164);
  v59 = *(_QWORD **)(v87 + 8);
  if (v59 != (_QWORD *)v87)
  {
    v85 = v57;
    v60 = (double)v53;
    v61 = (double)v54;
    v62 = (double)v54 / (double)v53;
    do
    {
      v63 = v59[2];
      v64 = (std::__shared_weak_count *)v59[3];
      v92 = v63;
      v93 = v64;
      if (v64)
      {
        p_shared_owners = (unint64_t *)&v64->__shared_owners_;
        do
          v66 = __ldxr(p_shared_owners);
        while (__stxr(v66 + 1, p_shared_owners));
      }
      v91 = *(_OWORD *)(v63 + 24);
      v68 = *(_QWORD *)(v63 + 8);
      v67 = *(_QWORD *)(v63 + 16);
      v70 = *(int *)(v63 + 40);
      v69 = *(int *)(v63 + 44);
      v71 = *(int *)(v63 + 48);
      memset(&v99, 0, sizeof(v99));
      lhs.value = v67;
      *(_OWORD *)&lhs.timescale = *(_OWORD *)(v63 + 24);
      rhs.value = v58;
      *(_OWORD *)&rhs.timescale = v94;
      CMTimeSubtract(&v99, &lhs, &rhs);
      v72 = v62;
      if (v67 >= 1)
      {
        v72 = v62;
        if (v58 >= 1)
        {
          v72 = v62;
          if (v99.value >= 1)
          {
            time1 = v99;
            CMTimeMake(&time2, 20, 1);
            v73 = CMTimeCompare(&time1, &time2);
            v72 = v62;
            if (v73 == -1)
              v72 = (double)v99.value * v61 / (double)v99.timescale;
          }
        }
      }
      v74 = v68 + v56 + v70 + v69 + v71;
      if (v74 >= (unint64_t)v72)
        v56 = v74 - (unint64_t)v72;
      else
        v56 = 0;
      v94 = v91;
      v20 = (uint64_t *)v87;
      if (v64)
      {
        v75 = (unint64_t *)&v64->__shared_owners_;
        do
          v76 = __ldaxr(v75);
        while (__stlxr(v76 - 1, v75));
        if (!v76)
        {
          ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
          std::__shared_weak_count::__release_weak(v64);
        }
      }
      v59 = (_QWORD *)v59[1];
      v58 = v67;
    }
    while (v59 != (_QWORD *)v87);
    v77 = (int)(3000.0 / v60);
    if (v85 < v77)
      v77 = v85;
    v78 = (double)v77 * v61 / 1000.0;
    v55 = (unint64_t)v78 - v56;
    if ((unint64_t)v78 < v56)
      v55 = 0;
    v18 = v88;
  }
  *((_QWORD *)v18 + 7) = v56;
  *((_QWORD *)v18 + 8) = v55;
  v79 = operator new(0x20uLL);
  v79[2] = v18;
  v79[3] = v89;
  if (v89)
  {
    v80 = (unint64_t *)&v89->__shared_owners_;
    do
      v81 = __ldxr(v80);
    while (__stxr(v81 + 1, v80));
  }
  v82 = *v20;
  *v79 = *v20;
  v79[1] = v20;
  *(_QWORD *)(v82 + 8) = v79;
  *v20 = (uint64_t)v79;
  ++v20[2];
  if (v89)
  {
    v83 = (unint64_t *)&v89->__shared_owners_;
    do
      v84 = __ldaxr(v83);
    while (__stlxr(v84 - 1, v83));
    if (!v84)
    {
      ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
      std::__shared_weak_count::__release_weak(v89);
    }
  }
  std::mutex::unlock(v86);
}

void sub_1B677A360(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  sub_1B6772C88((uint64_t)&a14);
  std::mutex::unlock(a11);
  _Unwind_Resume(a1);
}

_QWORD *sub_1B677A398(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;

  if (result[2])
  {
    v1 = result;
    result = (_QWORD *)result[1];
    v2 = *v1;
    v3 = *result;
    *(_QWORD *)(v3 + 8) = *(_QWORD *)(*v1 + 8);
    **(_QWORD **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        v4 = (_QWORD *)result[1];
        operator delete(result);
        result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

void sub_1B677A3F8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6A15B50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1B677A408(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6A15B50;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC9814CLL);
}

void sub_1B677A440(_QWORD *a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v4 = a1[2];
  v5 = a1[1];
  if (v4 == v5)
    v6 = 0;
  else
    v6 = ((v4 - v5) << 7) - 1;
  v7 = a1[5];
  v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_1B677A558(a1);
    v5 = a1[1];
    v7 = a1[5];
    v8 = a1[4] + v7;
  }
  *(_DWORD *)(*(_QWORD *)(v5 + ((v8 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v8 & 0x3FF)) = *a2;
  a1[5] = v7 + 1;
}

void sub_1B677A4C4(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 32) >= 0x800uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(_QWORD *)(a1 + 8) += 8;
    *(_QWORD *)(a1 + 32) -= 1024;
  }
}

void sub_1B677A510(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6A15B18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1B677A520(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6A15B18;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC9814CLL);
}

void sub_1B677A558(_QWORD *a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  _QWORD *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  int64_t v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  unint64_t v23;
  uint64_t v24;
  void *v25;
  void *v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  __int128 v33;
  void *v34;
  __int128 v35;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  char *v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  unint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t *v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  char *v61;
  uint64_t v62;
  unint64_t v63;
  char *v64;
  uint64_t v65;
  uint64_t i;
  _QWORD *v67;
  char *v68;
  _BYTE *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  uint64_t *v81;
  uint64_t v82;
  uint64_t v83;
  char *v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t *v87;
  uint64_t v88;
  uint64_t v89;
  char *v90;
  uint64_t v91;
  __int128 v92;
  __int128 v93;
  uint64_t v94;
  __int128 v95;
  uint64_t v96;
  __int128 v97;

  v2 = a1[4];
  v3 = v2 >= 0x400;
  v4 = v2 - 1024;
  if (v3)
  {
    a1[4] = v4;
    v5 = (_QWORD *)a1[1];
    v6 = (char *)a1[2];
    v9 = *v5;
    v7 = (char *)(v5 + 1);
    v8 = v9;
    a1[1] = v7;
    if (v6 != (char *)a1[3])
      goto LABEL_41;
    v10 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1)
        v40 = 1;
      else
        v40 = (uint64_t)&v6[-*a1] >> 2;
      v41 = (char *)sub_1B677AA34(v40);
      v42 = &v41[8 * (v40 >> 2)];
      v44 = &v41[8 * v43];
      v45 = (uint64_t *)a1[1];
      v6 = v42;
      v46 = a1[2] - (_QWORD)v45;
      if (v46)
      {
        v6 = &v42[v46 & 0xFFFFFFFFFFFFFFF8];
        v47 = 8 * (v46 >> 3);
        v48 = &v41[8 * (v40 >> 2)];
        do
        {
          v49 = *v45++;
          *(_QWORD *)v48 = v49;
          v48 += 8;
          v47 -= 8;
        }
        while (v47);
      }
      goto LABEL_29;
    }
LABEL_5:
    v11 = v10 >> 3;
    v12 = v10 >> 3 < -1;
    v13 = (v10 >> 3) + 2;
    if (v12)
      v14 = v13;
    else
      v14 = v11 + 1;
    v15 = -(v14 >> 1);
    v16 = v14 >> 1;
    v17 = &v7[-8 * v16];
    v18 = v6 - v7;
    if (v6 != v7)
    {
      memmove(&v7[-8 * v16], v7, v6 - v7);
      v7 = (char *)a1[1];
    }
    v6 = &v17[v18];
    a1[1] = &v7[8 * v15];
    a1[2] = &v17[v18];
    goto LABEL_41;
  }
  v20 = (char *)a1[2];
  v19 = (char *)a1[3];
  v21 = (char *)*a1;
  v22 = (char *)a1[1];
  v23 = (v20 - v22) >> 3;
  v24 = (uint64_t)&v19[-*a1];
  if (v23 < v24 >> 3)
  {
    v25 = operator new(0x1000uLL);
    v26 = v25;
    if (v19 != v20)
    {
      *(_QWORD *)v20 = v25;
LABEL_42:
      a1[2] += 8;
      return;
    }
    if (v22 == v21)
    {
      if (v20 == v22)
        v51 = 1;
      else
        v51 = (v19 - v22) >> 2;
      v52 = 2 * v51;
      v53 = (char *)sub_1B677AA34(v51);
      v22 = &v53[(v52 + 6) & 0xFFFFFFFFFFFFFFF8];
      v55 = (uint64_t *)a1[1];
      v56 = v22;
      v57 = a1[2] - (_QWORD)v55;
      if (v57)
      {
        v56 = &v22[v57 & 0xFFFFFFFFFFFFFFF8];
        v58 = 8 * (v57 >> 3);
        v59 = &v53[(v52 + 6) & 0xFFFFFFFFFFFFFFF8];
        do
        {
          v60 = *v55++;
          *(_QWORD *)v59 = v60;
          v59 += 8;
          v58 -= 8;
        }
        while (v58);
      }
      v61 = (char *)*a1;
      *a1 = v53;
      a1[1] = v22;
      a1[2] = v56;
      a1[3] = &v53[8 * v54];
      if (v61)
      {
        operator delete(v61);
        v22 = (char *)a1[1];
      }
    }
    *((_QWORD *)v22 - 1) = v26;
    v7 = (char *)a1[1];
    v6 = (char *)a1[2];
    a1[1] = v7 - 8;
    v8 = *((_QWORD *)v7 - 1);
    a1[1] = v7;
    if (v6 != (char *)a1[3])
    {
LABEL_41:
      *(_QWORD *)v6 = v8;
      goto LABEL_42;
    }
    v10 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1)
        v85 = 1;
      else
        v85 = (uint64_t)&v6[-*a1] >> 2;
      v41 = (char *)sub_1B677AA34(v85);
      v42 = &v41[8 * (v85 >> 2)];
      v44 = &v41[8 * v86];
      v87 = (uint64_t *)a1[1];
      v6 = v42;
      v88 = a1[2] - (_QWORD)v87;
      if (v88)
      {
        v6 = &v42[v88 & 0xFFFFFFFFFFFFFFF8];
        v89 = 8 * (v88 >> 3);
        v90 = &v41[8 * (v85 >> 2)];
        do
        {
          v91 = *v87++;
          *(_QWORD *)v90 = v91;
          v90 += 8;
          v89 -= 8;
        }
        while (v89);
      }
LABEL_29:
      v50 = (char *)*a1;
      *a1 = v41;
      a1[1] = v42;
      a1[2] = v6;
      a1[3] = v44;
      if (v50)
      {
        operator delete(v50);
        v6 = (char *)a1[2];
      }
      goto LABEL_41;
    }
    goto LABEL_5;
  }
  v27 = v24 >> 2;
  if (v19 == v21)
    v28 = 1;
  else
    v28 = v27;
  v29 = (char *)sub_1B677AA34(v28);
  v31 = v30;
  v32 = &v29[8 * v23];
  *(_QWORD *)&v33 = v29;
  *((_QWORD *)&v33 + 1) = v32;
  v95 = v33;
  v34 = operator new(0x1000uLL);
  *(_QWORD *)&v35 = v32;
  *((_QWORD *)&v35 + 1) = &v29[8 * v31];
  if (v23 == v31)
  {
    v36 = 8 * v23;
    *(_QWORD *)&v37 = v95;
    if (v20 - v22 >= 1)
    {
      v38 = v36 >> 3;
      if (v38 >= -1)
        v39 = v38 + 1;
      else
        v39 = v38 + 2;
      v32 -= 8 * (v39 >> 1);
      *(_QWORD *)&v35 = v32;
      *((_QWORD *)&v37 + 1) = v32;
      goto LABEL_50;
    }
    v62 = v36 >> 2;
    if (v20 == v22)
      v63 = 1;
    else
      v63 = v62;
    v64 = (char *)sub_1B677AA34(v63);
    v32 = &v64[8 * (v63 >> 2)];
    *(_QWORD *)&v37 = v64;
    *((_QWORD *)&v37 + 1) = v32;
    *(_QWORD *)&v35 = v32;
    *((_QWORD *)&v35 + 1) = &v64[8 * v65];
    if (!v29)
      goto LABEL_50;
    v92 = v35;
    v95 = v37;
    operator delete(v29);
    v35 = v92;
  }
  v37 = v95;
LABEL_50:
  *(_QWORD *)v32 = v34;
  *(_QWORD *)&v35 = v35 + 8;
  for (i = a1[2]; i != a1[1]; i -= 8)
  {
    v67 = (_QWORD *)*((_QWORD *)&v37 + 1);
    if (*((_QWORD *)&v37 + 1) == (_QWORD)v37)
    {
      v69 = (_BYTE *)v35;
      if ((unint64_t)v35 >= *((_QWORD *)&v35 + 1))
      {
        if (*((_QWORD *)&v35 + 1) == *((_QWORD *)&v37 + 1))
          v74 = 1;
        else
          v74 = (uint64_t)(*((_QWORD *)&v35 + 1) - *((_QWORD *)&v37 + 1)) >> 2;
        v75 = (char *)sub_1B677AA34(v74);
        v68 = &v75[(2 * v74 + 6) & 0xFFFFFFFFFFFFFFF8];
        v77 = v68;
        v78 = v69 - (_BYTE *)v67;
        if (v69 != (_BYTE *)v67)
        {
          v77 = &v68[v78 & 0xFFFFFFFFFFFFFFF8];
          v79 = 8 * (v78 >> 3);
          v80 = v68;
          v81 = v67;
          do
          {
            v82 = *v81++;
            *(_QWORD *)v80 = v82;
            v80 += 8;
            v79 -= 8;
          }
          while (v79);
        }
        *(_QWORD *)&v37 = v75;
        *((_QWORD *)&v37 + 1) = v68;
        *(_QWORD *)&v35 = v77;
        *((_QWORD *)&v35 + 1) = &v75[8 * v76];
        if (v67)
        {
          v93 = v35;
          v97 = v37;
          operator delete(v67);
          v35 = v93;
          v37 = v97;
        }
      }
      else
      {
        v70 = (uint64_t)(*((_QWORD *)&v35 + 1) - v35) >> 3;
        if (v70 >= -1)
          v71 = v70 + 1;
        else
          v71 = v70 + 2;
        v72 = v71 >> 1;
        v73 = v35 + 8 * (v71 >> 1);
        v68 = (char *)(v73 - (v35 - *((_QWORD *)&v37 + 1)));
        if ((_QWORD)v35 == *((_QWORD *)&v37 + 1))
        {
          v69 = (_BYTE *)*((_QWORD *)&v37 + 1);
        }
        else
        {
          v94 = *((_QWORD *)&v35 + 1);
          v96 = v37;
          memmove((void *)(v73 - (v35 - *((_QWORD *)&v37 + 1))), *((const void **)&v37 + 1), v35 - *((_QWORD *)&v37 + 1));
          *((_QWORD *)&v35 + 1) = v94;
          *(_QWORD *)&v37 = v96;
        }
        *((_QWORD *)&v37 + 1) = v68;
        *(_QWORD *)&v35 = &v69[8 * v72];
      }
    }
    else
    {
      v68 = (char *)*((_QWORD *)&v37 + 1);
    }
    v83 = *(_QWORD *)(i - 8);
    *((_QWORD *)v68 - 1) = v83;
    *((_QWORD *)&v37 + 1) -= 8;
  }
  v84 = (char *)*a1;
  *(_OWORD *)a1 = v37;
  *((_OWORD *)a1 + 1) = v35;
  if (v84)
    operator delete(v84);
}

void sub_1B677AA04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int128 a11)
{
  void *v11;

  operator delete(v11);
  if ((_QWORD)a11)
    operator delete((void *)a11);
  _Unwind_Resume(a1);
}

void *sub_1B677AA34(unint64_t a1)
{
  if (a1 >> 61)
    sub_1B6773BF4();
  return operator new(8 * a1);
}

void *sub_1B677AA68(void *result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t i;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _OWORD *v20;

  if (a2 >= 1)
  {
    v9 = (int)result;
    v10 = 0;
    v11 = (int)(result & 0xFFFFFFC0);
    v12 = ((~(result & 0xFFFFFFC0) + (_DWORD)result) & 0xFFFFFFF0) + 16;
    v13 = a2;
    v14 = a3;
    v15 = a5;
    do
    {
      if ((int)v11 >= 1)
      {
        for (i = 0; i < v11; i += 64)
        {
          v17 = *(_OWORD *)(v14 + i + 16);
          v18 = *(_OWORD *)(v14 + i + 32);
          v19 = *(_OWORD *)(v14 + i + 48);
          v20 = (_OWORD *)(v15 + i);
          *v20 = *(_OWORD *)(v14 + i);
          v20[1] = v17;
          v20[2] = v18;
          v20[3] = v19;
        }
      }
      if ((int)v11 < v9)
        result = memcpy((void *)(a5 + v11 + v10 * a6), (const void *)(a3 + v11 + v10 * a4), v12);
      ++v10;
      v14 += a4;
      v15 += a6;
    }
    while (v10 != v13);
  }
  return result;
}

void sub_1B677AB54(void ***a1)
{
  void **v1;
  __CVBuffer **v2;
  __CVBuffer **v4;
  void *v5;

  v1 = *a1;
  v2 = (__CVBuffer **)**a1;
  if (v2)
  {
    v4 = (__CVBuffer **)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        v4 = sub_1B677AC1C(v4 - 3);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1B677ABC4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 144);
  if (v2)
    MEMORY[0x1BCC9811C](v2, 0x1000C8077774924);
  v3 = *(_QWORD *)(a1 + 152);
  if (v3)
    MEMORY[0x1BCC9811C](v3, 0x1000C8077774924);
  return a1;
}

__CVBuffer **sub_1B677AC1C(__CVBuffer **a1)
{
  __CVBuffer *v2;

  v2 = *a1;
  if (v2)
  {
    CVPixelBufferRelease(v2);
    *a1 = 0;
  }
  return a1;
}

uint64_t sub_1B677AC50(uint64_t a1, int a2, __CVBuffer *a3)
{
  unint64_t v5;
  id v6;
  void *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  __CVBuffer *v13;
  uint64_t v14;
  uint64_t v15;
  size_t WidthOfPlane;
  size_t HeightOfPlane;
  char v18;
  uint64_t v19;
  size_t BytesPerRowOfPlane;
  unint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  size_t v26;
  size_t v27;
  void *v28;
  void *v29;
  void *v30;
  void *BaseAddressOfPlane;
  uint64_t v32;
  size_t v33;
  int Height;
  int Width;
  char v36;
  __int128 v37;
  uint64_t v38;

  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 184) - *(_QWORD *)(a1 + 176)) >> 3) > a2)
  {
    v5 = a2;
    v6 = *(id *)a1;
    v7 = v6;
    if (!v6
      || !*(_BYTE *)(a1 + 248)
      || (v8 = (uint64_t *)(*(_QWORD *)(a1 + 176) + 24 * (int)v5),
          v9 = *v8,
          v10 = v8[1],
          *(_QWORD *)&v11 = (int)v10,
          *((_QWORD *)&v11 + 1) = SHIDWORD(v10),
          v37 = v11,
          v38 = 0,
          objc_msgSend(v6, "copySubframe:toFrame:atOffset:", v9, a3, &v37)))
    {
      if (!a3)
      {
        v19 = 4294954394;
        goto LABEL_19;
      }
      v12 = *(_QWORD *)(a1 + 176) + 24 * (int)v5;
      v13 = *(__CVBuffer **)v12;
      v15 = *(int *)(v12 + 8);
      v14 = *(int *)(v12 + 12);
      WidthOfPlane = CVPixelBufferGetWidthOfPlane(a3, 1uLL);
      v36 = WidthOfPlane < CVPixelBufferGetWidth(a3);
      HeightOfPlane = CVPixelBufferGetHeightOfPlane(a3, 1uLL);
      v18 = HeightOfPlane < CVPixelBufferGetHeight(a3);
      v19 = CVPixelBufferLockBaseAddress(v13, 1uLL);
      if ((_DWORD)v19)
      {
LABEL_19:

        return v19;
      }
      v19 = CVPixelBufferLockBaseAddress(a3, 0);
      if ((_DWORD)v19)
      {
        CVPixelBufferUnlockBaseAddress(v13, 1uLL);
        goto LABEL_19;
      }
      Width = CVPixelBufferGetWidth(a3);
      Height = CVPixelBufferGetHeight(a3);
      BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a3, 0);
      v33 = CVPixelBufferGetBytesPerRowOfPlane(a3, 1uLL);
      BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(a3, 0);
      v30 = CVPixelBufferGetBaseAddressOfPlane(a3, 1uLL);
      v29 = CVPixelBufferGetBaseAddressOfPlane(v13, 0);
      v28 = CVPixelBufferGetBaseAddressOfPlane(v13, 1uLL);
      v27 = CVPixelBufferGetBytesPerRowOfPlane(v13, 0);
      v26 = CVPixelBufferGetBytesPerRowOfPlane(v13, 1uLL);
      LODWORD(v21) = CVPixelBufferGetWidth(v13);
      v22 = CVPixelBufferGetHeight(v13);
      v23 = (uint64_t)BaseAddressOfPlane + v15 + BytesPerRowOfPlane * v14;
      v32 = (uint64_t)v30 + v15 + v33 * ((int)v14 >> v18);
      if (Width - (int)v15 >= (int)v21)
        v21 = v21;
      else
        v21 = (Width - v15);
      if (Height - (int)v14 >= v22)
        v24 = v22;
      else
        v24 = Height - v14;
      sub_1B677AA68((void *)v21, v24, (uint64_t)v29, v27, v23, BytesPerRowOfPlane);
      sub_1B677AA68((void *)((2 * (int)v21) >> v36), v24 >> v18, (uint64_t)v28, v26, v32, v33);
      CVPixelBufferUnlockBaseAddress(v13, 1uLL);
      CVPixelBufferUnlockBaseAddress(a3, 0);
    }
    v19 = 0;
    *(_QWORD *)(*(_QWORD *)(a1 + 200) + ((v5 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v5;
    goto LABEL_19;
  }
  return 4294954385;
}

void sub_1B677AF18(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_1B677AF2C(_QWORD *a1, CVPixelBufferRef pixelBuffer)
{
  __CVBuffer *v2;
  _QWORD *v3;
  int Width;
  int Height;
  int v6;
  size_t v7;
  const std::nothrow_t *v8;
  void *v9;
  size_t v10;
  void *v11;
  void *v12;
  id v13;
  char *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  unint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _DWORD *v27;
  int v28;
  void *v29;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  __CVBuffer *v40;
  size_t BytesPerRowOfPlane;
  size_t v42;
  size_t HeightOfPlane;
  size_t v44;
  char v45;
  size_t v46;
  char v47;
  id v48;
  size_t WidthOfPlane;
  char *v50;
  char *BaseAddressOfPlane;
  uint64_t v52;
  unsigned __int8 *v53;
  unsigned __int8 *v54;
  uint8_t buf[16];
  uint8_t v56[16];

  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[23] - a1[22]) >> 3) != a1[26])
    return 4294954385;
  v2 = pixelBuffer;
  v3 = a1;
  Width = CVPixelBufferGetWidth(pixelBuffer);
  Height = CVPixelBufferGetHeight(v2);
  if (!*((_BYTE *)v3 + 168))
  {
    v3[11] = sub_1B687E070;
    v3[12] = sub_1B687E550;
    v3[13] = sub_1B687E980;
    v3[14] = sub_1B687EABC;
    v3[15] = sub_1B687EB48;
    v3[16] = sub_1B6880664;
    if (Width <= Height)
      v6 = Height;
    else
      v6 = Width;
    *((_DWORD *)v3 + 36) = v6 >> 3;
    *((_DWORD *)v3 + 37) = v6 >> 2;
    v7 = (uint64_t)v6 >> 3;
    v8 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
    v9 = operator new[](v7, MEMORY[0x1E0DE4E10]);
    v3[19] = v9;
    v10 = (uint64_t)v6 >> 2;
    v11 = operator new[](v10, v8);
    v3[20] = v11;
    if (!v9 || (v12 = v11) == 0)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Decoder failed to initialize stitching filter", buf, 2u);
      }
      return 4294954392;
    }
    memset(v9, 52, v7);
    memset(v12, 13, v10);
    *((_BYTE *)v3 + 168) = 1;
  }
  v13 = (id)*v3;
  v48 = v13;
  if (!v13 || !*((_BYTE *)v3 + 248))
    goto LABEL_44;
  v14 = (char *)v3[28];
  v3[29] = v14;
  v15 = v3[26];
  if (v15 >= 2)
  {
    v16 = 1;
    while (1)
    {
      if (((*(_QWORD *)(v3[25] + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v16) & 1) != 0)
      {
        v17 = v3[22];
        if (*(_DWORD *)(v17 + 24 * v16 + 8))
        {
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)v56 = 0;
            _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "X offset not yet supported in Metal", v56, 2u);
          }
          goto LABEL_44;
        }
        v18 = *(_DWORD *)(v17 + 24 * v16 + 12);
        if (v18)
        {
          v19 = v3[30];
          if ((unint64_t)v14 >= v19)
          {
            v21 = (char *)v3[28];
            v22 = (v14 - v21) >> 2;
            v23 = v22 + 1;
            if ((unint64_t)(v22 + 1) >> 62)
              sub_1B6773BAC();
            v24 = v19 - (_QWORD)v21;
            if (v24 >> 1 > v23)
              v23 = v24 >> 1;
            if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL)
              v25 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v25 = v23;
            if (v25)
            {
              v25 = (unint64_t)sub_1B6773BC0(v25);
              v21 = (char *)v3[28];
              v14 = (char *)v3[29];
            }
            else
            {
              v26 = 0;
            }
            v27 = (_DWORD *)(v25 + 4 * v22);
            *v27 = v18;
            v20 = (char *)(v27 + 1);
            while (v14 != v21)
            {
              v28 = *((_DWORD *)v14 - 1);
              v14 -= 4;
              *--v27 = v28;
            }
            v3[28] = v27;
            v3[29] = v20;
            v3[30] = v25 + 4 * v26;
            if (v21)
              operator delete(v21);
          }
          else
          {
            *(_DWORD *)v14 = v18;
            v20 = v14 + 4;
          }
          v3[29] = v20;
          v15 = v3[26];
          v14 = v20;
        }
      }
      if (v15 <= ++v16)
      {
        v29 = v48;
        goto LABEL_40;
      }
    }
  }
  v29 = v13;
LABEL_40:
  if (objc_msgSend(v29, "subframeDeblock:withOffsetsY:numEdges:", v2))
  {
LABEL_44:
    CVPixelBufferLockBaseAddress(v2, 0);
    if (v3[26] >= 2uLL)
    {
      v31 = 0;
      v32 = v3[25];
      v33 = 1;
      do
      {
        v34 = v33 >> 6;
        v35 = 1 << v33;
        v36 = *(_QWORD *)(v32 + 8 * (v33 >> 6));
        if ((v36 & (1 << v33)) != 0)
        {
          v37 = v3[22] + v31;
          v38 = *(unsigned int *)(v37 + 32);
          v54 = (unsigned __int8 *)v3[19];
          v39 = v3;
          v52 = *(unsigned int *)(v37 + 36);
          v53 = (unsigned __int8 *)v3[20];
          v40 = v2;
          BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(v2, 0);
          v50 = (char *)CVPixelBufferGetBaseAddressOfPlane(v2, 1uLL);
          BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v2, 0);
          v42 = CVPixelBufferGetBytesPerRowOfPlane(v40, 1uLL);
          WidthOfPlane = CVPixelBufferGetWidthOfPlane(v40, 0);
          HeightOfPlane = CVPixelBufferGetHeightOfPlane(v40, 0);
          v44 = CVPixelBufferGetWidthOfPlane(v40, 1uLL);
          v45 = v44 < CVPixelBufferGetWidth(v40);
          v46 = CVPixelBufferGetHeightOfPlane(v40, 1uLL);
          v47 = v46 < CVPixelBufferGetHeight(v40);
          if ((int)v38 >= 1)
          {
            ((void (*)(char *, size_t, unsigned __int8 *, unsigned __int8 *, size_t))v39[11])(&BaseAddressOfPlane[v38], BytesPerRowOfPlane, v54, v53, HeightOfPlane);
            ((void (*)(char *, size_t, _QWORD, _QWORD, _QWORD))v39[15])(&v50[(2 * v38) >> v45], v42, *v54, *v53, ((int)HeightOfPlane >> v47));
          }
          if ((int)v52 >= 1)
          {
            ((void (*)(char *, size_t, unsigned __int8 *, unsigned __int8 *, size_t))v39[12])(&BaseAddressOfPlane[BytesPerRowOfPlane * v52], BytesPerRowOfPlane, v54, v53, WidthOfPlane);
            ((void (*)(char *, size_t, _QWORD, _QWORD, _QWORD))v39[16])(&v50[v42 * (v52 >> v47)], v42, *v54, *v53, ((int)WidthOfPlane >> v45));
          }
          v3 = v39;
          v32 = v39[25];
          v35 = 1 << v33;
          v34 = v33 >> 6;
          v36 = *(_QWORD *)(v32 + 8 * (v33 >> 6));
          v2 = v40;
        }
        *(_QWORD *)(v32 + 8 * v34) = v36 & ~v35;
        ++v33;
        v31 += 24;
      }
      while (v3[26] > v33);
    }
    v29 = v48;
    CVPixelBufferUnlockBaseAddress(v2, 0);
  }

  return 0;
}

void sub_1B677B458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

uint64_t sub_1B677B478()
{
  size_t v1;

  if ((byte_1EF1387CD & 1) == 0)
  {
    v1 = 4;
    if (sysctlbyname("hw.physicalcpu", &dword_1EF137C80, &v1, 0, 0))
      dword_1EF137C80 = 1;
    byte_1EF1387CD = 1;
  }
  return dword_1EF137C80;
}

void sub_1B677B4E8(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)a1[112];
  if (v2)
  {
    free(v2);
    a1[112] = 0;
  }
  v3 = (void *)a1[113];
  if (v3)
  {
    free(v3);
    a1[113] = 0;
  }
  v4 = (void *)a1[118];
  if (v4)
  {
    free(v4);
    a1[118] = 0;
  }
}

void sub_1B677B534(uint64_t a1, char *a2, uint64_t a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, float a8)
{
  float v9;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t i;
  uint64_t v26;
  __int128 *v27;
  float32x4_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 *v40;
  float32x4_t v41;
  void *v42;
  void *v43;
  size_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  int8x16_t v48;
  int8x16_t v49;
  int8x16_t v50;
  int8x16_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  int16x4_t *v56;
  int8x8_t v57;
  int16x4_t v58;
  int16x4_t v59;
  int16x4_t v60;
  int16x4_t v61;
  int16x4_t v62;
  int16x4_t v63;
  int16x4_t v64;
  int32x4_t v65;
  int32x4_t v66;
  int32x4_t v67;
  int32x4_t v68;
  int32x4_t v69;
  int32x4_t v70;
  int32x4_t v71;
  int32x4_t v72;
  int32x4_t *v73;
  int32x4_t v74;
  int32x4_t v75;
  int32x4_t v76;
  int32x4_t v77;
  int32x4_t v78;
  int32x4_t v79;
  int32x4_t v80;
  int32x4_t v81;
  int32x4_t v82;
  int32x4_t v83;
  int32x4_t v84;
  int32x4_t v85;
  int32x4_t v86;
  int32x4_t v87;
  int32x4_t v88;
  int32x4_t v89;
  int32x4_t v90;
  int32x4_t v91;
  int32x4_t v92;
  int32x4_t v93;
  int32x4_t v94;
  int32x4_t v95;
  int32x4_t v96;
  int32x4_t v97;
  int32x4_t v98;
  int32x4_t v99;
  int32x4_t v100;
  int32x4_t v101;
  int32x4_t v102;
  int32x4_t v103;
  int32x4_t v104;
  int32x4_t v105;
  int32x4_t v106;
  int32x4_t v107;
  int32x4_t v108;
  int32x4_t v109;
  uint32x4_t v110;
  uint32x4_t v111;
  int32x4_t v112;
  int32x4_t v113;
  int32x4_t v114;
  int32x4_t v115;
  uint32x4_t v116;
  int32x4_t v117;
  int32x4_t v118;
  uint32x4_t v119;
  uint32x4_t v120;
  uint32x4_t v121;
  int32x4_t v122;
  int32x4_t v123;
  int32x4_t v124;
  int32x4_t v125;
  int32x4_t v126;
  int32x4_t v127;
  int16x8_t v128;
  int32x4_t v129;
  int32x4_t v130;
  int32x4_t v131;
  int32x4_t v132;
  int16x8_t v133;
  int8x8_t v134;
  int32x4_t v135;
  int32x4_t v136;
  int32x4_t v137;
  int32x4_t v138;
  int16x8_t v139;
  int32x4_t v140;
  int32x4_t v141;
  int32x4_t v142;
  int32x4_t v143;
  int16x8_t v144;
  int32x4_t v145;
  int32x4_t v146;
  int32x4_t v147;
  int32x4_t v148;
  int16x8_t v149;
  int32x4_t v150;
  int32x4_t v151;
  int16x8_t v152;
  int32x4_t v153;
  int32x4_t v154;
  int16x8_t v155;
  int16x8_t v156;
  int16x8_t v157;
  int16x8_t v158;
  int16x8_t v159;
  int16x8_t v160;
  int16x8_t v161;
  int16x8_t v162;
  int16x8_t v163;
  __int16 v164;
  __int16 v165;
  __int16 v166;
  __int16 v167;
  int v168;
  int v169;
  int v170;
  int v171;
  int v172;
  int v173;
  int v174;
  int v175;
  int v176;
  int v177;
  int v178;
  int v179;
  int v180;
  __int16 v181;
  __int16 v182;
  int v183;
  int v184;
  int v185;
  __int16 *v186;
  uint64_t v187;
  int v188;
  int16x8_t v189;
  int16x8_t v190;
  int16x8_t v191;
  int16x8_t v192;
  int16x8_t v193;
  int16x8_t v194;
  int16x8_t v195;
  int16x8_t v196;
  int16x8_t v197;
  int16x8_t v198;
  int16x8_t v199;
  int16x8_t v200;
  int16x8_t v201;
  int16x8_t v202;
  int16x8_t v203;
  int16x8_t v204;
  int16x8_t v205;
  int16x8_t v206;
  int16x8_t v207;
  int16x8_t v208;
  int16x8_t v209;
  int16x8_t v210;
  int16x8_t v211;
  int16x8_t v212;
  int16x8_t v213;
  int16x8_t v214;
  int16x8_t v215;
  int16x8_t v216;
  int16x8_t v217;
  int16x8_t v218;
  int16x8_t v219;
  int16x8_t v220;
  int16x8_t v221;
  int16x8_t v222;
  unsigned int v223;
  int16x8_t v224;
  int v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint8x16_t v229;
  __int128 v230;
  __int128 v231;
  __int128 v232;
  __int128 v233;
  int8x16_t v234;
  int8x16_t v235;
  int8x16_t v236;
  int8x16_t v237;
  size_t v238;
  int16x8_t *v239;
  int8x16_t v240;
  int8x16_t v241;
  int16x8_t v242;
  int16x8_t v243;
  int8x16_t v244;
  int8x16_t v245;
  int8x16_t v246;
  int8x16_t v247;
  int8x16_t v248;
  uint16x8_t v249;
  uint16x8_t v250;
  uint16x8_t v251;
  uint16x8_t v252;
  char v253;
  uint64_t v255;
  unint64_t v256;
  unint64_t v257;
  int8x8_t v259;
  int16x8_t v260;
  int16x8_t v261;
  int16x8_t v262;
  int16x8_t v263;
  int16x8_t v264;
  int16x8_t v265;
  int16x8_t v266;
  int16x8_t v267;
  unsigned int v268;
  unsigned int v269;
  unsigned int v270;
  unsigned int v271;
  unsigned int v272;
  unsigned int v273;
  unsigned int v274;
  unsigned int v275;
  unsigned int v276;
  unsigned int v277;
  unsigned int v278;
  unsigned int v279;
  unsigned int v280;
  unsigned int v281;
  unsigned int v282;
  unsigned int v283;
  unsigned int v284;
  unsigned int v285;
  unsigned int v286;
  unsigned int v287;
  unsigned int v288;
  unsigned int v289;
  unsigned int v290;
  unsigned int v291;
  unsigned int v292;
  unsigned int v293;
  unsigned int v294;
  unsigned int v295;
  unsigned int v296;
  unsigned int v297;
  unsigned int v298;
  unsigned int v299;
  uint64_t v300;
  int8x16x2_t v301;
  int8x16x2_t v302;

  v9 = a8;
  v300 = *MEMORY[0x1E0C80C00];
  v255 = a5;
  if (*(_QWORD *)(a1 + 912) != a4 || *(_QWORD *)(a1 + 920) != a5)
  {
    sub_1B677B4E8((_QWORD *)a1);
    v9 = a8;
    a5 = v255;
    if (a4)
    {
      if (v255)
      {
        *(_QWORD *)(a1 + 896) = malloc_type_malloc(2 * v255 * a4, 0xAF7B4C98uLL);
        *(_QWORD *)(a1 + 904) = malloc_type_malloc(2 * v255 * a4, 0xA2B192A7uLL);
        v14 = malloc_type_malloc(v255 * a4, 0x822FC793uLL);
        v9 = a8;
        a5 = v255;
        *(_QWORD *)(a1 + 944) = v14;
        if (!*(_QWORD *)(a1 + 896) || !*(_QWORD *)(a1 + 904))
          goto LABEL_21;
        v15 = 0;
        v16 = 0;
        LODWORD(v17) = 0;
        do
        {
          v18 = 0;
          v17 = (int)v17;
          v19 = v15;
          do
          {
            *(_WORD *)(a1 + 2 * v17++ + 128) = v19;
            ++v18;
            v19 += a3 + 1;
          }
          while (v18 != 8);
          ++v16;
          v15 += a3 - 1;
        }
        while (v16 != 8);
        v20 = 0;
        v21 = 0;
        LODWORD(v22) = 0;
        do
        {
          v23 = 0;
          v22 = (int)v22;
          v24 = v20;
          do
          {
            *(_WORD *)(a1 + 2 * v22++ + 256) = v24;
            ++v23;
            v24 += a4 + 1;
          }
          while (v23 != 8);
          ++v21;
          v20 += a4 - 1;
        }
        while (v21 != 8);
        for (i = 1; i != 64; ++i)
          *(_WORD *)(a1 + 2 * i) = 0x10u / i;
        v26 = 0;
        *(_WORD *)a1 = 16;
        v27 = &xmmword_1B691FE38;
        do
        {
          v28 = (float32x4_t)*v27++;
          *(int16x4_t *)(a1 + 768 + v26) = vmovn_s32(vcvtq_s32_f32(vrndaq_f32(vmulq_n_f32(v28, a8))));
          v26 += 8;
        }
        while (v26 != 128);
        *(_QWORD *)(a1 + 928) = a3;
        *(float *)(a1 + 936) = a8;
        *(_QWORD *)(a1 + 912) = a4;
        *(_QWORD *)(a1 + 920) = v255;
      }
    }
  }
  if (!a5)
  {
    v253 = 1;
    goto LABEL_25;
  }
LABEL_21:
  v29 = 0;
  v30 = a5;
  do
  {
    memcpy((void *)(*(_QWORD *)(a1 + 944) + v29), a2, a4);
    a2 += a3;
    v29 += a4;
    --v30;
  }
  while (v30);
  v253 = 0;
  a5 = v255;
  v9 = a8;
LABEL_25:
  v31 = *(_QWORD *)(a1 + 944);
  if (*(_QWORD *)(a1 + 928) != a4)
  {
    v32 = 0;
    v33 = 0;
    v34 = 0;
    *(_QWORD *)(a1 + 928) = a4;
    do
    {
      v35 = 0;
      v36 = v34;
      v37 = v32;
      v38 = a1 + 128 + 2 * v34;
      do
      {
        *(_WORD *)(v38 + 2 * v35++) = v37;
        v37 += a4 + 1;
      }
      while (v35 != 8);
      v34 = v36 + 8;
      ++v33;
      v32 += a4 - 1;
    }
    while (v33 != 8);
  }
  if (vabds_f32(*(float *)(a1 + 936), v9) > 1.0e-10)
  {
    v39 = 0;
    *(float *)(a1 + 936) = v9;
    v40 = &xmmword_1B691FE38;
    do
    {
      v41 = (float32x4_t)*v40++;
      *(int16x4_t *)(a1 + 768 + v39) = vmovn_s32(vcvtq_s32_f32(vrndaq_f32(vmulq_n_f32(v41, v9))));
      v39 += 8;
    }
    while (v39 != 128);
  }
  v42 = *(void **)(a1 + 904);
  v43 = *(void **)(a1 + 896);
  v44 = a5 * a4;
  v45 = a5;
  bzero(v43, 2 * a5 * a4);
  bzero(v42, v44);
  v256 = v45 - 15;
  if (v45 != 15)
  {
    v257 = 0;
    v46 = a4 - 8;
    v47 = a1 + 526;
    v48 = (int8x16_t)xmmword_1B6917360;
    v49 = (int8x16_t)xmmword_1B6917370;
    v50 = (int8x16_t)xmmword_1B6917380;
    v51 = (int8x16_t)xmmword_1B6917390;
    do
    {
      if (v46 >= 8)
      {
        v52 = 7;
        do
        {
          v53 = 0;
          v54 = v52 + v257 * a4;
          do
          {
            *(_WORD *)(a1 + v53 + 384) = *(unsigned __int8 *)(v31 + v54 + *(__int16 *)(a1 + v53 + 128));
            v53 += 2;
          }
          while (v53 != 128);
          v55 = -32;
          v56 = (int16x4_t *)(a1 + 384);
          do
          {
            v301 = *(int8x16x2_t *)v56->i8;
            v302 = *(int8x16x2_t *)v56[4].i8;
            v57 = (int8x8_t)vzip1_s16(*(int16x4_t *)v302.val[0].i8, *(int16x4_t *)v302.val[1].i8);
            v58.i32[0] = vzip1_s16(*v56, *(int16x4_t *)v301.val[1].i8).u32[0];
            v58.i32[1] = vext_s8(*(int8x8_t *)&v302, v57, 4uLL).i32[1];
            v59.i32[0] = vtrn2_s16(*v56, *(int16x4_t *)v301.val[1].i8).u32[0];
            v59.i32[1] = v57.i32[1];
            v57.i16[2] = WORD2(*(_QWORD *)&v56[4]);
            v57.i16[3] = WORD2(*(_QWORD *)&v56[6]);
            v60.i32[0] = vzip2_s16(*v56, *(int16x4_t *)v301.val[1].i8).u32[0];
            v60.i32[1] = v57.i32[1];
            v61.i32[0] = vuzp2_s16(vuzp2_s16(*v56, *(int16x4_t *)v301.val[1].i8), *v56).u32[0];
            v61.i32[1] = vzip2_s16(*(int16x4_t *)&v302, *(int16x4_t *)(&v302 + 16)).i32[1];
            v62.i32[0] = vzip2q_s16(*(int16x8_t *)v56->i8, (int16x8_t)v301.val[1]).u32[0];
            v62.i32[1] = vqtbl2q_s8(v302, v48).i32[1];
            v63.i32[0] = vqtbl2q_s8(*(int8x16x2_t *)v56->i8, v49).u32[0];
            v63.i32[1] = vzip2q_s16(*(int16x8_t *)&v302, *(int16x8_t *)(&v302 + 16)).i32[1];
            v64.i32[0] = vqtbl2q_s8(*(int8x16x2_t *)v56->i8, v51).u32[0];
            v64.i32[1] = vqtbl2q_s8(v302, v50).i32[1];
            v301.val[0].i32[0] = vqtbl2q_s8(*(int8x16x2_t *)v56->i8, (int8x16_t)xmmword_1B69173B0).u32[0];
            v301.val[0].i32[1] = vqtbl2q_s8(v302, (int8x16_t)xmmword_1B69173A0).i32[1];
            v301.val[1] = (int8x16_t)vaddl_s16(*(int16x4_t *)v301.val[0].i8, v58);
            v302.val[0] = (int8x16_t)vaddl_s16(v64, v59);
            v302.val[1] = (int8x16_t)vaddl_s16(v63, v60);
            v65 = vaddl_s16(v62, v61);
            v301.val[0] = (int8x16_t)vsubl_s16(v58, *(int16x4_t *)v301.val[0].i8);
            v66 = vsubl_s16(v59, v64);
            v67 = vsubl_s16(v60, v63);
            v68 = vsubl_s16(v61, v62);
            v69 = vaddq_s32((int32x4_t)v301.val[1], v65);
            v70 = vaddq_s32((int32x4_t)v302.val[0], (int32x4_t)v302.val[1]);
            v301.val[1] = (int8x16_t)vsubq_s32((int32x4_t)v301.val[1], v65);
            v302.val[0] = (int8x16_t)vsubq_s32((int32x4_t)v302.val[0], (int32x4_t)v302.val[1]);
            v302.val[1] = (int8x16_t)vsraq_n_s32(vaddq_s32(vaddq_s32(v66, (int32x4_t)v301.val[0]), v67), (int32x4_t)v301.val[0], 1uLL);
            v71 = vsubq_s32((int32x4_t)v301.val[0], vsraq_n_s32(vaddq_s32(v67, v68), v67, 1uLL));
            v301.val[0] = (int8x16_t)vsubq_s32(vaddq_s32(v68, (int32x4_t)v301.val[0]), vsraq_n_s32(v66, v66, 1uLL));
            v72 = vaddq_s32(vsraq_n_s32(v68, v68, 1uLL), vsubq_s32(v66, v67));
            v73 = (int32x4_t *)&v260.i8[v55];
            v73[2] = vaddq_s32(v69, v70);
            v73[6] = vsraq_n_s32((int32x4_t)v301.val[1], (int32x4_t)v302.val[0], 1uLL);
            v73[10] = vsubq_s32(v69, v70);
            v73[14] = vsubq_s32(vshrq_n_s32((int32x4_t)v301.val[1], 1uLL), (int32x4_t)v302.val[0]);
            v73[4] = vsraq_n_s32((int32x4_t)v302.val[1], v72, 2uLL);
            v73[8] = vsraq_n_s32(v71, (int32x4_t)v301.val[0], 2uLL);
            v73[12] = vsubq_s32((int32x4_t)v301.val[0], vshrq_n_s32(v71, 2uLL));
            v73[16] = vsubq_s32(vshrq_n_s32((int32x4_t)v302.val[1], 2uLL), v72);
            v56 += 8;
            v55 += 16;
          }
          while (v55);
          v74.i64[0] = __PAIR64__(v262.u32[0], v260.u32[0]);
          v74.i64[1] = __PAIR64__(v266.u32[0], v264.u32[0]);
          v75.i64[0] = __PAIR64__(v276, v268);
          v76.i64[0] = __PAIR64__(v277, v269);
          v75.i64[1] = __PAIR64__(v292, v284);
          v77.i64[0] = __PAIR64__(v263.u32[3], v261.u32[3]);
          v77.i64[1] = __PAIR64__(v267.u32[3], v265.u32[3]);
          v78.i64[0] = __PAIR64__(v283, v275);
          v79.i64[0] = __PAIR64__(v282, v274);
          v78.i64[1] = __PAIR64__(v299, v291);
          v80 = vaddq_s32(v78, v75);
          v81 = vaddq_s32(v77, v74);
          v82.i64[0] = __PAIR64__(v262.u32[1], v260.u32[1]);
          v82.i64[1] = __PAIR64__(v266.u32[1], v264.u32[1]);
          v76.i64[1] = __PAIR64__(v293, v285);
          v83.i64[0] = __PAIR64__(v263.u32[2], v261.u32[2]);
          v83.i64[1] = __PAIR64__(v267.u32[2], v265.u32[2]);
          v79.i64[1] = __PAIR64__(v298, v290);
          v84 = vaddq_s32(v79, v76);
          v85.i64[0] = __PAIR64__(v278, v270);
          v86.i64[0] = __PAIR64__(v279, v271);
          v85.i64[1] = __PAIR64__(v294, v286);
          v87 = vaddq_s32(v83, v82);
          v88.i64[0] = __PAIR64__(v281, v273);
          v89.i64[0] = __PAIR64__(v280, v272);
          v88.i64[1] = __PAIR64__(v297, v289);
          v90 = vaddq_s32(v88, v85);
          v91.i64[0] = __PAIR64__(v262.u32[2], v260.u32[2]);
          v91.i64[1] = __PAIR64__(v266.u32[2], v264.u32[2]);
          v92.i64[0] = __PAIR64__(v263.u32[1], v261.u32[1]);
          v92.i64[1] = __PAIR64__(v267.u32[1], v265.u32[1]);
          v93 = vaddq_s32(v92, v91);
          v94.i64[0] = __PAIR64__(v262.u32[3], v260.u32[3]);
          v94.i64[1] = __PAIR64__(v266.u32[3], v264.u32[3]);
          v86.i64[1] = __PAIR64__(v295, v287);
          v95.i64[0] = __PAIR64__(v263.u32[0], v261.u32[0]);
          v95.i64[1] = __PAIR64__(v267.u32[0], v265.u32[0]);
          v89.i64[1] = __PAIR64__(v296, v288);
          v96 = vaddq_s32(v89, v86);
          v97 = vaddq_s32(v95, v94);
          v98 = vsubq_s32(v75, v78);
          v99 = vsubq_s32(v74, v77);
          v100 = vsubq_s32(v82, v83);
          v101 = vsubq_s32(v76, v79);
          v102 = vsubq_s32(v85, v88);
          v103 = vsubq_s32(v91, v92);
          v104 = vsubq_s32(v94, v95);
          v105 = vsubq_s32(v86, v89);
          v106 = vaddq_s32(v97, v81);
          v107 = vaddq_s32(v96, v80);
          v108 = vaddq_s32(v93, v87);
          v109 = vaddq_s32(v90, v84);
          v110 = (uint32x4_t)vsubq_s32(v81, v97);
          v111 = (uint32x4_t)vsubq_s32(v80, v96);
          v112 = vsubq_s32(v87, v93);
          v113 = vsubq_s32(v84, v90);
          v114 = vaddq_s32(v100, v103);
          v115 = vsubq_s32(v100, v103);
          v116 = (uint32x4_t)vsubq_s32(v99, vaddq_s32(vsraq_n_s32(v103, v103, 1uLL), v104));
          v117 = vaddq_s32(v101, v102);
          v118 = vsubq_s32(v101, v102);
          v119 = (uint32x4_t)vsubq_s32(v98, vaddq_s32(vsraq_n_s32(v102, v102, 1uLL), v105));
          v120 = (uint32x4_t)vaddq_s32(vsraq_n_s32(v99, v99, 1uLL), v114);
          v121 = (uint32x4_t)vaddq_s32(vsraq_n_s32(v98, v98, 1uLL), v117);
          v122 = vaddq_s32(vsubq_s32(v99, vsraq_n_s32(v100, v100, 1uLL)), v104);
          v123 = vaddq_s32(vsubq_s32(v98, vsraq_n_s32(v101, v101, 1uLL)), v105);
          v124 = vsraq_n_s32(vaddq_s32(v115, v104), v104, 1uLL);
          v125 = vsraq_n_s32(vaddq_s32(v118, v105), v105, 1uLL);
          v126 = vaddq_s32(v107, v109);
          v127 = vaddq_s32(v106, v108);
          v128 = vuzp1q_s16((int16x8_t)v127, (int16x8_t)v126);
          *(int16x4_t *)v115.i8 = vmovn_s32(v126);
          *(int16x4_t *)v117.i8 = vmovn_s32(v127);
          v129 = (int32x4_t)vshrq_n_u32(v111, 1uLL);
          v130 = (int32x4_t)vsraq_n_u32(v111, (uint32x4_t)v113, 1uLL);
          v131 = (int32x4_t)vshrq_n_u32(v110, 1uLL);
          v132 = (int32x4_t)vsraq_n_u32(v110, (uint32x4_t)v112, 1uLL);
          v133 = vuzp1q_s16((int16x8_t)v132, (int16x8_t)v130);
          v134 = (int8x8_t)vmovn_s32(v130);
          v135 = vsubq_s32(v107, v109);
          v136 = vsubq_s32(v106, v108);
          v137 = vsubq_s32(v129, v113);
          v138 = vsubq_s32(v131, v112);
          v139 = vuzp1q_s16((int16x8_t)v138, (int16x8_t)v137);
          v259 = (int8x8_t)vmovn_s32(v137);
          v140 = (int32x4_t)vshrq_n_u32(v121, 2uLL);
          v141 = (int32x4_t)vsraq_n_u32(v121, (uint32x4_t)v125, 2uLL);
          v142 = (int32x4_t)vshrq_n_u32(v120, 2uLL);
          v143 = (int32x4_t)vsraq_n_u32(v120, (uint32x4_t)v124, 2uLL);
          v144 = vuzp1q_s16((int16x8_t)v143, (int16x8_t)v141);
          *(int16x4_t *)v137.i8 = vmovn_s32(v143);
          v145 = (int32x4_t)vshrq_n_u32(v119, 2uLL);
          v146 = (int32x4_t)vsraq_n_u32(v119, (uint32x4_t)v123, 2uLL);
          v147 = (int32x4_t)vshrq_n_u32(v116, 2uLL);
          v148 = (int32x4_t)vsraq_n_u32(v116, (uint32x4_t)v122, 2uLL);
          v149 = vuzp1q_s16((int16x8_t)v148, (int16x8_t)v146);
          *(int16x4_t *)v112.i8 = vmovn_s32(v146);
          *(int16x4_t *)v118.i8 = vmovn_s32(v148);
          v150 = vsubq_s32(v123, v145);
          v151 = vsubq_s32(v122, v147);
          v152 = vuzp1q_s16((int16x8_t)v151, (int16x8_t)v150);
          *(int16x4_t *)v147.i8 = vmovn_s32(v150);
          *(int16x4_t *)v145.i8 = vmovn_s32(v151);
          v153 = vsubq_s32(v140, v125);
          v154 = vsubq_s32(v142, v124);
          v155 = vcgtq_s16(vabsq_s16(v128), *(int16x8_t *)(a1 + 768));
          v156 = vcgtq_s16(vabsq_s16(v144), *(int16x8_t *)(a1 + 784));
          v157 = vcgtq_s16(vabsq_s16(v133), *(int16x8_t *)(a1 + 800));
          v158 = vcgtq_s16(vabsq_s16(v149), *(int16x8_t *)(a1 + 816));
          v159 = vcgtq_s16(vabsq_s16(vuzp1q_s16((int16x8_t)v136, (int16x8_t)v135)), *(int16x8_t *)(a1 + 832));
          v160 = vcgtq_s16(vabsq_s16(v152), *(int16x8_t *)(a1 + 848));
          v161 = vcgtq_s16(vabsq_s16(v139), *(int16x8_t *)(a1 + 864));
          v162 = vcgtq_s16(vabsq_s16(vuzp1q_s16((int16x8_t)v154, (int16x8_t)v153)), *(int16x8_t *)(a1 + 880));
          *(int16x8_t *)(a1 + 512) = vqrshrn_high_n_s32(vqrshrn_n_s32(vmull_s16((int16x4_t)vand_s8(*(int8x8_t *)v117.i8, *(int8x8_t *)v155.i8), (int16x4_t)0x39006600390040), 6uLL), vmull_s16((int16x4_t)vand_s8(*(int8x8_t *)v115.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v155, (int8x16_t)v155, 8uLL)), (int16x4_t)0x39006600390040), 6uLL);
          *(int16x8_t *)(a1 + 528) = vqrshrn_high_n_s32(vqrshrn_n_s32(vmull_s16((int16x4_t)vand_s8(*(int8x8_t *)v137.i8, *(int8x8_t *)v156.i8), (int16x4_t)0x32005B00320039), 6uLL), vmull_s16((int16x4_t)vand_s8((int8x8_t)vmovn_s32(v141), (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v156, (int8x16_t)v156, 8uLL)), (int16x4_t)0x32005B00320039), 6uLL);
          *(int16x8_t *)(a1 + 544) = vqrshrn_high_n_s32(vqrshrn_n_s32(vmull_s16((int16x4_t)vand_s8((int8x8_t)vmovn_s32(v132), *(int8x8_t *)v157.i8), (int16x4_t)0x5B00A4005B0066), 6uLL), vmull_s16((int16x4_t)vand_s8(v134, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v157, (int8x16_t)v157, 8uLL)), (int16x4_t)0x5B00A4005B0066), 6uLL);
          *(int16x8_t *)(a1 + 560) = vqrshrn_high_n_s32(vqrshrn_n_s32(vmull_s16((int16x4_t)vand_s8(*(int8x8_t *)v118.i8, *(int8x8_t *)v158.i8), (int16x4_t)0x32005B00320039), 6uLL), vmull_s16((int16x4_t)vand_s8(*(int8x8_t *)v112.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v158, (int8x16_t)v158, 8uLL)), (int16x4_t)0x32005B00320039), 6uLL);
          *(int16x8_t *)(a1 + 576) = vqrshrn_high_n_s32(vqrshrn_n_s32(vmull_s16((int16x4_t)vand_s8((int8x8_t)vmovn_s32(v136), *(int8x8_t *)v159.i8), (int16x4_t)0x39006600390040), 6uLL), vmull_s16((int16x4_t)vand_s8((int8x8_t)vmovn_s32(v135), (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v159, (int8x16_t)v159, 8uLL)), (int16x4_t)0x39006600390040), 6uLL);
          *(int16x8_t *)(a1 + 592) = vqrshrn_high_n_s32(vqrshrn_n_s32(vmull_s16((int16x4_t)vand_s8(*(int8x8_t *)v145.i8, *(int8x8_t *)v160.i8), (int16x4_t)0x32005B00320039), 6uLL), vmull_s16((int16x4_t)vand_s8(*(int8x8_t *)v147.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v160, (int8x16_t)v160, 8uLL)), (int16x4_t)0x32005B00320039), 6uLL);
          *(int16x8_t *)(a1 + 608) = vqrshrn_high_n_s32(vqrshrn_n_s32(vmull_s16((int16x4_t)vand_s8((int8x8_t)vmovn_s32(v138), *(int8x8_t *)v161.i8), (int16x4_t)0x5B00A4005B0066), 6uLL), vmull_s16((int16x4_t)vand_s8(v259, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v161, (int8x16_t)v161, 8uLL)), (int16x4_t)0x5B00A4005B0066), 6uLL);
          *(int16x8_t *)(a1 + 624) = vqrshrn_high_n_s32(vqrshrn_n_s32(vmull_s16((int16x4_t)vand_s8((int8x8_t)vmovn_s32(v154), *(int8x8_t *)v162.i8), (int16x4_t)0x32005B00320039), 6uLL), vmull_s16((int16x4_t)vand_s8((int8x8_t)vmovn_s32(v153), (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v162, (int8x16_t)v162, 8uLL)), (int16x4_t)0x32005B00320039), 6uLL);
          v163 = vaddq_s16(vaddq_s16(vaddq_s16(v156, vaddq_s16(v155, v157)), vaddq_s16(v158, v159)), vaddq_s16(vaddq_s16(v160, v161), v162));
          do
          {
            v164 = *(_WORD *)(v47 + v55 - 14);
            v165 = *(_WORD *)(v47 + v55 - 6);
            v166 = v165 + v164;
            v167 = v164 - v165;
            v168 = *(__int16 *)(v47 + v55 - 10);
            v169 = *(__int16 *)(v47 + v55 - 2);
            v170 = (v168 >> 1) - v169;
            v171 = v168 + (v169 >> 1);
            v172 = *(__int16 *)(v47 + v55 - 4);
            v173 = *(__int16 *)(v47 + v55 - 8);
            v174 = *(__int16 *)(v47 + v55);
            v175 = v172 - (v173 + v174 + (v174 >> 1));
            v176 = *(__int16 *)(v47 + v55 - 12);
            v177 = v174 - (v173 + (v173 >> 1)) + v176;
            v178 = v172 + (v172 >> 1) + v174 - v176;
            v179 = v173 + v172 + v176 + (v176 >> 1);
            v180 = (__int16)v178;
            LOWORD(v173) = v171 + v166;
            LOWORD(v171) = v166 - v171;
            v181 = v170 + v167;
            v182 = v167 - v170;
            v183 = v175 + ((__int16)v179 >> 2);
            v184 = v179 - ((__int16)v175 >> 2);
            v185 = ((__int16)v177 >> 2) - v178;
            v186 = &v260.i16[(unint64_t)v55 / 2];
            *v186 = v184 + v173;
            v186[1] = v185 + v181;
            LOWORD(v177) = v177 + (v180 >> 2);
            v186[2] = v177 + v182;
            v186[3] = v183 + v171;
            v186[4] = v171 - v183;
            v186[5] = v182 - v177;
            v186[6] = v181 - v185;
            v186[7] = v173 - v184;
            v55 += 16;
          }
          while (v55 != 128);
          v187 = 0;
          v188 = vaddlvq_s16(v163);
          v189 = vaddq_s16(v264, v260);
          v190 = vsubq_s16(v265, vsraq_n_s16(vaddq_s16(v263, v267), v267, 1uLL));
          v191 = vsubq_s16(v260, v264);
          v192 = vaddq_s16(vsubq_s16(v267, vsraq_n_s16(v263, v263, 1uLL)), v261);
          v193 = vsubq_s16(vshrq_n_s16(v262, 1uLL), v266);
          v194 = vsubq_s16(vaddq_s16(vsraq_n_s16(v265, v265, 1uLL), v267), v261);
          v195 = vsraq_n_s16(v262, v266, 1uLL);
          v196 = vsraq_n_s16(vaddq_s16(vaddq_s16(v263, v265), v261), v261, 1uLL);
          v197 = vaddq_s16(v193, v191);
          v198 = vsubq_s16(v191, v193);
          v199 = vaddq_s16(v195, v189);
          v200 = vsubq_s16(v189, v195);
          v201 = vshrq_n_s16(v190, 2uLL);
          v202 = vsraq_n_s16(v190, v196, 2uLL);
          v203 = vsubq_s16(v196, v201);
          v204 = vshrq_n_s16(v192, 2uLL);
          v205 = vsraq_n_s16(v192, v194, 2uLL);
          v206 = vsubq_s16(v204, v194);
          v207 = vaddq_s16(v199, v203);
          v208 = vrshrn_high_n_s32(vrshrn_n_s32(vmovl_s16(*(int16x4_t *)v207.i8), 6uLL), vmovl_high_s16(v207), 6uLL);
          v209 = vaddq_s16(v197, v206);
          v210 = vrshrn_high_n_s32(vrshrn_n_s32(vmovl_s16(*(int16x4_t *)v209.i8), 6uLL), vmovl_high_s16(v209), 6uLL);
          *(int16x8_t *)(a1 + 640) = v208;
          *(int16x8_t *)(a1 + 656) = v210;
          v211 = vaddq_s16(v198, v205);
          v212 = vrshrn_high_n_s32(vrshrn_n_s32(vmovl_s16(*(int16x4_t *)v211.i8), 6uLL), vmovl_high_s16(v211), 6uLL);
          v213 = vaddq_s16(v200, v202);
          v214 = vrshrn_high_n_s32(vrshrn_n_s32(vmovl_s16(*(int16x4_t *)v213.i8), 6uLL), vmovl_high_s16(v213), 6uLL);
          *(int16x8_t *)(a1 + 672) = v212;
          *(int16x8_t *)(a1 + 688) = v214;
          v215 = vsubq_s16(v200, v202);
          v216 = vrshrn_high_n_s32(vrshrn_n_s32(vmovl_s16(*(int16x4_t *)v215.i8), 6uLL), vmovl_high_s16(v215), 6uLL);
          v217 = vsubq_s16(v198, v205);
          v218 = vrshrn_high_n_s32(vrshrn_n_s32(vmovl_s16(*(int16x4_t *)v217.i8), 6uLL), vmovl_high_s16(v217), 6uLL);
          *(int16x8_t *)(a1 + 704) = v216;
          *(int16x8_t *)(a1 + 720) = v218;
          v219 = vsubq_s16(v197, v206);
          v220 = vrshrn_high_n_s32(vrshrn_n_s32(vmovl_s16(*(int16x4_t *)v219.i8), 6uLL), vmovl_high_s16(v219), 6uLL);
          v221 = vsubq_s16(v199, v203);
          v222 = vrshrn_high_n_s32(vrshrn_n_s32(vmovl_s16(*(int16x4_t *)v221.i8), 6uLL), vmovl_high_s16(v221), 6uLL);
          *(int16x8_t *)(a1 + 736) = v220;
          *(int16x8_t *)(a1 + 752) = v222;
          v223 = *(unsigned __int16 *)(a1 - 2 * v188);
          v224 = vdupq_n_s16(v223);
          *(int16x8_t *)(a1 + 640) = vmulq_s16(v224, v208);
          *(int16x8_t *)(a1 + 656) = vmulq_s16(v224, v210);
          *(int16x8_t *)(a1 + 672) = vmulq_s16(v224, v212);
          *(int16x8_t *)(a1 + 688) = vmulq_s16(v224, v214);
          *(int16x8_t *)(a1 + 704) = vmulq_s16(v224, v216);
          *(int16x8_t *)(a1 + 720) = vmulq_s16(v224, v218);
          *(int16x8_t *)(a1 + 736) = vmulq_s16(v224, v220);
          *(int16x8_t *)(a1 + 752) = vmulq_s16(v224, v222);
          do
          {
            v225 = v54 + *(__int16 *)(a1 + v187 + 256);
            *((_WORD *)v43 + v225) += *(_WORD *)(a1 + v187 + 640);
            *((_BYTE *)v42 + v225) += v223;
            v187 += 2;
          }
          while (v187 != 128);
          v52 += 5;
          v49 = (int8x16_t)xmmword_1B6917370;
          v48 = (int8x16_t)xmmword_1B6917360;
          v51 = (int8x16_t)xmmword_1B6917390;
          v50 = (int8x16_t)xmmword_1B6917380;
        }
        while (v46 > v52);
      }
      v257 += 5;
    }
    while (v256 > v257);
  }
  if ((v253 & 1) == 0)
  {
    v226 = 0;
    v227 = *(_QWORD *)(a1 + 904);
    v228 = *(_QWORD *)(a1 + 896) + 16;
    v229.i64[0] = 0x1111111111111111;
    v229.i64[1] = 0x1111111111111111;
    v230 = xmmword_1B6917400;
    v231 = xmmword_1B6917410;
    v232 = xmmword_1B6917420;
    v233 = xmmword_1B6917430;
    v234.i64[0] = 0xECECECECECECECECLL;
    v234.i64[1] = 0xECECECECECECECECLL;
    v235.i64[0] = 0xF1F1F1F1F1F1F1F1;
    v235.i64[1] = 0xF1F1F1F1F1F1F1F1;
    v236.i64[0] = -1;
    v236.i64[1] = -1;
    v237.i64[0] = 0xFEFEFEFEFEFEFEFELL;
    v237.i64[1] = 0xFEFEFEFEFEFEFEFELL;
    do
    {
      if (a4)
      {
        v238 = 0;
        v239 = (int16x8_t *)v228;
        do
        {
          v240 = *(int8x16_t *)(v227 + v238);
          v241 = vbslq_s8((int8x16_t)vcgtq_u8(v229, (uint8x16_t)v240), v235, v234);
          v242 = vmovl_s8(*(int8x8_t *)v241.i8);
          v243 = vmovl_high_s8(v241);
          v244 = vaddq_s8(v240, v240);
          v245 = vaddq_s8(v244, v237);
          v246 = vaddq_s8(v244, v236);
          v247 = vzip1q_s8(v245, v246);
          v248 = vzip2q_s8(v245, v246);
          v249 = (uint16x8_t)vqtbx4q_s8(*(int8x16x4_t *)&v233, v247);
          v250 = (uint16x8_t)vqtbx4q_s8(*(int8x16x4_t *)&v233, v248);
          v251 = (uint16x8_t)vmaxq_s16(v239[-1], (int16x8_t)0);
          v252 = (uint16x8_t)vmaxq_s16(*v239, (int16x8_t)0);
          *(int8x16_t *)(a6 + v238) = vbslq_s8(vceqzq_s8(v240), *(int8x16_t *)(v31 + v238), (int8x16_t)vqmovn_high_u16(vqmovn_u16(vqmovn_high_u32(vqmovn_u32(vshlq_u32(vmull_u16(*(uint16x4_t *)v251.i8, *(uint16x4_t *)v249.i8), (uint32x4_t)vmovl_s16(*(int16x4_t *)v242.i8))), vshlq_u32(vmull_high_u16(v251, v249), (uint32x4_t)vmovl_high_s16(v242)))), vqmovn_high_u32(vqmovn_u32(vshlq_u32(vmull_u16(*(uint16x4_t *)v252.i8, *(uint16x4_t *)v250.i8), (uint32x4_t)vmovl_s16(*(int16x4_t *)v243.i8))), vshlq_u32(vmull_high_u16(v252, v250),
                                                         (uint32x4_t)vmovl_high_s16(v243)))));
          v238 += 16;
          v239 += 2;
        }
        while (v238 < a4);
      }
      v227 += a4;
      a6 += a7;
      v31 += a4;
      ++v226;
      v228 += 2 * a4;
    }
    while (v226 != v255);
  }
}

void sub_1B677C420(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B677C568(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B677C70C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  void *v20;

  _Unwind_Resume(a1);
}

void sub_1B677C89C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  void *v9;

  a9.super_class = (Class)VCPReactionAVCaptureDeviceObserver;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1B677CAE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B677CC7C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B677CDB8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B677CF58(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B677CFC4(uint64_t a1, void *a2)
{
  id *v3;
  id WeakRetained;
  id v5;
  id v6;

  objc_msgSend(a2, "object");
  v6 = (id)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v6, "hasMediaType:", *MEMORY[0x1E0C8A808]))
  {
    v3 = (id *)(a1 + 32);
    WeakRetained = objc_loadWeakRetained(v3);

    if (WeakRetained)
    {
      v5 = objc_loadWeakRetained(v3);
      objc_msgSend(v5, "addDevice:", v6);

    }
  }

}

void sub_1B677D040(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B677D060(uint64_t a1, void *a2)
{
  id *v3;
  id WeakRetained;
  id v5;
  id v6;

  objc_msgSend(a2, "object");
  v6 = (id)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v6, "hasMediaType:", *MEMORY[0x1E0C8A808]))
  {
    v3 = (id *)(a1 + 32);
    WeakRetained = objc_loadWeakRetained(v3);

    if (WeakRetained)
    {
      v5 = objc_loadWeakRetained(v3);
      objc_msgSend(v5, "removeDevice:", v6);

    }
  }

}

void sub_1B677D0DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t sub_1B677D0FC()
{
  uint64_t result;

  qword_1EDBB4C48 = 0;
  unk_1EDBB4C50 = "VCPRateControlSession_NonLowLatency";
  qword_1EDBB4C58 = 0;
  unk_1EDBB4C60 = 0;
  qword_1EDBB4C68 = (uint64_t)sub_1B677D148;
  unk_1EDBB4C70 = 0u;
  unk_1EDBB4C80 = 0u;
  result = _CFRuntimeRegisterClass();
  qword_1EDBB4C40 = result;
  return result;
}

uint64_t sub_1B677D148(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *(_QWORD *)(result + 16);
    if (v2)
    {
      *(_BYTE *)(v2 + 232) = 1;
      sub_1B6778D98(v2);
      std::condition_variable::~condition_variable((std::condition_variable *)(v2 + 2480));
      std::condition_variable::~condition_variable((std::condition_variable *)(v2 + 2432));
      std::mutex::~mutex((std::mutex *)(v2 + 2368));
      std::mutex::~mutex((std::mutex *)(v2 + 2304));
      result = MEMORY[0x1BCC9814C](v2, 0x10F0C40EEABCC0CLL);
      *(_QWORD *)(v1 + 16) = 0;
    }
  }
  return result;
}

uint64_t **sub_1B677D1C8(uint64_t a1, const void *a2)
{
  uint64_t **result;
  uint64_t **v4;
  CFTypeRef v5;

  v5 = a2;
  result = sub_1B67782D8(*(_QWORD **)(a1 + 2544), &v5);
  if (result)
  {
    v4 = sub_1B67782D8(*(_QWORD **)(a1 + 2544), &v5);
    if (!v4)
      sub_1B67783D0("unordered_map::at: key not found");
    return (uint64_t **)(*((_BYTE *)v4 + 48) != 0);
  }
  return result;
}

void sub_1B677D228(char *__format, ...)
{
  uint8_t buf[4];
  char *v2;
  char __str[1024];
  uint64_t v4;
  va_list va;

  va_start(va, __format);
  v4 = *MEMORY[0x1E0C80C00];
  vsnprintf(__str, 0x400uLL, __format, va);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    v2 = __str;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "(Encoder Configuration) %s", buf, 0xCu);
  }
}

void sub_1B677D418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1B677DA34(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1B677DC40(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B677DE3C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B677E024(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B677E160(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B677E26C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  sub_1B6773B7C((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1B677E374(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  sub_1B6773B7C((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1B677E47C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  sub_1B6773B7C((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1B677EA20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,const void *a29)
{
  void *v29;
  void *v30;
  void *v31;

  sub_1B67704D8(&a29);
  _Unwind_Resume(a1);
}

void sub_1B677EE20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13)
{
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1B677F4A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  uint64_t v18;
  uint64_t i;
  uint64_t j;

  for (i = 8; i != -8; i -= 8)
  for (j = 8; j != -8; j -= 8)

  _Unwind_Resume(a1);
}

void sub_1B677F8F0(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;
  uint64_t i;
  uint64_t j;

  for (i = 8; i != -8; i -= 8)
  for (j = 8; j != -8; j -= 8)

  _Unwind_Resume(a1);
}

void sub_1B678009C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,const void *a42,const void *a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,const void *a57)
{
  const void **v57;
  void *v58;
  const void **v59;
  uint64_t i;

  sub_1B6773B7C(v59);
  sub_1B6770568(v57);

  sub_1B6770568(&a42);
  sub_1B6773B7C(&a43);

  for (i = 8; i != -8; i -= 8)
  sub_1B67704D8(&a57);
  _Unwind_Resume(a1);
}

id sub_1B67802CC(uint64_t a1, _QWORD *a2)
{
  id v4;
  uint64_t v5;
  id v6;
  id v7;
  void *v8;
  id v9;
  void *v10;
  id v11;
  id v12;
  id v13;
  _QWORD v15[4];
  id v16;
  id v17;
  id location;

  v4 = *(id *)a1;
  if (!*(_QWORD *)a1)
  {
    v5 = objc_opt_new();
    v6 = *(id *)a1;
    *(_QWORD *)a1 = v5;

    v4 = *(id *)a1;
  }
  v7 = v4;
  objc_sync_enter(v7);
  if ((unint64_t)objc_msgSend(*(id *)a1, "count") < 2)
  {
    v8 = 0;
  }
  else
  {
    objc_msgSend(*(id *)a1, "lastObject");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(*(id *)a1, "removeLastObject");
  }
  objc_sync_exit(v7);

  if (!v8)
    v8 = (void *)objc_msgSend(*(id *)(a1 + 8), "newBufferWithLength:options:", *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  objc_initWeak(&location, *(id *)a1);
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3221225472;
  v15[2] = sub_1B6780E20;
  v15[3] = &unk_1E6A16A88;
  objc_copyWeak(&v17, &location);
  v9 = v8;
  v16 = v9;
  v10 = (void *)MEMORY[0x1BCC9874C](v15);
  v11 = objc_alloc(MEMORY[0x1E0C99D50]);
  v12 = objc_retainAutorelease(v9);
  *a2 = objc_msgSend(v11, "initWithBytesNoCopy:length:deallocator:", objc_msgSend(v12, "contents"), objc_msgSend(v12, "length"), v10);
  v13 = v12;

  objc_destroyWeak(&v17);
  objc_destroyWeak(&location);
  return v13;
}

void sub_1B678046C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  void *v16;
  void *v17;

  objc_sync_exit(v17);

  _Unwind_Resume(a1);
}

void sub_1B67804AC(uint64_t a1)
{
  std::mutex *v2;
  int v3;
  unint64_t *v4;
  unint64_t v5;

  v2 = (std::mutex *)(a1 + 24);
  std::mutex::lock((std::mutex *)(a1 + 24));
  v3 = *(_DWORD *)(a1 + 136);
  if ((v3 & 2) != 0)
    sub_1B6780564(1u);
  v4 = (unint64_t *)(a1 + 8);
  do
    v5 = __ldxr(v4);
  while (__stxr(v5 + 1, v4));
  *(_DWORD *)(a1 + 136) = v3 | 2;
  std::mutex::unlock(v2);
}

void sub_1B6780508(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B678051C(uint64_t a1)
{
  sub_1B67704D8((const void **)(a1 + 144));

  sub_1B6773B7C((const void **)(a1 + 128));
  sub_1B6770568((const void **)(a1 + 120));

  return a1;
}

void sub_1B6780564(unsigned int a1)
{
  void *exception;
  const std::error_category *v3;

  exception = __cxa_allocate_exception(0x20uLL);
  v3 = std::future_category();
  MEMORY[0x1BCC97F9C](exception, a1, v3);
  __cxa_throw(exception, (struct type_info *)&unk_1E6A14AE8, (void (*)(void *))MEMORY[0x1E0DE4540]);
}

void sub_1B67805AC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1B67805C0(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E6A15E28;
  sub_1B67704D8((const void **)(a1 + 296));

  sub_1B6773B7C((const void **)(a1 + 280));
  sub_1B6770568((const void **)(a1 + 272));

  *(_QWORD *)a1 = MEMORY[0x1E0DE4FC8] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_1B678063C(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E6A15E28;
  sub_1B67704D8((const void **)(a1 + 296));

  sub_1B6773B7C((const void **)(a1 + 280));
  sub_1B6770568((const void **)(a1 + 272));

  *(_QWORD *)a1 = MEMORY[0x1E0DE4FC8] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
  JUMPOUT(0x1BCC9814CLL);
}

uint64_t sub_1B67806CC(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 136) & 1) != 0)
    sub_1B67704D8((const void **)(a1 + 144));
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 8))(a1);
}

const void **sub_1B6780704(uint64_t a1)
{
  int v2;
  int v3;
  int v4;
  unsigned int v5;
  const __CFDictionary *MutableCopy;
  __CVBuffer *v7;
  uint64_t v8;
  CFDataRef Data;
  CFTypeID v10;
  CFStringRef v11;
  const char *CStringPtr;
  const __CFString *v13;
  unint64_t v14;
  signed int PixelFormatType;
  int Length;
  int v17;
  char v18;
  unsigned __int16 v19;
  uint64_t v20;
  size_t v21;
  uint64_t v22;
  unsigned int HeightOfPlane;
  unint64_t v24;
  char v25;
  unsigned int v26;
  _DWORD *v27;
  int v28;
  int v29;
  _DWORD *v30;
  char *v31;
  const UInt8 *v32;
  size_t v33;
  const UInt8 *v34;
  size_t v35;
  int v36;
  const void *v37;
  UInt8 *BytePtr;
  const void *v40;
  __int128 v41;
  uint64_t v42;
  __int128 v43;
  uint64_t v44;
  CFDataRef theData;
  CFTypeRef cf;
  CFPropertyListRef propertyList;
  CFStringRef v48;
  _BYTE buf[64];
  _OWORD v50[3];
  CFErrorRef error[4];

  error[1] = *(CFErrorRef *)MEMORY[0x1E0C80C00];
  objc_msgSend(*(id *)(a1 + 152), "waitUntilCompleted");
  v2 = *(_DWORD *)(a1 + 160);
  v3 = *(_DWORD *)(a1 + 164);
  v4 = *(_DWORD *)(a1 + 168);
  v5 = *(_DWORD *)(a1 + 208);
  v43 = *(_OWORD *)(a1 + 224);
  v44 = *(_QWORD *)(a1 + 240);
  v41 = *(_OWORD *)(a1 + 248);
  MutableCopy = *(const __CFDictionary **)(a1 + 272);
  v42 = *(_QWORD *)(a1 + 264);
  v7 = *(__CVBuffer **)(a1 + 280);
  v8 = *(_QWORD *)(a1 + 288);
  BytePtr = (UInt8 *)CFDataGetBytePtr(*(CFDataRef *)(a1 + 296));
  if (!MutableCopy)
  {
    cf = 0;
    propertyList = 0;
    goto LABEL_14;
  }
  if (CFDictionaryContainsKey(MutableCopy, CFSTR("DirtyRegionArray")))
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, MutableCopy);
    CFDictionaryRemoveValue(MutableCopy, CFSTR("DirtyRegionArray"));
    cf = 0;
    propertyList = MutableCopy;
    if (!MutableCopy)
      goto LABEL_14;
  }
  else
  {
    CFRetain(MutableCopy);
    cf = 0;
    propertyList = MutableCopy;
  }
  if (!CFDictionaryGetCount(MutableCopy))
  {
LABEL_14:
    v14 = 120;
    goto LABEL_15;
  }
  error[0] = 0;
  Data = CFPropertyListCreateData(0, propertyList, kCFPropertyListBinaryFormat_v1_0, 0, error);
  if (!Data)
  {
    v10 = CFGetTypeID(propertyList);
    v11 = CFCopyTypeIDDescription(v10);
    v48 = v11;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      CStringPtr = CFStringGetCStringPtr(v11, 0x8000100u);
      v13 = CFErrorCopyFailureReason(error[0]);
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = CStringPtr;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = CFStringGetCStringPtr(v13, 0x8000100u);
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Failed to serialize %s (%s)", buf, 0x16u);
    }
    sub_1B6770508((const void **)&v48);
  }
  sub_1B6770538((const void **)error);
  theData = 0;
  cf = Data;
  sub_1B67704D8((const void **)&theData);
  if (!cf)
  {
    v36 = -50;
    goto LABEL_53;
  }
  v14 = CFDataGetLength((CFDataRef)cf) + 120;
LABEL_15:
  v48 = 0;
  theData = 0;
  *(_DWORD *)buf = v4;
  *(_OWORD *)&buf[4] = v43;
  *(_QWORD *)&buf[20] = v44;
  *(_OWORD *)&buf[28] = v41;
  *(_QWORD *)&buf[44] = v42;
  PixelFormatType = CVPixelBufferGetPixelFormatType(v7);
  *(_DWORD *)&buf[52] = PixelFormatType;
  Length = (int)cf;
  if (cf)
    Length = CFDataGetLength((CFDataRef)cf);
  *(_DWORD *)&buf[56] = Length;
  v17 = (int)theData;
  if (theData)
    v17 = CFDataGetLength(theData);
  *(_DWORD *)&buf[60] = v17;
  if (PixelFormatType > 875704949)
  {
    if (PixelFormatType == 875836534 || PixelFormatType == 875836518)
      goto LABEL_27;
    v19 = 12918;
  }
  else
  {
    v18 = 1;
    if (PixelFormatType == 875704422 || PixelFormatType == 875704438)
      goto LABEL_28;
    v19 = 12902;
  }
  if (PixelFormatType == (v19 | 0x34320000))
  {
LABEL_27:
    v18 = 0;
LABEL_28:
    v20 = 0;
    v21 = 0;
    v22 = v8 + 224;
    while (1)
    {
      if (CVPixelBufferGetPlaneCount(v7) <= v21)
      {
        v29 = 0;
        v30 = (_DWORD *)((char *)v50 + v20);
        *v30 = 0;
        v30[8] = 0;
      }
      else
      {
        HeightOfPlane = CVPixelBufferGetHeightOfPlane(v7, v21);
        v24 = *(unsigned int *)(v22 + v20);
        if (v14 > v24)
        {
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
            LODWORD(error[0]) = 67109120;
            HIDWORD(error[0]) = v21;
            _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Header is larger than offset to plane %d", (uint8_t *)error, 8u);
          }
          v36 = -50;
          goto LABEL_52;
        }
        if (v20)
          v25 = v18;
        else
          v25 = 0;
        v26 = v5 >> v25;
        if (v26 >= HeightOfPlane)
          v26 = HeightOfPlane;
        v27 = (_DWORD *)((char *)v50 + v20);
        *v27 = v24;
        v28 = *(_DWORD *)(v22 + v20 + 16);
        v27[8] = v28;
        v29 = v28 * v26;
      }
      *(_DWORD *)((char *)&v50[1] + v20) = v29;
      ++v21;
      v20 += 4;
      if (v21 == 4)
      {
        *(_WORD *)BytePtr = 8;
        *((_WORD *)BytePtr + 1) = v2;
        *((_DWORD *)BytePtr + 1) = v3;
        *(_OWORD *)(BytePtr + 56) = *(_OWORD *)&buf[48];
        *(_OWORD *)(BytePtr + 72) = v50[0];
        *(_OWORD *)(BytePtr + 88) = v50[1];
        *(_OWORD *)(BytePtr + 104) = v50[2];
        *(_OWORD *)(BytePtr + 8) = *(_OWORD *)buf;
        *(_OWORD *)(BytePtr + 24) = *(_OWORD *)&buf[16];
        *(_OWORD *)(BytePtr + 40) = *(_OWORD *)&buf[32];
        v31 = (char *)(BytePtr + 120);
        if (cf)
        {
          v32 = CFDataGetBytePtr((CFDataRef)cf);
          v33 = CFDataGetLength((CFDataRef)cf);
          memcpy(v31, v32, v33);
          v31 += v33;
        }
        if (theData)
        {
          v34 = CFDataGetBytePtr(theData);
          v35 = CFDataGetLength(theData);
          memcpy(v31, v34, v35);
        }
        v36 = 0;
        goto LABEL_52;
      }
    }
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    LODWORD(error[0]) = 67109120;
    HIDWORD(error[0]) = PixelFormatType;
    _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "pixel format (%d) is not supported\n", (uint8_t *)error, 8u);
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    LOWORD(error[0]) = 0;
    _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Failed to get chroma subsampling shift\n", (uint8_t *)error, 2u);
  }
  v36 = -666;
LABEL_52:
  sub_1B67704D8((const void **)&theData);
  sub_1B6770568((const void **)&v48);
LABEL_53:
  sub_1B67704D8(&cf);
  sub_1B6770568(&propertyList);
  if (v36)
  {
    v40 = 0;
  }
  else
  {
    v37 = *(const void **)(a1 + 296);
    v40 = v37;
    if (v37)
      CFRetain(v37);
  }
  sub_1B6780D7C(a1, &v40);
  return sub_1B67704D8(&v40);
}

void sub_1B6780C8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::exception_ptr a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,int a22,const void *a23,const void *a24,const void *a25)
{
  std::__assoc_sub_state *v25;
  uint64_t v26;
  std::exception_ptr v28;

  if (a2)
  {
    sub_1B6770508(&a25);
    sub_1B6770538((const void **)(v26 - 112));
    sub_1B67704D8(&a23);
    sub_1B6770568(&a24);
    __cxa_begin_catch(exception_object);
    std::current_exception();
    v28.__ptr_ = &a11;
    std::__assoc_sub_state::set_exception(v25, v28);
    std::exception_ptr::~exception_ptr(&a11);
    __cxa_end_catch();
    JUMPOUT(0x1B6780BA0);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B6780D5C()
{
  JUMPOUT(0x1B6780CA8);
}

void sub_1B6780D64(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::exception_ptr a11)
{
  std::exception_ptr::~exception_ptr(&a11);
  __cxa_end_catch();
  JUMPOUT(0x1B6780CA8);
}

void sub_1B6780D7C(uint64_t a1, _QWORD *a2)
{
  std::mutex *v4;
  uint64_t v5;
  std::exception_ptr v6;

  v4 = (std::mutex *)(a1 + 24);
  std::mutex::lock((std::mutex *)(a1 + 24));
  if ((*(_BYTE *)(a1 + 136) & 1) != 0
    || (v6.__ptr_ = 0, v5 = *(_QWORD *)(a1 + 16), std::exception_ptr::~exception_ptr(&v6), v5))
  {
    sub_1B6780564(2u);
  }
  *(_QWORD *)(a1 + 144) = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 136) |= 5u;
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 88));
  std::mutex::unlock(v4);
}

void sub_1B6780E0C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B6780E20(uint64_t a1)
{
  id WeakRetained;
  id v3;
  id v4;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    v4 = WeakRetained;
    v3 = WeakRetained;
    objc_sync_enter(v3);
    objc_msgSend(v3, "addObject:", *(_QWORD *)(a1 + 32));
    objc_sync_exit(v3);

    WeakRetained = v4;
  }

}

void sub_1B6780E7C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

std::future<void> *sub_1B6780E98(std::future<void> *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  std::future<void> *result;
  unint64_t v7;

  v3 = *a2;
  *a2 = 0;
  v4 = operator new();
  *(_QWORD *)(v4 + 8) = 0;
  v5 = (unint64_t *)(v4 + 8);
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)(v4 + 24) = 850045863;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_QWORD *)(v4 + 80) = 0;
  *(_QWORD *)(v4 + 88) = 1018212795;
  *(_OWORD *)(v4 + 96) = 0u;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_QWORD *)(v4 + 128) = 0;
  *(_QWORD *)v4 = &off_1E6A15EF8;
  *(_QWORD *)(v4 + 144) = v3;
  *(_DWORD *)(v4 + 136) = 8;
  result = std::future<void>::future(a1, (std::__assoc_sub_state *)v4);
  do
    v7 = __ldaxr(v5);
  while (__stlxr(v7 - 1, v5));
  if (!v7)
    return (std::future<void> *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
  return result;
}

void sub_1B6780F68(_Unwind_Exception *a1)
{
  uint64_t v1;
  unint64_t *v2;
  unint64_t v4;

  do
    v4 = __ldaxr(v2);
  while (__stlxr(v4 - 1, v2));
  if (!v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 16))(v1);

  _Unwind_Resume(a1);
}

void sub_1B6780FA8(uint64_t a1)
{

  *(_QWORD *)a1 = MEMORY[0x1E0DE4FC8] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_1B6780FF8(uint64_t a1)
{

  *(_QWORD *)a1 = MEMORY[0x1E0DE4FC8] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
  JUMPOUT(0x1BCC9814CLL);
}

void sub_1B678105C(std::__assoc_sub_state *a1)
{
  -[std::__assoc_sub_state_vtbl waitUntilScheduled](a1[1].__vftable, "waitUntilScheduled");
  std::__assoc_sub_state::set_value(a1);
}

void sub_1B6781090(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::__assoc_sub_state *v10;
  std::exception_ptr v11;

  __cxa_begin_catch(a1);
  std::current_exception();
  v11.__ptr_ = &a10;
  std::__assoc_sub_state::set_exception(v10, v11);
  std::exception_ptr::~exception_ptr(&a10);
  __cxa_end_catch();
  JUMPOUT(0x1B6781080);
}

void sub_1B67810B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1B67810D4(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E6A15F28;
  sub_1B67704D8((const void **)(a1 + 160));

  *(_QWORD *)a1 = MEMORY[0x1E0DE4FC8] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_1B6781134(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E6A15F28;
  sub_1B67704D8((const void **)(a1 + 160));

  *(_QWORD *)a1 = MEMORY[0x1E0DE4FC8] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
  JUMPOUT(0x1BCC9814CLL);
}

uint64_t sub_1B67811A8(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 8))(a1);
}

void sub_1B67811B4(uint64_t a1)
{
  const UInt8 *BytePtr;
  unint64_t v3;
  uint64x2_t v4;
  uint64x2_t v5;
  uint64x2_t v6;
  uint64x2_t v7;
  uint32x4_t v8;
  uint32x4_t v9;
  uint32x4_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  int64x2_t v14;
  int64x2_t v15;
  int64x2_t v16;
  int64x2_t v17;
  int64x2_t v18;
  std::exception_ptr v19;

  objc_msgSend(*(id *)(a1 + 152), "waitUntilCompleted");
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 160));
  v3 = *(_QWORD *)(a1 + 176) * *(_QWORD *)(a1 + 168);
  v4 = 0uLL;
  if (v3 < 0x11)
  {
    if (!v3)
    {
      v17 = 0u;
      v18 = 0u;
      v11 = 0;
      v15 = 0u;
      v16 = 0u;
      goto LABEL_10;
    }
    v5 = 0uLL;
    v6 = 0uLL;
    v7 = 0uLL;
  }
  else
  {
    v5 = 0uLL;
    v6 = 0uLL;
    v7 = 0uLL;
    do
    {
      v8 = *((uint32x4_t *)BytePtr + 1);
      v10 = *((uint32x4_t *)BytePtr + 2);
      v9 = *((uint32x4_t *)BytePtr + 3);
      v5 = vaddw_high_u32(vaddw_high_u32(v5, *(uint32x4_t *)BytePtr), v10);
      v6 = vaddw_u32(vaddw_u32(v6, *(uint32x2_t *)v8.i8), *(uint32x2_t *)v9.i8);
      v4 = vaddw_u32(vaddw_u32(v4, *(uint32x2_t *)BytePtr), *(uint32x2_t *)v10.i8);
      v7 = vaddw_high_u32(vaddw_high_u32(v7, v8), v9);
      BytePtr += 64;
      v3 -= 16;
    }
    while (v3 > 0x10);
  }
  v11 = 0;
  do
  {
    v12 = *(_DWORD *)BytePtr;
    BytePtr += 4;
    v11 += v12;
    --v3;
  }
  while (v3);
  v15 = (int64x2_t)v7;
  v16 = (int64x2_t)v6;
  v17 = (int64x2_t)v5;
  v18 = (int64x2_t)v4;
LABEL_10:
  std::mutex::lock((std::mutex *)(a1 + 24));
  if ((*(_BYTE *)(a1 + 136) & 1) != 0
    || (v19.__ptr_ = 0, v13 = *(_QWORD *)(a1 + 16), std::exception_ptr::~exception_ptr(&v19), v13))
  {
    sub_1B6780564(2u);
  }
  v14 = vaddq_s64(vaddq_s64(v18, v16), vaddq_s64(v17, v15));
  *(_QWORD *)(a1 + 144) = v14.i64[1] + v11 + v14.i64[0];
  *(_DWORD *)(a1 + 136) |= 5u;
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 88));
  std::mutex::unlock((std::mutex *)(a1 + 24));
}

void sub_1B678130C(void *a1)
{
  std::__assoc_sub_state *v1;
  std::mutex *v2;
  uint64_t v3;
  std::exception_ptr v5;

  std::mutex::unlock(v2);
  __cxa_begin_catch(a1);
  std::current_exception();
  v5.__ptr_ = (void *)(v3 - 48);
  std::__assoc_sub_state::set_exception(v1, v5);
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(v3 - 48));
  __cxa_end_catch();
  JUMPOUT(0x1B67812D8);
}

void sub_1B678134C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::exception_ptr::~exception_ptr((std::exception_ptr *)(v1 - 48));
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1B6781368(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  void *v5;

  v3 = a2;
  v4 = v3;
  if (*(id *)(a1 + 8) != v3)
  {
    v5 = *(void **)a1;
    *(_QWORD *)a1 = 0;

    v3 = *(id *)(a1 + 8);
  }
  *(_QWORD *)(a1 + 8) = v4;

}

void sub_1B67813AC(uint64_t *a1, uint64_t a2)
{
  void *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  const char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  *a1 = a2;
  v3 = dlopen("/System/Library/PrivateFrameworks/Portrait.framework/Portrait", 1);
  if (!v3)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      return;
    v6 = *a1;
    v10 = 134217984;
    v11 = v6;
    v7 = MEMORY[0x1E0C81028];
    v8 = "VCPReactionObserverSession (0x%llx): portrait framework does not exist\n";
    goto LABEL_10;
  }
  v4 = (uint64_t *)dlsym(v3, "kPTEffectAttachmentKey_ReactionEffectComplexity");
  if (v4)
  {
    v5 = *v4;
    a1[4] = *v4;
    if (v5)
      return;
  }
  else if (a1[4])
  {
    return;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v9 = *a1;
    v10 = 134217984;
    v11 = v9;
    v7 = MEMORY[0x1E0C81028];
    v8 = "VCPReactionObserverSession (0x%llx): ReactionEffectComplexity does not exist";
LABEL_10:
    _os_log_impl(&dword_1B676B000, v7, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v10, 0xCu);
  }
}

uint64_t sub_1B67814D0(uint64_t a1, CVBufferRef buffer, unsigned int a3)
{
  const __CFDictionary *v5;
  const void *v6;
  const __CFNumber *Value;
  _BOOL4 v8;
  unint64_t v9;
  uint64_t result;
  BOOL v11;
  unint64_t v12;
  uint64_t v13;
  int valuePtr;
  CFDictionaryRef theDict;
  CFDictionaryRef **p_p_theDict;
  CFDictionaryRef *p_theDict;

  if (buffer)
  {
    v5 = CVBufferCopyAttachments(buffer, kCVAttachmentMode_ShouldPropagate);
    theDict = v5;
    if (v5
      && (v6 = *(const void **)(a1 + 32)) != 0
      && CFDictionaryContainsKey(v5, v6)
      && (Value = (const __CFNumber *)CFDictionaryGetValue(theDict, *(const void **)(a1 + 32))) != 0)
    {
      *(_BYTE *)(a1 + 24) = 0;
      valuePtr = 0;
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
      v8 = valuePtr > 0;
      if (valuePtr >= 1)
      {
        v13 = a1;
        v9 = atomic_load((unint64_t *)(a1 + 8));
        if (v9 != -1)
        {
          p_theDict = (CFDictionaryRef *)&v13;
          p_p_theDict = &p_theDict;
          std::__call_once((std::once_flag::_State_type *)(a1 + 8), &p_p_theDict, (void (__cdecl *)(void *))sub_1B6781618);
        }
      }
    }
    else
    {
      v8 = 0;
    }
    sub_1B6770568((const void **)&theDict);
  }
  else
  {
    v8 = 0;
  }
  if (*(_BYTE *)(a1 + 24))
    result = a3;
  else
    result = v8;
  if (*(_BYTE *)(a1 + 24))
    v11 = a3 == 0;
  else
    v11 = 1;
  if (!v11)
  {
    theDict = (CFDictionaryRef)a1;
    v12 = atomic_load((unint64_t *)(a1 + 16));
    if (v12 != -1)
    {
      p_theDict = &theDict;
      p_p_theDict = &p_theDict;
      std::__call_once((std::once_flag::_State_type *)(a1 + 16), &p_p_theDict, (void (__cdecl *)(void *))sub_1B67816C4);
    }
    return 1;
  }
  return result;
}

void sub_1B67815F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  sub_1B6770568((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1B6781618(uint64_t ****a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v2 = ****a1;
    v3 = 134217984;
    v4 = v2;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPReactionObserverSession (0x%llx): observer sees ReactionEffectComplexity in image buffer attachment\n", (uint8_t *)&v3, 0xCu);
  }
}

void sub_1B67816C4(uint64_t ****a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v2 = ****a1;
    v3 = 134217984;
    v4 = v2;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPReactionObserverSession (0x%llx): observer sees ReactionEffectsInProgress in avcapture device\n", (uint8_t *)&v3, 0xCu);
  }
}

uint64_t sub_1B6781770(uint64_t a1, const char *a2, uint64_t a3)
{
  std::mutex *v6;
  __CFBundle *BundleWithIdentifier;
  const __CFURL *v8;
  size_t v9;
  const __CFURL *v10;
  const __CFURL *v11;
  const __CFString *v12;
  const __CFString *v13;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  std::string::size_type v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  std::string *v21;
  std::string::size_type size;
  std::string *v23;
  _QWORD *v25;
  uint64_t *v26;
  uint64_t context;
  uint64_t v28;
  __int128 v29;
  std::__shared_weak_count *v30;
  unint64_t *p_shared_owners;
  unint64_t v32;
  uint64_t plan;
  _BYTE v35[56];
  std::string v36;

  memset(&v35[32], 0, 24);
  v6 = (std::mutex *)(a1 + 544);
  std::mutex::lock((std::mutex *)(a1 + 544));
  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.VideoProcessing"));
  if (!BundleWithIdentifier || (v8 = CFBundleCopyResourcesDirectoryURL(BundleWithIdentifier)) == 0)
  {
    v18 = 4294954385;
    goto LABEL_58;
  }
  v9 = strlen(a2);
  v10 = CFURLCreateAbsoluteURLWithBytes(0, (const UInt8 *)a2, v9, 0x8000100u, v8, 0);
  v11 = v10;
  if (!v10)
  {
    v13 = 0;
    goto LABEL_12;
  }
  v12 = CFURLCopyPath(v10);
  v13 = v12;
  if (!v12)
  {
LABEL_12:
    v18 = 4294954385;
    goto LABEL_54;
  }
  if (CFStringGetLength(v12))
  {
    Length = CFStringGetLength(v13);
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0);
    v16 = MaximumSizeForEncoding + 1;
    if ((unint64_t)(MaximumSizeForEncoding + 1) >= 0x7FFFFFFFFFFFFFF8)
      sub_1B6781D28();
    if (v16 >= 0x17)
    {
      v19 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v16 | 7) != 0x17)
        v19 = v16 | 7;
      v20 = v19 + 1;
      v17 = operator new(v19 + 1);
      v36.__r_.__value_.__l.__size_ = v16;
      v36.__r_.__value_.__r.__words[2] = v20 | 0x8000000000000000;
      v36.__r_.__value_.__r.__words[0] = (std::string::size_type)v17;
    }
    else
    {
      *((_BYTE *)&v36.__r_.__value_.__s + 23) = MaximumSizeForEncoding + 1;
      v17 = &v36;
      if (MaximumSizeForEncoding == -1)
        goto LABEL_18;
    }
    bzero(v17, v16);
LABEL_18:
    *((_BYTE *)v17 + v16) = 0;
    if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v21 = &v36;
    else
      v21 = (std::string *)v36.__r_.__value_.__r.__words[0];
    if (CFStringGetCString(v13, (char *)v21, v16, 0))
    {
      size = HIBYTE(v36.__r_.__value_.__r.__words[2]);
      v23 = &v36;
      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      {
        size = v36.__r_.__value_.__l.__size_;
        v23 = (std::string *)v36.__r_.__value_.__r.__words[0];
      }
      while (size)
      {
        if (v23->__r_.__value_.__s.__data_[--size])
        {
          if (size != -1)
            std::string::resize(&v36, size + 1, 0);
          break;
        }
      }
      *(std::string *)v35 = v36;
    }
    else
    {
      sub_1B6781C7C(v35, "");
      if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v36.__r_.__value_.__l.__data_);
    }
    if ((v35[55] & 0x80000000) != 0)
      operator delete(*(void **)&v35[32]);
    goto LABEL_33;
  }
  sub_1B6781C7C(v35, "");
LABEL_33:
  *(std::string *)&v35[32] = *(std::string *)v35;
  if (!*(_QWORD *)a1)
  {
    v25 = operator new(0x28uLL);
    v25[1] = 0;
    v25[2] = 0;
    *v25 = &off_1E6A15A98;
    v25[3] = 0;
    v26 = v25 + 3;
    *((_DWORD *)v25 + 8) = 10007;
    context = espresso_create_context();
    v25[3] = context;
    if (!context)
    {
      *((_DWORD *)v25 + 8) = 5;
      v28 = espresso_create_context();
      *v26 = v28;
      if (!v28)
      {
        *((_DWORD *)v25 + 8) = 0;
        *v26 = espresso_create_context();
      }
    }
    *(_QWORD *)&v29 = v25 + 3;
    *((_QWORD *)&v29 + 1) = v25;
    v30 = *(std::__shared_weak_count **)(a1 + 8);
    *(_OWORD *)a1 = v29;
    if (v30)
    {
      p_shared_owners = (unint64_t *)&v30->__shared_owners_;
      do
        v32 = __ldaxr(p_shared_owners);
      while (__stlxr(v32 - 1, p_shared_owners));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    if (!*(_QWORD *)a1 || (plan = espresso_create_plan(), (*(_QWORD *)(a1 + 16) = plan) == 0))
    {
      v18 = 4294954392;
      goto LABEL_54;
    }
    v18 = espresso_plan_add_network();
    if ((_DWORD)v18)
      goto LABEL_54;
    if (a3)
    {
      v18 = espresso_network_select_configuration();
      if ((_DWORD)v18)
        goto LABEL_54;
    }
    v18 = espresso_plan_build();
    if ((_DWORD)v18)
      goto LABEL_54;
    if (!*(_BYTE *)(a1 + 608))
    {
      v18 = espresso_network_bind_buffer();
      if (!(_DWORD)v18)
      {
        v18 = espresso_network_bind_buffer();
        if (!(_DWORD)v18)
          v18 = espresso_network_bind_buffer();
      }
      goto LABEL_54;
    }
  }
  v18 = 0;
LABEL_54:
  CFRelease(v8);
  if (v11)
    CFRelease(v11);
  if (v13)
    CFRelease(v13);
LABEL_58:
  std::mutex::unlock(v6);
  if ((v35[55] & 0x80000000) != 0)
    operator delete(*(void **)&v35[32]);
  return v18;
}

void sub_1B6781B98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  std::mutex *v24;

  std::mutex::unlock(v24);
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_1B6781C08(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6A15A98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1B6781C18(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6A15A98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC9814CLL);
}

uint64_t sub_1B6781C48(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
  {
    result = espresso_context_destroy();
    *(_QWORD *)(a1 + 24) = 0;
  }
  return result;
}

_QWORD *sub_1B6781C7C(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    sub_1B6781D28();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

void sub_1B6781D28()
{
  sub_1B6773C1C("basic_string");
}

uint64_t VCPSessionGetTypeID()
{
  pthread_once(&stru_1EF137C88, (void (*)(void))sub_1B6781D68);
  return qword_1EF1387D8;
}

uint64_t sub_1B6781D68()
{
  uint64_t result;

  qword_1EF1387E0 = 0;
  *(_QWORD *)algn_1EF1387E8 = "VCPSession";
  qword_1EF1387F0 = (uint64_t)nullsub_4;
  unk_1EF1387F8 = 0;
  qword_1EF138800 = (uint64_t)sub_1B6781DC0;
  *(_OWORD *)algn_1EF138808 = 0u;
  *(_OWORD *)&algn_1EF138808[16] = 0u;
  result = _CFRuntimeRegisterClass();
  qword_1EF1387D8 = result;
  return result;
}

_QWORD *sub_1B6781DC0(_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = (_QWORD *)result[3];
    if (v2 && sub_1B677B478() != 1)
    {
      sub_1B677B4E8(v2);
      free(v2);
    }
    v1[3] = 0;
    v3 = v1[4];
    if (v3)
    {
      sub_1B677463C(v1[4]);
      MEMORY[0x1BCC9814C](v3, 0x10B0C40E486B3C3);
    }
    v1[4] = 0;
    result = (_QWORD *)v1[5];
    if (result)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
    v1[5] = 0;
  }
  return result;
}

uint64_t VCPSessionPrewarm(int a1, const __CFDictionary *a2)
{
  _QWORD *v2;
  uint8_t v4[16];
  uint8_t buf[16];

  if (a1 == 1936548208)
  {
    v2 = VCPSessionCreate(0, 1936548208, a2);
    if (v2)
    {
      CFRelease(v2);
      return 0;
    }
    else
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCP light spill session creation failed during session pre-warm", buf, 2u);
      }
      return 4294943592;
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v4 = 0;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Unsupported type parameter for session pre-warm", v4, 2u);
    }
    return 4294943593;
  }
}

_QWORD *VCPSessionCreate(uint64_t a1, int a2, const __CFDictionary *a3)
{
  uint64_t Instance;
  _QWORD *v6;
  double DoubleValue;
  const __CFNumber *Value;
  SInt32 IntValue;
  uint64_t v10;
  SInt32 v11;
  _BOOL4 v12;
  SInt32 v13;
  SInt32 v14;
  SInt32 v15;
  const __CFNumber *v16;
  const __CFBoolean *v17;
  const __CFNumber *v18;
  const __CFNumber *v19;
  const __CFNumber *v20;
  const __CFNumber *v21;
  const __CFString *v22;
  const __CFString *v23;
  const __CFString *v24;
  const __CFString *v25;
  const __CFString *v26;
  const __CFString *v27;
  uint64_t v28;
  const __CFString *v30;
  const __CFString *v31;
  const __CFString *v32;
  const __CFString *v33;
  const __CFString *v34;
  const __CFString *valuePtr;

  pthread_once(&stru_1EF137C88, (void (*)(void))sub_1B6781D68);
  Instance = _CFRuntimeCreateInstance();
  v6 = (_QWORD *)Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 32) = 0;
    *(_QWORD *)(Instance + 40) = 0;
    *(_DWORD *)(Instance + 16) = a2;
    if (a2 <= 1634889062)
    {
      if (a2 != 1634889062)
      {
LABEL_60:
        CFRelease(v6);
        return 0;
      }
      if (sub_1B677B478() != 1)
        v6[3] = malloc_type_calloc(0x3C0uLL, 1uLL, 0x55E39E3uLL);
    }
    else if (a2 == 1634889063)
    {
      v10 = operator new();
      *(_DWORD *)(v10 + 16) = 0;
      *(_WORD *)(v10 + 8226) = 0;
      *(_QWORD *)v10 = 0;
      *(_QWORD *)(v10 + 6) = 0;
      *(_QWORD *)(v10 + 8280) = 0;
      *(_QWORD *)(v10 + 8296) = 0;
      *(_QWORD *)(v10 + 8288) = 0;
      *(_QWORD *)(v10 + 8304) = sub_1B6773F70;
      *(_QWORD *)(v10 + 8312) = 0;
      *(_QWORD *)(v10 + 8320) = sub_1B6774274;
      *(_QWORD *)(v10 + 8328) = 0;
      *(_QWORD *)(v10 + 8232) = v10;
      *(_QWORD *)(v10 + 8288) = dispatch_get_global_queue(0, 0);
      v6[4] = v10;
    }
    else if (a2 != 1684632680)
    {
      if (a2 != 1936548208)
        goto LABEL_60;
      DoubleValue = 3.0;
      if (a3)
      {
        if (CFDictionaryContainsKey(a3, CFSTR("SpillmapWidth")))
        {
          LODWORD(valuePtr) = 0;
          Value = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("SpillmapWidth"));
          if (Value)
          {
            CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
            IntValue = (int)valuePtr;
          }
          else
          {
            IntValue = 0;
          }
        }
        else
        {
          IntValue = 8;
        }
        if (CFDictionaryContainsKey(a3, CFSTR("SpillmapHeight")))
        {
          LODWORD(valuePtr) = 0;
          v16 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("SpillmapHeight"));
          if (v16)
          {
            CFNumberGetValue(v16, kCFNumberSInt32Type, &valuePtr);
            v13 = (int)valuePtr;
          }
          else
          {
            v13 = 0;
          }
        }
        else
        {
          v13 = 8;
        }
        v12 = CFDictionaryContainsKey(a3, CFSTR("SpillmapUseAttachment"))
           && (v17 = (const __CFBoolean *)CFDictionaryGetValue(a3, CFSTR("SpillmapUseAttachment"))) != 0
           && CFBooleanGetValue(v17) != 0;
        if (CFDictionaryContainsKey(a3, CFSTR("SpillmapLayout"))
          && (LODWORD(valuePtr) = 0, (v18 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("SpillmapLayout"))) != 0))
        {
          CFNumberGetValue(v18, kCFNumberSInt32Type, &valuePtr);
          v11 = (int)valuePtr;
        }
        else
        {
          v11 = 0;
        }
        if (CFDictionaryContainsKey(a3, CFSTR("SpillmapIntermediateWidth")))
        {
          LODWORD(valuePtr) = 0;
          v19 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("SpillmapIntermediateWidth"));
          if (v19)
          {
            CFNumberGetValue(v19, kCFNumberSInt32Type, &valuePtr);
            v15 = (int)valuePtr;
          }
          else
          {
            v15 = 0;
          }
        }
        else
        {
          v15 = 128;
        }
        if (CFDictionaryContainsKey(a3, CFSTR("SpillmapIntermediateHeight")))
        {
          LODWORD(valuePtr) = 0;
          v20 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("SpillmapIntermediateHeight"));
          if (v20)
          {
            CFNumberGetValue(v20, kCFNumberSInt32Type, &valuePtr);
            v14 = (int)valuePtr;
          }
          else
          {
            v14 = 0;
          }
        }
        else
        {
          v14 = 128;
        }
        if (CFDictionaryContainsKey(a3, CFSTR("SpillmapIntermediateBlurSigma")))
        {
          valuePtr = 0;
          v21 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("SpillmapIntermediateBlurSigma"));
          if (v21)
          {
            CFNumberGetValue(v21, kCFNumberDoubleType, &valuePtr);
            DoubleValue = *(double *)&valuePtr;
          }
          else
          {
            DoubleValue = 0.0;
          }
        }
      }
      else
      {
        v11 = 0;
        v12 = 0;
        v13 = 8;
        v14 = 128;
        IntValue = 8;
        v15 = 128;
      }
      v22 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("SpillmapWidth"), CFSTR("com.apple.VideoProcessing"));
      valuePtr = v22;
      if (v22)
        IntValue = CFStringGetIntValue(v22);
      v23 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("SpillmapHeight"), CFSTR("com.apple.VideoProcessing"));
      v34 = v23;
      if (v23)
        v13 = CFStringGetIntValue(v23);
      v24 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("SpillmapLayout"), CFSTR("com.apple.VideoProcessing"));
      v33 = v24;
      if (v24)
        v11 = CFStringGetIntValue(v24);
      v25 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("SpillmapIntermediateTextureWidth"), CFSTR("com.apple.VideoProcessing"));
      v32 = v25;
      if (v25)
        v15 = CFStringGetIntValue(v25);
      v26 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("SpillmapIntermediateTextureHeight"), CFSTR("com.apple.VideoProcessing"));
      v31 = v26;
      if (v26)
        v14 = CFStringGetIntValue(v26);
      v27 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("SpillmapIntermediateGaussianSigma"), CFSTR("com.apple.VideoProcessing"));
      v30 = v27;
      if (v27)
        DoubleValue = CFStringGetDoubleValue(v27);
      v28 = operator new();
      *(_DWORD *)(v28 + 8) = IntValue;
      *(_DWORD *)(v28 + 12) = v13;
      if (v12)
      {
        *(_QWORD *)v28 = &off_1E6A15498;
        *(_OWORD *)(v28 + 16) = 0u;
        *(_OWORD *)(v28 + 32) = 0u;
        *(_OWORD *)(v28 + 48) = 0u;
        *(_OWORD *)(v28 + 64) = 0u;
      }
      else
      {
        *(_QWORD *)v28 = &off_1E6A15148;
        *(_QWORD *)(v28 + 16) = 0;
        *(_BYTE *)(v28 + 24) = 0;
        *(_BYTE *)(v28 + 32) = 0;
        *(_QWORD *)(v28 + 40) = 0;
        *(_DWORD *)(v28 + 28) = v11;
        *(_DWORD *)(v28 + 48) = v15;
        *(_DWORD *)(v28 + 52) = v14;
        *(double *)(v28 + 56) = DoubleValue;
      }
      sub_1B6770508((const void **)&v30);
      sub_1B6770508((const void **)&v31);
      sub_1B6770508((const void **)&v32);
      sub_1B6770508((const void **)&v33);
      sub_1B6770508((const void **)&v34);
      sub_1B6770508((const void **)&valuePtr);
      v6[5] = v28;
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v28 + 16))(v28))
        goto LABEL_60;
    }
  }
  return v6;
}

void sub_1B678246C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v3;
  va_list va;
  const void *v5;
  va_list va1;
  const void *v7;
  va_list va2;
  const void *v9;
  va_list va3;
  va_list va4;

  va_start(va4, a2);
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v5 = va_arg(va2, const void *);
  va_copy(va3, va2);
  v7 = va_arg(va3, const void *);
  va_copy(va4, va3);
  v9 = va_arg(va4, const void *);
  sub_1B6770508((const void **)va);
  sub_1B6770508((const void **)va1);
  sub_1B6770508((const void **)va2);
  sub_1B6770508((const void **)va3);
  sub_1B6770508((const void **)va4);
  _Unwind_Resume(a1);
}

uint64_t VCPSessionExecute(uint64_t a1, CFDictionaryRef theDict, CVPixelBufferRef *a3, uint64_t a4, CVPixelBufferRef *a5)
{
  uint64_t v8;
  int v9;
  float v11;
  int v13;
  __CVBuffer *v14;
  __CVBuffer *v15;
  unsigned int Width;
  int Height;
  char *BaseAddress;
  int BytesPerRow;
  __CVBuffer *v20;
  CFTypeRef v21;
  int v22;
  int v23;
  uint64_t v24;
  __CVBuffer *v25;
  __CVBuffer *v26;
  size_t v27;
  size_t v28;
  size_t v29;
  size_t v30;
  int v31;
  float v32;
  int v33;
  int v34;
  int v35;
  unsigned int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  unsigned int *v41;
  _BYTE *v42;
  char v43;
  int v44;
  int v45;
  char v46;
  int v47;
  int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  char *v52;
  unsigned int v53;
  int v54;
  char *v55;
  int v56;
  unsigned int v57;
  int v58;
  char *v59;
  int v60;
  unsigned int v61;
  uint64_t v62;
  int v63;
  _BYTE *v64;
  int v66;
  unint64_t v67;
  char v68;
  char v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int v72;
  char *v73;
  int v74;
  unsigned int v75;
  int v76;
  char *v77;
  int v78;
  unsigned int v79;
  unsigned int v80;
  int v81;
  char *v82;
  __int16 v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  char *v87;
  int v88;
  char *v89;
  int v90;
  unsigned int v91;
  unsigned int v92;
  int v93;
  char *v94;
  unsigned int v95;
  int v96;
  char v97;
  char v98;
  int v99;
  int v100;
  unsigned int v101;
  unsigned int v102;
  unsigned int v103;
  char *v104;
  unsigned int v105;
  int v106;
  char *v107;
  int v108;
  unsigned int v109;
  int v110;
  char *v111;
  int v112;
  unsigned int v113;
  uint64_t v114;
  int v115;
  _BYTE *v116;
  int v118;
  int v119;
  unsigned int v120;
  CVPixelBufferRef v121;
  char *v122;
  uint64_t v123;
  uint64_t v124;
  __int16 v125;
  uint64_t v126;
  uint64_t i;
  _BYTE *v128;
  char *v129;
  uint64_t v130;
  unsigned __int16 v131;
  unsigned int v132;
  unsigned __int16 v133;
  unsigned int v134;
  const void **p_number;
  unsigned __int16 *v136;
  __CVBuffer *v137;
  __CVBuffer *v138;
  unsigned int v139;
  int v140;
  int v141;
  const __CFNumber *v142;
  size_t v143;
  size_t v144;
  unsigned __int16 v145;
  float v146;
  unsigned int v147;
  unsigned int v148;
  unsigned int v149;
  unsigned __int16 v150;
  uint64_t v151;
  _QWORD *v152;
  _QWORD *v153;
  __int16 v154;
  uint64_t v155;
  size_t v156;
  _QWORD *v157;
  const std::nothrow_t *v158;
  __int16 v159;
  char *v160;
  dispatch_group_t v161;
  uint64_t v162;
  unsigned __int16 *v163;
  double v164;
  float v165;
  uint64_t v166;
  double v167;
  float v168;
  double v169;
  double v170;
  float v171;
  double v172;
  double v173;
  float v174;
  float v175;
  double v176;
  float v177;
  double v178;
  double v179;
  float v180;
  float v181;
  float v182;
  uint64_t v183;
  float *v184;
  float v185;
  float v186;
  double v187;
  float v188;
  double v189;
  double v190;
  float v191;
  double v192;
  float v193;
  double v194;
  double v195;
  float v196;
  unsigned int v197;
  __int16 v198;
  uint64_t v199;
  void **v200;
  unsigned __int16 *v201;
  float v202;
  unsigned __int16 v203;
  uint64_t v204;
  uint64_t v205;
  _WORD *v206;
  __int16 v207;
  int v208;
  uint64_t v209;
  unint64_t v210;
  float v211;
  size_t BytesPerRowOfPlane;
  size_t v214;
  char *v215;
  void *v216;
  char *BaseAddressOfPlane;
  int v218;
  int v219;
  int v220;
  int v221;
  char *v222;
  __CVBuffer *v223;
  int v224;
  float v225;
  CVPixelBufferRef v226;
  __CVBuffer *v227;
  int v228;
  float v229;
  int v230;
  _WORD *v231;
  int v232;
  unsigned int v233;
  int v234;
  float v235;
  int v236;
  int v237;
  float v238;
  float valuePtr;
  unsigned int v240;
  CFNumberRef number;
  int v242;
  unsigned int v243;
  uint64_t v244;
  void *value[18];

  value[16] = *(void **)MEMORY[0x1E0C80C00];
  if (!a1)
    return 4294943593;
  v8 = 0;
  v9 = *(_DWORD *)(a1 + 16);
  if (v9 > 1684632679)
  {
    if (v9 != 1684632680)
    {
      if (v9 != 1936548208)
        return v8;
      if (a4 == 1)
        return (*(uint64_t (**)(_QWORD, CVPixelBufferRef, CVPixelBufferRef *))(**(_QWORD **)(a1 + 40) + 24))(*(_QWORD *)(a1 + 40), *a3, a5);
      return 4294943593;
    }
    if (CVPixelBufferGetPixelFormatType(*a3) != 1983000880 || CVPixelBufferGetPixelFormatType(*a5) != 846624121)
      return 4294943593;
    v14 = *a3;
    v15 = *a5;
    CVPixelBufferLockBaseAddress(v14, 0);
    CVPixelBufferLockBaseAddress(v15, 0);
    Width = CVPixelBufferGetWidth(v14);
    Height = CVPixelBufferGetHeight(v14);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(v14);
    BytesPerRow = CVPixelBufferGetBytesPerRow(v14);
    v20 = (__CVBuffer *)CVPixelBufferGetBaseAddress(v15);
    v228 = CVPixelBufferGetBytesPerRow(v15);
    v230 = Height;
    v244 = 0;
    v242 = Height;
    v243 = Width;
    v21 = CVBufferCopyAttachment(v14, (CFStringRef)*MEMORY[0x1E0CA8D50], 0);
    value[0] = (void *)v21;
    if (v21)
    {
      number = 0;
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v21, (const void *)*MEMORY[0x1E0CA8D48], (const void **)&number))
      {
        CFNumberGetValue(number, kCFNumberIntType, (char *)&v244 + 4);
      }
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value[0], (const void *)*MEMORY[0x1E0CA8D58], (const void **)&number))
      {
        CFNumberGetValue(number, kCFNumberIntType, &v244);
      }
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value[0], (const void *)*MEMORY[0x1E0CA8D60], (const void **)&number))
      {
        CFNumberGetValue(number, kCFNumberIntType, &v243);
        HIDWORD(v244) += (Width - v243) >> 1;
      }
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value[0], (const void *)*MEMORY[0x1E0CA8D40], (const void **)&number))
      {
        CFNumberGetValue(number, kCFNumberIntType, &v242);
        LODWORD(v244) = v244 + ((Height - v242) >> 1);
        v230 = v242;
      }
      v22 = HIDWORD(v244);
      if ((v244 & 0x100000000) != 0)
        goto LABEL_177;
      Width = v243;
    }
    else
    {
      v22 = 0;
    }
    if (((Width | v230) & 1) == 0)
    {
      v226 = v20;
      v224 = v22 + Width;
      v33 = 2 * (v22 + Width);
      if (v33 + 10 >= BytesPerRow)
        goto LABEL_276;
      LODWORD(number) = 0;
      v34 = dword_1EF138768;
      if (v230 >= 1)
      {
        v35 = 0;
        v36 = 0;
        v37 = BytesPerRow >> 2;
        v38 = 2 * v22;
        v237 = v33 - 1;
        v39 = v22 / 6;
        v218 = v37;
        v40 = v37 * v244;
        v222 = &BaseAddress[16 * v39];
        v236 = v224 - 7;
        v219 = 6 * v39 + 6;
        v220 = (12 * v39) | 3;
        v221 = 12 * v39;
        while (1)
        {
          v234 = v35;
          LODWORD(number) = ((_WORD)number + (_WORD)v35 + (_WORD)v34) & 0xFFF;
          v232 = v40;
          v41 = (unsigned int *)&v222[4 * v40];
          v233 = v36;
          v42 = (char *)v226 + v36;
          v43 = 1;
          v44 = v220;
          v45 = v221;
          do
          {
            v46 = v43;
            v47 = v45;
            v48 = sub_1B6773E14(*v41, (int *)&number, v42, v45, v38, v237);
            if (number > 0xFFF)
              goto LABEL_276;
            v49 = v41[1];
            v50 = (v49 >> 10) & 0x3FF;
            v51 = (v49 >> 20) & 0x3FF;
            if (v51 <= 0x43)
              v52 = byte_1B691CDE4;
            else
              v52 = (char *)&unk_1B691DDE4;
            v53 = v41[1] & 0x3FF;
            v54 = (int)(v51 + v52[number]) >> 2;
            if (v54 >= 255)
              LOBYTE(v54) = -1;
            if (v53 <= 0x43)
              v55 = byte_1B691CDE4;
            else
              v55 = (char *)&unk_1B691DDE4;
            v56 = (int)(v53 + v55[((_WORD)number + 1) & 0xFFF]) >> 2;
            if (v56 >= 255)
              LOBYTE(v56) = -1;
            LOBYTE(v240) = v56;
            if (v54 > 0x11u)
            {
              v58 = 512 - v50;
              if (v50 >= 0x200)
                v58 = v50 - 512;
              if (v58 <= 3)
                v59 = byte_1B691CDE4;
              else
                v59 = (char *)&unk_1B691DDE4;
              v60 = v59[((_WORD)number + 2) & 0xFFF];
              v61 = ((v50 + v60) & ~((int)(v50 + v60) >> 31)) >> 2;
              if (v61 >= 0xFF)
                LOBYTE(v57) = -1;
              else
                LOBYTE(v57) = v61;
            }
            else
            {
              v57 = v50 >> 2;
            }
            v62 = 0;
            v63 = 0;
            LODWORD(number) = ((_WORD)number + 3) & 0xFFF;
            BYTE1(v240) = v57;
            BYTE2(v240) = v54;
            v64 = &v42[v48];
            do
            {
              if (v44 + (int)v62 >= v38 && v44 + (int)v62 < v33)
              {
                *v64++ = *((_BYTE *)&v240 + v62);
                ++v63;
              }
              ++v62;
            }
            while (v62 != 3);
            v43 = 0;
            v34 = ((_WORD)dword_1EF138768 + (v54 & 1)) & 0xFFF;
            dword_1EF138768 = v34;
            v41 += 2;
            v45 = v47 + 6;
            v42 += v48 + (uint64_t)v63;
            v44 += 6;
          }
          while ((v46 & 1) != 0);
          v66 = v219;
          if (v219 <= v236)
          {
            v67 = number;
            do
            {
              v45 += 12;
              v68 = 1;
              do
              {
                if (v67 > 0xFFF)
                  goto LABEL_276;
                v69 = v68;
                v70 = *v41;
                v71 = *v41 & 0x3FF;
                v72 = (*v41 >> 10) & 0x3FF;
                if (v72 <= 0x43)
                  v73 = byte_1B691CDE4;
                else
                  v73 = (char *)&unk_1B691DDE4;
                v74 = (int)(v72 + v73[v67]) >> 2;
                if (v74 >= 255)
                  LOBYTE(v74) = -1;
                if (v74 > 0x11u)
                {
                  v76 = 512 - v71;
                  if (v71 >= 0x200)
                    v76 = v71 - 512;
                  if (v76 <= 3)
                    v77 = byte_1B691CDE4;
                  else
                    v77 = (char *)&unk_1B691DDE4;
                  v78 = v77[((_WORD)v67 + 1) & 0xFFF];
                  v75 = ((v71 + v78) & ~((int)(v71 + v78) >> 31)) >> 2;
                  if (v75 >= 0xFF)
                    LOBYTE(v75) = -1;
                }
                else
                {
                  v75 = v71 >> 2;
                }
                LODWORD(number) = ((_WORD)v67 + 2) & 0xFFF;
                *v42 = v75;
                v42[1] = v74;
                if (number > 0xFFF)
                  goto LABEL_276;
                v79 = (v70 >> 20) & 0x3FF;
                if (v74 > 0x11u)
                {
                  v81 = 512 - v79;
                  if (v79 >= 0x200)
                    v81 = v79 - 512;
                  if (v81 <= 3)
                    v82 = byte_1B691CDE4;
                  else
                    v82 = (char *)&unk_1B691DDE4;
                  v80 = ((v79 + v82[number]) & ~((int)(v79 + v82[number]) >> 31)) >> 2;
                  if (v80 >= 0xFF)
                    LOBYTE(v80) = -1;
                }
                else
                {
                  v80 = v79 >> 2;
                }
                LODWORD(number) = ((_WORD)number + 1) & 0xFFF;
                v42[2] = v80;
                v83 = v34 + (v74 & 1);
                dword_1EF138768 = v83 & 0xFFF;
                if (number > 0xFFF)
                  goto LABEL_276;
                v84 = v41[1];
                v85 = (v84 >> 20) & 0x3FF;
                v86 = v84 & 0x3FF;
                if (v85 <= 0x43)
                  v87 = byte_1B691CDE4;
                else
                  v87 = (char *)&unk_1B691DDE4;
                v88 = (int)(v85 + v87[number]) >> 2;
                if (v88 >= 255)
                  LOBYTE(v88) = -1;
                if (v86 <= 0x43)
                  v89 = byte_1B691CDE4;
                else
                  v89 = (char *)&unk_1B691DDE4;
                v90 = (int)(v86 + v89[((_WORD)number + 1) & 0xFFF]) >> 2;
                if (v90 >= 255)
                  LOBYTE(v90) = -1;
                LODWORD(number) = ((_WORD)number + 2) & 0xFFF;
                v42[3] = v90;
                if (number > 0xFFF)
                  goto LABEL_276;
                v91 = (v84 >> 10) & 0x3FF;
                if (v88 > 0x11u)
                {
                  v93 = 512 - v91;
                  if (v91 >= 0x200)
                    v93 = v91 - 512;
                  if (v93 <= 3)
                    v94 = byte_1B691CDE4;
                  else
                    v94 = (char *)&unk_1B691DDE4;
                  v95 = ((v91 + v94[number]) & ~((int)(v91 + v94[number]) >> 31)) >> 2;
                  if (v95 >= 0xFF)
                    LOBYTE(v92) = -1;
                  else
                    LOBYTE(v92) = v95;
                }
                else
                {
                  v92 = v91 >> 2;
                }
                v68 = 0;
                v67 = ((_WORD)number + 1) & 0xFFF;
                LODWORD(number) = ((_WORD)number + 1) & 0xFFF;
                v42[4] = v92;
                v42[5] = v88;
                v34 = (v83 + (v88 & 1)) & 0xFFF;
                dword_1EF138768 = v34;
                v41 += 2;
                v42 += 6;
              }
              while ((v69 & 1) != 0);
              v66 += 6;
            }
            while (v66 <= v236);
          }
          if (v66 < v224)
            break;
LABEL_167:
          v40 = v232 + v218;
          v36 = v233 + v228;
          v35 = v234 + 1;
          if (v234 + 1 == v230)
            goto LABEL_168;
        }
        v96 = v45 + 3;
        v97 = 1;
        while (1)
        {
          v98 = v97;
          v99 = v45;
          v100 = sub_1B6773E14(*v41, (int *)&number, v42, v45, v38, v237);
          if (number > 0xFFF)
            break;
          v101 = v41[1];
          v102 = (v101 >> 10) & 0x3FF;
          v103 = (v101 >> 20) & 0x3FF;
          if (v103 <= 0x43)
            v104 = byte_1B691CDE4;
          else
            v104 = (char *)&unk_1B691DDE4;
          v105 = v41[1] & 0x3FF;
          v106 = (int)(v103 + v104[number]) >> 2;
          if (v106 >= 255)
            LOBYTE(v106) = -1;
          if (v105 <= 0x43)
            v107 = byte_1B691CDE4;
          else
            v107 = (char *)&unk_1B691DDE4;
          v108 = (int)(v105 + v107[((_WORD)number + 1) & 0xFFF]) >> 2;
          if (v108 >= 255)
            LOBYTE(v108) = -1;
          LOBYTE(v240) = v108;
          if (v106 > 0x11u)
          {
            v110 = 512 - v102;
            if (v102 >= 0x200)
              v110 = v102 - 512;
            if (v110 <= 3)
              v111 = byte_1B691CDE4;
            else
              v111 = (char *)&unk_1B691DDE4;
            v112 = v111[((_WORD)number + 2) & 0xFFF];
            v113 = ((v102 + v112) & ~((int)(v102 + v112) >> 31)) >> 2;
            if (v113 >= 0xFF)
              LOBYTE(v109) = -1;
            else
              LOBYTE(v109) = v113;
          }
          else
          {
            v109 = v102 >> 2;
          }
          v114 = 0;
          v115 = 0;
          LODWORD(number) = ((_WORD)number + 3) & 0xFFF;
          BYTE1(v240) = v109;
          BYTE2(v240) = v106;
          v116 = &v42[v100];
          do
          {
            if (v96 + (int)v114 >= v38 && v96 + (int)v114 < v33)
            {
              *v116++ = *((_BYTE *)&v240 + v114);
              ++v115;
            }
            ++v114;
          }
          while (v114 != 3);
          v97 = 0;
          v34 = ((_WORD)dword_1EF138768 + (v106 & 1)) & 0xFFF;
          dword_1EF138768 = v34;
          v41 += 2;
          v45 = v99 + 6;
          v42 += v100 + (uint64_t)v115;
          v96 += 6;
          if ((v98 & 1) == 0)
            goto LABEL_167;
        }
LABEL_276:
        exit(1);
      }
LABEL_168:
      v118 = v242;
      if (v242 >= 1)
      {
        v119 = 0;
        LOWORD(v120) = 0;
        v121 = v226;
        v122 = (char *)v226 + v228;
        v123 = 2 * v228;
        v124 = (int)((v243 + 15) & 0xFFFFFFF0);
        do
        {
          v125 = v119 + v120 + v34;
          v120 = v125 & 0xFFF;
          if ((int)v124 >= 1)
          {
            v126 = 0;
            for (i = 0; i < v124; i += 2)
            {
              v128 = (char *)v121 + v126;
              v129 = &v122[v126];
              v130 = (v125 + 1) & 0xFFF;
              v131 = byte_1B691CDE4[v120] + 2 * (*((unsigned __int8 *)v121 + v126) + v122[v126]);
              v132 = v131 & 0xFFFC;
              LOBYTE(v131) = v131 >> 2;
              v133 = byte_1B691CDE4[v130]
                   + 2 * (v122[v126 + 2] + *((unsigned __int8 *)v121 + v126 + 2));
              v134 = v133 & 0xFFFC;
              v133 >>= 2;
              v125 = v130 + 1;
              v34 = ((_WORD)v34 + ((v132 >> 2) & 1) + ((v134 >> 2) & 1)) & 0xFFF;
              *v128 = v131;
              *v129 = v131;
              v128[2] = v133;
              v129[2] = v133;
              v120 = v125 & 0xFFF;
              v126 += 4;
            }
            dword_1EF138768 = v34;
          }
          v121 = (CVPixelBufferRef)((char *)v121 + v123);
          v122 += v123;
          v119 += 2;
        }
        while (v119 < v118);
      }
      if (v34 >= 4096)
        goto LABEL_276;
      CVPixelBufferUnlockBaseAddress(v14, 0);
      CVPixelBufferUnlockBaseAddress(v15, 0);
      v8 = 0;
LABEL_178:
      p_number = (const void **)value;
LABEL_252:
      sub_1B6770568(p_number);
      return v8;
    }
LABEL_177:
    v8 = 4294943593;
    goto LABEL_178;
  }
  if (v9 == 1634889062)
  {
    v244 = 0;
    if (theDict)
    {
      value[0] = 0;
      if (CFDictionaryGetValueIfPresent(theDict, CFSTR("used_width"), (const void **)value))
        CFNumberGetValue((CFNumberRef)value[0], kCFNumberSInt32Type, (char *)&v244 + 4);
      if (CFDictionaryGetValueIfPresent(theDict, CFSTR("used_height"), (const void **)value))
      {
        CFNumberGetValue((CFNumberRef)value[0], kCFNumberSInt32Type, &v244);
        v13 = v244;
      }
      else
      {
        v13 = 0;
      }
      v23 = HIDWORD(v244);
    }
    else
    {
      v13 = 0;
      v23 = 0;
    }
    v24 = *(_QWORD *)(a1 + 24);
    v25 = *a3;
    v26 = *a5;
    if (sub_1B677B478() != 1)
    {
      v27 = CVPixelBufferGetWidth(v25);
      v28 = CVPixelBufferGetHeight(v25);
      v29 = CVPixelBufferGetWidth(v26);
      v30 = CVPixelBufferGetHeight(v26);
      v8 = 4294943593;
      if (!v24 || (v27 & 0xF) != 0 || v27 != v29 || v28 != v30)
        return v8;
      if (byte_1EF1387CC == 1)
      {
        v31 = dword_1EF1387C8;
      }
      else
      {
        number = (CFNumberRef)100;
        if (sysctlbyname("hw.machine", value, (size_t *)&number, 0, 0))
        {
          v31 = 0;
        }
        else if (strstr((char *)value, "iPhone"))
        {
          v31 = 1;
        }
        else if (strstr((char *)value, "iPad"))
        {
          v31 = 2;
        }
        else if (strstr((char *)value, "x86_64"))
        {
          v31 = 3;
        }
        else
        {
          v31 = 0;
        }
        dword_1EF1387C8 = v31;
        byte_1EF1387CC = 1;
      }
      v211 = 0.0;
      if (v23 && v13 && v31)
      {
        if (v31 == 2)
        {
          v211 = 2.0;
        }
        else if (v31 == 1)
        {
          if (v13 < 192 || v23 < 256)
            v211 = 2.5;
          else
            v211 = 3.0;
        }
      }
      BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v25, 0);
      if (v25 == v26)
      {
        CVPixelBufferLockBaseAddress(v25, 0);
        BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(v25, 0);
        sub_1B677B534(v24, BaseAddressOfPlane, BytesPerRowOfPlane, v27, v28, (uint64_t)BaseAddressOfPlane, BytesPerRowOfPlane, v211);
      }
      else
      {
        v214 = CVPixelBufferGetBytesPerRowOfPlane(v26, 0);
        CVPixelBufferLockBaseAddress(v25, 0);
        CVPixelBufferLockBaseAddress(v26, 0);
        v215 = (char *)CVPixelBufferGetBaseAddressOfPlane(v25, 0);
        v216 = CVPixelBufferGetBaseAddressOfPlane(v26, 0);
        sub_1B677B534(v24, v215, BytesPerRowOfPlane, v27, v28, (uint64_t)v216, v214, v211);
        CVPixelBufferUnlockBaseAddress(v25, 0);
        v25 = v26;
      }
      CVPixelBufferUnlockBaseAddress(v25, 0);
    }
    return 0;
  }
  else if (v9 == 1634889063)
  {
    if (CVPixelBufferGetPixelFormatType(*a3) == 846624121 && CVPixelBufferGetPixelFormatType(*a5) == 846624121)
    {
      v238 = 0.0;
      valuePtr = 0.0;
      if (theDict)
      {
        value[0] = 0;
        if (CFDictionaryGetValueIfPresent(theDict, CFSTR("phase_x"), (const void **)value))
          CFNumberGetValue((CFNumberRef)value[0], kCFNumberFloatType, &valuePtr);
        if (CFDictionaryGetValueIfPresent(theDict, CFSTR("phase_y"), (const void **)value))
        {
          CFNumberGetValue((CFNumberRef)value[0], kCFNumberFloatType, &v238);
          v11 = v238;
        }
        else
        {
          v11 = 0.0;
        }
        v32 = valuePtr;
      }
      else
      {
        v11 = 0.0;
        v32 = 0.0;
      }
      v8 = 4294943593;
      if (v11 < -0.5 || v32 > 0.5 || v32 < -0.5 || v11 > 0.5)
        return v8;
      v136 = *(unsigned __int16 **)(a1 + 32);
      v137 = *a3;
      v138 = *a5;
      v243 = 0;
      LODWORD(v244) = 0;
      v242 = CVPixelBufferGetWidth(v137);
      v139 = CVPixelBufferGetHeight(v137);
      v240 = v139;
      v140 = CVPixelBufferGetWidth(v138);
      v141 = CVPixelBufferGetHeight(v138);
      v142 = (const __CFNumber *)CVBufferCopyAttachment(v137, (CFStringRef)*MEMORY[0x1E0CA8D50], 0);
      number = v142;
      v229 = v32;
      if (v142)
      {
        value[0] = 0;
        if (CFDictionaryGetValueIfPresent(v142, (const void *)*MEMORY[0x1E0CA8D48], (const void **)value))
          CFNumberGetValue((CFNumberRef)value[0], kCFNumberIntType, &v244);
        if (CFDictionaryGetValueIfPresent(number, (const void *)*MEMORY[0x1E0CA8D58], (const void **)value))
          CFNumberGetValue((CFNumberRef)value[0], kCFNumberIntType, &v243);
        if (CFDictionaryGetValueIfPresent(number, (const void *)*MEMORY[0x1E0CA8D60], (const void **)value))
        {
          CFNumberGetValue((CFNumberRef)value[0], kCFNumberIntType, &v242);
          v143 = CVPixelBufferGetWidth(v137);
          LODWORD(v244) = v244 + ((v143 - v242) >> 1);
        }
        if (CFDictionaryGetValueIfPresent(number, (const void *)*MEMORY[0x1E0CA8D40], (const void **)value))
        {
          CFNumberGetValue((CFNumberRef)value[0], kCFNumberIntType, &v240);
          v144 = CVPixelBufferGetHeight(v137);
          v139 = v240;
          v243 += (v144 - v240) >> 1;
        }
        if ((v244 & 1) != 0)
        {
          v8 = 4294943593;
LABEL_251:
          p_number = (const void **)&number;
          goto LABEL_252;
        }
      }
      v225 = v11;
      v227 = v137;
      v231 = v136 + 4112;
      v145 = v242;
      if (v242 != *v136 || v139 != v136[1] || v136[2] != v140 || v136[3] != v141)
      {
        v223 = v138;
        sub_1B677463C((uint64_t)v136);
        *v136 = v145;
        v136[1] = v139;
        v136[2] = v140;
        v136[3] = v141;
        v146 = (float)(unsigned __int16)v140 / (float)v145;
        if (v146 >= 1.0)
          v146 = 1.0;
        v147 = vcvtps_s32_f32(3.0 / v146);
        *((float *)v136 + 2) = v146;
        if (v147 >= 0x10)
          LOWORD(v147) = 16;
        v136[6] = v147;
        *v231 = ((_BYTE)v147 + 7) & 0x38;
        HIDWORD(v244) = 1;
        value[0] = (void *)4;
        if (sysctlbyname("hw.logicalcpu", (char *)&v244 + 4, (size_t *)value, 0, 0))
          fwrite("Failed to query number of CPUs\n", 0x1FuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
        v148 = v136[3];
        v149 = ((HIDWORD(v244) - 1 + v148) / HIDWORD(v244) + 1) & 0xFFFFFFFE;
        v150 = WORD2(v244) - (v149 * (HIDWORD(v244) - 1) > v148);
        v136[4113] = v150;
        v151 = v150;
        v152 = operator new[](24 * v151, MEMORY[0x1E0DE4E10]);
        if (!v152)
        {
          *((_QWORD *)v136 + 1035) = 0;
LABEL_250:
          v8 = 4294943590;
          goto LABEL_251;
        }
        if ((_DWORD)v151)
        {
          v153 = v152;
          do
          {
            *v153 = 0;
            v153[2] = 0;
            v153 += 3;
          }
          while (v153 != &v152[3 * v151]);
          v154 = 0;
          *((_QWORD *)v136 + 1035) = v152;
          v155 = (unsigned __int16)*v231;
          v156 = 8 * v155 + 4 * ((unsigned __int16)((*v136 >> 1) + 7) & 0xFFF8) + 14;
          v157 = v152 + 2;
          v158 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
          while (1)
          {
            *(v157 - 2) = v136 + 4116;
            *((_WORD *)v157 - 4) = v149 * v154++;
            v159 = v148 >= (unsigned __int16)(v149 * v154) ? v149 * v154 : v148;
            *((_WORD *)v157 - 3) = v159;
            v160 = (char *)operator new[](v156, v158);
            *v157 = v160;
            if (!v160)
              goto LABEL_250;
            *v157 = &v160[2 * v155];
            v157 += 3;
            if (!--v151)
              goto LABEL_223;
          }
        }
        *((_QWORD *)v136 + 1035) = v152;
LABEL_223:
        v161 = dispatch_group_create();
        *((_QWORD *)v136 + 1037) = v161;
        if (!v161)
          goto LABEL_250;
        v162 = 0;
        v163 = v136 + 16;
        v164 = 3.0;
        v138 = v223;
        do
        {
          v165 = (float)(int)v162 * -0.0078125;
          if (fabsf(v165) >= 0.00001)
          {
            v169 = v165 * 3.14159265;
            v235 = *((float *)v136 + 2);
            v167 = v235;
            v170 = v169 * v235;
            v171 = v170;
            v172 = sinf(v171) / v170;
            v173 = v169 / v164 * v235;
            v174 = v173;
            v168 = v172 * (sinf(v174) / v173);
            v166 = v136[6];
            *((float *)value + v166 - 1) = v168;
          }
          else
          {
            v166 = v136[6];
            *((_DWORD *)value + v166 - 1) = 1065353216;
            v235 = *((float *)v136 + 2);
            v167 = v235;
            v168 = 1.0;
          }
          v175 = v165 + 1.0;
          v176 = (float)(v165 + 1.0) * 3.14159265;
          v177 = v176 * v167;
          v178 = sinf(v177) / (v176 * v167);
          v179 = v176 / 3.0 * v167;
          v180 = v179;
          v181 = v178 * (sinf(v180) / v179);
          v182 = v168 + v181;
          *((float *)value + v166) = v181;
          if (v166 >= 2)
          {
            v183 = 4 * v166;
            v184 = (float *)((char *)value + v183 + 4);
            do
            {
              v165 = v165 + -1.0;
              v185 = 0.0;
              v186 = 0.0;
              if (v165 > (float)(-3.0 / v235))
              {
                v187 = v165 * 3.14159265;
                v188 = v187 * v167;
                v189 = sinf(v188) / (v187 * v167);
                v190 = v187 / 3.0 * v167;
                v191 = v190;
                v186 = v189 * (sinf(v191) / v190);
              }
              v175 = v175 + 1.0;
              *(float *)((char *)&value[-1] + v183) = v186;
              if (v175 < (float)(3.0 / v235))
              {
                v192 = v175 * 3.14159265;
                v193 = v192 * v167;
                v194 = sinf(v193) / (v192 * v167);
                v195 = v192 / 3.0 * v167;
                v196 = v195;
                v185 = v194 * (sinf(v196) / v195);
              }
              *v184++ = v185;
              v182 = v182 + (float)(v186 + v185);
              v183 -= 4;
            }
            while (v183 != 4);
          }
          v197 = 2 * v166;
          v198 = 0;
          if ((_DWORD)v166)
          {
            if (v197 <= 1)
              v199 = 1;
            else
              v199 = v197;
            v200 = value;
            v201 = v163;
            v164 = 3.0;
            do
            {
              v202 = *(float *)v200 / v182;
              *(float *)v200 = v202;
              v200 = (void **)((char *)v200 + 4);
              v203 = llroundf(v202 * 64.0);
              *v201++ = v203;
              v198 += v203;
              --v199;
            }
            while (v199);
          }
          else
          {
            v164 = 3.0;
          }
          v204 = (uint64_t)&v136[32 * v162 + 16];
          v205 = v204 + 2 * v166;
          v208 = *(__int16 *)(v205 - 2);
          v206 = (_WORD *)(v205 - 2);
          v207 = v208;
          if (v208 <= *(__int16 *)(v204 + 2 * v166))
          {
            v207 = *(_WORD *)(v204 + 2 * v166);
            v206 = (_WORD *)(v204 + 2 * v166);
          }
          *v206 = v207 - v198 + 64;
          bzero((void *)(v204 + 2 * v197), 2 * (int)(32 - v197));
          ++v162;
          v163 += 32;
        }
        while (v162 != 128);
      }
      CVPixelBufferLockBaseAddress(v227, 1uLL);
      CVPixelBufferLockBaseAddress(v138, 0);
      *((_QWORD *)v136 + 1030) = CVPixelBufferGetBaseAddress(v227);
      *((_QWORD *)v136 + 1031) = CVPixelBufferGetBytesPerRow(v227);
      *((_QWORD *)v136 + 1032) = CVPixelBufferGetBaseAddress(v138);
      *((_QWORD *)v136 + 1033) = CVPixelBufferGetBytesPerRow(v138);
      *((float *)v136 + 2068) = v229;
      *((float *)v136 + 2069) = v225;
      *((_QWORD *)v136 + 1030) += (2 * v244) + *((_QWORD *)v136 + 1031) * v243;
      if (v136[4113])
      {
        v209 = 0;
        v210 = 0;
        do
        {
          dispatch_group_async_f(*((dispatch_group_t *)v136 + 1037), *((dispatch_queue_t *)v136 + 1036), (void *)(*((_QWORD *)v136 + 1035) + v209), (dispatch_function_t)sub_1B6774700);
          ++v210;
          v209 += 24;
        }
        while (v210 < v136[4113]);
      }
      dispatch_group_wait(*((dispatch_group_t *)v136 + 1037), 0xFFFFFFFFFFFFFFFFLL);
      *((_DWORD *)v136 + 4) = ((unsigned __int16)*((_DWORD *)v136 + 4)
                             + (unsigned __int16)((3 * v136[2] * v136[3]) >> 1)
                             + (**((_BYTE **)v136 + 1030) & 1)) & 0xFFF;
      CVPixelBufferUnlockBaseAddress(v227, 0);
      CVPixelBufferUnlockBaseAddress(v138, 0);
      v8 = 0;
      goto LABEL_251;
    }
    return 4294943593;
  }
  return v8;
}

void sub_1B6783A24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,const void *a26)
{
  sub_1B6770568(&a26);
  _Unwind_Resume(a1);
}

uint64_t VCPSessionSetProperty(uint64_t a1, CFTypeRef cf1, const __CFData *a3)
{
  CFTypeID TypeID;

  if (a1)
  {
    if (!*(_DWORD *)(a1 + 16))
    {
      if (CFEqual(cf1, CFSTR("SCN_UUID")))
      {
        TypeID = CFDataGetTypeID();
        if (TypeID == CFGetTypeID(a3))
        {
          CFDataGetBytePtr(a3);
          CFDataGetLength(a3);
        }
      }
    }
  }
  return 0;
}

uint64_t VCPSessionCopyProperty()
{
  return 0;
}

CFDictionaryRef VCPSessionCreateDefaultBufferProperties(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFDictionaryRef v4;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  void *v12;
  void *v13;
  __CFDictionary *Mutable;
  CFNumberRef v15;
  CFNumberRef v16;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int valuePtr;
  int v23;
  void *values[5];
  __CFDictionary *v25;
  void *keys[5];
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1 || *(_DWORD *)(a1 + 16))
    return 0;
  v27 = 0;
  v25 = 0;
  valuePtr = 875704438;
  v7 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  values[0] = v7;
  keys[0] = *(void **)MEMORY[0x1E0CA9040];
  v21 = a3;
  v8 = CFNumberCreate(0, kCFNumberSInt32Type, &v21);
  values[1] = v8;
  keys[1] = *(void **)MEMORY[0x1E0CA90E0];
  v20 = a4;
  v9 = CFNumberCreate(0, kCFNumberSInt32Type, &v20);
  values[2] = v9;
  keys[2] = *(void **)MEMORY[0x1E0CA8FD8];
  v18 = 16;
  v19 = 64;
  v10 = CFNumberCreate(0, kCFNumberSInt32Type, &v19);
  v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v18);
  v12 = (void *)*MEMORY[0x1E0CA9048];
  values[3] = v10;
  values[4] = v11;
  v13 = (void *)*MEMORY[0x1E0CA8F68];
  keys[3] = v12;
  keys[4] = v13;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v23 = 1024;
  v15 = CFNumberCreate(0, kCFNumberIntType, &v23);
  if (v15)
  {
    v16 = v15;
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CBBF10], v15);
    CFRelease(v16);
  }
  v25 = Mutable;
  v27 = *MEMORY[0x1E0CA8FF0];
  v4 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)values, 6, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFRelease(v7);
  CFRelease(v8);
  CFRelease(v9);
  CFRelease(v10);
  CFRelease(v11);
  CFRelease(Mutable);
  return v4;
}

CFStringRef VCPCreateNegotiatedFLS(const __CFString *a1, const __CFString *a2)
{
  _BOOL4 v4;
  int v6;
  const __CFString *v7;
  __int16 v8;
  const __CFString *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v4 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT);
  if (a1 && a2)
  {
    if (v4)
    {
      v6 = 138543618;
      v7 = a1;
      v8 = 2114;
      v9 = a2;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPCreateNegotiatedFLS remote_FLB %{public}@  local_FLS %{public}@", (uint8_t *)&v6, 0x16u);
    }
    return sub_1B685C050(a2, a1);
  }
  else
  {
    if (v4)
    {
      v6 = 134218240;
      v7 = a1;
      v8 = 2048;
      v9 = a2;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPCreateNegotiatedFLS remote_FLB_ptr %p local_FLS %p", (uint8_t *)&v6, 0x16u);
    }
    return 0;
  }
}

CFDataRef VCPCreateCompressedFLS(const __CFString *a1)
{
  _BOOL4 v2;
  int v4;
  const __CFString *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v2 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT);
  if (a1)
  {
    if (v2)
    {
      v4 = 138543362;
      v5 = a1;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPCreateCompressedFLS FLS %{public}@ ", (uint8_t *)&v4, 0xCu);
    }
    return sub_1B685C598(a1);
  }
  else
  {
    if (v2)
    {
      LOWORD(v4) = 0;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPCreateCompressedFLS FLS NULL", (uint8_t *)&v4, 2u);
    }
    return 0;
  }
}

CFStringRef VCPCreateDecompressedFLS(const __CFData *a1)
{
  _BOOL4 v2;
  int v4;
  const __CFData *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v2 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT);
  if (a1)
  {
    if (v2)
    {
      v4 = 138543362;
      v5 = a1;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPCreateDecompressedFLS compressed_FLS %{public}@ ", (uint8_t *)&v4, 0xCu);
    }
    return sub_1B685C744(a1);
  }
  else
  {
    if (v2)
    {
      LOWORD(v4) = 0;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPCreateDecompressedFLS compressed_FLS NULL", (uint8_t *)&v4, 2u);
    }
    return 0;
  }
}

uint64_t VCPReactionObserverCreate(_QWORD *a1, uint64_t a2, VCPReactionAVCaptureDeviceObserver **a3)
{
  VCPReactionAVCaptureDeviceObserver *v4;
  VCPReactionAVCaptureDeviceObserver *v5;
  VCPReactionAVCaptureDeviceObserver *v6;
  uint64_t v7;
  __int16 v9[8];

  v4 = -[VCPReactionAVCaptureDeviceObserver initWithCallerID:listener:callback:]([VCPReactionAVCaptureDeviceObserver alloc], "initWithCallerID:listener:callback:", *a1, a1, a2);
  v5 = v4;
  if (v4)
  {
    v6 = v4;
    v7 = 0;
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v9[0] = 0;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Failed to create VCPReactionAVCaptureDeviceObserver", (uint8_t *)v9, 2u);
    }
    v6 = 0;
    v7 = 4294967188;
  }

  *a3 = v6;
  return v7;
}

uint64_t VCPCodecCopyProperties(int a1, CFDictionaryRef *a2, int a3)
{
  CFDictionaryRef v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  const __CFAllocator *v13;
  const __CFString *v14;
  __int128 *v15;
  __int128 *v16;
  __int128 *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  char *v26;
  char *v27;
  __int128 *v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  const __CFAllocator *v33;
  const CFDictionaryKeyCallBacks *v34;
  const CFDictionaryValueCallBacks *v35;
  const __CFAllocator *v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  char v41;
  char v42;
  const void *v43;
  char *valuePtr;
  int v46;
  void *values;
  CFStringRef v48;
  void *keys;
  const __CFString *v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  keys = 0;
  v50 = 0;
  values = 0;
  v48 = 0;
  switch(a1)
  {
    case 0:
      LODWORD(valuePtr) = 1;
      v46 = 0;
      if (qword_1EDBB4CB8 != -1)
        dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
      if (dword_1EDBB4CC4 >= 8)
        goto LABEL_17;
      goto LABEL_18;
    case 1:
      if (a3 <= 41)
      {
        if (a3 != 1)
        {
          if (a3 == 20)
          {
            dword_1EF138650 = 0;
            v7 = xmmword_1B69200CB;
            v8 = unk_1B69200DB;
            xmmword_1EF138610 = xmmword_1B69200CB;
            unk_1EF138620 = unk_1B69200DB;
            v9 = xmmword_1B69200EB;
            v10 = unk_1B69200FB;
            xmmword_1EF138630 = xmmword_1B69200EB;
            unk_1EF138640 = unk_1B69200FB;
            v11 = *(_OWORD *)"FLS;SW:1;";
            v12 = unk_1B69200BB;
            xmmword_1EF1385F0 = *(_OWORD *)"FLS;SW:1;";
            unk_1EF138600 = unk_1B69200BB;
            if (qword_1EDBB4CB8 != -1)
            {
              dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
              v12 = unk_1B69200BB;
              v11 = *(_OWORD *)"FLS;SW:1;";
              v10 = unk_1B69200FB;
              v9 = xmmword_1B69200EB;
              v8 = unk_1B69200DB;
              v7 = xmmword_1B69200CB;
            }
            if (dword_1EDBB4CC4 == 255)
            {
              dword_1EF1386B4 = 0;
              xmmword_1EF138674 = v7;
              unk_1EF138684 = v8;
              xmmword_1EF138694 = v9;
              unk_1EF1386A4 = v10;
              xmmword_1EF138654 = v11;
              unk_1EF138664 = v12;
              goto LABEL_47;
            }
            dword_1EF1386B4 = 0;
            v16 = (__int128 *)"FLS;VRAE:0;SW:1;";
            goto LABEL_46;
          }
LABEL_35:
          dword_1EF138650 = 0;
          xmmword_1EF138610 = xmmword_1B691FF9C;
          unk_1EF138620 = unk_1B691FFAC;
          xmmword_1EF138630 = xmmword_1B691FFBC;
          unk_1EF138640 = unk_1B691FFCC;
          xmmword_1EF1385F0 = *(_OWORD *)"FLS;";
          unk_1EF138600 = unk_1B691FF8C;
          dword_1EF1386B4 = 0;
          xmmword_1EF138654 = *(_OWORD *)"FLS;";
          unk_1EF138664 = unk_1B691FF8C;
          xmmword_1EF138674 = xmmword_1B691FF9C;
          unk_1EF138684 = unk_1B691FFAC;
          xmmword_1EF138694 = xmmword_1B691FFBC;
          unk_1EF1386A4 = unk_1B691FFCC;
          goto LABEL_47;
        }
        dword_1EF138650 = 0;
        xmmword_1EF138630 = xmmword_1B692021A;
        unk_1EF138640 = unk_1B692022A;
        strcpy((char *)&xmmword_1EF1385F0, "FLS;RVRA1:1;AS:2;MS:-1;LTR;CABAC;CR:3;LF:-1;PR;CH1:4;CH:4;FA:5;");
        dword_1EF1386B4 = 0;
        v17 = (__int128 *)"FLS;RVRA1:0;PR;LF:-1;CR:1;CF:2;CH1:3;FA:4;";
LABEL_34:
        v22 = v17[1];
        xmmword_1EF138654 = *v17;
        unk_1EF138664 = v22;
        v23 = v17[2];
        v24 = v17[3];
        v25 = v17[5];
        xmmword_1EF138694 = v17[4];
        unk_1EF1386A4 = v25;
        xmmword_1EF138674 = v23;
        unk_1EF138684 = v24;
        goto LABEL_47;
      }
      if (a3 == 42)
      {
        dword_1EF138650 = 0;
        unk_1EF138622 = 0;
        unk_1EF138624 = 0;
        unk_1EF138628 = 0;
        xmmword_1EF138630 = xmmword_1B6920150;
        unk_1EF138640 = unk_1B6920160;
        strcpy((char *)&xmmword_1EF1385F0, "FLS;MS:-1;LF:-1;LTR;CABAC;POS:0;EOD:1;HTS:2;RR:3;");
        dword_1EF1386B4 = 0;
        v17 = (__int128 *)"FLS;LF:-1;POS:5;EOD:1;HTS:2;RR:3;";
        goto LABEL_34;
      }
      if (a3 != 43)
        goto LABEL_35;
      dword_1EF1386B4 = 0;
      v16 = (__int128 *)"FLS;RVRA1:0;";
LABEL_46:
      v37 = v16[3];
      xmmword_1EF138674 = v16[2];
      unk_1EF138684 = v37;
      v38 = v16[5];
      xmmword_1EF138694 = v16[4];
      unk_1EF1386A4 = v38;
      v39 = v16[1];
      xmmword_1EF138654 = *v16;
      unk_1EF138664 = v39;
LABEL_47:
      keys = CFSTR("VCPCodec_AVC1");
      v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      values = (void *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)&xmmword_1EF1385F0, 0);
      v50 = CFSTR("VCPCodec_LRP");
      v14 = CFStringCreateWithCString(v13, (const char *)&xmmword_1EF138654, 0);
LABEL_48:
      v48 = v14;
      v34 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
      v35 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
      v36 = v13;
LABEL_49:
      v5 = CFDictionaryCreate(v36, (const void **)&keys, (const void **)&values, 2, v34, v35);
LABEL_50:
      if (v5)
        v6 = 0;
      else
        v6 = 4294954392;
LABEL_53:
      v40 = 0;
      *a2 = v5;
      v41 = 1;
      do
      {
        v42 = v41;
        v43 = *(&values + v40);
        if (v43)
          CFRelease(v43);
        v41 = 0;
        v40 = 1;
      }
      while ((v42 & 1) != 0);
      return v6;
    case 2:
      LODWORD(valuePtr) = 1;
      v46 = 0;
      if (qword_1EDBB4CB8 != -1)
        dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
      if (dword_1EDBB4CC4 >= 9)
LABEL_17:
        v46 = 1;
LABEL_18:
      keys = CFSTR("VCPCodec_AVC1");
      v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
      v50 = CFSTR("VCPCodec_LRP");
      v14 = (const __CFString *)CFNumberCreate(v13, kCFNumberIntType, &v46);
      goto LABEL_48;
    case 3:
      valuePtr = 0;
      sub_1B67EBE44(&valuePtr, a3);
      v5 = sub_1B685BF8C(valuePtr);
      goto LABEL_50;
    case 4:
      strncpy(byte_1EF13832E, "FLS2;", 0xFAuLL);
      strncpy(byte_1EF138228, "FLS2;", 0xFAuLL);
      if (a3 > 41)
      {
        if (a3 == 42)
        {
          dword_1EF1385DA = 0;
          xmmword_1EF13859A = xmmword_1B6921441;
          unk_1EF1385AA = unk_1B6921451;
          xmmword_1EF1385BA = xmmword_1B6921461;
          unk_1EF1385CA = unk_1B6921471;
          strcpy((char *)&xmmword_1EF13857A, "POS;EOD;HTS;RR;");
          unk_1EF13858A = unk_1B6921431;
          dword_1EF13856E = 0;
          strcpy((char *)&xmmword_1EF13850E, "POS;EOD;HTS;RR;");
          unk_1EF13851E = unk_1B6921431;
          xmmword_1EF13852E = xmmword_1B6921441;
          unk_1EF13853E = unk_1B6921451;
          xmmword_1EF13854E = xmmword_1B6921461;
          unk_1EF13855E = unk_1B6921471;
          goto LABEL_38;
        }
        if (a3 == 43)
        {
          dword_1EF1385DA = 0;
          xmmword_1EF13859A = xmmword_1B6921312;
          unk_1EF1385AA = unk_1B6921322;
          xmmword_1EF1385BA = xmmword_1B6921332;
          unk_1EF1385CA = unk_1B6921342;
          xmmword_1EF13857A = *(_OWORD *)"RVRA1;";
          unk_1EF13858A = unk_1B6921302;
          goto LABEL_38;
        }
      }
      else
      {
        if (a3 == 1)
        {
          dword_1EF1385DA = 0;
          xmmword_1EF13859A = xmmword_1B69214A6;
          unk_1EF1385AA = unk_1B69214B6;
          xmmword_1EF1385BA = xmmword_1B69214C6;
          unk_1EF1385CA = unk_1B69214D6;
          strcpy((char *)&xmmword_1EF13857A, "RVRA1;CH1;CR;CF;FA;");
          unk_1EF13858E = unk_1B692149A;
          unk_1EF138592 = unk_1B692149E;
          dword_1EF13856E = 0;
          v15 = (__int128 *)"RVRA1;CH1;CR;FA;";
          goto LABEL_32;
        }
        if (a3 == 20)
        {
          dword_1EF1385DA = 0;
          xmmword_1EF13859A = xmmword_1B6921377;
          unk_1EF1385AA = unk_1B6921387;
          xmmword_1EF1385BA = xmmword_1B6921397;
          unk_1EF1385CA = unk_1B69213A7;
          xmmword_1EF13857A = *(_OWORD *)"VRAE;SW;";
          unk_1EF13858A = unk_1B6921367;
          dword_1EF13856E = 0;
          v15 = (__int128 *)"SW;";
LABEL_32:
          v18 = v15[1];
          xmmword_1EF13850E = *v15;
          unk_1EF13851E = v18;
          v19 = v15[2];
          v20 = v15[3];
          v21 = v15[5];
          xmmword_1EF13854E = v15[4];
          unk_1EF13855E = v21;
          xmmword_1EF13852E = v19;
          unk_1EF13853E = v20;
          goto LABEL_38;
        }
      }
      dword_1EF1385DA = 0;
      xmmword_1EF1385BA = 0u;
      unk_1EF1385CA = 0u;
      xmmword_1EF13859A = 0u;
      unk_1EF1385AA = 0u;
      xmmword_1EF13857A = 0u;
      unk_1EF13858A = 0u;
      xmmword_1EF13850E = 0u;
      unk_1EF13851E = 0u;
      xmmword_1EF13852E = 0u;
      unk_1EF13853E = 0u;
      xmmword_1EF13854E = 0u;
      unk_1EF13855E = 0u;
      dword_1EF13856E = 0;
LABEL_38:
      v26 = strcat(byte_1EF13832E, (const char *)&xmmword_1EF13857A);
      *(_WORD *)&byte_1EF13832E[strlen(v26)] = 124;
      v27 = strcat(byte_1EF138228, (const char *)&xmmword_1EF13850E);
      *(_WORD *)&byte_1EF138228[strlen(v27)] = 124;
      if (!sub_1B67EE434())
        goto LABEL_43;
      if (qword_1EDBB4CB8 != -1)
        dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
      if (dword_1EDBB4CC4 >= 13)
      {
        dword_1EF138502 = 0;
        unk_1EF1384D4 = 0;
        unk_1EF1384D6 = 0;
        unk_1EF1384DA = unk_1B6921652;
        xmmword_1EF1384E2 = xmmword_1B692165A;
        unk_1EF1384F2 = unk_1B692166A;
        strcpy((char *)&xmmword_1EF1384A2, "RVRA1;VRAE;CH1;CR;CF;FA;POS;HTS;EOD;RR;QP;SW;MLS;");
        dword_1EF138496 = 0;
        v28 = (__int128 *)"RVRA1;CH1;CR;FA;POS;HTS;EOD;RR;QP;SW;MLS;";
      }
      else
      {
LABEL_43:
        dword_1EF138502 = 0;
        HIWORD(xmmword_1EF1384C2) = 0;
        unk_1EF1384D2 = unk_1B6921580;
        xmmword_1EF1384E2 = xmmword_1B6921590;
        unk_1EF1384F2 = unk_1B69215A0;
        strcpy((char *)&xmmword_1EF1384A2, "RVRA1;VRAE;CH1;CR;CF;FA;POS;HTS;EOD;RR;QP;SW;");
        dword_1EF138496 = 0;
        v28 = (__int128 *)"RVRA1;CH1;CR;FA;POS;HTS;EOD;RR;QP;SW;;";
      }
      v29 = v28[1];
      xmmword_1EF138436 = *v28;
      unk_1EF138446 = v29;
      v30 = v28[2];
      v31 = v28[3];
      v32 = v28[5];
      xmmword_1EF138476 = v28[4];
      unk_1EF138486 = v32;
      xmmword_1EF138456 = v30;
      unk_1EF138466 = v31;
      strcat(byte_1EF13832E, (const char *)&xmmword_1EF1384A2);
      strcat(byte_1EF138228, (const char *)&xmmword_1EF138436);
      keys = CFSTR("VCPCodec_AVC1");
      v33 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      values = (void *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], byte_1EF138228, 0);
      v50 = CFSTR("VCPCodec_LRP");
      v48 = CFStringCreateWithCString(v33, byte_1EF13832E, 0);
      v34 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
      v35 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
      v36 = v33;
      goto LABEL_49;
    default:
      v5 = 0;
      v6 = 4294954396;
      goto LABEL_53;
  }
}

uint64_t VCPCodecGetProperty(int a1, CFDictionaryRef *a2)
{
  return VCPCodecCopyProperties(a1, a2, 1);
}

uint64_t VCPCreateUserDataPrefixSEINALU(int a1, char *a2, size_t a3, char *a4, unint64_t *a5)
{
  int v5;
  int v6;

  v5 = 1;
  if (a1 > 1718908519)
  {
    if (a1 == 1718908520)
      return sub_1B6883114(a2, a3, a4, *a5, a5, v5);
    v6 = 1752589105;
  }
  else
  {
    if (a1 == 1684632424)
      return sub_1B6883114(a2, a3, a4, *a5, a5, v5);
    v6 = 1685481521;
  }
  if (a1 != v6)
    v5 = 0;
  return sub_1B6883114(a2, a3, a4, *a5, a5, v5);
}

uint64_t sub_1B67848D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, __int128 a17, __int128 a18, __int128 a19, __int128 a20,__int128 a21,__int128 a22,__int128 a23,__int128 a24,__int128 a25,__int128 a26,__int128 a27,__int128 a28,__int128 a29,__int128 a30,__int128 a31,__int128 a32,__int128 a33,__int128 a34,__int128 a35,__int128 a36,__int128 a37,__int128 a38,uint64_t a39,uint64_t a40,char a41,__int16 a42,char a43,int a44,char a45,__int128 a46,__int128 a47,__int128 a48,__int128 a49,__int128 a50)
{
  uint64_t v50;
  _QWORD *v51;
  _QWORD *v52;
  unint64_t v53;
  unint64_t v54;
  unsigned __int8 *v55;
  __int128 v56;
  uint64_t result;
  uint8_t buf[8];
  uint64_t vars8;

  v50 = MEMORY[0x1E0C80A78](a1, a2, a3, a4, a5, a6);
  v52 = v51;
  v54 = v53;
  v55 = (unsigned __int8 *)v50;
  STACK[0x13638] = *MEMORY[0x1E0C80C00];
  a16 = 0;
  a17 = 0u;
  a18 = 0u;
  a19 = 0u;
  a20 = 0u;
  a21 = 0u;
  a22 = 0u;
  a23 = 0u;
  a24 = 0u;
  a25 = 0u;
  LOWORD(a26) = 0;
  *(_QWORD *)&v56 = -1;
  *((_QWORD *)&v56 + 1) = -1;
  *(__int128 *)((char *)&a26 + 2) = v56;
  *(__int128 *)((char *)&a27 + 2) = v56;
  *(__int128 *)((char *)&a28 + 2) = v56;
  *(__int128 *)((char *)&a29 + 2) = v56;
  a39 = 0;
  *(__int128 *)((char *)&a33 + 2) = 0u;
  *(__int128 *)((char *)&a34 + 2) = 0u;
  *(__int128 *)((char *)&a35 + 2) = 0u;
  *(__int128 *)((char *)&a36 + 2) = 0u;
  *(__int128 *)((char *)&a37 + 2) = 0u;
  *(__int128 *)((char *)&a30 + 2) = 0u;
  *(__int128 *)((char *)&a31 + 2) = 0u;
  *(__int128 *)((char *)&a32 + 2) = 0u;
  BYTE2(a38) = 0;
  WORD6(a38) = 0;
  *(_QWORD *)((char *)&a38 + 4) = 0;
  *(_QWORD *)buf = &off_1E6A159D8;
  vars8 = 2;
  off_1EF137C48 = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_1B67AD840;
  *(_OWORD *)&STACK[0x2B1] = 0uLL;
  *(_OWORD *)&STACK[0x2A8] = 0uLL;
  *(_OWORD *)&STACK[0x298] = 0uLL;
  *(_OWORD *)&STACK[0x288] = 0uLL;
  *(_OWORD *)&STACK[0x278] = 0uLL;
  *(_OWORD *)&STACK[0x268] = 0uLL;
  a50 = 0uLL;
  a49 = 0uLL;
  a48 = 0uLL;
  a47 = 0uLL;
  a46 = 0uLL;
  *(_OWORD *)&STACK[0x2C2] = 0uLL;
  *(_OWORD *)&STACK[0x2D2] = 0uLL;
  *(_OWORD *)&STACK[0x2E2] = 0uLL;
  *(_OWORD *)&STACK[0x2F2] = 0uLL;
  *(_OWORD *)&STACK[0x2FE] = 0uLL;
  STACK[0x314] = 0;
  LODWORD(STACK[0x3EC]) = 0;
  *(_OWORD *)&STACK[0x448] = 0uLL;
  *(_OWORD *)&STACK[0x430] = 0uLL;
  *(_OWORD *)&STACK[0x600] = 0uLL;
  *(_OWORD *)&STACK[0x750] = 0uLL;
  *(_OWORD *)&STACK[0x760] = 0uLL;
  STACK[0x770] = 0;
  LODWORD(STACK[0x930]) = 8;
  LOBYTE(STACK[0x934]) = 0;
  *(_OWORD *)&STACK[0xFB8] = 0uLL;
  STACK[0xFC8] = 0;
  bzero(&STACK[0xFD8], 0x210uLL);
  *(_OWORD *)&STACK[0x1258] = 0u;
  *(_OWORD *)&STACK[0x1248] = 0u;
  *(_OWORD *)&STACK[0xF88] = 0u;
  *(_OWORD *)&STACK[0xF98] = 0u;
  STACK[0xFA8] = 0;
  LOBYTE(STACK[0x473]) = 1;
  LOWORD(a40) = 1;
  BYTE2(a40) = 0;
  HIDWORD(a40) = 0;
  a41 = 0;
  a42 = 258;
  a43 = 0;
  a44 = 0;
  a45 = 0;
  LODWORD(STACK[0x310]) = 0;
  STACK[0x41E] = 0;
  *(_OWORD *)&STACK[0x3F0] = 0u;
  *(_OWORD *)&STACK[0x400] = 0u;
  *(_OWORD *)&STACK[0x410] = 0u;
  LOBYTE(STACK[0x426]) = 1;
  LODWORD(STACK[0x428]) = 0;
  LOBYTE(STACK[0x42C]) = 0;
  LOWORD(STACK[0x440]) = 0;
  STACK[0x788] = 0;
  *(_OWORD *)&STACK[0x13348] = 0u;
  LOBYTE(STACK[0x13378]) = 0;
  *(_OWORD *)&STACK[0x13364] = 0u;
  *(_OWORD *)&STACK[0x13380] = 0u;
  *(_OWORD *)&STACK[0x13390] = 0u;
  *(_OWORD *)&STACK[0x133A0] = 0u;
  STACK[0x1351C] = 0;
  LODWORD(STACK[0x13524]) = 0;
  *(_OWORD *)&STACK[0x1350C] = 0u;
  sub_1B67B6B1C((uint64_t)buf, v55, v54);
  sub_1B67E8CB8(&a40);
  result = 0;
  if (v52)
    *v52 = 0;
  return result;
}

void sub_1B6785630(_Unwind_Exception *a1)
{
  sub_1B6770598((const void **)&STACK[0x200]);
  _Unwind_Resume(a1);
}

void sub_1B678567C()
{
  _QWORD *v0;

  if (!*v0)
    JUMPOUT(0x1B678566CLL);
  JUMPOUT(0x1B6785668);
}

uint64_t VCPReadHEVCSliceHeader(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, __int128 a17, __int128 a18, __int128 a19, __int128 a20,__int128 a21,__int128 a22,__int128 a23,__int128 a24,__int128 a25,__int128 a26,__int128 a27,__int128 a28,__int128 a29,__int128 a30,__int128 a31,__int128 a32,__int128 a33,__int128 a34,__int128 a35,__int128 a36,__int128 a37,__int128 a38,uint64_t a39,uint64_t a40,char a41,__int16 a42,char a43,int a44,char a45,__int128 a46,__int128 a47,__int128 a48,__int128 a49,__int128 a50)
{
  unsigned __int8 v54;
  __int16 *v56;
  __int128 v57;
  __int16 *v58;

  v54 = atomic_load((unsigned __int8 *)&qword_1EF138C88);
  if ((v54 & 1) == 0 && __cxa_guard_acquire(&qword_1EF138C88))
  {
    v56 = word_1EF138840;
    *(_QWORD *)&v57 = -1;
    *((_QWORD *)&v57 + 1) = -1;
    do
    {
      *v56 = 0;
      *(_OWORD *)(v56 + 2) = 0uLL;
      *(_OWORD *)(v56 + 10) = 0uLL;
      *(_OWORD *)(v56 + 18) = 0uLL;
      *(_OWORD *)(v56 + 26) = 0uLL;
      *(_OWORD *)(v56 + 34) = 0uLL;
      *(_OWORD *)(v56 + 42) = 0uLL;
      *(_OWORD *)(v56 + 50) = 0uLL;
      *(_OWORD *)(v56 + 58) = 0uLL;
      *(_OWORD *)(v56 + 66) = 0uLL;
      v56[74] = 0;
      *(_OWORD *)(v56 + 75) = v57;
      *(_OWORD *)(v56 + 83) = v57;
      *(_OWORD *)(v56 + 91) = v57;
      *(_OWORD *)(v56 + 99) = v57;
      *(_QWORD *)(v56 + 178) = 0;
      *((_BYTE *)v56 + 342) = 0;
      *(_OWORD *)(v56 + 123) = 0uLL;
      *(_OWORD *)(v56 + 115) = 0uLL;
      *(_OWORD *)(v56 + 107) = 0uLL;
      v58 = v56 + 107;
      *(_OWORD *)(v56 + 155) = 0uLL;
      *(_OWORD *)(v56 + 163) = 0uLL;
      *(_OWORD *)(v56 + 139) = 0uLL;
      *(_OWORD *)(v56 + 147) = 0uLL;
      v56[176] = 0;
      *((_QWORD *)v56 + 43) = 0;
      v56 += 182;
      *((_OWORD *)v58 + 3) = 0uLL;
    }
    while (v56 != (__int16 *)&unk_1EF138C84);
    __cxa_guard_release(&qword_1EF138C88);
  }
  if (qword_1EF138C90 != -1)
    dispatch_once(&qword_1EF138C90, &unk_1E6A15FD0);
  return sub_1B67848D4(a2, a3, a4, (uint64_t)&word_1EF138840[182 * a5], 0, 0, a4 != 0, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34,
           a35,
           a36,
           a37,
           a38,
           a39,
           a40,
           a41,
           a42,
           a43,
           a44,
           a45,
           a46,
           a47,
           a48,
           a49,
           a50);
}

#error "1B67858C4: call analysis failed (funcsize=100)"

uint64_t VCPReadCodecConfigParams(int a1, const void *a2, size_t a3, CFDictionaryRef *a4, uint64_t a5, uint64_t a6)
{
  int v7;
  const __CFAllocator *v8;
  CFDictionaryRef v9;
  uint64_t v10;
  char v11;
  char v12;
  const void *v13;
  _DWORD v15[4];
  uint64_t v16;
  void *values[2];
  void *keys[3];

  keys[2] = *(void **)MEMORY[0x1E0C80C00];
  if (a1 > 1718908519)
  {
    if (a1 == 1752589105)
      goto LABEL_7;
    v7 = 1718908520;
  }
  else
  {
    if (a1 == 1684632424)
      goto LABEL_7;
    v7 = 1685481521;
  }
  if (a1 != v7)
  {
    sub_1B6892768((uint64_t)a2, a3, (uint64_t)v15, 0, a5, a6);
    goto LABEL_8;
  }
LABEL_7:
  sub_1B68921D4(a2, a3, v15, 0);
LABEL_8:
  keys[0] = CFSTR("Width");
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &v16);
  keys[1] = CFSTR("Height");
  values[1] = CFNumberCreate(v8, kCFNumberIntType, (char *)&v16 + 4);
  v9 = CFDictionaryCreate(v8, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v10 = 0;
  *a4 = v9;
  v11 = 1;
  do
  {
    v12 = v11;
    v13 = values[v10];
    if (v13)
      CFRelease(v13);
    v11 = 0;
    v10 = 1;
  }
  while ((v12 & 1) != 0);
  return 0;
}

uint64_t VCPParseParameterSetsAndCreateConfigurationRecord(int a1, uint64_t a2, unint64_t *a3, void *a4, size_t *a5)
{
  int v7;
  const opaqueCMFormatDescription *v8;
  const opaqueCMFormatDescription *v9;
  const opaqueCMFormatDescription *v10;
  int v11;
  int v12;
  uint8_t *v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  uint8_t *v17;
  uint64_t v18;
  const opaqueCMFormatDescription *v19;
  int v20;
  uint8_t *v21;
  const opaqueCMFormatDescription *v22;
  uint8_t *v23;
  const opaqueCMFormatDescription *v24;
  int v25;
  uint64_t v26;
  BOOL v27;
  size_t v29;
  CMFormatDescriptionRef *v30;
  int v31;
  int v32;
  uint8_t *v33;
  uint64_t v34;
  unint64_t v35;
  size_t v36;
  uint8_t *v37;
  int v38;
  CMFormatDescriptionRef *v39;
  uint64_t v40;
  size_t v41;
  int v42;
  BOOL v43;
  const __CFDictionary *Extension;
  const __CFData *Value;
  const __CFData *v46;
  unint64_t v47;
  CFIndex Length;
  const UInt8 *BytePtr;
  const opaqueCMFormatDescription *v50;
  const opaqueCMFormatDescription *v51;
  CMFormatDescriptionRef formatDescriptionOut;
  size_t parameterSetSizes;
  CMFormatDescriptionRef *p_formatDescriptionOut;
  const opaqueCMFormatDescription **v55;
  uint64_t v56;
  uint64_t v57;
  uint8_t *parameterSetPointers;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  if (a1 <= 1718908519)
  {
    if (a1 != 1684632424)
    {
      v7 = 1685481521;
      goto LABEL_6;
    }
LABEL_7:
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    while (v15 < *a3)
    {
      v18 = a2 + v15;
      v19 = (const opaqueCMFormatDescription *)bswap32(*(_DWORD *)(a2 + v15));
      v20 = (*(unsigned __int8 *)(a2 + v15 + 4) >> 1) & 0x3F;
      if (v20 == 34)
      {
        ++v12;
        if (!v14)
        {
          v10 = v19;
          v14 = v18 + 4;
        }
      }
      else
      {
        v21 = (uint8_t *)(v18 + 4);
        if (v13)
          v22 = v9;
        else
          v22 = v19;
        if (v13)
          v23 = v13;
        else
          v23 = v21;
        if (v17)
          v24 = v8;
        else
          v24 = v19;
        if (v17)
          v21 = v17;
        if (v20 == 32)
        {
          v25 = v16 + 1;
        }
        else
        {
          v24 = v8;
          v25 = v16;
        }
        if (v20 != 32)
          v21 = v17;
        if (v20 == 33)
          v9 = v22;
        else
          v8 = v24;
        if (v20 == 33)
        {
          ++v11;
          v13 = v23;
        }
        else
        {
          v16 = v25;
        }
        if (v20 != 33)
          v17 = v21;
      }
      v15 += ((_DWORD)v19 + 4);
      if (v16)
      {
        if (v11 && v12)
          break;
      }
    }
    v51 = v10;
    formatDescriptionOut = v9;
    v50 = v8;
    v26 = (_QWORD)v9 * (_QWORD)v8 * (_QWORD)v10;
    if (v11 * v11 * v12)
      v27 = v26 == 0;
    else
      v27 = 1;
    if (!v27)
    {
      *a3 = v15;
      parameterSetPointers = v17;
      v59 = (uint64_t)v13;
      v61 = 0;
      v62 = 0;
      v60 = v14;
      parameterSetSizes = (size_t)&v50;
      p_formatDescriptionOut = &formatDescriptionOut;
      v56 = 0;
      v57 = 0;
      v55 = &v51;
      return sub_1B68910E4(&parameterSetPointers, (unint64_t **)&parameterSetSizes, byte_1B69202A4, a4, a5);
    }
    return 4294954394;
  }
  if (a1 == 1718908520)
    goto LABEL_7;
  v7 = 1752589105;
LABEL_6:
  if (a1 == v7)
    goto LABEL_7;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  while (v35 < *a3)
  {
    v36 = bswap32(*(_DWORD *)(a2 + v35));
    v37 = (uint8_t *)(a2 + v35 + 4);
    v38 = *v37 & 0x1F;
    if (v34)
      v39 = v30;
    else
      v39 = (CMFormatDescriptionRef *)v36;
    if (v34)
      v40 = v34;
    else
      v40 = a2 + v35 + 4;
    if (v33)
      v41 = v29;
    else
      v41 = v36;
    if (v33)
      v37 = v33;
    if (v38 == 7)
    {
      v42 = v31 + 1;
    }
    else
    {
      v41 = v29;
      v42 = v31;
    }
    if (v38 != 7)
      v37 = v33;
    if (v38 == 8)
      v30 = v39;
    else
      v29 = v41;
    if (v38 == 8)
      ++v32;
    else
      v31 = v42;
    if (v38 == 8)
      v34 = v40;
    else
      v33 = v37;
    v35 += (v36 + 4);
    if (v31)
    {
      if (v32)
        break;
    }
  }
  if (v32 * v31)
    v43 = (_QWORD)v30 * v29 == 0;
  else
    v43 = 1;
  if (v43)
    return 4294954394;
  *a3 = v35;
  parameterSetPointers = v33;
  v59 = v34;
  parameterSetSizes = v29;
  p_formatDescriptionOut = v30;
  formatDescriptionOut = 0;
  CMVideoFormatDescriptionCreateFromH264ParameterSets((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2uLL, (const uint8_t *const *)&parameterSetPointers, &parameterSetSizes, 4, &formatDescriptionOut);
  if (formatDescriptionOut)
  {
    Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(formatDescriptionOut, (CFStringRef)*MEMORY[0x1E0CA2240]);
    if (Extension)
    {
      Value = (const __CFData *)CFDictionaryGetValue(Extension, CFSTR("avcC"));
      if (Value)
      {
        v46 = Value;
        v47 = *a5;
        if (v47 >= CFDataGetLength(Value))
          Length = CFDataGetLength(v46);
        else
          Length = *a5;
        *a5 = Length;
        BytePtr = CFDataGetBytePtr(v46);
        memcpy(a4, BytePtr, *a5);
      }
    }
    CFRelease(formatDescriptionOut);
  }
  return 0;
}

uint64_t VCPParseConfigurationRecordAndCreateParameterSets(int a1, const void *a2, size_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t *v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  void *__dst[2];
  size_t v24;
  int64x2_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD v29[5];
  _QWORD v30[5];
  _QWORD v31[5];
  char v32;
  char v33;
  char v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v9 = 4294954394;
  if (a1 > 1718908519)
  {
    if (a1 != 1752589105)
    {
      v10 = 1718908520;
LABEL_6:
      if (a1 != v10)
        return v9;
    }
  }
  else if (a1 != 1684632424)
  {
    v10 = 1685481521;
    goto LABEL_6;
  }
  v11 = operator new[]();
  v31[0] = v11;
  v31[1] = v11 + a3;
  v31[3] = 0;
  v31[4] = 0;
  v31[2] = v11 + a3 + a3;
  v30[0] = a3;
  v30[1] = a3;
  v30[3] = 0;
  v30[4] = 0;
  v30[2] = a3;
  v29[0] = &v34;
  v29[1] = &v33;
  v29[3] = 0;
  v29[4] = 0;
  v29[2] = &v32;
  v27 = 0;
  v28 = 0;
  v25 = vdupq_n_s64(0x80uLL);
  v26 = 512;
  __dst[0] = 0;
  __dst[1] = 0;
  v24 = 0;
  if (sub_1B67C2364(__dst, a3, 0x10uLL))
  {
    v9 = 4294954392;
  }
  else
  {
    memcpy(__dst[0], a2, a3);
    v24 = a3;
    v9 = sub_1B67C9718((uint64_t)__dst, (uint64_t)v31, (uint64_t)v30, (uint64_t)v29, (uint64_t)&v25);
  }
  if (__dst[0])
    free(__dst[0]);
  if ((_DWORD)v9)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      LOWORD(__dst[0]) = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "LRPConfigurationRecordToParameterSets failed", (uint8_t *)__dst, 2u);
    }
  }
  else
  {
    v12 = 0;
    v13 = 0;
    do
    {
      v14 = v25.u64[v12];
      if (v14 >= 8)
      {
        v15 = 0;
        v16 = v31[v12];
        v17 = v14 >> 3;
        v18 = (uint64_t *)v29[v12];
        do
        {
          v20 = *v18++;
          v19 = v20;
          if (!v20)
            break;
          v21 = v13 + 4;
          if (v21 + (unint64_t)v19 > *a5)
          {
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
            {
              LOWORD(__dst[0]) = 0;
              _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "parameter sets buf overrun\n", (uint8_t *)__dst, 2u);
            }
            v9 = 4294954394;
            goto LABEL_26;
          }
          *(_DWORD *)(a4 + v13) = bswap32(v19);
          memcpy((void *)(a4 + v21), (const void *)(v16 + v15), v19);
          v13 = v19 + v21;
          v15 += v19;
          --v17;
        }
        while (v17);
      }
      ++v12;
    }
    while (v12 != 3);
    v9 = 0;
    *a5 = v13;
  }
LABEL_26:
  MEMORY[0x1BCC9811C](v11, 0x1000C8077774924);
  return v9;
}

void sub_1B67860E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9)
{
  if (a9)
    free(a9);
  _Unwind_Resume(exception_object);
}

uint64_t VCPCompressionSessionGetTypeID()
{
  pthread_once(&stru_1EF137C98, (void (*)(void))sub_1B6786128);
  return qword_1EF138C98;
}

uint64_t sub_1B6786128()
{
  uint64_t result;

  qword_1EF138CB8 = 0;
  unk_1EF138CC0 = "VCPCompressionSession";
  qword_1EF138CC8 = 0;
  unk_1EF138CD0 = 0;
  qword_1EF138CD8 = (uint64_t)sub_1B6786174;
  unk_1EF138CE0 = 0u;
  unk_1EF138CF0 = 0u;
  result = _CFRuntimeRegisterClass();
  qword_1EF138C98 = result;
  return result;
}

std::mutex *sub_1B6786174(std::mutex *result)
{
  std::mutex *v1;
  std::mutex *v2;

  if (result)
  {
    v1 = result;
    VCPCompressionSessionInvalidate((uint64_t)result);
    v2 = *(std::mutex **)&v1[33].__m_.__opaque[32];
    if (v2)
    {
      std::mutex::~mutex(v2);
      MEMORY[0x1BCC9814C]();
      *(_QWORD *)&v1[33].__m_.__opaque[32] = 0;
    }
    result = *(std::mutex **)&v1[36].__m_.__opaque[24];
    if (result)
    {
      std::mutex::~mutex(result);
      result = (std::mutex *)MEMORY[0x1BCC9814C]();
      *(_QWORD *)&v1[36].__m_.__opaque[24] = 0;
    }
  }
  return result;
}

void VCPCompressionSessionInvalidate(uint64_t a1)
{
  std::mutex *v2;
  int v3;
  int v4;
  int v5;
  const char *v6;
  int v7;
  NSObject *v8;
  const char *v9;
  uint32_t v10;
  int v11;
  int v12;
  int v13;
  const char *v14;
  int v15;
  void *v16;
  NSObject *v17;
  OpaqueVTCompressionSession *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t *v23;
  const void **v24;
  const void **v25;
  __CVBuffer *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  const void *v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  const char *v35;
  int v36;
  NSObject *v37;
  const char *v38;
  int v39;
  uint64_t v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  __int16 v45;
  const char *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      return;
    LOWORD(v39) = 0;
    v8 = MEMORY[0x1E0C81028];
    v9 = "VCPCompressionSessionInvalidate got NULL vcpSession\n";
    v10 = 2;
    goto LABEL_53;
  }
  v2 = *(std::mutex **)(a1 + 2152);
  if (!v2)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      return;
    v12 = *(_DWORD *)(a1 + 60);
    v11 = *(_DWORD *)(a1 + 64);
    v13 = *(_DWORD *)(a1 + 24);
    v14 = "H.264";
    if (v13 > 1718908519)
    {
      if (v13 == 1752589105)
        goto LABEL_51;
      v15 = 1718908520;
    }
    else
    {
      if (v13 == 1684632424)
        goto LABEL_51;
      v15 = 1685481521;
    }
    if (v13 != v15)
    {
LABEL_52:
      v39 = 134218754;
      v40 = a1;
      v41 = 1024;
      v42 = v12;
      v43 = 1024;
      v44 = v11;
      v45 = 2080;
      v46 = v14;
      v8 = MEMORY[0x1E0C81028];
      v9 = "VCPEnc %p (%dx%d, %s): VCPCompressionSessionInvalidate got NULL session mutex\n";
      v10 = 34;
LABEL_53:
      _os_log_impl(&dword_1B676B000, v8, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v39, v10);
      return;
    }
LABEL_51:
    v14 = "HEVC";
    goto LABEL_52;
  }
  std::mutex::lock(*(std::mutex **)(a1 + 2152));
  if (!*(_BYTE *)(a1 + 2160))
  {
    *(_BYTE *)(a1 + 2160) = 1;
    v16 = *(void **)(a1 + 2176);
    if (v16)
    {
      objc_msgSend(v16, "invalidate");
      CFRelease(*(CFTypeRef *)(a1 + 2176));
      *(_QWORD *)(a1 + 2176) = 0;
    }
    v17 = *(NSObject **)(a1 + 2168);
    if (v17)
    {
      dispatch_semaphore_wait(v17, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(*(dispatch_object_t *)(a1 + 2168));
      *(_QWORD *)(a1 + 2168) = 0;
    }
    v18 = *(OpaqueVTCompressionSession **)(a1 + 16);
    if (v18)
    {
      VTCompressionSessionInvalidate(v18);
      CFRelease(*(CFTypeRef *)(a1 + 16));
      *(_QWORD *)(a1 + 16) = 0;
    }
    v19 = *(uint64_t **)(a1 + 2184);
    if (v19)
    {
      std::mutex::~mutex((std::mutex *)(v19 + 26));
      sub_1B67866A8((_QWORD *)v19[24]);
      sub_1B67867B4((uint64_t)(v19 + 11));
      sub_1B67867B4((uint64_t)(v19 + 5));
      if (v19[2])
      {
        v20 = *v19;
        v21 = (uint64_t *)v19[1];
        v22 = *v21;
        *(_QWORD *)(v22 + 8) = *(_QWORD *)(*v19 + 8);
        **(_QWORD **)(v20 + 8) = v22;
        v19[2] = 0;
        if (v21 != v19)
        {
          do
          {
            v23 = (uint64_t *)v21[1];
            sub_1B6772C88((uint64_t)(v21 + 2));
            operator delete(v21);
            v21 = v23;
          }
          while (v23 != v19);
        }
      }
      MEMORY[0x1BCC9814C](v19, 0x10A0C403C4C3B74);
      *(_QWORD *)(a1 + 2184) = 0;
    }
    v24 = *(const void ***)(a1 + 96);
    if (v24)
    {
      v25 = sub_1B6777A90(v24);
      MEMORY[0x1BCC9814C](v25, 0xC0C40B8AA526DLL);
      *(_QWORD *)(a1 + 96) = 0;
    }
    v26 = *(__CVBuffer **)(a1 + 112);
    if (v26)
    {
      CVPixelBufferRelease(v26);
      *(_QWORD *)(a1 + 112) = 0;
    }
    v27 = *(_QWORD *)(a1 + 2192);
    if (v27)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v27 + 256))(v27);
      *(_QWORD *)(a1 + 2192) = 0;
    }
    v28 = *(void **)(a1 + 120);
    if (v28)
    {
      free(v28);
      *(_QWORD *)(a1 + 120) = 0;
    }
    v29 = *(_QWORD *)(a1 + 2312);
    if (v29)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v29 + 8))(v29);
      *(_QWORD *)(a1 + 2312) = 0;
    }
    v30 = *(const void **)(a1 + 2320);
    if (v30)
    {
      CFRelease(v30);
      *(_QWORD *)(a1 + 2320) = 0;
    }
    v31 = *(_QWORD *)(a1 + 136);
    if (v31)
    {
      MEMORY[0x1BCC9814C](v31, 0x1060C405A861112);
      *(_QWORD *)(a1 + 136) = 0;
    }
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      goto LABEL_60;
    v33 = *(_DWORD *)(a1 + 60);
    v32 = *(_DWORD *)(a1 + 64);
    v34 = *(_DWORD *)(a1 + 24);
    v35 = "H.264";
    if (v34 > 1718908519)
    {
      if (v34 == 1752589105)
        goto LABEL_57;
      v36 = 1718908520;
    }
    else
    {
      if (v34 == 1684632424)
        goto LABEL_57;
      v36 = 1685481521;
    }
    if (v34 != v36)
    {
LABEL_58:
      v39 = 134218754;
      v40 = a1;
      v41 = 1024;
      v42 = v33;
      v43 = 1024;
      v44 = v32;
      v45 = 2080;
      v46 = v35;
      v37 = MEMORY[0x1E0C81028];
      v38 = "VCPEnc %p (%dx%d, %s): Video compression session invalidated\n";
      goto LABEL_59;
    }
LABEL_57:
    v35 = "HEVC";
    goto LABEL_58;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(_DWORD *)(a1 + 60);
    v3 = *(_DWORD *)(a1 + 64);
    v5 = *(_DWORD *)(a1 + 24);
    v6 = "H.264";
    if (v5 > 1718908519)
    {
      if (v5 == 1752589105)
        goto LABEL_46;
      v7 = 1718908520;
    }
    else
    {
      if (v5 == 1684632424)
        goto LABEL_46;
      v7 = 1685481521;
    }
    if (v5 != v7)
    {
LABEL_47:
      v39 = 134218754;
      v40 = a1;
      v41 = 1024;
      v42 = v4;
      v43 = 1024;
      v44 = v3;
      v45 = 2080;
      v46 = v6;
      v37 = MEMORY[0x1E0C81028];
      v38 = "VCPEnc %p (%dx%d, %s): Video compression session invalidated already\n";
LABEL_59:
      _os_log_impl(&dword_1B676B000, v37, OS_LOG_TYPE_DEFAULT, v38, (uint8_t *)&v39, 0x22u);
      goto LABEL_60;
    }
LABEL_46:
    v6 = "HEVC";
    goto LABEL_47;
  }
LABEL_60:
  std::mutex::unlock(v2);
}

void sub_1B6786694(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B67866A8(_QWORD *a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;

  if (a1)
  {
    sub_1B67866A8(*a1);
    sub_1B67866A8(a1[1]);
    if (a1[14])
    {
      v2 = a1[12];
      v3 = (uint64_t *)a1[13];
      v4 = *v3;
      *(_QWORD *)(v4 + 8) = *(_QWORD *)(v2 + 8);
      **(_QWORD **)(v2 + 8) = v4;
      a1[14] = 0;
      if (v3 != a1 + 12)
      {
        do
        {
          v5 = (uint64_t *)v3[1];
          v6 = (std::__shared_weak_count *)v3[3];
          if (v6)
          {
            p_shared_owners = (unint64_t *)&v6->__shared_owners_;
            do
              v8 = __ldaxr(p_shared_owners);
            while (__stlxr(v8 - 1, p_shared_owners));
            if (!v8)
            {
              ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
              std::__shared_weak_count::__release_weak(v6);
            }
          }
          operator delete(v3);
          v3 = v5;
        }
        while (v5 != a1 + 12);
      }
    }
    v9 = (std::__shared_weak_count *)a1[10];
    if (v9)
    {
      v10 = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    sub_1B677A398(a1 + 5);
    operator delete(a1);
  }
}

uint64_t sub_1B67867B4(uint64_t a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
  *(_QWORD *)(a1 + 40) = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = *(void ***)(a1 + 16);
      v2 = (void **)(*(_QWORD *)(a1 + 8) + 8);
      *(_QWORD *)(a1 + 8) = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 512;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    v6 = 1024;
LABEL_7:
    *(_QWORD *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    v9 = *(_QWORD *)(a1 + 8);
    v8 = *(_QWORD *)(a1 + 16);
    if (v8 != v9)
      *(_QWORD *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t sub_1B6786878(CMSampleBufferRef *a1, const void *a2, size_t a3, size_t *a4)
{
  size_t v8;
  size_t v9;
  size_t v10;
  size_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint8_t *v22;
  int v23;
  _BYTE *v24;
  size_t v25;
  unsigned __int8 *v26;
  unsigned int v27;
  OpaqueCMBlockBuffer *DataBuffer;
  size_t DataLength;
  NSObject *v30;
  const char *v31;
  uint8_t buf[16];
  CMBlockBufferRef v34[2];

  v34[1] = *(CMBlockBufferRef *)MEMORY[0x1E0C80C00];
  v34[0] = 0;
  *a4 = 0;
  v8 = a3 + 16;
  v9 = (a3 + 16) / 0xFF;
  v10 = a3 + 16 + v9;
  v11 = v10 + 5;
  v12 = operator new[]();
  *(_BYTE *)(v12 + 2) = 5;
  *(_WORD *)v12 = 334;
  v13 = memset((void *)(v12 + 3), 255, v9);
  v19 = v12 + 3 + v8 / 0xFF;
  *(_BYTE *)v19 = v10;
  *(_OWORD *)(v19 + 1) = xmmword_1B692B730;
  v20 = v19 + 17;
  if ((const void *)(v19 + 17) != a2)
    v13 = memcpy((void *)(v19 + 17), a2, a3);
  *(_BYTE *)(v20 + a3) = 0x80;
  MEMORY[0x1E0C80A78](v13, v14, v15, v16, v17, v18);
  v22 = &buf[-v21];
  if (v10 != -5)
  {
    v23 = 0;
    v24 = v22 + 4;
    v25 = v10 + 5;
    v26 = (unsigned __int8 *)v12;
    do
    {
      v27 = *v26;
      if (v23 == 2)
      {
        if (v27 > 3)
        {
          v23 = 2;
        }
        else
        {
          v23 = 0;
          *v24++ = 3;
          ++v11;
          v27 = *v26;
        }
      }
      if (v27)
        v23 = 0;
      else
        ++v23;
      ++v26;
      *v24++ = v27;
      --v25;
    }
    while (v25);
  }
  DataBuffer = CMSampleBufferGetDataBuffer(*a1);
  DataLength = CMBlockBufferGetDataLength(DataBuffer);
  *(_DWORD *)v22 = bswap32(v11);
  if (CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v11 + 4 + DataLength, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, v11 + 4, 1u, v34))
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_30;
    *(_WORD *)buf = 0;
    v30 = MEMORY[0x1E0C81028];
    v31 = "Create prefix-user-data-SEI mem error";
    goto LABEL_22;
  }
  if (CMBlockBufferReplaceDataBytes(v22, v34[0], 0, v11 + 4))
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_30;
    *(_WORD *)buf = 0;
    v30 = MEMORY[0x1E0C81028];
    v31 = "Prefix-user-data-SEI error when copying to sample buffer";
    goto LABEL_22;
  }
  if (CMBlockBufferAppendBufferReference(v34[0], DataBuffer, 0, DataLength, 0))
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_30;
    *(_WORD *)buf = 0;
    v30 = MEMORY[0x1E0C81028];
    v31 = "Prefix-user-data-SEI error when appending compressed data";
    goto LABEL_22;
  }
  if (v34[0])
  {
    if (sub_1B6786C00(a1, v34[0]))
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        v30 = MEMORY[0x1E0C81028];
        v31 = "Prefix-user-data-SEI ReplaceBlockBufferInSampleBuffer failed";
LABEL_22:
        _os_log_error_impl(&dword_1B676B000, v30, OS_LOG_TYPE_ERROR, v31, buf, 2u);
      }
    }
    else
    {
      *a4 = v11;
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    v30 = MEMORY[0x1E0C81028];
    v31 = "Prefix-user-data-SEI mem full error";
    goto LABEL_22;
  }
LABEL_30:
  if (v34[0])
    CFRelease(v34[0]);
  return MEMORY[0x1BCC9811C](v12, 0x1000C8077774924);
}

uint64_t sub_1B6786C00(CMSampleBufferRef *a1, CMBlockBufferRef theBuffer)
{
  const opaqueCMFormatDescription *FormatDescription;
  const __CFArray *SampleAttachmentsArray;
  const __CFArray *v6;
  const __CFDictionary *ValueAtIndex;
  const __CFArray *v8;
  void *v9;
  CMSampleBufferRef v10;
  uint64_t v11;
  CMTime v13;
  CMSampleTimingInfo timingInfoOut;
  CMSampleBufferRef v15;
  size_t sampleSizeArray;

  sampleSizeArray = CMBlockBufferGetDataLength(theBuffer);
  FormatDescription = CMSampleBufferGetFormatDescription(*a1);
  v15 = 0;
  if (CMSampleBufferGetSampleTimingInfo(*a1, 0, &timingInfoOut))
  {
    timingInfoOut.presentationTimeStamp = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
    timingInfoOut.decodeTimeStamp = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E18];
    CMTimeMake(&v13, 1, 1);
    timingInfoOut.duration = v13;
  }
  CMSampleBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theBuffer, 1u, 0, 0, FormatDescription, 1, 1, &timingInfoOut, 1, &sampleSizeArray, &v15);
  if (!v15)
    return 4294954392;
  SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(*a1, 1u);
  if (!SampleAttachmentsArray)
    goto LABEL_9;
  v6 = SampleAttachmentsArray;
  if (!CFArrayGetCount(SampleAttachmentsArray))
    goto LABEL_9;
  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v6, 0);
  v8 = CMSampleBufferGetSampleAttachmentsArray(v15, 1u);
  if (v8)
  {
    v9 = (void *)CFArrayGetValueAtIndex(v8, 0);
    if (v9)
    {
      CFDictionaryApplyFunction(ValueAtIndex, (CFDictionaryApplierFunction)sub_1B6786D94, v9);
LABEL_9:
      CFRelease(*a1);
      v10 = v15;
      CFRetain(v15);
      v11 = 0;
      *a1 = v10;
      goto LABEL_12;
    }
  }
  v11 = 4294954385;
LABEL_12:
  if (v15)
    CFRelease(v15);
  return v11;
}

void sub_1B6786D94(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionaryAddValue(theDict, key, value);
}

uint64_t VCPCompressionSessionCreate(const __CFAllocator *a1, int a2, signed int a3, int a4, const __CFDictionary *a5, const __CFDictionary *a6, uint64_t a7, uint64_t a8, uint64_t a9, CFTypeRef *a10)
{
  char *Instance;
  char *v17;
  CFMutableDictionaryRef MutableCopy;
  const char *v19;
  int v20;
  const __CFDictionary *v21;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v23;
  const void *Value;
  const void *v25;
  CFNumberRef v26;
  const __CFNumber *v27;
  const __CFNumber *v28;
  CFTypeID v29;
  const void *v30;
  const __CFNumber *v31;
  const __CFNumber *v32;
  CFTypeID v33;
  unsigned int *v34;
  const __CFString *v35;
  const __CFString *v36;
  id *v37;
  NSObject *v38;
  const void *v39;
  const void *v40;
  const void *v41;
  _BOOL4 v42;
  const void *v43;
  const __CFNumber *v44;
  const __CFNumber *v45;
  CFTypeID v46;
  const __CFNumber *v47;
  const __CFNumber *v48;
  CFTypeID v49;
  int v50;
  unsigned int v51;
  const void *v52;
  const __CFString *v53;
  uint64_t v54;
  const __CFNumber *v55;
  const __CFNumber *v56;
  CFTypeID v57;
  const void *v58;
  const void *v59;
  const void *v60;
  const char *v61;
  int v62;
  int v63;
  const __CFString *v64;
  const void **v65;
  void *v66;
  int *v67;
  int v68;
  CFNumberRef v69;
  int v70;
  const void **v71;
  void *v72;
  const void **v73;
  const void **v74;
  _QWORD *v75;
  uint64_t v76;
  const void *v77;
  int v78;
  int v79;
  int v80;
  const char *v81;
  int v82;
  int v83;
  int v84;
  int v85;
  uint64_t v86;
  CFTypeRef v87;
  CFTypeRef v88;
  int v90;
  const char *v91;
  const void *v92;
  const __CFNumber *v93;
  const __CFNumber *v94;
  CFTypeID v95;
  const char *v96;
  int v97;
  CFNumberRef v98;
  const char *v99;
  const char *v100;
  CFNumberRef v101;
  const __CFNumber *v102;
  const __CFString *v103;
  const __CFString *v104;
  const __CFString *v105;
  OpaqueVTCompressionSession *v106;
  int AppBooleanValue;
  NSObject *v108;
  const char *v109;
  const __CFString *v110;
  int v111;
  const char *v112;
  int v113;
  const char *v114;
  void *v115;
  void *v116;
  _QWORD *v117;
  char *v118;
  uint64_t v119;
  char *v120;
  char *v121;
  NSObject *v122;
  const char *v123;
  const char *v124;
  const __CFAllocator *allocator;
  __CFDictionary *theDict;
  Boolean keyExistsAndHasValidFormat;
  CFTypeRef cf;
  CFTypeRef v130;
  int v131;
  _BYTE valuePtr[14];
  _BYTE v133[10];
  __int16 v134;
  const char *v135;
  __int16 v136;
  _BYTE v137[30];
  uint64_t v138;

  v138 = *MEMORY[0x1E0C80C00];
  cf = 0;
  keyExistsAndHasValidFormat = 0;
  *a10 = 0;
  pthread_once(&stru_1EF137C98, (void (*)(void))sub_1B6786128);
  allocator = a1;
  Instance = (char *)_CFRuntimeCreateInstance();
  v130 = Instance;
  if (!Instance)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      return 4294954392;
    v19 = "H.264";
    if (a4 > 1718908519)
    {
      if (a4 == 1752589105)
        goto LABEL_116;
      v20 = 1718908520;
    }
    else
    {
      if (a4 == 1684632424)
        goto LABEL_116;
      v20 = 1685481521;
    }
    if (a4 != v20)
    {
LABEL_117:
      *(_DWORD *)valuePtr = 67109890;
      *(_DWORD *)&valuePtr[4] = a2;
      *(_WORD *)&valuePtr[8] = 1024;
      *(_DWORD *)&valuePtr[10] = a3;
      *(_WORD *)v133 = 2080;
      *(_QWORD *)&v133[2] = v19;
      v134 = 1024;
      v54 = 4294954392;
      LODWORD(v135) = -12904;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc (%dx%d, %s): Failed to create video compression session, err = %d\n", valuePtr, 0x1Eu);
      return v54;
    }
LABEL_116:
    v19 = "HEVC";
    goto LABEL_117;
  }
  v17 = Instance;
  if (qword_1EDBB4C38 != -1)
    dispatch_once(&qword_1EDBB4C38, &unk_1E6A16A60);
  bzero(v17 + 16, 0x920uLL);
  if (a5)
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a5);
  else
    MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v21 = MutableCopy;
  if (a6)
    Mutable = CFDictionaryCreateMutableCopy(0, 0, a6);
  else
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v23 = Mutable;
  theDict = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (CFDictionaryContainsKey(v21, CFSTR("Alpha")))
  {
    Value = CFDictionaryGetValue(v21, CFSTR("Alpha"));
    if (Value)
    {
      v25 = Value;
      if (CFGetTypeID(Value))
      {
        if (CFBooleanGetTypeID())
        {
          if (CFEqual(v25, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
          {
            *(_DWORD *)valuePtr = 1982882104;
            v26 = CFNumberCreate(0, kCFNumberSInt32Type, valuePtr);
            if (v26)
            {
              CFDictionarySetValue(v23, (const void *)*MEMORY[0x1E0CA9040], v26);
              CFRelease(v26);
            }
          }
        }
      }
    }
  }
  if (!CFDictionaryContainsKey(v21, CFSTR("HistCorrMode")))
  {
    *((_DWORD *)v17 + 541) = 0;
    if (!v23)
      goto LABEL_34;
    goto LABEL_28;
  }
  *(_DWORD *)valuePtr = 0;
  v27 = (const __CFNumber *)CFDictionaryGetValue(v21, CFSTR("HistCorrMode"));
  v28 = v27;
  if (v27)
  {
    v29 = CFGetTypeID(v27);
    if (v29 == CFNumberGetTypeID())
      CFNumberGetValue(v28, kCFNumberSInt32Type, valuePtr);
  }
  *((_DWORD *)v17 + 541) = *(_DWORD *)valuePtr;
  if (v23)
  {
LABEL_28:
    v30 = (const void *)*MEMORY[0x1E0CA9040];
    if (CFDictionaryContainsKey(v23, (const void *)*MEMORY[0x1E0CA9040]))
    {
      *(_DWORD *)valuePtr = 0;
      v31 = (const __CFNumber *)CFDictionaryGetValue(v23, v30);
      v32 = v31;
      if (v31)
      {
        v33 = CFGetTypeID(v31);
        if (v33 == CFNumberGetTypeID())
          CFNumberGetValue(v32, kCFNumberSInt32Type, valuePtr);
      }
      if (*(_DWORD *)valuePtr == 1751411059)
        a4 = 1684632424;
    }
  }
LABEL_34:
  *((_DWORD *)v17 + 18) = 1;
  v34 = (unsigned int *)(v17 + 72);
  *((_DWORD *)v17 + 12) = 0;
  *((_WORD *)v17 + 26) = 256;
  v17[104] = 1;
  *((_QWORD *)v17 + 4) = a8;
  *((_QWORD *)v17 + 5) = a9;
  *((_WORD *)v17 + 64) = -1;
  *((_DWORD *)v17 + 36) = a2 & 0xFFFFFFFE;
  *((_DWORD *)v17 + 37) = a3 & 0xFFFFFFFE;
  v17[2160] = 0;
  *((_QWORD *)v17 + 291) = 1;
  v35 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("SerializationMode"), CFSTR("com.apple.VideoProcessing"));
  v36 = v35;
  if (v35)
  {
    *((_DWORD *)v17 + 582) = CFStringGetIntValue(v35);
    CFRelease(v36);
  }
  v37 = (id *)(v17 + 2176);
  if (!sub_1B67C24BC((_QWORD *)v17 + 272))
  {
    v38 = dispatch_semaphore_create(0);
    *((_QWORD *)v17 + 271) = v38;
    dispatch_semaphore_signal(v38);
    if (!*((_QWORD *)v17 + 271))
    {
      if (*v37)
      {
        objc_msgSend(*v37, "invalidate");
        CFRelease(*v37);
        *v37 = 0;
      }
    }
  }
  if (a5)
  {
    v39 = (const void *)*MEMORY[0x1E0CEDD38];
    v42 = CFDictionaryContainsKey(a5, (const void *)*MEMORY[0x1E0CEDD38])
       && (v40 = CFDictionaryGetValue(a5, v39), (v41 = v40) != 0)
       && CFGetTypeID(v40)
       && CFBooleanGetTypeID()
       && CFEqual(v41, (CFTypeRef)*MEMORY[0x1E0C9AE50]) != 0;
    v43 = (const void *)*MEMORY[0x1E0CED248];
    if (CFDictionaryContainsKey(a5, (const void *)*MEMORY[0x1E0CED248]))
    {
      v44 = (const __CFNumber *)CFDictionaryGetValue(a5, v43);
      v45 = v44;
      if (v44)
      {
        v46 = CFGetTypeID(v44);
        if (v46 == CFNumberGetTypeID())
          CFNumberGetValue(v45, kCFNumberSInt32Type, v17 + 68);
      }
    }
    if (CFDictionaryContainsKey(a5, CFSTR("NumberOfTiles")))
    {
      v47 = (const __CFNumber *)CFDictionaryGetValue(a5, CFSTR("NumberOfTiles"));
      v48 = v47;
      if (v47)
      {
        v49 = CFGetTypeID(v47);
        if (v49 == CFNumberGetTypeID())
          CFNumberGetValue(v48, kCFNumberSInt32Type, v17 + 72);
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        v50 = *((_DWORD *)v17 + 18);
        *(_DWORD *)valuePtr = 134218240;
        *(_QWORD *)&valuePtr[4] = v17;
        *(_WORD *)&valuePtr[12] = 1024;
        *(_DWORD *)v133 = v50;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p: Encoder got number of tiles video specification: %d\n", valuePtr, 0x12u);
      }
      v51 = *v34;
      if ((int)*v34 <= 1)
        v51 = 1;
      if (v51 >= 4)
        v51 = 4;
      *v34 = v51;
    }
    v52 = (const void *)*MEMORY[0x1E0CED180];
    if (CFDictionaryContainsKey(v21, (const void *)*MEMORY[0x1E0CED180]))
    {
      v53 = (const __CFString *)CFDictionaryGetValue(v21, v52);
      CFRetain(v53);
    }
    else
    {
      v53 = 0;
    }
    if (CFDictionaryContainsKey(a5, CFSTR("decodingOrderBase")))
    {
      v55 = (const __CFNumber *)CFDictionaryGetValue(a5, CFSTR("decodingOrderBase"));
      v56 = v55;
      if (v55)
      {
        v57 = CFGetTypeID(v55);
        if (v57 == CFNumberGetTypeID())
          CFNumberGetValue(v56, kCFNumberSInt32Type, v17 + 84);
      }
    }
    v58 = (const void *)*MEMORY[0x1E0CED2B0];
    if (CFDictionaryContainsKey(a5, (const void *)*MEMORY[0x1E0CED2B0]))
    {
      v59 = CFDictionaryGetValue(v21, v58);
      if (v59)
      {
        v60 = (const void *)*MEMORY[0x1E0C9AE50];
        if (CFEqual(v59, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
          CFDictionaryAddValue(theDict, v58, v60);
      }
    }
  }
  else
  {
    v42 = 0;
    v53 = 0;
  }
  if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    goto LABEL_86;
  v61 = "H.264";
  if (a4 <= 1718908519)
  {
    if (a4 != 1684632424)
    {
      v62 = 1685481521;
      goto LABEL_81;
    }
LABEL_82:
    v61 = "HEVC";
    goto LABEL_83;
  }
  if (a4 == 1752589105)
    goto LABEL_82;
  v62 = 1718908520;
LABEL_81:
  if (a4 == v62)
    goto LABEL_82;
LABEL_83:
  v63 = *((_DWORD *)v17 + 17);
  v64 = CFSTR("N/A");
  if (v53)
    v64 = v53;
  *(_DWORD *)valuePtr = 134219778;
  *(_QWORD *)&valuePtr[4] = v17;
  *(_WORD *)&valuePtr[12] = 1024;
  *(_DWORD *)v133 = a2;
  *(_WORD *)&v133[4] = 1024;
  *(_DWORD *)&v133[6] = a3;
  v134 = 2080;
  v135 = v61;
  v136 = 1024;
  *(_DWORD *)v137 = v42;
  *(_WORD *)&v137[4] = 1024;
  *(_DWORD *)&v137[6] = v63;
  *(_WORD *)&v137[10] = 2112;
  *(_QWORD *)&v137[12] = v64;
  *(_WORD *)&v137[20] = 2080;
  *(_QWORD *)&v137[22] = "iOS";
  _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Got video encoder specification: request_hw = %d, usage = %d, profile_level = %@, target = %s\n", valuePtr, 0x42u);
LABEL_86:
  if (v53)
    CFRelease(v53);
  v65 = (const void **)operator new();
  *v65 = 0;
  v66 = (void *)MEMORY[0x1BCC98608]();
  if (!*v65)
  {
    *(_QWORD *)valuePtr = objc_opt_new();
    sub_1B6777A50(v65, (const void **)valuePtr);
    sub_1B6777A90((const void **)valuePtr);
  }
  objc_autoreleasePoolPop(v66);
  if (!*v65 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)valuePtr = 0;
    _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Unable to initialize metal session", valuePtr, 2u);
  }
  v67 = (int *)v130;
  *((_QWORD *)v130 + 12) = v65;
  v68 = v67[18];
  if (v68 >= 2)
  {
    a3 = (a3 / v68 + 15) & 0xFFFFFFF0;
    *(_DWORD *)valuePtr = a3;
    v69 = CFNumberCreate(0, kCFNumberSInt32Type, valuePtr);
    if (v69)
    {
      CFDictionarySetValue(v23, (const void *)*MEMORY[0x1E0CA8FD8], v69);
      CFRelease(v69);
    }
  }
  v70 = v67[541];
  if (v70)
  {
    if (v70 == 2)
    {
      v75 = (_QWORD *)operator new();
      *v75 = 0;
      v75[1] = 0;
      v76 = *((_QWORD *)v67 + 285);
      *((_QWORD *)v67 + 285) = v75;
      if (v76)
      {
        if (*(_QWORD *)v76)
        {
          CFRelease(*(CFTypeRef *)v76);
          *(_QWORD *)v76 = 0;
        }
        v77 = *(const void **)(v76 + 8);
        if (v77)
        {
          CFRelease(v77);
          *(_QWORD *)(v76 + 8) = 0;
        }
        MEMORY[0x1BCC9814C](v76, 0x20C40A4A59CD2);
      }
      goto LABEL_101;
    }
    if (v70 == 1)
    {
      v71 = (const void **)operator new();
      *v71 = 0;
      v72 = (void *)MEMORY[0x1BCC98608]();
      *(_QWORD *)valuePtr = objc_opt_new();
      sub_1B6777A50(v71, (const void **)valuePtr);
      sub_1B6777A90((const void **)valuePtr);
      objc_autoreleasePoolPop(v72);
      v73 = (const void **)*((_QWORD *)v67 + 284);
      *((_QWORD *)v67 + 284) = v71;
      if (v73)
      {
        v74 = sub_1B6777A90(v73);
        MEMORY[0x1BCC9814C](v74, 0xC0C40B8AA526DLL);
      }
LABEL_101:
      sub_1B678851C((char **)v67 + 286, v67[18]);
      goto LABEL_123;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v79 = v67[15];
      v78 = v67[16];
      v80 = v67[6];
      v81 = "H.264";
      if (v80 > 1718908519)
      {
        if (v80 == 1752589105)
          goto LABEL_121;
        v82 = 1718908520;
      }
      else
      {
        if (v80 == 1684632424)
          goto LABEL_121;
        v82 = 1685481521;
      }
      if (v80 != v82)
      {
LABEL_122:
        *(_DWORD *)valuePtr = 134219010;
        *(_QWORD *)&valuePtr[4] = v67;
        *(_WORD *)&valuePtr[12] = 1024;
        *(_DWORD *)v133 = v79;
        *(_WORD *)&v133[4] = 1024;
        *(_DWORD *)&v133[6] = v78;
        v134 = 2080;
        v135 = v81;
        v136 = 1024;
        *(_DWORD *)v137 = v70;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Invalid histogram correlation mode %d!\n", valuePtr, 0x28u);
        goto LABEL_123;
      }
LABEL_121:
      v81 = "HEVC";
      goto LABEL_122;
    }
  }
LABEL_123:
  v83 = 0;
  v84 = 1718908515;
  if (a4 > 1718908519)
  {
    if (a4 != 1752589105)
    {
      v85 = 1718908520;
LABEL_128:
      if (a4 != v85)
        goto LABEL_130;
    }
  }
  else if (a4 != 1684632424)
  {
    v85 = 1685481521;
    goto LABEL_128;
  }
  v84 = 1718908520;
  v83 = 1;
LABEL_130:
  v86 = VTCompressionSessionCreateWithOptions();
  v54 = v86;
  v87 = cf;
  if (!cf)
  {
    if ((_DWORD)v86)
      v54 = v86;
    else
      v54 = 4294954392;
LABEL_136:
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v96 = "H.264";
      v97 = v67[17];
      *(_DWORD *)valuePtr = 134219778;
      if (v83)
        v96 = "HEVC";
      *(_QWORD *)&valuePtr[4] = v67;
      *(_WORD *)&valuePtr[12] = 1024;
      *(_DWORD *)v133 = a2;
      *(_WORD *)&v133[4] = 1024;
      *(_DWORD *)&v133[6] = a3;
      v134 = 2080;
      v135 = v96;
      v136 = 2080;
      *(_QWORD *)v137 = "";
      *(_WORD *)&v137[8] = 1024;
      *(_DWORD *)&v137[10] = v97;
      *(_WORD *)&v137[14] = 2080;
      *(_QWORD *)&v137[16] = "iOS";
      *(_WORD *)&v137[24] = 1024;
      *(_DWORD *)&v137[26] = v54;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VCPEnc %p (%dx%d, %s): Failed to create %s video encoder with usage %d on %s, err = %d!\n", valuePtr, 0x42u);
    }
LABEL_137:
    v88 = v130;
    if (!v130)
      goto LABEL_139;
    goto LABEL_138;
  }
  if ((_DWORD)v86)
  {
    CFRelease(cf);
    cf = 0;
    goto LABEL_136;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v90 = v67[17];
    v91 = "H.264";
    *(_DWORD *)valuePtr = 134219266;
    if (v83)
      v91 = "HEVC";
    *(_QWORD *)&valuePtr[4] = v67;
    *(_WORD *)&valuePtr[12] = 1024;
    *(_DWORD *)v133 = a2;
    *(_WORD *)&v133[4] = 1024;
    *(_DWORD *)&v133[6] = a3;
    v134 = 2080;
    v135 = v91;
    v136 = 1024;
    *(_DWORD *)v137 = v90;
    *(_WORD *)&v137[4] = 2080;
    *(_QWORD *)&v137[6] = "iOS";
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Created video encoder with usage %d on %s.\n", valuePtr, 0x32u);
    v87 = cf;
  }
  v67[33] = 8;
  *((_QWORD *)v67 + 2) = v87;
  cf = 0;
  if (v23)
  {
    v92 = (const void *)*MEMORY[0x1E0CA9040];
    if (CFDictionaryContainsKey(v23, (const void *)*MEMORY[0x1E0CA9040]))
    {
      v131 = 0;
      v93 = (const __CFNumber *)CFDictionaryGetValue(v23, v92);
      v94 = v93;
      if (v93)
      {
        v95 = CFGetTypeID(v93);
        if (v95 == CFNumberGetTypeID())
          CFNumberGetValue(v94, kCFNumberSInt32Type, &v131);
      }
      if (v131 <= 2016686639)
      {
        if (v131 != 645424692 && v131 != 645428788)
        {
          if (v131 == 1751411059)
          {
            v67[33] = 10;
            VTCompressionSessionSetProperty();
            goto LABEL_180;
          }
          goto LABEL_229;
        }
      }
      else
      {
        if (v131 <= 2019963439)
        {
          if (v131 != 2016686640)
          {
            if (v131 != 2016687156)
              goto LABEL_229;
            goto LABEL_175;
          }
LABEL_170:
          v67[33] = 10;
          v98 = CFNumberCreate(allocator, kCFNumberSInt32Type, v67 + 33);
          VTCompressionSessionSetProperty();
          VTCompressionSessionSetProperty();
          VTCompressionSessionSetProperty();
          VTCompressionSessionSetProperty();
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          {
            v99 = "H.264";
            *(_DWORD *)valuePtr = 134218754;
            *(_QWORD *)&valuePtr[4] = v67;
            *(_WORD *)&valuePtr[12] = 1024;
            if (v83)
              v99 = "HEVC";
            *(_DWORD *)v133 = a2;
            *(_WORD *)&v133[4] = 1024;
            *(_DWORD *)&v133[6] = a3;
            v134 = 2080;
            v135 = v99;
            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Got 10b input and set HDRMetadataInsertionMode_Auto/HEVC_Main10_AutoLevel/bitdepth10\n", valuePtr, 0x22u);
          }
          goto LABEL_179;
        }
        if (v131 != 2019963956)
        {
          if (v131 != 2019963440)
          {
LABEL_229:
            if ((v131 & 0xFFFFFFEF) == 0x34343466)
            {
              VTCompressionSessionSetProperty();
              if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
              {
                v124 = "H.264";
                *(_DWORD *)valuePtr = 134218754;
                *(_QWORD *)&valuePtr[4] = v67;
                *(_WORD *)&valuePtr[12] = 1024;
                if (v83)
                  v124 = "HEVC";
                *(_DWORD *)v133 = a2;
                *(_WORD *)&v133[4] = 1024;
                *(_DWORD *)&v133[6] = a3;
                v134 = 2080;
                v135 = v124;
                _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Got 8b 444 input and set HEVC_Main444_AutoLevel\n", valuePtr, 0x22u);
              }
            }
            goto LABEL_180;
          }
          goto LABEL_170;
        }
      }
LABEL_175:
      v67[33] = 10;
      v98 = CFNumberCreate(allocator, kCFNumberSInt32Type, v67 + 33);
      VTCompressionSessionSetProperty();
      VTCompressionSessionSetProperty();
      VTCompressionSessionSetProperty();
      VTCompressionSessionSetProperty();
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        v100 = "H.264";
        *(_DWORD *)valuePtr = 134218754;
        *(_QWORD *)&valuePtr[4] = v67;
        *(_WORD *)&valuePtr[12] = 1024;
        if (v83)
          v100 = "HEVC";
        *(_DWORD *)v133 = a2;
        *(_WORD *)&v133[4] = 1024;
        *(_DWORD *)&v133[6] = a3;
        v134 = 2080;
        v135 = v100;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Got 10b input and set HDRMetadataInsertionMode_Auto/HEVC_Main44410_AutoLevel/bitdepth10\n", valuePtr, 0x22u);
      }
LABEL_179:
      CFRelease(v98);
    }
  }
LABEL_180:
  if (v67[18] >= 2)
  {
    VTCompressionSessionGetPixelBufferPool(*((VTCompressionSessionRef *)v67 + 2));
    CVPixelBufferPoolSetMaxBufferAge();
    v101 = CFNumberCreate(allocator, kCFNumberSInt32Type, v67 + 18);
    VTCompressionSessionSetProperty();
    CFRelease(v101);
  }
  v131 = 0;
  *(_QWORD *)valuePtr = 4;
  if (!sysctlbyname("hw.activecpu", &v131, (size_t *)valuePtr, 0, 0) && v131 >= 2)
  {
    *(_DWORD *)valuePtr = 0;
    if (v21)
    {
      v102 = (const __CFNumber *)CFDictionaryGetValue(v21, CFSTR("UsingCellular"));
      if (v102)
        CFNumberGetValue(v102, kCFNumberIntType, valuePtr);
    }
    v103 = (const __CFString *)CFNumberCreate(allocator, kCFNumberIntType, valuePtr);
    if (v103)
    {
      VCPCompressionSessionSetProperty((uint64_t)v67, CFSTR("UsingCellular"), v103);
      CFRelease(v103);
    }
  }
  if (v21)
  {
    v104 = (const __CFString *)*MEMORY[0x1E0CEDD18];
    v105 = (const __CFString *)CFDictionaryGetValue(v21, (const void *)*MEMORY[0x1E0CEDD18]);
    VCPCompressionSessionSetProperty((uint64_t)v67, v104, v105);
  }
  v106 = (OpaqueVTCompressionSession *)*((_QWORD *)v67 + 2);
  if (v106)
    VTCompressionSessionPrepareToEncodeFrames(v106);
  v67[6] = v84;
  v67[15] = a2;
  v67[16] = a3;
  AppBooleanValue = CFPreferencesGetAppBooleanValue(CFSTR("SignLanguageProminence"), CFSTR("com.apple.VideoProcessing"), &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat && !AppBooleanValue)
    goto LABEL_200;
  if (qword_1EF1385E8 != -1)
    dispatch_once(&qword_1EF1385E8, &unk_1E6A16EB8);
  if (byte_1EF1385E0)
  {
    *((_WORD *)v67 + 26) = 257;
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      goto LABEL_203;
    *(_WORD *)valuePtr = 0;
    v108 = MEMORY[0x1E0C81028];
    v109 = "VideoProminence analysis enabled\n";
  }
  else
  {
LABEL_200:
    *((_WORD *)v67 + 26) = 0;
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      goto LABEL_203;
    *(_WORD *)valuePtr = 0;
    v108 = MEMORY[0x1E0C81028];
    v109 = "VideoProminence analysis disabled\n";
  }
  _os_log_impl(&dword_1B676B000, v108, OS_LOG_TYPE_DEFAULT, v109, valuePtr, 2u);
LABEL_203:
  v110 = (const __CFString *)CFNumberCreate(allocator, kCFNumberSInt64Type, &v130);
  if (v110)
  {
    VCPCompressionSessionSetProperty((uint64_t)v130, CFSTR("CallerID"), v110);
    CFRelease(v110);
  }
  v111 = *((_DWORD *)v130 + 6);
  v112 = "H.264";
  if (v111 > 1718908519)
  {
    if (v111 != 1752589105)
    {
      v113 = 1718908520;
LABEL_210:
      if (v111 != v113)
        goto LABEL_212;
    }
  }
  else if (v111 != 1684632424)
  {
    v113 = 1685481521;
    goto LABEL_210;
  }
  v112 = "HEVC";
LABEL_212:
  if (*((_DWORD *)v130 + 33) == 8)
    v114 = "SDR";
  else
    v114 = "HDR";
  snprintf((char *)v130 + 152, 0x7D0uLL, "VCPEnc %p (%dx%d, %s, %s)", v130, *((_DWORD *)v130 + 15), *((_DWORD *)v130 + 16), v112, v114);
  v115 = operator new(0x88uLL, MEMORY[0x1E0DE4E10]);
  v88 = v130;
  if (v115)
  {
    v116 = v115;
    sub_1B6872CF8((uint64_t)v115, (uint64_t)sub_1B678A228, (uint64_t)v130);
    v117 = v130;
    *((_QWORD *)v130 + 289) = v116;
    v118 = (char *)operator new(0x110uLL, MEMORY[0x1E0DE4E10]);
    if (v118)
    {
      *(_QWORD *)v118 = v118;
      *((_QWORD *)v118 + 1) = v118;
      *((_QWORD *)v118 + 2) = 0;
      *((_QWORD *)v118 + 3) = 0x1312D000000003CLL;
      *((_QWORD *)v118 + 4) = 0x4114585555555555;
      *(_OWORD *)(v118 + 40) = 0u;
      *(_OWORD *)(v118 + 56) = 0u;
      *(_OWORD *)(v118 + 72) = 0u;
      *(_OWORD *)(v118 + 88) = 0u;
      *(_OWORD *)(v118 + 104) = 0u;
      *(_OWORD *)(v118 + 120) = 0u;
      *(_OWORD *)(v118 + 136) = 0u;
      *((_DWORD *)v118 + 38) = 50;
      v119 = MEMORY[0x1E0CA2E68];
      *(_OWORD *)(v118 + 156) = *MEMORY[0x1E0CA2E68];
      *(_QWORD *)(v118 + 172) = *(_QWORD *)(v119 + 16);
      *((_QWORD *)v118 + 24) = 0;
      *((_QWORD *)v118 + 23) = v118 + 192;
      *((_QWORD *)v118 + 25) = 0;
      *((_QWORD *)v118 + 26) = 850045863;
      *(_OWORD *)(v118 + 216) = 0u;
      *(_OWORD *)(v118 + 232) = 0u;
      *(_OWORD *)(v118 + 248) = 0u;
      *((_QWORD *)v118 + 33) = 0;
      v117[273] = v118;
      v120 = (char *)operator new(0x40uLL, MEMORY[0x1E0DE4E10]);
      if (v120)
      {
        *(_QWORD *)v120 = 850045863;
        *(_OWORD *)(v120 + 8) = 0u;
        *(_OWORD *)(v120 + 24) = 0u;
        *(_OWORD *)(v120 + 40) = 0u;
        *((_QWORD *)v120 + 7) = 0;
        v117[269] = v120;
        v121 = (char *)operator new(0x40uLL, MEMORY[0x1E0DE4E10]);
        if (v121)
        {
          v54 = 0;
          *(_QWORD *)v121 = 850045863;
          *(_OWORD *)(v121 + 8) = 0u;
          *(_OWORD *)(v121 + 24) = 0u;
          *(_OWORD *)(v121 + 40) = 0u;
          *((_QWORD *)v121 + 7) = 0;
          v117[292] = v121;
          if (!v21)
            goto LABEL_141;
          goto LABEL_140;
        }
        v117[292] = 0;
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          goto LABEL_236;
        *(_WORD *)valuePtr = 0;
        v122 = MEMORY[0x1E0C81028];
        v123 = "Failed to create session callback mutex\n";
        goto LABEL_235;
      }
      v117[269] = 0;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)valuePtr = 0;
        v122 = MEMORY[0x1E0C81028];
        v123 = "Failed to create session mutex\n";
        goto LABEL_235;
      }
    }
    else
    {
      v117[273] = 0;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)valuePtr = 0;
        v122 = MEMORY[0x1E0C81028];
        v123 = "Failed to create rate controller\n";
LABEL_235:
        _os_log_error_impl(&dword_1B676B000, v122, OS_LOG_TYPE_ERROR, v123, valuePtr, 2u);
      }
    }
LABEL_236:
    v54 = 4294954392;
    goto LABEL_137;
  }
  *((_QWORD *)v130 + 289) = 0;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)valuePtr = 0;
    v122 = MEMORY[0x1E0C81028];
    v123 = "Failed to create stats monitor\n";
    goto LABEL_235;
  }
  v54 = 4294954392;
LABEL_138:
  CFRelease(v88);
  v130 = 0;
LABEL_139:
  if (v21)
LABEL_140:
    CFRelease(v21);
LABEL_141:
  if (v23)
    CFRelease(v23);
  if (theDict)
    CFRelease(theDict);
  *a10 = v130;
  return v54;
}

void sub_1B67884BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1BCC98134](v1, MEMORY[0x1E0DE4E10]);
  _Unwind_Resume(a1);
}

void sub_1B678851C(char **a1, unint64_t a2)
{
  char *v4;
  char *v5;
  unint64_t v6;
  unint64_t v7;
  char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;

  v4 = *a1;
  v5 = a1[1];
  v6 = 0xFF00FF00FF00FF01 * ((v5 - *a1) >> 5);
  v7 = a2 - v6;
  if (a2 <= v6)
  {
    if (a2 < v6)
      a1[1] = &v4[8224 * a2];
  }
  else
  {
    v8 = a1[2];
    if (0xFF00FF00FF00FF01 * ((v8 - v5) >> 5) >= v7)
    {
      v18 = &v5[8224 * v7];
      do
      {
        bzero(v5, 0x2020uLL);
        *((_DWORD *)v5 + 2053) = 1;
        v5 += 8224;
      }
      while (v5 != v18);
      a1[1] = v18;
    }
    else
    {
      if (a2 > 0x7F807F807F807)
        sub_1B6773BAC();
      v9 = 0xFF00FF00FF00FF01 * ((v8 - v4) >> 5);
      v10 = 2 * v9;
      if (2 * v9 <= a2)
        v10 = a2;
      if (v9 >= 0x3FC03FC03FC03)
        v11 = 0x7F807F807F807;
      else
        v11 = v10;
      if (v11 > 0x7F807F807F807)
        sub_1B6773BF4();
      v12 = (char *)operator new(8224 * v11, (std::align_val_t)0x20uLL);
      v13 = &v12[8224 * v6];
      v14 = &v12[8224 * a2];
      v15 = v13;
      do
      {
        bzero(v15, 0x2020uLL);
        *((_DWORD *)v15 + 2053) = 1;
        v15 += 8224;
      }
      while (v15 != v14);
      v16 = &v12[8224 * v11];
      v17 = *a1;
      if (v5 != *a1)
      {
        do
        {
          v5 -= 8224;
          v13 -= 8224;
          memcpy(v13, v5, 0x2018uLL);
        }
        while (v5 != v17);
        v5 = *a1;
      }
      *a1 = v13;
      a1[1] = v14;
      a1[2] = v16;
      if (v5)
        JUMPOUT(0x1BCC98140);
    }
  }
}

void sub_1B67886D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CMSampleBufferRef sbuf)
{
  opaqueCMSampleBuffer *v5;
  unsigned int v10;
  int v11;
  BOOL v12;
  int v13;
  BOOL v14;
  const opaqueCMFormatDescription *FormatDescription;
  size_t v16;
  int v17;
  uint64_t v18;
  int v19;
  std::__assoc_sub_state *v20;
  _BYTE *v21;
  int v22;
  int v23;
  uint64_t v24;
  const __CFDictionary *v25;
  int v26;
  const void *v27;
  const __CFData *Data;
  const UInt8 *BytePtr;
  size_t Length;
  CFMutableDictionaryRef Mutable;
  int SerializedAtomDataBlockBufferWithFlagsForCFType;
  CFTypeID v33;
  CFStringRef v34;
  const char *CStringPtr;
  const __CFString *v36;
  const char *v37;
  int v38;
  OpaqueCMBlockBuffer *v39;
  size_t v40;
  void *v41;
  void *v42;
  std::mutex *v43;
  int v44;
  int v45;
  int v46;
  const char *v47;
  int v48;
  uint64_t v49;
  double v50;
  BOOL v51;
  const __CFArray *SampleAttachmentsArray;
  OpaqueCMBlockBuffer *DataBuffer;
  CFNumberRef v54;
  const void **v55;
  CFNumberRef v56;
  CFNumberRef v57;
  const void *v58;
  const void *v59;
  const __CFNumber *Value;
  const __CFNumber *v61;
  CFTypeID v62;
  const void *v63;
  char v64;
  const void *v65;
  CFNumberRef v66;
  const __CFNumber *v67;
  CFTypeID TypeID;
  uint64_t v69;
  int v70;
  int v71;
  double v72;
  int v73;
  uint64_t **v74;
  uint64_t **v75;
  uint64_t *v76;
  _DWORD *v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t *v80;
  int v81;
  _DWORD *v82;
  uint64_t *v83;
  std::__shared_weak_count *v84;
  uint64_t v85;
  unint64_t *p_shared_owners;
  unint64_t v87;
  std::__shared_weak_count *v88;
  unint64_t *v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  double v94;
  double v95;
  int v96;
  int v97;
  int v98;
  const char *v99;
  int v100;
  int v101;
  uint64_t v102;
  uint64_t v103;
  const __CFNumber *v104;
  const __CFNumber *v105;
  CFTypeID v106;
  const __CFNumber *v107;
  const __CFNumber *v108;
  CFTypeID v109;
  uint64_t v110;
  _BOOL4 v111;
  int v112;
  int v113;
  int v114;
  const char *v115;
  int v116;
  uint64_t **v117;
  int v118;
  unsigned int v119;
  unsigned int v120;
  size_t DataLength;
  uint64_t v122;
  __CFDictionary *theDict;
  size_t v124;
  int v125;
  int v126;
  double valuePtr;
  CMSampleBufferRef sbufa;
  CFDataRef theData;
  void *v130;
  _BYTE buf[12];
  __int16 v132;
  _BYTE v133[10];
  __int16 v134;
  const char *v135;
  __int16 v136;
  double v137;
  __int16 v138;
  _BYTE v139[14];
  __int16 v140;
  double v141;
  CFErrorRef error[4];

  v5 = sbuf;
  error[2] = *(CFErrorRef *)MEMORY[0x1E0C80C00];
  sbufa = sbuf;
  if (sbuf)
    CFRetain(sbuf);
  v10 = a4 & 2;
  valuePtr = -1.0;
  v11 = *(_DWORD *)(a1 + 60);
  v125 = *(_DWORD *)(a1 + 64);
  v126 = v11;
  v124 = 0;
  if (a1 && a2)
  {
    if ((a4 & 2) == 0 && !v5)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Invalid sample buffer\n", buf, 2u);
      }
      goto LABEL_196;
    }
    if ((a4 & 2) != 0)
    {
      v14 = 0;
    }
    else
    {
      FormatDescription = CMSampleBufferGetFormatDescription(v5);
      v14 = CMFormatDescriptionGetMediaSubType(FormatDescription) == 1685481521;
    }
    if (*(_WORD *)(a1 + 50)
      && *(_BYTE *)(a1 + 52)
      && !v5
      && CMSampleBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, &sbufa))
    {
      sbufa = 0;
    }
    if ((a4 & 2) != 0)
    {
      if (!sbufa)
      {
        DataLength = 0;
LABEL_115:
        theDict = 0;
        v122 = 0;
        v64 = 1;
        goto LABEL_124;
      }
      v16 = 0;
      goto LABEL_92;
    }
    v17 = *(_DWORD *)(a2 + 8);
    if (v17 < (unint64_t)((uint64_t)(*(_QWORD *)(a2 + 280) - *(_QWORD *)(a2 + 272)) >> 3))
    {
      v18 = v17 + 1;
      v19 = *(_DWORD *)(a1 + 72);
      if ((int)v18 >= v19)
      {
        v22 = *(_DWORD *)(a2 + 8);
      }
      else
      {
        do
        {
          v20 = *(std::__assoc_sub_state **)(*(_QWORD *)(a2 + 272) + 8 * v18);
          if (v20)
          {
            sub_1B678AAF4(v20);
            if (!*v21)
              v17 = v18;
            v19 = *(_DWORD *)(a1 + 72);
          }
          ++v18;
        }
        while (v18 < v19);
        v22 = *(_DWORD *)(a2 + 8);
      }
      *(_BYTE *)(a2 + 80) = v22 == v17;
    }
    if (!v14)
    {
      v23 = *(_DWORD *)(a1 + 68);
      if (v23 == 42 || v23 == 20)
      {
        v24 = *(_QWORD *)(a1 + 2192);
        if (v24)
        {
          if (*(_BYTE *)(v24 + 33))
            sub_1B678ABB0(a1, &sbufa, a2);
        }
      }
    }
    if (!sbufa)
    {
      DataLength = 0;
LABEL_112:
      if ((a4 & 2) == 0 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "no sample attachment found\n", buf, 2u);
      }
      goto LABEL_115;
    }
    v25 = *(const __CFDictionary **)(a2 + 264);
    if (!v25
      || (v26 = *(_DWORD *)(a1 + 2328),
          !CFDictionaryContainsKey(*(CFDictionaryRef *)(a2 + 264), CFSTR("PropagatableAttachments")))
      || (v27 = CFDictionaryGetValue(v25, CFSTR("PropagatableAttachments"))) == 0)
    {
LABEL_73:
      v16 = v124;
      if (!v124)
        goto LABEL_92;
      v43 = *(std::mutex **)(a1 + 2336);
      if (v43)
      {
        *(_QWORD *)buf = *(_QWORD *)(a1 + 2336);
        buf[8] = 1;
        std::mutex::lock(v43);
        *(_DWORD *)(a1 + 2332) += 8 * v16;
        sub_1B678B174((uint64_t)buf);
        if (buf[8])
          std::mutex::unlock(*(std::mutex **)buf);
LABEL_86:
        v49 = *(_QWORD *)(a1 + 2184);
        if (!v49
          || ((v50 = *(double *)(v49 + 32), v50 > 0.0) ? (v51 = v50 > (double)(8 * v16)) : (v51 = 1),
              v51 || !(v111 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))))
        {
LABEL_92:
          SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(sbufa, 1u);
          if (SampleAttachmentsArray)
            theDict = (__CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
          else
            theDict = 0;
          DataBuffer = CMSampleBufferGetDataBuffer(sbufa);
          DataLength = CMBlockBufferGetDataLength(DataBuffer);
          if (theDict)
          {
            if (*(_BYTE *)(a1 + 52))
            {
              v54 = CFNumberCreate(0, kCFNumberSInt16Type, (const void *)(a1 + 48));
              if (v54)
              {
                CFDictionarySetValue(theDict, CFSTR("PriorityScore"), v54);
                CFRelease(v54);
              }
            }
            v55 = (const void **)MEMORY[0x1E0CA25C8];
            if (*(int *)(a1 + 72) >= 2)
            {
              *(_DWORD *)buf = *(_DWORD *)(a2 + 8);
              v56 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
              if (v56)
              {
                CFDictionarySetValue(theDict, CFSTR("TileID"), v56);
                CFRelease(v56);
              }
              *(_WORD *)buf = *(_DWORD *)(a1 + 76);
              v57 = CFNumberCreate(0, kCFNumberSInt16Type, buf);
              if (v57)
              {
                CFDictionarySetValue(theDict, CFSTR("TileOrder"), v57);
                CFRelease(v57);
              }
              if (*(_BYTE *)(a2 + 44))
              {
                v58 = (const void *)*MEMORY[0x1E0C9AE40];
                CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E0CA2620], (const void *)*MEMORY[0x1E0C9AE40]);
                CFDictionarySetValue(theDict, *v55, v58);
              }
            }
            v59 = (const void *)*MEMORY[0x1E0CEDA50];
            if (CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E0CEDA50]))
            {
              Value = (const __CFNumber *)CFDictionaryGetValue(theDict, v59);
              v61 = Value;
              if (Value)
              {
                v62 = CFGetTypeID(Value);
                if (v62 == CFNumberGetTypeID())
                  CFNumberGetValue(v61, kCFNumberDoubleType, &valuePtr);
              }
            }
            v63 = CFDictionaryGetValue(theDict, *v55);
            if (v63)
              HIDWORD(v122) = CFEqual(v63, (CFTypeRef)*MEMORY[0x1E0C9AE40]) != 0;
            else
              HIDWORD(v122) = 0;
            v65 = CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E0CEDA90]);
            if (v65)
            {
              LODWORD(v122) = CFEqual(v65, (CFTypeRef)*MEMORY[0x1E0C9AE50]) != 0;
              if (!v16)
                goto LABEL_123;
            }
            else
            {
              LODWORD(v122) = 0;
              if (!v16)
              {
LABEL_123:
                v64 = 0;
LABEL_124:
                if (*(_QWORD *)(a1 + 2184))
                {
                  LODWORD(v130) = 0;
                  if ((a4 & 2) != 0)
                    v64 = 1;
                  if ((v64 & 1) == 0)
                  {
                    if (CFDictionaryContainsKey(theDict, CFSTR("TemporalID")))
                    {
                      v67 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("TemporalID"));
                      if (v67)
                      {
                        TypeID = CFNumberGetTypeID();
                        if (TypeID == CFGetTypeID(v67))
                          CFNumberGetValue(v67, kCFNumberSInt32Type, &v130);
                      }
                    }
                  }
                  v69 = *(_QWORD *)(a1 + 2184);
                  v71 = *(_DWORD *)(a2 + 24);
                  v118 = *(unsigned __int8 *)(a2 + 45);
                  v72 = valuePtr;
                  v73 = (int)v130;
                  *(_DWORD *)buf = *(_DWORD *)(a2 + 8);
                  v70 = *(_DWORD *)buf;
                  std::mutex::lock((std::mutex *)(v69 + 208));
                  v119 = a3;
                  v120 = a4;
                  v74 = sub_1B6779B8C((uint64_t **)(v69 + 184), v70, buf);
                  v75 = v74;
                  v76 = (uint64_t *)v69;
                  while (1)
                  {
                    v76 = (uint64_t *)v76[1];
                    if (v76 == (uint64_t *)v69)
                      break;
                    v77 = (_DWORD *)v76[2];
                    if (*v77 == v71)
                    {
                      v117 = v74 + 5;
                      if (!v10)
                      {
                        sub_1B677A440((_QWORD *)(v69 + 88), v77 + 11);
                        v78 = *(_QWORD *)(v69 + 128);
                        if (v78 >= 0x11)
                        {
                          ++*(_QWORD *)(v69 + 120);
                          *(_QWORD *)(v69 + 128) = v78 - 1;
                          sub_1B677A4C4(v69 + 88);
                        }
                        LODWORD(error[0]) = 8 * DataLength;
                        sub_1B677A440((_QWORD *)(v69 + 40), error);
                        v79 = *(_QWORD *)(v69 + 80);
                        if (v79 >= 0x11)
                        {
                          ++*(_QWORD *)(v69 + 72);
                          *(_QWORD *)(v69 + 80) = v79 - 1;
                          sub_1B677A4C4(v69 + 40);
                        }
                        if (!v73)
                          *((_BYTE *)v75 + 128) = 0;
                      }
                      if (v118)
                      {
                        v80 = v75[9];
                        if (v80 && !*(_BYTE *)v80)
                          *((_DWORD *)v75 + 30) = 0;
                        if (!v10)
                        {
                          v81 = *((_DWORD *)v75 + 30);
                          if ((v81 & 0x80000000) == 0)
                            *((_DWORD *)v75 + 30) = v81 + 1;
                        }
                        if (v72 < 17.0)
                        {
                          v82 = operator new(0x18uLL);
                          v82[4] = v71;
                          *((_QWORD *)v82 + 1) = v117;
                          v83 = v75[5];
                          *(_QWORD *)v82 = v83;
                          v83[1] = (uint64_t)v82;
                          v75[5] = (uint64_t *)v82;
                          v75[7] = (uint64_t *)((char *)v75[7] + 1);
                        }
                      }
                      v84 = (std::__shared_weak_count *)operator new(0x28uLL);
                      v85 = (uint64_t)(v76 + 2);
                      v84->__shared_owners_ = 0;
                      p_shared_owners = (unint64_t *)&v84->__shared_owners_;
                      v84->__shared_weak_owners_ = 0;
                      v84->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6A15B18;
                      LOBYTE(v84[1].__vftable) = v118;
                      BYTE1(v84[1].__vftable) = v10 >> 1;
                      *(double *)&v84[1].__shared_owners_ = v72;
                      if (!v10)
                      {
                        do
                          v87 = __ldxr(p_shared_owners);
                        while (__stxr(v87 + 1, p_shared_owners));
                        v88 = (std::__shared_weak_count *)v75[10];
                        v75[9] = (uint64_t *)&v84[1];
                        v75[10] = (uint64_t *)v84;
                        if (v88)
                        {
                          v89 = (unint64_t *)&v88->__shared_owners_;
                          do
                            v90 = __ldaxr(v89);
                          while (__stlxr(v90 - 1, v89));
                          if (!v90)
                          {
                            ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
                            std::__shared_weak_count::__release_weak(v88);
                            v85 = (uint64_t)(v76 + 2);
                          }
                        }
                      }
                      do
                        v91 = __ldaxr(p_shared_owners);
                      while (__stlxr(v91 - 1, p_shared_owners));
                      if (!v91)
                      {
                        v92 = v85;
                        ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
                        std::__shared_weak_count::__release_weak(v84);
                        v85 = v92;
                      }
                      v93 = *v76;
                      *(_QWORD *)(v93 + 8) = v76[1];
                      *(_QWORD *)v76[1] = v93;
                      --*(_QWORD *)(v69 + 16);
                      sub_1B6772C88(v85);
                      operator delete(v76);
                      break;
                    }
                  }
                  std::mutex::unlock((std::mutex *)(v69 + 208));
                  a3 = v119;
                  a4 = v120;
                }
                sub_1B67ED98C(a2 + 176);
                v94 = *(double *)(a2 + 176);
                if (*(int *)(a1 + 72) > 1)
                  goto LABEL_175;
                v95 = *(double *)(a1 + 88);
                if (v95 <= 0.0
                  || v94 * 1000.0 <= 1.0 / v95 * 3000.0
                  || !os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                {
                  goto LABEL_175;
                }
                v97 = *(_DWORD *)(a1 + 60);
                v96 = *(_DWORD *)(a1 + 64);
                v98 = *(_DWORD *)(a1 + 24);
                v99 = "H.264";
                if (v98 > 1718908519)
                {
                  if (v98 == 1752589105)
                    goto LABEL_173;
                  v100 = 1718908520;
                }
                else
                {
                  if (v98 == 1684632424)
                    goto LABEL_173;
                  v100 = 1685481521;
                }
                if (v98 != v100)
                {
LABEL_174:
                  v101 = *(_DWORD *)(a2 + 24);
                  *(_DWORD *)buf = 134219778;
                  *(_QWORD *)&buf[4] = a1;
                  v132 = 1024;
                  *(_DWORD *)v133 = v97;
                  *(_WORD *)&v133[4] = 1024;
                  *(_DWORD *)&v133[6] = v96;
                  v134 = 2080;
                  v135 = v99;
                  v136 = 2048;
                  v137 = v94 * 1000.0;
                  v138 = 1024;
                  *(_DWORD *)v139 = v101;
                  *(_WORD *)&v139[4] = 2048;
                  *(double *)&v139[6] = 1.0 / v95 * 1000.0;
                  v140 = 2048;
                  v141 = v95;
                  _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Delay Warning: Encoding time=%.2f ms of frame=%d is greater than 3 times the expected input frame interval=%.2f ms with input frame rate=%.2f\n", buf, 0x46u);
LABEL_175:
                  v102 = *(_QWORD *)(a1 + 2312);
                  if (v102)
                  {
                    sub_1B6872E44(v102, (uint64_t *)"encoded_frames", 1.0);
                    sub_1B6872E44(*(_QWORD *)(a1 + 2312), (uint64_t *)"header_bits", (double)*(int *)(a2 + 28));
                    sub_1B6872E44(*(_QWORD *)(a1 + 2312), (uint64_t *)"rtx_bits", (double)*(int *)(a2 + 32));
                    sub_1B6872E44(*(_QWORD *)(a1 + 2312), (uint64_t *)"fec_bits", (double)*(int *)(a2 + 36));
                    sub_1B6872E44(*(_QWORD *)(a1 + 2312), (uint64_t *)"sei_bits", (double)*(int *)(a2 + 40));
                    v103 = *(_QWORD *)(a1 + 2312);
                    if (v10)
                    {
                      sub_1B6872E44(v103, (uint64_t *)"dropped_frames", 1.0);
                    }
                    else
                    {
                      sub_1B6872E44(v103, (uint64_t *)"transmit_frames", 1.0);
                      sub_1B6872E44(*(_QWORD *)(a1 + 2312), (uint64_t *)"encoded_bits", (double)(8 * DataLength));
                      sub_1B6872E44(*(_QWORD *)(a1 + 2312), (uint64_t *)"encoding_time", v94);
                      sub_1B6872E44(*(_QWORD *)(a1 + 2312), (uint64_t *)"frame_qp", valuePtr);
                      sub_1B6872E44(*(_QWORD *)(a1 + 2312), (uint64_t *)"min_frame_size", (double)*(int *)(a2 + 168));
                    }
                    if (*(_BYTE *)(a2 + 45))
                      sub_1B6872E44(*(_QWORD *)(a1 + 2312), (uint64_t *)"repeated_frames", 1.0);
                    if (HIDWORD(v122))
                      sub_1B6872E44(*(_QWORD *)(a1 + 2312), (uint64_t *)"idr_frames", 1.0);
                    if ((_DWORD)v122)
                      sub_1B6872E44(*(_QWORD *)(a1 + 2312), (uint64_t *)"refresh_frames", 1.0);
                  }
                  if (!v10
                    && sbufa
                    && CFDictionaryContainsKey(theDict, CFSTR("VRAWidth"))
                    && CFDictionaryContainsKey(theDict, CFSTR("VRAHeight")))
                  {
                    v104 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("VRAWidth"));
                    v105 = v104;
                    if (v104)
                    {
                      v106 = CFGetTypeID(v104);
                      if (v106 == CFNumberGetTypeID())
                        CFNumberGetValue(v105, kCFNumberSInt32Type, &v126);
                    }
                    v107 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("VRAHeight"));
                    v108 = v107;
                    if (v107)
                    {
                      v109 = CFGetTypeID(v107);
                      if (v109 == CFNumberGetTypeID())
                        CFNumberGetValue(v108, kCFNumberSInt32Type, &v125);
                    }
                  }
                  kdebug_trace();
                  kdebug_trace();
LABEL_196:
                  (*(void (**)(_QWORD, _QWORD, uint64_t, uint64_t, CMSampleBufferRef))(a1 + 32))(*(_QWORD *)(a1 + 40), *(_QWORD *)a2, a3, a4, sbufa);
                  *(_DWORD *)(a1 + 76) += (sbufa != 0) & ~(v10 != 0);
                  v110 = sub_1B678B1B4(a2);
                  MEMORY[0x1BCC9814C](v110, 0x10A0C40973F72EDLL);
                  v5 = sbufa;
                  if (!sbufa)
                    return;
                  goto LABEL_197;
                }
LABEL_173:
                v99 = "HEVC";
                goto LABEL_174;
              }
            }
            *(_DWORD *)buf = v16;
            v66 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
            if (v66)
            {
              CFDictionarySetValue(theDict, CFSTR("PropagatableAttachmentsNALSize"), v66);
              CFRelease(v66);
            }
            goto LABEL_123;
          }
          goto LABEL_112;
        }
        v113 = *(_DWORD *)(a1 + 60);
        v112 = *(_DWORD *)(a1 + 64);
        v114 = *(_DWORD *)(a1 + 24);
        v115 = "H.264";
        if (v114 > 1718908519)
        {
          if (v114 == 1752589105)
            goto LABEL_206;
          v116 = 1718908520;
        }
        else
        {
          if (v114 == 1684632424)
            goto LABEL_206;
          v116 = 1685481521;
        }
        if (v114 != v116)
        {
LABEL_207:
          *(_DWORD *)buf = 134219266;
          *(_QWORD *)&buf[4] = a1;
          v132 = 1024;
          *(_DWORD *)v133 = v113;
          *(_WORD *)&v133[4] = 1024;
          *(_DWORD *)&v133[6] = v112;
          v134 = 2080;
          v135 = v115;
          v136 = 2048;
          v137 = (double)(8 * v16);
          v138 = 2048;
          *(double *)v139 = v50;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): VCPCompressionSessionCallback SEI size=%.0f larger than target frame size=%.0f\n", buf, 0x36u);
          goto LABEL_92;
        }
LABEL_206:
        v115 = "HEVC";
        goto LABEL_207;
      }
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        goto LABEL_86;
      v45 = *(_DWORD *)(a1 + 60);
      v44 = *(_DWORD *)(a1 + 64);
      v46 = *(_DWORD *)(a1 + 24);
      v47 = "H.264";
      if (v46 > 1718908519)
      {
        if (v46 == 1752589105)
          goto LABEL_84;
        v48 = 1718908520;
      }
      else
      {
        if (v46 == 1684632424)
          goto LABEL_84;
        v48 = 1685481521;
      }
      if (v46 != v48)
      {
LABEL_85:
        *(_DWORD *)buf = 134218754;
        *(_QWORD *)&buf[4] = a1;
        v132 = 1024;
        *(_DWORD *)v133 = v45;
        *(_WORD *)&v133[4] = 1024;
        *(_DWORD *)&v133[6] = v44;
        v134 = 2080;
        v135 = v47;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): VCPCompressionSessionCallback got NULL callback mutex\n", buf, 0x22u);
        goto LABEL_86;
      }
LABEL_84:
      v47 = "HEVC";
      goto LABEL_85;
    }
    if (v26 == 1)
    {
      error[0] = 0;
      Data = CFPropertyListCreateData(0, v27, kCFPropertyListBinaryFormat_v1_0, 0, error);
      if (Data)
      {
        sub_1B6770538((const void **)error);
        theData = Data;
        BytePtr = CFDataGetBytePtr(Data);
        Length = CFDataGetLength(theData);
        sub_1B6786878(&sbufa, BytePtr, Length, &v124);
      }
      else
      {
        v33 = CFGetTypeID(v27);
        v34 = CFCopyTypeIDDescription(v33);
        v130 = (void *)v34;
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          CStringPtr = CFStringGetCStringPtr(v34, 0x8000100u);
          v36 = CFErrorCopyFailureReason(error[0]);
          v37 = CFStringGetCStringPtr(v36, 0x8000100u);
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = CStringPtr;
          v132 = 2080;
          *(_QWORD *)v133 = v37;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Failed to serialize %s (%s)", buf, 0x16u);
        }
        sub_1B6770508((const void **)&v130);
        sub_1B6770538((const void **)error);
        theData = 0;
      }
      sub_1B67704D8((const void **)&theData);
      goto LABEL_73;
    }
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v130 = Mutable;
    if (!Mutable)
    {
LABEL_72:
      sub_1B67705C8((const void **)&v130);
      goto LABEL_73;
    }
    CFDictionaryAddValue(Mutable, CFSTR("PropagatableAttachments"), v27);
    *(_QWORD *)buf = 0;
    if (v26 == 2)
      SerializedAtomDataBlockBufferWithFlagsForCFType = FigRemote_CreateSerializedAtomDataBlockBufferWithFlagsForCFType();
    else
      SerializedAtomDataBlockBufferWithFlagsForCFType = FigRemote_CreateSerializedAtomDataBlockBufferForCFType();
    v38 = SerializedAtomDataBlockBufferWithFlagsForCFType;
    v39 = *(OpaqueCMBlockBuffer **)buf;
    if (*(_QWORD *)buf)
    {
      theData = *(CFDataRef *)buf;
      goto LABEL_63;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(error[0]) = 67109120;
      HIDWORD(error[0]) = v38;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "CFPropertyList SerializeAtomData failed at SerializedAtomDataBlockBufferForCFType (%d)\n", (uint8_t *)error, 8u);
      v39 = *(OpaqueCMBlockBuffer **)buf;
      theData = *(CFDataRef *)buf;
      if (*(_QWORD *)buf)
      {
LABEL_63:
        v40 = CMBlockBufferGetDataLength(v39);
        v41 = operator new[](v40, MEMORY[0x1E0DE4E10]);
        if (v41)
        {
          v42 = v41;
          *(_QWORD *)buf = 0;
          CMBlockBufferAccessDataBytes(theData, 0, v40, v41, (char **)buf);
          sub_1B6786878(&sbufa, *(const void **)buf, v40, &v124);
          MEMORY[0x1BCC9811C](v42, 0x1000C8077774924);
        }
        else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "addAttachmentSEI unable to create temp buffer\n", buf, 2u);
        }
      }
    }
    else
    {
      theData = 0;
    }
    sub_1B67705F8((const void **)&theData);
    goto LABEL_72;
  }
  if (a2)
    goto LABEL_196;
  v12 = (a4 & 2) != 0 || v5 == 0;
  v13 = *(_DWORD *)(a1 + 76);
  if (!v12)
    ++v13;
  *(_DWORD *)(a1 + 76) = v13;
  if (v5)
LABEL_197:
    CFRelease(v5);
}

void sub_1B67897CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25,const void *a26,std::mutex *a27,char a28)
{
  sub_1B67705F8(&a25);
  sub_1B67705C8(&a26);
  _Unwind_Resume(a1);
}

uint64_t VCPCompressionSessionSetProperty(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  const __CFAllocator *v6;
  __CFString *Mutable;
  int v8;
  int v9;
  int v10;
  const char *v11;
  int v12;
  uint64_t v13;
  int v14;
  CFTypeID v15;
  CFTypeID v16;
  CFNumberRef v17;
  uint64_t v18;
  int v19;
  double v20;
  int v21;
  CFTypeID TypeID;
  void *v23;
  char *v24;
  int v25;
  CFTypeID v26;
  void *v27;
  const char *v28;
  CFTypeID v29;
  unsigned int v30;
  int v31;
  int v32;
  int v33;
  const char *v34;
  int v35;
  int v36;
  CFTypeID v37;
  CFTypeID v38;
  int v39;
  int v40;
  uint64_t v41;
  int v42;
  int v43;
  int v44;
  const char *v45;
  int v46;
  int v47;
  int v48;
  int v49;
  const char *v50;
  int v51;
  int v52;
  CFTypeID v53;
  CFTypeID v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  double v59;
  int v60;
  float v61;
  __CFArray *v62;
  CFNumberRef v63;
  CFNumberRef v64;
  int v66;
  float valuePtr;
  uint8_t buf[4];
  uint64_t v69;
  __int16 v70;
  int v71;
  __int16 v72;
  int v73;
  __int16 v74;
  const char *v75;
  __int16 v76;
  _BYTE v77[10];
  void *v78;
  __int16 v79;
  int v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  sub_1B685548C(Mutable, a3);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v9 = *(_DWORD *)(a1 + 60);
    v8 = *(_DWORD *)(a1 + 64);
    v10 = *(_DWORD *)(a1 + 24);
    v11 = "H.264";
    if (v10 > 1718908519)
    {
      if (v10 == 1752589105)
        goto LABEL_8;
      v12 = 1718908520;
    }
    else
    {
      if (v10 == 1684632424)
        goto LABEL_8;
      v12 = 1685481521;
    }
    if (v10 != v12)
    {
LABEL_9:
      *(_DWORD *)buf = 134219266;
      v69 = a1;
      v70 = 1024;
      v71 = v9;
      v72 = 1024;
      v73 = v8;
      v74 = 2080;
      v75 = v11;
      v76 = 2112;
      *(_QWORD *)v77 = a2;
      *(_WORD *)&v77[8] = 2114;
      v78 = Mutable;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Encoder got %@ property = %{public}@\n", buf, 0x36u);
      goto LABEL_10;
    }
LABEL_8:
    v11 = "HEVC";
    goto LABEL_9;
  }
LABEL_10:
  CFRelease(Mutable);
  v13 = *MEMORY[0x1E0CECEB0];
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECEB0]))
    *(_BYTE *)(a1 + 2348) = 1;
  v14 = CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECFD0]);
  if (!a3 || !v14 || (v15 = CFNumberGetTypeID(), v15 != CFGetTypeID(a3)))
  {
    v21 = CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED0F8]);
    if (a3)
    {
      if (v21)
      {
        TypeID = CFStringGetTypeID();
        if (TypeID == CFGetTypeID(a3))
        {
          v23 = *(void **)(a1 + 120);
          if (v23)
          {
            free(v23);
            *(_QWORD *)(a1 + 120) = 0;
          }
          v24 = (char *)malloc_type_calloc(0x3E9uLL, 1uLL, 0x100004077774924uLL);
          *(_QWORD *)(a1 + 120) = v24;
          CFStringGetCString(a3, v24, 1001, 0);
        }
      }
    }
    if (CFEqual(a2, CFSTR("NegotiationDetailsBitField")))
    {
      if (!a3)
        goto LABEL_38;
    }
    else
    {
      v25 = CFEqual(a2, CFSTR("NegotiatedFLB"));
      if (!a3 || !v25)
        goto LABEL_38;
    }
    v26 = CFDataGetTypeID();
    if (v26 == CFGetTypeID(a3))
    {
      v27 = *(void **)(a1 + 120);
      if (v27)
      {
        free(v27);
        *(_QWORD *)(a1 + 120) = 0;
      }
      *(_QWORD *)(a1 + 120) = malloc_type_calloc(0x3E9uLL, 1uLL, 0x100004077774924uLL);
      if (CFEqual(a2, CFSTR("NegotiationDetailsBitField")))
        v28 = "FLBA;";
      else
        v28 = "FLBN;";
      sub_1B685BEC8((const __CFData *)a3, v28, *(char **)(a1 + 120), 1000);
    }
LABEL_38:
    if (CFEqual(a2, CFSTR("CompressionMode")))
    {
      LOWORD(valuePtr) = 0;
      v29 = CFGetTypeID(a3);
      v30 = 0;
      if (v29 == CFNumberGetTypeID())
      {
        CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt16Type, &valuePtr);
        v30 = LOWORD(valuePtr);
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        LODWORD(v69) = (__int16)v30;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VideoProminence: kVCPCompressionPropertyKey_CompressionMode (set by AVC) = %d", buf, 8u);
        v30 = LOWORD(valuePtr);
      }
      if (v30 >= 3)
      {
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          return 4294943593;
        v32 = *(_DWORD *)(a1 + 60);
        v31 = *(_DWORD *)(a1 + 64);
        v33 = *(_DWORD *)(a1 + 24);
        v34 = "H.264";
        if (v33 > 1718908519)
        {
          if (v33 == 1752589105)
            goto LABEL_64;
          v35 = 1718908520;
        }
        else
        {
          if (v33 == 1684632424)
            goto LABEL_64;
          v35 = 1685481521;
        }
        if (v33 != v35)
        {
LABEL_65:
          *(_DWORD *)buf = 134219010;
          v69 = a1;
          v70 = 1024;
          v71 = v32;
          v72 = 1024;
          v73 = v31;
          v74 = 2080;
          v75 = v34;
          v76 = 1024;
          *(_DWORD *)v77 = (__int16)v30;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Unexpected compression mode: %d!\n", buf, 0x28u);
          return 4294943593;
        }
LABEL_64:
        v34 = "HEVC";
        goto LABEL_65;
      }
      *(_WORD *)(a1 + 50) = v30;
      v41 = 0;
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        return v41;
      v43 = *(_DWORD *)(a1 + 60);
      v42 = *(_DWORD *)(a1 + 64);
      v44 = *(_DWORD *)(a1 + 24);
      v45 = "H.264";
      if (v44 > 1718908519)
      {
        if (v44 == 1752589105)
          goto LABEL_70;
        v46 = 1718908520;
      }
      else
      {
        if (v44 == 1684632424)
          goto LABEL_70;
        v46 = 1685481521;
      }
      if (v44 != v46)
      {
LABEL_71:
        *(_DWORD *)buf = 134219266;
        v69 = a1;
        v70 = 1024;
        v71 = v43;
        v72 = 1024;
        v73 = v42;
        v74 = 2080;
        v75 = v45;
        v76 = 1024;
        *(_DWORD *)v77 = v30;
        *(_WORD *)&v77[4] = 1024;
        *(_DWORD *)&v77[6] = 0;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Encoder got compression mode property: %d, but forced to %d\n", buf, 0x2Eu);
        return 0;
      }
LABEL_70:
      v45 = "HEVC";
      goto LABEL_71;
    }
    v36 = CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED248]);
    if (!a3)
      goto LABEL_91;
    if (!v36)
      goto LABEL_91;
    v37 = CFNumberGetTypeID();
    if (v37 != CFGetTypeID(a3))
      goto LABEL_91;
    v38 = CFGetTypeID(a3);
    if (v38 == CFNumberGetTypeID())
      CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, (void *)(a1 + 68));
    if (*(_DWORD *)(a1 + 68) != 1)
    {
LABEL_91:
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECEF0]))
      {
        *(_DWORD *)buf = 0;
        if (a3)
        {
          v53 = CFNumberGetTypeID();
          if (v53 == CFGetTypeID(a3))
          {
            v54 = CFGetTypeID(a3);
            if (v54 == CFNumberGetTypeID())
              CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, buf);
            v55 = *(_QWORD *)(a1 + 2312);
            if (v55)
              sub_1B6872FAC(v55, (uint64_t *)"target_bitrate", (double)*(int *)buf);
            v56 = *(_QWORD *)(a1 + 2184);
            if (v56)
            {
              v57 = *(_DWORD *)buf;
              *(_DWORD *)(v56 + 28) = *(_DWORD *)buf;
              v58 = *(_DWORD *)(v56 + 24);
              if (v58 < 1)
                v59 = 0.0;
              else
                v59 = (double)v57 / (double)v58;
              *(double *)(v56 + 32) = v59;
            }
          }
        }
        v60 = *(_DWORD *)(a1 + 68);
        if (v60 == 42 || v60 == 20)
        {
          v61 = 0.05;
          if (v60 == 20)
            v61 = 0.5;
          valuePtr = v61;
          v66 = (int)(float)((float)(v61 * (float)*(int *)buf) * 0.125);
          v62 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
          v63 = CFNumberCreate(v6, kCFNumberSInt32Type, &v66);
          CFArrayAppendValue(v62, v63);
          CFRelease(v63);
          v64 = CFNumberCreate(v6, kCFNumberFloat32Type, &valuePtr);
          CFArrayAppendValue(v62, v64);
          CFRelease(v64);
          VTSessionSetProperty(*(VTSessionRef *)(a1 + 16), (CFStringRef)*MEMORY[0x1E0CECF78], v62);
          CFRelease(v62);
        }
      }
      if (!CFEqual(a2, CFSTR("ThermalLevel")) || *(_DWORD *)(a1 + 24) != 1635148593)
        return VTSessionSetProperty(*(VTSessionRef *)(a1 + 16), a2, a3);
      return 0;
    }
    v39 = *(_DWORD *)(a1 + 24);
    if (v39 > 1718908519)
    {
      if (v39 != 1752589105)
      {
        v40 = 1718908520;
LABEL_87:
        if (v39 != v40)
          goto LABEL_91;
      }
    }
    else if (v39 != 1684632424)
    {
      v40 = 1685481521;
      goto LABEL_87;
    }
    if (!*(_BYTE *)(a1 + 2348) && (sub_1B679C0B0() & 1) == 0)
      VCPCompressionSessionSetProperty(a1, v13, *MEMORY[0x1E0C9AE50]);
    goto LABEL_91;
  }
  v16 = CFGetTypeID(a3);
  if (v16 == CFNumberGetTypeID())
    CFNumberGetValue((CFNumberRef)a3, kCFNumberDoubleType, (void *)(a1 + 88));
  *(double *)(a1 + 88) = *(double *)(a1 + 88) * (double)*(int *)(a1 + 72);
  v17 = CFNumberCreate(v6, kCFNumberDoubleType, (const void *)(a1 + 88));
  v18 = *(_QWORD *)(a1 + 2184);
  if (v18)
  {
    v19 = (int)*(double *)(a1 + 88);
    *(_DWORD *)(v18 + 24) = v19;
    if (v19 < 1)
      v20 = 0.0;
    else
      v20 = (double)*(int *)(v18 + 28) / (double)v19;
    *(double *)(v18 + 32) = v20;
  }
  if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    goto LABEL_83;
  v48 = *(_DWORD *)(a1 + 60);
  v47 = *(_DWORD *)(a1 + 64);
  v49 = *(_DWORD *)(a1 + 24);
  v50 = "H.264";
  if (v49 <= 1718908519)
  {
    if (v49 != 1684632424)
    {
      v51 = 1685481521;
      goto LABEL_80;
    }
LABEL_81:
    v50 = "HEVC";
    goto LABEL_82;
  }
  if (v49 == 1752589105)
    goto LABEL_81;
  v51 = 1718908520;
LABEL_80:
  if (v49 == v51)
    goto LABEL_81;
LABEL_82:
  v52 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)buf = 134219522;
  v69 = a1;
  v70 = 1024;
  v71 = v48;
  v72 = 1024;
  v73 = v47;
  v74 = 2080;
  v75 = v50;
  v76 = 2112;
  *(_QWORD *)v77 = a3;
  *(_WORD *)&v77[8] = 2112;
  v78 = v17;
  v79 = 1024;
  v80 = v52;
  _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Encoder got ExpectedFrameRate property: %@, will be set to %@ to support %d-tile encoding\n", buf, 0x3Cu);
LABEL_83:
  v41 = VTSessionSetProperty(*(VTSessionRef *)(a1 + 16), a2, v17);
  if (v17)
    CFRelease(v17);
  return v41;
}

void sub_1B678A228(uint64_t a1, double a2)
{
  uint64_t v3;
  double *v4;
  _QWORD *v5;
  _QWORD *v6;
  double v7;
  double v8;
  double *v9;
  _QWORD *v10;
  unint64_t v11;
  BOOL v12;
  _QWORD *v13;
  double *v14;
  _QWORD *v15;
  unint64_t v16;
  BOOL v17;
  _QWORD *v18;
  double v19;
  double *v20;
  _QWORD *v21;
  unint64_t v22;
  BOOL v23;
  _QWORD *v24;
  double v25;
  double *v26;
  _QWORD *v27;
  unint64_t v28;
  BOOL v29;
  _QWORD *v30;
  double v31;
  double *v32;
  _QWORD *v33;
  unint64_t v34;
  BOOL v35;
  _QWORD *v36;
  double v37;
  double *v38;
  _QWORD *v39;
  unint64_t v40;
  BOOL v41;
  _QWORD *v42;
  double v43;
  double *v44;
  _QWORD *v45;
  unint64_t v46;
  BOOL v47;
  _QWORD *v48;
  double v49;
  double *v50;
  _QWORD *v51;
  unint64_t v52;
  BOOL v53;
  _QWORD *v54;
  double v55;
  double *v56;
  _QWORD *v57;
  unint64_t v58;
  BOOL v59;
  _QWORD *v60;
  double v61;
  double *v62;
  _QWORD *v63;
  unint64_t v64;
  BOOL v65;
  _QWORD *v66;
  uint64_t v67;
  double *v68;
  _QWORD *v69;
  unint64_t v70;
  BOOL v71;
  _QWORD *v72;
  double v73;
  double *v74;
  _QWORD *v75;
  unint64_t v76;
  BOOL v77;
  _QWORD *v78;
  double v79;
  double *v80;
  _QWORD *v81;
  unint64_t v82;
  BOOL v83;
  _QWORD *v84;
  double v85;
  double *v86;
  _QWORD *v87;
  unint64_t v88;
  BOOL v89;
  _QWORD *v90;
  double v91;
  double *v92;
  _QWORD *v93;
  unint64_t v94;
  BOOL v95;
  _QWORD *v96;
  double v97;
  double v98;
  double *v99;
  unint64_t v100;
  BOOL v101;
  _QWORD *v102;
  _BOOL4 v103;
  double v104;
  double v105;
  NSObject *v106;
  const char *v107;
  uint32_t v108;
  double v110;
  double v111;
  double v112;
  double v113;
  double v114;
  double v115;
  uint64_t v116;
  double v117;
  uint8_t buf[4];
  uint64_t v119;
  __int16 v120;
  double v121;
  __int16 v122;
  double v123;
  __int16 v124;
  double v125;
  __int16 v126;
  double v127;
  __int16 v128;
  double v129;
  __int16 v130;
  double v131;
  __int16 v132;
  double v133;
  __int16 v134;
  double v135;
  __int16 v136;
  double v137;
  __int16 v138;
  uint64_t v139;
  __int16 v140;
  double v141;
  __int16 v142;
  double v143;
  __int16 v144;
  double v145;
  __int16 v146;
  double v147;
  __int16 v148;
  double v149;
  __int16 v150;
  char *v151;
  __int16 v152;
  double v153;
  char __str[16];
  __int128 v155;
  __int128 v156;
  __int16 v157;
  uint64_t v158;

  v158 = *MEMORY[0x1E0C80C00];
  if (a2 > 0.0)
  {
    if (!a1)
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        return;
      *(_WORD *)buf = 0;
      v106 = MEMORY[0x1E0C81028];
      v107 = "Empty callback refcon in VCPEncStatsMonitorCallback()\n";
      v108 = 2;
      goto LABEL_193;
    }
    v3 = *(_QWORD *)(a1 + 2312);
    v6 = *(_QWORD **)(v3 + 32);
    v4 = (double *)(v3 + 32);
    v5 = v6;
    v7 = 0.0;
    v8 = 0.0;
    if (!v6)
      goto LABEL_181;
    v9 = v4;
    v10 = v5;
    do
    {
      v11 = v10[4];
      v12 = v11 >= (unint64_t)"input_frames";
      if (v11 >= (unint64_t)"input_frames")
        v13 = v10;
      else
        v13 = v10 + 1;
      if (v12)
        v9 = (double *)v10;
      v10 = (_QWORD *)*v13;
    }
    while (*v13);
    v8 = 0.0;
    if (v9 != v4 && *((_QWORD *)v9 + 4) <= (unint64_t)"input_frames")
      v8 = v9[5];
    if (v5)
    {
      v14 = v4;
      v15 = v5;
      do
      {
        v16 = v15[4];
        v17 = v16 >= (unint64_t)"encoded_frames";
        if (v16 >= (unint64_t)"encoded_frames")
          v18 = v15;
        else
          v18 = v15 + 1;
        if (v17)
          v14 = (double *)v15;
        v15 = (_QWORD *)*v18;
      }
      while (*v18);
      v19 = 0.0;
      if (v14 != v4 && *((_QWORD *)v14 + 4) <= (unint64_t)"encoded_frames")
        v19 = v14[5];
      v20 = v4;
      v21 = v5;
      do
      {
        v22 = v21[4];
        v23 = v22 >= (unint64_t)"transmit_frames";
        if (v22 >= (unint64_t)"transmit_frames")
          v24 = v21;
        else
          v24 = v21 + 1;
        if (v23)
          v20 = (double *)v21;
        v21 = (_QWORD *)*v24;
      }
      while (*v24);
      v25 = 0.0;
      if (v20 != v4 && *((_QWORD *)v20 + 4) <= (unint64_t)"transmit_frames")
        v25 = v20[5];
      v26 = v4;
      v27 = v5;
      do
      {
        v28 = v27[4];
        v29 = v28 >= (unint64_t)"frame_qp";
        if (v28 >= (unint64_t)"frame_qp")
          v30 = v27;
        else
          v30 = v27 + 1;
        if (v29)
          v26 = (double *)v27;
        v27 = (_QWORD *)*v30;
      }
      while (*v30);
      v31 = 0.0;
      if (v26 != v4 && *((_QWORD *)v26 + 4) <= (unint64_t)"frame_qp")
        v31 = v26[5];
      v32 = v4;
      v33 = v5;
      do
      {
        v34 = v33[4];
        v35 = v34 >= (unint64_t)"encoded_bits";
        if (v34 >= (unint64_t)"encoded_bits")
          v36 = v33;
        else
          v36 = v33 + 1;
        if (v35)
          v32 = (double *)v33;
        v33 = (_QWORD *)*v36;
      }
      while (*v36);
      v37 = 0.0;
      if (v32 != v4 && *((_QWORD *)v32 + 4) <= (unint64_t)"encoded_bits")
        v37 = v32[5];
      v38 = v4;
      v39 = v5;
      do
      {
        v40 = v39[4];
        v41 = v40 >= (unint64_t)"header_bits";
        if (v40 >= (unint64_t)"header_bits")
          v42 = v39;
        else
          v42 = v39 + 1;
        if (v41)
          v38 = (double *)v39;
        v39 = (_QWORD *)*v42;
      }
      while (*v42);
      v43 = 0.0;
      if (v38 != v4 && *((_QWORD *)v38 + 4) <= (unint64_t)"header_bits")
        v43 = v38[5];
      v44 = v4;
      v45 = v5;
      do
      {
        v46 = v45[4];
        v47 = v46 >= (unint64_t)"rtx_bits";
        if (v46 >= (unint64_t)"rtx_bits")
          v48 = v45;
        else
          v48 = v45 + 1;
        if (v47)
          v44 = (double *)v45;
        v45 = (_QWORD *)*v48;
      }
      while (*v48);
      v49 = 0.0;
      if (v44 != v4 && *((_QWORD *)v44 + 4) <= (unint64_t)"rtx_bits")
        v49 = v44[5];
      v50 = v4;
      v51 = v5;
      do
      {
        v52 = v51[4];
        v53 = v52 >= (unint64_t)"fec_bits";
        if (v52 >= (unint64_t)"fec_bits")
          v54 = v51;
        else
          v54 = v51 + 1;
        if (v53)
          v50 = (double *)v51;
        v51 = (_QWORD *)*v54;
      }
      while (*v54);
      v55 = 0.0;
      if (v50 != v4 && *((_QWORD *)v50 + 4) <= (unint64_t)"fec_bits")
        v55 = v50[5];
      v56 = v4;
      v57 = v5;
      do
      {
        v58 = v57[4];
        v59 = v58 >= (unint64_t)"encoding_time";
        if (v58 >= (unint64_t)"encoding_time")
          v60 = v57;
        else
          v60 = v57 + 1;
        if (v59)
          v56 = (double *)v57;
        v57 = (_QWORD *)*v60;
      }
      while (*v60);
      v61 = 0.0;
      if (v56 != v4 && *((_QWORD *)v56 + 4) <= (unint64_t)"encoding_time")
        v61 = v56[5];
      v62 = v4;
      v63 = v5;
      do
      {
        v64 = v63[4];
        v65 = v64 >= (unint64_t)"target_bitrate";
        if (v64 >= (unint64_t)"target_bitrate")
          v66 = v63;
        else
          v66 = v63 + 1;
        if (v65)
          v62 = (double *)v63;
        v63 = (_QWORD *)*v66;
      }
      while (*v66);
      v67 = 0;
      if (v62 != v4 && *((_QWORD *)v62 + 4) <= (unint64_t)"target_bitrate")
        v67 = *((_QWORD *)v62 + 5);
      v68 = v4;
      v69 = v5;
      do
      {
        v70 = v69[4];
        v71 = v70 >= (unint64_t)"sei_bits";
        if (v70 >= (unint64_t)"sei_bits")
          v72 = v69;
        else
          v72 = v69 + 1;
        if (v71)
          v68 = (double *)v69;
        v69 = (_QWORD *)*v72;
      }
      while (*v72);
      v73 = 0.0;
      if (v68 != v4 && *((_QWORD *)v68 + 4) <= (unint64_t)"sei_bits")
        v73 = v68[5];
      v74 = v4;
      v75 = v5;
      do
      {
        v76 = v75[4];
        v77 = v76 >= (unint64_t)"min_frame_size";
        if (v76 >= (unint64_t)"min_frame_size")
          v78 = v75;
        else
          v78 = v75 + 1;
        if (v77)
          v74 = (double *)v75;
        v75 = (_QWORD *)*v78;
      }
      while (*v78);
      v79 = 0.0;
      if (v74 != v4 && *((_QWORD *)v74 + 4) <= (unint64_t)"min_frame_size")
        v79 = v74[5];
      v80 = v4;
      v81 = v5;
      do
      {
        v82 = v81[4];
        v83 = v82 >= (unint64_t)"dropped_frames";
        if (v82 >= (unint64_t)"dropped_frames")
          v84 = v81;
        else
          v84 = v81 + 1;
        if (v83)
          v80 = (double *)v81;
        v81 = (_QWORD *)*v84;
      }
      while (*v84);
      v85 = 0.0;
      if (v80 != v4 && *((_QWORD *)v80 + 4) <= (unint64_t)"dropped_frames")
        v85 = v80[5];
      v86 = v4;
      v87 = v5;
      do
      {
        v88 = v87[4];
        v89 = v88 >= (unint64_t)"idr_frames";
        if (v88 >= (unint64_t)"idr_frames")
          v90 = v87;
        else
          v90 = v87 + 1;
        if (v89)
          v86 = (double *)v87;
        v87 = (_QWORD *)*v90;
      }
      while (*v90);
      v91 = 0.0;
      if (v86 != v4 && *((_QWORD *)v86 + 4) <= (unint64_t)"idr_frames")
        v91 = v86[5];
      v92 = v4;
      v93 = v5;
      do
      {
        v94 = v93[4];
        v95 = v94 >= (unint64_t)"repeated_frames";
        if (v94 >= (unint64_t)"repeated_frames")
          v96 = v93;
        else
          v96 = v93 + 1;
        if (v95)
          v92 = (double *)v93;
        v93 = (_QWORD *)*v96;
      }
      while (*v96);
      v97 = 0.0;
      v98 = 0.0;
      if (v92 != v4 && *((_QWORD *)v92 + 4) <= (unint64_t)"repeated_frames")
        v98 = v92[5];
      v99 = v4;
      do
      {
        v100 = v5[4];
        v101 = v100 >= (unint64_t)"refresh_frames";
        if (v100 >= (unint64_t)"refresh_frames")
          v102 = v5;
        else
          v102 = v5 + 1;
        if (v101)
          v99 = (double *)v5;
        v5 = (_QWORD *)*v102;
      }
      while (*v102);
      if (v99 != v4 && *((_QWORD *)v99 + 4) <= (unint64_t)"refresh_frames")
        v97 = v99[5];
      v103 = v19 > 0.0;
      v105 = 0.0;
      v7 = 0.0;
      if (v19 > 0.0)
        v7 = v61 / v19 * 1000.0;
      v110 = v19 / a2;
      v111 = v25 / a2;
      v112 = v8 / a2;
      v104 = v37 / a2;
      if (v25 > 0.000001)
        v105 = v31 / v25;
    }
    else
    {
LABEL_181:
      v103 = 0;
      v104 = 0.0 / a2;
      v98 = 0.0;
      v85 = 0.0;
      v73 = 0.0;
      v49 = 0.0;
      v25 = 0.0;
      v43 = 0.0;
      v111 = 0.0 / a2;
      v112 = v8 / a2;
      v110 = 0.0 / a2;
      v55 = 0.0;
      v67 = 0;
      v79 = 0.0;
      v91 = 0.0;
      v97 = 0.0;
      v105 = 0.0;
    }
    v113 = v105;
    v114 = v7;
    v115 = v97;
    v116 = v67;
    v117 = v73;
    v157 = 0;
    v155 = 0u;
    v156 = 0u;
    *(_OWORD *)__str = 0u;
    if (v103 && v79 / v25 > 2.22044605e-16)
      snprintf(__str, 0x32uLL, "Min_frame_size=%.0f bytes, ", v79 / v25);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136450562;
      v119 = a1 + 152;
      v120 = 2048;
      v121 = v112;
      v122 = 2048;
      v123 = v110;
      v124 = 2048;
      v125 = v85 / a2;
      v126 = 2048;
      v127 = v98 / a2;
      v128 = 2048;
      v129 = v91 / a2;
      v130 = 2048;
      v131 = v115 / a2;
      v132 = 2048;
      v133 = v111;
      v134 = 2048;
      v135 = v113;
      v136 = 2048;
      v137 = v49 / a2 + v104 + v43 / a2 + v55 / a2;
      v138 = 2048;
      v139 = v116;
      v140 = 2048;
      v141 = v104 - v117 / a2;
      v142 = 2048;
      v143 = v55 / a2;
      v144 = 2048;
      v145 = v43 / a2;
      v146 = 2048;
      v147 = v117 / a2;
      v148 = 2048;
      v149 = v49 / a2;
      v150 = 2082;
      v151 = __str;
      v152 = 2048;
      v153 = v114;
      v106 = MEMORY[0x1E0C81028];
      v107 = "[VCPEncStatsMonitor] %{public}s: Input_fps=%.2f, Enc_fps=%.2f, drop_fps=%.2f, repeat_fps=%.2f, idr_fps=%.2f"
             ", refresh_fps=%.2f, Tx_fps=%.2f, Avg_QP=%.2f, Bit_rate (Total/Target/Video/FEC/Header/SEI/RTX)=%.0f/%.0f/%."
             "0f/%.0f/%.0f/%.0f/%0.f, %{public}sEnc_time=%.2f ms\n";
      v108 = 182;
LABEL_193:
      _os_log_impl(&dword_1B676B000, v106, OS_LOG_TYPE_DEFAULT, v107, buf, v108);
    }
  }
}

void sub_1B678AAF4(std::__assoc_sub_state *a1)
{
  void *ptr;
  std::exception_ptr v3;
  std::exception_ptr v4;
  std::exception_ptr v5;
  std::unique_lock<std::mutex> __lk;

  __lk.__m_ = &a1->__mut_;
  __lk.__owns_ = 1;
  std::mutex::lock(&a1->__mut_);
  std::__assoc_sub_state::__sub_wait(a1, &__lk);
  ptr = a1->__exception_.__ptr_;
  v5.__ptr_ = 0;
  std::exception_ptr::~exception_ptr(&v5);
  if (ptr)
  {
    std::exception_ptr::exception_ptr(&v4, &a1->__exception_);
    v3.__ptr_ = &v4;
    std::rethrow_exception(v3);
    __break(1u);
  }
  else if (__lk.__owns_)
  {
    std::mutex::unlock(__lk.__m_);
  }
}

void sub_1B678AB84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, char a12)
{
  std::exception_ptr::~exception_ptr((std::exception_ptr *)&a9);
  if (a12)
    std::mutex::unlock(a11);
  _Unwind_Resume(a1);
}

char *sub_1B678ABB0(uint64_t a1, CMSampleBufferRef *a2, uint64_t a3)
{
  OpaqueCMBlockBuffer *DataBuffer;
  char *result;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  unsigned __int8 *v15;
  int v16;
  char v17;
  char v18;
  uint64_t v19;
  int v20;
  int v21;
  char v22;
  int v23;
  int v24;
  int v25;
  int v26;
  char v27;
  int v28;
  size_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint8_t *v41;
  unsigned __int8 *v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  const __CFAllocator *v47;
  uint8_t buf[12];
  unsigned int sourceBytes;
  char *returnedPointerOut;
  CMBlockBufferRef blockBufferOut;
  size_t v52;
  size_t v53;
  _QWORD v54[2];

  v54[1] = *MEMORY[0x1E0C80C00];
  DataBuffer = CMSampleBufferGetDataBuffer(*a2);
  v53 = 0;
  v54[0] = 0;
  blockBufferOut = 0;
  v52 = 0;
  returnedPointerOut = 0;
  result = sub_1B685C8CC(*(char **)(a1 + 2192));
  if (result)
  {
    v8 = (uint64_t)result;
    v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2192) + 296))(*(_QWORD *)(a1 + 2192));
    v10 = 0;
    if (v9)
    {
      v11 = *(_DWORD *)(a1 + 24);
      if (v11 > 1718908519)
      {
        if (v11 == 1718908520)
          goto LABEL_13;
        v12 = 1752589105;
      }
      else
      {
        if (v11 == 1684632424)
          goto LABEL_13;
        v12 = 1685481521;
      }
      if (v11 != v12)
        v10 = 1;
LABEL_13:
      if (sub_1B685CADC(v8, *(_QWORD *)(a1 + 2192), v10, DataBuffer, v54, &v52, &v53, 0))
      {
        v15 = 0;
        goto LABEL_66;
      }
      goto LABEL_21;
    }
    v13 = *(_DWORD *)(a1 + 24);
    if (v13 > 1718908519)
    {
      if (v13 != 1718908520)
      {
        v14 = 1752589105;
LABEL_17:
        if (v13 != v14)
          v10 = 1;
      }
    }
    else if (v13 != 1684632424)
    {
      v14 = 1685481521;
      goto LABEL_17;
    }
    v15 = 0;
    if (sub_1B685CE28(DataBuffer, 4u, v10, &v52, &v53, 0))
    {
LABEL_66:
      result = (char *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
      if (v15)
        return (char *)MEMORY[0x1BCC9811C](v15, 0x1000C8077774924);
      return result;
    }
    v54[0] = 0;
LABEL_21:
    if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(a1 + 2192) + 80))(*(_QWORD *)(a1 + 2192))
      && *(_QWORD *)(a3 + 96))
    {
      v16 = 1 << (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2192) + 200))(*(_QWORD *)(a1 + 2192));
      v17 = *(_BYTE *)(v8 + 186);
      if (*(_BYTE *)(a3 + 80))
      {
        v18 = v17 | v16;
        v19 = *(_QWORD *)(a3 + 96);
      }
      else
      {
        v19 = 0;
        v18 = v17 & ~(_BYTE)v16;
      }
      *(_BYTE *)(v8 + 186) = v18;
      *(_QWORD *)(v8 + 88) = v19;
    }
    if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(a1 + 2192) + 88))(*(_QWORD *)(a1 + 2192)))
      *(_BYTE *)(v8 + 96) = *(_BYTE *)(a3 + 80);
    if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(a1 + 2192) + 96))(*(_QWORD *)(a1 + 2192)))
    {
      v20 = 1 << (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2192) + 216))(*(_QWORD *)(a1 + 2192));
      if (*(int *)(a1 + 72) >= 2 && *(_BYTE *)(a3 + 44))
      {
        v21 = *(_DWORD *)(a1 + 148);
        *(_WORD *)(v8 + 98) = *(_DWORD *)(a1 + 144);
        *(_WORD *)(v8 + 100) = v21;
        v22 = *(_BYTE *)(v8 + 186) | v20;
      }
      else
      {
        *(_DWORD *)(v8 + 98) = 0;
        v22 = *(_BYTE *)(v8 + 186) & ~(_BYTE)v20;
      }
      *(_BYTE *)(v8 + 186) = v22;
    }
    if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(a1 + 2192) + 112))(*(_QWORD *)(a1 + 2192)))
    {
      v23 = 1 << (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2192) + 232))(*(_QWORD *)(a1 + 2192));
      v24 = *(_DWORD *)(a3 + 160);
      if (v24 < 1 || (v25 = *(_DWORD *)(a3 + 164), v25 < 1))
      {
        v27 = *(_BYTE *)(v8 + 186) & ~(_BYTE)v23;
      }
      else
      {
        v26 = *(_DWORD *)(a3 + 156);
        *(_WORD *)(v8 + 104) = *(_DWORD *)(a3 + 152);
        *(_WORD *)(v8 + 106) = v26;
        *(_WORD *)(v8 + 108) = v24;
        *(_WORD *)(v8 + 110) = v25;
        v27 = *(_BYTE *)(v8 + 186) | v23;
      }
      *(_BYTE *)(v8 + 186) = v27;
    }
    v28 = v54[0];
    v29 = v53 - v54[0] - 3;
    v15 = (unsigned __int8 *)operator new[]();
    v30 = (*(uint64_t (**)(uint64_t, unsigned __int8 *, _QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)v8 + 136))(v8, v15, *(_QWORD *)(a1 + 2192), *(unsigned __int8 *)(v8 + 186), 3, (*(_DWORD *)(a3 + 168) - (_DWORD)v29) & ~((*(_DWORD *)(a3 + 168) - (int)v29) >> 31));
    v31 = CMBlockBufferAccessDataBytes(DataBuffer, v29, 3uLL, v15, &returnedPointerOut);
    if (!(_DWORD)v31)
    {
      v37 = 0;
      v38 = returnedPointerOut;
      do
      {
        returnedPointerOut = &v38[v37 + 1];
        v15[v37] = v38[v37];
        ++v37;
      }
      while (v37 != 3);
      MEMORY[0x1E0C80A78](v31, v32, v33, v34, v35, v36);
      v41 = &buf[-v40];
      if (*v15 || v15[1] || v15[2] != 3)
      {
        v42 = v15;
      }
      else
      {
        v42 = v15;
        if (v15[3] >= 4u)
        {
          v15[2] = 0;
          v39 = v30 + 2;
          v42 = v15 + 1;
        }
      }
      if (v39)
      {
        v43 = 0;
        v44 = 0;
        do
        {
          v45 = *v42;
          if (v44 == 2)
          {
            if (v45 > 3)
            {
              v44 = 2;
            }
            else
            {
              v44 = 0;
              v41[v43++] = 3;
            }
          }
          if (v45)
            v44 = 0;
          else
            ++v44;
          ++v42;
          v46 = v43 + 1;
          v41[v43++] = v45;
          --v39;
        }
        while (v39);
      }
      else
      {
        v46 = 0;
      }
      sourceBytes = bswap32(v53 - (v52 + v28) + v46 - 7);
      if (!CMBlockBufferReplaceDataBytes(&sourceBytes, DataBuffer, v52, 4uLL))
      {
        v47 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        if (!CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E0C9AE00], DataBuffer, 0, v29, 0, &blockBufferOut))
        {
          if (blockBufferOut)
          {
            CMBlockBufferAppendMemoryBlock(blockBufferOut, 0, v46, v47, 0, 0, v46, 1u);
            CMBlockBufferReplaceDataBytes(v41, blockBufferOut, v29, v46);
            if (sub_1B6786C00(a2, blockBufferOut))
            {
              if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "ReplaceBlockBufferInSampleBuffer failed", buf, 2u);
              }
            }
          }
        }
      }
      if (blockBufferOut)
        CFRelease(blockBufferOut);
    }
    goto LABEL_66;
  }
  return result;
}

void sub_1B678B174(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
  {
    std::mutex::unlock(*(std::mutex **)a1);
    *(_BYTE *)(a1 + 8) = 0;
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    sub_1B678B1B4();
  }
}

uint64_t sub_1B678B1B4(uint64_t a1)
{
  __CVBuffer *v2;
  const void *v3;
  unint64_t *v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t *v8;
  unint64_t v9;
  void **v11;

  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 216));
  v2 = *(__CVBuffer **)(a1 + 224);
  if (v2)
  {
    CVPixelBufferRelease(v2);
    *(_QWORD *)(a1 + 224) = 0;
  }
  v3 = *(const void **)(a1 + 264);
  if (v3)
    CFRelease(v3);
  v11 = (void **)(a1 + 272);
  sub_1B678B274(&v11);
  v4 = *(unint64_t **)(a1 + 248);
  if (v4)
  {
    v5 = v4 + 1;
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
      (*(void (**)(unint64_t *))(*v4 + 16))(v4);
  }
  v7 = *(unint64_t **)(a1 + 240);
  if (v7)
  {
    v8 = v7 + 1;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
      (*(void (**)(unint64_t *))(*v7 + 16))(v7);
  }
  std::future<void>::~future((std::future<void> *)(a1 + 232));
  return a1;
}

void sub_1B678B274(void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    sub_1B678B2B4((unint64_t *)v2);
    operator delete(**a1);
  }
}

unint64_t *sub_1B678B2B4(unint64_t *result)
{
  unint64_t *v1;
  unint64_t v2;
  unint64_t i;
  unint64_t *v4;
  unint64_t *v5;
  unint64_t v6;

  v1 = result;
  v2 = *result;
  for (i = result[1]; i != v2; i -= 8)
  {
    v4 = *(unint64_t **)(i - 8);
    result = v4;
    if (v4)
    {
      v5 = result + 1;
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
        result = (unint64_t *)(*(uint64_t (**)(unint64_t *))(*result + 16))(result);
    }
  }
  v1[1] = v2;
  return result;
}

CVPixelBufferPoolRef VCPCompressionSessionGetPixelBufferPool(uint64_t a1)
{
  return VTCompressionSessionGetPixelBufferPool(*(VTCompressionSessionRef *)(a1 + 16));
}

uint64_t VCPCompressionSessionCopyProperty(uint64_t a1, const __CFString *a2, const __CFAllocator *a3, void *a4)
{
  return VTSessionCopyProperty(*(VTSessionRef *)(a1 + 16), a2, a3, a4);
}

uint64_t VCPCompressionSessionCopySupportedPropertyDictionary(uint64_t a1, CFDictionaryRef *a2)
{
  return VTSessionCopySupportedPropertyDictionary(*(VTSessionRef *)(a1 + 16), a2);
}

__CFArray *VCPCompressionAllocateDPB(const __CFDictionary *a1, int a2, unsigned int a3, unsigned int a4)
{
  const void *Value;
  const void *v9;
  const void *v10;
  const void *v11;
  CFTypeID TypeID;
  BOOL v13;
  CFTypeID v14;
  BOOL v15;
  CFTypeID v16;
  uint64_t v17;
  int v18;
  int AppBooleanValue;
  _BOOL4 v22;
  int v23;
  int32x2_t v24;
  int v25;
  __CFArray *Mutable;
  const __CFDictionary *v28;
  OSType v29;
  unsigned int v30;
  unsigned int v31;
  __CFDictionary *v32;
  __CFDictionary *v33;
  int v34;
  int v35;
  int v36;
  char v37;
  const __CFString *v38;
  int v39;
  int v40;
  IOSurfaceRef IOSurface;
  __IOSurface *v42;
  __IOSurface *v43;
  unsigned __int8 v44;
  int32x2_t v45;
  int32x2_t v46;
  int v47;
  OSType pixelFormatType;
  uint64_t valuePtr;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _DWORD v53[2];
  uint8_t v54[4];
  int v55;
  signed int v56;
  _BYTE buf[12];
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  Value = CFDictionaryGetValue(a1, (const void *)*MEMORY[0x1E0CED2C0]);
  v9 = CFDictionaryGetValue(a1, (const void *)*MEMORY[0x1E0CED2B8]);
  v10 = CFDictionaryGetValue(a1, CFSTR("DPBPixelFormat"));
  if (!Value
    || ((v11 = v10, TypeID = CFNumberGetTypeID(), TypeID == CFGetTypeID(Value)) ? (v13 = v9 == 0) : (v13 = 1),
        v13
     || ((v14 = CFBooleanGetTypeID(), v14 == CFGetTypeID(v9)) ? (v15 = v11 == 0) : (v15 = 1),
         v15 || (v16 = CFNumberGetTypeID(), v16 != CFGetTypeID(v11)))))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = a1;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VCPCompressionAllocateDPB: invalid desc %@\n", buf, 0xCu);
    }
    return 0;
  }
  v51 = 0;
  v52 = 0;
  valuePtr = 0;
  v50 = 0;
  CFNumberGetValue((CFNumberRef)Value, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberGetValue((CFNumberRef)v11, kCFNumberSInt32Type, &valuePtr);
  v47 = CFBooleanGetValue((CFBooleanRef)v9);
  v17 = valuePtr;
  if (qword_1EDBB4CB8 != -1)
    dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
  v18 = dword_1EDBB4CC4;
  AppBooleanValue = CFPreferencesGetAppBooleanValue(CFSTR("corevideo_dpb_alloc"), CFSTR("com.apple.VideoProcessing"), 0);
  v22 = v18 > 12 && v47 == 0 || AppBooleanValue != 0;
  v23 = sub_1B67C37F4(v17);
  if (a2 == 1752589105)
  {
    v25 = 0;
    v24 = vmax_s32((int32x2_t)(*(_QWORD *)&vadd_s32((int32x2_t)__PAIR64__(a4, a3), (int32x2_t)0x1F0000001FLL) & 0xFFFFFFE0FFFFFFE0), (int32x2_t)0x40000000A0);
    if (v22)
      goto LABEL_33;
    goto LABEL_31;
  }
  if (a2 != 1635148593)
  {
    v25 = 0;
    v24 = 0;
    if (v22)
      goto LABEL_33;
LABEL_31:
    v28 = 0;
    pixelFormatType = 0;
    goto LABEL_40;
  }
  v24 = vmax_s32((int32x2_t)(*(_QWORD *)&vadd_s32((int32x2_t)__PAIR64__(a4, a3), (int32x2_t)0xF0000000FLL) & 0xFFFFFFF0FFFFFFF0), (int32x2_t)0x60000000C0);
  v25 = 1;
  if (!v22)
    goto LABEL_31;
LABEL_33:
  v45 = v24;
  v29 = sub_1B6828FE0(v17);
  v30 = v45.i32[0];
  v31 = v45.u32[1];
  v32 = sub_1B6829458(v45.i32[0], v45.i32[1], v25);
  v28 = v32;
  pixelFormatType = v29;
  if (v29 && v32)
  {
    v33 = 0;
    v34 = 1;
    goto LABEL_47;
  }
  if (dword_1EF137CD0 >= 3 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v17;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Not using CoreVideo to allocate DPB for pixfmt %d", buf, 8u);
  }
  v24 = v45;
LABEL_40:
  if (qword_1EDBB4CB8 != -1)
  {
    v46 = v24;
    dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
    v24 = v46;
  }
  v30 = v24.i32[0];
  v31 = v24.u32[1];
  v35 = sub_1B6828970(v24.i32[0], v24.i32[1], dword_1EDBB4CC4, v25, v17, (signed int *)buf, &v56, (_DWORD *)&v52 + 1, &v52, (unsigned int *)&v51 + 1, (unsigned int *)&v51, (_DWORD *)&v50 + 1, (unsigned int *)&v50);
  if (!v35)
  {
    *(_DWORD *)v54 = HIDWORD(v52);
    v55 = v52;
    v53[0] = HIDWORD(v51);
    v53[1] = v51;
    v33 = sub_1B68297D4(v30, v31, v25, v23, v17, (uint64_t)v54, (uint64_t)v53, 0);
    v34 = 0;
LABEL_47:
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    v37 = 0;
    v38 = (const __CFString *)*MEMORY[0x1E0CBC048];
    v39 = HIDWORD(valuePtr);
    while (v39 < 1)
    {
LABEL_62:
      v44 = v37 ^ 1;
      v37 = 1;
      if (((v47 != 0) & v44) == 0)
      {
        v36 = 0;
        goto LABEL_65;
      }
    }
    v40 = 0;
    while (1)
    {
      if (v34)
      {
        *(_QWORD *)buf = 0;
        if (CVPixelBufferCreate(0, v30, v31, pixelFormatType, v28, (CVPixelBufferRef *)buf))
          goto LABEL_64;
        IOSurface = CVPixelBufferGetIOSurface(*(CVPixelBufferRef *)buf);
        v42 = IOSurface;
        if (IOSurface)
          CFRetain(IOSurface);
        CFRelease(*(CFTypeRef *)buf);
      }
      else
      {
        v43 = IOSurfaceCreate(v33);
        if (!v43)
        {
LABEL_64:
          v36 = 1;
          goto LABEL_65;
        }
        v42 = v43;
        IOSurfaceSetValue(v43, v38, CFSTR("dpb"));
        if ((v37 & 1) != 0)
        {
          if (qword_1EDBB4CB8 != -1)
            dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
          if (dword_1EDBB4CC4 <= 12)
            sub_1B682AE50(v42, v50, SBYTE4(v50));
        }
      }
      CFArrayAppendValue(Mutable, v42);
      CFRelease(v42);
      ++v40;
      v39 = HIDWORD(valuePtr);
      if (v40 >= SHIDWORD(valuePtr))
        goto LABEL_62;
    }
  }
  v36 = v35;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v54 = 0;
    _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Failed to calculate recon buffer size\n", v54, 2u);
  }
  Mutable = 0;
  v33 = 0;
LABEL_65:
  if (v28)
    CFRelease(v28);
  if (v33)
    CFRelease(v33);
  if (v36 && Mutable)
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t VCPAVEContextCreate(int a1, int a2, int a3)
{
  uint64_t result;

  result = operator new();
  *(_DWORD *)result = a1;
  *(_DWORD *)(result + 4) = a2;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 8) = a3;
  *(_DWORD *)(result + 44) = 1;
  *(_QWORD *)(result + 48) = 0;
  return result;
}

uint64_t VCPAVEContextRelease(uint64_t result)
{
  if (result)
  {
    sub_1B6773DE4((const void **)(result + 48));
    JUMPOUT(0x1BCC9814CLL);
  }
  return result;
}

uint64_t VCPAVEScaleReferenceFrames(_DWORD *a1, CFDictionaryRef theDict)
{
  const __CFArray *Value;
  CFIndex v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const __CFDictionary *ValueAtIndex;
  const __CFBoolean *v9;
  const __CFNumber *v10;
  const __CFNumber *v11;
  CFTypeID v12;
  const __CFNumber *v13;
  const __CFNumber *v14;
  CFTypeID v15;
  const __CFNumber *v16;
  const __CFNumber *v17;
  CFTypeID v18;
  int v19;
  const __CFNumber *v20;
  const __CFNumber *v21;
  CFTypeID v22;
  const __CFNumber *v23;
  const __CFNumber *v24;
  CFTypeID v25;
  const __CFDictionary *v26;
  const __CFNumber *v27;
  const __CFNumber *v28;
  CFTypeID v29;
  const __CFNumber *v30;
  const __CFNumber *v31;
  CFTypeID v32;
  const __CFNumber *v33;
  const __CFNumber *v34;
  CFTypeID v35;
  const __CFNumber *v36;
  const __CFNumber *v37;
  CFTypeID v38;
  const __CFNumber *v39;
  const __CFNumber *v40;
  CFTypeID v41;
  const __CFDictionary *v42;
  const __CFNumber *v43;
  const __CFNumber *v44;
  CFTypeID v45;
  const __CFNumber *v46;
  const __CFNumber *v47;
  CFTypeID v48;
  const __CFNumber *v49;
  const __CFNumber *v50;
  CFTypeID v51;
  const __CFDictionary *v52;
  const __CFNumber *v53;
  const __CFNumber *v54;
  CFTypeID v55;
  const __CFNumber *v56;
  const __CFNumber *v57;
  CFTypeID v58;
  const __CFNumber *v59;
  const __CFNumber *v60;
  CFTypeID v61;
  int v62;
  int v63;
  unsigned int v64;
  unsigned int v65;
  _QWORD *v66;
  uint64_t v67;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  void *key;
  const void *v80;
  const void *v81;
  const void *v82;
  IOSurfaceID v83;
  _DWORD v84[5];
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unsigned __int16 v88;
  unsigned __int16 v89;
  unsigned __int16 v90;
  unsigned __int16 v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  _QWORD v96[3];
  _QWORD *v97;
  uint64_t v98;

  v98 = *MEMORY[0x1E0C80C00];
  Value = (const __CFArray *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E0CED4F8]);
  v4 = 0;
  v82 = (const void *)*MEMORY[0x1E0CED520];
  v81 = (const void *)*MEMORY[0x1E0CED528];
  v80 = (const void *)*MEMORY[0x1E0CED550];
  key = (void *)*MEMORY[0x1E0CED540];
  v78 = (void *)*MEMORY[0x1E0CED538];
  v77 = (void *)*MEMORY[0x1E0CED558];
  v76 = (void *)*MEMORY[0x1E0CED560];
  v75 = (void *)*MEMORY[0x1E0CED580];
  v74 = (void *)*MEMORY[0x1E0CED570];
  v73 = (void *)*MEMORY[0x1E0CED568];
  v72 = (void *)*MEMORY[0x1E0CED578];
  v71 = (void *)*MEMORY[0x1E0CED530];
  v5 = (const void *)*MEMORY[0x1E0CED518];
  v6 = (const void *)*MEMORY[0x1E0CED500];
  v7 = (const void *)*MEMORY[0x1E0CED510];
  v69 = (void *)*MEMORY[0x1E0CED508];
  v70 = (void *)*MEMORY[0x1E0CED548];
  while (CFArrayGetCount(Value) > v4)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, v4);
    v9 = (const __CFBoolean *)CFDictionaryGetValue(ValueAtIndex, CFSTR("DelayedRVRAScale"));
    if (!CFBooleanGetValue(v9))
      goto LABEL_67;
    v10 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, v82);
    v11 = v10;
    if (v10)
    {
      v12 = CFGetTypeID(v10);
      if (v12 == CFNumberGetTypeID())
        CFNumberGetValue(v11, kCFNumberSInt32Type, &v85);
    }
    v13 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, v81);
    v14 = v13;
    if (v13)
    {
      v15 = CFGetTypeID(v13);
      if (v15 == CFNumberGetTypeID())
        CFNumberGetValue(v14, kCFNumberSInt32Type, (char *)&v85 + 4);
    }
    v95 = 0;
    v16 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, v80);
    v17 = v16;
    if (v16 && (v18 = CFGetTypeID(v16), v18 == CFNumberGetTypeID()))
    {
      CFNumberGetValue(v17, kCFNumberSInt32Type, &v95);
      v19 = v95;
    }
    else
    {
      v19 = 0;
    }
    v84[3] = v19;
    v20 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, key);
    v21 = v20;
    if (v20)
    {
      v22 = CFGetTypeID(v20);
      if (v22 == CFNumberGetTypeID())
        CFNumberGetValue(v21, kCFNumberSInt64Type, &v87);
    }
    v23 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, v78);
    v24 = v23;
    if (v23)
    {
      v25 = CFGetTypeID(v23);
      if (v25 == CFNumberGetTypeID())
        CFNumberGetValue(v24, kCFNumberSInt32Type, &v86);
    }
    v26 = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, v77);
    v27 = (const __CFNumber *)CFDictionaryGetValue(v26, v76);
    v28 = v27;
    if (v27)
    {
      v29 = CFGetTypeID(v27);
      if (v29 == CFNumberGetTypeID())
        CFNumberGetValue(v28, kCFNumberSInt32Type, &v92);
    }
    v30 = (const __CFNumber *)CFDictionaryGetValue(v26, v75);
    v31 = v30;
    if (v30)
    {
      v32 = CFGetTypeID(v30);
      if (v32 == CFNumberGetTypeID())
        CFNumberGetValue(v31, kCFNumberSInt32Type, (char *)&v92 + 4);
    }
    v33 = (const __CFNumber *)CFDictionaryGetValue(v26, v74);
    v34 = v33;
    if (v33)
    {
      v35 = CFGetTypeID(v33);
      if (v35 == CFNumberGetTypeID())
        CFNumberGetValue(v34, kCFNumberSInt32Type, &v93);
    }
    v36 = (const __CFNumber *)CFDictionaryGetValue(v26, v73);
    v37 = v36;
    if (v36)
    {
      v38 = CFGetTypeID(v36);
      if (v38 == CFNumberGetTypeID())
        CFNumberGetValue(v37, kCFNumberSInt32Type, (char *)&v93 + 4);
    }
    v39 = (const __CFNumber *)CFDictionaryGetValue(v26, v72);
    v40 = v39;
    if (v39)
    {
      v41 = CFGetTypeID(v39);
      if (v41 == CFNumberGetTypeID())
        CFNumberGetValue(v40, kCFNumberSInt32Type, &v94);
    }
    v42 = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, v71);
    v43 = (const __CFNumber *)CFDictionaryGetValue(v42, v5);
    v44 = v43;
    if (v43)
    {
      v45 = CFGetTypeID(v43);
      if (v45 == CFNumberGetTypeID())
        CFNumberGetValue(v44, kCFNumberSInt16Type, &v88);
    }
    v46 = (const __CFNumber *)CFDictionaryGetValue(v42, v6);
    v47 = v46;
    if (v46)
    {
      v48 = CFGetTypeID(v46);
      if (v48 == CFNumberGetTypeID())
        CFNumberGetValue(v47, kCFNumberSInt16Type, &v90);
    }
    if (CFDictionaryContainsKey(v42, v7))
    {
      v49 = (const __CFNumber *)CFDictionaryGetValue(v42, v7);
      v50 = v49;
      if (!v49)
        goto LABEL_47;
    }
    else
    {
      v49 = (const __CFNumber *)CFDictionaryGetValue(v42, v69);
      v50 = v49;
      if (!v49)
        goto LABEL_47;
    }
    v51 = CFGetTypeID(v49);
    if (v51 == CFNumberGetTypeID())
      CFNumberGetValue(v50, kCFNumberSInt32Type, &v83);
LABEL_47:
    v52 = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, v70);
    v53 = (const __CFNumber *)CFDictionaryGetValue(v52, v5);
    v54 = v53;
    if (v53)
    {
      v55 = CFGetTypeID(v53);
      if (v55 == CFNumberGetTypeID())
        CFNumberGetValue(v54, kCFNumberSInt16Type, &v89);
    }
    v56 = (const __CFNumber *)CFDictionaryGetValue(v52, v6);
    v57 = v56;
    if (v56)
    {
      v58 = CFGetTypeID(v56);
      if (v58 == CFNumberGetTypeID())
        CFNumberGetValue(v57, kCFNumberSInt16Type, &v91);
    }
    if (CFDictionaryContainsKey(v52, v7))
    {
      v59 = (const __CFNumber *)CFDictionaryGetValue(v52, v7);
      v60 = v59;
      if (!v59)
        goto LABEL_59;
    }
    else
    {
      v59 = (const __CFNumber *)CFDictionaryGetValue(v52, v69);
      v60 = v59;
      if (!v59)
        goto LABEL_59;
    }
    v61 = CFGetTypeID(v59);
    if (v61 == CFNumberGetTypeID())
      CFNumberGetValue(v60, kCFNumberSInt32Type, v84);
LABEL_59:
    sub_1B682B7A4((uint64_t)a1, v83);
    v62 = a1[1];
    if (*a1 == 1752589105)
      v63 = 1752589105;
    else
      v63 = 1635148593;
    v64 = a1[3];
    v65 = a1[4];
    v96[0] = &off_1E6A14620;
    v96[1] = a1;
    v97 = v96;
    sub_1B68274B4(&v83, v63, (uint64_t)(a1 + 5), (uint64_t)(a1 + 7), (uint64_t)(a1 + 9), v64, v65, (uint64_t)v96, v62, v88, v90, v89, v91);
    v66 = v97;
    if (v97 == v96)
    {
      v66 = v96;
      v67 = 4;
    }
    else
    {
      if (!v97)
        goto LABEL_67;
      v67 = 5;
    }
    (*(void (**)(void))(*v66 + 8 * v67))();
LABEL_67:
    ++v4;
  }
  return 0;
}

void sub_1B678C0EC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  _QWORD *v3;
  uint64_t v4;

  v3 = *(_QWORD **)(v1 - 104);
  if (v3 == (_QWORD *)(v1 - 128))
  {
    v4 = 4;
    v3 = (_QWORD *)(v1 - 128);
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t VCPAVEExtraInloopChromaFilter(int a1, CFDictionaryRef theDict, int a3, int a4)
{
  const __CFArray *Value;
  CFIndex v7;
  const void *v8;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *v10;
  const __CFNumber *v11;
  CFTypeID v12;
  const __CFDictionary *v13;
  const void *v14;
  const __CFDictionary *v15;
  const void *v16;
  const __CFNumber *v17;
  const __CFNumber *v18;
  CFTypeID v19;
  __CVBuffer *v20;
  int Width;
  size_t BytesPerRowOfPlane;
  int v23;
  int v24;
  unsigned __int8 v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  _BYTE *v29;
  _BYTE *v30;
  uint64_t v31;
  __CVBuffer *pixelBuffer;
  int v34;
  _BYTE *BaseAddressOfPlane;
  int Height;
  __IOSurface *v37;
  CFTypeRef cf;
  IOSurfaceID valuePtr[6];
  _DWORD v40[14];

  Value = (const __CFArray *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E0CED4F8]);
  v7 = 0;
  v8 = (const void *)*MEMORY[0x1E0CED520];
  while (CFArrayGetCount(Value) > v7)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, v7);
    v10 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, v8);
    if (v10)
    {
      v11 = v10;
      v12 = CFGetTypeID(v10);
      if (v12 == CFNumberGetTypeID())
        CFNumberGetValue(v11, kCFNumberSInt32Type, v40);
    }
    if (v40[0] == a3)
    {
      v13 = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CED530]);
      v14 = (const void *)*MEMORY[0x1E0CED510];
      if (CFDictionaryContainsKey(v13, (const void *)*MEMORY[0x1E0CED510]))
      {
        v15 = v13;
        v16 = v14;
      }
      else
      {
        v16 = (const void *)*MEMORY[0x1E0CED508];
        v15 = v13;
      }
      v17 = (const __CFNumber *)CFDictionaryGetValue(v15, v16);
      if (v17)
      {
        v18 = v17;
        v19 = CFGetTypeID(v17);
        if (v19 == CFNumberGetTypeID())
          CFNumberGetValue(v18, kCFNumberSInt32Type, valuePtr);
      }
      cf = 0;
      v37 = IOSurfaceLookup(valuePtr[0]);
      CVPixelBufferCreateWithIOSurface(0, v37, 0, (CVPixelBufferRef *)&cf);
      v20 = (__CVBuffer *)cf;
      Width = CVPixelBufferGetWidth((CVPixelBufferRef)cf);
      Height = CVPixelBufferGetHeight(v20);
      BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v20, 1uLL);
      if (a4 >= 51)
        v23 = 51;
      else
        v23 = a4;
      if (v23 <= 15)
        v23 = 15;
      v24 = v23 - 15;
      v25 = byte_1B692B685[v24];
      v26 = byte_1B692B6B6[v24];
      CVPixelBufferLockBaseAddress(v20, 0);
      BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(v20, 1uLL);
      if (v26)
      {
        pixelBuffer = v20;
        if (Width >= 2)
        {
          v27 = 0;
          v34 = Height >> 1;
          v28 = Width >> 1;
          v29 = &BaseAddressOfPlane[4 * BytesPerRowOfPlane];
          do
          {
            if ((v27 | 4) < v28)
              sub_1B67F4FDC(&BaseAddressOfPlane[2 * (v27 | 4)], BytesPerRowOfPlane, v25, v26, v34);
            v27 += 8;
            if (v27 < v28)
              sub_1B67F4FDC(&BaseAddressOfPlane[2 * v27], BytesPerRowOfPlane, v25, v26, v34);
            if (Height >= 10)
            {
              v30 = v29;
              v31 = 4;
              do
              {
                sub_1B67F5070(v30, BytesPerRowOfPlane, v25, v26, 8);
                v31 += 4;
                v30 += 4 * BytesPerRowOfPlane;
              }
              while (v31 < v34);
            }
            v29 += 16;
          }
          while (v27 < v28);
        }
        CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
      }
      sub_1B682BB38((const void **)&v37);
      sub_1B6773B7C(&cf);
      return 0;
    }
    ++v7;
  }
  return 0;
}

void sub_1B678C428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  sub_1B6773B7C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t VCPAVECalculateFrameChecksum(_DWORD *a1, CFDictionaryRef theDict, int a3, int a4, __CFDictionary *a5)
{
  const __CFArray *Value;
  CFIndex v9;
  const void *v10;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *v12;
  const __CFNumber *v13;
  CFTypeID v14;
  const __CFDictionary *v15;
  const void *v16;
  const __CFNumber *v17;
  const __CFNumber *v18;
  CFTypeID v19;
  char v20;
  int v21;
  CFNumberRef v22;
  unsigned __int16 v24;
  __IOSurface *v25;
  CFTypeRef cf;
  IOSurfaceID valuePtr[6];
  _DWORD v28[15];
  int v29;
  CFNumberRef v30;
  _DWORD v31[2];
  _DWORD v32[2];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    Value = (const __CFArray *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E0CED4F8]);
    v9 = 0;
    v10 = (const void *)*MEMORY[0x1E0CED520];
    while (1)
    {
      if (CFArrayGetCount(Value) <= v9)
        return 0;
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, v9);
      v12 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, v10);
      v13 = v12;
      if (v12)
      {
        v14 = CFGetTypeID(v12);
        if (v14 == CFNumberGetTypeID())
          CFNumberGetValue(v13, kCFNumberSInt32Type, v28);
      }
      if (v28[0] == a3)
        break;
      ++v9;
    }
    v15 = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CED530]);
    v16 = (const void *)*MEMORY[0x1E0CED510];
    if (CFDictionaryContainsKey(v15, (const void *)*MEMORY[0x1E0CED510]))
    {
      v17 = (const __CFNumber *)CFDictionaryGetValue(v15, v16);
      v18 = v17;
      if (v17)
      {
LABEL_13:
        v19 = CFGetTypeID(v17);
        if (v19 == CFNumberGetTypeID())
          CFNumberGetValue(v18, kCFNumberSInt32Type, valuePtr);
      }
    }
    else
    {
      v17 = (const __CFNumber *)CFDictionaryGetValue(v15, (const void *)*MEMORY[0x1E0CED508]);
      v18 = v17;
      if (v17)
        goto LABEL_13;
    }
    cf = 0;
    v25 = IOSurfaceLookup(valuePtr[0]);
    CVPixelBufferCreateWithIOSurface(0, v25, 0, (CVPixelBufferRef *)&cf);
    sub_1B682B7A4((uint64_t)a1, valuePtr[0]);
    v24 = 0;
    v20 = a1[11];
    v21 = a1[2];
    v32[0] = a1[1];
    v32[1] = 2 * (v32[0] >> v20);
    v31[0] = v21;
    v31[1] = v21 >> v20;
    sub_1B6825974(valuePtr[0], &v24, (uint64_t)v32, (uint64_t)v31, (uint64_t)(a1 + 5), a1[3], a1[4]);
    v29 = v24;
    v22 = CFNumberCreate(0, kCFNumberSInt32Type, &v29);
    v30 = v22;
    if (v22)
      CFDictionaryAddValue(a5, (const void *)*MEMORY[0x1E0CEDA78], v22);
    sub_1B6770598((const void **)&v30);
    sub_1B682BB38((const void **)&v25);
    sub_1B6773B7C(&cf);
  }
  return 0;
}

void sub_1B678C6D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v3;
  va_list va;
  const void *v5;
  va_list va1;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v5 = va_arg(va2, const void *);
  v7 = va_arg(va2, _QWORD);
  v8 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  sub_1B6770598((const void **)va2);
  sub_1B682BB38((const void **)va);
  sub_1B6773B7C((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B678C718(uint64_t a1, CFDictionaryRef theDict, int a3, uint64_t a4)
{
  const __CFArray *Value;
  const __CFArray *v8;
  CFIndex Count;
  CGSize *v10;
  CGSize *v11;
  CGSize *v12;
  CFIndex v13;
  unsigned int i;
  const __CFDictionary *ValueAtIndex;
  CGSize v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  CGSize size;
  CGSize *v22;
  CGSize *v23;
  CGSize v24;
  char *v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  CGSize *v30;
  double height;
  char v32;
  uint64_t v33;
  CGRect v35;

  if (!theDict)
    return 4294954394;
  Value = (const __CFArray *)CFDictionaryGetValue(theDict, CFSTR("DirtyRegionArray"));
  v8 = Value;
  if (!Value)
    return 0;
  Count = CFArrayGetCount(Value);
  if (Count < 1)
    return 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  for (i = 0; i < Count; v13 = ++i)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v8, v13);
    if (!ValueAtIndex || !CGRectMakeWithDictionaryRepresentation(ValueAtIndex, &v35))
    {
      v33 = 4294954394;
      if (!v10)
        return v33;
      goto LABEL_45;
    }
    if (v11 >= v12)
    {
      v17 = ((char *)v11 - (char *)v10) >> 5;
      v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 59)
        sub_1B6773BAC();
      if (v12 - v10 > v18)
        v18 = v12 - v10;
      if ((unint64_t)((char *)v12 - (char *)v10) >= 0x7FFFFFFFFFFFFFE0)
        v19 = 0x7FFFFFFFFFFFFFFLL;
      else
        v19 = v18;
      if (v19)
      {
        if (v19 >> 59)
          sub_1B6773BF4();
        v20 = (char *)operator new(32 * v19);
      }
      else
      {
        v20 = 0;
      }
      size = v35.size;
      v22 = (CGSize *)&v20[32 * v17];
      *v22 = (CGSize)v35.origin;
      v22[1] = size;
      if (v11 == v10)
      {
        v25 = &v20[32 * v17];
      }
      else
      {
        v23 = (CGSize *)&v20[32 * v17];
        do
        {
          v24 = v11[-1];
          v25 = (char *)&v23[-2];
          v23[-2] = v11[-2];
          v23[-1] = v24;
          v11 -= 2;
          v23 -= 2;
        }
        while (v11 != v10);
      }
      v12 = (CGSize *)&v20[32 * v19];
      v11 = v22 + 2;
      if (v10)
        operator delete(v10);
      v10 = (CGSize *)v25;
    }
    else
    {
      v16 = v35.size;
      *v11 = (CGSize)v35.origin;
      v11[1] = v16;
      v11 += 2;
    }
  }
  if (v11 != v10 && *(int *)(a1 + 72) >= 1)
  {
    v26 = 0;
    do
    {
      v27 = *(_DWORD *)(a1 + 64);
      v28 = v27 * v26;
      if (a3 - v27 * (int)v26 < v27)
        v27 = a3 - v27 * v26;
      v29 = v27 + v28;
      v30 = v10;
      while (1)
      {
        height = v30->height;
        if (v29 >= (int)height && v28 <= (int)(height + v30[1].height))
          break;
        v30 += 2;
        if (v30 == v11)
        {
          v32 = 0;
          goto LABEL_39;
        }
      }
      v32 = 1;
LABEL_39:
      *(_BYTE *)(a4 + v26++) = v32;
    }
    while (v26 < *(int *)(a1 + 72));
  }
  v33 = 0;
  if (v10)
LABEL_45:
    operator delete(v10);
  return v33;
}

void sub_1B678C95C(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B678C978(uint64_t a1, uint64_t a2, __CVBuffer *a3)
{
  VTSessionRef *v6;
  __CVPixelBufferPool *PixelBufferPool;
  CVPixelBufferRef *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  const char *v14;
  int v15;
  int Width;
  int Height;
  int v18;
  int v19;
  double v20;
  double v21;
  BOOL v22;
  float v23;
  double v24;
  double v25;
  float v26;
  float v27;
  float v28;
  float v29;
  int v30;
  int v31;
  float v32;
  float v33;
  float v34;
  float v35;
  CFDictionaryRef DictionaryRepresentation;
  CFDictionaryRef v37;
  int v38;
  int v39;
  int v40;
  const char *v41;
  int v42;
  int v43;
  int v44;
  int v45;
  const char *v46;
  int v47;
  int v49;
  uint64_t v50;
  __int16 v51;
  int v52;
  __int16 v53;
  int v54;
  __int16 v55;
  const char *v56;
  uint64_t v57;
  CGRect v58;
  CGRect v59;

  v57 = *MEMORY[0x1E0C80C00];
  v6 = (VTSessionRef *)(a1 + 2320);
  if (*(_QWORD *)(a1 + 2320)
    || (v10 = VTPixelTransferSessionCreate(0, (VTPixelTransferSessionRef *)v6), !(_DWORD)v10))
  {
    PixelBufferPool = VTCompressionSessionGetPixelBufferPool(*(VTCompressionSessionRef *)(a1 + 16));
    v8 = (CVPixelBufferRef *)(a2 + 224);
    if (CVPixelBufferPoolCreatePixelBuffer(0, PixelBufferPool, (CVPixelBufferRef *)(a2 + 224)))
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        return 4294954394;
      v44 = *(_DWORD *)(a1 + 60);
      v43 = *(_DWORD *)(a1 + 64);
      v45 = *(_DWORD *)(a1 + 24);
      v46 = "H.264";
      if (v45 > 1718908519)
      {
        if (v45 == 1752589105)
          goto LABEL_45;
        v47 = 1718908520;
      }
      else
      {
        if (v45 == 1684632424)
          goto LABEL_45;
        v47 = 1685481521;
      }
      if (v45 != v47)
      {
LABEL_46:
        v49 = 134218754;
        v50 = a1;
        v51 = 1024;
        v52 = v44;
        v53 = 1024;
        v54 = v43;
        v55 = 2080;
        v56 = v46;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VCPEnc %p (%dx%d, %s): Encoder failed to create copied_image_buffer_\n", (uint8_t *)&v49, 0x22u);
        return 4294954394;
      }
LABEL_45:
      v46 = "HEVC";
      goto LABEL_46;
    }
    Width = CVPixelBufferGetWidth(a3);
    Height = CVPixelBufferGetHeight(a3);
    if (*(int *)(a2 + 160) <= 0)
      v18 = Width;
    else
      v18 = *(_DWORD *)(a2 + 160);
    if (*(int *)(a2 + 164) <= 0)
      v19 = Height;
    else
      v19 = *(_DWORD *)(a2 + 164);
    v20 = (double)v18;
    v21 = (double)v19;
    v22 = v18 <= Width && v19 <= Height;
    v23 = (float)v18;
    v24 = (double)v18;
    v25 = (double)v19;
    if (!v22)
    {
      v26 = (float)Width;
      v27 = (float)Width / v23;
      v28 = (float)Height / (float)v19;
      if (v27 >= v28)
        v26 = v28 * v23;
      v24 = v26;
      v29 = v27 * (float)v19;
      if (v27 >= v28)
        v29 = (float)Height;
      v25 = v29;
    }
    v30 = CVPixelBufferGetWidth(*v8);
    v31 = CVPixelBufferGetHeight(*v8);
    if (v18 > v30 || v19 > v31)
    {
      v32 = (float)v30;
      v33 = (float)v30 / v23;
      v34 = (float)v31 / (float)v19;
      if (v33 >= v34)
        v32 = v34 * v23;
      v20 = v32;
      v35 = v33 * (float)v19;
      if (v33 >= v34)
        v35 = (float)v31;
      v21 = v35;
    }
    v58.origin.x = 0.0;
    v58.origin.y = 0.0;
    v58.size.width = v24;
    v58.size.height = v25;
    DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v58);
    v9 = VTSessionSetProperty(*v6, (CFStringRef)*MEMORY[0x1E0CED850], DictionaryRepresentation);
    if ((_DWORD)v9)
      return v9;
    CFRelease(DictionaryRepresentation);
    v59.origin.x = 0.0;
    v59.origin.y = 0.0;
    v59.size.width = v20;
    v59.size.height = v21;
    v37 = CGRectCreateDictionaryRepresentation(v59);
    v9 = VTSessionSetProperty(*v6, (CFStringRef)*MEMORY[0x1E0CED7D0], v37);
    if ((_DWORD)v9)
      return v9;
    CFRelease(v37);
    if (!VTPixelTransferSessionTransferImage((VTPixelTransferSessionRef)*v6, a3, *v8))
      return 0;
    CVPixelBufferRelease(*v8);
    *v8 = 0;
    v9 = 0;
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      return v9;
    v39 = *(_DWORD *)(a1 + 60);
    v38 = *(_DWORD *)(a1 + 64);
    v40 = *(_DWORD *)(a1 + 24);
    v41 = "H.264";
    if (v40 > 1718908519)
    {
      if (v40 == 1752589105)
        goto LABEL_55;
      v42 = 1718908520;
    }
    else
    {
      if (v40 == 1684632424)
        goto LABEL_55;
      v42 = 1685481521;
    }
    if (v40 != v42)
    {
LABEL_56:
      v49 = 134218754;
      v50 = a1;
      v51 = 1024;
      v52 = v39;
      v53 = 1024;
      v54 = v38;
      v55 = 2080;
      v56 = v41;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Encoder failed to copy input source to copied_image_buffer_\n", (uint8_t *)&v49, 0x22u);
      return 0;
    }
LABEL_55:
    v41 = "HEVC";
    goto LABEL_56;
  }
  v9 = v10;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v12 = *(_DWORD *)(a1 + 60);
    v11 = *(_DWORD *)(a1 + 64);
    v13 = *(_DWORD *)(a1 + 24);
    v14 = "H.264";
    if (v13 > 1718908519)
    {
      if (v13 == 1752589105)
        goto LABEL_50;
      v15 = 1718908520;
    }
    else
    {
      if (v13 == 1684632424)
        goto LABEL_50;
      v15 = 1685481521;
    }
    if (v13 != v15)
    {
LABEL_51:
      v49 = 134218754;
      v50 = a1;
      v51 = 1024;
      v52 = v12;
      v53 = 1024;
      v54 = v11;
      v55 = 2080;
      v56 = v14;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VCPEnc %p (%dx%d, %s): Failed to create buffer_copy_session\n", (uint8_t *)&v49, 0x22u);
      return v9;
    }
LABEL_50:
    v14 = "HEVC";
    goto LABEL_51;
  }
  return v9;
}

uint64_t VCPCompressionSessionEncodeFrame(uint64_t a1, __CVBuffer *a2, CMTime *a3, __int128 *a4, const __CFDictionary *a5, uint64_t a6, VTEncodeInfoFlags *a7)
{
  std::mutex *v8;
  int v12;
  CMTimeFlags v13;
  int v14;
  const char *v15;
  int v16;
  int v17;
  CMTimeFlags v18;
  int v19;
  const char *v20;
  int v21;
  int v22;
  CMTime *v23;
  int v24;
  int32_t timescale;
  CMTimeValue v26;
  CMTimeFlags *p_flags;
  int v28;
  CMTimeValue v29;
  int v30;
  int v31;
  __IOSurface *IOSurface;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t Seconds;
  BOOL v37;
  _BOOL4 v38;
  const __CFDictionary *v39;
  const void *v40;
  const __CFDictionary *v41;
  const __CFDictionary *v42;
  const void *v43;
  CFTypeID v44;
  const void *ValueAtIndex;
  CFTypeID v46;
  void *v47;
  const __CFDictionary *v48;
  void *v49;
  uint64_t v50;
  int v51;
  int v52;
  char *v53;
  int v54;
  char v55;
  int v56;
  uint64_t v57;
  const void *v58;
  const void *v59;
  _BOOL4 v60;
  const void *v61;
  const void *v62;
  BOOL v63;
  const void *v64;
  const void *v65;
  const __CFNumber *v66;
  const __CFNumber *v67;
  CFTypeID v68;
  const void *v69;
  const __CFNumber *v70;
  const __CFNumber *v71;
  CFTypeID v72;
  const __CFNumber *v73;
  const __CFNumber *v74;
  CFTypeID v75;
  const __CFNumber *v76;
  const __CFNumber *v77;
  CFTypeID v78;
  std::mutex *v79;
  __CVBuffer *v80;
  int v81;
  CFNumberRef v82;
  _BOOL4 v83;
  int v84;
  CMTimeFlags v85;
  int v86;
  const char *v87;
  int v88;
  const __CFString *StringForIntegerCodePoint;
  int v90;
  CMTimeFlags v91;
  int v92;
  const char *v93;
  int v94;
  const void *v95;
  CFTypeID TypeID;
  CFTypeID v97;
  int v98;
  const void *v99;
  CFTypeID v100;
  unsigned int Count;
  uint64_t v102;
  CFIndex i;
  const __CFNumber *v104;
  int v105;
  int j;
  uint64_t v107;
  int v108;
  uint64_t **v109;
  uint64_t **v110;
  uint64_t *k;
  _BOOL4 v112;
  BOOL v113;
  uint64_t v114;
  int v115;
  const __CFString *v116;
  const __CFAllocator *v117;
  NSObject *v118;
  const char *v119;
  int v120;
  _OWORD *v121;
  unint64_t v122;
  __CFString *v123;
  size_t v124;
  char *v125;
  unsigned __int8 *v126;
  uint64_t v127;
  char *v128;
  uint64_t v129;
  __CFDictionary *v130;
  const __CFDictionary *v131;
  const void *v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  int v136;
  int v137;
  int v138;
  uint64_t v139;
  _QWORD *v140;
  _QWORD *v141;
  _QWORD *v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  unint64_t v146;
  char *v147;
  uint64_t *v148;
  uint64_t v149;
  int64x2_t v150;
  CMTimeValue v151;
  uint64_t *v152;
  uint64_t *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  int v157;
  int v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  unint64_t *v163;
  unint64_t v164;
  unint64_t *v165;
  unint64_t *v166;
  unint64_t v167;
  uint64_t v168;
  unsigned int v169;
  unsigned int v170;
  int v171;
  uint64_t v172;
  uint64_t v173;
  unint64_t *v174;
  unint64_t v175;
  unint64_t *v176;
  unint64_t *v177;
  unint64_t v178;
  void *v179;
  id v180;
  void *v181;
  __int128 v182;
  uint64_t v183;
  CMTimeValue v184;
  unint64_t *v185;
  unint64_t *v186;
  unint64_t v187;
  CMTimeValue v188;
  unint64_t *v189;
  unint64_t v190;
  uint64_t v191;
  uint64_t v192;
  unint64_t *v193;
  unint64_t v194;
  unint64_t *v195;
  int v196;
  uint64_t v197;
  CMTimeValue v198;
  unint64_t *v199;
  unint64_t *v200;
  unint64_t v201;
  CMTimeValue v202;
  unint64_t *v203;
  unint64_t v204;
  uint64_t v205;
  CMTimeValue v206;
  unint64_t *v207;
  unint64_t *v208;
  unint64_t v209;
  unint64_t *v210;
  int v211;
  const char *v212;
  int v213;
  CMTimeFlags v214;
  int v215;
  __CVPixelBufferPool *PixelBufferPool;
  __CVBuffer *v217;
  __IOSurface *v218;
  uint64_t v219;
  __CVBuffer *v220;
  uint64_t v221;
  uint64_t v222;
  CMTimeValue v223;
  void *v224;
  OSType PixelFormatType;
  id v226;
  __int128 v227;
  int v228;
  int v229;
  double v230;
  int32_t v231;
  int64_t v232;
  int v233;
  int v234;
  int v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  int v241;
  CFNumberRef v242;
  void **v243;
  uint64_t *v244;
  __CFString *v245;
  unint64_t v246;
  uint64_t v247;
  unint64_t **v248;
  uint64_t v249;
  unint64_t v250;
  unint64_t v251;
  unint64_t **v252;
  unint64_t **v253;
  unint64_t **v254;
  unint64_t *v255;
  unint64_t *v256;
  unint64_t *v257;
  unint64_t v258;
  _BYTE *v259;
  uint64_t v260;
  int v261;
  uint64_t v262;
  uint64_t v263;
  char v264;
  __CFDictionary *v265;
  CFNumberRef v266;
  CFNumberRef v267;
  CFNumberRef v268;
  CFNumberRef v269;
  const void *v270;
  CFArrayRef v271;
  CFNumberRef v272;
  CFNumberRef v273;
  uint64_t v274;
  std::__assoc_sub_state *v275;
  OpaqueVTCompressionSession *v276;
  __CVBuffer *v277;
  void *v278;
  int v279;
  int v280;
  int v281;
  CMTimeFlags v282;
  int v283;
  const char *v284;
  int v285;
  const __CFDictionary *v286;
  const __CFDictionary *v287;
  CFTypeID v288;
  const __CFNumber *v289;
  const __CFNumber *v290;
  CFTypeID v291;
  uint64_t v292;
  int v293;
  _BOOL4 v294;
  int v295;
  CMTimeFlags v296;
  int v297;
  const char *v298;
  int v299;
  const __CFString *v300;
  int v301;
  CMTimeFlags v302;
  int v303;
  const char *v304;
  int v305;
  int v306;
  CMTimeFlags v307;
  int v308;
  const char *v309;
  int v310;
  CMTimeValue v311;
  uint64_t v312;
  uint64_t v313;
  __int128 v314;
  __int128 v315;
  int v316;
  __int128 v317;
  CMTimeEpoch epoch;
  int v319;
  CMTimeFlags v320;
  int v321;
  int v322;
  CMTimeValue v323;
  unint64_t *v324;
  unint64_t *v325;
  unint64_t v326;
  CMTimeValue v327;
  unint64_t *v328;
  unint64_t v329;
  CMTimeValue v330;
  unint64_t *v331;
  unint64_t *v332;
  unint64_t v333;
  unint64_t *v334;
  int v335;
  const char *v336;
  int v337;
  const UInt8 *v338;
  int v339;
  uint64_t v340;
  int v341;
  IOSurfaceID v342;
  uint64_t v343;
  uint64_t v344;
  int v345;
  CMTimeFlags v346;
  int v347;
  const char *v348;
  int v349;
  OpaqueVTCompressionSession *v350;
  __CVBuffer *v351;
  uint64_t v352;
  const void *v353;
  CFStringRef v355;
  const __CFAllocator *v356;
  const __CFString *v357;
  int v358;
  CMTimeFlags v359;
  int v360;
  const char *v361;
  int v362;
  int v363;
  CMTimeFlags v364;
  int v365;
  const char *v366;
  int v367;
  int v368;
  CMTimeFlags v369;
  int v370;
  const char *v371;
  int v372;
  NSObject *v373;
  const char *v374;
  NSObject *v375;
  const char *v376;
  void *v377;
  void *v378;
  void *v379;
  void *v380;
  void *v381;
  void *key;
  const __CFAllocator *allocator;
  const void *v384;
  const void *v385;
  const void *v386;
  int HeightOfPlane;
  void *v388;
  id *v389;
  const void *v390;
  VTEncodeInfoFlags *infoFlagsOut;
  const __CFDictionary *theDict;
  int theDicta;
  int theDictb;
  _BOOL4 v395;
  _BOOL4 v396;
  unsigned __int8 *v397;
  std::mutex *v398;
  _QWORD *v399;
  int v400;
  __CVBuffer *buffer;
  const __CFDictionary *MutableCopy;
  unsigned __int8 v403;
  int v405;
  int v407;
  char v408;
  _BOOL4 v409;
  unsigned int v410;
  int v411;
  uint64_t v412;
  uint64_t v413;
  IOSurfaceID ID;
  CMTime v416;
  CMTime v417;
  __int128 v418;
  CMTimeEpoch v419;
  CFDataRef v420;
  CMTime v421;
  CMTime v422;
  CMTime v423;
  CMTime v424;
  CMTime time2;
  CMTime time1;
  CMTime v427;
  CMTime v428;
  CMTime rhs;
  CMTime lhs;
  CMTime duration;
  CMTime presentationTimeStamp;
  CMTime v433;
  CFDataRef theData;
  CMTime pixelBufferOut;
  CMTime v436;
  CMTime v437;
  uint64_t v438;
  int v439;
  uint64_t valuePtr;
  CMTime time;
  uint8_t v442[16];
  CMTime propertyValueOut;
  _BYTE v444[30];
  __int16 v445;
  uint64_t v446;
  int64x2_t v447;
  char *v448;
  uint64_t v449;
  int v450;
  uint64_t v451;
  CMTimeFlags epoch_high;
  uint8_t buf[8];
  __CFString *v454;
  void *v455;
  void *value;
  void *values;
  CMTime v458;
  uint64_t v459;

  v459 = *MEMORY[0x1E0C80C00];
  v8 = *(std::mutex **)(a1 + 2152);
  if (!v8)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      return 4294954384;
    v18 = *(_DWORD *)(a1 + 60);
    v17 = *(_DWORD *)(a1 + 64);
    v19 = *(_DWORD *)(a1 + 24);
    v20 = "H.264";
    if (v19 > 1718908519)
    {
      if (v19 == 1752589105)
        goto LABEL_32;
      v21 = 1718908520;
    }
    else
    {
      if (v19 == 1684632424)
        goto LABEL_32;
      v21 = 1685481521;
    }
    if (v19 != v21)
    {
LABEL_33:
      LODWORD(propertyValueOut.value) = 134218754;
      *(CMTimeValue *)((char *)&propertyValueOut.value + 4) = a1;
      LOWORD(propertyValueOut.flags) = 1024;
      *(CMTimeFlags *)((char *)&propertyValueOut.flags + 2) = v18;
      WORD1(propertyValueOut.epoch) = 1024;
      HIDWORD(propertyValueOut.epoch) = v17;
      *(_WORD *)v444 = 2080;
      *(_QWORD *)&v444[2] = v20;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): VCPCompressionSessionEncodeFrame got NULL session mutex\n", (uint8_t *)&propertyValueOut, 0x22u);
      return 4294954384;
    }
LABEL_32:
    v20 = "HEVC";
    goto LABEL_33;
  }
  v398 = v8;
  std::mutex::lock(v8);
  if (*(_BYTE *)(a1 + 2160))
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
LABEL_28:
      v33 = 4294954393;
      goto LABEL_539;
    }
    v13 = *(_DWORD *)(a1 + 60);
    v12 = *(_DWORD *)(a1 + 64);
    v14 = *(_DWORD *)(a1 + 24);
    v15 = "H.264";
    if (v14 > 1718908519)
    {
      if (v14 == 1752589105)
        goto LABEL_26;
      v16 = 1718908520;
    }
    else
    {
      if (v14 == 1684632424)
        goto LABEL_26;
      v16 = 1685481521;
    }
    if (v14 != v16)
    {
LABEL_27:
      LODWORD(propertyValueOut.value) = 134218754;
      *(CMTimeValue *)((char *)&propertyValueOut.value + 4) = a1;
      LOWORD(propertyValueOut.flags) = 1024;
      *(CMTimeFlags *)((char *)&propertyValueOut.flags + 2) = v13;
      WORD1(propertyValueOut.epoch) = 1024;
      HIDWORD(propertyValueOut.epoch) = v12;
      *(_WORD *)v444 = 2080;
      *(_QWORD *)&v444[2] = v15;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Video compression session invalidated already!\n", (uint8_t *)&propertyValueOut, 0x22u);
      goto LABEL_28;
    }
LABEL_26:
    v15 = "HEVC";
    goto LABEL_27;
  }
  infoFlagsOut = a7;
  buffer = a2;
  if (*(_QWORD *)(a1 + 2312) && *(int *)(a1 + 72) >= 1)
  {
    v22 = 0;
    do
    {
      sub_1B6872E44(*(_QWORD *)(a1 + 2312), (uint64_t *)"input_frames", 1.0);
      ++v22;
    }
    while (v22 < *(_DWORD *)(a1 + 72));
  }
  v23 = a3;
  v24 = *((_DWORD *)a4 + 2);
  timescale = a3->timescale;
  if (v24 != timescale)
  {
    time = *(CMTime *)a4;
    CMTimeConvertScale(&propertyValueOut, &time, timescale, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
    *(CMTime *)a4 = propertyValueOut;
    v23 = a3;
    v24 = a3->timescale;
  }
  theDict = a5;
  v26 = v23->value;
  p_flags = &v23->flags;
  v451 = *(_QWORD *)&v23->flags;
  epoch_high = HIDWORD(v23->epoch);
  if (v24 <= 999)
  {
    v458.value = v26;
    *(_QWORD *)&v458.flags = *(_QWORD *)p_flags;
    v28 = HIDWORD(v23->epoch);
    v458.timescale = v24;
    HIDWORD(v458.epoch) = v28;
    CMTimeConvertScale(&propertyValueOut, &v458, 1000, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
    v26 = propertyValueOut.value;
    v451 = *(_QWORD *)&propertyValueOut.flags;
    v24 = propertyValueOut.timescale;
    epoch_high = HIDWORD(propertyValueOut.epoch);
  }
  a3->value = v26;
  a3->timescale = v24;
  *(_QWORD *)p_flags = v451;
  p_flags[2] = epoch_high;
  v29 = *(_QWORD *)a4;
  v30 = *((_DWORD *)a4 + 2);
  v449 = *(_QWORD *)((char *)a4 + 12);
  v450 = *((_DWORD *)a4 + 5);
  v399 = (_QWORD *)((char *)a4 + 12);
  if (v30 <= 999)
  {
    v458.value = v29;
    *(_QWORD *)&v458.flags = *(_QWORD *)((char *)a4 + 12);
    v31 = *((_DWORD *)a4 + 5);
    v458.timescale = v30;
    HIDWORD(v458.epoch) = v31;
    CMTimeConvertScale(&propertyValueOut, &v458, 1000, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
    v29 = propertyValueOut.value;
    v449 = *(_QWORD *)&propertyValueOut.flags;
    v30 = propertyValueOut.timescale;
    v450 = HIDWORD(propertyValueOut.epoch);
  }
  *(_QWORD *)a4 = v29;
  *((_DWORD *)a4 + 2) = v30;
  *v399 = v449;
  *((_DWORD *)a4 + 5) = v450;
  IOSurface = CVPixelBufferGetIOSurface(a2);
  if (IOSurface)
    ID = IOSurfaceGetID(IOSurface);
  else
    ID = 0;
  v34 = *(_DWORD *)(a1 + 76);
  v35 = *(_DWORD *)(a1 + 84);
  propertyValueOut = *a3;
  Seconds = CMTimeGetSeconds(&propertyValueOut);
  v411 = *(_DWORD *)(a1 + 72);
  valuePtr = 0;
  v439 = 0;
  v438 = 0;
  if (a5)
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a5);
  else
    MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v412 = (unsigned __int16)(v35 + v34);
  v413 = Seconds;
  kdebug_trace();
  v37 = *(_DWORD *)(a1 + 68) != 43;
  if (*(_BYTE *)(a1 + 53))
    v38 = *(_DWORD *)(a1 + 68) != 43;
  else
    v38 = 0;
  *(_BYTE *)(a1 + 53) = v38;
  if (!*(_BYTE *)(a1 + 52))
    v37 = 0;
  *(_BYTE *)(a1 + 52) = v37;
  if (*(unsigned __int16 *)(a1 + 50) - 1 <= 1 && v38)
  {
    v39 = CVBufferCopyAttachments(buffer, kCVAttachmentMode_ShouldPropagate);
    v447.i64[0] = (uint64_t)v39;
    if (v39)
    {
      v40 = (const void *)*MEMORY[0x1E0D04138];
      if (CFDictionaryContainsKey(v39, (const void *)*MEMORY[0x1E0D04138]))
      {
        v41 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v447.i64[0], v40);
        v42 = v41;
        if (v41)
        {
          v43 = CFDictionaryGetValue(v41, (const void *)*MEMORY[0x1E0D05350]);
          pixelBufferOut.value = (CMTimeValue)v43;
          if (!v43)
          {
            if (qword_1EF138D18 != -1)
              dispatch_once(&qword_1EF138D18, &unk_1E6A169E0);
            if ((byte_1EF138D20 & 1) != 0)
              goto LABEL_62;
            v48 = (const __CFDictionary *)CFDictionaryGetValue(v42, CFSTR("MetadataCVA"));
            if (!v48)
              goto LABEL_62;
            v43 = CFDictionaryGetValue(v48, (const void *)*MEMORY[0x1E0CFCCF0]);
            pixelBufferOut.value = (CMTimeValue)v43;
            if (!v43)
              goto LABEL_63;
          }
          if (CFArrayGetCount((CFArrayRef)v43) == 1)
          {
            v44 = CFGetTypeID(v43);
            if (v44 == CFArrayGetTypeID())
            {
              values = 0;
              ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v43, 0);
              v43 = ValueAtIndex;
              if (!ValueAtIndex)
              {
LABEL_63:
                sub_1B6770568((const void **)&v447);
                if (!dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 2168), 0))
                {
                  v49 = *(void **)(a1 + 2176);
                  propertyValueOut.value = MEMORY[0x1E0C809B0];
                  *(_QWORD *)&propertyValueOut.timescale = 0x40000000;
                  propertyValueOut.epoch = (CMTimeEpoch)sub_1B67906C8;
                  *(_QWORD *)v444 = &unk_1E6A169A0;
                  *(_QWORD *)&v444[8] = a1;
                  sub_1B67C2528(v49, (uint64_t)buffer, 4u, (uint64_t)v43, &propertyValueOut);
                }
                if (v43)
                  CFRelease(v43);
                goto LABEL_67;
              }
              v46 = CFGetTypeID(ValueAtIndex);
              if (v46 == CFDictionaryGetTypeID())
              {
                value = 0;
                memset(&v458, 0, sizeof(v458));
                *(_QWORD *)buf = 0;
                v454 = 0;
                v455 = 0;
                if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v43, (const void *)*MEMORY[0x1E0D05368], (const void **)&value))
                {
                  v458.value = *MEMORY[0x1E0D47610];
                  v47 = value;
                  *(_QWORD *)buf = value;
                }
                else
                {
                  v47 = 0;
                }
                if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v43, (const void *)*MEMORY[0x1E0D05360], (const void **)&value)&& CGRectMakeWithDictionaryRepresentation((CFDictionaryRef)value, (CGRect *)&propertyValueOut))
                {
                  *(_QWORD *)&v458.timescale = *MEMORY[0x1E0D47608];
                  v355 = sub_1B6790678(*(double *)&propertyValueOut.value, *(double *)&propertyValueOut.timescale, *(double *)&propertyValueOut.epoch, *(double *)v444);
                  v454 = (__CFString *)v355;
                }
                else
                {
                  v355 = 0;
                }
                if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v43, (const void *)*MEMORY[0x1E0D05370], (const void **)&value))
                {
                  v43 = 0;
                  v458.epoch = *MEMORY[0x1E0D47618];
                  v455 = value;
                  if (!v47 || !v355 || !value)
                    goto LABEL_584;
                  v356 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
                  values = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&v458, (const void **)buf, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                  if (values)
                  {
                    pixelBufferOut.value = (CMTimeValue)CFArrayCreate(v356, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
                    if (pixelBufferOut.value)
                    {
                      v43 = CFDictionaryCreate(v356, MEMORY[0x1E0D47600], (const void **)&pixelBufferOut, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                      CFRelease((CFTypeRef)pixelBufferOut.value);
                    }
                    else
                    {
                      v43 = 0;
                    }
                    CFRelease(values);
LABEL_584:
                    if (v454)
                      CFRelease(v454);
                    goto LABEL_63;
                  }
                }
                v43 = 0;
                goto LABEL_584;
              }
            }
          }
        }
      }
    }
LABEL_62:
    v43 = 0;
    goto LABEL_63;
  }
LABEL_67:
  if (!*(_QWORD *)(a1 + 2192))
  {
    v50 = 0;
    v51 = *(_DWORD *)(a1 + 24);
    if (v51 > 1718908519)
    {
      if (v51 != 1718908520)
      {
        v52 = 1752589105;
LABEL_73:
        if (v51 != v52)
          v50 = 1;
      }
    }
    else if (v51 != 1684632424)
    {
      v52 = 1685481521;
      goto LABEL_73;
    }
    v53 = sub_1B685B8B4(*(char **)(a1 + 120), 1, *(unsigned int *)(a1 + 68), v50);
    *(_QWORD *)(a1 + 2192) = v53;
    if ((*(unsigned int (**)(char *))(*(_QWORD *)v53 + 120))(v53) && !*(_DWORD *)(a1 + 2344))
      VCPCompressionSessionSetProperty(a1, CFSTR("RemoteMLScale"), (const __CFString *)*MEMORY[0x1E0C9AE50]);
  }
  if (!*(_BYTE *)(a1 + 104) || CVPixelBufferGetPixelFormatType(buffer) != 1111970369)
  {
    v410 = 0;
    goto LABEL_87;
  }
  v458.value = (CMTimeValue)CVBufferCopyAttachment(buffer, (CFStringRef)*MEMORY[0x1E0CA8D68], 0);
  *(_QWORD *)buf = CVBufferCopyAttachment(buffer, (CFStringRef)*MEMORY[0x1E0CA8E98], 0);
  if (v458.value
    && CFStringCompare((CFStringRef)v458.value, (CFStringRef)*MEMORY[0x1E0CA8D98], 0) == kCFCompareEqualTo
    && *(_QWORD *)buf
    && CFStringCompare(*(CFStringRef *)buf, (CFStringRef)*MEMORY[0x1E0CA8EB0], 0) == kCFCompareEqualTo)
  {
    StringForIntegerCodePoint = CVColorPrimariesGetStringForIntegerCodePoint(12);
    if (VCPCompressionSessionSetProperty(a1, (const __CFString *)*MEMORY[0x1E0CECF48], StringForIntegerCodePoint))
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v91 = *(_DWORD *)(a1 + 60);
        v90 = *(_DWORD *)(a1 + 64);
        v92 = *(_DWORD *)(a1 + 24);
        v93 = "H.264";
        if (v92 > 1718908519)
        {
          if (v92 == 1752589105)
            goto LABEL_589;
          v94 = 1718908520;
        }
        else
        {
          if (v92 == 1684632424)
            goto LABEL_589;
          v94 = 1685481521;
        }
        if (v92 != v94)
        {
LABEL_590:
          LODWORD(propertyValueOut.value) = 134218754;
          *(CMTimeValue *)((char *)&propertyValueOut.value + 4) = a1;
          LOWORD(propertyValueOut.flags) = 1024;
          *(CMTimeFlags *)((char *)&propertyValueOut.flags + 2) = v91;
          WORD1(propertyValueOut.epoch) = 1024;
          HIDWORD(propertyValueOut.epoch) = v90;
          *(_WORD *)v444 = 2080;
          *(_QWORD *)&v444[2] = v93;
          v375 = MEMORY[0x1E0C81028];
          v376 = "VCPEnc %p (%dx%d, %s): Failed to set ColorPrimaries as SMPTE_EG_432_1!\n";
LABEL_606:
          _os_log_error_impl(&dword_1B676B000, v375, OS_LOG_TYPE_ERROR, v376, (uint8_t *)&propertyValueOut, 0x22u);
          goto LABEL_607;
        }
LABEL_589:
        v93 = "HEVC";
        goto LABEL_590;
      }
LABEL_607:
      v55 = 0;
      v410 = -12902;
      v54 = 7;
      goto LABEL_83;
    }
    v300 = CVTransferFunctionGetStringForIntegerCodePoint(1);
    if (VCPCompressionSessionSetProperty(a1, (const __CFString *)*MEMORY[0x1E0CED238], v300))
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        goto LABEL_607;
      v302 = *(_DWORD *)(a1 + 60);
      v301 = *(_DWORD *)(a1 + 64);
      v303 = *(_DWORD *)(a1 + 24);
      v304 = "H.264";
      if (v303 > 1718908519)
      {
        if (v303 == 1752589105)
          goto LABEL_599;
        v305 = 1718908520;
      }
      else
      {
        if (v303 == 1684632424)
          goto LABEL_599;
        v305 = 1685481521;
      }
      if (v303 != v305)
      {
LABEL_600:
        LODWORD(propertyValueOut.value) = 134218754;
        *(CMTimeValue *)((char *)&propertyValueOut.value + 4) = a1;
        LOWORD(propertyValueOut.flags) = 1024;
        *(CMTimeFlags *)((char *)&propertyValueOut.flags + 2) = v302;
        WORD1(propertyValueOut.epoch) = 1024;
        HIDWORD(propertyValueOut.epoch) = v301;
        *(_WORD *)v444 = 2080;
        *(_QWORD *)&v444[2] = v304;
        v375 = MEMORY[0x1E0C81028];
        v376 = "VCPEnc %p (%dx%d, %s): Failed to set TransferFunction as BT_709!\n";
        goto LABEL_606;
      }
LABEL_599:
      v304 = "HEVC";
      goto LABEL_600;
    }
    v357 = CVYCbCrMatrixGetStringForIntegerCodePoint(9);
    if (VCPCompressionSessionSetProperty(a1, (const __CFString *)*MEMORY[0x1E0CED290], v357))
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        goto LABEL_607;
      v359 = *(_DWORD *)(a1 + 60);
      v358 = *(_DWORD *)(a1 + 64);
      v360 = *(_DWORD *)(a1 + 24);
      v361 = "H.264";
      if (v360 > 1718908519)
      {
        if (v360 == 1752589105)
          goto LABEL_604;
        v362 = 1718908520;
      }
      else
      {
        if (v360 == 1684632424)
          goto LABEL_604;
        v362 = 1685481521;
      }
      if (v360 != v362)
      {
LABEL_605:
        LODWORD(propertyValueOut.value) = 134218754;
        *(CMTimeValue *)((char *)&propertyValueOut.value + 4) = a1;
        LOWORD(propertyValueOut.flags) = 1024;
        *(CMTimeFlags *)((char *)&propertyValueOut.flags + 2) = v359;
        WORD1(propertyValueOut.epoch) = 1024;
        HIDWORD(propertyValueOut.epoch) = v358;
        *(_WORD *)v444 = 2080;
        *(_QWORD *)&v444[2] = v361;
        v375 = MEMORY[0x1E0C81028];
        v376 = "VCPEnc %p (%dx%d, %s): Failed to set YCbCrMatrix as BT_2020_nonconstant!\n";
        goto LABEL_606;
      }
LABEL_604:
      v361 = "HEVC";
      goto LABEL_605;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v369 = *(_DWORD *)(a1 + 60);
      v368 = *(_DWORD *)(a1 + 64);
      v370 = *(_DWORD *)(a1 + 24);
      v371 = "H.264";
      if (v370 > 1718908519)
      {
        if (v370 == 1752589105)
          goto LABEL_594;
        v372 = 1718908520;
      }
      else
      {
        if (v370 == 1684632424)
          goto LABEL_594;
        v372 = 1685481521;
      }
      if (v370 != v372)
      {
LABEL_595:
        LODWORD(propertyValueOut.value) = 134218754;
        *(CMTimeValue *)((char *)&propertyValueOut.value + 4) = a1;
        LOWORD(propertyValueOut.flags) = 1024;
        *(CMTimeFlags *)((char *)&propertyValueOut.flags + 2) = v369;
        WORD1(propertyValueOut.epoch) = 1024;
        HIDWORD(propertyValueOut.epoch) = v368;
        *(_WORD *)v444 = 2080;
        *(_QWORD *)&v444[2] = v371;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Encoder set color primaries as SMPTE_EG_432_1, transferfunction as BT_709, YCbCrMatrix as BT_2020_nonconstant\n", (uint8_t *)&propertyValueOut, 0x22u);
        goto LABEL_82;
      }
LABEL_594:
      v371 = "HEVC";
      goto LABEL_595;
    }
  }
LABEL_82:
  v54 = 0;
  v410 = 0;
  v55 = 1;
LABEL_83:
  sub_1B6770508((const void **)buf);
  sub_1B6770508((const void **)&v458);
  if ((v55 & 1) == 0 && v54 == 7)
  {
    v403 = 0;
    v408 = 0;
    goto LABEL_529;
  }
LABEL_87:
  if (*(_WORD *)(a1 + 50) == 2)
  {
    if (v411 >= 1)
    {
      v56 = v411 + 1;
      do
      {
        v57 = operator new();
        sub_1B6790754(v57, a6, 0, 0, 0, 0, v412, Seconds, ID, 0);
        propertyValueOut.value = 0;
        sub_1B67886D4(a1, v57, v410, 2, 0);
        --v56;
      }
      while (v56 > 1);
    }
    goto LABEL_538;
  }
  if (!MutableCopy)
  {
    v83 = 0;
    v63 = 0;
    v60 = 0;
    v81 = 0;
    v80 = buffer;
    goto LABEL_171;
  }
  v58 = CFDictionaryGetValue(MutableCopy, (const void *)*MEMORY[0x1E0CED620]);
  v59 = v58;
  v60 = v58 && CFGetTypeID(v58) && CFBooleanGetTypeID() && CFEqual(v59, (CFTypeRef)*MEMORY[0x1E0C9AE50]) != 0;
  v61 = CFDictionaryGetValue(MutableCopy, (const void *)*MEMORY[0x1E0CED5B8]);
  v62 = v61;
  v63 = v61 && CFGetTypeID(v61) && CFBooleanGetTypeID() && CFEqual(v62, (CFTypeRef)*MEMORY[0x1E0C9AE50]) != 0;
  v64 = CFDictionaryGetValue(MutableCopy, (const void *)*MEMORY[0x1E0CED5C8]);
  v65 = v64;
  v395 = v64 && CFGetTypeID(v64) && CFBooleanGetTypeID() && CFEqual(v65, (CFTypeRef)*MEMORY[0x1E0C9AE50]) != 0;
  v66 = (const __CFNumber *)CFDictionaryGetValue(MutableCopy, (const void *)*MEMORY[0x1E0CED590]);
  v67 = v66;
  if (v66)
  {
    v68 = CFGetTypeID(v66);
    if (v68 == CFNumberGetTypeID())
      CFNumberGetValue(v67, kCFNumberSInt32Type, &valuePtr);
  }
  v69 = (const void *)*MEMORY[0x1E0CED5F0];
  v70 = (const __CFNumber *)CFDictionaryGetValue(MutableCopy, (const void *)*MEMORY[0x1E0CED5F0]);
  v71 = v70;
  if (v70)
  {
    v72 = CFGetTypeID(v70);
    if (v72 == CFNumberGetTypeID())
      CFNumberGetValue(v71, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  }
  v73 = (const __CFNumber *)CFDictionaryGetValue(MutableCopy, (const void *)*MEMORY[0x1E0CED608]);
  v74 = v73;
  if (v73)
  {
    v75 = CFGetTypeID(v73);
    if (v75 == CFNumberGetTypeID())
      CFNumberGetValue(v74, kCFNumberSInt32Type, &v439);
  }
  v76 = (const __CFNumber *)CFDictionaryGetValue(MutableCopy, CFSTR("HIDTimeStamp"));
  v77 = v76;
  if (v76)
  {
    v78 = CFGetTypeID(v76);
    if (v78 == CFNumberGetTypeID())
      CFNumberGetValue(v77, kCFNumberSInt64Type, &v438);
  }
  v79 = *(std::mutex **)(a1 + 2336);
  if (!v79)
  {
    v81 = 0;
    v80 = buffer;
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      goto LABEL_144;
    v85 = *(_DWORD *)(a1 + 60);
    v84 = *(_DWORD *)(a1 + 64);
    v86 = *(_DWORD *)(a1 + 24);
    v87 = "H.264";
    if (v86 > 1718908519)
    {
      if (v86 == 1752589105)
        goto LABEL_142;
      v88 = 1718908520;
    }
    else
    {
      if (v86 == 1684632424)
        goto LABEL_142;
      v88 = 1685481521;
    }
    if (v86 != v88)
    {
LABEL_143:
      LODWORD(propertyValueOut.value) = 134218754;
      *(CMTimeValue *)((char *)&propertyValueOut.value + 4) = a1;
      LOWORD(propertyValueOut.flags) = 1024;
      *(CMTimeFlags *)((char *)&propertyValueOut.flags + 2) = v85;
      WORD1(propertyValueOut.epoch) = 1024;
      HIDWORD(propertyValueOut.epoch) = v84;
      *(_WORD *)v444 = 2080;
      *(_QWORD *)&v444[2] = v87;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): VCPCompressionSessionEncodeFrame got NULL callback mutex\n", (uint8_t *)&propertyValueOut, 0x22u);
      v81 = 0;
      goto LABEL_144;
    }
LABEL_142:
    v87 = "HEVC";
    goto LABEL_143;
  }
  propertyValueOut.value = *(_QWORD *)(a1 + 2336);
  LOBYTE(propertyValueOut.timescale) = 1;
  std::mutex::lock(v79);
  v80 = buffer;
  v81 = *(_DWORD *)(a1 + 2332);
  *(_DWORD *)(a1 + 2332) = 0;
  sub_1B678B174((uint64_t)&propertyValueOut);
  if (v81 >= 1)
  {
    LODWORD(v458.value) = HIDWORD(valuePtr) + v81;
    v82 = CFNumberCreate(0, kCFNumberSInt32Type, &v458);
    if (v82)
    {
      CFDictionarySetValue(MutableCopy, v69, v82);
      CFRelease(v82);
    }
  }
  if (LOBYTE(propertyValueOut.timescale))
    std::mutex::unlock((std::mutex *)propertyValueOut.value);
LABEL_144:
  v95 = CFDictionaryGetValue(MutableCopy, (const void *)*MEMORY[0x1E0CED5A8]);
  if (v95)
  {
    TypeID = CFDataGetTypeID();
    v97 = CFGetTypeID(v95);
    v98 = v395;
    if (TypeID == v97)
      v98 = 1;
    v395 = v98;
    if (TypeID == v97)
      v63 = 0;
  }
  v99 = CFDictionaryGetValue(MutableCopy, (const void *)*MEMORY[0x1E0CED4A0]);
  if (!v99)
    goto LABEL_170;
  v100 = CFArrayGetTypeID();
  if (v100 != CFGetTypeID(v99))
    goto LABEL_170;
  Count = CFArrayGetCount((CFArrayRef)v99);
  if (Count >= 0x10)
    v102 = 16;
  else
    v102 = Count;
  if (!(_DWORD)v102)
  {
    v80 = buffer;
LABEL_170:
    v83 = v395;
    goto LABEL_171;
  }
  v409 = v60;
  for (i = 0; i != v102; ++i)
  {
    LODWORD(v458.value) = 0;
    v104 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)v99, i);
    CFNumberGetValue(v104, kCFNumberIntType, &v458);
    v105 = *(_DWORD *)(a1 + 72);
    if (v105 >= 1)
    {
      for (j = 0; j < v105; ++j)
      {
        v107 = *(_QWORD *)(a1 + 2184);
        if (v107)
        {
          v108 = v458.value;
          LODWORD(propertyValueOut.value) = j;
          v109 = sub_1B6779B8C((uint64_t **)(v107 + 184), j, &propertyValueOut);
          v110 = v109 + 5;
          for (k = v109[6]; k != (uint64_t *)v110; k = (uint64_t *)k[1])
          {
            if (*((_DWORD *)k + 4) == v108)
            {
              if (k != (uint64_t *)v110)
                *((_BYTE *)v109 + 64) = 1;
              break;
            }
          }
          v105 = *(_DWORD *)(a1 + 72);
        }
      }
    }
  }
  v80 = buffer;
  v83 = v395;
  v60 = v409;
LABEL_171:
  v403 = *(_BYTE *)(a1 + 104) | v63;
  v396 = v83;
  v112 = (v403 | v83) == 0;
  if (v403 | v83)
    v113 = 0;
  else
    v113 = v60;
  v408 = v113;
  v114 = *(_QWORD *)(a1 + 136);
  if (v114)
  {
LABEL_175:
    v115 = sub_1B67814D0(v114, v80, 0);
    v458.value = 0;
    VTSessionCopySupportedPropertyDictionary(*(VTSessionRef *)(a1 + 16), (CFDictionaryRef *)&v458);
    if (!v458.value)
      goto LABEL_192;
    v116 = (const __CFString *)*MEMORY[0x1E0CED098];
    if (!CFDictionaryContainsKey((CFDictionaryRef)v458.value, (const void *)*MEMORY[0x1E0CED098]))
      goto LABEL_192;
    v447.i32[0] = -1;
    propertyValueOut.value = 0;
    v117 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    VTSessionCopyProperty(*(VTSessionRef *)(a1 + 16), v116, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], &propertyValueOut);
    if (propertyValueOut.value)
      CFNumberGetValue((CFNumberRef)propertyValueOut.value, kCFNumberIntType, &v447);
    sub_1B6770598((const void **)&propertyValueOut);
    if (v115)
    {
      if (v447.i32[0] <= 39)
      {
        *(_QWORD *)buf = CFNumberCreate(v117, kCFNumberSInt32Type, &unk_1B691FF38);
        VCPCompressionSessionSetProperty(a1, v116, *(const __CFString **)buf);
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(propertyValueOut.value) = 67109376;
          HIDWORD(propertyValueOut.value) = v447.i32[0];
          LOWORD(propertyValueOut.timescale) = 1024;
          *(CMTimeScale *)((char *)&propertyValueOut.timescale + 2) = 40;
          v118 = MEMORY[0x1E0C81028];
          v119 = "boosting maxAllowedQp %d -> %d\n";
LABEL_190:
          _os_log_impl(&dword_1B676B000, v118, OS_LOG_TYPE_DEFAULT, v119, (uint8_t *)&propertyValueOut, 0xEu);
          goto LABEL_191;
        }
        goto LABEL_191;
      }
    }
    else if (v447.i32[0] >= 40)
    {
      *(_QWORD *)buf = CFNumberCreate(v117, kCFNumberSInt32Type, &unk_1B691FF3C);
      VCPCompressionSessionSetProperty(a1, v116, *(const __CFString **)buf);
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(propertyValueOut.value) = 67109376;
        HIDWORD(propertyValueOut.value) = v447.i32[0];
        LOWORD(propertyValueOut.timescale) = 1024;
        *(CMTimeScale *)((char *)&propertyValueOut.timescale + 2) = -1;
        v118 = MEMORY[0x1E0C81028];
        v119 = "reset maxAllowedQp %d -> %d\n";
        goto LABEL_190;
      }
LABEL_191:
      sub_1B6770598((const void **)buf);
    }
LABEL_192:
    sub_1B6770568((const void **)&v458);
    goto LABEL_193;
  }
  v120 = *(_DWORD *)(a1 + 68);
  if (v120 == 20 || v120 == 1)
  {
    v121 = operator new(0x28uLL, MEMORY[0x1E0DE4E10]);
    if (v121)
    {
      *v121 = 0u;
      v121[1] = 0u;
      *((_BYTE *)v121 + 24) = 1;
      *((_QWORD *)v121 + 4) = 0;
      *(_QWORD *)(a1 + 136) = v121;
      sub_1B67813AC((uint64_t *)v121, a1);
    }
    else
    {
      *(_QWORD *)(a1 + 136) = 0;
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        goto LABEL_193;
      LOWORD(propertyValueOut.value) = 0;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "failed to create reaction listener\n", (uint8_t *)&propertyValueOut, 2u);
    }
    v114 = *(_QWORD *)(a1 + 136);
    v80 = buffer;
    if (v114)
      goto LABEL_175;
  }
LABEL_193:
  if (*(int *)(a1 + 72) < 2)
  {
    v129 = operator new();
    sub_1B6790754(v129, a6, 0, 0, v408, v403 != 0, v412, Seconds, ID, 1);
    v458.value = v129;
    if (v80)
    {
      v130 = *(__CFDictionary **)(v129 + 264);
      if (v130)
      {
        v131 = CVBufferCopyAttachments(v80, kCVAttachmentMode_ShouldPropagate);
        propertyValueOut.value = (CMTimeValue)v131;
        if (v131 && CFDictionaryContainsKey(v131, CFSTR("PropagatableAttachments")))
        {
          v132 = CFDictionaryGetValue((CFDictionaryRef)propertyValueOut.value, CFSTR("PropagatableAttachments"));
          if (v132)
          {
            CFDictionaryAddValue(v130, CFSTR("PropagatableAttachments"), v132);
          }
          else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc: PropagatableAttachments exist but NULL - no SEI created\n", buf, 2u);
          }
        }
        sub_1B6770568((const void **)&propertyValueOut);
      }
    }
    if (MutableCopy)
    {
      v286 = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, (const void *)*MEMORY[0x1E0CED670]);
      v287 = v286;
      if (v286)
      {
        v288 = CFGetTypeID(v286);
        if (v288 == CFDictionaryGetTypeID())
        {
          sub_1B6790B00(v287, (const void *)*MEMORY[0x1E0CA8D60], (void *)(v129 + 160));
          sub_1B6790B00(v287, (const void *)*MEMORY[0x1E0CA8D40], (void *)(v129 + 164));
          sub_1B6790B00(v287, (const void *)*MEMORY[0x1E0CA8D48], (void *)(v129 + 152));
          sub_1B6790B00(v287, (const void *)*MEMORY[0x1E0CA8D58], (void *)(v129 + 156));
        }
      }
      v289 = (const __CFNumber *)CFDictionaryGetValue(MutableCopy, CFSTR("PadFrameToMinimumSize"));
      v290 = v289;
      if (v289)
      {
        v291 = CFGetTypeID(v289);
        if (v291 == CFNumberGetTypeID())
          CFNumberGetValue(v290, kCFNumberSInt32Type, (void *)(v129 + 168));
      }
    }
    v292 = *(_QWORD *)(a1 + 2184);
    if (v292)
    {
      v293 = *(unsigned __int8 *)(v129 + 45);
      v294 = *(_DWORD *)(a1 + 68) == 20;
      v428 = *a3;
      v427 = *(CMTime *)(a1 + 2248);
      *(_BYTE *)(v129 + 46) = sub_1B6779994(v292, 0, v293, v408 ^ 1, v294, &v428, &v427);
    }
    if (!*(_DWORD *)(a1 + 80)
      || (*(_BYTE *)p_flags & 1) == 0
      || (*(_BYTE *)(a1 + 2212) & 1) == 0
      || (*(_BYTE *)v399 & 1) == 0
      || (time1 = *a3, time2 = *(CMTime *)(a1 + 2200), CMTimeCompare(&time1, &time2) >= 1)
      && (*(_QWORD *)a4 & 0x8000000000000000) == 0)
    {
LABEL_468:
      v314 = *(_OWORD *)&a3->value;
      *(_QWORD *)(a1 + 2216) = a3->epoch;
      *(_OWORD *)(a1 + 2200) = v314;
      v315 = *a4;
      *(_QWORD *)(a1 + 2240) = *((_QWORD *)a4 + 2);
      *(_OWORD *)(a1 + 2224) = v315;
      if (*(_BYTE *)(v129 + 46))
      {
        v458.value = 0;
        sub_1B67886D4(a1, v129, v410, 2, 0);
LABEL_527:
        --v411;
        goto LABEL_528;
      }
      sub_1B67ED940(v129 + 176);
      v316 = *(_DWORD *)(a1 + 80);
      if (v316)
      {
        memset(&propertyValueOut, 0, sizeof(propertyValueOut));
        v424 = *a3;
        v423 = *(CMTime *)(a1 + 2248);
        CMTimeSubtract(&propertyValueOut, &v424, &v423);
        v422 = propertyValueOut;
        v421 = *(CMTime *)a4;
        if (CMTimeCompare(&v422, &v421))
          *(CMTime *)a4 = propertyValueOut;
        v316 = *(_DWORD *)(a1 + 80);
      }
      v317 = *(_OWORD *)&a3->value;
      *(_OWORD *)(v129 + 104) = *(_OWORD *)&a3->value;
      epoch = a3->epoch;
      *(_QWORD *)(v129 + 120) = epoch;
      *(_OWORD *)(v129 + 128) = *a4;
      *(_QWORD *)(v129 + 144) = *((_QWORD *)a4 + 2);
      *(_OWORD *)(a1 + 2248) = v317;
      *(_QWORD *)(a1 + 2264) = epoch;
      LODWORD(epoch) = HIDWORD(valuePtr);
      *(_DWORD *)(v129 + 24) = v316;
      *(_DWORD *)(v129 + 28) = epoch;
      v319 = valuePtr;
      *(_DWORD *)(v129 + 32) = v439;
      *(_DWORD *)(v129 + 36) = v319;
      *(_DWORD *)(v129 + 40) = v81;
      *(_QWORD *)(v129 + 96) = v438;
      *(_DWORD *)(a1 + 80) = v316 + 1;
      v320 = *(_DWORD *)(a1 + 60);
      v321 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)buf = v320;
      *(_DWORD *)&buf[4] = v321;
      v447.i64[0] = 0;
      *(_DWORD *)(v129 + 256) = 2139095039;
      v322 = *(_DWORD *)(a1 + 2164);
      switch(v322)
      {
        case 0:
LABEL_508:
          v340 = *(_QWORD *)(a1 + 2184);
          if (v340)
          {
            v341 = *(_DWORD *)(v129 + 24);
            v418 = *(_OWORD *)&a3->value;
            v419 = a3->epoch;
            sub_1B6779E28(v340, 0, v341, v408, (uint64_t)&v418, SHIDWORD(valuePtr), valuePtr, v81);
          }
          sub_1B6790BBC(MutableCopy, CFSTR("SignpostTimeStamp"), *(_QWORD *)(v129 + 48));
          sub_1B6790BBC(MutableCopy, CFSTR("SignpostID"), *(_QWORD *)(v129 + 64));
          v342 = *(_DWORD *)(v129 + 56);
          v412 = *(_QWORD *)(v129 + 64);
          v413 = *(_QWORD *)(v129 + 48);
          kdebug_trace();
          if (*(_DWORD *)(a1 + 68) != 20)
            goto LABEL_523;
          v343 = *(int *)(a1 + 60);
          if (CVPixelBufferGetWidth(buffer) == v343)
          {
            v344 = *(int *)(a1 + 64);
            if (CVPixelBufferGetHeight(buffer) == v344)
              goto LABEL_523;
          }
          if (!sub_1B678C978(a1, v129, buffer)
            || !os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          {
            goto LABEL_523;
          }
          v346 = *(_DWORD *)(a1 + 60);
          v345 = *(_DWORD *)(a1 + 64);
          v347 = *(_DWORD *)(a1 + 24);
          v348 = "H.264";
          if (v347 > 1718908519)
          {
            if (v347 == 1752589105)
              goto LABEL_521;
            v349 = 1718908520;
          }
          else
          {
            if (v347 == 1684632424)
              goto LABEL_521;
            v349 = 1685481521;
          }
          if (v347 != v349)
          {
LABEL_522:
            LODWORD(propertyValueOut.value) = 134218754;
            *(CMTimeValue *)((char *)&propertyValueOut.value + 4) = a1;
            LOWORD(propertyValueOut.flags) = 1024;
            *(CMTimeFlags *)((char *)&propertyValueOut.flags + 2) = v346;
            WORD1(propertyValueOut.epoch) = 1024;
            HIDWORD(propertyValueOut.epoch) = v345;
            *(_WORD *)v444 = 2080;
            *(_QWORD *)&v444[2] = v348;
            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): CopyROIRegionFromSourceBuffer failed!\n", (uint8_t *)&propertyValueOut, 0x22u);
LABEL_523:
            v350 = *(OpaqueVTCompressionSession **)(a1 + 16);
            if (*(_QWORD *)(v129 + 224))
              v351 = *(__CVBuffer **)(v129 + 224);
            else
              v351 = buffer;
            v417 = *a3;
            v416 = *(CMTime *)a4;
            v458.value = 0;
            v410 = VTCompressionSessionEncodeFrame(v350, v351, &v417, &v416, MutableCopy, (void *)v129, infoFlagsOut);
            kdebug_trace();
            ID = v342;
            goto LABEL_527;
          }
LABEL_521:
          v348 = "HEVC";
          goto LABEL_522;
        case 2:
          sub_1B679D378(&propertyValueOut.value, *(VTPixelTransferSessionRef **)(a1 + 2280), buffer, v447.i32, (int *)buf);
          v330 = propertyValueOut.value;
          propertyValueOut.value = 0;
          v331 = *(unint64_t **)(v129 + 248);
          *(_QWORD *)(v129 + 248) = v330;
          if (v331)
          {
            v332 = v331 + 1;
            do
              v333 = __ldaxr(v332);
            while (__stlxr(v333 - 1, v332));
            if (!v333)
              (*(void (**)(unint64_t *))(*v331 + 16))(v331);
            v327 = propertyValueOut.value;
            if (propertyValueOut.value)
            {
              v334 = (unint64_t *)(propertyValueOut.value + 8);
              do
                v329 = __ldaxr(v334);
              while (__stlxr(v329 - 1, v334));
LABEL_494:
              if (!v329)
                (*(void (**)(CMTimeValue))(*(_QWORD *)v327 + 16))(v327);
            }
          }
LABEL_505:
          v129 = v458.value;
          if (!*(_DWORD *)(a1 + 2164))
            goto LABEL_508;
          goto LABEL_506;
        case 1:
          sub_1B679E43C(&propertyValueOut, *(id **)(a1 + 2272), (uint64_t)buffer, &v447, buf);
          v323 = propertyValueOut.value;
          propertyValueOut.value = 0;
          v324 = *(unint64_t **)(v129 + 248);
          *(_QWORD *)(v129 + 248) = v323;
          if (v324)
          {
            v325 = v324 + 1;
            do
              v326 = __ldaxr(v325);
            while (__stlxr(v326 - 1, v325));
            if (!v326)
              (*(void (**)(unint64_t *))(*v324 + 16))(v324);
            v327 = propertyValueOut.value;
            if (propertyValueOut.value)
            {
              v328 = (unint64_t *)(propertyValueOut.value + 8);
              do
                v329 = __ldaxr(v328);
              while (__stlxr(v329 - 1, v328));
              goto LABEL_494;
            }
          }
          goto LABEL_505;
      }
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
LABEL_506:
        if (*(_QWORD *)(v129 + 248))
        {
          v338 = *(const UInt8 **)(a1 + 2288);
          sub_1B6790958((std::__assoc_sub_state_vtbl **)&v420, (std::__assoc_sub_state **)(v129 + 248));
          sub_1B679D9C8(v338, v420, *(_DWORD *)(a1 + 132));
          v129 = v458.value;
          *(_DWORD *)(v458.value + 256) = v339;
          sub_1B67704D8((const void **)&v420);
          sub_1B6790B60(MutableCopy, *(float *)(v129 + 256));
        }
        goto LABEL_508;
      }
      v335 = *(_DWORD *)(a1 + 24);
      v336 = "H.264";
      if (v335 > 1718908519)
      {
        if (v335 == 1752589105)
          goto LABEL_503;
        v337 = 1718908520;
      }
      else
      {
        if (v335 == 1684632424)
          goto LABEL_503;
        v337 = 1685481521;
      }
      if (v335 != v337)
      {
LABEL_504:
        LODWORD(propertyValueOut.value) = 134219010;
        *(CMTimeValue *)((char *)&propertyValueOut.value + 4) = a1;
        LOWORD(propertyValueOut.flags) = 1024;
        *(CMTimeFlags *)((char *)&propertyValueOut.flags + 2) = v320;
        WORD1(propertyValueOut.epoch) = 1024;
        HIDWORD(propertyValueOut.epoch) = v321;
        *(_WORD *)v444 = 2080;
        *(_QWORD *)&v444[2] = v336;
        *(_WORD *)&v444[10] = 1024;
        *(_DWORD *)&v444[12] = v322;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Invalid histogram correlation mode %d!\n", (uint8_t *)&propertyValueOut, 0x28u);
        goto LABEL_505;
      }
LABEL_503:
      v336 = "HEVC";
      goto LABEL_504;
    }
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
LABEL_467:
      *(_BYTE *)(v129 + 46) = 1;
      goto LABEL_468;
    }
    v296 = *(_DWORD *)(a1 + 60);
    v295 = *(_DWORD *)(a1 + 64);
    v297 = *(_DWORD *)(a1 + 24);
    v298 = "H.264";
    if (v297 > 1718908519)
    {
      if (v297 == 1752589105)
        goto LABEL_465;
      v299 = 1718908520;
    }
    else
    {
      if (v297 == 1684632424)
        goto LABEL_465;
      v299 = 1685481521;
    }
    if (v297 != v299)
    {
LABEL_466:
      v311 = a3->value;
      v312 = *(_QWORD *)(a1 + 2200);
      v313 = *(_QWORD *)a4;
      LODWORD(propertyValueOut.value) = 134219522;
      *(CMTimeValue *)((char *)&propertyValueOut.value + 4) = a1;
      LOWORD(propertyValueOut.flags) = 1024;
      *(CMTimeFlags *)((char *)&propertyValueOut.flags + 2) = v296;
      WORD1(propertyValueOut.epoch) = 1024;
      HIDWORD(propertyValueOut.epoch) = v295;
      *(_WORD *)v444 = 2080;
      *(_QWORD *)&v444[2] = v298;
      *(_WORD *)&v444[10] = 2048;
      *(_QWORD *)&v444[12] = v311;
      *(_WORD *)&v444[20] = 2048;
      *(_QWORD *)&v444[22] = v312;
      v445 = 2048;
      v446 = v313;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Encoder got out of order input frame, current/previous timestamps = %lld/%lld, duration = %lld\n", (uint8_t *)&propertyValueOut, 0x40u);
      goto LABEL_467;
    }
LABEL_465:
    v298 = "HEVC";
    goto LABEL_466;
  }
  HeightOfPlane = CVPixelBufferGetHeightOfPlane(v80, 0);
  v122 = *(int *)(a1 + 72);
  v400 = *(_DWORD *)(a1 + 76);
  v454 = 0;
  v455 = 0;
  *(_QWORD *)buf = 0;
  propertyValueOut.value = (CMTimeValue)buf;
  LOBYTE(propertyValueOut.timescale) = 0;
  if ((_DWORD)v122)
  {
    sub_1B6790CEC(buf, v122);
    v123 = v454;
    bzero(v454, 8 * v122);
    v454 = (__CFString *)((char *)v123 + 8 * v122);
    v124 = *(int *)(a1 + 72);
    v447 = 0uLL;
    v448 = 0;
    if ((_DWORD)v124)
    {
      if ((v124 & 0x80000000) != 0)
        sub_1B6773BAC();
      v125 = (char *)operator new(v124);
      v126 = (unsigned __int8 *)v125;
      v127 = 0;
      v128 = &v125[v124];
      do
        v125[v127++] = 1;
      while (v124 != v127);
    }
    else
    {
      v126 = 0;
      v128 = 0;
    }
  }
  else
  {
    v126 = 0;
    v128 = 0;
    v447 = 0uLL;
    v448 = 0;
  }
  v397 = v126;
  if (((v408 ^ 1) & 1) != 0)
  {
    if (v112
      && sub_1B678C718(a1, theDict, HeightOfPlane, (uint64_t)v126)
      && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(propertyValueOut.value) = 0;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "error in ComputeDirtyTiles\n", (uint8_t *)&propertyValueOut, 2u);
    }
  }
  else if (v128 - (char *)v126 >= 1)
  {
    bzero(v126, v128 - (char *)v126);
  }
  LODWORD(v133) = *(_DWORD *)(a1 + 72);
  if ((int)v133 < 1)
    goto LABEL_339;
  v134 = 0;
  LODWORD(v135) = 0;
  v136 = 0;
  do
  {
    v137 = *(_DWORD *)(a1 + 84);
    v138 = v126[v134];
    v139 = operator new();
    v412 = (unsigned __int16)(v137 + v400) | (unint64_t)(v134 << 32);
    sub_1B6790754(v139, a6, v134, v136, v138 == 0, v403 != 0, v412, Seconds, ID, v134 == (_DWORD)v133 - 1);
    propertyValueOut.value = v139;
    v140 = (_QWORD *)v447.i64[1];
    if (v447.i64[1] >= (unint64_t)v448)
    {
      v142 = (_QWORD *)v447.i64[0];
      v143 = (v447.i64[1] - v447.i64[0]) >> 3;
      v144 = v143 + 1;
      if ((unint64_t)(v143 + 1) >> 61)
        sub_1B6773BAC();
      v145 = (uint64_t)&v448[-v447.i64[0]];
      if ((uint64_t)&v448[-v447.i64[0]] >> 2 > v144)
        v144 = v145 >> 2;
      if ((unint64_t)v145 >= 0x7FFFFFFFFFFFFFF8)
        v146 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v146 = v144;
      if (v146)
      {
        if (v146 >> 61)
          sub_1B6773BF4();
        v147 = (char *)operator new(8 * v146);
      }
      else
      {
        v147 = 0;
      }
      v148 = (uint64_t *)&v147[8 * v143];
      propertyValueOut.value = 0;
      *v148 = v139;
      v141 = v148 + 1;
      if (v140 == v142)
      {
        v151 = 0;
        v150 = vdupq_n_s64((unint64_t)v140);
      }
      else
      {
        do
        {
          v149 = *--v140;
          *v140 = 0;
          *--v148 = v149;
        }
        while (v140 != v142);
        v150 = v447;
        v151 = propertyValueOut.value;
      }
      v447.i64[0] = (uint64_t)v148;
      v447.i64[1] = (uint64_t)v141;
      v448 = &v147[8 * v146];
      v153 = (uint64_t *)v150.i64[1];
      v152 = (uint64_t *)v150.i64[0];
      while (v153 != v152)
        sub_1B67908B8(--v153);
      if (v152)
        operator delete(v152);
      v447.i64[1] = (uint64_t)v141;
      v126 = v397;
      if (v151)
      {
        v154 = sub_1B678B1B4(v151);
        MEMORY[0x1BCC9814C](v154, 0x10A0C40973F72EDLL);
        v141 = (_QWORD *)v447.i64[1];
      }
    }
    else
    {
      *(_QWORD *)v447.i64[1] = v139;
      v447.i64[1] = (uint64_t)(v140 + 1);
      v141 = v140 + 1;
    }
    v155 = *(_QWORD *)(a1 + 2184);
    v156 = *(v141 - 1);
    if (v155)
    {
      v157 = *(unsigned __int8 *)(v156 + 45);
      v437 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E18];
      v436 = v437;
      v158 = sub_1B6779994(v155, v134, v157, v408 ^ 1, 0, &v437, &v436);
      *(_BYTE *)(*(v141 - 1) + 46) = v158;
    }
    else
    {
      v158 = *(unsigned __int8 *)(v156 + 46);
    }
    if (v158)
      v135 = v135;
    else
      v135 = v134;
    ++v134;
    v136 += *(_DWORD *)(a1 + 64);
    v133 = *(int *)(a1 + 72);
  }
  while (v134 < v133);
  if ((int)v133 < 1)
  {
LABEL_339:
    v229 = 0;
LABEL_340:
    v458 = *a3;
    memset(&pixelBufferOut, 0, sizeof(pixelBufferOut));
    v230 = *(double *)(a1 + 88);
    v231 = *((_DWORD *)a4 + 2);
    if (v230 <= 0.0)
      v232 = *(_QWORD *)a4 / (int)v133;
    else
      v232 = (uint64_t)((double)v231 / v230);
    CMTimeMake(&pixelBufferOut, v232, v231);
    v233 = valuePtr;
    if (v229 < 1)
    {
      v234 = HIDWORD(valuePtr);
      v235 = v439;
    }
    else
    {
      v233 = (int)valuePtr / v229;
      v234 = SHIDWORD(valuePtr) / v229;
      v235 = v439 / v229;
    }
    v407 = v235;
    if (*(int *)(a1 + 72) < 1)
    {
      v280 = 0;
      v279 = v410;
      goto LABEL_414;
    }
    v236 = 0;
    key = (void *)*MEMORY[0x1E0CED638];
    v388 = (void *)*MEMORY[0x1E0CED5B8];
    v390 = (const void *)*MEMORY[0x1E0C9AE50];
    v386 = (const void *)*MEMORY[0x1E0CED5C8];
    v377 = (void *)*MEMORY[0x1E0CED5A8];
    v380 = (void *)*MEMORY[0x1E0CED590];
    v379 = (void *)*MEMORY[0x1E0CED5F0];
    v378 = (void *)*MEMORY[0x1E0CED608];
    v385 = (const void *)*MEMORY[0x1E0CED620];
    v384 = (const void *)*MEMORY[0x1E0C9AE40];
    allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v381 = (void *)*MEMORY[0x1E0CED640];
    v237 = v410;
    v405 = v233;
    theDictb = v234;
    while (1)
    {
      v238 = v447.i64[0];
      v239 = *(_QWORD *)(v447.i64[0] + 8 * v236);
      *(_DWORD *)(v239 + 256) = 2139095039;
      if (*(_DWORD *)(a1 + 2164) && *(_QWORD *)(v239 + 248))
      {
        v240 = *(_QWORD *)(a1 + 2288);
        sub_1B6790958((std::__assoc_sub_state_vtbl **)&theData, (std::__assoc_sub_state **)(v239 + 248));
        sub_1B679D9C8((const UInt8 *)(v240 + 8224 * v236), theData, *(_DWORD *)(a1 + 132));
        *(_DWORD *)(*(_QWORD *)(v238 + 8 * v236) + 256) = v241;
        sub_1B67704D8((const void **)&theData);
        LODWORD(propertyValueOut.value) = *(_DWORD *)(*(_QWORD *)(v238 + 8 * v236) + 256);
        v242 = CFNumberCreate(0, kCFNumberFloatType, &propertyValueOut);
        if (v242)
        {
          CFDictionarySetValue(MutableCopy, CFSTR("HistCorr"), v242);
          CFRelease(v242);
        }
        v239 = *(_QWORD *)(v238 + 8 * v236);
      }
      v243 = (void **)(v239 + 272);
      if ((uint8_t *)(v239 + 272) != buf)
      {
        v245 = *(__CFString **)buf;
        v244 = (uint64_t *)v454;
        v246 = ((uint64_t)v454 - *(_QWORD *)buf) >> 3;
        v247 = *(_QWORD *)(v239 + 288);
        v248 = *(unint64_t ***)(v239 + 272);
        if (v246 <= (v247 - (uint64_t)v248) >> 3)
        {
          v251 = (uint64_t)(*(_QWORD *)(v239 + 280) - (_QWORD)v248) >> 3;
          if (v251 >= v246)
          {
            v253 = sub_1B6790C20(*(unint64_t ***)buf, (unint64_t **)v454, v248);
            v254 = *(unint64_t ***)(v239 + 280);
            v233 = v405;
            v234 = theDictb;
            while (v254 != v253)
            {
              v256 = *--v254;
              v255 = v256;
              if (v256)
              {
                v257 = v255 + 1;
                do
                  v258 = __ldaxr(v257);
                while (__stlxr(v258 - 1, v257));
                if (!v258)
                  (*(void (**)(unint64_t *))(*v255 + 16))(v255);
              }
            }
            *(_QWORD *)(v239 + 280) = v253;
          }
          else
          {
            v252 = (unint64_t **)(*(_QWORD *)buf + 8 * v251);
            sub_1B6790C20(*(unint64_t ***)buf, v252, v248);
            *(_QWORD *)(v239 + 280) = sub_1B6790CB0(v239 + 288, (uint64_t *)v252, v244, *(uint64_t **)(v239 + 280));
            v233 = v405;
            v234 = theDictb;
          }
        }
        else
        {
          if (v248)
          {
            sub_1B678B2B4((unint64_t *)(v239 + 272));
            operator delete(*v243);
            v247 = 0;
            *v243 = 0;
            *(_QWORD *)(v239 + 280) = 0;
            *(_QWORD *)(v239 + 288) = 0;
          }
          if ((char *)v244 - (char *)v245 < 0)
            sub_1B6773BAC();
          v249 = v247 >> 2;
          if (v247 >> 2 <= v246)
            v249 = ((char *)v244 - (char *)v245) >> 3;
          if ((unint64_t)v247 >= 0x7FFFFFFFFFFFFFF8)
            v250 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v250 = v249;
          sub_1B6790CEC((_QWORD *)(v239 + 272), v250);
          v233 = v405;
          v234 = theDictb;
          *(_QWORD *)(v239 + 280) = sub_1B6790CB0(v239 + 288, (uint64_t *)v245, v244, *(uint64_t **)(v239 + 280));
        }
      }
      sub_1B678AAF4(*(std::__assoc_sub_state **)(*(_QWORD *)buf + 8 * v236));
      if (*v259)
      {
        v260 = *(_QWORD *)(v238 + 8 * v236);
        *(_QWORD *)(v238 + 8 * v236) = 0;
        sub_1B67886D4(a1, v260, v237, 2, 0);
      }
      else
      {
        v261 = *(_DWORD *)(a1 + 80);
        v262 = *(_QWORD *)(v238 + 8 * v236);
        *(_DWORD *)(v262 + 24) = v261;
        *(_DWORD *)(v262 + 28) = v234;
        *(_DWORD *)(v262 + 36) = v233;
        *(_DWORD *)(v262 + 40) = 0;
        *(_QWORD *)(v262 + 96) = v438;
        *(_DWORD *)(a1 + 80) = v261 + 1;
        v263 = *(_QWORD *)(a1 + 2184);
        if (v263)
        {
          v264 = *(_BYTE *)(v262 + 45);
          v433 = v458;
          sub_1B6779E28(v263, v236, v261, v264, (uint64_t)&v433, v234, v233, 0);
        }
        propertyValueOut = v458;
        *(Float64 *)(*(_QWORD *)(v238 + 8 * v236) + 72) = CMTimeGetSeconds(&propertyValueOut);
        v265 = CFDictionaryCreateMutableCopy(0, 0, MutableCopy);
        LODWORD(propertyValueOut.value) = *(_DWORD *)(*(_QWORD *)(v238 + 8 * v236) + 8);
        v266 = CFNumberCreate(0, kCFNumberSInt32Type, &propertyValueOut);
        if (v266)
        {
          CFDictionarySetValue(v265, key, v266);
          CFRelease(v266);
        }
        if (v403)
          CFDictionarySetValue(v265, v388, v390);
        else
          CFDictionaryRemoveValue(v265, v388);
        if (v396)
        {
          CFDictionarySetValue(v265, v386, v390);
        }
        else
        {
          CFDictionaryRemoveValue(v265, v386);
          CFDictionaryRemoveValue(v265, v377);
        }
        if (v233 >= 1)
        {
          LODWORD(propertyValueOut.value) = v233;
          v267 = CFNumberCreate(0, kCFNumberSInt32Type, &propertyValueOut);
          if (v267)
          {
            CFDictionarySetValue(v265, v380, v267);
            CFRelease(v267);
          }
        }
        if (v234 >= 1)
        {
          LODWORD(propertyValueOut.value) = v234;
          v268 = CFNumberCreate(0, kCFNumberSInt32Type, &propertyValueOut);
          if (v268)
          {
            CFDictionarySetValue(v265, v379, v268);
            CFRelease(v268);
          }
        }
        if (v407 >= 1)
        {
          LODWORD(propertyValueOut.value) = v407;
          v269 = CFNumberCreate(0, kCFNumberSInt32Type, &propertyValueOut);
          if (v269)
          {
            CFDictionarySetValue(v265, v378, v269);
            CFRelease(v269);
          }
        }
        if (*(_BYTE *)(*(_QWORD *)(v238 + 8 * v236) + 45))
          v270 = v390;
        else
          v270 = v384;
        CFDictionarySetValue(v265, v385, v270);
        memset(&propertyValueOut, 0, sizeof(propertyValueOut));
        propertyValueOut.value = (CMTimeValue)CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(*(_QWORD *)(v238 + 8 * v236) + 12));
        *(_QWORD *)&propertyValueOut.timescale = CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(*(_QWORD *)(v238 + 8 * v236) + 16));
        propertyValueOut.epoch = (CMTimeEpoch)CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(*(_QWORD *)(v238 + 8 * v236) + 20));
        v271 = CFArrayCreate(allocator, (const void **)&propertyValueOut, 3, MEMORY[0x1E0C9B378]);
        if (v271)
        {
          CFDictionarySetValue(v265, v381, v271);
          CFRelease(v271);
        }
        CFRelease((CFTypeRef)propertyValueOut.value);
        CFRelease(*(CFTypeRef *)&propertyValueOut.timescale);
        CFRelease((CFTypeRef)propertyValueOut.epoch);
        values = *(void **)(*(_QWORD *)(v238 + 8 * v236) + 48);
        v272 = CFNumberCreate(0, kCFNumberSInt64Type, &values);
        if (v272)
        {
          CFDictionarySetValue(v265, CFSTR("SignpostTimeStamp"), v272);
          CFRelease(v272);
        }
        values = *(void **)(*(_QWORD *)(v238 + 8 * v236) + 64);
        v273 = CFNumberCreate(0, kCFNumberSInt64Type, &values);
        if (v273)
        {
          CFDictionarySetValue(v265, CFSTR("SignpostID"), v273);
          CFRelease(v273);
        }
        v274 = *(_QWORD *)(v238 + 8 * v236);
        v275 = *(std::__assoc_sub_state **)(v274 + 232);
        if (v275)
        {
          std::__assoc_sub_state::wait(v275);
          v274 = *(_QWORD *)(v238 + 8 * v236);
        }
        v412 = *(_QWORD *)(v274 + 64);
        v413 = *(_QWORD *)(v274 + 48);
        ID = *(_DWORD *)(v274 + 56);
        kdebug_trace();
        v276 = *(OpaqueVTCompressionSession **)(a1 + 16);
        v277 = *(__CVBuffer **)(*(_QWORD *)(v238 + 8 * v236) + 216);
        presentationTimeStamp = v458;
        duration = pixelBufferOut;
        v278 = *(void **)(v238 + 8 * v236);
        *(_QWORD *)(v238 + 8 * v236) = 0;
        LODWORD(v237) = VTCompressionSessionEncodeFrame(v276, v277, &presentationTimeStamp, &duration, v265, v278, infoFlagsOut);
        kdebug_trace();
        if (v265)
          CFRelease(v265);
      }
      --v411;
      if ((_DWORD)v237)
        break;
      lhs = v458;
      rhs = pixelBufferOut;
      v126 = v397;
      CMTimeAdd(&propertyValueOut, &lhs, &rhs);
      v237 = 0;
      v279 = 0;
      v280 = 0;
      ++v236;
      v458 = propertyValueOut;
      if (v236 >= *(int *)(a1 + 72))
        goto LABEL_414;
    }
    v126 = v397;
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
LABEL_413:
      v280 = 7;
      v279 = -12902;
LABEL_414:
      v410 = v279;
      if (!v126)
        goto LABEL_416;
      goto LABEL_415;
    }
    v307 = *(_DWORD *)(a1 + 60);
    v306 = *(_DWORD *)(a1 + 64);
    v308 = *(_DWORD *)(a1 + 24);
    v309 = "H.264";
    if (v308 > 1718908519)
    {
      if (v308 == 1752589105)
        goto LABEL_562;
      v310 = 1718908520;
    }
    else
    {
      if (v308 == 1684632424)
        goto LABEL_562;
      v310 = 1685481521;
    }
    if (v308 != v310)
    {
LABEL_563:
      LODWORD(propertyValueOut.value) = 134219522;
      *(CMTimeValue *)((char *)&propertyValueOut.value + 4) = a1;
      LOWORD(propertyValueOut.flags) = 1024;
      *(CMTimeFlags *)((char *)&propertyValueOut.flags + 2) = v307;
      WORD1(propertyValueOut.epoch) = 1024;
      HIDWORD(propertyValueOut.epoch) = v306;
      *(_WORD *)v444 = 2080;
      *(_QWORD *)&v444[2] = v309;
      *(_WORD *)&v444[10] = 1024;
      *(_DWORD *)&v444[12] = v237;
      *(_WORD *)&v444[16] = 1024;
      *(_DWORD *)&v444[18] = v236;
      *(_WORD *)&v444[22] = 1024;
      *(_DWORD *)&v444[24] = v400;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VCPEnc %p (%dx%d, %s): Encoder fails with err = %d, tile id %d order %d\n", (uint8_t *)&propertyValueOut, 0x34u);
      goto LABEL_413;
    }
LABEL_562:
    v309 = "HEVC";
    goto LABEL_563;
  }
  v159 = 0;
  theDicta = 0;
  while (1)
  {
    v160 = v447.i64[0];
    v161 = *(_QWORD *)(v447.i64[0] + 8 * v159);
    if (*(_BYTE *)(v161 + 45))
      *(_QWORD *)(v161 + 88) = 0;
    if (*(_BYTE *)(v161 + 46))
    {
      v162 = operator new();
      *(_QWORD *)(v162 + 8) = 0;
      v163 = (unint64_t *)(v162 + 8);
      *(_QWORD *)(v162 + 16) = 0;
      *(_QWORD *)(v162 + 24) = 850045863;
      *(_OWORD *)(v162 + 32) = 0u;
      *(_OWORD *)(v162 + 48) = 0u;
      *(_OWORD *)(v162 + 64) = 0u;
      *(_QWORD *)(v162 + 80) = 0;
      *(_QWORD *)(v162 + 88) = 1018212795;
      *(_OWORD *)(v162 + 96) = 0u;
      *(_OWORD *)(v162 + 112) = 0u;
      *(_QWORD *)(v162 + 128) = 0;
      *(_QWORD *)v162 = &off_1E6A15E60;
      *(_DWORD *)(v162 + 136) = 8;
      sub_1B67804AC(v162);
      do
        v164 = __ldaxr(v163);
      while (__stlxr(v164 - 1, v163));
      if (!v164)
        (*(void (**)(uint64_t))(*(_QWORD *)v162 + 16))(v162);
      v165 = *(unint64_t **)(*(_QWORD *)buf + 8 * v159);
      *(_QWORD *)(*(_QWORD *)buf + 8 * v159) = v162;
      if (v165)
      {
        v166 = v165 + 1;
        do
          v167 = __ldaxr(v166);
        while (__stlxr(v167 - 1, v166));
        if (!v167)
          (*(void (**)(unint64_t *))(*v165 + 16))(v165);
      }
      goto LABEL_337;
    }
    *(_BYTE *)(v161 + 80) = v159 == v135;
    pixelBufferOut.value = 0;
    v168 = *(_QWORD *)(v160 + 8 * v159);
    v170 = *(_DWORD *)(v168 + 12);
    v169 = *(_DWORD *)(v168 + 16);
    v171 = (signed int)(HeightOfPlane - v169) >= *(_DWORD *)(a1 + 64) ? *(_DWORD *)(a1 + 64) : HeightOfPlane - v169;
    LODWORD(values) = *(_DWORD *)(a1 + 60);
    HIDWORD(values) = v171;
    value = (void *)__PAIR64__(v169, v170);
    v389 = *(id **)(a1 + 96);
    v172 = *(_QWORD *)(a1 + 112);
    if (!v172 || v403 || v396 || *(_BYTE *)(v168 + 45))
    {
      v173 = operator new();
      *(_QWORD *)(v173 + 8) = 0;
      v174 = (unint64_t *)(v173 + 8);
      *(_QWORD *)(v173 + 16) = 0;
      *(_QWORD *)(v173 + 24) = 850045863;
      *(_OWORD *)(v173 + 32) = 0u;
      *(_OWORD *)(v173 + 48) = 0u;
      *(_OWORD *)(v173 + 64) = 0u;
      *(_QWORD *)(v173 + 80) = 0;
      *(_QWORD *)(v173 + 88) = 1018212795;
      *(_OWORD *)(v173 + 96) = 0u;
      *(_OWORD *)(v173 + 112) = 0u;
      *(_QWORD *)(v173 + 128) = 0;
      *(_QWORD *)v173 = &off_1E6A15EC0;
      *(_DWORD *)(v173 + 136) = 8;
      sub_1B67804AC(v173);
      do
        v175 = __ldaxr(v174);
      while (__stlxr(v175 - 1, v174));
      if (!v175)
        (*(void (**)(uint64_t))(*(_QWORD *)v173 + 16))(v173);
      v176 = *(unint64_t **)(*(_QWORD *)buf + 8 * v159);
      *(_QWORD *)(*(_QWORD *)buf + 8 * v159) = v173;
      if (v176)
      {
        v177 = v176 + 1;
        do
          v178 = __ldaxr(v177);
        while (__stlxr(v178 - 1, v177));
        goto LABEL_275;
      }
    }
    else
    {
      v179 = (void *)MEMORY[0x1BCC98608]();
      v180 = *v389;
      v181 = v180;
      *(_QWORD *)&v182 = (int)value;
      *((_QWORD *)&v182 + 1) = SHIDWORD(value);
      *(_OWORD *)&propertyValueOut.value = v182;
      *(_QWORD *)&v182 = (int)values;
      *((_QWORD *)&v182 + 1) = SHIDWORD(values);
      *(_OWORD *)v444 = v182;
      propertyValueOut.epoch = 0;
      *(_QWORD *)&v444[16] = 1;
      if (v180)
        objc_msgSend(v180, "temporalTransitionScore:previousFrame:forRegion:", buffer, v172, &propertyValueOut);
      else
        v458.value = 0;

      objc_autoreleasePoolPop(v179);
      v183 = *(_QWORD *)(v160 + 8 * v159);
      v184 = v458.value;
      v458.value = 0;
      v185 = *(unint64_t **)(v183 + 240);
      *(_QWORD *)(v183 + 240) = v184;
      if (v185)
      {
        v186 = v185 + 1;
        do
          v187 = __ldaxr(v186);
        while (__stlxr(v187 - 1, v186));
        if (!v187)
          (*(void (**)(unint64_t *))(*v185 + 16))(v185);
        v188 = v458.value;
        if (v458.value)
        {
          v189 = (unint64_t *)(v458.value + 8);
          do
            v190 = __ldaxr(v189);
          while (__stlxr(v190 - 1, v189));
          if (!v190)
            (*(void (**)(CMTimeValue))(*(_QWORD *)v188 + 16))(v188);
        }
      }
      v191 = *(_QWORD *)(v160 + 8 * v159);
      v192 = operator new();
      *(_QWORD *)(v192 + 8) = 0;
      v193 = (unint64_t *)(v192 + 8);
      *(_QWORD *)(v192 + 16) = 0;
      *(_QWORD *)(v192 + 24) = 850045863;
      *(_OWORD *)(v192 + 32) = 0u;
      *(_OWORD *)(v192 + 48) = 0u;
      *(_OWORD *)(v192 + 64) = 0u;
      *(_QWORD *)(v192 + 80) = 0;
      *(_QWORD *)(v192 + 88) = 1018212795;
      *(_OWORD *)(v192 + 96) = 0u;
      *(_OWORD *)(v192 + 112) = 0u;
      *(_QWORD *)(v192 + 128) = 0;
      *(_QWORD *)v192 = &off_1E6A15E90;
      *(_QWORD *)(v192 + 144) = a1;
      *(_QWORD *)(v192 + 152) = v191;
      *(_DWORD *)(v192 + 160) = v159;
      *(_BYTE *)(v192 + 164) = v408;
      *(_DWORD *)(v192 + 136) = 8;
      sub_1B67804AC(v192);
      do
        v194 = __ldaxr(v193);
      while (__stlxr(v194 - 1, v193));
      if (!v194)
        (*(void (**)(uint64_t))(*(_QWORD *)v192 + 16))(v192);
      v176 = *(unint64_t **)(*(_QWORD *)buf + 8 * v159);
      *(_QWORD *)(*(_QWORD *)buf + 8 * v159) = v192;
      if (v176)
      {
        v195 = v176 + 1;
        do
          v178 = __ldaxr(v195);
        while (__stlxr(v178 - 1, v195));
LABEL_275:
        if (!v178)
          (*(void (**)(unint64_t *))(*v176 + 16))(v176);
      }
    }
    v196 = *(_DWORD *)(a1 + 2164);
    if (!v196)
      goto LABEL_329;
    if (v196 != 2)
    {
      if (v196 == 1)
      {
        sub_1B679E43C(&propertyValueOut, *(id **)(a1 + 2272), (uint64_t)buffer, &value, &values);
        v197 = *(_QWORD *)(v160 + 8 * v159);
        v198 = propertyValueOut.value;
        propertyValueOut.value = 0;
        v199 = *(unint64_t **)(v197 + 248);
        *(_QWORD *)(v197 + 248) = v198;
        if (v199)
        {
          v200 = v199 + 1;
          do
            v201 = __ldaxr(v200);
          while (__stlxr(v201 - 1, v200));
          if (!v201)
            (*(void (**)(unint64_t *))(*v199 + 16))(v199);
          v202 = propertyValueOut.value;
          if (propertyValueOut.value)
          {
            v203 = (unint64_t *)(propertyValueOut.value + 8);
            do
              v204 = __ldaxr(v203);
            while (__stlxr(v204 - 1, v203));
            goto LABEL_318;
          }
        }
        goto LABEL_329;
      }
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        goto LABEL_329;
      v211 = *(_DWORD *)(a1 + 24);
      if (v211 > 1718908519)
      {
        if (v211 == 1752589105)
          goto LABEL_327;
        v212 = "H.264";
        v213 = 1718908520;
      }
      else
      {
        if (v211 == 1684632424)
          goto LABEL_327;
        v212 = "H.264";
        v213 = 1685481521;
      }
      if (v211 != v213)
      {
LABEL_328:
        v214 = *(_DWORD *)(a1 + 60);
        v215 = *(_DWORD *)(a1 + 64);
        LODWORD(propertyValueOut.value) = 134219010;
        *(CMTimeValue *)((char *)&propertyValueOut.value + 4) = a1;
        LOWORD(propertyValueOut.flags) = 1024;
        *(CMTimeFlags *)((char *)&propertyValueOut.flags + 2) = v214;
        WORD1(propertyValueOut.epoch) = 1024;
        HIDWORD(propertyValueOut.epoch) = v215;
        *(_WORD *)v444 = 2080;
        *(_QWORD *)&v444[2] = v212;
        *(_WORD *)&v444[10] = 1024;
        *(_DWORD *)&v444[12] = v196;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Invalid histogram correlation mode %d!\n", (uint8_t *)&propertyValueOut, 0x28u);
        goto LABEL_329;
      }
LABEL_327:
      v212 = "HEVC";
      goto LABEL_328;
    }
    sub_1B679D378(&propertyValueOut.value, *(VTPixelTransferSessionRef **)(a1 + 2280), buffer, (int *)&value, (int *)&values);
    v205 = *(_QWORD *)(v160 + 8 * v159);
    v206 = propertyValueOut.value;
    propertyValueOut.value = 0;
    v207 = *(unint64_t **)(v205 + 248);
    *(_QWORD *)(v205 + 248) = v206;
    if (v207)
    {
      v208 = v207 + 1;
      do
        v209 = __ldaxr(v208);
      while (__stlxr(v209 - 1, v208));
      if (!v209)
        (*(void (**)(unint64_t *))(*v207 + 16))(v207);
      v202 = propertyValueOut.value;
      if (propertyValueOut.value)
      {
        v210 = (unint64_t *)(propertyValueOut.value + 8);
        do
          v204 = __ldaxr(v210);
        while (__stlxr(v204 - 1, v210));
LABEL_318:
        if (!v204)
          (*(void (**)(CMTimeValue))(*(_QWORD *)v202 + 16))(v202);
      }
    }
LABEL_329:
    PixelBufferPool = VTCompressionSessionGetPixelBufferPool(*(VTCompressionSessionRef *)(a1 + 16));
    if (CVPixelBufferPoolCreatePixelBuffer(0, PixelBufferPool, (CVPixelBufferRef *)&pixelBufferOut))
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        goto LABEL_452;
      v282 = *(_DWORD *)(a1 + 60);
      v281 = *(_DWORD *)(a1 + 64);
      v283 = *(_DWORD *)(a1 + 24);
      v284 = "H.264";
      if (v283 > 1718908519)
      {
        if (v283 == 1752589105)
          goto LABEL_574;
        v285 = 1718908520;
      }
      else
      {
        if (v283 == 1684632424)
          goto LABEL_574;
        v285 = 1685481521;
      }
      if (v283 != v285)
      {
LABEL_575:
        LODWORD(propertyValueOut.value) = 134219266;
        *(CMTimeValue *)((char *)&propertyValueOut.value + 4) = a1;
        LOWORD(propertyValueOut.flags) = 1024;
        *(CMTimeFlags *)((char *)&propertyValueOut.flags + 2) = v282;
        WORD1(propertyValueOut.epoch) = 1024;
        HIDWORD(propertyValueOut.epoch) = v281;
        *(_WORD *)v444 = 2080;
        *(_QWORD *)&v444[2] = v284;
        *(_WORD *)&v444[10] = 1024;
        *(_DWORD *)&v444[12] = v159;
        *(_WORD *)&v444[16] = 1024;
        *(_DWORD *)&v444[18] = v400;
        v373 = MEMORY[0x1E0C81028];
        v374 = "VCPEnc %p (%dx%d, %s): Encoder failed to create buffer for tile id %d, order %d\n";
        goto LABEL_581;
      }
LABEL_574:
      v284 = "HEVC";
      goto LABEL_575;
    }
    CVBufferPropagateAttachments(buffer, (CVBufferRef)pixelBufferOut.value);
    v217 = (__CVBuffer *)pixelBufferOut.value;
    *(_QWORD *)(*(_QWORD *)(v160 + 8 * v159) + 216) = pixelBufferOut.value;
    v218 = CVPixelBufferGetIOSurface(v217);
    if (v218)
      LODWORD(v218) = IOSurfaceGetID(v218);
    *(_DWORD *)(*(_QWORD *)(v160 + 8 * v159) + 56) = (_DWORD)v218;
    v219 = kdebug_trace();
    if (*(_QWORD *)(a1 + 96))
    {
      v220 = (__CVBuffer *)pixelBufferOut.value;
      if (pixelBufferOut.value)
        break;
    }
LABEL_336:
    kdebug_trace();
    sub_1B67ED940(*(_QWORD *)(v160 + 8 * v159) + 176);
    ++v400;
    ++theDicta;
LABEL_337:
    ++v159;
    v133 = *(int *)(a1 + 72);
    if (v159 >= v133)
    {
      v126 = v397;
      v229 = theDicta;
      goto LABEL_340;
    }
  }
  v221 = *(_QWORD *)(v160 + 8 * v159);
  v222 = *(_QWORD *)(v221 + 12);
  v223 = *(int *)(a1 + 60);
  v224 = (void *)MEMORY[0x1BCC98608](v219);
  PixelFormatType = CVPixelBufferGetPixelFormatType(buffer);
  if (PixelFormatType == CVPixelBufferGetPixelFormatType(v220))
  {
    v226 = *v389;
    *(_QWORD *)&v227 = (int)v222;
    *((_QWORD *)&v227 + 1) = SHIDWORD(v222);
    *(_OWORD *)&propertyValueOut.value = v227;
    propertyValueOut.epoch = 0;
    v458.value = v223;
    *(_QWORD *)&v458.timescale = v171;
    v458.epoch = 1;
    v228 = objc_msgSend(v226, "copyFromFrame:toTile:origin:size:withFence:", buffer, v220, &propertyValueOut, &v458, v221 + 232);
    objc_autoreleasePoolPop(v224);
    if (v228)
      goto LABEL_451;
    goto LABEL_336;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v442 = 0;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "pixfmt mismatch!", v442, 2u);
  }
  objc_autoreleasePoolPop(v224);
LABEL_451:
  if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    goto LABEL_452;
  v364 = *(_DWORD *)(a1 + 60);
  v363 = *(_DWORD *)(a1 + 64);
  v365 = *(_DWORD *)(a1 + 24);
  v366 = "H.264";
  if (v365 <= 1718908519)
  {
    if (v365 != 1684632424)
    {
      v367 = 1685481521;
      goto LABEL_578;
    }
    goto LABEL_579;
  }
  if (v365 == 1752589105)
    goto LABEL_579;
  v367 = 1718908520;
LABEL_578:
  if (v365 == v367)
LABEL_579:
    v366 = "HEVC";
  LODWORD(propertyValueOut.value) = 134219266;
  *(CMTimeValue *)((char *)&propertyValueOut.value + 4) = a1;
  LOWORD(propertyValueOut.flags) = 1024;
  *(CMTimeFlags *)((char *)&propertyValueOut.flags + 2) = v364;
  WORD1(propertyValueOut.epoch) = 1024;
  HIDWORD(propertyValueOut.epoch) = v363;
  *(_WORD *)v444 = 2080;
  *(_QWORD *)&v444[2] = v366;
  *(_WORD *)&v444[10] = 1024;
  *(_DWORD *)&v444[12] = v159;
  *(_WORD *)&v444[16] = 1024;
  *(_DWORD *)&v444[18] = v400;
  v373 = MEMORY[0x1E0C81028];
  v374 = "VCPEnc %p (%dx%d, %s): Encoder failed to create tile id %d, order %d\n";
LABEL_581:
  _os_log_error_impl(&dword_1B676B000, v373, OS_LOG_TYPE_ERROR, v374, (uint8_t *)&propertyValueOut, 0x2Eu);
LABEL_452:
  v410 = -12902;
  v280 = 7;
  v126 = v397;
  if (v397)
LABEL_415:
    operator delete(v126);
LABEL_416:
  propertyValueOut.value = (CMTimeValue)&v447;
  sub_1B6790A90((void ***)&propertyValueOut);
  propertyValueOut.value = (CMTimeValue)buf;
  sub_1B678B274((void ***)&propertyValueOut);
  if (!v280)
LABEL_528:
    *(_BYTE *)(a1 + 104) = 0;
LABEL_529:
  if (v411 >= 1)
  {
    do
    {
      v352 = operator new();
      sub_1B6790754(v352, a6, 0, 0, v408, v403 != 0, v412, v413, ID, 0);
      propertyValueOut.value = 0;
      sub_1B67886D4(a1, v352, v410, 2, 0);
      --v411;
    }
    while (v411);
  }
  if (MutableCopy)
    CFRelease(MutableCopy);
  v353 = *(const void **)(a1 + 112);
  if (v353)
  {
    CFRelease(v353);
    *(_QWORD *)(a1 + 112) = 0;
  }
  if (*(int *)(a1 + 72) >= 2)
    *(_QWORD *)(a1 + 112) = CVPixelBufferRetain(buffer);
  kdebug_trace();
LABEL_538:
  v33 = v410;
LABEL_539:
  std::mutex::unlock(v398);
  return v33;
}

void sub_1B67903AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,std::mutex *a27)
{
  uint64_t v27;

  sub_1B6770568((const void **)(v27 - 256));
  std::mutex::unlock(a27);
  _Unwind_Resume(a1);
}

CFStringRef sub_1B6790678(double a1, double a2, double a3, double a4)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("{{%.*g, %.*g}, {%.*g, %.*g}}"), 17, *(_QWORD *)&a1, 17, *(_QWORD *)&a2, 17, *(_QWORD *)&a3, 17, *(_QWORD *)&a4);
}

intptr_t sub_1B67906C8(uint64_t a1, int a2, CFDictionaryRef theDict)
{
  uint64_t v4;
  const __CFNumber *Value;
  float valuePtr;

  if (a2)
  {
    v4 = *(_QWORD *)(a1 + 32);
    *(_WORD *)(v4 + 48) = 0;
  }
  else
  {
    valuePtr = 0.0;
    Value = (const __CFNumber *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E0D47698]);
    CFNumberGetValue(Value, kCFNumberFloatType, &valuePtr);
    v4 = *(_QWORD *)(a1 + 32);
    *(_WORD *)(v4 + 48) = (int)fmax(fmin(valuePtr * 255.0, 255.0), 1.0);
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v4 + 2168));
}

uint64_t sub_1B6790754(uint64_t a1, uint64_t a2, int a3, int a4, char a5, char a6, uint64_t a7, uint64_t a8, int a9, char a10)
{
  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 20) = 0;
  *(_QWORD *)(a1 + 36) = 0;
  *(_QWORD *)(a1 + 28) = 0;
  *(_BYTE *)(a1 + 44) = a6;
  *(_BYTE *)(a1 + 45) = a5;
  *(_BYTE *)(a1 + 46) = 0;
  *(_QWORD *)(a1 + 48) = a8;
  *(_DWORD *)(a1 + 56) = a9;
  *(_QWORD *)(a1 + 64) = a7;
  *(_QWORD *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 80) = a10;
  *(_OWORD *)(a1 + 88) = xmmword_1B6917450;
  CMTimeMake((CMTime *)(a1 + 104), 0, 1000);
  CMTimeMake((CMTime *)(a1 + 128), 0, 1000);
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 168) = 0;
  *(_BYTE *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_QWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 256) = 2139095039;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 264) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  return a1;
}

void sub_1B679083C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  std::future<void> *v10;
  void **v11;
  void **v12;
  std::__assoc_sub_state *state;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__assoc_sub_state *v17;
  unint64_t *v18;
  unint64_t v19;

  v12 = v11;
  a10 = v12;
  sub_1B678B274(&a10);
  state = v10[31].__state_;
  if (state)
  {
    p_shared_owners = (unint64_t *)&state->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
      ((void (*)(std::__assoc_sub_state *))state->__on_zero_shared)(state);
  }
  v17 = v10[30].__state_;
  if (v17)
  {
    v18 = (unint64_t *)&v17->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
      ((void (*)(std::__assoc_sub_state *))v17->__on_zero_shared)(v17);
  }
  std::future<void>::~future(v10 + 29);
  _Unwind_Resume(a1);
}

uint64_t sub_1B67908B8(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_1B678B1B4(result);
    JUMPOUT(0x1BCC9814CLL);
  }
  return result;
}

void sub_1B67908F4(__CFDictionary *a1, const void *a2, int a3)
{
  CFNumberRef v5;
  CFNumberRef v6;
  int valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  if (v5)
  {
    v6 = v5;
    CFDictionarySetValue(a1, a2, v5);
    CFRelease(v6);
  }
}

void sub_1B6790958(std::__assoc_sub_state_vtbl **a1, std::__assoc_sub_state **a2)
{
  std::__assoc_sub_state *v3;
  void *ptr;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::exception_ptr v7;
  std::exception_ptr v8;
  std::unique_lock<std::mutex> __lk;

  v3 = *a2;
  *a2 = 0;
  __lk.__m_ = &v3->__mut_;
  __lk.__owns_ = 1;
  std::mutex::lock(&v3->__mut_);
  std::__assoc_sub_state::__sub_wait(v3, &__lk);
  ptr = v3->__exception_.__ptr_;
  v8.__ptr_ = 0;
  std::exception_ptr::~exception_ptr(&v8);
  if (ptr)
  {
    std::exception_ptr::exception_ptr(&v8, &v3->__exception_);
    v7.__ptr_ = &v8;
    std::rethrow_exception(v7);
    __break(1u);
  }
  else
  {
    *a1 = v3[1].__vftable;
    v3[1].__vftable = 0;
    if (__lk.__owns_)
      std::mutex::unlock(__lk.__m_);
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
      ((void (*)(std::__assoc_sub_state *))v3->__on_zero_shared)(v3);
  }
}

void sub_1B6790A30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10, std::mutex *a11, char a12)
{
  unint64_t *v12;
  unint64_t *v14;
  unint64_t v15;

  std::exception_ptr::~exception_ptr(&a10);
  if (a12)
    std::mutex::unlock(a11);
  if (v12)
  {
    v14 = v12 + 1;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
      (*(void (**)(unint64_t *))(*v12 + 16))(v12);
  }
  _Unwind_Resume(a1);
}

void sub_1B6790A90(void ***a1)
{
  void **v1;
  uint64_t *v2;
  uint64_t *v4;
  void *v5;

  v1 = *a1;
  v2 = (uint64_t *)**a1;
  if (v2)
  {
    v4 = (uint64_t *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
        sub_1B67908B8(--v4);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

const __CFNumber *sub_1B6790B00(const __CFDictionary *a1, const void *a2, void *a3)
{
  const __CFNumber *result;
  const __CFNumber *v5;
  CFTypeID v6;

  result = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  if (result)
  {
    v5 = result;
    v6 = CFGetTypeID(result);
    result = (const __CFNumber *)CFNumberGetTypeID();
    if ((const __CFNumber *)v6 == result)
      return (const __CFNumber *)CFNumberGetValue(v5, kCFNumberSInt32Type, a3);
  }
  return result;
}

void sub_1B6790B60(__CFDictionary *a1, float a2)
{
  CFNumberRef v3;
  CFNumberRef v4;
  float valuePtr;

  valuePtr = a2;
  v3 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  if (v3)
  {
    v4 = v3;
    CFDictionarySetValue(a1, CFSTR("HistCorr"), v3);
    CFRelease(v4);
  }
}

void sub_1B6790BBC(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  CFNumberRef v5;
  CFNumberRef v6;
  uint64_t valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  if (v5)
  {
    v6 = v5;
    CFDictionarySetValue(a1, a2, v5);
    CFRelease(v6);
  }
}

unint64_t **sub_1B6790C20(unint64_t **a1, unint64_t **a2, unint64_t **a3)
{
  unint64_t **v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      if (*v5)
      {
        v6 = *v5 + 1;
        do
          v7 = __ldxr(v6);
        while (__stxr(v7 + 1, v6));
      }
      v8 = *a3;
      if (*a3)
      {
        v9 = v8 + 1;
        do
          v10 = __ldaxr(v9);
        while (__stlxr(v10 - 1, v9));
        if (!v10)
          (*(void (**)(unint64_t *))(*v8 + 16))(v8);
      }
      v11 = *v5++;
      *a3++ = v11;
    }
    while (v5 != a2);
  }
  return a3;
}

uint64_t *sub_1B6790CB0(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *result;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  result = a4;
  while (a2 != a3)
  {
    v5 = *a2;
    *result = *a2;
    if (v5)
    {
      v6 = (unint64_t *)(v5 + 8);
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
    ++a2;
    ++result;
  }
  return result;
}

char *sub_1B6790CEC(_QWORD *a1, unint64_t a2)
{
  char *result;

  if (a2 >> 61)
    sub_1B6773BAC();
  result = (char *)operator new(8 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * a2];
  return result;
}

void sub_1B6790D2C(uint64_t a1)
{
  std::exception_ptr *v2;

  *(_QWORD *)a1 = MEMORY[0x1E0DE4FC8] + 16;
  v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_1B6790D78(uint64_t a1)
{
  std::exception_ptr *v2;

  *(_QWORD *)a1 = MEMORY[0x1E0DE4FC8] + 16;
  v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
  JUMPOUT(0x1BCC9814CLL);
}

uint64_t sub_1B6790DD8(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 8))(a1);
}

void sub_1B6790DE4(uint64_t a1)
{
  char v1;

  v1 = 0;
  sub_1B6790E58(a1, &v1);
}

void sub_1B6790E14(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception_ptr a9)
{
  std::__assoc_sub_state *v9;
  std::exception_ptr v10;

  __cxa_begin_catch(a1);
  std::current_exception();
  v10.__ptr_ = &a9;
  std::__assoc_sub_state::set_exception(v9, v10);
  std::exception_ptr::~exception_ptr(&a9);
  __cxa_end_catch();
  JUMPOUT(0x1B6790E04);
}

void sub_1B6790E3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception_ptr a9)
{
  std::exception_ptr::~exception_ptr(&a9);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1B6790E58(uint64_t a1, _BYTE *a2)
{
  std::mutex *v4;
  uint64_t v5;
  std::exception_ptr v6;

  v4 = (std::mutex *)(a1 + 24);
  std::mutex::lock((std::mutex *)(a1 + 24));
  if ((*(_BYTE *)(a1 + 136) & 1) != 0
    || (v6.__ptr_ = 0, v5 = *(_QWORD *)(a1 + 16), std::exception_ptr::~exception_ptr(&v6), v5))
  {
    sub_1B6780564(2u);
  }
  *(_BYTE *)(a1 + 140) = *a2;
  *(_DWORD *)(a1 + 136) |= 5u;
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 88));
  std::mutex::unlock(v4);
}

void sub_1B6790EE4(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B6790EF8(uint64_t a1)
{
  std::exception_ptr *v2;

  *(_QWORD *)a1 = MEMORY[0x1E0DE4FC8] + 16;
  v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_1B6790F44(uint64_t a1)
{
  std::exception_ptr *v2;

  *(_QWORD *)a1 = MEMORY[0x1E0DE4FC8] + 16;
  v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
  JUMPOUT(0x1BCC9814CLL);
}

void sub_1B6790FA4(uint64_t a1)
{
  uint64_t v2;
  std::__assoc_sub_state *v3;
  void *ptr;
  std::__assoc_sub_state_vtbl *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  int v9;
  char v10;
  BOOL v11;
  std::exception_ptr v12;
  char v13;
  CMTime v14;
  CMTime __lk;

  v2 = *(_QWORD *)(a1 + 152);
  if (!*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2184) || (v3 = *(std::__assoc_sub_state **)(v2 + 240)) == 0)
  {
LABEL_12:
    v13 = *(_BYTE *)(v2 + 46);
    sub_1B6790E58(a1, &v13);
    return;
  }
  *(_QWORD *)(v2 + 240) = 0;
  __lk.value = (CMTimeValue)&v3->__mut_;
  LOBYTE(__lk.timescale) = 1;
  std::mutex::lock(&v3->__mut_);
  std::__assoc_sub_state::__sub_wait(v3, (std::unique_lock<std::mutex> *)&__lk);
  ptr = v3->__exception_.__ptr_;
  v14.value = 0;
  std::exception_ptr::~exception_ptr((std::exception_ptr *)&v14);
  if (!ptr)
  {
    v5 = v3[1].__vftable;
    if (LOBYTE(__lk.timescale))
      std::mutex::unlock((std::mutex *)__lk.value);
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
      ((void (*)(std::__assoc_sub_state *))v3->__on_zero_shared)(v3);
    v2 = *(_QWORD *)(a1 + 152);
    *(_QWORD *)(v2 + 88) = v5;
    if (!v5)
    {
      *(_BYTE *)(v2 + 45) = 1;
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 144) + 2184);
      v9 = *(_DWORD *)(a1 + 160);
      v10 = *(_BYTE *)(a1 + 164) == 0;
      __lk = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E18];
      v14 = __lk;
      v11 = sub_1B6779994(v8, v9, 1, v10, 0, &__lk, &v14);
      v2 = *(_QWORD *)(a1 + 152);
      *(_BYTE *)(v2 + 46) = v11;
    }
    goto LABEL_12;
  }
  std::exception_ptr::exception_ptr((std::exception_ptr *)&v14, &v3->__exception_);
  v12.__ptr_ = &v14;
  std::rethrow_exception(v12);
  __break(1u);
}

void sub_1B67910F0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::exception_ptr a11, uint64_t a12, uint64_t a13, uint64_t a14, std::mutex *a15, char a16)
{
  std::__assoc_sub_state *v16;
  unint64_t *v17;
  unint64_t *v19;
  unint64_t v20;
  std::exception_ptr v21;

  std::exception_ptr::~exception_ptr(&a11);
  if (a16)
    std::mutex::unlock(a15);
  v19 = v17 + 1;
  do
    v20 = __ldaxr(v19);
  while (__stlxr(v20 - 1, v19));
  if (!v20)
    (*(void (**)(unint64_t *))(*v17 + 16))(v17);
  __cxa_begin_catch(a1);
  std::current_exception();
  v21.__ptr_ = &a9;
  std::__assoc_sub_state::set_exception(v16, v21);
  std::exception_ptr::~exception_ptr((std::exception_ptr *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x1B67910C4);
}

void sub_1B6791178(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception_ptr a9)
{
  std::exception_ptr::~exception_ptr(&a9);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1B6791194(uint64_t a1)
{
  std::exception_ptr *v2;

  *(_QWORD *)a1 = MEMORY[0x1E0DE4FC8] + 16;
  v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_1B67911E0(uint64_t a1)
{
  std::exception_ptr *v2;

  *(_QWORD *)a1 = MEMORY[0x1E0DE4FC8] + 16;
  v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
  JUMPOUT(0x1BCC9814CLL);
}

void sub_1B6791240(uint64_t a1)
{
  char v1;

  v1 = 1;
  sub_1B6790E58(a1, &v1);
}

void sub_1B6791274(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception_ptr a9)
{
  std::__assoc_sub_state *v9;
  std::exception_ptr v10;

  __cxa_begin_catch(a1);
  std::current_exception();
  v10.__ptr_ = &a9;
  std::__assoc_sub_state::set_exception(v9, v10);
  std::exception_ptr::~exception_ptr(&a9);
  __cxa_end_catch();
  JUMPOUT(0x1B6791264);
}

void sub_1B679129C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception_ptr a9)
{
  std::exception_ptr::~exception_ptr(&a9);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1B67912B8()
{
  if (!*MEMORY[0x1E0CFCCF0])
    byte_1EF138D20 = 1;
}

uint64_t VCPCompressionSessionCompleteFrames(uint64_t a1, CMTime *a2)
{
  OpaqueVTCompressionSession *v2;
  CMTime v4;

  v2 = *(OpaqueVTCompressionSession **)(a1 + 16);
  v4 = *a2;
  return VTCompressionSessionCompleteFrames(v2, &v4);
}

uint64_t VCPDecompressionSessionGetTypeID()
{
  pthread_once(&stru_1EF137CA8, (void (*)(void))sub_1B679134C);
  return qword_1EF138CA0;
}

uint64_t sub_1B679134C()
{
  uint64_t result;

  qword_1EF138D28 = 0;
  unk_1EF138D30 = "VCPDecompressionSession";
  qword_1EF138D38 = 0;
  unk_1EF138D40 = 0;
  qword_1EF138D48 = (uint64_t)sub_1B6791398;
  unk_1EF138D50 = 0u;
  unk_1EF138D60 = 0u;
  result = _CFRuntimeRegisterClass();
  qword_1EF138CA0 = result;
  return result;
}

void sub_1B6791398(uint64_t a1)
{
  if (a1)
    VCPDecompressionSessionInvalidate(a1);
}

void VCPDecompressionSessionInvalidate(uint64_t a1)
{
  OpaqueVTDecompressionSession *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  __CVPixelBufferPool *v7;
  __CVBuffer *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  const void **v12;
  __CVPixelBufferPool *v13;
  __CVPixelBufferPool *v14;
  uint64_t v15;
  void *v16;
  uint64_t *v17;
  __CVPixelBufferPool *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  uint64_t v25;
  const void *v26;
  const void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t i;
  uint64_t v31;
  uint64_t j;
  int v33;
  int v34;
  int v35;
  const char *v36;
  int v37;
  _BYTE v38[12];
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  __int16 v43;
  const char *v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(OpaqueVTDecompressionSession **)(a1 + 16);
    if (v2)
    {
      VTDecompressionSessionInvalidate(v2);
      CFRelease(*(CFTypeRef *)(a1 + 16));
      *(_QWORD *)(a1 + 16) = 0;
    }
    v3 = *(const void **)(a1 + 48);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(a1 + 48) = 0;
    }
    v4 = *(const void **)(a1 + 56);
    if (v4)
    {
      CFRelease(v4);
      *(_QWORD *)(a1 + 56) = 0;
    }
    v5 = *(const void **)(a1 + 64);
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)(a1 + 64) = 0;
    }
    v6 = *(const void **)(a1 + 72);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(a1 + 72) = 0;
    }
    v7 = *(__CVPixelBufferPool **)(a1 + 184);
    if (v7)
    {
      CVPixelBufferPoolRelease(v7);
      *(_QWORD *)(a1 + 184) = 0;
    }
    v8 = *(__CVBuffer **)(a1 + 192);
    if (v8)
    {
      CVPixelBufferRelease(v8);
      *(_QWORD *)(a1 + 192) = 0;
    }
    v9 = *(_QWORD *)(a1 + 2280);
    if (v9)
    {
      v10 = *(void **)(v9 + 224);
      if (v10)
      {
        *(_QWORD *)(v9 + 232) = v10;
        operator delete(v10);
      }
      v11 = *(void **)(v9 + 200);
      if (v11)
        operator delete(v11);
      *(_QWORD *)v38 = v9 + 176;
      sub_1B677AB54((void ***)v38);
      sub_1B677ABC4(v9 + 8);
      v12 = sub_1B6777A90((const void **)v9);
      MEMORY[0x1BCC9814C](v12, 0x10F0C40E9E3E2ADLL);
      *(_QWORD *)(a1 + 2280) = 0;
    }
    v13 = *(__CVPixelBufferPool **)(a1 + 2240);
    if (v13)
    {
      CVPixelBufferPoolRelease(v13);
      *(_QWORD *)(a1 + 2240) = 0;
    }
    v14 = *(__CVPixelBufferPool **)(a1 + 2248);
    if (v14)
    {
      CVPixelBufferPoolRelease(v14);
      *(_QWORD *)(a1 + 2248) = 0;
    }
    v15 = *(_QWORD *)(a1 + 2288);
    if (v15)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 256))(v15);
      *(_QWORD *)(a1 + 2288) = 0;
    }
    v16 = *(void **)(a1 + 2256);
    if (v16)
    {
      objc_msgSend(v16, "invalidate");
      CFRelease(*(CFTypeRef *)(a1 + 2256));
      *(_QWORD *)(a1 + 2256) = 0;
    }
    v17 = *(uint64_t **)(a1 + 2304);
    if (v17)
    {
      std::mutex::lock((std::mutex *)(v17 + 6));
      v18 = (__CVPixelBufferPool *)v17[3];
      if (v18)
      {
        CVPixelBufferPoolRelease(v18);
        v17[3] = 0;
      }
      v19 = *v17;
      if (*v17)
      {
        v20 = *(_QWORD *)(v19 - 8);
        if (v20)
        {
          v21 = v19 + 616 * v20;
          do
          {
            std::mutex::lock((std::mutex *)(v21 - 72));
            if (*(_QWORD *)(v21 - 600))
            {
              espresso_plan_destroy();
              *(_QWORD *)(v21 - 600) = 0;
            }
            std::mutex::unlock((std::mutex *)(v21 - 72));
            std::mutex::~mutex((std::mutex *)(v21 - 72));
            v22 = *(std::__shared_weak_count **)(v21 - 608);
            if (v22)
            {
              p_shared_owners = (unint64_t *)&v22->__shared_owners_;
              do
                v24 = __ldaxr(p_shared_owners);
              while (__stlxr(v24 - 1, p_shared_owners));
              if (!v24)
              {
                ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
                std::__shared_weak_count::__release_weak(v22);
              }
            }
            v21 -= 616;
          }
          while (v21 != v19);
        }
        MEMORY[0x1BCC9811C](v19 - 16, 0x10A0C803A5D1B82);
        *v17 = 0;
      }
      v25 = v17[5];
      if (v25)
      {
        MEMORY[0x1BCC9811C](v25, 0x1000C8052888210);
        v17[5] = 0;
      }
      std::mutex::unlock((std::mutex *)(v17 + 6));
      std::mutex::~mutex((std::mutex *)(v17 + 6));
      MEMORY[0x1BCC9814C](v17, 0x10A0C40F3D614E7);
      *(_QWORD *)(a1 + 2304) = 0;
    }
    v26 = *(const void **)(a1 + 96);
    if (v26)
    {
      CFRelease(v26);
      *(_QWORD *)(a1 + 96) = 0;
    }
    v27 = *(const void **)(a1 + 104);
    if (v27)
    {
      CFRelease(v27);
      *(_QWORD *)(a1 + 104) = 0;
    }
    v28 = *(_QWORD *)(a1 + 2224);
    if (v28)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v28 + 8))(v28);
      *(_QWORD *)(a1 + 2224) = 0;
    }
    v29 = *(_QWORD *)(a1 + 2352);
    if (v29)
    {
      sub_1B6772C88(v29 + 1568);
      sub_1B6772C88(v29 + 1552);
      sub_1B6772C88(v29 + 1536);
      for (i = 1520; i != 496; i -= 16)
        sub_1B6772C88(v29 + i);
      do
      {
        sub_1B6772C88(v29 + i);
        i -= 16;
      }
      while (i != 240);
      do
      {
        sub_1B6772C88(v29 + i);
        i -= 16;
      }
      while (i != -16);
      MEMORY[0x1BCC9814C](v29, 0x20C40F81735CALL);
      *(_QWORD *)(a1 + 2352) = 0;
    }
    v31 = *(_QWORD *)(a1 + 2360);
    if (v31)
    {
      sub_1B6772C88(v31 + 4624);
      sub_1B6772C88(v31 + 4608);
      for (j = 4592; j != 496; j -= 16)
        sub_1B6772C88(v31 + j);
      do
      {
        sub_1B6772C88(v31 + j);
        j -= 16;
      }
      while (j != -16);
      MEMORY[0x1BCC9814C](v31, 0x20C408F2BB087);
      *(_QWORD *)(a1 + 2360) = 0;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v34 = *(_DWORD *)(a1 + 112);
      v33 = *(_DWORD *)(a1 + 116);
      v35 = *(_DWORD *)(a1 + 24);
      v36 = "H.264";
      if (v35 > 1718908519)
      {
        if (v35 == 1752589105)
          goto LABEL_72;
        v37 = 1718908520;
      }
      else
      {
        if (v35 == 1684632424)
          goto LABEL_72;
        v37 = 1685481521;
      }
      if (v35 != v37)
      {
LABEL_73:
        *(_DWORD *)v38 = 134218754;
        *(_QWORD *)&v38[4] = a1;
        v39 = 1024;
        v40 = v34;
        v41 = 1024;
        v42 = v33;
        v43 = 2080;
        v44 = v36;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Video decompression session invalidated\n", v38, 0x22u);
        return;
      }
LABEL_72:
      v36 = "HEVC";
      goto LABEL_73;
    }
  }
}

void sub_1B679183C(_Unwind_Exception *a1, int a2)
{
  if (a2)
    sub_1B67704C8(a1);
  _Unwind_Resume(a1);
}

uint64_t VCPDecompressionSessionCreate(const void *a1, const opaqueCMFormatDescription *a2, const __CFDictionary *a3, const void *a4, _OWORD *a5, uint64_t *a6)
{
  const __CFString *v12;
  uint64_t Instance;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  const char *v20;
  int v21;
  uint64_t v22;
  const void *v23;
  __CVPixelBufferPool *v24;
  VTSessionRef *v26;
  int v27;
  int v28;
  int v29;
  const char *v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  const char *v36;
  int v37;
  NSObject *v38;
  const char *v39;
  int v40;
  int v41;
  int v42;
  const char *v43;
  int v44;
  int v45;
  int v46;
  int v47;
  const char *v48;
  int v49;
  uint32_t v50;
  int v51;
  int v52;
  int v53;
  const char *v54;
  int v55;
  int v56;
  const char *v57;
  int v58;
  void *v59;
  void *v60;
  uint8_t v61[16];
  _BYTE buf[12];
  __int16 v63;
  int v64;
  __int16 v65;
  int v66;
  __int16 v67;
  const char *v68;
  __int16 v69;
  int v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v12 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("EnableVideoChatAnalysis"), CFSTR("com.apple.VideoProcessing"));
  pthread_once(&stru_1EF137CA8, (void (*)(void))sub_1B679134C);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v16 = 4294954392;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = -12904;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VCPDec: Failed to create video decompression session, err = %d\n", buf, 8u);
    }
    goto LABEL_19;
  }
  v14 = Instance;
  bzero((void *)(Instance + 16), 0x938uLL);
  *(_OWORD *)(v14 + 28) = *a5;
  *(_OWORD *)(v14 + 48) = 0u;
  *(_OWORD *)(v14 + 64) = 0u;
  *(_OWORD *)(v14 + 2256) = 0u;
  *(_BYTE *)(v14 + 2272) = 0;
  *(_DWORD *)(v14 + 144) = 0;
  *(_QWORD *)(v14 + 136) = 1;
  *(_QWORD *)(v14 + 156) = 0x8000000000000000;
  *(_WORD *)(v14 + 164) = 0;
  *(_DWORD *)(v14 + 168) = 0;
  *(_BYTE *)(v14 + 172) = 0;
  *(_QWORD *)(v14 + 200) = -1;
  *(_BYTE *)(v14 + 208) = 64;
  if (v12 && CFStringCompare(v12, CFSTR("1"), 0) == kCFCompareEqualTo)
    *(_BYTE *)(v14 + 2272) = 1;
  sub_1B67C24BC((_QWORD *)(v14 + 2256));
  v15 = sub_1B679220C(a1, a2, a3, a4, (_DWORD *)v14);
  if ((_DWORD)v15)
  {
    v16 = v15;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v18 = *(_DWORD *)(v14 + 112);
      v17 = *(_DWORD *)(v14 + 116);
      v19 = *(_DWORD *)(v14 + 24);
      v20 = "H.264";
      if (v19 > 1718908519)
      {
        if (v19 == 1752589105)
          goto LABEL_44;
        v21 = 1718908520;
      }
      else
      {
        if (v19 == 1684632424)
          goto LABEL_44;
        v21 = 1685481521;
      }
      if (v19 != v21)
      {
LABEL_45:
        *(_DWORD *)buf = 134219010;
        *(_QWORD *)&buf[4] = v14;
        v63 = 1024;
        v64 = v18;
        v65 = 1024;
        v66 = v17;
        v67 = 2080;
        v68 = v20;
        v69 = 1024;
        v70 = v16;
        v38 = MEMORY[0x1E0C81028];
        v39 = "VCPDec %p (%dx%d, %s): Failed to create video decoder, err = %d\n";
LABEL_61:
        v50 = 40;
LABEL_62:
        _os_log_error_impl(&dword_1B676B000, v38, OS_LOG_TYPE_ERROR, v39, buf, v50);
        goto LABEL_14;
      }
LABEL_44:
      v20 = "HEVC";
      goto LABEL_45;
    }
LABEL_14:
    v23 = *(const void **)(v14 + 104);
    if (v23)
    {
      CFRelease(v23);
      *(_QWORD *)(v14 + 104) = 0;
    }
    v24 = *(__CVPixelBufferPool **)(v14 + 2248);
    if (v24)
    {
      CVPixelBufferPoolRelease(v24);
      *(_QWORD *)(v14 + 2248) = 0;
    }
    CFRelease((CFTypeRef)v14);
LABEL_19:
    v14 = 0;
    goto LABEL_20;
  }
  v22 = VTPixelTransferSessionCreate(0, (VTPixelTransferSessionRef *)(v14 + 96));
  if ((_DWORD)v22)
  {
    v16 = v22;
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_14;
    v41 = *(_DWORD *)(v14 + 112);
    v40 = *(_DWORD *)(v14 + 116);
    v42 = *(_DWORD *)(v14 + 24);
    v43 = "H.264";
    if (v42 > 1718908519)
    {
      if (v42 == 1752589105)
        goto LABEL_59;
      v44 = 1718908520;
    }
    else
    {
      if (v42 == 1684632424)
        goto LABEL_59;
      v44 = 1685481521;
    }
    if (v42 != v44)
    {
LABEL_60:
      *(_DWORD *)buf = 134219010;
      *(_QWORD *)&buf[4] = v14;
      v63 = 1024;
      v64 = v41;
      v65 = 1024;
      v66 = v40;
      v67 = 2080;
      v68 = v43;
      v69 = 1024;
      v70 = v16;
      v38 = MEMORY[0x1E0C81028];
      v39 = "VCPDec %p (%dx%d, %s): Decoder failed to create up_scaling_session, err = %d\n";
      goto LABEL_61;
    }
LABEL_59:
    v43 = "HEVC";
    goto LABEL_60;
  }
  if (*(_DWORD *)(v14 + 152) != 1111970369)
    goto LABEL_71;
  v26 = (VTSessionRef *)(v14 + 104);
  if (!*(_QWORD *)(v14 + 104))
  {
    v32 = VTPixelTransferSessionCreate(0, (VTPixelTransferSessionRef *)(v14 + 104));
    if ((_DWORD)v32)
    {
      v16 = v32;
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        goto LABEL_14;
      v34 = *(_DWORD *)(v14 + 112);
      v33 = *(_DWORD *)(v14 + 116);
      v35 = *(_DWORD *)(v14 + 24);
      v36 = "H.264";
      if (v35 > 1718908519)
      {
        if (v35 == 1752589105)
          goto LABEL_86;
        v37 = 1718908520;
      }
      else
      {
        if (v35 == 1684632424)
          goto LABEL_86;
        v37 = 1685481521;
      }
      if (v35 != v37)
      {
LABEL_87:
        *(_DWORD *)buf = 134219010;
        *(_QWORD *)&buf[4] = v14;
        v63 = 1024;
        v64 = v34;
        v65 = 1024;
        v66 = v33;
        v67 = 2080;
        v68 = v36;
        v69 = 1024;
        v70 = v16;
        v38 = MEMORY[0x1E0C81028];
        v39 = "VCPDec %p (%dx%d, %s): Decoder failed to create data_format_transfer_session, err = %d\n";
        goto LABEL_61;
      }
LABEL_86:
      v36 = "HEVC";
      goto LABEL_87;
    }
  }
  if (!*(_QWORD *)(v14 + 2248))
  {
    *(_QWORD *)buf = 0;
    v16 = sub_1B68556D0(*(_DWORD *)(v14 + 112), *(_DWORD *)(v14 + 116), (CFMutableDictionaryRef *)buf);
    if ((_DWORD)v16)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v61 = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Failed to create source pixel attributes\n", v61, 2u);
      }
    }
    else
    {
      CVPixelBufferPoolCreate(0, 0, *(CFDictionaryRef *)buf, (CVPixelBufferPoolRef *)(v14 + 2248));
      if (*(_QWORD *)(v14 + 2248))
      {
        sub_1B67705C8((const void **)buf);
        goto LABEL_26;
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v61 = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "failed to create pixelBufferPool\n", v61, 2u);
      }
      v16 = 4294954392;
    }
    sub_1B67705C8((const void **)buf);
    goto LABEL_14;
  }
LABEL_26:
  if (*(_DWORD *)(v14 + 148) == 1)
  {
    v16 = VTSessionSetProperty(*v26, (CFStringRef)*MEMORY[0x1E0CED7C0], (CFTypeRef)*MEMORY[0x1E0CA8D98]);
    if ((_DWORD)v16)
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        goto LABEL_14;
      v28 = *(_DWORD *)(v14 + 112);
      v27 = *(_DWORD *)(v14 + 116);
      v29 = *(_DWORD *)(v14 + 24);
      v30 = "H.264";
      if (v29 > 1718908519)
      {
        if (v29 == 1752589105)
          goto LABEL_91;
        v31 = 1718908520;
      }
      else
      {
        if (v29 == 1684632424)
          goto LABEL_91;
        v31 = 1685481521;
      }
      if (v29 != v31)
      {
LABEL_92:
        *(_DWORD *)buf = 134218754;
        *(_QWORD *)&buf[4] = v14;
        v63 = 1024;
        v64 = v28;
        v65 = 1024;
        v66 = v27;
        v67 = 2080;
        v68 = v30;
        v38 = MEMORY[0x1E0C81028];
        v39 = "VCPDec %p (%dx%d, %s): Decoder failed to set DestinationColorPrimaries for color transfer\n";
LABEL_103:
        v50 = 34;
        goto LABEL_62;
      }
LABEL_91:
      v30 = "HEVC";
      goto LABEL_92;
    }
    v16 = VTSessionSetProperty(*v26, (CFStringRef)*MEMORY[0x1E0CED7D8], (CFTypeRef)*MEMORY[0x1E0CA8EB0]);
    if ((_DWORD)v16)
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        goto LABEL_14;
      v46 = *(_DWORD *)(v14 + 112);
      v45 = *(_DWORD *)(v14 + 116);
      v47 = *(_DWORD *)(v14 + 24);
      v48 = "H.264";
      if (v47 > 1718908519)
      {
        if (v47 == 1752589105)
          goto LABEL_96;
        v49 = 1718908520;
      }
      else
      {
        if (v47 == 1684632424)
          goto LABEL_96;
        v49 = 1685481521;
      }
      if (v47 != v49)
      {
LABEL_97:
        *(_DWORD *)buf = 134218754;
        *(_QWORD *)&buf[4] = v14;
        v63 = 1024;
        v64 = v46;
        v65 = 1024;
        v66 = v45;
        v67 = 2080;
        v68 = v48;
        v38 = MEMORY[0x1E0C81028];
        v39 = "VCPDec %p (%dx%d, %s): Decoder failed to set DestinationTransferFunction for color transfer\n";
        goto LABEL_103;
      }
LABEL_96:
      v48 = "HEVC";
      goto LABEL_97;
    }
    v16 = VTSessionSetProperty(*v26, (CFStringRef)*MEMORY[0x1E0CED7E0], (CFTypeRef)*MEMORY[0x1E0CA8F00]);
    if ((_DWORD)v16)
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        goto LABEL_14;
      v52 = *(_DWORD *)(v14 + 112);
      v51 = *(_DWORD *)(v14 + 116);
      v53 = *(_DWORD *)(v14 + 24);
      v54 = "H.264";
      if (v53 > 1718908519)
      {
        if (v53 == 1752589105)
          goto LABEL_101;
        v55 = 1718908520;
      }
      else
      {
        if (v53 == 1684632424)
          goto LABEL_101;
        v55 = 1685481521;
      }
      if (v53 != v55)
      {
LABEL_102:
        *(_DWORD *)buf = 134218754;
        *(_QWORD *)&buf[4] = v14;
        v63 = 1024;
        v64 = v52;
        v65 = 1024;
        v66 = v51;
        v67 = 2080;
        v68 = v54;
        v38 = MEMORY[0x1E0C81028];
        v39 = "VCPDec %p (%dx%d, %s): Decoder failed to set DestinationYCbCrMatrix for color transfer\n";
        goto LABEL_103;
      }
LABEL_101:
      v54 = "HEVC";
      goto LABEL_102;
    }
  }
LABEL_71:
  v56 = *(_DWORD *)(v14 + 24);
  v57 = "H.264";
  if (v56 > 1718908519)
  {
    if (v56 != 1752589105)
    {
      v58 = 1718908520;
LABEL_76:
      if (v56 != v58)
        goto LABEL_78;
    }
  }
  else if (v56 != 1684632424)
  {
    v58 = 1685481521;
    goto LABEL_76;
  }
  v57 = "HEVC";
LABEL_78:
  snprintf((char *)(v14 + 220), 0x7D0uLL, "VCPDec %p (%dx%d, %s)", (const void *)v14, *(_DWORD *)(v14 + 112), *(_DWORD *)(v14 + 116), v57);
  v59 = operator new(0x88uLL, MEMORY[0x1E0DE4E10]);
  if (!v59)
  {
    *(_QWORD *)(v14 + 2224) = 0;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Failed to create stats monitor\n", buf, 2u);
    }
    v16 = 4294954392;
    goto LABEL_14;
  }
  v60 = v59;
  sub_1B6872CF8((uint64_t)v59, (uint64_t)sub_1B6794580, v14);
  v16 = 0;
  *(_QWORD *)(v14 + 2224) = v60;
LABEL_20:
  *a6 = v14;
  if (v12)
    CFRelease(v12);
  return v16;
}

void sub_1B67921D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  sub_1B67705C8((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1B679220C(const void *a1, CMVideoFormatDescriptionRef videoDesc, const __CFDictionary *a3, const void *a4, _DWORD *a5)
{
  CFMutableDictionaryRef MutableCopy;
  const __CFDictionary *v10;
  int *v11;
  const __CFNumber *Value;
  const __CFNumber *v13;
  CFTypeID v14;
  int32_t v15;
  int v16;
  const void *v17;
  const void *v18;
  const void *v19;
  _BOOL4 v20;
  char *v21;
  uint64_t v22;
  const void *v23;
  const __CFNumber *v24;
  const __CFNumber *v25;
  CFTypeID v26;
  const __CFNumber *v27;
  const __CFNumber *v28;
  CFTypeID v29;
  int32_t v30;
  const __CFNumber *v31;
  const __CFNumber *v32;
  CFTypeID v33;
  int32_t v34;
  const void *v35;
  const void *v36;
  const void *v37;
  _BOOL4 v38;
  int v39;
  const void *v40;
  const void *v41;
  const void *v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  _QWORD *v48;
  __int128 v49;
  unint64_t v50;
  CFNumberRef v51;
  int v52;
  int v53;
  const __CFString *v54;
  const __CFString *v55;
  const __CFNumber *v56;
  const __CFNumber *v57;
  CFTypeID v58;
  unsigned int v59;
  int v60;
  const char *v61;
  int v62;
  int v63;
  const char *v64;
  int v65;
  const __CFNumber *v66;
  const __CFNumber *v67;
  CFTypeID v68;
  int v69;
  int v70;
  const char *v71;
  int v72;
  const __CFString *v73;
  const __CFData *v74;
  const __CFData *v75;
  const __CFData *v76;
  int v77;
  const char *v78;
  int v79;
  int v80;
  const char *v81;
  __CFDictionary *v82;
  int v83;
  int v84;
  const char *v85;
  int v86;
  int v87;
  const char *v88;
  int v89;
  int v90;
  const char *v91;
  int v92;
  NSObject *v93;
  const char *v94;
  uint32_t v95;
  int v96;
  const char *v97;
  int v98;
  const __CFString *v99;
  const __CFString *v100;
  const __CFDictionary *Extension;
  int v102;
  int v103;
  const __CFData *v104;
  void *v105;
  void *v106;
  const UInt8 *BytePtr;
  size_t Length;
  int v109;
  const char *v110;
  int v111;
  const __CFData *v112;
  void *v113;
  void *v114;
  const UInt8 *v115;
  CFIndex v116;
  uint64_t v117;
  uint64_t v118;
  int v119;
  int v120;
  int v121;
  const char *v122;
  int v123;
  int v124;
  const char *v125;
  int v126;
  int v127;
  const char *v128;
  int v129;
  const char *v130;
  const char *v131;
  const char *v132;
  const char *v133;
  unsigned int v134;
  unsigned int v135;
  uint64_t v136;
  int v137;
  const char *v138;
  int v139;
  uint64_t v140;
  int v141;
  const char *v142;
  int v143;
  CFTypeID v144;
  const void *v145;
  const __CFDictionary *v146;
  const __CFDictionary *v147;
  CFTypeID v148;
  int v149;
  const char *v150;
  int v151;
  const char *v152;
  int v153;
  const char *v154;
  int v155;
  int v156;
  const char *v157;
  int v158;
  uint64_t v159;
  int v160;
  int v161;
  char *v162;
  const __CFString *v163;
  CFMutableStringRef v164;
  int v166;
  const char *v167;
  int v168;
  const char *v169;
  NSObject *v170;
  const char *v171;
  uint32_t v172;
  int32_t v173;
  int32_t v174;
  int v175;
  const char *v176;
  int v177;
  int v178;
  int v179;
  CFTypeRef v180;
  __CFDictionary *theDict;
  CMVideoDimensions Dimensions;
  const void *valuePtr;
  uint64_t v185;
  uint64_t (*v186)(uint64_t, int *, uint64_t, uint64_t, CVPixelBufferRef, __int128 *, __int128 *);
  _DWORD *v187;
  _BYTE buf[12];
  __int16 v189;
  int32_t width;
  __int16 v191;
  int32_t height;
  __int16 v193;
  const char *v194;
  __int16 v195;
  _BYTE v196[34];
  uint64_t v197;
  CFRange v198;

  v197 = *MEMORY[0x1E0C80C00];
  v185 = 0;
  Dimensions = CMVideoFormatDescriptionGetDimensions(videoDesc);
  v186 = sub_1B6794F74;
  v187 = a5;
  if (a3)
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a3);
  else
    MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v10 = MutableCopy;
  theDict = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v10)
  {
    v180 = a4;
    if (CFDictionaryContainsKey(v10, CFSTR("NumberOfTiles")))
    {
      v11 = a5 + 34;
      Value = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("NumberOfTiles"));
      if (Value)
      {
        v13 = Value;
        v14 = CFGetTypeID(Value);
        if (v14 == CFNumberGetTypeID())
          CFNumberGetValue(v13, kCFNumberSInt32Type, a5 + 34);
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        v15 = a5[34];
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = a5;
        v189 = 1024;
        width = v15;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p: Decoder got number of tiles video specification: %d\n", buf, 0x12u);
      }
      v16 = *v11;
      if (*v11 <= 1)
        v16 = 1;
      *v11 = v16;
    }
    v17 = (const void *)*MEMORY[0x1E0CED338];
    if (CFDictionaryContainsKey(v10, (const void *)*MEMORY[0x1E0CED338]))
    {
      v18 = CFDictionaryGetValue(v10, v17);
      v19 = v18;
      v20 = v18 && CFGetTypeID(v18) && CFBooleanGetTypeID() && CFEqual(v19, (CFTypeRef)*MEMORY[0x1E0C9AE50]) != 0;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = a5;
        v189 = 1024;
        width = v20;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p: Decoder got kVTDecompressionPropertyKey_MachThreadPriorityOfConsistentThreadCallingDecodeFrame : %d\n", buf, 0x12u);
      }
    }
    v23 = (const void *)*MEMORY[0x1E0CED330];
    if (CFDictionaryContainsKey(v10, (const void *)*MEMORY[0x1E0CED330]))
    {
      LODWORD(valuePtr) = 0;
      v24 = (const __CFNumber *)CFDictionaryGetValue(v10, v23);
      v25 = v24;
      if (v24)
      {
        v26 = CFGetTypeID(v24);
        if (v26 == CFNumberGetTypeID())
          CFNumberGetValue(v25, kCFNumberSInt32Type, &valuePtr);
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = a5;
        v189 = 1024;
        width = (int)valuePtr;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p: Decoder got kVTDecompressionPropertyKey_MachThreadPriorityForThreadEmittingFrames : %d\n", buf, 0x12u);
      }
    }
    if (CFDictionaryContainsKey(v10, CFSTR("FrameBufferWidth")))
    {
      v27 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("FrameBufferWidth"));
      v28 = v27;
      if (v27)
      {
        v29 = CFGetTypeID(v27);
        if (v29 == CFNumberGetTypeID())
          CFNumberGetValue(v28, kCFNumberSInt32Type, a5 + 35);
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        v30 = a5[35];
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = a5;
        v189 = 1024;
        width = v30;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p: Decoder got buffer width video specification: %d\n", buf, 0x12u);
      }
    }
    if (CFDictionaryContainsKey(v10, CFSTR("FrameBufferHeight")))
    {
      v31 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("FrameBufferHeight"));
      v32 = v31;
      if (v31)
      {
        v33 = CFGetTypeID(v31);
        if (v33 == CFNumberGetTypeID())
          CFNumberGetValue(v32, kCFNumberSInt32Type, a5 + 36);
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        v34 = a5[36];
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = a5;
        v189 = 1024;
        width = v34;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p: Decoder got buffer height video specification: %d\n", buf, 0x12u);
      }
    }
    v35 = (const void *)*MEMORY[0x1E0CEDCA8];
    if (CFDictionaryContainsKey(v10, (const void *)*MEMORY[0x1E0CEDCA8]))
    {
      v36 = CFDictionaryGetValue(v10, v35);
      v37 = v36;
      v38 = !v36 || !CFGetTypeID(v36) || !CFBooleanGetTypeID() || CFEqual(v37, (CFTypeRef)*MEMORY[0x1E0C9AE50]) != 0;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = a5;
        v189 = 1024;
        width = v38;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p: Decoder got enable hardware decoder: %d\n", buf, 0x12u);
      }
      v39 = v38 - 1;
    }
    else
    {
      v39 = 0;
    }
    v40 = (const void *)*MEMORY[0x1E0CED458];
    if (CFDictionaryContainsKey(v10, (const void *)*MEMORY[0x1E0CED458]))
    {
      v41 = CFDictionaryGetValue(v10, v40);
      if (v41)
      {
        v42 = (const void *)*MEMORY[0x1E0C9AE50];
        if (CFEqual(v41, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
          CFDictionaryAddValue(theDict, v40, v42);
      }
    }
    v43 = a5[34];
    if (v43 >= 2)
    {
      a5[35] = Dimensions.width;
      a5[36] = v43 * Dimensions.height;
      v44 = operator new();
      v45 = v44;
      v46 = (int)a5[34];
      *(_QWORD *)v44 = 0;
      *(_OWORD *)(v44 + 176) = 0u;
      *(_QWORD *)(v44 + 152) = 0;
      *(_QWORD *)(v44 + 160) = 0;
      *(_QWORD *)(v44 + 144) = 0;
      *(_BYTE *)(v44 + 168) = 0;
      *(_OWORD *)(v44 + 192) = 0u;
      *(_OWORD *)(v44 + 208) = 0u;
      *(_OWORD *)(v44 + 224) = 0u;
      *(_OWORD *)(v44 + 233) = 0u;
      if ((_DWORD)v46)
      {
        if ((v46 & 0x80000000) != 0)
          sub_1B6773BAC();
        v47 = (char *)operator new(24 * v46);
        bzero(v47, 24 * ((24 * v46 - 24) / 0x18) + 24);
        *(_QWORD *)(v45 + 176) = v47;
        *(_QWORD *)(v45 + 184) = &v47[24 * ((24 * v46 - 24) / 0x18) + 24];
        *(_QWORD *)(v45 + 192) = &v47[24 * (int)v46];
        if (((v46 + 63) & 0xFFFFFFFFFFFFFFC0) != 0)
        {
          if (((v46 + 63) & 0x8000000000000000) != 0)
            sub_1B6773BAC();
          v48 = operator new(8 * (((((v46 + 63) & 0xFFFFFFFFFFFFFFC0) - 1) >> 6) + 1));
          *((_QWORD *)&v49 + 1) = ((((v46 + 63) & 0xFFFFFFFFFFFFFFC0) - 1) >> 6) + 1;
          *v48 = 0;
        }
        else
        {
          v48 = 0;
          *((_QWORD *)&v49 + 1) = 0;
        }
        *(_QWORD *)&v49 = v46;
        *(_QWORD *)(v45 + 200) = v48;
        *(_OWORD *)(v45 + 208) = v49;
        v50 = v46 >> 6;
        if (v46 >= 0x40)
          bzero(v48, 8 * v50);
        if ((v46 & 0x3F) != 0)
          v48[v50] &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v46 & 0x3F));
      }
      else
      {
        *(_QWORD *)(v44 + 208) = v46;
      }
      *(_BYTE *)(v45 + 248) = 1;
      *(_QWORD *)buf = objc_opt_new();
      sub_1B6777A50((const void **)v45, (const void **)buf);
      sub_1B6777A90((const void **)buf);
      *((_QWORD *)a5 + 285) = v45;
    }
    a5[6] = CMFormatDescriptionGetMediaSubType(videoDesc);
    *(_DWORD *)buf = 1;
    v51 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
    if (v51)
    {
      CFDictionaryAddValue(v10, (const void *)*MEMORY[0x1E0CEDCD0], v51);
      CFRelease(v51);
    }
    v52 = a5[6];
    if (v52 > 1718908519)
    {
      if (v52 != 1752589105)
      {
        v53 = 1718908520;
LABEL_76:
        if (v52 != v53)
          goto LABEL_83;
      }
    }
    else if (v52 != 1684632424)
    {
      v53 = 1685481521;
      goto LABEL_76;
    }
    v54 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("FaceTimeDecoder"), CFSTR("com.apple.VideoConference"));
    v55 = v54;
    if (v54)
    {
      if (CFStringCompare(v54, CFSTR("hw"), 0))
      {
        if (CFStringCompare(v55, CFSTR("sw"), 0) == kCFCompareEqualTo)
          v39 = -1;
      }
      else
      {
        v39 = 1;
      }
      CFRelease(v55);
    }
LABEL_83:
    if (!CFDictionaryContainsKey(v10, CFSTR("DecPixelFormat")))
      goto LABEL_102;
    v56 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("DecPixelFormat"));
    v57 = v56;
    if (v56)
    {
      v58 = CFGetTypeID(v56);
      if (v58 == CFNumberGetTypeID())
        CFNumberGetValue(v57, kCFNumberSInt32Type, a5 + 38);
    }
    v59 = a5[38];
    if (!v59)
      goto LABEL_102;
    if (v59 == 1111970369)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        v60 = a5[6];
        v61 = "H.264";
        if (v60 > 1718908519)
        {
          if (v60 == 1752589105)
            goto LABEL_100;
          v62 = 1718908520;
        }
        else
        {
          if (v60 == 1684632424)
            goto LABEL_100;
          v62 = 1685481521;
        }
        if (v60 != v62)
        {
LABEL_101:
          *(_DWORD *)buf = 134219778;
          *(_QWORD *)&buf[4] = a5;
          v189 = 1024;
          width = Dimensions.width;
          v191 = 1024;
          height = Dimensions.height;
          v193 = 2080;
          v194 = v61;
          v195 = 1024;
          *(_DWORD *)v196 = 66;
          *(_WORD *)&v196[4] = 1024;
          *(_DWORD *)&v196[6] = 71;
          *(_WORD *)&v196[10] = 1024;
          *(_DWORD *)&v196[12] = 82;
          *(_WORD *)&v196[16] = 1024;
          *(_DWORD *)&v196[18] = 65;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder got output pixel format: %c%c%c%c\n", buf, 0x3Au);
          goto LABEL_102;
        }
LABEL_100:
        v61 = "HEVC";
        goto LABEL_101;
      }
LABEL_102:
      if (!CFDictionaryContainsKey(v10, CFSTR("DecColorSpace")))
        goto LABEL_119;
      v66 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("DecColorSpace"));
      v67 = v66;
      if (v66)
      {
        v68 = CFGetTypeID(v66);
        if (v68 == CFNumberGetTypeID())
          CFNumberGetValue(v67, kCFNumberSInt32Type, a5 + 37);
      }
      v69 = a5[37];
      if (!v69)
        goto LABEL_119;
      if (v69 == 1)
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          v70 = a5[6];
          v71 = "H.264";
          if (v70 > 1718908519)
          {
            if (v70 == 1752589105)
              goto LABEL_117;
            v72 = 1718908520;
          }
          else
          {
            if (v70 == 1684632424)
              goto LABEL_117;
            v72 = 1685481521;
          }
          if (v70 != v72)
          {
LABEL_118:
            *(_DWORD *)buf = 134218754;
            *(_QWORD *)&buf[4] = a5;
            v189 = 1024;
            width = Dimensions.width;
            v191 = 1024;
            height = Dimensions.height;
            v193 = 2080;
            v194 = v71;
            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder got color space format P3_D65\n", buf, 0x22u);
            goto LABEL_119;
          }
LABEL_117:
          v71 = "HEVC";
          goto LABEL_118;
        }
LABEL_119:
        v73 = (const __CFString *)CFDictionaryGetValue(a3, CFSTR("NegotiationDetails"));
        v74 = (const __CFData *)CFDictionaryGetValue(a3, CFSTR("NegotiationDetailsBitField"));
        v75 = (const __CFData *)CFDictionaryGetValue(a3, CFSTR("NegotiatedFLB"));
        v76 = v75;
        if (!v73 && !v74 && !v75)
        {
          *((_BYTE *)a5 + 80) = 0;
          if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          {
LABEL_191:
            v21 = 0;
            goto LABEL_192;
          }
          v77 = a5[6];
          v78 = "H.264";
          if (v77 > 1718908519)
          {
            if (v77 == 1752589105)
              goto LABEL_134;
            v79 = 1718908520;
          }
          else
          {
            if (v77 == 1684632424)
              goto LABEL_134;
            v79 = 1685481521;
          }
          if (v77 != v79)
          {
LABEL_135:
            *(_DWORD *)buf = 134218754;
            *(_QWORD *)&buf[4] = a5;
            v189 = 1024;
            width = Dimensions.width;
            v191 = 1024;
            height = Dimensions.height;
            v193 = 2080;
            v194 = v78;
            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder FLS doesn't exist\n", buf, 0x22u);
            goto LABEL_191;
          }
LABEL_134:
          v78 = "HEVC";
          goto LABEL_135;
        }
        v21 = (char *)malloc_type_calloc(0x3E9uLL, 1uLL, 0x100004077774924uLL);
        if (v21)
        {
          if (v74)
          {
            sub_1B685BEC8(v74, "FLBA;", v21, 1000);
            goto LABEL_178;
          }
          if (v76)
          {
            sub_1B685BEC8(v76, "FLBN;", v21, 1000);
            goto LABEL_178;
          }
          if (CFStringGetCString(v73, v21, 1001, 0)
            || (*((_BYTE *)a5 + 80) = 0, !os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT)))
          {
LABEL_178:
            if (strcmp(v21, "FLS;") && strcmp(v21, "FLBA;") && strcmp(v21, "FLBN;"))
            {
LABEL_192:
              v99 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("SerializationMode"), CFSTR("com.apple.VideoProcessing"));
              v100 = v99;
              a5[558] = 1;
              if (v99)
              {
                a5[558] = CFStringGetIntValue(v99);
                CFRelease(v100);
              }
              *((CMVideoDimensions *)a5 + 14) = Dimensions;
              *((_QWORD *)a5 + 15) = 0;
              *((CMVideoDimensions *)a5 + 16) = Dimensions;
              if (!videoDesc)
                goto LABEL_227;
              Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(videoDesc, (CFStringRef)*MEMORY[0x1E0CA2240]);
              if (!Extension)
                goto LABEL_227;
              v102 = a5[6];
              if (v102 > 1718908519)
              {
                if (v102 == 1752589105)
                  goto LABEL_202;
                v103 = 1718908520;
              }
              else
              {
                if (v102 == 1684632424)
                  goto LABEL_202;
                v103 = 1685481521;
              }
              if (v102 == v103)
              {
LABEL_202:
                v104 = (const __CFData *)CFDictionaryGetValue(Extension, CFSTR("hvcC"));
                if (*((_QWORD *)a5 + 294))
                {
LABEL_205:
                  if (v104)
                  {
                    BytePtr = CFDataGetBytePtr(v104);
                    Length = CFDataGetLength(v104);
                    if (sub_1B68921D4(BytePtr, Length, a5 + 28, *((_BYTE **)a5 + 294)))
                    {
                      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                      {
                        v109 = a5[6];
                        v110 = "H.264";
                        if (v109 > 1718908519)
                        {
                          if (v109 == 1752589105)
                            goto LABEL_225;
                          v111 = 1718908520;
                        }
                        else
                        {
                          if (v109 == 1684632424)
                            goto LABEL_225;
                          v111 = 1685481521;
                        }
                        if (v109 != v111)
                        {
LABEL_226:
                          *(_DWORD *)buf = 134218754;
                          *(_QWORD *)&buf[4] = a5;
                          v189 = 1024;
                          width = Dimensions.width;
                          v191 = 1024;
                          height = Dimensions.height;
                          v193 = 2080;
                          v194 = v110;
                          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder could not parse config info!\n", buf, 0x22u);
                          goto LABEL_227;
                        }
LABEL_225:
                        v110 = "HEVC";
                        goto LABEL_226;
                      }
                    }
                  }
LABEL_227:
                  if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                  {
LABEL_236:
                    if (v39 != -1 || !os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                    {
LABEL_246:
                      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                        goto LABEL_264;
                      v127 = a5[6];
                      v128 = "H.264";
                      if (v127 > 1718908519)
                      {
                        if (v127 == 1752589105)
                          goto LABEL_253;
                        v129 = 1718908520;
                      }
                      else
                      {
                        if (v127 == 1684632424)
                          goto LABEL_253;
                        v129 = 1685481521;
                      }
                      if (v127 != v129)
                      {
LABEL_254:
                        v130 = "HW decoder only";
                        *(_DWORD *)buf = 134219522;
                        *(_QWORD *)&buf[4] = a5;
                        v189 = 1024;
                        width = Dimensions.width;
                        if (v21)
                          v131 = v21;
                        else
                          v131 = "";
                        v191 = 1024;
                        v132 = "; forced: HW";
                        height = Dimensions.height;
                        if (v39 != 1)
                          v132 = "";
                        if (v39 == -1)
                          v130 = "no decoder";
                        v193 = 2080;
                        v194 = v128;
                        v133 = "; forced: SW";
                        v195 = 2080;
                        if (v39 != -1)
                          v133 = v132;
                        *(_QWORD *)v196 = v130;
                        *(_WORD *)&v196[8] = 2082;
                        *(_QWORD *)&v196[10] = v131;
                        *(_WORD *)&v196[18] = 2082;
                        *(_QWORD *)&v196[20] = v133;
                        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Creating %s; FLS = \"%{public}s\"%{public}s\n",
                          buf,
                          0x40u);
LABEL_264:
                        if (v39 != -1)
                        {
                          v134 = VTDecompressionSessionCreateWithOptions();
                          v135 = v134;
                          v136 = v185;
                          if (v185 && !v134 || !os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                            goto LABEL_281;
                          v137 = a5[6];
                          v138 = "H.264";
                          if (v137 > 1718908519)
                          {
                            if (v137 == 1752589105)
                              goto LABEL_279;
                            v139 = 1718908520;
                          }
                          else
                          {
                            if (v137 == 1684632424)
                              goto LABEL_279;
                            v139 = 1685481521;
                          }
                          if (v137 != v139)
                          {
LABEL_280:
                            *(_DWORD *)buf = 134218754;
                            *(_QWORD *)&buf[4] = a5;
                            v189 = 1024;
                            width = Dimensions.width;
                            v191 = 1024;
                            height = Dimensions.height;
                            v193 = 2080;
                            v194 = v138;
                            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Creating HW decoder was unsuccesful\n", buf, 0x22u);
                            v136 = v185;
LABEL_281:
                            *((_BYTE *)a5 + 2368) = 0;
                            if (v136 && !v135)
                            {
LABEL_283:
                              valuePtr = 0;
                              VTDecompressionSessionCopySupportedPropertyDictionary();
                              if (valuePtr)
                              {
                                v144 = CFGetTypeID(valuePtr);
                                if (v144 == CFDictionaryGetTypeID())
                                {
                                  v145 = (const void *)*MEMORY[0x1E0CED2D8];
                                  if (CFDictionaryContainsKey((CFDictionaryRef)valuePtr, (const void *)*MEMORY[0x1E0CED2D8]))
                                  {
                                    v146 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)valuePtr, v145);
                                    v147 = v146;
                                    if (v146)
                                    {
                                      v148 = CFGetTypeID(v146);
                                      if (v148 == CFDictionaryGetTypeID())
                                      {
                                        if (CFDictionaryContainsKey(v147, (const void *)*MEMORY[0x1E0CED9E8]))
                                        {
                                          *((_BYTE *)a5 + 2368) = 1;
                                          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                                          {
                                            *(_DWORD *)buf = 134217984;
                                            *(_QWORD *)&buf[4] = a5;
                                            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p kVTPropertySupportedInPerFrameOptionsKey set\n", buf, 0xCu);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                                goto LABEL_305;
                              v149 = a5[6];
                              v150 = "H.264";
                              if (v149 > 1718908519)
                              {
                                if (v149 == 1752589105)
                                  goto LABEL_301;
                                v151 = 1718908520;
                              }
                              else
                              {
                                if (v149 == 1684632424)
                                  goto LABEL_301;
                                v151 = 1685481521;
                              }
                              if (v149 != v151)
                              {
LABEL_302:
                                v152 = "";
                                *(_DWORD *)buf = 134219778;
                                if (v21)
                                  v152 = v21;
                                *(_QWORD *)&buf[4] = a5;
                                v189 = 1024;
                                width = Dimensions.width;
                                v191 = 1024;
                                height = Dimensions.height;
                                v193 = 2080;
                                v194 = v150;
                                v195 = 2080;
                                *(_QWORD *)v196 = &unk_1B691FF74;
                                *(_WORD *)&v196[8] = 1024;
                                *(_DWORD *)&v196[10] = 1;
                                *(_WORD *)&v196[14] = 2080;
                                *(_QWORD *)&v196[16] = "iOS";
                                *(_WORD *)&v196[24] = 2082;
                                *(_QWORD *)&v196[26] = v152;
                                _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Created %s video decoder, usage = %d, on %s; FLS = \"%{public}s\"\n",
                                  buf,
                                  0x46u);
LABEL_305:
                                sub_1B6770568(&valuePtr);
                                *((_QWORD *)a5 + 2) = v185;
                                *((_WORD *)a5 + 87) = 0;
                                if ((int)a5[34] > 1)
                                {
                                  valuePtr = 0;
                                  v22 = VTDecompressionSessionCopyProperty();
                                  if ((_DWORD)v22)
                                  {
                                    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                                    {
                                      v153 = a5[6];
                                      v154 = "H.264";
                                      if (v153 > 1718908519)
                                      {
                                        if (v153 == 1752589105)
                                          goto LABEL_374;
                                        v155 = 1718908520;
                                      }
                                      else
                                      {
                                        if (v153 == 1684632424)
                                          goto LABEL_374;
                                        v155 = 1685481521;
                                      }
                                      if (v153 != v155)
                                      {
LABEL_375:
                                        *(_DWORD *)buf = 134218754;
                                        *(_QWORD *)&buf[4] = a5;
                                        v189 = 1024;
                                        width = Dimensions.width;
                                        v191 = 1024;
                                        height = Dimensions.height;
                                        v193 = 2080;
                                        v194 = v154;
                                        v170 = MEMORY[0x1E0C81028];
                                        v171 = "VCPDec %p (%dx%d, %s): Failed to copy decoder pixel buffer pool\n";
LABEL_384:
                                        v172 = 34;
LABEL_385:
                                        _os_log_error_impl(&dword_1B676B000, v170, OS_LOG_TYPE_ERROR, v171, buf, v172);
                                        goto LABEL_345;
                                      }
LABEL_374:
                                      v154 = "HEVC";
                                      goto LABEL_375;
                                    }
LABEL_345:
                                    CFRelease(v10);
                                    goto LABEL_346;
                                  }
                                  v22 = CVPixelBufferPoolSetMaxBufferAge();
                                  if (valuePtr)
                                    CFRelease(valuePtr);
                                  if ((_DWORD)v22)
                                  {
                                    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                                      goto LABEL_345;
                                    v156 = a5[6];
                                    v157 = "H.264";
                                    if (v156 > 1718908519)
                                    {
                                      if (v156 == 1752589105)
                                        goto LABEL_382;
                                      v158 = 1718908520;
                                    }
                                    else
                                    {
                                      if (v156 == 1684632424)
                                        goto LABEL_382;
                                      v158 = 1685481521;
                                    }
                                    if (v156 != v158)
                                    {
LABEL_383:
                                      *(_DWORD *)buf = 134218754;
                                      *(_QWORD *)&buf[4] = a5;
                                      v189 = 1024;
                                      width = Dimensions.width;
                                      v191 = 1024;
                                      height = Dimensions.height;
                                      v193 = 2080;
                                      v194 = v157;
                                      v170 = MEMORY[0x1E0C81028];
                                      v171 = "VCPDec %p (%dx%d, %s): Failed to set max buffer age of decoder pixel buffer pool\n";
                                      goto LABEL_384;
                                    }
LABEL_382:
                                    v157 = "HEVC";
                                    goto LABEL_383;
                                  }
                                }
                                if (a1)
                                {
                                  CFRetain(a1);
                                  *((_QWORD *)a5 + 6) = a1;
                                }
                                if (videoDesc)
                                {
                                  CFRetain(videoDesc);
                                  *((_QWORD *)a5 + 7) = videoDesc;
                                }
                                if (a3)
                                {
                                  CFRetain(a3);
                                  *((_QWORD *)a5 + 8) = a3;
                                }
                                if (v180)
                                {
                                  CFRetain(v180);
                                  *((_QWORD *)a5 + 9) = v180;
                                }
                                v159 = 0;
                                *((_BYTE *)a5 + 94) = 1;
                                v160 = a5[6];
                                if (v160 > 1718908519)
                                {
                                  if (v160 != 1718908520)
                                  {
                                    v161 = 1752589105;
LABEL_331:
                                    if (v160 != v161)
                                      v159 = 1;
                                  }
                                }
                                else if (v160 != 1684632424)
                                {
                                  v161 = 1685481521;
                                  goto LABEL_331;
                                }
                                v162 = sub_1B685B8B4(v21, 0, 0xFFFFFFFFLL, v159);
                                *((_QWORD *)a5 + 286) = v162;
                                *((_BYTE *)a5 + 80) = v162[33];
                                if (v21)
                                {
                                  v163 = (const __CFString *)(*(uint64_t (**)(char *))(*(_QWORD *)v162 + 264))(v162);
                                  v164 = CFStringCreateMutableCopy(0, 0, v163);
                                  v198.length = CFStringGetLength(v164);
                                  v198.location = 0;
                                  CFStringFindAndReplace(v164, CFSTR("VRAE:"), CFSTR("RVRA1:"), v198, 0);
                                  VCPDecompressionSessionSetProperty((uint64_t)a5, CFSTR("NegotiationDetails"), v164);
                                  CFRelease(v164);
                                  CFRelease(v163);
                                }
                                if ((a5[574] & 1) != 0)
                                  sub_1B6797138((uint64_t)a5);
                                v22 = 0;
                                goto LABEL_345;
                              }
LABEL_301:
                              v150 = "HEVC";
                              goto LABEL_302;
                            }
                            if (v135)
                              v22 = v135;
                            else
                              v22 = 4294954392;
LABEL_344:
                            if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                              goto LABEL_345;
                            v166 = a5[6];
                            v167 = "H.264";
                            if (v166 > 1718908519)
                            {
                              if (v166 == 1752589105)
                                goto LABEL_358;
                              v168 = 1718908520;
                            }
                            else
                            {
                              if (v166 == 1684632424)
                                goto LABEL_358;
                              v168 = 1685481521;
                            }
                            if (v166 != v168)
                            {
LABEL_359:
                              v169 = "";
                              *(_DWORD *)buf = 134219778;
                              if (v21)
                                v169 = v21;
                              *(_QWORD *)&buf[4] = a5;
                              v189 = 1024;
                              width = Dimensions.width;
                              v191 = 1024;
                              height = Dimensions.height;
                              v193 = 2080;
                              v194 = v167;
                              v195 = 1024;
                              *(_DWORD *)v196 = 1;
                              *(_WORD *)&v196[4] = 2080;
                              *(_QWORD *)&v196[6] = "iOS";
                              *(_WORD *)&v196[14] = 1024;
                              *(_DWORD *)&v196[16] = v135;
                              *(_WORD *)&v196[20] = 2082;
                              *(_QWORD *)&v196[22] = v169;
                              v170 = MEMORY[0x1E0C81028];
                              v171 = "VCPDec %p (%dx%d, %s): Failed to create video decoder - check dec creation matrix f"
                                     "or root cause, usage = %d, on %s, err = %d; FLS = \"%{public}s\"\n";
                              v172 = 66;
                              goto LABEL_385;
                            }
LABEL_358:
                            v167 = "HEVC";
                            goto LABEL_359;
                          }
LABEL_279:
                          v138 = "HEVC";
                          goto LABEL_280;
                        }
                        v140 = v185;
                        *((_BYTE *)a5 + 2368) = 0;
                        if (v140)
                          goto LABEL_283;
                        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                        {
LABEL_343:
                          v135 = 0;
                          v22 = 4294954392;
                          goto LABEL_344;
                        }
                        v141 = a5[6];
                        v142 = "H.264";
                        if (v141 > 1718908519)
                        {
                          if (v141 == 1752589105)
                            goto LABEL_341;
                          v143 = 1718908520;
                        }
                        else
                        {
                          if (v141 == 1684632424)
                            goto LABEL_341;
                          v143 = 1685481521;
                        }
                        if (v141 != v143)
                        {
LABEL_342:
                          *(_DWORD *)buf = 134218754;
                          *(_QWORD *)&buf[4] = a5;
                          v189 = 1024;
                          width = Dimensions.width;
                          v191 = 1024;
                          height = Dimensions.height;
                          v193 = 2080;
                          v194 = v142;
                          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): No forced SW decoder allowed\n", buf, 0x22u);
                          goto LABEL_343;
                        }
LABEL_341:
                        v142 = "HEVC";
                        goto LABEL_342;
                      }
LABEL_253:
                      v128 = "HEVC";
                      goto LABEL_254;
                    }
                    v124 = a5[6];
                    v125 = "H.264";
                    if (v124 > 1718908519)
                    {
                      if (v124 == 1752589105)
                        goto LABEL_244;
                      v126 = 1718908520;
                    }
                    else
                    {
                      if (v124 == 1684632424)
                        goto LABEL_244;
                      v126 = 1685481521;
                    }
                    if (v124 != v126)
                    {
LABEL_245:
                      *(_DWORD *)buf = 134218754;
                      *(_QWORD *)&buf[4] = a5;
                      v189 = 1024;
                      width = Dimensions.width;
                      v191 = 1024;
                      height = Dimensions.height;
                      v193 = 2080;
                      v194 = v125;
                      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Disabling HW dec because of forced SW request\n", buf, 0x22u);
                      goto LABEL_246;
                    }
LABEL_244:
                    v125 = "HEVC";
                    goto LABEL_245;
                  }
                  v121 = a5[6];
                  v122 = "H.264";
                  if (v121 > 1718908519)
                  {
                    if (v121 == 1752589105)
                      goto LABEL_234;
                    v123 = 1718908520;
                  }
                  else
                  {
                    if (v121 == 1684632424)
                      goto LABEL_234;
                    v123 = 1685481521;
                  }
                  if (v121 != v123)
                  {
LABEL_235:
                    *(_DWORD *)buf = 134218754;
                    *(_QWORD *)&buf[4] = a5;
                    v189 = 1024;
                    width = Dimensions.width;
                    v191 = 1024;
                    height = Dimensions.height;
                    v193 = 2080;
                    v194 = v122;
                    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Detected embedded system capable of HW AVD decoding\n", buf, 0x22u);
                    goto LABEL_236;
                  }
LABEL_234:
                  v122 = "HEVC";
                  goto LABEL_235;
                }
                v105 = operator new(0x630uLL, MEMORY[0x1E0DE4E10]);
                if (v105)
                {
                  v106 = v105;
                  bzero(v105, 0x630uLL);
                  *((_QWORD *)a5 + 294) = v106;
                  goto LABEL_205;
                }
                *((_QWORD *)a5 + 294) = 0;
                if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                {
LABEL_221:
                  v22 = 4294967188;
                  goto LABEL_345;
                }
                v174 = a5[28];
                v173 = a5[29];
                v178 = a5[6];
                v176 = "H.264";
                if (v178 > 1718908519)
                {
                  if (v178 == 1752589105)
                    goto LABEL_389;
                  v179 = 1718908520;
                }
                else
                {
                  if (v178 == 1684632424)
                    goto LABEL_389;
                  v179 = 1685481521;
                }
                if (v178 != v179)
                {
LABEL_390:
                  *(_DWORD *)buf = 134219010;
                  *(_QWORD *)&buf[4] = a5;
                  v189 = 1024;
                  width = v174;
                  v191 = 1024;
                  height = v173;
                  v193 = 2080;
                  v194 = v176;
                  v195 = 1024;
                  v22 = 4294967188;
                  *(_DWORD *)v196 = -108;
                  v170 = MEMORY[0x1E0C81028];
                  v171 = "VCPDec %p (%dx%d, %s): Decoder failed to create the parameter_sets, err = %d\n";
                  v172 = 40;
                  goto LABEL_385;
                }
LABEL_389:
                v176 = "HEVC";
                goto LABEL_390;
              }
              v112 = (const __CFData *)CFDictionaryGetValue(Extension, CFSTR("avcC"));
              if (*((_QWORD *)a5 + 295))
              {
LABEL_214:
                if (!v112)
                  goto LABEL_227;
                v115 = CFDataGetBytePtr(v112);
                v116 = CFDataGetLength(v112);
                if (!sub_1B6892768((uint64_t)v115, v116, (uint64_t)(a5 + 28), *((_QWORD *)a5 + 295), v117, v118)|| !os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                {
                  goto LABEL_227;
                }
                v119 = a5[6];
                v110 = "H.264";
                if (v119 > 1718908519)
                {
                  if (v119 == 1752589105)
                    goto LABEL_369;
                  v120 = 1718908520;
                }
                else
                {
                  if (v119 == 1684632424)
                    goto LABEL_369;
                  v120 = 1685481521;
                }
                if (v119 != v120)
                  goto LABEL_226;
LABEL_369:
                v110 = "HEVC";
                goto LABEL_226;
              }
              v113 = operator new(0x1220uLL, MEMORY[0x1E0DE4E10]);
              if (v113)
              {
                v114 = v113;
                bzero(v113, 0x1220uLL);
                *((_QWORD *)a5 + 295) = v114;
                goto LABEL_214;
              }
              *((_QWORD *)a5 + 295) = 0;
              if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                goto LABEL_221;
              v174 = a5[28];
              v173 = a5[29];
              v175 = a5[6];
              v176 = "H.264";
              if (v175 > 1718908519)
              {
                if (v175 == 1752589105)
                  goto LABEL_394;
                v177 = 1718908520;
              }
              else
              {
                if (v175 == 1684632424)
                  goto LABEL_394;
                v177 = 1685481521;
              }
              if (v175 != v177)
                goto LABEL_390;
LABEL_394:
              v176 = "HEVC";
              goto LABEL_390;
            }
            if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
              goto LABEL_190;
            v96 = a5[6];
            v97 = "H.264";
            if (v96 > 1718908519)
            {
              if (v96 == 1752589105)
                goto LABEL_188;
              v98 = 1718908520;
            }
            else
            {
              if (v96 == 1684632424)
                goto LABEL_188;
              v98 = 1685481521;
            }
            if (v96 != v98)
            {
LABEL_189:
              *(_DWORD *)buf = 134219010;
              *(_QWORD *)&buf[4] = a5;
              v189 = 1024;
              width = Dimensions.width;
              v191 = 1024;
              height = Dimensions.height;
              v193 = 2080;
              v194 = v97;
              v195 = 2082;
              *(_QWORD *)v196 = v21;
              _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Changing empty decoder FLS = \"%{public}s\" to FLS = \"\"\n", buf, 0x2Cu);
LABEL_190:
              *((_BYTE *)a5 + 80) = 0;
              free(v21);
              goto LABEL_191;
            }
LABEL_188:
            v97 = "HEVC";
            goto LABEL_189;
          }
          v84 = a5[6];
          v85 = "H.264";
          if (v84 > 1718908519)
          {
            if (v84 == 1752589105)
              goto LABEL_176;
            v86 = 1718908520;
          }
          else
          {
            if (v84 == 1684632424)
              goto LABEL_176;
            v86 = 1685481521;
          }
          if (v84 != v86)
          {
LABEL_177:
            *(_DWORD *)buf = 134218754;
            *(_QWORD *)&buf[4] = a5;
            v189 = 1024;
            width = Dimensions.width;
            v191 = 1024;
            height = Dimensions.height;
            v193 = 2080;
            v194 = v85;
            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder could not get FLS!\n", buf, 0x22u);
            goto LABEL_178;
          }
LABEL_176:
          v85 = "HEVC";
          goto LABEL_177;
        }
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          v21 = 0;
          v22 = 4294954392;
          goto LABEL_345;
        }
        v90 = a5[6];
        v91 = "H.264";
        if (v90 > 1718908519)
        {
          if (v90 == 1752589105)
            goto LABEL_171;
          v92 = 1718908520;
        }
        else
        {
          if (v90 == 1684632424)
            goto LABEL_171;
          v92 = 1685481521;
        }
        if (v90 != v92)
        {
LABEL_172:
          *(_DWORD *)buf = 134219010;
          *(_QWORD *)&buf[4] = a5;
          v189 = 1024;
          width = Dimensions.width;
          v191 = 1024;
          height = Dimensions.height;
          v193 = 2080;
          v194 = v91;
          v195 = 1024;
          v22 = 4294954392;
          *(_DWORD *)v196 = -12904;
          _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VCPDec %p (%dx%d, %s): Decoder failed to create an FLS, err = %d", buf, 0x28u);
          v21 = 0;
          goto LABEL_345;
        }
LABEL_171:
        v91 = "HEVC";
        goto LABEL_172;
      }
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
LABEL_113:
        v21 = 0;
        v22 = 4294954394;
        goto LABEL_345;
      }
      v87 = a5[6];
      v88 = "H.264";
      if (v87 > 1718908519)
      {
        if (v87 == 1752589105)
          goto LABEL_165;
        v89 = 1718908520;
      }
      else
      {
        if (v87 == 1684632424)
          goto LABEL_165;
        v89 = 1685481521;
      }
      if (v87 != v89)
      {
LABEL_166:
        *(_DWORD *)buf = 134219010;
        *(_QWORD *)&buf[4] = a5;
        v189 = 1024;
        width = Dimensions.width;
        v191 = 1024;
        height = Dimensions.height;
        v193 = 2080;
        v194 = v88;
        v195 = 1024;
        *(_DWORD *)v196 = v69;
        v93 = MEMORY[0x1E0C81028];
        v94 = "VCPDec %p (%dx%d, %s): Decoder failed to support color space, which is %d\n";
        v95 = 40;
        goto LABEL_167;
      }
LABEL_165:
      v88 = "HEVC";
      goto LABEL_166;
    }
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_113;
    v63 = a5[6];
    v64 = "H.264";
    if (v63 > 1718908519)
    {
      if (v63 == 1752589105)
        goto LABEL_160;
      v65 = 1718908520;
    }
    else
    {
      if (v63 == 1684632424)
        goto LABEL_160;
      v65 = 1685481521;
    }
    if (v63 != v65)
    {
LABEL_161:
      *(_DWORD *)buf = 134219778;
      *(_QWORD *)&buf[4] = a5;
      v189 = 1024;
      width = Dimensions.width;
      v191 = 1024;
      height = Dimensions.height;
      v193 = 2080;
      v194 = v64;
      v195 = 1024;
      *(_DWORD *)v196 = HIBYTE(v59);
      *(_WORD *)&v196[4] = 1024;
      *(_DWORD *)&v196[6] = BYTE2(v59);
      *(_WORD *)&v196[10] = 1024;
      *(_DWORD *)&v196[12] = BYTE1(v59);
      *(_WORD *)&v196[16] = 1024;
      *(_DWORD *)&v196[18] = v59;
      v93 = MEMORY[0x1E0C81028];
      v94 = "VCPDec %p (%dx%d, %s): Decoder failed to support pixel format, which is %c%c%c%c\n";
      v95 = 58;
LABEL_167:
      _os_log_error_impl(&dword_1B676B000, v93, OS_LOG_TYPE_ERROR, v94, buf, v95);
      goto LABEL_113;
    }
LABEL_160:
    v64 = "HEVC";
    goto LABEL_161;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v80 = a5[6];
    v81 = "H.264";
    if (v80 > 1718908519)
    {
      v82 = theDict;
      if (v80 == 1752589105)
        goto LABEL_149;
      v83 = 1718908520;
    }
    else
    {
      v82 = theDict;
      if (v80 == 1684632424)
        goto LABEL_149;
      v83 = 1685481521;
    }
    if (v80 != v83)
    {
LABEL_150:
      *(_DWORD *)buf = 134219010;
      *(_QWORD *)&buf[4] = a5;
      v189 = 1024;
      width = Dimensions.width;
      v191 = 1024;
      height = Dimensions.height;
      v193 = 2080;
      v194 = v81;
      v195 = 1024;
      v22 = 4294954392;
      *(_DWORD *)v196 = -12904;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VCPDec %p (%dx%d, %s): Failed to create decoder specification copy, err = %d\n", buf, 0x28u);
      v21 = 0;
      goto LABEL_347;
    }
LABEL_149:
    v81 = "HEVC";
    goto LABEL_150;
  }
  v21 = 0;
  v22 = 4294954392;
LABEL_346:
  v82 = theDict;
LABEL_347:
  if (v82)
    CFRelease(v82);
  if (v21)
    free(v21);
  return v22;
}

void sub_1B67944FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  sub_1B6770568((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1B6794580(uint64_t a1, double a2)
{
  uint64_t v4;
  _QWORD *v5;
  double *v6;
  _QWORD *v7;
  double v8;
  double v9;
  double *v10;
  _QWORD *v11;
  unint64_t v12;
  BOOL v13;
  _QWORD *v14;
  double *v15;
  _QWORD *v16;
  unint64_t v17;
  BOOL v18;
  _QWORD *v19;
  double v20;
  double *v21;
  _QWORD *v22;
  unint64_t v23;
  BOOL v24;
  _QWORD *v25;
  double v26;
  double v27;
  double *v28;
  _QWORD *v29;
  unint64_t v30;
  BOOL v31;
  _QWORD *v32;
  _BOOL4 v33;
  double v34;
  double v35;
  double *v36;
  _QWORD *v37;
  unint64_t v38;
  BOOL v39;
  _QWORD *v40;
  double v41;
  double v42;
  double *v43;
  _QWORD *v44;
  unint64_t v45;
  BOOL v46;
  _QWORD *v47;
  double v48;
  NSObject *v49;
  const char *v50;
  uint8_t *v51;
  uint32_t v52;
  double *v53;
  _QWORD *v54;
  unint64_t v55;
  BOOL v56;
  _QWORD *v57;
  double v58;
  double v59;
  double *v60;
  _QWORD *v61;
  unint64_t v62;
  BOOL v63;
  _QWORD *v64;
  double v65;
  double *v66;
  _QWORD *v67;
  unint64_t v68;
  BOOL v69;
  _QWORD *v70;
  uint64_t v71;
  double *v72;
  _QWORD *v73;
  unint64_t v74;
  BOOL v75;
  _QWORD *v76;
  uint64_t v77;
  double *v78;
  _QWORD *v79;
  unint64_t v80;
  BOOL v81;
  _QWORD *v82;
  uint64_t v83;
  double *v84;
  _QWORD *v85;
  unint64_t v86;
  BOOL v87;
  _QWORD *v88;
  double v89;
  double *v90;
  _QWORD *v91;
  unint64_t v92;
  BOOL v93;
  _QWORD *v94;
  uint64_t v95;
  double *v96;
  _QWORD *v97;
  unint64_t v98;
  BOOL v99;
  _QWORD *v100;
  uint64_t v101;
  uint64_t v102;
  double *v103;
  unint64_t v104;
  BOOL v105;
  _QWORD *v106;
  int v107;
  uint64_t i;
  double v109;
  double v110;
  uint64_t j;
  double v112;
  double v113;
  char *v114;
  _QWORD *v115;
  double v116;
  double *v117;
  _QWORD *v118;
  unint64_t v119;
  BOOL v120;
  _QWORD *v121;
  double v122;
  char *v123;
  double *v124;
  unint64_t v125;
  BOOL v126;
  _QWORD *v127;
  double v128;
  double v129;
  double v130;
  uint8_t buf[4];
  uint64_t v132;
  __int16 v133;
  double v134;
  __int16 v135;
  double v136;
  __int16 v137;
  double v138;
  __int16 v139;
  double v140;
  __int16 v141;
  double v142;
  __int16 v143;
  double v144;
  __int16 v145;
  double v146;
  __int16 v147;
  double v148;
  __int16 v149;
  char *v150;
  _BYTE v151[8];
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  _BYTE v155[8];
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  char __str[2008];
  uint64_t v160;

  v160 = *MEMORY[0x1E0C80C00];
  if (a2 > 0.0)
  {
    if (!a1)
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        return;
      *(_WORD *)__str = 0;
      v49 = MEMORY[0x1E0C81028];
      v50 = "Empty callback refcon in VCPDecStatsMonitorCallback()\n";
      v51 = (uint8_t *)__str;
      v52 = 2;
      goto LABEL_213;
    }
    v4 = *(_QWORD *)(a1 + 2224);
    v7 = *(_QWORD **)(v4 + 32);
    v6 = (double *)(v4 + 32);
    v5 = v7;
    v8 = 0.0;
    v9 = 0.0;
    if (!v7)
      goto LABEL_72;
    v10 = v6;
    v11 = v5;
    do
    {
      v12 = v11[4];
      v13 = v12 >= (unint64_t)"input_frames";
      if (v12 >= (unint64_t)"input_frames")
        v14 = v11;
      else
        v14 = v11 + 1;
      if (v13)
        v10 = (double *)v11;
      v11 = (_QWORD *)*v14;
    }
    while (*v14);
    v9 = 0.0;
    if (v10 != v6 && *((_QWORD *)v10 + 4) <= (unint64_t)"input_frames")
      v9 = v10[5];
    if (v5)
    {
      v15 = v6;
      v16 = v5;
      do
      {
        v17 = v16[4];
        v18 = v17 >= (unint64_t)"decoded_frames";
        if (v17 >= (unint64_t)"decoded_frames")
          v19 = v16;
        else
          v19 = v16 + 1;
        if (v18)
          v15 = (double *)v16;
        v16 = (_QWORD *)*v19;
      }
      while (*v19);
      v20 = 0.0;
      if (v15 != v6 && *((_QWORD *)v15 + 4) <= (unint64_t)"decoded_frames")
        v20 = v15[5];
      v21 = v6;
      v22 = v5;
      do
      {
        v23 = v22[4];
        v24 = v23 >= (unint64_t)"transmit_frames";
        if (v23 >= (unint64_t)"transmit_frames")
          v25 = v22;
        else
          v25 = v22 + 1;
        if (v24)
          v21 = (double *)v22;
        v22 = (_QWORD *)*v25;
      }
      while (*v25);
      v26 = 0.0;
      v27 = 0.0;
      if (v21 != v6 && *((_QWORD *)v21 + 4) <= (unint64_t)"transmit_frames")
        v27 = v21[5];
      v28 = v6;
      v29 = v5;
      do
      {
        v30 = v29[4];
        v31 = v30 >= (unint64_t)"decoding_time";
        if (v30 >= (unint64_t)"decoding_time")
          v32 = v29;
        else
          v32 = v29 + 1;
        if (v31)
          v28 = (double *)v29;
        v29 = (_QWORD *)*v32;
      }
      while (*v32);
      if (v28 != v6 && *((_QWORD *)v28 + 4) <= (unint64_t)"decoding_time")
        v26 = v28[5];
      v33 = v20 > 0.0;
      v34 = 0.0;
      v35 = 0.0;
      v8 = 0.0;
      if (v20 > 0.0)
      {
        v36 = v6;
        v37 = v5;
        do
        {
          v38 = v37[4];
          v39 = v38 >= (unint64_t)"vra_width";
          if (v38 >= (unint64_t)"vra_width")
            v40 = v37;
          else
            v40 = v37 + 1;
          if (v39)
            v36 = (double *)v37;
          v37 = (_QWORD *)*v40;
        }
        while (*v40);
        v41 = 0.0;
        v42 = 0.0;
        if (v36 != v6 && *((_QWORD *)v36 + 4) <= (unint64_t)"vra_width")
          v42 = v36[5];
        v35 = v42 / v20;
        v43 = v6;
        v44 = v5;
        do
        {
          v45 = v44[4];
          v46 = v45 >= (unint64_t)"vra_height";
          if (v45 >= (unint64_t)"vra_height")
            v47 = v44;
          else
            v47 = v44 + 1;
          if (v46)
            v43 = (double *)v44;
          v44 = (_QWORD *)*v47;
        }
        while (*v47);
        if (v43 != v6 && *((_QWORD *)v43 + 4) <= (unint64_t)"vra_height")
          v41 = v43[5];
        v34 = v41 / v20;
        v8 = v26 / v20 * 1000.0;
      }
      v129 = v20 / a2;
      v130 = v9 / a2;
      v48 = v27 / a2;
      v53 = v6;
      v54 = v5;
      do
      {
        v55 = v54[4];
        v56 = v55 >= (unint64_t)"sei";
        if (v55 >= (unint64_t)"sei")
          v57 = v54;
        else
          v57 = v54 + 1;
        if (v56)
          v53 = (double *)v54;
        v54 = (_QWORD *)*v57;
      }
      while (*v57);
      v58 = 0.0;
      if (v53 != v6 && *((_QWORD *)v53 + 4) <= (unint64_t)"sei")
        v58 = v53[5];
      if (v20 > 0.0)
      {
        v59 = v58 * 8.0 / a2;
        v60 = v6;
        v61 = v5;
        do
        {
          v62 = v61[4];
          v63 = v62 >= (unint64_t)"slice_qp0";
          if (v62 >= (unint64_t)"slice_qp0")
            v64 = v61;
          else
            v64 = v61 + 1;
          if (v63)
            v60 = (double *)v61;
          v61 = (_QWORD *)*v64;
        }
        while (*v64);
        v65 = 0.0;
        if (v60 != v6 && *((_QWORD *)v60 + 4) <= (unint64_t)"slice_qp0")
          v65 = v60[5];
        v66 = v6;
        v67 = v5;
        do
        {
          v68 = v67[4];
          v69 = v68 >= (unint64_t)"slice_qp1";
          if (v68 >= (unint64_t)"slice_qp1")
            v70 = v67;
          else
            v70 = v67 + 1;
          if (v69)
            v66 = (double *)v67;
          v67 = (_QWORD *)*v70;
        }
        while (*v70);
        v71 = 0;
        if (v66 != v6 && *((_QWORD *)v66 + 4) <= (unint64_t)"slice_qp1")
          v71 = *((_QWORD *)v66 + 5);
        v156 = v71;
        v72 = v6;
        v73 = v5;
        do
        {
          v74 = v73[4];
          v75 = v74 >= (unint64_t)"slice_qp2";
          if (v74 >= (unint64_t)"slice_qp2")
            v76 = v73;
          else
            v76 = v73 + 1;
          if (v75)
            v72 = (double *)v73;
          v73 = (_QWORD *)*v76;
        }
        while (*v76);
        v77 = 0;
        if (v72 != v6 && *((_QWORD *)v72 + 4) <= (unint64_t)"slice_qp2")
          v77 = *((_QWORD *)v72 + 5);
        v157 = v77;
        v78 = v6;
        v79 = v5;
        do
        {
          v80 = v79[4];
          v81 = v80 >= (unint64_t)"slice_qp3";
          if (v80 >= (unint64_t)"slice_qp3")
            v82 = v79;
          else
            v82 = v79 + 1;
          if (v81)
            v78 = (double *)v79;
          v79 = (_QWORD *)*v82;
        }
        while (*v82);
        v83 = 0;
        if (v78 != v6 && *((_QWORD *)v78 + 4) <= (unint64_t)"slice_qp3")
          v83 = *((_QWORD *)v78 + 5);
        v158 = v83;
        v84 = v6;
        v85 = v5;
        do
        {
          v86 = v85[4];
          v87 = v86 >= (unint64_t)"slice_size0";
          if (v86 >= (unint64_t)"slice_size0")
            v88 = v85;
          else
            v88 = v85 + 1;
          if (v87)
            v84 = (double *)v85;
          v85 = (_QWORD *)*v88;
        }
        while (*v88);
        v89 = 0.0;
        if (v84 != v6 && *((_QWORD *)v84 + 4) <= (unint64_t)"slice_size0")
          v89 = v84[5];
        v90 = v6;
        v91 = v5;
        do
        {
          v92 = v91[4];
          v93 = v92 >= (unint64_t)"slice_size1";
          if (v92 >= (unint64_t)"slice_size1")
            v94 = v91;
          else
            v94 = v91 + 1;
          if (v93)
            v90 = (double *)v91;
          v91 = (_QWORD *)*v94;
        }
        while (*v94);
        v95 = 0;
        if (v90 != v6 && *((_QWORD *)v90 + 4) <= (unint64_t)"slice_size1")
          v95 = *((_QWORD *)v90 + 5);
        v152 = v95;
        v96 = v6;
        v97 = v5;
        do
        {
          v98 = v97[4];
          v99 = v98 >= (unint64_t)"slice_size2";
          if (v98 >= (unint64_t)"slice_size2")
            v100 = v97;
          else
            v100 = v97 + 1;
          if (v99)
            v96 = (double *)v97;
          v97 = (_QWORD *)*v100;
        }
        while (*v100);
        v101 = 0;
        v102 = 0;
        if (v96 != v6 && *((_QWORD *)v96 + 4) <= (unint64_t)"slice_size2")
          v102 = *((_QWORD *)v96 + 5);
        v153 = v102;
        v103 = v6;
        do
        {
          v104 = v5[4];
          v105 = v104 >= (unint64_t)"slice_size3";
          if (v104 >= (unint64_t)"slice_size3")
            v106 = v5;
          else
            v106 = v5 + 1;
          if (v105)
            v103 = (double *)v5;
          v5 = (_QWORD *)*v106;
        }
        while (*v106);
        if (v103 != v6 && *((_QWORD *)v103 + 4) <= (unint64_t)"slice_size3")
          v101 = *((_QWORD *)v103 + 5);
        v154 = v101;
        if (v65 <= 0.0)
          v107 = 0;
        else
          v107 = snprintf(__str, 0x7D0uLL, ", slice_qp = %.2f", v65 / v20);
        for (i = 8; i != 32; i += 8)
        {
          v109 = *(double *)&v155[i];
          if (v109 > 0.0)
            v107 += snprintf(&__str[v107], 2000 - v107, "/%.2f", v109 / v20);
        }
        v110 = 0.0;
        if (v89 > 0.0)
        {
          v107 += snprintf(&__str[v107], 2000 - v107, ", slice_bps = %.0f", v89 * 8.0 / a2);
          v110 = v89 * 8.0 / a2 + 0.0;
        }
        for (j = 8; j != 32; j += 8)
        {
          v112 = *(double *)&v151[j];
          if (v112 > 0.0)
          {
            v113 = v112 * 8.0 / a2;
            v107 += snprintf(&__str[v107], 2000 - v107, "/%.0f", v113);
            v110 = v110 + v113;
          }
        }
        if (v59 > 0.0)
        {
          v107 += snprintf(&__str[v107], 2000 - v107, ", SEI_bps = %.0f", v59);
          v110 = v59 + v110;
        }
        snprintf(&__str[v107], 2000 - v107, ", total_bps = %.0f", v110);
      }
    }
    else
    {
LABEL_72:
      v33 = 0;
      v48 = 0.0 / a2;
      v129 = 0.0 / a2;
      v130 = v9 / a2;
      v35 = 0.0;
      v34 = 0.0;
    }
    if ((*(_BYTE *)(a1 + 2296) & 1) == 0)
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 136448002;
      v132 = a1 + 220;
      v114 = __str;
      v133 = 2048;
      if (!v33)
        v114 = "";
      v134 = v130;
      v135 = 2048;
      v136 = v129;
      v137 = 2048;
      v138 = v48;
      v139 = 2048;
      v140 = v8;
      v141 = 2048;
      v142 = v35;
      v143 = 2048;
      v144 = v34;
      v145 = 2080;
      v146 = *(double *)&v114;
      v49 = MEMORY[0x1E0C81028];
      v50 = "[VCPDecStatsMonitor] %{public}s: Input_fps=%.2f, Dec_fps=%.2f, Tx_fps=%.2f, Dec_time=%.2f ms, VRA=%.0fx%.0f%s\n";
      v51 = buf;
      v52 = 82;
      goto LABEL_213;
    }
    v115 = *(_QWORD **)v6;
    v116 = 0.0;
    if (!*(_QWORD *)v6)
      goto LABEL_208;
    v117 = v6;
    v118 = *(_QWORD **)v6;
    do
    {
      v119 = v118[4];
      v120 = v119 >= (unint64_t)"ml_enhanced_frames";
      if (v119 >= (unint64_t)"ml_enhanced_frames")
        v121 = v118;
      else
        v121 = v118 + 1;
      if (v120)
        v117 = (double *)v118;
      v118 = (_QWORD *)*v121;
    }
    while (*v121);
    if (v117 != v6 && *((_QWORD *)v117 + 4) <= (unint64_t)"ml_enhanced_frames")
    {
      v122 = v117[5];
      if (v122 > 0.0)
      {
        v124 = v6;
        do
        {
          v125 = v115[4];
          v126 = v125 >= (unint64_t)"ml_enhance_time";
          if (v125 >= (unint64_t)"ml_enhance_time")
            v127 = v115;
          else
            v127 = v115 + 1;
          if (v126)
            v124 = (double *)v115;
          v115 = (_QWORD *)*v127;
        }
        while (*v127);
        v128 = 0.0;
        if (v124 != v6 && *((_QWORD *)v124 + 4) <= (unint64_t)"ml_enhance_time")
          v128 = v124[5];
        v116 = v128 / v122 * 1000.0;
      }
    }
    else
    {
LABEL_208:
      v122 = 0.0;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136448514;
      v132 = a1 + 220;
      v133 = 2048;
      v134 = v130;
      v135 = 2048;
      v136 = v129;
      v137 = 2048;
      v138 = v48;
      v139 = 2048;
      v140 = v122 / a2;
      v141 = 2048;
      v142 = v8;
      v143 = 2048;
      v144 = v116;
      v123 = "";
      v145 = 2048;
      v146 = v35;
      if (v33)
        v123 = __str;
      v147 = 2048;
      v148 = v34;
      v149 = 2080;
      v150 = v123;
      v49 = MEMORY[0x1E0C81028];
      v50 = "[VCPDecStatsMonitor] %{public}s: Input_fps=%.2f, Dec_fps=%.2f, Tx_fps=%.2f, ML_fps=%.2f, Dec_time=%.2f ms, M"
            "L_time=%.2f ms, VRA=%.0fx%.0f%s\n";
      v51 = buf;
      v52 = 102;
LABEL_213:
      _os_log_impl(&dword_1B676B000, v49, OS_LOG_TYPE_DEFAULT, v50, v51, v52);
    }
  }
}

uint64_t sub_1B6794F74(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, CVPixelBufferRef pixelBuffer, __int128 *a6, __int128 *a7)
{
  __IOSurface *IOSurface;
  __n128 v15;
  uint64_t v16;
  double v17;
  uint64_t v18;
  unint64_t v19;
  CVPixelBufferRef v20;
  __IOSurface *v21;
  const __CFNumber *v22;
  int v23;
  __CVBuffer *v24;
  size_t Width;
  size_t Height;
  size_t v27;
  size_t v28;
  size_t v29;
  int v30;
  const char *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  const __CFString *v36;
  const __CFString *v37;
  _BOOL4 v38;
  __CVBuffer *v39;
  int v40;
  int v41;
  int v42;
  const char *v43;
  int v44;
  int v45;
  int v46;
  void *BaseAddressOfPlane;
  void *v48;
  int BytesPerRowOfPlane;
  int v50;
  int v51;
  int v52;
  int v53;
  const char *v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  const char *v61;
  int v62;
  int v63;
  int v64;
  int v65;
  const char *v66;
  int v67;
  int v68;
  int *v69;
  const __CFAllocator *v70;
  __CFDictionary *Mutable;
  CFNumberRef v72;
  CFNumberRef v73;
  CFNumberRef v74;
  CFNumberRef v75;
  const __CFAllocator *v76;
  CFMutableDictionaryRef v77;
  __CFDictionary *v78;
  uint64_t v79;
  CFNumberRef v80;
  CFNumberRef v81;
  CFNumberRef v82;
  CFNumberRef v83;
  int *v84;
  CFNumberRef v85;
  CFNumberRef v86;
  CFNumberRef v87;
  __CVBuffer *v88;
  int v89;
  uint64_t v90;
  float v91;
  float v92;
  __CVBuffer *v93;
  unsigned int v94;
  unsigned int v95;
  int32x2_t v96;
  uint64_t v97;
  float32x2_t v98;
  int32x2_t v99;
  uint64_t v100;
  int v101;
  CVPixelBufferPoolRef *v102;
  int v103;
  __CVPixelBufferPool *v104;
  const __CFDictionary *PixelBufferAttributes;
  const __CFDictionary *v106;
  const void *v107;
  const void *v108;
  int v109;
  int v110;
  int v111;
  int v112;
  __CVBuffer *v113;
  const __CFDictionary *v114;
  const void *Value;
  const void *v116;
  const void *v117;
  const __CFString *v118;
  const __CFString *v119;
  CFNumberRef v120;
  CFNumberRef v121;
  __CVBuffer *v122;
  __CVBuffer *v123;
  void (*v124)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __int128 *, __int128 *);
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  __int128 *v128;
  __int128 *v129;
  uint64_t v130;
  uint64_t v131;
  __CVBuffer *v132;
  uint64_t v133;
  int v135;
  int v136;
  int v137;
  const char *v138;
  int v139;
  int v140;
  signed int PixelFormatType;
  const CFDictionaryKeyCallBacks *v142;
  const CFDictionaryValueCallBacks *v143;
  __CFDictionary *v144;
  CFMutableDictionaryRef v145;
  CFNumberRef v146;
  CFNumberRef v147;
  CFNumberRef v148;
  CFNumberRef v149;
  CFNumberRef v150;
  CFNumberRef v151;
  CFNumberRef v152;
  CFNumberRef v153;
  CFNumberRef v154;
  CFNumberRef v155;
  CFNumberRef v156;
  CFNumberRef v157;
  CVBufferRef *v158;
  int v159;
  int v160;
  int v161;
  int v162;
  int v163;
  const char *v164;
  int v165;
  int v166;
  int v167;
  int v168;
  const char *v169;
  int v170;
  int v171;
  int v172;
  int v173;
  const char *v174;
  int v175;
  const char *v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  unint64_t v181;
  __CVBuffer *v182;
  int v183;
  int v184;
  uint64_t v185;
  int v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  int v190;
  int v191;
  CVPixelBufferRef *v192;
  uint64_t v193;
  int v194;
  int v195;
  int v196;
  int v197;
  const char *v198;
  int v199;
  int v200;
  int v201;
  int v202;
  int v203;
  int v204;
  int v205;
  int v206;
  const char *v207;
  int v208;
  int v209;
  int v210;
  int v211;
  const char *v212;
  int v213;
  int v214;
  int v215;
  OSType v216;
  NSObject *v217;
  const char *v218;
  uint32_t v219;
  BOOL v220;
  int v221;
  uint64_t v222;
  unint64_t v223;
  int v224;
  uint64_t v225;
  uint64_t v226;
  int v228;
  const char *v229;
  int v230;
  int64_t v231;
  int v232;
  int v233;
  int v234;
  int v235;
  int v236;
  int v237;
  const char *v238;
  int v239;
  NSObject *v240;
  const char *v241;
  os_log_type_t v242;
  uint32_t v243;
  CVPixelBufferPoolRef *poolOut;
  int v245;
  unsigned int v246;
  __int128 *v247;
  __int128 *v248;
  __int128 v249;
  uint64_t v250;
  __int128 v251;
  uint64_t v252;
  __int128 v253;
  uint64_t v254;
  __int128 v255;
  uint64_t v256;
  size_t extraRowsOnBottom;
  size_t extraRowsOnTop;
  size_t extraColumnsOnRight;
  size_t extraColumnsOnLeft;
  int valuePtr;
  __CVBuffer *v262;
  uint8_t buf[4];
  uint64_t v264;
  __int16 v265;
  _BYTE v266[10];
  _BYTE v267[10];
  __int16 v268;
  _BYTE v269[10];
  size_t v270;
  uint64_t v271;

  v271 = *MEMORY[0x1E0C80C00];
  v262 = 0;
  valuePtr = 0;
  IOSurface = CVPixelBufferGetIOSurface(pixelBuffer);
  if (IOSurface)
    IOSurfaceGetID(IOSurface);
  v15.n128_f64[0] = sub_1B67ED98C((uint64_t)(a2 + 6));
  v16 = *(_QWORD *)(a1 + 2224);
  if (v16)
  {
    v17 = *((double *)a2 + 3);
    sub_1B6872E44(v16, (uint64_t *)"decoded_frames", 1.0);
    sub_1B6872E44(*(_QWORD *)(a1 + 2224), (uint64_t *)"decoding_time", v17);
  }
  if ((_DWORD)a3 || !pixelBuffer)
  {
    v33 = 0;
    v34 = *(_DWORD *)(a1 + 24);
    if (v34 > 1718908519)
    {
      if (v34 == 1752589105)
        goto LABEL_33;
      v35 = 1718908520;
    }
    else
    {
      if (v34 == 1684632424)
        goto LABEL_33;
      v35 = 1685481521;
    }
    if (v34 != v35)
      goto LABEL_147;
LABEL_33:
    if (*(_DWORD *)(a1 + 168) == 2)
      goto LABEL_34;
    v36 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("TempSVCER"), CFSTR("com.apple.VideoProcessing"));
    if (v36)
    {
      v37 = v36;
      v38 = CFStringGetIntValue(v36) != 0;
      CFRelease(v37);
    }
    else
    {
      v38 = 1;
    }
    if ((_DWORD)a3 != -17694 || pixelBuffer)
    {
      if ((_DWORD)a3)
      {
        v33 = 0;
LABEL_145:
        v46 = 2;
        goto LABEL_146;
      }
LABEL_34:
      v33 = 0;
      goto LABEL_147;
    }
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
LABEL_53:
      if (!v38 || *((unsigned __int8 *)a2 + 84) < 2u || (v45 = *(_DWORD *)(a1 + 204), a2[5] > v45) && v45 > 0)
      {
        a3 = 4294949602;
LABEL_58:
        v33 = 0;
        v46 = 1;
LABEL_146:
        *(_DWORD *)(a1 + 168) = v46;
        goto LABEL_147;
      }
      a3 = 0;
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        goto LABEL_58;
      v52 = *(_DWORD *)(a1 + 112);
      v51 = *(_DWORD *)(a1 + 116);
      v53 = *(_DWORD *)(a1 + 24);
      v54 = "H.264";
      if (v53 > 1718908519)
      {
        if (v53 == 1752589105)
          goto LABEL_349;
        v55 = 1718908520;
      }
      else
      {
        if (v53 == 1684632424)
          goto LABEL_349;
        v55 = 1685481521;
      }
      if (v53 != v55)
      {
LABEL_350:
        *(_DWORD *)buf = 134218754;
        v264 = a1;
        v265 = 1024;
        *(_DWORD *)v266 = v52;
        *(_WORD *)&v266[4] = 1024;
        *(_DWORD *)&v266[6] = v51;
        *(_WORD *)v267 = 2080;
        *(_QWORD *)&v267[2] = v54;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): VCP error resilience updated kVTVideoDecoderReferenceMissingErr to noErr\n", buf, 0x22u);
        a3 = 0;
        goto LABEL_58;
      }
LABEL_349:
      v54 = "HEVC";
      goto LABEL_350;
    }
    v41 = *(_DWORD *)(a1 + 112);
    v40 = *(_DWORD *)(a1 + 116);
    v42 = *(_DWORD *)(a1 + 24);
    v43 = "H.264";
    if (v42 > 1718908519)
    {
      if (v42 == 1752589105)
        goto LABEL_51;
      v44 = 1718908520;
    }
    else
    {
      if (v42 == 1684632424)
        goto LABEL_51;
      v44 = 1685481521;
    }
    if (v42 != v44)
    {
LABEL_52:
      *(_DWORD *)buf = 134218754;
      v264 = a1;
      v265 = 1024;
      *(_DWORD *)v266 = v41;
      *(_WORD *)&v266[4] = 1024;
      *(_DWORD *)&v266[6] = v40;
      *(_WORD *)v267 = 2080;
      *(_QWORD *)&v267[2] = v43;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): VCP decoder got kVTVideoDecoderReferenceMissingErr error\n", buf, 0x22u);
      goto LABEL_53;
    }
LABEL_51:
    v43 = "HEVC";
    goto LABEL_52;
  }
  v18 = *(_QWORD *)(a1 + 2224);
  if (v18)
    sub_1B6872E44(v18, (uint64_t *)"transmit_frames", 1.0);
  if (*(_BYTE *)(a1 + 2272))
  {
    v19 = *(_QWORD *)(a1 + 2264);
    if (v19 <= 0x12B && !(v19 % 0x1E))
    {
      v20 = CVPixelBufferRetain(pixelBuffer);
      sub_1B67C2528(*(void **)(a1 + 2256), (uint64_t)v20, 2u, 0, &unk_1E6A16A20);
      v19 = *(_QWORD *)(a1 + 2264);
    }
    if (v19 < 0x12C)
      ++v19;
    *(_QWORD *)(a1 + 2264) = v19;
  }
  v247 = a7;
  v248 = a6;
  if (*(_BYTE *)(a1 + 80))
  {
    if (!(*(unsigned int (**)(_QWORD, __n128))(**((_QWORD **)a2 + 15) + 24))(*((_QWORD *)a2 + 15), v15)
      || !*(_WORD *)(*((_QWORD *)a2 + 15) + 16))
    {
      goto LABEL_90;
    }
    v21 = CVPixelBufferGetIOSurface(pixelBuffer);
    v22 = (const __CFNumber *)IOSurfaceCopyValue(v21, CFSTR("FrameYUVChecksum"));
    if (v22)
    {
      CFNumberGetValue(v22, kCFNumberSInt32Type, &valuePtr);
      v23 = valuePtr;
      if (valuePtr)
        goto LABEL_70;
    }
    v24 = CVPixelBufferRetain(pixelBuffer);
    extraColumnsOnLeft = 0;
    extraRowsOnTop = 0;
    extraColumnsOnRight = 0;
    extraRowsOnBottom = 0;
    CVPixelBufferGetExtendedPixels(v24, &extraColumnsOnLeft, &extraColumnsOnRight, &extraRowsOnTop, &extraRowsOnBottom);
    Width = CVPixelBufferGetWidth(v24);
    Height = CVPixelBufferGetHeight(v24);
    v27 = extraColumnsOnLeft + Width + extraColumnsOnRight;
    v28 = extraRowsOnTop + Height + extraRowsOnBottom;
    v29 = *(unsigned int *)(a1 + 112);
    if (v27 >= v29 && v28 >= *(unsigned int *)(a1 + 116))
    {
      CVPixelBufferLockBaseAddress(v24, 1uLL);
      BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(v24, 0);
      v48 = CVPixelBufferGetBaseAddressOfPlane(v24, 1uLL);
      BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v24, 0);
      v50 = CVPixelBufferGetBytesPerRowOfPlane(v24, 1uLL);
      valuePtr = sub_1B68AC3F8((uint64_t)BaseAddressOfPlane, (uint64_t)v48, BytesPerRowOfPlane, v50, *(_DWORD *)(a1 + 112), *(_DWORD *)(a1 + 116));
      CVPixelBufferUnlockBaseAddress(v24, 1uLL);
      goto LABEL_69;
    }
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      goto LABEL_69;
    v30 = *(_DWORD *)(a1 + 24);
    v31 = "H.264";
    if (v30 > 1718908519)
    {
      if (v30 == 1752589105)
        goto LABEL_67;
      v32 = 1718908520;
    }
    else
    {
      if (v30 == 1684632424)
        goto LABEL_67;
      v32 = 1685481521;
    }
    if (v30 != v32)
    {
LABEL_68:
      v56 = *(_DWORD *)(a1 + 116);
      *(_DWORD *)buf = 134219266;
      v264 = a1;
      v265 = 2080;
      *(_QWORD *)v266 = v31;
      *(_WORD *)&v266[8] = 1024;
      *(_DWORD *)v267 = v29;
      *(_WORD *)&v267[4] = 1024;
      *(_DWORD *)&v267[6] = v56;
      v268 = 2048;
      *(_QWORD *)v269 = v27;
      *(_WORD *)&v269[8] = 2048;
      v270 = v28;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%s): Decoder cannot calculate checksum. Target resolution (%d, %d) is bigger than pixel buffer resolution (%ld, %ld)\n", buf, 0x36u);
LABEL_69:
      CVPixelBufferRelease(v24);
      v23 = valuePtr;
      if (valuePtr)
      {
LABEL_70:
        v57 = *(unsigned __int16 *)(*((_QWORD *)a2 + 15) + 16);
        if (v23 != v57)
        {
          if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          {
LABEL_84:
            v68 = 0;
            a3 = 4294954387;
LABEL_91:
            v69 = (int *)*((_QWORD *)a2 + 15);
            if (v69[5] >= 1 && v69[6] >= 1)
            {
              v70 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
              Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              v69 = (int *)*((_QWORD *)a2 + 15);
              if (Mutable)
              {
                v72 = CFNumberCreate(v70, kCFNumberIntType, v69 + 7);
                CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA8D48], v72);
                CFRelease(v72);
                v73 = CFNumberCreate(v70, kCFNumberIntType, (const void *)(*((_QWORD *)a2 + 15) + 32));
                CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA8D58], v73);
                CFRelease(v73);
                v74 = CFNumberCreate(v70, kCFNumberIntType, (const void *)(*((_QWORD *)a2 + 15) + 20));
                CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA8D60], v74);
                CFRelease(v74);
                v75 = CFNumberCreate(v70, kCFNumberIntType, (const void *)(*((_QWORD *)a2 + 15) + 24));
                CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA8D40], v75);
                CFRelease(v75);
                CVBufferSetAttachment(pixelBuffer, (CFStringRef)*MEMORY[0x1E0CED6C8], Mutable, kCVAttachmentMode_ShouldPropagate);
                CFRelease(Mutable);
                v69 = (int *)*((_QWORD *)a2 + 15);
              }
            }
            if ((*(unsigned int (**)(int *))(*(_QWORD *)v69 + 112))(v69))
            {
              v76 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
              v77 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              if (v77)
              {
                v78 = v77;
                v79 = *((_QWORD *)a2 + 15);
                *(_DWORD *)buf = *(__int16 *)(v79 + 104);
                LODWORD(extraColumnsOnLeft) = *(__int16 *)(v79 + 106);
                LODWORD(extraColumnsOnRight) = *(unsigned __int16 *)(v79 + 108);
                LODWORD(extraRowsOnTop) = *(unsigned __int16 *)(v79 + 110);
                v80 = CFNumberCreate(v76, kCFNumberIntType, buf);
                CFDictionarySetValue(v78, (const void *)*MEMORY[0x1E0CA8D48], v80);
                CFRelease(v80);
                v81 = CFNumberCreate(v76, kCFNumberIntType, &extraColumnsOnLeft);
                CFDictionarySetValue(v78, (const void *)*MEMORY[0x1E0CA8D58], v81);
                CFRelease(v81);
                v82 = CFNumberCreate(v76, kCFNumberIntType, &extraColumnsOnRight);
                CFDictionarySetValue(v78, (const void *)*MEMORY[0x1E0CA8D60], v82);
                CFRelease(v82);
                v83 = CFNumberCreate(v76, kCFNumberIntType, &extraRowsOnTop);
                CFDictionarySetValue(v78, (const void *)*MEMORY[0x1E0CA8D40], v83);
                CFRelease(v83);
                CVBufferSetAttachment(pixelBuffer, (CFStringRef)*MEMORY[0x1E0CED6C8], v78, kCVAttachmentMode_ShouldPropagate);
                CFRelease(v78);
              }
            }
            v84 = a2 + 24;
            if (a2[24] >= 1 && a2[25] >= 1)
            {
              v85 = CFNumberCreate(0, kCFNumberIntType, a2 + 24);
              CVBufferSetAttachment(pixelBuffer, CFSTR("VraWidth"), v85, kCVAttachmentMode_ShouldPropagate);
              CFRelease(v85);
              v86 = CFNumberCreate(0, kCFNumberIntType, a2 + 25);
              CVBufferSetAttachment(pixelBuffer, CFSTR("VraHeight"), v86, kCVAttachmentMode_ShouldPropagate);
              CFRelease(v86);
            }
            a2[22] = 0;
            v87 = CFNumberCreate(0, kCFNumberIntType, a2 + 22);
            CVBufferSetAttachment(pixelBuffer, CFSTR("RotationFlags"), v87, kCVAttachmentMode_ShouldPropagate);
            CFRelease(v87);
            v88 = CVPixelBufferRetain(pixelBuffer);
            v262 = v88;
            v89 = *(unsigned __int8 *)(a1 + 93);
            *((_QWORD *)a2 + 13) = 0;
            if (v89)
            {
              v90 = *((_QWORD *)a2 + 15);
              v91 = *(float *)(v90 + 60);
              if (v91 < 1.0 && v91 > 0.0)
              {
                v92 = *(float *)(v90 + 64);
                if (v92 < 1.0 && v92 > 0.0)
                {
                  v93 = v88;
                  v94 = CVPixelBufferGetWidth(v88);
                  v95 = CVPixelBufferGetHeight(v93);
                  v96 = (int32x2_t)__PAIR64__(v95, v94);
                  if (*v84 >= 1)
                    v96 = (int32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(a2[25] > 0), 0x1FuLL)), *(int8x8_t *)(a2 + 24), (int8x8_t)__PAIR64__(v95, v94));
                  v97 = *((_QWORD *)a2 + 15);
                  v98 = vcvt_f32_s32(v96);
                  v99 = vcvt_s32_f32(vmul_f32(*(float32x2_t *)(v97 + 60), v98));
                  *((int32x2_t *)a2 + 12) = v99;
                  *((int32x2_t *)a2 + 13) = vmin_s32(vsub_s32(v96, v99), vcvt_s32_f32(vmul_f32(*(float32x2_t *)(v97 + 52), v98)));
                }
              }
            }
            if (v68)
            {
              if (a2[25] < 1 || *v84 < 1)
              {
                a3 = 0;
              }
              else
              {
                v100 = *(_QWORD *)(a1 + 2224);
                if (v100)
                {
                  sub_1B6872E44(v100, (uint64_t *)"vra_width", (double)*v84);
                  sub_1B6872E44(*(_QWORD *)(a1 + 2224), (uint64_t *)"vra_height", (double)a2[25]);
                }
                if (*(_QWORD *)(a1 + 2304) && (*(_BYTE *)(a1 + 2296) & 1) != 0)
                {
                  a3 = sub_1B67978FC(a1, a2, &v262);
                }
                else if (sub_1B6797F28(a1, a2, &v262, 0, 0))
                {
                  a3 = 4294954385;
                }
                else
                {
                  a3 = 0;
                }
              }
            }
            v39 = v262;
            a6 = v248;
            if (!v262)
              goto LABEL_136;
            goto LABEL_121;
          }
          v59 = *(_DWORD *)(a1 + 112);
          v58 = *(_DWORD *)(a1 + 116);
          v60 = *(_DWORD *)(a1 + 24);
          v61 = "H.264";
          if (v60 > 1718908519)
          {
            if (v60 == 1752589105)
              goto LABEL_82;
            v62 = 1718908520;
          }
          else
          {
            if (v60 == 1684632424)
              goto LABEL_82;
            v62 = 1685481521;
          }
          if (v60 != v62)
          {
LABEL_83:
            *(_DWORD *)buf = 134219266;
            v264 = a1;
            v265 = 1024;
            *(_DWORD *)v266 = v59;
            *(_WORD *)&v266[4] = 1024;
            *(_DWORD *)&v266[6] = v58;
            *(_WORD *)v267 = 2080;
            *(_QWORD *)&v267[2] = v61;
            v268 = 1024;
            *(_DWORD *)v269 = v23;
            *(_WORD *)&v269[4] = 1024;
            *(_DWORD *)&v269[6] = v57;
            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder checksum mismatch local %x <-> received %x\n", buf, 0x2Eu);
            goto LABEL_84;
          }
LABEL_82:
          v61 = "HEVC";
          goto LABEL_83;
        }
LABEL_90:
        a3 = 0;
        v68 = 1;
        goto LABEL_91;
      }
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        goto LABEL_90;
      v64 = *(_DWORD *)(a1 + 112);
      v63 = *(_DWORD *)(a1 + 116);
      v65 = *(_DWORD *)(a1 + 24);
      v66 = "H.264";
      if (v65 > 1718908519)
      {
        if (v65 == 1752589105)
          goto LABEL_88;
        v67 = 1718908520;
      }
      else
      {
        if (v65 == 1684632424)
          goto LABEL_88;
        v67 = 1685481521;
      }
      if (v65 != v67)
      {
LABEL_89:
        *(_DWORD *)buf = 134218754;
        v264 = a1;
        v265 = 1024;
        *(_DWORD *)v266 = v64;
        *(_WORD *)&v266[4] = 1024;
        *(_DWORD *)&v266[6] = v63;
        *(_WORD *)v267 = 2080;
        *(_QWORD *)&v267[2] = v66;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder checksum is N/A", buf, 0x22u);
        goto LABEL_90;
      }
LABEL_88:
      v66 = "HEVC";
      goto LABEL_89;
    }
LABEL_67:
    v31 = "HEVC";
    goto LABEL_68;
  }
  v39 = CVPixelBufferRetain(pixelBuffer);
  a3 = 0;
  v262 = v39;
  if (!v39)
    goto LABEL_136;
LABEL_121:
  if (*(int *)(a1 + 136) < 2)
  {
LABEL_136:
    v33 = 0;
LABEL_137:
    a7 = v247;
    goto LABEL_138;
  }
  v246 = a4;
  if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(a1 + 2288) + 96))(*(_QWORD *)(a1 + 2288)))
  {
    if (*(_WORD *)(a1 + 176))
    {
      v101 = *(unsigned __int16 *)(a1 + 178);
      if (*(_WORD *)(a1 + 178))
      {
        *(_DWORD *)(a1 + 140) = *(unsigned __int16 *)(a1 + 176);
        *(_DWORD *)(a1 + 144) = v101;
      }
    }
  }
  v102 = (CVPixelBufferPoolRef *)(a1 + 184);
  if (!*(_QWORD *)(a1 + 184))
    goto LABEL_367;
  v103 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 15) + 96))(*((_QWORD *)a2 + 15));
  v104 = *v102;
  if (v103)
  {
    PixelBufferAttributes = CVPixelBufferPoolGetPixelBufferAttributes(*v102);
    *(_DWORD *)buf = 0;
    LODWORD(extraColumnsOnLeft) = 0;
    if (PixelBufferAttributes)
    {
      v106 = PixelBufferAttributes;
      v107 = (const void *)*MEMORY[0x1E0CA90E0];
      if (CFDictionaryContainsKey(PixelBufferAttributes, (const void *)*MEMORY[0x1E0CA90E0]))
        sub_1B6790B00(v106, v107, buf);
      v108 = (const void *)*MEMORY[0x1E0CA8FD8];
      if (CFDictionaryContainsKey(v106, (const void *)*MEMORY[0x1E0CA8FD8]))
        sub_1B6790B00(v106, v108, &extraColumnsOnLeft);
    }
    if (*(_DWORD *)(a1 + 140) == *(_DWORD *)buf && *(_DWORD *)(a1 + 144) == (_DWORD)extraColumnsOnLeft)
    {
      v104 = *v102;
    }
    else
    {
      CVPixelBufferPoolRelease(*v102);
      v104 = 0;
      *v102 = 0;
    }
  }
  if (!v104)
  {
LABEL_367:
    poolOut = (CVPixelBufferPoolRef *)(a1 + 184);
    v140 = *(_DWORD *)(a1 + 140);
    v245 = *(_DWORD *)(a1 + 144);
    PixelFormatType = CVPixelBufferGetPixelFormatType(v39);
    v142 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    v143 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    v144 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v145 = CFDictionaryCreateMutable(0, 0, v142, v143);
    if (PixelFormatType > 1885745711)
    {
      if (PixelFormatType == 1885746228)
      {
        PixelFormatType = 2019963956;
      }
      else if (PixelFormatType == 1885745712)
      {
        PixelFormatType = 2019963440;
      }
    }
    else if (PixelFormatType == 1882468912)
    {
      PixelFormatType = 2016686640;
    }
    else if (PixelFormatType == 1882469428)
    {
      PixelFormatType = 2016687156;
    }
    *(_DWORD *)buf = v140;
    v146 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
    if (v146)
    {
      v147 = v146;
      CFDictionaryAddValue(v144, (const void *)*MEMORY[0x1E0CA90E0], v146);
      CFRelease(v147);
    }
    *(_DWORD *)buf = v245;
    v148 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
    if (v148)
    {
      v149 = v148;
      CFDictionaryAddValue(v144, (const void *)*MEMORY[0x1E0CA8FD8], v148);
      CFRelease(v149);
    }
    *(_DWORD *)buf = PixelFormatType;
    v150 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
    if (v150)
    {
      v151 = v150;
      CFDictionaryAddValue(v144, (const void *)*MEMORY[0x1E0CA9040], v150);
      CFRelease(v151);
    }
    *(_DWORD *)buf = 2;
    v152 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
    if (v152)
    {
      v153 = v152;
      CFDictionaryAddValue(v144, (const void *)*MEMORY[0x1E0CA9060], v152);
      CFRelease(v153);
    }
    *(_DWORD *)buf = 64;
    v154 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
    if (v154)
    {
      v155 = v154;
      CFDictionaryAddValue(v144, (const void *)*MEMORY[0x1E0CA8F68], v154);
      CFRelease(v155);
    }
    *(_DWORD *)buf = 64;
    v156 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
    if (v156)
    {
      v157 = v156;
      CFDictionaryAddValue(v144, (const void *)*MEMORY[0x1E0CA9048], v156);
      CFRelease(v157);
    }
    CFDictionarySetValue(v144, (const void *)*MEMORY[0x1E0CA8FF0], v145);
    CVPixelBufferPoolCreate(0, 0, v144, poolOut);
    if (v144)
      CFRelease(v144);
    if (v145)
      CFRelease(v145);
    v104 = *poolOut;
    if (!*poolOut)
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        goto LABEL_188;
      v172 = *(_DWORD *)(a1 + 140);
      v171 = *(_DWORD *)(a1 + 144);
      v173 = *(_DWORD *)(a1 + 24);
      v174 = "H.264";
      if (v173 > 1718908519)
      {
        if (v173 == 1752589105)
          goto LABEL_299;
        v175 = 1718908520;
      }
      else
      {
        if (v173 == 1684632424)
          goto LABEL_299;
        v175 = 1685481521;
      }
      if (v173 != v175)
      {
LABEL_300:
        v216 = CVPixelBufferGetPixelFormatType(v39);
        *(_DWORD *)buf = 134219010;
        v264 = a1;
        v265 = 1024;
        *(_DWORD *)v266 = v172;
        *(_WORD *)&v266[4] = 1024;
        *(_DWORD *)&v266[6] = v171;
        *(_WORD *)v267 = 2080;
        *(_QWORD *)&v267[2] = v174;
        v268 = 1024;
        *(_DWORD *)v269 = v216;
        v217 = MEMORY[0x1E0C81028];
        v218 = "VCPDec %p (%dx%d, %s): Decoder failed to create stitched pixel buffer pool for subframe decoding! (pixfmt %d)\n";
        v219 = 40;
LABEL_310:
        _os_log_impl(&dword_1B676B000, v217, OS_LOG_TYPE_DEFAULT, v218, buf, v219);
        goto LABEL_188;
      }
LABEL_299:
      v174 = "HEVC";
      goto LABEL_300;
    }
  }
  v158 = (CVBufferRef *)(a1 + 192);
  if (*(_QWORD *)(a1 + 192))
    goto LABEL_229;
  if (!CVPixelBufferPoolCreatePixelBuffer(0, v104, (CVPixelBufferRef *)(a1 + 192)))
  {
    CVBufferPropagateAttachments(v262, *v158);
LABEL_229:
    v159 = *((unsigned __int16 *)a2 + 6);
    v160 = *(unsigned __int16 *)(a1 + 156);
    if (v159 == v160)
      goto LABEL_263;
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
LABEL_258:
      *(_BYTE *)(a1 + 165) = 1;
      v177 = *(_QWORD *)(a1 + 2280);
      v179 = *(_QWORD *)(v177 + 176);
      v178 = *(_QWORD *)(v177 + 184);
      if (v178 != v179)
      {
        v180 = 0;
        v181 = 0;
        do
        {
          v182 = *(__CVBuffer **)(v179 + v180);
          if (v182)
          {
            CVPixelBufferRelease(v182);
            *(_QWORD *)(v179 + v180) = 0;
            v179 = *(_QWORD *)(v177 + 176);
            v178 = *(_QWORD *)(v177 + 184);
          }
          ++v181;
          v180 += 24;
        }
        while (0xAAAAAAAAAAAAAAABLL * ((v178 - v179) >> 3) > v181);
      }
LABEL_263:
      v183 = a2[4];
      v184 = *(_DWORD *)(a1 + 160);
      if (v183 > v184 || v183 < 0 && v184 >= 1)
      {
        *(_DWORD *)(a1 + 160) = v183;
        *(_DWORD *)(a1 + 156) = *((unsigned __int16 *)a2 + 6);
        *(_BYTE *)(a1 + 164) = 0;
        a6 = v248;
LABEL_267:
        kdebug_trace();
        v185 = *(_QWORD *)(a1 + 2280);
        v186 = a2[2];
        v187 = *(_QWORD *)(v185 + 176);
        if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(v185 + 184) - v187) >> 3) > v186)
        {
          v188 = *((_QWORD *)a2 + 15);
          v189 = *(_QWORD *)(v188 + 68);
          v190 = *(_DWORD *)(v188 + 76);
          v191 = a2[2];
          v192 = (CVPixelBufferRef *)(v187 + 24 * v186);
          if (*v192)
          {
            CVPixelBufferRelease(*v192);
            *v192 = 0;
          }
          *v192 = CVPixelBufferRetain(pixelBuffer);
          v193 = v187 + 24 * v191;
          *(_QWORD *)(v193 + 8) = v189;
          *(_DWORD *)(v193 + 16) = v190;
          v185 = *(_QWORD *)(a1 + 2280);
          v186 = a2[2];
          a6 = v248;
        }
        v194 = sub_1B677AC50(v185, v186, *v158);
        kdebug_trace();
        if (v194)
        {
          a4 = v246;
          a7 = v247;
          if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          {
LABEL_295:
            v33 = 0;
            *(_BYTE *)(a1 + 164) = 1;
            *(_WORD *)(a1 + 158) = 0;
            goto LABEL_138;
          }
          v196 = *(_DWORD *)(a1 + 112);
          v195 = *(_DWORD *)(a1 + 116);
          v197 = *(_DWORD *)(a1 + 24);
          v198 = "H.264";
          if (v197 > 1718908519)
          {
            if (v197 == 1752589105)
              goto LABEL_293;
            v199 = 1718908520;
          }
          else
          {
            if (v197 == 1684632424)
              goto LABEL_293;
            v199 = 1685481521;
          }
          if (v197 != v199)
          {
LABEL_294:
            v214 = a2[2];
            v215 = *((unsigned __int16 *)a2 + 6);
            *(_DWORD *)buf = 134219266;
            v264 = a1;
            v265 = 1024;
            *(_DWORD *)v266 = v196;
            *(_WORD *)&v266[4] = 1024;
            *(_DWORD *)&v266[6] = v195;
            *(_WORD *)v267 = 2080;
            *(_QWORD *)&v267[2] = v198;
            v268 = 1024;
            *(_DWORD *)v269 = v214;
            *(_WORD *)&v269[4] = 1024;
            *(_DWORD *)&v269[6] = v215;
            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Failed to stitch tile (id %d, order %d)\n", buf, 0x2Eu);
            goto LABEL_295;
          }
LABEL_293:
          v198 = "HEVC";
          goto LABEL_294;
        }
        ++*(_WORD *)(a1 + 156);
        v200 = a2[2];
        v201 = (unsigned __int16)(*(_WORD *)(a1 + 158) | (1 << v200));
        *(_WORD *)(a1 + 158) |= 1 << v200;
        v202 = *(_DWORD *)(a1 + 136);
        v203 = ~(-1 << v202);
        if (v201 == v203)
        {
          *(_BYTE *)(a1 + 165) = 0;
          a7 = v247;
          goto LABEL_278;
        }
        if (*(_BYTE *)(a1 + 165))
        {
          v33 = 0;
LABEL_304:
          a4 = v246;
          goto LABEL_137;
        }
        v220 = __OFSUB__(v202, 1);
        v221 = v202 - 1;
        if (v221 < 0 != v220)
        {
LABEL_343:
          a7 = v247;
          if (v201 != v203 || !*((_BYTE *)a2 + 14))
          {
            v33 = 0;
LABEL_357:
            a4 = v246;
            goto LABEL_138;
          }
LABEL_278:
          kdebug_trace();
          if (!sub_1B677AF2C(*(_QWORD **)(a1 + 2280), *(CVPixelBufferRef *)(a1 + 192))
            || !os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          {
            goto LABEL_356;
          }
          v205 = *(_DWORD *)(a1 + 112);
          v204 = *(_DWORD *)(a1 + 116);
          v206 = *(_DWORD *)(a1 + 24);
          v207 = "H.264";
          if (v206 > 1718908519)
          {
            if (v206 == 1752589105)
              goto LABEL_354;
            v208 = 1718908520;
          }
          else
          {
            if (v206 == 1684632424)
              goto LABEL_354;
            v208 = 1685481521;
          }
          if (v206 != v208)
          {
LABEL_355:
            *(_DWORD *)buf = 134218754;
            v264 = a1;
            v265 = 1024;
            *(_DWORD *)v266 = v205;
            *(_WORD *)&v266[4] = 1024;
            *(_DWORD *)&v266[6] = v204;
            *(_WORD *)v267 = 2080;
            *(_QWORD *)&v267[2] = v207;
            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Failed to filter the frame\n", buf, 0x22u);
LABEL_356:
            kdebug_trace();
            v33 = 1;
            goto LABEL_357;
          }
LABEL_354:
          v207 = "HEVC";
          goto LABEL_355;
        }
        v222 = 0;
        v223 = 0;
        if (*((_BYTE *)a2 + 14))
          LOBYTE(v200) = v221;
        v224 = ~(-1 << (v200 + 1)) - v201;
        while (1)
        {
          v225 = *(_QWORD *)(a1 + 2280);
          v226 = *(_QWORD *)(v225 + 176);
          if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(v225 + 184) - v226) >> 3) <= v223)
            goto LABEL_326;
          if (!*(_QWORD *)(v226 + v222) || (v224 & 1) == 0)
            goto LABEL_326;
          if (!sub_1B677AC50(v225, v223, *v158))
            break;
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          {
            v228 = *(_DWORD *)(a1 + 24);
            if (v228 <= 1718908519)
            {
              if (v228 != 1684632424)
              {
                v229 = "H.264";
                v230 = 1685481521;
                goto LABEL_331;
              }
              goto LABEL_332;
            }
            if (v228 == 1752589105)
              goto LABEL_332;
            v229 = "H.264";
            v230 = 1718908520;
LABEL_331:
            if (v228 == v230)
LABEL_332:
              v229 = "HEVC";
            v232 = *(_DWORD *)(a1 + 112);
            v233 = *(_DWORD *)(a1 + 116);
            v234 = *((unsigned __int16 *)a2 + 6);
            *(_DWORD *)buf = 134219266;
            v264 = a1;
            v265 = 1024;
            *(_DWORD *)v266 = v232;
            *(_WORD *)&v266[4] = 1024;
            *(_DWORD *)&v266[6] = v233;
            *(_WORD *)v267 = 2080;
            *(_QWORD *)&v267[2] = v229;
            v268 = 1024;
            *(_DWORD *)v269 = v223;
            *(_WORD *)&v269[4] = 1024;
            *(_DWORD *)&v269[6] = v234;
            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Failed to stitch non-dirty tile (id %d, order %d)\n", buf, 0x2Eu);
          }
LABEL_327:
          ++v223;
          v231 = *(int *)(a1 + 136);
          v222 += 24;
          if ((uint64_t)v223 >= v231)
          {
            v201 = *(unsigned __int16 *)(a1 + 158);
            v203 = ~(-1 << v231);
            a6 = v248;
            goto LABEL_343;
          }
        }
        *(_WORD *)(a1 + 158) |= 1 << v223;
LABEL_326:
        LOWORD(v224) = (unsigned __int16)v224 >> 1;
        goto LABEL_327;
      }
      a6 = v248;
      if (*(_BYTE *)(a1 + 164))
      {
        a4 = v246;
        a7 = v247;
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
        {
LABEL_364:
          v33 = 0;
LABEL_138:
          v109 = *(_DWORD *)(a1 + 24);
          if (v109 > 1718908519)
          {
            if (v109 == 1752589105)
              goto LABEL_144;
            v110 = 1718908520;
          }
          else
          {
            if (v109 == 1684632424)
              goto LABEL_144;
            v110 = 1685481521;
          }
          if (v109 != v110)
            goto LABEL_147;
LABEL_144:
          if ((_DWORD)a3)
            goto LABEL_145;
          a3 = *(unsigned int *)(a1 + 168);
          if ((_DWORD)a3)
          {
            if ((_DWORD)a3 == 1 || (v135 = *((unsigned __int8 *)a2 + 85), v135 == 32) || v135 == 20)
            {
              if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
              {
LABEL_250:
                a3 = 0;
                *(_DWORD *)(a1 + 168) = 0;
                *(_BYTE *)(a1 + 172) = 0;
                goto LABEL_147;
              }
              v137 = *(_DWORD *)(a1 + 112);
              v136 = *(_DWORD *)(a1 + 116);
              v138 = "H.264";
              if (v109 > 1718908519)
              {
                if (v109 == 1752589105)
                  goto LABEL_246;
                v139 = 1718908520;
              }
              else
              {
                if (v109 == 1684632424)
                  goto LABEL_246;
                v139 = 1685481521;
              }
              if (v109 != v139)
              {
LABEL_247:
                v176 = "Decoder recovered by IDR frame";
                *(_DWORD *)buf = 134219010;
                v264 = a1;
                v265 = 1024;
                if ((_DWORD)a3 == 1)
                  v176 = "Decoder recovered from recoverable error";
                *(_DWORD *)v266 = v137;
                *(_WORD *)&v266[4] = 1024;
                *(_DWORD *)&v266[6] = v136;
                *(_WORD *)v267 = 2080;
                *(_QWORD *)&v267[2] = v138;
                v268 = 2080;
                *(_QWORD *)v269 = v176;
                _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): %s\n", buf, 0x2Cu);
                goto LABEL_250;
              }
LABEL_246:
              v138 = "HEVC";
              goto LABEL_247;
            }
            a3 = 0;
          }
LABEL_147:
          v111 = *(_DWORD *)(a1 + 24);
          if (v111 > 1718908519)
          {
            if (v111 == 1718908520)
              goto LABEL_153;
            v112 = 1752589105;
          }
          else
          {
            if (v111 == 1684632424)
              goto LABEL_153;
            v112 = 1685481521;
          }
          if (v111 != v112)
          {
            v113 = v262;
            goto LABEL_159;
          }
LABEL_153:
          v113 = v262;
          if (*(_DWORD *)(a1 + 168) == 2)
          {
            if (v262)
            {
              CVPixelBufferRelease(v262);
              v262 = 0;
            }
            if (*(_BYTE *)(a1 + 172))
            {
              a3 = 0;
            }
            else
            {
              *(_BYTE *)(a1 + 172) = 0;
              v118 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("ForceOneKeyRequest"), CFSTR("com.apple.VideoProcessing"));
              if (v118)
              {
                v119 = v118;
                *(_BYTE *)(a1 + 172) = CFStringGetIntValue(v118) != 0;
                CFRelease(v119);
              }
              a3 = 4294954387;
            }
            goto LABEL_170;
          }
LABEL_159:
          v114 = (const __CFDictionary *)*((_QWORD *)a2 + 19);
          if (v114 && v113)
          {
            if (CFDictionaryContainsKey(v114, CFSTR("PropagatableAttachmentsNALSize")))
            {
              Value = CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 19), CFSTR("PropagatableAttachmentsNALSize"));
              if (Value)
              {
                v116 = Value;
                CVBufferSetAttachment(v113, CFSTR("PropagatableAttachmentsNALSize"), Value, kCVAttachmentMode_ShouldPropagate);
                CFRelease(v116);
              }
            }
            if (CFDictionaryContainsKey(*((CFDictionaryRef *)a2 + 19), CFSTR("PropagatableAttachments")))
            {
              v117 = CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 19), CFSTR("PropagatableAttachments"));
              if (v117)
                CVBufferSetAttachment(v262, CFSTR("PropagatableAttachments"), v117, kCVAttachmentMode_ShouldPropagate);
            }
          }
LABEL_170:
          if (*(_BYTE *)(a1 + 80))
          {
            if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)a2 + 15) + 80))(*((_QWORD *)a2 + 15)))
            {
              v120 = CFNumberCreate(0, kCFNumberSInt64Type, (const void *)(*((_QWORD *)a2 + 15) + 88));
              if (v120)
              {
                v121 = v120;
                if (v262)
                  CVBufferSetAttachment(v262, CFSTR("HIDTimeStamp"), v120, kCVAttachmentMode_ShouldPropagate);
                v122 = *(__CVBuffer **)(a1 + 192);
                if (v122)
                  CVBufferSetAttachment(v122, CFSTR("HIDTimeStamp"), v121, kCVAttachmentMode_ShouldPropagate);
                CFRelease(v121);
              }
            }
          }
          v123 = v262;
          if (*((_BYTE *)a2 + 112) && v262)
            CVBufferSetAttachment(v262, CFSTR("FrameMLEnahnced"), (CFTypeRef)*MEMORY[0x1E0C9AE50], kCVAttachmentMode_ShouldPropagate);
          kdebug_trace();
          v124 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __int128 *, __int128 *))(a1 + 28);
          v125 = *(_QWORD *)(a1 + 36);
          v126 = *(_QWORD *)a2;
          if (*(int *)(a1 + 136) < 2)
          {
            v251 = *a6;
            v252 = *((_QWORD *)a6 + 2);
            v249 = *a7;
            v250 = *((_QWORD *)a7 + 2);
            v128 = &v251;
            v129 = &v249;
            v130 = a3;
            v131 = a4;
            v132 = v123;
          }
          else
          {
            if (v33)
            {
              v127 = *(_QWORD *)(a1 + 192);
              v255 = *a6;
              v256 = *((_QWORD *)a6 + 2);
              v253 = *a7;
              v254 = *((_QWORD *)a7 + 2);
              v124(v125, v126, a3, a4, v127, &v255, &v253);
              CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 192));
              *(_QWORD *)(a1 + 192) = 0;
LABEL_187:
              CVPixelBufferRelease(v123);
              goto LABEL_188;
            }
            v255 = *a6;
            v256 = *((_QWORD *)a6 + 2);
            v253 = *a7;
            v254 = *((_QWORD *)a7 + 2);
            v128 = &v255;
            v129 = &v253;
            v130 = a3;
            v131 = a4;
            v132 = 0;
          }
          v124(v125, v126, v130, v131, (uint64_t)v132, v128, v129);
          goto LABEL_187;
        }
        v210 = *(_DWORD *)(a1 + 112);
        v209 = *(_DWORD *)(a1 + 116);
        v211 = *(_DWORD *)(a1 + 24);
        v212 = "H.264";
        if (v211 > 1718908519)
        {
          if (v211 == 1752589105)
            goto LABEL_341;
          v213 = 1718908520;
        }
        else
        {
          if (v211 == 1684632424)
            goto LABEL_341;
          v213 = 1685481521;
        }
        if (v211 != v213)
        {
LABEL_342:
          *(_DWORD *)buf = 134218754;
          v264 = a1;
          v265 = 1024;
          *(_DWORD *)v266 = v210;
          *(_WORD *)&v266[4] = 1024;
          *(_DWORD *)&v266[6] = v209;
          *(_WORD *)v267 = 2080;
          *(_QWORD *)&v267[2] = v212;
          v240 = MEMORY[0x1E0C81028];
          v241 = "VCPDec %p (%dx%d, %s): Do not process this subframe because it should be dropped\n";
          v242 = OS_LOG_TYPE_DEBUG;
          v243 = 34;
LABEL_363:
          _os_log_impl(&dword_1B676B000, v240, v242, v241, buf, v243);
          goto LABEL_364;
        }
LABEL_341:
        v212 = "HEVC";
        goto LABEL_342;
      }
      if (v183 == v184)
      {
        if (*((unsigned __int16 *)a2 + 6) != *(unsigned __int16 *)(a1 + 156))
        {
          v33 = 0;
          *(_BYTE *)(a1 + 164) = 1;
          *(_WORD *)(a1 + 158) = 0;
          goto LABEL_304;
        }
        goto LABEL_267;
      }
      v33 = 0;
      a4 = v246;
      a7 = v247;
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        goto LABEL_138;
      v236 = *(_DWORD *)(a1 + 112);
      v235 = *(_DWORD *)(a1 + 116);
      v237 = *(_DWORD *)(a1 + 24);
      v238 = "H.264";
      if (v237 > 1718908519)
      {
        if (v237 == 1752589105)
          goto LABEL_361;
        v239 = 1718908520;
      }
      else
      {
        if (v237 == 1684632424)
          goto LABEL_361;
        v239 = 1685481521;
      }
      if (v237 != v239)
      {
LABEL_362:
        *(_DWORD *)buf = 134219266;
        v264 = a1;
        v265 = 1024;
        *(_DWORD *)v266 = v236;
        *(_WORD *)&v266[4] = 1024;
        *(_DWORD *)&v266[6] = v235;
        *(_WORD *)v267 = 2080;
        *(_QWORD *)&v267[2] = v238;
        v268 = 1024;
        *(_DWORD *)v269 = v184;
        *(_WORD *)&v269[4] = 1024;
        *(_DWORD *)&v269[6] = v183;
        v240 = MEMORY[0x1E0C81028];
        v241 = "VCPDec %p (%dx%d, %s): Timestamp does not match, expected: %d, actual: %d\n";
        v242 = OS_LOG_TYPE_DEFAULT;
        v243 = 46;
        goto LABEL_363;
      }
LABEL_361:
      v238 = "HEVC";
      goto LABEL_362;
    }
    v162 = *(_DWORD *)(a1 + 112);
    v161 = *(_DWORD *)(a1 + 116);
    v163 = *(_DWORD *)(a1 + 24);
    v164 = "H.264";
    if (v163 > 1718908519)
    {
      if (v163 == 1752589105)
        goto LABEL_256;
      v165 = 1718908520;
    }
    else
    {
      if (v163 == 1684632424)
        goto LABEL_256;
      v165 = 1685481521;
    }
    if (v163 != v165)
    {
LABEL_257:
      *(_DWORD *)buf = 134219266;
      v264 = a1;
      v265 = 1024;
      *(_DWORD *)v266 = v162;
      *(_WORD *)&v266[4] = 1024;
      *(_DWORD *)&v266[6] = v161;
      *(_WORD *)v267 = 2080;
      *(_QWORD *)&v267[2] = v164;
      v268 = 1024;
      *(_DWORD *)v269 = v160;
      *(_WORD *)&v269[4] = 1024;
      *(_DWORD *)&v269[6] = v159;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Tile order does not match, expected: %d, actual: %d\n", buf, 0x2Eu);
      goto LABEL_258;
    }
LABEL_256:
    v164 = "HEVC";
    goto LABEL_257;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v167 = *(_DWORD *)(a1 + 112);
    v166 = *(_DWORD *)(a1 + 116);
    v168 = *(_DWORD *)(a1 + 24);
    v169 = "H.264";
    if (v168 > 1718908519)
    {
      if (v168 == 1752589105)
        goto LABEL_308;
      v170 = 1718908520;
    }
    else
    {
      if (v168 == 1684632424)
        goto LABEL_308;
      v170 = 1685481521;
    }
    if (v168 != v170)
    {
LABEL_309:
      *(_DWORD *)buf = 134218754;
      v264 = a1;
      v265 = 1024;
      *(_DWORD *)v266 = v167;
      *(_WORD *)&v266[4] = 1024;
      *(_DWORD *)&v266[6] = v166;
      *(_WORD *)v267 = 2080;
      *(_QWORD *)&v267[2] = v169;
      v217 = MEMORY[0x1E0C81028];
      v218 = "VCPDec %p (%dx%d, %s): Decoder failed to create stitched pixel buffer for subframe decoding!\n";
      v219 = 34;
      goto LABEL_310;
    }
LABEL_308:
    v169 = "HEVC";
    goto LABEL_309;
  }
LABEL_188:
  v133 = *((_QWORD *)a2 + 15);
  if (v133)
    (*(void (**)(uint64_t))(*(_QWORD *)v133 + 8))(v133);
  *((_QWORD *)a2 + 15) = 0;
  sub_1B67705C8((const void **)a2 + 19);
  return MEMORY[0x1BCC9814C](a2, 0x10A0C40B5D84229);
}

uint64_t VCPDecompressionSessionSetProperty(uint64_t a1, CFStringRef theString1, const void *a3)
{
  uint64_t result;
  CFTypeID v7;
  BOOL v8;
  CFTypeID v9;
  uint8_t v10[16];

  if (a1)
  {
    if (CFStringCompare(theString1, CFSTR("FaceZoom"), 0))
    {
      if (CFStringCompare(theString1, CFSTR("MLEnhance"), 0))
      {
        return VTDecompressionSessionSetProperty();
      }
      else
      {
        v9 = CFGetTypeID(a3);
        if (v9 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)a3))
        {
          return sub_1B6797138(a1);
        }
        else
        {
          sub_1B67977D8((_DWORD *)a1);
          return 0;
        }
      }
    }
    else
    {
      v7 = CFGetTypeID(a3);
      v8 = v7 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)a3) != 0;
      result = 0;
      *(_BYTE *)(a1 + 93) = v8;
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v10 = 0;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDecompressionSessionSetProperty: vcpSession is NULL", v10, 2u);
    }
    return 4294954394;
  }
  return result;
}

uint64_t sub_1B6797138(uint64_t a1)
{
  _DWORD *v2;
  char *v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  const char *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  const char *v15;
  int v16;
  const __CFDictionary *PixelBufferAttributes;
  const __CFDictionary *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  int v22;
  int v23;
  int v24;
  const char *v25;
  int v26;
  int v28;
  int v29;
  int v30;
  const char *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  const char *v37;
  int v38;
  NSObject *v39;
  const char *v40;
  uint32_t v41;
  int v42;
  int v43;
  int v44;
  uint8_t buf[4];
  uint64_t v46;
  __int16 v47;
  int v48;
  __int16 v49;
  int v50;
  __int16 v51;
  const char *v52;
  __int16 v53;
  int v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v2 = *(_DWORD **)(a1 + 2288);
  if (v2[10] == 1 && !(*(unsigned int (**)(_DWORD *))(*(_QWORD *)v2 + 120))(v2))
    return 4294954386;
  if (qword_1EF1385E8 != -1)
    dispatch_once(&qword_1EF1385E8, &unk_1E6A16EB8);
  if (!byte_1EF1385E0)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_14;
    v29 = *(_DWORD *)(a1 + 112);
    v28 = *(_DWORD *)(a1 + 116);
    v30 = *(_DWORD *)(a1 + 24);
    v31 = "H.264";
    if (v30 > 1718908519)
    {
      if (v30 == 1752589105)
        goto LABEL_60;
      v32 = 1718908520;
    }
    else
    {
      if (v30 == 1684632424)
        goto LABEL_60;
      v32 = 1685481521;
    }
    if (v30 != v32)
    {
LABEL_61:
      *(_DWORD *)buf = 134218754;
      v46 = a1;
      v47 = 1024;
      v48 = v29;
      v49 = 1024;
      v50 = v28;
      v51 = 2080;
      v52 = v31;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VCPDec %p (%dx%d, %s): Frame enhancer is only supported on ANE devices\n", buf, 0x22u);
      goto LABEL_14;
    }
LABEL_60:
    v31 = "HEVC";
    goto LABEL_61;
  }
  if (*(_QWORD *)(a1 + 2304))
  {
LABEL_14:
    v4 = 0;
    goto LABEL_15;
  }
  v3 = (char *)operator new(0x80uLL, MEMORY[0x1E0DE4E10]);
  if (!v3)
  {
    *(_QWORD *)(a1 + 2304) = 0;
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v4 = 4294967188;
      goto LABEL_15;
    }
    v35 = *(_DWORD *)(a1 + 112);
    v34 = *(_DWORD *)(a1 + 116);
    v36 = *(_DWORD *)(a1 + 24);
    v37 = "H.264";
    if (v36 > 1718908519)
    {
      if (v36 == 1752589105)
        goto LABEL_73;
      v38 = 1718908520;
    }
    else
    {
      if (v36 == 1684632424)
        goto LABEL_73;
      v38 = 1685481521;
    }
    if (v36 != v38)
    {
LABEL_74:
      *(_DWORD *)buf = 134219010;
      v46 = a1;
      v47 = 1024;
      v48 = v35;
      v49 = 1024;
      v50 = v34;
      v51 = 2080;
      v52 = v37;
      v53 = 1024;
      v4 = 4294967188;
      v54 = -108;
      v39 = MEMORY[0x1E0C81028];
      v40 = "VCPDec %p (%dx%d, %s): Decoder failed to create the frame enhancer, err = %d\n";
      v41 = 40;
      goto LABEL_75;
    }
LABEL_73:
    v37 = "HEVC";
    goto LABEL_74;
  }
  *((_QWORD *)v3 + 3) = 0;
  *((_DWORD *)v3 + 8) = 0;
  *(_QWORD *)v3 = 0;
  *((_QWORD *)v3 + 1) = 0;
  v3[16] = 0;
  *((_QWORD *)v3 + 5) = 0;
  *((_QWORD *)v3 + 6) = 850045863;
  *(_OWORD *)(v3 + 56) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_OWORD *)(v3 + 88) = 0u;
  *(_OWORD *)(v3 + 104) = 0u;
  *(_QWORD *)(v3 + 117) = 0;
  *(_QWORD *)(a1 + 2304) = v3;
  v43 = 0;
  v44 = 875704438;
  v42 = 0;
  v4 = VTDecompressionSessionCopyProperty();
  if (!(_DWORD)v4)
  {
    PixelBufferAttributes = CVPixelBufferPoolGetPixelBufferAttributes(0);
    if (PixelBufferAttributes)
    {
      v18 = PixelBufferAttributes;
      v19 = (const void *)*MEMORY[0x1E0CA9040];
      if (CFDictionaryContainsKey(PixelBufferAttributes, (const void *)*MEMORY[0x1E0CA9040]))
        sub_1B6790B00(v18, v19, &v44);
      v20 = (const void *)*MEMORY[0x1E0CA90E0];
      if (CFDictionaryContainsKey(v18, (const void *)*MEMORY[0x1E0CA90E0]))
        sub_1B6790B00(v18, v20, &v43);
      v21 = (const void *)*MEMORY[0x1E0CA8FD8];
      if (CFDictionaryContainsKey(v18, (const void *)*MEMORY[0x1E0CA8FD8]))
        sub_1B6790B00(v18, v21, &v42);
    }
    if (v43 && v42 && !sub_1B6770628(*(_QWORD *)(a1 + 2304), (int *)(a1 + 2296), v43, v42, v44)
      || !os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_15;
    }
    v23 = *(_DWORD *)(a1 + 112);
    v22 = *(_DWORD *)(a1 + 116);
    v24 = *(_DWORD *)(a1 + 24);
    v25 = "H.264";
    if (v24 > 1718908519)
    {
      if (v24 == 1752589105)
        goto LABEL_55;
      v26 = 1718908520;
    }
    else
    {
      if (v24 == 1684632424)
        goto LABEL_55;
      v26 = 1685481521;
    }
    if (v24 != v26)
    {
LABEL_56:
      v33 = *(_DWORD *)(a1 + 2296);
      *(_DWORD *)buf = 134219010;
      v46 = a1;
      v47 = 1024;
      v48 = v23;
      v49 = 1024;
      v50 = v22;
      v51 = 2080;
      v52 = v25;
      v53 = 1024;
      v54 = v33;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder failed to initialize the frame enhancer with mode %d!\n", buf, 0x28u);
      goto LABEL_15;
    }
LABEL_55:
    v25 = "HEVC";
    goto LABEL_56;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v6 = *(_DWORD *)(a1 + 112);
    v5 = *(_DWORD *)(a1 + 116);
    v7 = *(_DWORD *)(a1 + 24);
    v8 = "H.264";
    if (v7 > 1718908519)
    {
      if (v7 == 1752589105)
        goto LABEL_68;
      v9 = 1718908520;
    }
    else
    {
      if (v7 == 1684632424)
        goto LABEL_68;
      v9 = 1685481521;
    }
    if (v7 != v9)
    {
LABEL_69:
      *(_DWORD *)buf = 134218754;
      v46 = a1;
      v47 = 1024;
      v48 = v6;
      v49 = 1024;
      v50 = v5;
      v51 = 2080;
      v52 = v8;
      v39 = MEMORY[0x1E0C81028];
      v40 = "VCPDec %p (%dx%d, %s): Failed to copy decoder pixel buffer pool\n";
      v41 = 34;
LABEL_75:
      _os_log_error_impl(&dword_1B676B000, v39, OS_LOG_TYPE_ERROR, v40, buf, v41);
      goto LABEL_15;
    }
LABEL_68:
    v8 = "HEVC";
    goto LABEL_69;
  }
LABEL_15:
  v10 = *(_QWORD *)(a1 + 2304);
  if (!v10 || !*(_BYTE *)(v10 + 16))
    sub_1B67977D8((_DWORD *)a1);
  if (!(_DWORD)v4)
  {
    v11 = *(_QWORD *)(a1 + 2304);
    if (v11 && *(_BYTE *)(v11 + 16))
    {
      *(_DWORD *)(a1 + 2296) |= 1u;
      v4 = 0;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        v13 = *(_DWORD *)(a1 + 112);
        v12 = *(_DWORD *)(a1 + 116);
        v14 = *(_DWORD *)(a1 + 24);
        v15 = "H.264";
        if (v14 > 1718908519)
        {
          if (v14 == 1752589105)
            goto LABEL_46;
          v16 = 1718908520;
        }
        else
        {
          if (v14 == 1684632424)
            goto LABEL_46;
          v16 = 1685481521;
        }
        if (v14 != v16)
        {
LABEL_47:
          *(_DWORD *)buf = 134218754;
          v46 = a1;
          v47 = 1024;
          v48 = v13;
          v49 = 1024;
          v50 = v12;
          v51 = 2080;
          v52 = v15;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Frame enhancer is enabled\n", buf, 0x22u);
          return 0;
        }
LABEL_46:
        v15 = "HEVC";
        goto LABEL_47;
      }
    }
    else
    {
      sub_1B67977D8((_DWORD *)a1);
      return 4294954394;
    }
  }
  return v4;
}

void sub_1B67977D8(_DWORD *a1)
{
  int v2;
  int v3;
  int v4;
  const char *v5;
  BOOL v6;
  int v7;
  int v9;
  _DWORD *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  __int16 v15;
  const char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  a1[574] &= ~1u;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v3 = a1[28];
    v2 = a1[29];
    v4 = a1[6];
    v5 = "H.264";
    if (v4 > 1718908519)
    {
      v6 = v4 == 1752589105;
      v7 = 1718908520;
    }
    else
    {
      v6 = v4 == 1684632424;
      v7 = 1685481521;
    }
    if (v6 || v4 == v7)
      v5 = "HEVC";
    v9 = 134218754;
    v10 = a1;
    v11 = 1024;
    v12 = v3;
    v13 = 1024;
    v14 = v2;
    v15 = 2080;
    v16 = v5;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Frame enhancer is disabled\n", (uint8_t *)&v9, 0x22u);
  }
}

uint64_t sub_1B67978FC(uint64_t a1, _DWORD *a2, __CVBuffer **a3)
{
  unsigned __int8 v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int16 *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned __int8 *v14;
  int v15;
  int v16;
  unint64_t v17;
  uint64_t result;
  uint64_t v19;
  __CVBuffer *v20;
  uint64_t v21;
  uint64_t v22;
  __int16 *v23;
  int v24;
  int v25;
  int v26;
  const char *v27;
  int v28;
  int BytesPerRowOfPlane;
  const unsigned __int8 *BaseAddressOfPlane;
  uint64_t v31;
  float *v32;
  uint64_t v33;
  vDSP_Length v34;
  int v35;
  const unsigned __int8 *v36;
  float *v37;
  int v38;
  int v39;
  const unsigned __int8 *v40;
  const unsigned __int8 *v41;
  float *v42;
  float *__C;
  int v44;
  vDSP_Length __N;
  __CVBuffer *pixelBuffer;
  uint64_t v47;
  uint64_t v48;
  float *__A;
  uint64_t v50;
  std::mutex *v51;
  float v52;
  float __B;
  _BYTE pixelBufferOut[12];
  __int16 v55;
  int v56;
  __int16 v57;
  int v58;
  __int16 v59;
  const char *v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 2296) & 0xC) == 0)
    return 0;
  v7 = *(_QWORD *)(a1 + 2304);
  v8 = *(unsigned int *)(v7 + 120);
  if ((int)v8 < 1)
    goto LABEL_10;
  v9 = 0;
  v10 = (__int16 *)&qword_1EF1386C0 + 2;
  while (a2[24] > *(v10 - 1) && a2[25] > *v10)
  {
    ++v9;
    v10 += 3;
    if (v8 == v9)
      goto LABEL_10;
  }
  if ((_DWORD)v9 == 1 || (*(_DWORD *)(v7 + 32) & 8) == 0)
  {
    v12 = (unsigned __int16)*(v10 - 1);
    v14 = (unsigned __int8 *)&qword_1EF1386C0 + 6 * v9;
    v13 = *v14;
    v3 = v14[1];
    v11 = *((unsigned __int16 *)v14 + 2);
  }
  else
  {
LABEL_10:
    v11 = 0;
    v12 = 0;
    v13 = 0;
  }
  v15 = (_DWORD)v12 << 16;
  v16 = (__int16)v12;
  v17 = ((v12 << 16) | (unint64_t)(v11 << 32)) >> 16;
  result = sub_1B6797F28(a1, a2, a3, (__int16)v12, (int)v17 >> 16);
  if ((_DWORD)result)
    return 4294954385;
  if ((v13 & 0xFFFF00FF | (v3 << 8) | v15) >= 0x10000 && v17 >= 0x10000)
  {
    *(_BYTE *)(a1 + 2344) = 0;
    *(_QWORD *)(a1 + 2312) = 0;
    sub_1B67ED940(a1 + 2312);
    v19 = *(_QWORD *)(a1 + 2304);
    v20 = *a3;
    *(_QWORD *)pixelBufferOut = 0;
    v51 = (std::mutex *)(v19 + 48);
    std::mutex::lock((std::mutex *)(v19 + 48));
    if (!*(_BYTE *)(v19 + 16) || !*(_QWORD *)v19)
      goto LABEL_27;
    v21 = *(unsigned int *)(v19 + 120);
    if ((int)v21 >= 1)
    {
      v22 = 0;
      v23 = (__int16 *)&qword_1EF1386C0 + 2;
      while (v16 != *(v23 - 1) || (int)v17 >> 16 != *v23)
      {
        ++v22;
        v23 += 3;
        if (v21 == v22)
          goto LABEL_25;
      }
      *(_QWORD *)(v19 + 8) = *(_QWORD *)v19 + 616 * v22;
    }
LABEL_25:
    if (!*(_QWORD *)(v19 + 8)
      || CVPixelBufferPoolCreatePixelBuffer(0, *(CVPixelBufferPoolRef *)(v19 + 24), (CVPixelBufferRef *)pixelBufferOut))
    {
      goto LABEL_27;
    }
    if (*(_BYTE *)(v19 + 124))
      goto LABEL_61;
    pixelBuffer = v20;
    if (!CVPixelBufferLockBaseAddress(v20, 1uLL))
    {
      BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v20, 0);
      BaseAddressOfPlane = (const unsigned __int8 *)CVPixelBufferGetBaseAddressOfPlane(v20, 0);
      v31 = *(_QWORD *)(v19 + 8);
      v32 = *(float **)(v31 + 40);
      v33 = *(_QWORD *)(v31 + 120);
      v34 = v33;
      v35 = *(_DWORD *)(v31 + 128);
      __B = 0.0039216;
      v52 = -0.5;
      v50 = 4 * v33;
      __C = v32;
      v44 = v35 * v33;
      __N = (2 * v35 * v33);
      if (v35)
      {
        v36 = BaseAddressOfPlane;
        v47 = 2 * BytesPerRowOfPlane;
        v48 = BytesPerRowOfPlane;
        v37 = v32;
        v38 = v35;
        do
        {
          vDSP_vfltu8(v36, 2, v37, 1, v34);
          vDSP_vfltu8(v36 + 1, 2, &v37[v44], 1, v34);
          vDSP_vfltu8(&v36[v48], 2, &v37[(int)__N], 1, v34);
          vDSP_vfltu8(&v36[v48 + 1], 2, &v37[3 * v44], 1, v34);
          v36 += v47;
          v37 = (float *)((char *)v37 + v50);
          --v38;
        }
        while (v38);
      }
      vDSP_vsmul(__C, 1, &__B, __C, 1, (4 * v44));
      v39 = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 1uLL);
      v40 = (const unsigned __int8 *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 1uLL);
      __A = &__C[4 * v44];
      if (v35)
      {
        v41 = v40;
        v42 = &__C[4 * v44];
        do
        {
          vDSP_vfltu8(v41, 2, v42, 1, v34);
          vDSP_vfltu8(v41 + 1, 2, &v42[v44], 1, v34);
          v41 += v39;
          v42 = (float *)((char *)v42 + v50);
          --v35;
        }
        while (v35);
      }
      vDSP_vsmul(__A, 1, &__B, __A, 1, __N);
      vDSP_vsadd(__A, 1, &v52, __A, 1, __N);
      v20 = pixelBuffer;
      if (!CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL))
      {
LABEL_61:
        if (*(_BYTE *)(*(_QWORD *)(v19 + 8) + 608)
          && (espresso_network_bind_direct_cvpixelbuffer()
           || espresso_network_bind_direct_cvpixelbuffer())
          || espresso_plan_execute_sync())
        {
LABEL_27:
          CVPixelBufferRelease(*(CVPixelBufferRef *)pixelBufferOut);
          goto LABEL_28;
        }
        if (*(_BYTE *)(v19 + 124) || !sub_1B6770D9C(v19, *(CVPixelBufferRef *)pixelBufferOut))
        {
          CVBufferPropagateAttachments(v20, *(CVBufferRef *)pixelBufferOut);
          *a3 = *(__CVBuffer **)pixelBufferOut;
          CVPixelBufferRelease(v20);
          std::mutex::unlock(v51);
          *((_BYTE *)a2 + 112) = 1;
          goto LABEL_37;
        }
      }
    }
LABEL_28:
    std::mutex::unlock(v51);
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
LABEL_37:
      sub_1B67ED98C(a1 + 2312);
      result = *(_QWORD *)(a1 + 2224);
      if (!result)
        return result;
      sub_1B6872E44(result, (uint64_t *)"ml_enhanced_frames", 1.0);
      sub_1B6872E44(*(_QWORD *)(a1 + 2224), (uint64_t *)"ml_enhance_time", *(double *)(a1 + 2312));
      return 0;
    }
    v25 = *(_DWORD *)(a1 + 112);
    v24 = *(_DWORD *)(a1 + 116);
    v26 = *(_DWORD *)(a1 + 24);
    v27 = "H.264";
    if (v26 > 1718908519)
    {
      if (v26 == 1752589105)
        goto LABEL_35;
      v28 = 1718908520;
    }
    else
    {
      if (v26 == 1684632424)
        goto LABEL_35;
      v28 = 1685481521;
    }
    if (v26 != v28)
    {
LABEL_36:
      *(_DWORD *)pixelBufferOut = 134218754;
      *(_QWORD *)&pixelBufferOut[4] = a1;
      v55 = 1024;
      v56 = v25;
      v57 = 1024;
      v58 = v24;
      v59 = 2080;
      v60 = v27;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder failed to enhance the frame!\n", pixelBufferOut, 0x22u);
      goto LABEL_37;
    }
LABEL_35:
    v27 = "HEVC";
    goto LABEL_36;
  }
  return result;
}

void sub_1B6797EF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::mutex *a21)
{
  std::mutex::unlock(a21);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6797F28(uint64_t a1, _DWORD *a2, __CVBuffer **a3, int a4, int a5)
{
  __CVBuffer *v10;
  int v11;
  int v12;
  int Width;
  int Height;
  int v15;
  int v16;
  __int16 v17;
  CFDictionaryRef DictionaryRepresentation;
  int v19;
  double v20;
  int v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  CFDictionaryRef v25;
  const void *v26;
  int v27;
  int v28;
  int v29;
  const char *v30;
  int v31;
  int v32;
  int v33;
  int v34;
  const char *v35;
  int v36;
  int v37;
  int v38;
  int v39;
  const char *v40;
  int v41;
  int v43;
  int v44;
  int v45;
  const char *v46;
  int v47;
  int v48;
  int v49;
  int v50;
  const char *v51;
  int v52;
  CVPixelBufferRef pixelBufferOut;
  uint8_t buf[4];
  uint64_t v55;
  __int16 v56;
  int v57;
  __int16 v58;
  int v59;
  __int16 v60;
  const char *v61;
  uint64_t v62;
  CGRect v63;

  v62 = *MEMORY[0x1E0C80C00];
  v10 = *a3;
  pixelBufferOut = 0;
  v12 = *(_DWORD *)(a1 + 112);
  v11 = *(_DWORD *)(a1 + 116);
  Width = CVPixelBufferGetWidth(v10);
  Height = CVPixelBufferGetHeight(v10);
  v15 = Height;
  v16 = a2[24];
  if (v16 == v12 && a2[25] == v11 || v16 == Width && a2[25] == Height)
    return 0;
  v17 = CVPixelBufferPoolCreatePixelBuffer((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CVPixelBufferPoolRef *)(a1 + 2240), &pixelBufferOut);
  if (v17)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
LABEL_8:
      CVPixelBufferRelease(pixelBufferOut);
      return v17;
    }
    v33 = *(_DWORD *)(a1 + 112);
    v32 = *(_DWORD *)(a1 + 116);
    v34 = *(_DWORD *)(a1 + 24);
    v35 = "H.264";
    if (v34 > 1718908519)
    {
      if (v34 == 1752589105)
        goto LABEL_46;
      v36 = 1718908520;
    }
    else
    {
      if (v34 == 1684632424)
        goto LABEL_46;
      v36 = 1685481521;
    }
    if (v34 != v36)
    {
LABEL_47:
      *(_DWORD *)buf = 134218754;
      v55 = a1;
      v56 = 1024;
      v57 = v33;
      v58 = 1024;
      v59 = v32;
      v60 = 2080;
      v61 = v35;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VCPDec %p (%dx%d, %s): Decoder failed to create dst buffer for up scaling!\n", buf, 0x22u);
      goto LABEL_8;
    }
LABEL_46:
    v35 = "HEVC";
    goto LABEL_47;
  }
  v63.origin.x = (double)(int)a2[26];
  v63.origin.y = (double)(int)a2[27];
  v63.size.width = (double)(int)a2[24];
  v63.size.height = (double)(int)a2[25];
  DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v63);
  if (Width >= a4)
    v19 = a4;
  else
    v19 = Width;
  if (a4 <= 0)
    v19 = Width;
  v20 = (double)v19;
  if (v15 >= a5)
    v21 = a5;
  else
    v21 = v15;
  if (a5 <= 0)
    v21 = v15;
  v22 = (double)v21;
  v23 = 0;
  v24 = 0;
  v25 = CGRectCreateDictionaryRepresentation(*(CGRect *)(&v20 - 2));
  v26 = *(const void **)(a1 + 96);
  if (v26 && DictionaryRepresentation)
  {
    if (!VTSessionSetProperty(v26, CFSTR("SourceCropRectangle"), DictionaryRepresentation)
      || !os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
LABEL_37:
      if (!v25
        || !VTSessionSetProperty(*(VTSessionRef *)(a1 + 96), CFSTR("DestinationRectangle"), v25)
        || !os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
LABEL_53:
        v17 = VTPixelTransferSessionTransferImage(*(VTPixelTransferSessionRef *)(a1 + 96), v10, pixelBufferOut);
        if (!v17)
        {
          CVBufferPropagateAttachments(v10, pixelBufferOut);
          *a3 = pixelBufferOut;
          goto LABEL_57;
        }
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
LABEL_55:
          v10 = pixelBufferOut;
LABEL_57:
          CVPixelBufferRelease(v10);
          goto LABEL_58;
        }
        v49 = *(_DWORD *)(a1 + 112);
        v48 = *(_DWORD *)(a1 + 116);
        v50 = *(_DWORD *)(a1 + 24);
        v51 = "H.264";
        if (v50 > 1718908519)
        {
          if (v50 == 1752589105)
            goto LABEL_76;
          v52 = 1718908520;
        }
        else
        {
          if (v50 == 1684632424)
            goto LABEL_76;
          v52 = 1685481521;
        }
        if (v50 != v52)
        {
LABEL_77:
          *(_DWORD *)buf = 134218754;
          v55 = a1;
          v56 = 1024;
          v57 = v49;
          v58 = 1024;
          v59 = v48;
          v60 = 2080;
          v61 = v51;
          _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VCPDec %p (%dx%d, %s): Decoder failed to do up scaling!\n", buf, 0x22u);
          goto LABEL_55;
        }
LABEL_76:
        v51 = "HEVC";
        goto LABEL_77;
      }
      v38 = *(_DWORD *)(a1 + 112);
      v37 = *(_DWORD *)(a1 + 116);
      v39 = *(_DWORD *)(a1 + 24);
      v40 = "H.264";
      if (v39 > 1718908519)
      {
        if (v39 == 1752589105)
          goto LABEL_51;
        v41 = 1718908520;
      }
      else
      {
        if (v39 == 1684632424)
          goto LABEL_51;
        v41 = 1685481521;
      }
      if (v39 != v41)
      {
LABEL_52:
        *(_DWORD *)buf = 134218754;
        v55 = a1;
        v56 = 1024;
        v57 = v38;
        v58 = 1024;
        v59 = v37;
        v60 = 2080;
        v61 = v40;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder failed to set DestinationRectangle for up_scaling_session\n", buf, 0x22u);
        goto LABEL_53;
      }
LABEL_51:
      v40 = "HEVC";
      goto LABEL_52;
    }
    v28 = *(_DWORD *)(a1 + 112);
    v27 = *(_DWORD *)(a1 + 116);
    v29 = *(_DWORD *)(a1 + 24);
    v30 = "H.264";
    if (v29 > 1718908519)
    {
      if (v29 == 1752589105)
        goto LABEL_35;
      v31 = 1718908520;
    }
    else
    {
      if (v29 == 1684632424)
        goto LABEL_35;
      v31 = 1685481521;
    }
    if (v29 != v31)
    {
LABEL_36:
      *(_DWORD *)buf = 134218754;
      v55 = a1;
      v56 = 1024;
      v57 = v28;
      v58 = 1024;
      v59 = v27;
      v60 = 2080;
      v61 = v30;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder failed to set SourceCropRectangle for up_scaling_session\n", buf, 0x22u);
      goto LABEL_37;
    }
LABEL_35:
    v30 = "HEVC";
    goto LABEL_36;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v44 = *(_DWORD *)(a1 + 112);
    v43 = *(_DWORD *)(a1 + 116);
    v45 = *(_DWORD *)(a1 + 24);
    v46 = "H.264";
    if (v45 > 1718908519)
    {
      if (v45 == 1752589105)
        goto LABEL_71;
      v47 = 1718908520;
    }
    else
    {
      if (v45 == 1684632424)
        goto LABEL_71;
      v47 = 1685481521;
    }
    if (v45 != v47)
    {
LABEL_72:
      *(_DWORD *)buf = 134218754;
      v55 = a1;
      v56 = 1024;
      v57 = v44;
      v58 = 1024;
      v59 = v43;
      v60 = 2080;
      v61 = v46;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VCPDec %p (%dx%d, %s): Decoder failed to do up scaling!\n", buf, 0x22u);
      goto LABEL_27;
    }
LABEL_71:
    v46 = "HEVC";
    goto LABEL_72;
  }
LABEL_27:
  CVPixelBufferRelease(pixelBufferOut);
  v17 = -12911;
  if (DictionaryRepresentation)
LABEL_58:
    CFRelease(DictionaryRepresentation);
  if (v25)
    CFRelease(v25);
  return v17;
}

uint64_t sub_1B6798548(uint64_t a1)
{
  uint64_t i;

  sub_1B6772C88(a1 + 4624);
  sub_1B6772C88(a1 + 4608);
  for (i = 4592; i != 496; i -= 16)
    sub_1B6772C88(a1 + i);
  do
  {
    sub_1B6772C88(a1 + i);
    i -= 16;
  }
  while (i != -16);
  return a1;
}

uint64_t sub_1B67985AC(const void *a1, size_t blockLength, uint64_t a3, CFTypeRef *a4)
{
  NSObject *v8;
  const char *v9;
  uint32_t v10;
  int CFTypeFromSerializedAtomDataBlockBuffer;
  int v12;
  CMBlockBufferRef destinationBuffer;
  uint8_t buf[4];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  destinationBuffer = 0;
  if (!blockLength)
  {
    a3 = 0;
    *a4 = 0;
    return a3;
  }
  if (CMBlockBufferCreateWithMemoryBlock(0, 0, blockLength, 0, 0, 0, blockLength, 1u, &destinationBuffer))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v8 = MEMORY[0x1E0C81028];
      v9 = "CFPropertyList_DeserializeAtomData failed at BlockBufferCreateWithMemoryBlock";
LABEL_9:
      v10 = 2;
LABEL_10:
      _os_log_error_impl(&dword_1B676B000, v8, OS_LOG_TYPE_ERROR, v9, buf, v10);
      goto LABEL_13;
    }
    goto LABEL_13;
  }
  if (CMBlockBufferReplaceDataBytes(a1, destinationBuffer, 0, blockLength))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v8 = MEMORY[0x1E0C81028];
      v9 = "CFPropertyList_DeserializeAtomData failed at BlockBufferReplaceDataBytes";
      goto LABEL_9;
    }
LABEL_13:
    if (*a4)
    {
      CFRelease(a4);
      *a4 = 0;
    }
    a3 = 4294967246;
    goto LABEL_16;
  }
  CFTypeFromSerializedAtomDataBlockBuffer = FigRemote_CreateCFTypeFromSerializedAtomDataBlockBuffer();
  if (CFTypeFromSerializedAtomDataBlockBuffer)
  {
    v12 = CFTypeFromSerializedAtomDataBlockBuffer;
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_13;
    *(_DWORD *)buf = 67109120;
    v16 = v12;
    v8 = MEMORY[0x1E0C81028];
    v9 = "CFPropertyList_DeserializeAtomData failed at TypeFromSerializedAtomDataBlockBuffer (%d)";
    goto LABEL_25;
  }
  if (a3)
  {
    if (CFGetTypeID(*a4) != a3)
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        goto LABEL_13;
      *(_DWORD *)buf = 67109120;
      v16 = 0;
      v8 = MEMORY[0x1E0C81028];
      v9 = "CFPropertyList DeserializeAtomData wrong type ID(%d)";
LABEL_25:
      v10 = 8;
      goto LABEL_10;
    }
    a3 = 0;
  }
LABEL_16:
  if (destinationBuffer)
    CFRelease(destinationBuffer);
  return a3;
}

uint64_t sub_1B67987D8(UInt8 *bytes, CFIndex length, CFTypeID a3, CFTypeRef *a4)
{
  CFDataRef v6;
  CFPropertyListRef v7;
  CFStringRef v8;
  uint64_t result;
  CFTypeID v10;
  CFStringRef v11;
  const char *CStringPtr;
  const __CFString *v13;
  const char *v14;
  const char *v15;
  CFStringRef v16;
  CFErrorRef error;
  CFDataRef v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  const char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (length)
  {
    v6 = CFDataCreateWithBytesNoCopy(0, bytes, length, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    error = 0;
    v18 = v6;
    v7 = CFPropertyListCreateWithData(0, v6, 0, 0, &error);
    *a4 = v7;
    if (error)
    {
      v8 = CFCopyTypeIDDescription(a3);
      v16 = v8;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        CStringPtr = CFStringGetCStringPtr(v8, 0x8000100u);
        v13 = CFErrorCopyFailureReason(error);
        v14 = CFStringGetCStringPtr(v13, 0x8000100u);
        *(_DWORD *)buf = 136315394;
        v20 = CStringPtr;
        v21 = 2080;
        v22 = v14;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Failed to deserialize %s (%s)", buf, 0x16u);
      }
LABEL_5:
      sub_1B6770508((const void **)&v16);
      sub_1B6770538((const void **)&error);
      sub_1B67704D8((const void **)&v18);
      return 4294967246;
    }
    if (a3 && CFGetTypeID(v7) != a3)
    {
      v10 = CFGetTypeID(*a4);
      v11 = CFCopyTypeIDDescription(v10);
      v16 = v11;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v15 = CFStringGetCStringPtr(v11, 0x8000100u);
        *(_DWORD *)buf = 136315138;
        v20 = v15;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Deserialized unexpected type (%s)", buf, 0xCu);
      }
      CFRelease(*a4);
      *a4 = 0;
      goto LABEL_5;
    }
    sub_1B6770538((const void **)&error);
    sub_1B67704D8((const void **)&v18);
    return 0;
  }
  else
  {
    result = 0;
    *a4 = 0;
  }
  return result;
}

void sub_1B67989DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v3;
  va_list va;
  const void *v5;
  va_list va1;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v5 = va_arg(va2, const void *);
  sub_1B6770508((const void **)va);
  sub_1B6770538((const void **)va1);
  sub_1B67704D8((const void **)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_1B6798A18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  opaqueCMSampleBuffer *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  opaqueCMSampleBuffer *v11;
  uint8_t *v12;
  OpaqueCMBlockBuffer *DataBuffer;
  size_t DataLength;
  size_t v15;
  uint64_t v16;
  size_t v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  int v22;
  int v23;
  unsigned int v24;
  char v25;
  NSObject *v26;
  unsigned int v27;
  int v28;
  unsigned int v29;
  uint8_t *v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t *v34;
  BOOL v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  unsigned int *v42;
  unint64_t v43;
  unsigned int v44;
  NSObject *v45;
  const char *v46;
  uint32_t v47;
  int v48;
  unsigned int v49;
  int v50;
  unint64_t v51;
  char v52;
  unsigned int *v53;
  unsigned int v54;
  unsigned int v55;
  int v56;
  unint64_t v57;
  unsigned int *v58;
  unsigned int v59;
  int v60;
  unint64_t v61;
  char v62;
  unsigned int *v63;
  unsigned int v64;
  int v65;
  unsigned int v66;
  unint64_t v67;
  char v68;
  unsigned int *v69;
  unsigned int v70;
  int v71;
  int v72;
  uint64_t *v73;
  int v74;
  int v75;
  int v76;
  unint64_t v77;
  char v78;
  unsigned int *v79;
  unsigned int v80;
  unint64_t v81;
  unsigned int *v82;
  BOOL v83;
  unsigned int v84;
  int v85;
  int v86;
  int v87;
  unint64_t v88;
  unsigned int *v89;
  BOOL v90;
  unsigned int v91;
  unsigned int i;
  unsigned int v93;
  unsigned int v94;
  int *v95;
  int v96;
  int v98;
  unint64_t v99;
  unsigned int *v100;
  BOOL v101;
  unsigned int v102;
  int v103;
  unsigned int v104;
  int v105;
  unint64_t v106;
  unsigned int *v107;
  BOOL v108;
  unsigned int v109;
  unsigned int v110;
  int v111;
  int v112;
  int v113;
  unint64_t v114;
  char v115;
  unsigned int *v116;
  BOOL v117;
  unsigned int v118;
  char v119;
  uint64_t v120;
  char v121;
  unsigned int v122;
  int v123;
  int v124;
  int v125;
  unsigned int v126;
  int v127;
  unint64_t v128;
  unsigned int *v129;
  BOOL v130;
  unsigned int v131;
  uint64_t v132;
  unsigned int v133;
  int v134;
  int v135;
  int v136;
  unint64_t v137;
  char v138;
  unsigned int *v139;
  BOOL v140;
  unsigned int v141;
  char v142;
  uint64_t v143;
  char v144;
  unsigned int v145;
  int v146;
  int v147;
  unsigned int v148;
  unint64_t v149;
  char v150;
  unsigned int *v151;
  unsigned int v152;
  unsigned int j;
  unsigned int v154;
  unsigned int v155;
  int v156;
  uint8_t *v157;
  uint8_t *v158;
  uint8_t *v159;
  int v160;
  BOOL v161;
  unsigned int v162;
  NSObject *v163;
  const char *v164;
  int v165;
  unint64_t v166;
  char v167;
  unsigned int *v168;
  unsigned int v169;
  uint64_t k;
  unsigned int v171;
  unsigned int v172;
  int v174;
  char v175;
  NSObject *v176;
  std::__shared_weak_count *v178;
  unint64_t *p_shared_owners;
  unint64_t v180;
  std::__shared_weak_count *v181;
  unint64_t *v182;
  unint64_t v183;
  const opaqueCMFormatDescription *FormatDescription;
  const __CFDictionary *Extension;
  const __CFData *Value;
  const __CFData *v187;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v190;
  uint64_t v191;
  NSObject *v192;
  const char *v193;
  std::__shared_weak_count *v194;
  unint64_t *v195;
  unint64_t v196;
  std::__shared_weak_count *v197;
  unint64_t *v198;
  unint64_t v199;
  uint64_t m;
  uint64_t v202;
  int v203;
  int v204;
  int v205;
  int v206;
  int v207;
  int v208;
  int v209;
  int v210;
  unsigned int v211;
  uint64_t v212;
  uint64_t *v213;
  uint64_t *v214;
  uint64_t *v215;
  uint64_t *v216;
  uint8_t *v217;
  uint64_t v218;
  unint64_t v219;
  size_t v220;
  uint64_t v221;
  __int128 v222;
  int v223;
  char v224;
  _QWORD v225[3];
  char v226;
  char v227;
  uint64_t v228;
  uint64_t (*v229)(_QWORD *, uint64_t);
  uint64_t v230;
  unsigned int v231;
  uint8_t v232[16];
  __int128 v233;
  __int16 v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  __int16 v238;
  _DWORD v239[5];
  char v240;
  unsigned int v241;
  int v242;
  char v243;
  uint64_t v244;
  _QWORD v245[35];
  int v246;
  int v247;
  int v248;
  int v249;
  _BYTE v250[1824];
  void *v251[3];
  unsigned int *v252;
  unsigned int *v253;
  uint64_t v254;
  char *returnedPointerOut;
  int temporaryBlock;
  uint8_t v257[4616];
  std::__shared_weak_count *v258;
  std::__shared_weak_count *v259;
  char *v260;
  uint64_t v261;
  std::__shared_weak_count *v262;
  uint8_t buf[8];
  std::__shared_weak_count *v264;
  char v265[24];
  uint8_t v266[4];
  int v267;
  __int16 v268;
  int v269;
  uint64_t v270;

  v6 = (opaqueCMSampleBuffer *)MEMORY[0x1E0C80A78](a1, a2, a3, a4, a5, a6);
  v8 = v7;
  v10 = v9;
  v11 = v6;
  v270 = *MEMORY[0x1E0C80C00];
  v222 = 0uLL;
  v223 = -1;
  v224 = 0;
  v12 = *(uint8_t **)(v9 + 2360);
  DataBuffer = CMSampleBufferGetDataBuffer(v6);
  DataLength = CMBlockBufferGetDataLength(DataBuffer);
  v260 = 0;
  bzero(v257, 0x1220uLL);
  v221 = v8;
  if (v12)
    goto LABEL_2;
  FormatDescription = CMSampleBufferGetFormatDescription(v11);
  if (!FormatDescription)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_280;
    *(_WORD *)v232 = 0;
    v192 = MEMORY[0x1E0C81028];
    v193 = "Warning: VCPReadH264SliceHeader() parameter_sets_h264 = NULL and no videoFormatDescription in sample_buffer!";
LABEL_279:
    _os_log_error_impl(&dword_1B676B000, v192, OS_LOG_TYPE_ERROR, v193, v232, 2u);
    goto LABEL_280;
  }
  Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(FormatDescription, (CFStringRef)*MEMORY[0x1E0CA2240]);
  if (!Extension)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_280;
    *(_WORD *)v232 = 0;
    v192 = MEMORY[0x1E0C81028];
    v193 = "Warning: VCPReadH264SliceHeader() parameter_sets_h264 = NULL and no videoFormatDescription extensions in sample_buffer!";
    goto LABEL_279;
  }
  Value = (const __CFData *)CFDictionaryGetValue(Extension, CFSTR("avcC"));
  v187 = Value;
  if (!Value)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v232 = 0;
      v192 = MEMORY[0x1E0C81028];
      v193 = "Warning: VCPReadH264SliceHeader() parameter_sets_h264 = NULL and no avcC_data in sample_buffer!";
      goto LABEL_279;
    }
LABEL_280:
    v16 = 4294954394;
    goto LABEL_281;
  }
  BytePtr = CFDataGetBytePtr(Value);
  Length = CFDataGetLength(v187);
  v16 = sub_1B6892768((uint64_t)BytePtr, Length, 0, (uint64_t)v257, v190, v191);
  if ((_DWORD)v16)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v232 = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Warning: VCPReadH264SliceHeader() LRPConfigInfo_avcc parsing error!", v232, 2u);
    }
    goto LABEL_281;
  }
  v12 = v257;
LABEL_2:
  if (DataLength >= 5)
  {
    v219 = 0;
    v15 = 0;
    v16 = 0;
    v216 = (uint64_t *)(v12 + 4624);
    v215 = (uint64_t *)(v12 + 4632);
    v214 = (uint64_t *)(v12 + 4608);
    v213 = (uint64_t *)(v12 + 4616);
    v217 = v12;
    v17 = 4;
    v218 = v10;
    v220 = DataLength;
    while (1)
    {
      temporaryBlock = 0;
      returnedPointerOut = 0;
      CMBlockBufferAccessDataBytes(DataBuffer, v15, 4uLL, &temporaryBlock, &returnedPointerOut);
      v18 = bswap32(*(_DWORD *)returnedPointerOut);
      if (v18 >= 24)
        v19 = 24;
      else
        v19 = v18;
      v20 = v19;
      CMBlockBufferAccessDataBytes(DataBuffer, v17, v19, v265, &v260);
      v21 = v260;
      v22 = *v260;
      if (v22 < 0)
        goto LABEL_19;
      v23 = v22 & 0x1F;
      if ((v23 - 1) > 4)
        goto LABEL_19;
      v239[4] = 0;
      v240 = 0;
      v241 = 0;
      v243 = 0;
      *(_OWORD *)v232 = 0u;
      v233 = 0u;
      v234 = 0;
      v236 = 0;
      v237 = 0;
      v235 = 0;
      v238 = 0;
      memset(v239, 0, 13);
      v244 = 0;
      v245[0] = 0;
      *(_QWORD *)((char *)v245 + 7) = 0;
      v251[0] = 0;
      v251[1] = 0;
      v253 = 0;
      v254 = 0;
      v252 = 0;
      off_1EF137C48 = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_1B67AD840;
      if ((_DWORD)v20)
      {
        if ((*v260 & 0x80000000) == 0)
        {
          v24 = *v260;
          if (v20 > 1 || (v24 & 0x1E) == 0xA)
            break;
        }
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "failed to init nalu from buffer", buf, 2u);
      }
      v25 = 0;
      v16 = 4294954387;
LABEL_16:
      if (v251[0])
        free(v251[0]);
      if ((v25 & 1) == 0)
        goto LABEL_281;
LABEL_19:
      v15 = v17 + v18;
      v17 = v15 + 4;
      if (v15 + 4 >= DataLength)
        goto LABEL_281;
    }
    if (v219 >= 4)
    {
      if (dword_1EF137CD0 >= 3)
      {
        v26 = MEMORY[0x1E0C81028];
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1B676B000, v26, OS_LOG_TYPE_DEFAULT, "Warning: only 4 slices supported by VCPReadH264SliceHeader(), ignored the rest!", buf, 2u);
        }
      }
LABEL_261:
      v25 = 0;
      goto LABEL_16;
    }
    v224 = v23;
    *((_DWORD *)&v222 + v219) = v18 + 4;
    v27 = v24 >> 5;
    v28 = v24 & 0x1F;
    v225[2] = v21;
    v226 = v28;
    v227 = -1;
    v228 = v20;
    v229 = sub_1B67AD728;
    v230 = 0;
    v225[1] = 1;
    v225[0] = &off_1E6A14BF0;
    v231 = v27;
    *(_DWORD *)v232 = v27;
    *(_DWORD *)&v232[4] = v28;
    sub_1B67C8EF8(v251, v225);
    *(_QWORD *)buf = 0;
    v264 = 0;
    v261 = 0;
    v262 = 0;
    if (!v217)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v266 = 0;
        v45 = MEMORY[0x1E0C81028];
        v46 = "SliceHeaderH264::Parse() parameter_sets should not be NULL";
        v47 = 2;
LABEL_245:
        _os_log_error_impl(&dword_1B676B000, v45, OS_LOG_TYPE_ERROR, v46, v266, v47);
        goto LABEL_246;
      }
      goto LABEL_246;
    }
    *(_DWORD *)&v232[8] = sub_1B67C91C8((uint64_t)v251);
    LODWORD(v233) = sub_1B67C9140((uint64_t)v251);
    v29 = sub_1B67C9140((uint64_t)v251);
    DWORD1(v233) = v29;
    v30 = &v217[16 * v29];
    v31 = (uint64_t *)(v30 + 512);
    if (v29 > 0xFF)
      v31 = v216;
    v32 = (uint64_t *)(v30 + 520);
    if (v29 > 0xFF)
      v32 = v215;
    sub_1B67B665C(&v261, *v31, *v32);
    if (!v261)
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        goto LABEL_246;
      *(_DWORD *)v266 = 67109120;
      v267 = DWORD1(v233);
      v45 = MEMORY[0x1E0C81028];
      v46 = "SliceHeaderH264::Parse() pps with pic_parameter_set_id = %d is not available";
      goto LABEL_244;
    }
    v33 = *(unsigned int *)(v261 + 4);
    v34 = (uint64_t *)&v217[16 * v33];
    v35 = v33 > 0x1F;
    v36 = v214;
    if (!v35)
      v36 = v34;
    v37 = *v36;
    v38 = v34 + 1;
    if (v35)
      v38 = v213;
    sub_1B67B665C(buf, v37, *v38);
    v39 = *(_QWORD *)buf;
    if (!*(_QWORD *)buf)
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        goto LABEL_246;
      v48 = *(_DWORD *)(v261 + 4);
      *(_DWORD *)v266 = 67109120;
      v267 = v48;
      v45 = MEMORY[0x1E0C81028];
      v46 = "SliceHeaderH264::Parse() sps with seq_parameter_set_id = %d is not available";
      goto LABEL_244;
    }
    v40 = v254;
    v41 = HIDWORD(v254);
    v42 = v252;
    if (*(_BYTE *)(*(_QWORD *)buf + 19))
    {
      v43 = SHIDWORD(v254) + 2;
      v41 = v43 & 7;
      HIDWORD(v254) = v41;
      v42 = (unsigned int *)((char *)v252 + (v43 >> 3));
      v252 = v42;
      if (v42 >= v253)
      {
        if (v42 > v253)
          v42 = v253;
        v44 = v254;
      }
      else
      {
        v44 = bswap32(*v42);
      }
      v49 = v254 >> 30;
      v40 = v44 << v41;
      LODWORD(v254) = v44 << v41;
      DWORD2(v233) = v49;
    }
    v50 = *(_DWORD *)(*(_QWORD *)buf + 272);
    v51 = v41 + (uint64_t)(v50 + 4);
    v52 = v51 & 7;
    HIDWORD(v254) = v51 & 7;
    v53 = (unsigned int *)((char *)v42 + (v51 >> 3));
    v252 = v53;
    if (v53 >= v253)
    {
      v54 = v40;
      if (v53 > v253)
      {
        v252 = v253;
        v53 = v253;
        v54 = v40;
      }
    }
    else
    {
      v54 = bswap32(*v53);
    }
    v55 = v40 >> (28 - v50);
    v56 = v54 << v52;
    LODWORD(v254) = v54 << v52;
    HIDWORD(v233) = v55;
    if (!*(_BYTE *)(*(_QWORD *)buf + 1336))
    {
      v57 = (v51 & 7) + 1;
      HIDWORD(v254) = v57 & 7;
      v58 = (unsigned int *)((char *)v53 + (v57 >> 3));
      v252 = v58;
      if (v58 >= v253)
      {
        v59 = v54 << v52;
        if (v58 > v253)
        {
          v252 = v253;
          v58 = v253;
          v59 = v54 << v52;
        }
      }
      else
      {
        v59 = bswap32(*v58);
      }
      v60 = v59 << (v57 & 7);
      LODWORD(v254) = v60;
      LOBYTE(v234) = v56 < 0;
      if (v56 < 0)
      {
        v61 = (v57 & 7) + 1;
        v62 = v61 & 7;
        HIDWORD(v254) = v61 & 7;
        v63 = (unsigned int *)((char *)v58 + (v61 >> 3));
        v252 = v63;
        if (v63 >= v253)
        {
          if (v63 > v253)
            v252 = v253;
          v64 = v60;
        }
        else
        {
          v64 = bswap32(*v63);
        }
        LODWORD(v254) = v64 << v62;
        HIBYTE(v234) = v60 < 0;
      }
    }
    if (*(_DWORD *)&v232[4] == 5)
      LODWORD(v235) = sub_1B67C91C8((uint64_t)v251);
    if (*(_BYTE *)(v39 + 276) == 1)
    {
      if (!*(_BYTE *)(v39 + 284))
      {
        v71 = sub_1B67C91C8((uint64_t)v251);
        HIDWORD(v236) = (-((v71 + 1) & 1) ^ ((v71 + 1) >> 1)) + ((v71 + 1) & 1);
        if (*(_BYTE *)(v261 + 9))
        {
          if (!(_BYTE)v234)
          {
            v72 = sub_1B67C91C8((uint64_t)v251);
            v73 = &v237;
LABEL_82:
            *(_DWORD *)v73 = (-((v72 + 1) & 1) ^ ((v72 + 1) >> 1)) + ((v72 + 1) & 1);
          }
        }
      }
    }
    else if (!*(_BYTE *)(v39 + 276))
    {
      v65 = *(_DWORD *)(v39 + 280);
      v66 = v254;
      v67 = SHIDWORD(v254) + (uint64_t)(v65 + 4);
      v68 = v67 & 7;
      HIDWORD(v254) = v67 & 7;
      v69 = (unsigned int *)((char *)v252 + (v67 >> 3));
      v252 = v69;
      if (v69 >= v253)
      {
        if (v69 > v253)
          v252 = v253;
        v70 = v254;
      }
      else
      {
        v70 = bswap32(*v69);
      }
      LODWORD(v254) = v70 << v68;
      HIDWORD(v235) = v66 >> (28 - v65);
      if (*(_BYTE *)(v261 + 9) == 1 && !(_BYTE)v234)
      {
        v72 = sub_1B67C9140((uint64_t)v251);
        v73 = &v236;
        goto LABEL_82;
      }
    }
    v212 = v261;
    if (*(_BYTE *)(v261 + 86))
      HIDWORD(v237) = sub_1B67C9140((uint64_t)v251);
    v74 = v233;
    if (v233 > 8)
      goto LABEL_106;
    if (((1 << v233) & 0x129) != 0)
    {
      v75 = v254;
    }
    else
    {
      if (((1 << v233) & 0x42) == 0)
        goto LABEL_106;
      v76 = v254;
      v77 = SHIDWORD(v254) + 1;
      v78 = v77 & 7;
      HIDWORD(v254) = v77 & 7;
      v79 = (unsigned int *)((char *)v252 + (v77 >> 3));
      v252 = v79;
      if (v79 >= v253)
      {
        if (v79 > v253)
          v252 = v253;
        v80 = v254;
      }
      else
      {
        v80 = bswap32(*v79);
      }
      v75 = v80 << v78;
      LODWORD(v254) = v75;
      LOBYTE(v238) = v76 < 0;
      if (((1 << v233) & 0x16B) == 0)
        goto LABEL_106;
    }
    v81 = SHIDWORD(v254) + 1;
    HIDWORD(v254) = v81 & 7;
    v82 = (unsigned int *)((char *)v252 + (v81 >> 3));
    v252 = v82;
    v83 = v82 > v253;
    if (v82 >= v253)
    {
      v84 = v75;
      if (v83)
      {
        v252 = v253;
        v84 = v75;
      }
    }
    else
    {
      v84 = bswap32(*v82);
    }
    LODWORD(v254) = v84 << (v81 & 7);
    HIBYTE(v238) = v75 < 0;
    if (v75 < 0)
    {
      v239[0] = sub_1B67C9140((uint64_t)v251);
      v74 = v233;
      if ((_DWORD)v233 != 6 && (_DWORD)v233 != 1)
        goto LABEL_106;
      v85 = sub_1B67C9140((uint64_t)v251);
      v74 = v233;
    }
    else
    {
      v239[0] = *(_DWORD *)(v212 + 56);
      v85 = *(_DWORD *)(v212 + 60);
    }
    v239[1] = v85;
LABEL_106:
    v86 = v74 - 2;
    if ((v74 - 2) < 8 && ((0xA5u >> v86) & 1) != 0)
    {
      v74 = dword_1B693D9F0[v86];
    }
    else
    {
      v87 = v254;
      v88 = SHIDWORD(v254) + 1;
      HIDWORD(v254) = v88 & 7;
      v89 = (unsigned int *)((char *)v252 + (v88 >> 3));
      v252 = v89;
      v90 = v89 > v253;
      if (v89 >= v253)
      {
        v91 = v254;
        if (v90)
        {
          v252 = v253;
          v91 = v254;
        }
      }
      else
      {
        v91 = bswap32(*v89);
      }
      LODWORD(v254) = v91 << (v88 & 7);
      LOBYTE(v239[2]) = v87 < 0;
      if (v87 < 0)
      {
        for (i = 0; ; ++i)
        {
          v93 = sub_1B67C9140((uint64_t)v251);
          *((_DWORD *)&v245[2] + i) = v93;
          if (v93 == 3)
          {
            v74 = v233;
            v10 = v218;
            goto LABEL_123;
          }
          v94 = v93;
          v95 = &v246;
          if (v93 >= 2)
          {
            v95 = &v247;
            if (v93 != 2)
            {
              v176 = MEMORY[0x1E0C81028];
              if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)v266 = 67109120;
                v267 = v94;
                _os_log_error_impl(&dword_1B676B000, v176, OS_LOG_TYPE_ERROR, "SliceHeaderH264::Parse() get unknown value %d for reordering_of_pic_nums_idc0", v266, 8u);
              }
              v175 = 0;
              v16 = 4294954387;
              v10 = v218;
              goto LABEL_239;
            }
          }
          v95[i] = sub_1B67C9140((uint64_t)v251);
          v96 = v239[0];
          if (i > v239[0])
            break;
          DataLength = v220;
        }
        v10 = v218;
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          goto LABEL_235;
        *(_DWORD *)v266 = 67109376;
        v267 = i;
        v268 = 1024;
        v269 = v96;
        v163 = MEMORY[0x1E0C81028];
        v164 = "SliceHeaderH264::Parse() get too many(%d) ref reorderings arrived, expected <= num_ref_idx_l0_active_minus1(%d)";
        goto LABEL_265;
      }
    }
LABEL_123:
    if (v74 == 6 || v74 == 1)
    {
      v98 = v254;
      v99 = SHIDWORD(v254) + 1;
      HIDWORD(v254) = v99 & 7;
      v100 = (unsigned int *)((char *)v252 + (v99 >> 3));
      v252 = v100;
      v101 = v100 > v253;
      if (v100 >= v253)
      {
        v102 = v254;
        if (v101)
        {
          v252 = v253;
          v102 = v254;
        }
      }
      else
      {
        v102 = bswap32(*v100);
      }
      LODWORD(v254) = v102 << (v99 & 7);
      BYTE1(v239[2]) = v98 < 0;
      if (v98 < 0)
      {
        for (j = 0; ; ++j)
        {
          v154 = sub_1B67C9140((uint64_t)v251);
          v155 = v154;
          if (v154 >= 4)
          {
            if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
              goto LABEL_246;
            *(_DWORD *)v266 = 67109120;
            v267 = v155;
            v45 = MEMORY[0x1E0C81028];
            v46 = "SliceHeaderH264::Parse() ref_pic_list_reordering  L1: val(%d) > 3";
            goto LABEL_244;
          }
          *((_DWORD *)&v245[18] + j + 1) = v154;
          if (v154 == 3)
            goto LABEL_134;
          v156 = sub_1B67C9140((uint64_t)v251);
          v157 = &v232[4 * j];
          v158 = v157 + 784;
          v159 = v157 + 520;
          if (v155 >= 2)
            v159 = v158;
          *(_DWORD *)v159 = v156;
          v160 = v239[1];
          if (j > v239[1])
            break;
          DataLength = v220;
        }
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          goto LABEL_235;
        *(_DWORD *)v266 = 67109376;
        v267 = j;
        v268 = 1024;
        v269 = v160;
        v163 = MEMORY[0x1E0C81028];
        v164 = "SliceHeaderH264::Parse() get too many(%d) ref reorderings arrived, expected <= num_ref_idx_l1_active_minus1(%d)";
LABEL_265:
        _os_log_error_impl(&dword_1B676B000, v163, OS_LOG_TYPE_ERROR, v164, v266, 0xEu);
LABEL_235:
        v175 = 0;
        v16 = 4294954387;
LABEL_239:
        DataLength = v220;
        goto LABEL_247;
      }
    }
LABEL_134:
    if ((!*(_BYTE *)(v212 + 64) || (_DWORD)v233 && (_DWORD)v233 != 5)
      && (*(_DWORD *)(v212 + 68) != 1 || (_DWORD)v233 != 6 && (_DWORD)v233 != 1))
    {
      goto LABEL_185;
    }
    v248 = sub_1B67C9140((uint64_t)v251);
    v249 = sub_1B67C9140((uint64_t)v251);
    v103 = v239[0];
    if ((v239[0] + 1) <= 0x20)
    {
      v104 = 0;
      do
      {
        v105 = v254;
        v106 = SHIDWORD(v254) + 1;
        HIDWORD(v254) = v106 & 7;
        v107 = (unsigned int *)((char *)v252 + (v106 >> 3));
        v252 = v107;
        v108 = v107 > v253;
        if (v107 >= v253)
        {
          v109 = v254;
          if (v108)
          {
            v252 = v253;
            v109 = v254;
          }
        }
        else
        {
          v109 = bswap32(*v107);
        }
        LODWORD(v254) = v109 << (v106 & 7);
        v250[v104] = v105 < 0;
        if (v105 < 0)
        {
          v111 = sub_1B67C9140((uint64_t)v251);
          *(_DWORD *)&v250[12 * v104 + 128] = (-((v111 + 1) & 1) ^ ((v111 + 1) >> 1)) + ((v111 + 1) & 1);
          v112 = sub_1B67C9140((uint64_t)v251);
          v110 = (-((v112 + 1) & 1) ^ ((v112 + 1) >> 1)) + ((v112 + 1) & 1);
        }
        else
        {
          v110 = 0;
          *(_DWORD *)&v250[12 * v104 + 128] = 1 << v248;
        }
        *(_DWORD *)&v250[12 * v104 + 896] = v110;
        v113 = v254;
        v114 = SHIDWORD(v254) + 1;
        v115 = v114 & 7;
        HIDWORD(v254) = v114 & 7;
        v116 = (unsigned int *)((char *)v252 + (v114 >> 3));
        v252 = v116;
        v117 = v116 > v253;
        if (v116 >= v253)
        {
          v118 = v254;
          if (v117)
          {
            v252 = v253;
            v118 = v254;
          }
        }
        else
        {
          v118 = bswap32(*v116);
        }
        v119 = 0;
        LODWORD(v254) = v118 << v115;
        v250[v104 + 64] = v113 < 0;
        v120 = 1;
        do
        {
          v121 = v119;
          if (v113 < 0)
          {
            v123 = sub_1B67C9140((uint64_t)v251);
            *(_DWORD *)&v250[12 * v104 + 128 + 4 * v120] = (-((v123 + 1) & 1) ^ ((v123 + 1) >> 1))
                                                         + ((v123 + 1) & 1);
            v124 = sub_1B67C9140((uint64_t)v251);
            v122 = (-((v124 + 1) & 1) ^ ((v124 + 1) >> 1)) + ((v124 + 1) & 1);
          }
          else
          {
            v122 = 0;
            *(_DWORD *)&v250[12 * v104 + 128 + 4 * v120] = 1 << v249;
          }
          *(_DWORD *)&v250[12 * v104 + 896 + 4 * v120] = v122;
          v119 = 1;
          v120 = 2;
        }
        while ((v121 & 1) == 0);
        ++v104;
        v10 = v218;
        DataLength = v220;
      }
      while (v104 <= v239[0]);
      if ((_DWORD)v233 != 6 && (_DWORD)v233 != 1 || *(_DWORD *)(v212 + 68) != 1)
        goto LABEL_185;
      v125 = v239[1];
      if ((v239[1] + 1) <= 0x20)
      {
        v126 = 0;
        do
        {
          v127 = v254;
          v128 = SHIDWORD(v254) + 1;
          HIDWORD(v254) = v128 & 7;
          v129 = (unsigned int *)((char *)v252 + (v128 >> 3));
          v252 = v129;
          v130 = v129 > v253;
          if (v129 >= v253)
          {
            v131 = v254;
            if (v130)
            {
              v252 = v253;
              v131 = v254;
            }
          }
          else
          {
            v131 = bswap32(*v129);
          }
          LODWORD(v254) = v131 << (v128 & 7);
          v132 = v126;
          v250[v126 + 32] = v127 < 0;
          v211 = v126;
          if (v127 < 0)
          {
            v134 = sub_1B67C9140((uint64_t)v251);
            *(_DWORD *)&v250[12 * v132 + 512] = (-((v134 + 1) & 1) ^ ((v134 + 1) >> 1))
                                                            + ((v134 + 1) & 1);
            v135 = sub_1B67C9140((uint64_t)v251);
            v133 = (-((v135 + 1) & 1) ^ ((v135 + 1) >> 1)) + ((v135 + 1) & 1);
          }
          else
          {
            v133 = 0;
            *(_DWORD *)&v250[12 * v126 + 512] = 1 << v248;
          }
          *(_DWORD *)&v250[12 * v132 + 1280] = v133;
          v136 = v254;
          v137 = SHIDWORD(v254) + 1;
          v138 = v137 & 7;
          HIDWORD(v254) = v137 & 7;
          v139 = (unsigned int *)((char *)v252 + (v137 >> 3));
          v252 = v139;
          v140 = v139 > v253;
          if (v139 >= v253)
          {
            v141 = v254;
            if (v140)
            {
              v252 = v253;
              v141 = v254;
            }
          }
          else
          {
            v141 = bswap32(*v139);
          }
          v142 = 0;
          LODWORD(v254) = v141 << v138;
          v250[v132 + 64] = v136 < 0;
          v143 = 1;
          do
          {
            v144 = v142;
            if (v136 < 0)
            {
              v146 = sub_1B67C9140((uint64_t)v251);
              *(_DWORD *)&v232[12 * v132 + 1440 + 4 * v143] = (-((v146 + 1) & 1) ^ ((v146 + 1) >> 1))
                                                                          + ((v146 + 1) & 1);
              v147 = sub_1B67C9140((uint64_t)v251);
              v145 = (-((v147 + 1) & 1) ^ ((v147 + 1) >> 1)) + ((v147 + 1) & 1);
            }
            else
            {
              v145 = 0;
              *(_DWORD *)&v232[12 * v132 + 1440 + 4 * v143] = 1 << v249;
            }
            *(_DWORD *)&v232[12 * v132 + 2208 + 4 * v143] = v145;
            v142 = 1;
            v143 = 2;
          }
          while ((v144 & 1) == 0);
          v126 = v211 + 1;
          DataLength = v220;
          v10 = v218;
        }
        while (v211 + 1 <= v239[1]);
LABEL_185:
        if (*(_DWORD *)v232)
        {
          v148 = v254;
          v149 = SHIDWORD(v254) + 1;
          v150 = v149 & 7;
          HIDWORD(v254) = v149 & 7;
          v151 = (unsigned int *)((char *)v252 + (v149 >> 3));
          v252 = v151;
          v152 = v254 >> 31;
          if (*(_DWORD *)&v232[4] == 5)
          {
            if (v151 >= v253)
            {
              if (v151 > v253)
                v151 = v253;
            }
            else
            {
              v148 = bswap32(*v151);
            }
            v165 = v148 << v150;
            LODWORD(v254) = v165;
            HIBYTE(v239[2]) = v152;
            v166 = (v149 & 7) + 1;
            v167 = v166 & 7;
            HIDWORD(v254) = v166 & 7;
            v168 = (unsigned int *)((char *)v151 + (v166 >> 3));
            v252 = v168;
            if (v168 >= v253)
            {
              if (v168 > v253)
                v252 = v253;
              v169 = v165;
            }
            else
            {
              v169 = bswap32(*v168);
            }
            LODWORD(v254) = v169 << v167;
            LOBYTE(v239[3]) = v165 < 0;
          }
          else
          {
            v161 = v151 > v253;
            if (v151 >= v253)
            {
              v162 = v254;
              if (v161)
              {
                v252 = v253;
                v162 = v254;
              }
            }
            else
            {
              v162 = bswap32(*v151);
            }
            LODWORD(v254) = v162 << v150;
            BYTE2(v239[2]) = v152;
            if ((v148 & 0x80000000) != 0)
            {
              for (k = -32; ; k += 4)
              {
                v171 = sub_1B67C9140((uint64_t)v251);
                *(_DWORD *)&v250[k + 1696] = v171;
                if (!v171)
                  break;
                v172 = v171;
                if (v171 >= 7)
                {
                  if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                    goto LABEL_246;
                  *(_DWORD *)v266 = 67109120;
                  v267 = v172;
                  v45 = MEMORY[0x1E0C81028];
                  v46 = "SliceHeaderH264::Parse() unknown MMCO(%d) received, expected in range [1,6]";
                  goto LABEL_244;
                }
                if (!k)
                {
                  if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                    goto LABEL_246;
                  *(_DWORD *)v266 = 67109376;
                  v267 = 8;
                  v268 = 1024;
                  v269 = 8;
                  v45 = MEMORY[0x1E0C81028];
                  v46 = "SliceHeaderH264::Parse() too many MMCOs(%d) received, expected < %d";
                  v47 = 14;
                  goto LABEL_245;
                }
                switch(v171)
                {
                  case 1u:
                  case 3u:
                    *(_DWORD *)&v250[k + 1728] = sub_1B67C9140((uint64_t)v251);
                    if (v172 == 3)
                      goto LABEL_220;
                    if (v172 == 2)
                      goto LABEL_219;
                    break;
                  case 2u:
LABEL_219:
                    *(_DWORD *)&v250[k + 1760] = sub_1B67C9140((uint64_t)v251);
                    break;
                  case 4u:
                    *(_DWORD *)&v250[k + 1824] = sub_1B67C9140((uint64_t)v251);
                    break;
                  case 6u:
LABEL_220:
                    *(_DWORD *)&v250[k + 1792] = sub_1B67C9140((uint64_t)v251);
                    break;
                  default:
                    continue;
                }
              }
            }
          }
        }
        if (*(_BYTE *)(v212 + 8) == 1 && (v233 > 9 || ((1 << v233) & 0x294) == 0))
          v240 = sub_1B67C9140((uint64_t)v251);
        v174 = sub_1B67C9140((uint64_t)v251);
        v16 = 0;
        v241 = (-((v174 + 1) & 1) ^ ((v174 + 1) >> 1)) + ((v174 + 1) & 1);
        v242 = v241 + *(_DWORD *)(v212 + 72) + 26;
        v175 = 1;
        goto LABEL_247;
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v266 = 67109120;
        v267 = v125;
        v45 = MEMORY[0x1E0C81028];
        v46 = "SliceHeaderH264::Parse() num_ref_idx_l1_active_minus1(%d) + 1 > kBufMgtDecoMaxNumberOfRefPics_is32(32)";
        goto LABEL_244;
      }
LABEL_246:
      v175 = 0;
      v16 = 4294954387;
LABEL_247:
      v178 = v262;
      if (v262)
      {
        p_shared_owners = (unint64_t *)&v262->__shared_owners_;
        do
          v180 = __ldaxr(p_shared_owners);
        while (__stlxr(v180 - 1, p_shared_owners));
        if (!v180)
        {
          ((void (*)(std::__shared_weak_count *))v178->__on_zero_shared)(v178);
          std::__shared_weak_count::__release_weak(v178);
        }
      }
      v181 = v264;
      if (!v264)
        goto LABEL_256;
      v182 = (unint64_t *)&v264->__shared_owners_;
      do
        v183 = __ldaxr(v182);
      while (__stlxr(v183 - 1, v182));
      if (!v183)
      {
        ((void (*)(std::__shared_weak_count *))v181->__on_zero_shared)(v181);
        std::__shared_weak_count::__release_weak(v181);
        if ((v175 & 1) != 0)
        {
LABEL_257:
          v16 = 0;
          *((_BYTE *)&v222 + v219++ + 16) = v242;
          v25 = 1;
          goto LABEL_16;
        }
      }
      else
      {
LABEL_256:
        if ((v175 & 1) != 0)
          goto LABEL_257;
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Warning: VCPReadH264SliceHeader() slice header parsing error!", buf, 2u);
      }
      goto LABEL_261;
    }
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_246;
    *(_DWORD *)v266 = 67109120;
    v267 = v103;
    v45 = MEMORY[0x1E0C81028];
    v46 = "SliceHeaderH264::Parse() num_ref_idx_l0_active_minus1(%d) + 1 > kBufMgtDecoMaxNumberOfRefPics_is32(32)";
LABEL_244:
    v47 = 8;
    goto LABEL_245;
  }
  v16 = 0;
LABEL_281:
  v194 = v259;
  if (v259)
  {
    v195 = (unint64_t *)&v259->__shared_owners_;
    do
      v196 = __ldaxr(v195);
    while (__stlxr(v196 - 1, v195));
    if (!v196)
    {
      ((void (*)(std::__shared_weak_count *))v194->__on_zero_shared)(v194);
      std::__shared_weak_count::__release_weak(v194);
    }
  }
  v197 = v258;
  if (v258)
  {
    v198 = (unint64_t *)&v258->__shared_owners_;
    do
      v199 = __ldaxr(v198);
    while (__stlxr(v199 - 1, v198));
    if (!v199)
    {
      ((void (*)(std::__shared_weak_count *))v197->__on_zero_shared)(v197);
      std::__shared_weak_count::__release_weak(v197);
    }
  }
  for (m = 4592; m != 496; m -= 16)
    sub_1B6772C88((uint64_t)&v257[m]);
  do
  {
    sub_1B6772C88((uint64_t)&v257[m]);
    m -= 16;
  }
  while (m != -16);
  if ((_DWORD)v16)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v257 = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Warning, VCPReadH264SliceHeader() parsing error\n", v257, 2u);
    }
  }
  else
  {
    *(_OWORD *)(v221 + 128) = v222;
    *(_DWORD *)(v221 + 144) = v223;
    *(_BYTE *)(v221 + 85) = v224;
    v202 = *(_QWORD *)(v10 + 2224);
    if (v202)
    {
      v203 = *(_DWORD *)(v221 + 128);
      if (v203)
        sub_1B6872E44(v202, (uint64_t *)"slice_size0", (double)v203);
      v204 = *(_DWORD *)(v221 + 132);
      if (v204)
        sub_1B6872E44(*(_QWORD *)(v10 + 2224), (uint64_t *)"slice_size1", (double)v204);
      v205 = *(_DWORD *)(v221 + 136);
      if (v205)
        sub_1B6872E44(*(_QWORD *)(v10 + 2224), (uint64_t *)"slice_size2", (double)v205);
      v206 = *(_DWORD *)(v221 + 140);
      if (v206)
        sub_1B6872E44(*(_QWORD *)(v10 + 2224), (uint64_t *)"slice_size3", (double)v206);
      v207 = *(char *)(v221 + 144);
      if (v207 >= 1)
        sub_1B6872E44(*(_QWORD *)(v10 + 2224), (uint64_t *)"slice_qp0", (double)v207);
      v208 = *(char *)(v221 + 145);
      if (v208 >= 1)
        sub_1B6872E44(*(_QWORD *)(v10 + 2224), (uint64_t *)"slice_qp1", (double)v208);
      v209 = *(char *)(v221 + 146);
      if (v209 >= 1)
        sub_1B6872E44(*(_QWORD *)(v10 + 2224), (uint64_t *)"slice_qp2", (double)v209);
      v210 = *(char *)(v221 + 147);
      if (v210 >= 1)
        sub_1B6872E44(*(_QWORD *)(v10 + 2224), (uint64_t *)"slice_qp3", (double)v210);
    }
  }
  return v16;
}

void sub_1B679A254(_Unwind_Exception *a1)
{
  sub_1B6798548((uint64_t)&STACK[0xC60]);
  _Unwind_Resume(a1);
}

uint64_t VCPDecompressionSessionDecodeFrame(uint64_t a1, CFTypeRef cf, int a3, uint64_t a4, uint64_t a5)
{
  void *v8;
  int v10;
  uint64_t v11;
  const opaqueCMFormatDescription *FormatDescription;
  const opaqueCMFormatDescription *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  int *v18;
  char **v19;
  const void **v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  __CFDictionary *Mutable;
  uint64_t v28;
  uint64_t v29;
  size_t v30;
  __int128 v31;
  size_t v32;
  uint64_t v33;
  size_t v34;
  void *v35;
  void *v36;
  uint64_t v37;
  __int128 v38;
  int v39;
  __CFDictionary *v40;
  CFNumberRef v41;
  NSObject *v42;
  int v43;
  const char *v44;
  int v45;
  int v46;
  char v47;
  int v48;
  int v49;
  char v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  size_t v56;
  void *v57;
  CFTypeID TypeID;
  size_t v59;
  CFTypeID v60;
  _BOOL4 v61;
  int v62;
  CFTypeID v63;
  CFIndex v64;
  CFTypeID v65;
  NSObject *v66;
  const void *Value;
  char v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  const __CFNumber *v81;
  const __CFArray *SampleAttachmentsArray;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v84;
  int v85;
  int v86;
  char v87;
  int v88;
  int v89;
  int v90;
  const char *v91;
  int v92;
  const char *v93;
  int v94;
  _BOOL4 v95;
  int v96;
  const char *v97;
  int v98;
  int v99;
  const char *v100;
  int v101;
  int v102;
  int v103;
  NSObject *v104;
  const char *v105;
  uint32_t v106;
  int v107;
  int v108;
  uint64_t v109;
  int v110;
  int v111;
  NSObject *v113;
  const char *v114;
  uint32_t v115;
  uint64_t v116;
  CFNumberRef v117;
  CFNumberRef v118;
  CFNumberRef v119;
  unsigned int v120;
  unsigned int v121;
  int v122;
  uint64_t v123;
  const __CFAllocator *v124;
  CFNumberRef v125;
  const void *v126;
  CFDictionaryRef v127;
  uint64_t v128;
  int *v130;
  uint64_t v131;
  uint64_t v132;
  void *v133;
  __int128 v134;
  _BYTE v135[6];
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  _BYTE v152[32];
  __int128 v153[2];
  _BYTE v154[156];
  __int16 v155;
  _BYTE v156[194];
  uint64_t v157;
  char v158;
  char v159;
  _DWORD v160[5];
  uint64_t v161;

  v8 = (void *)cf;
  v161 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v144 = cf;
  *(_QWORD *)&v143 = *(unsigned __int16 *)(a1 + 174);
  v10 = *(_DWORD *)(a1 + 112);
  DWORD2(v143) = *(_DWORD *)(a1 + 116);
  HIDWORD(v143) = v10;
  v11 = *(_QWORD *)(a1 + 2224);
  if (v11)
    sub_1B6872E44(v11, (uint64_t *)"input_frames", 1.0);
  if (!v8 || (CFRetain(v8), !CMSampleBufferGetDataBuffer((CMSampleBufferRef)v8)))
  {
    Mutable = 0;
    v15 = 0;
    v28 = 4294954387;
    goto LABEL_236;
  }
  FormatDescription = CMSampleBufferGetFormatDescription((CMSampleBufferRef)v8);
  if (*(const opaqueCMFormatDescription **)(a1 + 56) != FormatDescription)
  {
    v13 = FormatDescription;
    if (!VTDecompressionSessionCanAcceptFormatDescription(*(VTDecompressionSessionRef *)(a1 + 16), FormatDescription))
    {
      VTDecompressionSessionInvalidate(*(VTDecompressionSessionRef *)(a1 + 16));
      CFRelease(*(CFTypeRef *)(a1 + 16));
      *(_QWORD *)(a1 + 16) = 0;
      v29 = sub_1B679220C(*(const void **)(a1 + 48), v13, *(const __CFDictionary **)(a1 + 64), *(const void **)(a1 + 72), (_DWORD *)a1);
      if ((_DWORD)v29)
      {
        v28 = v29;
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
LABEL_17:
          Mutable = 0;
          v15 = 0;
          goto LABEL_236;
        }
        *(_DWORD *)&v154[8] = 67109120;
        *(_DWORD *)&v154[12] = v28;
        v113 = MEMORY[0x1E0C81028];
        v114 = "Failed to recreate DecompressionSession, err = %d\n";
        v115 = 8;
LABEL_187:
        _os_log_error_impl(&dword_1B676B000, v113, OS_LOG_TYPE_ERROR, v114, &v154[8], v115);
        goto LABEL_17;
      }
    }
  }
  ++*(_WORD *)(a1 + 174);
  v14 = (char *)operator new(0xA0uLL, MEMORY[0x1E0DE4E10]);
  if (!v14)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      Mutable = 0;
      v15 = 0;
LABEL_22:
      v28 = 4294954392;
      goto LABEL_236;
    }
    v96 = *(_DWORD *)(a1 + 24);
    v97 = "H.264";
    if (v96 > 1718908519)
    {
      if (v96 == 1752589105)
        goto LABEL_184;
      v98 = 1718908520;
    }
    else
    {
      if (v96 == 1684632424)
        goto LABEL_184;
      v98 = 1685481521;
    }
    if (v96 != v98)
    {
LABEL_185:
      *(_DWORD *)&v154[8] = 134218498;
      *(_QWORD *)&v154[12] = a1;
      *(_WORD *)&v154[20] = 2080;
      *(_QWORD *)&v154[22] = v97;
      *(_WORD *)&v154[30] = 1024;
      v28 = 4294954392;
      *(_DWORD *)&v154[32] = -12904;
      v113 = MEMORY[0x1E0C81028];
      v114 = "VCPDec %p (%s): Decoder failed to create vcpFrameContext, err = %d\n";
      v115 = 28;
      goto LABEL_187;
    }
LABEL_184:
    v97 = "HEVC";
    goto LABEL_185;
  }
  v15 = (uint64_t)v14;
  *(_QWORD *)v14 = a4;
  *((_DWORD *)v14 + 2) = 0;
  *(_QWORD *)&v138 = v14 + 8;
  *((_WORD *)v14 + 6) = 0;
  *((_QWORD *)&v137 + 1) = v14 + 12;
  v14[14] = 0;
  *((_QWORD *)v14 + 2) = 0x80000000;
  *(_QWORD *)&v139 = v14 + 16;
  *((_QWORD *)v14 + 3) = 0;
  v16 = (uint64_t)(v14 + 24);
  v14[56] = 0;
  *((_QWORD *)v14 + 4) = 0;
  *((_QWORD *)v14 + 5) = 0;
  *((_DWORD *)v14 + 16) = 0;
  *((_QWORD *)v14 + 9) = 0;
  *((_DWORD *)v14 + 20) = 0;
  *((_DWORD *)v14 + 21) = 1077952512;
  *((_QWORD *)v14 + 11) = 0xFFFFFFFF00000000;
  v17 = v14 + 88;
  *((_QWORD *)v14 + 12) = 0;
  v18 = (int *)(v14 + 96);
  *((_QWORD *)v14 + 15) = 0;
  v19 = (char **)(v14 + 120);
  *((_QWORD *)v14 + 13) = 0;
  v14[112] = 0;
  *((_QWORD *)v14 + 16) = 0;
  *((_QWORD *)v14 + 17) = 0;
  *((_QWORD *)v14 + 19) = 0;
  v20 = (const void **)(v14 + 152);
  *((_DWORD *)v14 + 36) = -1;
  *(_QWORD *)&v154[8] = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  sub_1B67774AC(v20, (const void **)&v154[8]);
  sub_1B67705C8((const void **)&v154[8]);
  v21 = sub_1B685C8CC(*(char **)(a1 + 2288));
  *v19 = v21;
  if (!v21)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)&v154[8] = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "control_byte memory allocate failed!", &v154[8], 2u);
    }
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      Mutable = 0;
      goto LABEL_22;
    }
    v99 = *(_DWORD *)(a1 + 24);
    v100 = "H.264";
    if (v99 > 1718908519)
    {
      if (v99 == 1752589105)
        goto LABEL_191;
      v101 = 1718908520;
    }
    else
    {
      if (v99 == 1684632424)
        goto LABEL_191;
      v101 = 1685481521;
    }
    if (v99 != v101)
    {
LABEL_192:
      *(_DWORD *)&v154[8] = 134218498;
      *(_QWORD *)&v154[12] = a1;
      *(_WORD *)&v154[20] = 2080;
      *(_QWORD *)&v154[22] = v100;
      *(_WORD *)&v154[30] = 1024;
      v28 = 4294954392;
      *(_DWORD *)&v154[32] = -12904;
      v104 = MEMORY[0x1E0C81028];
      v105 = "VCPDec %p (%s): Decoder failed to initialize vcpFrameContext, err = %d\n";
      v106 = 28;
      goto LABEL_193;
    }
LABEL_191:
    v100 = "HEVC";
    goto LABEL_192;
  }
  sub_1B67ED940(v16);
  v25 = *(_DWORD *)(a1 + 24);
  DWORD1(v136) = a3;
  v131 = a5;
  v132 = (uint64_t)v19;
  v130 = v18;
  v133 = v17;
  if (v25 <= 1718908519)
  {
    if (v25 != 1684632424)
    {
      v26 = 1685481521;
      goto LABEL_25;
    }
LABEL_26:
    *((_QWORD *)&v138 + 1) = v20;
    *((_QWORD *)&v142 + 1) = CMSampleBufferGetDataBuffer((CMSampleBufferRef)v8);
    *(_QWORD *)&v141 = 0;
    *((_QWORD *)&v141 + 1) = CMBlockBufferGetDataLength(*((CMBlockBufferRef *)&v142 + 1));
    v28 = 0;
    v30 = 0;
    *(_QWORD *)&v140 = &v157;
    *((_QWORD *)&v140 + 1) = v156;
    *((_QWORD *)&v139 + 1) = v160;
    *(_QWORD *)&v137 = v153;
    *(_QWORD *)&v31 = 134219010;
    v134 = v31;
    while (1)
    {
      v32 = v30 + 4;
      if (v30 + 4 >= *((_QWORD *)&v141 + 1))
      {
LABEL_99:
        v70 = *(_QWORD *)(a1 + 2224);
        if (v70)
        {
          v71 = *(_DWORD *)(v15 + 128);
          if (v71)
            sub_1B6872E44(v70, (uint64_t *)"slice_size0", (double)v71);
          v72 = *(_DWORD *)(v15 + 132);
          if (v72)
            sub_1B6872E44(*(_QWORD *)(a1 + 2224), (uint64_t *)"slice_size1", (double)v72);
          v73 = *(_DWORD *)(v15 + 136);
          if (v73)
            sub_1B6872E44(*(_QWORD *)(a1 + 2224), (uint64_t *)"slice_size2", (double)v73);
          v74 = *(_DWORD *)(v15 + 140);
          if (v74)
            sub_1B6872E44(*(_QWORD *)(a1 + 2224), (uint64_t *)"slice_size3", (double)v74);
          v75 = *(char *)(v15 + 144);
          if (v75 >= 1)
            sub_1B6872E44(*(_QWORD *)(a1 + 2224), (uint64_t *)"slice_qp0", (double)v75);
          v76 = *(char *)(v15 + 145);
          if (v76 >= 1)
            sub_1B6872E44(*(_QWORD *)(a1 + 2224), (uint64_t *)"slice_qp1", (double)v76);
          v77 = *(char *)(v15 + 146);
          if (v77 >= 1)
            sub_1B6872E44(*(_QWORD *)(a1 + 2224), (uint64_t *)"slice_qp2", (double)v77);
          v78 = *(char *)(v15 + 147);
          if (v78 >= 1)
            sub_1B6872E44(*(_QWORD *)(a1 + 2224), (uint64_t *)"slice_qp3", (double)v78);
        }
LABEL_116:
        if (!(_DWORD)v28)
          goto LABEL_121;
LABEL_149:
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
LABEL_150:
          Mutable = 0;
          goto LABEL_236;
        }
        v102 = *(_DWORD *)(a1 + 112);
        v103 = *(_DWORD *)(a1 + 116);
        *(_DWORD *)&v154[8] = 134218496;
        *(_QWORD *)&v154[12] = a1;
        *(_WORD *)&v154[20] = 1024;
        *(_DWORD *)&v154[22] = v102;
        *(_WORD *)&v154[26] = 1024;
        *(_DWORD *)&v154[28] = v103;
        v104 = MEMORY[0x1E0C81028];
        v105 = "VCPDec %p (%dx%d, HEVC): VCPDecHEVCNaluParser() err!\n";
        v106 = 24;
LABEL_193:
        _os_log_error_impl(&dword_1B676B000, v104, OS_LOG_TYPE_ERROR, v105, &v154[8], v106);
        goto LABEL_150;
      }
      *(_DWORD *)&v152[4] = 0;
      *((_QWORD *)&v151 + 1) = 0;
      CMBlockBufferAccessDataBytes(*((CMBlockBufferRef *)&v142 + 1), v30, 4uLL, &v152[4], (char **)&v151 + 1);
      v33 = bswap32(**((_DWORD **)&v151 + 1));
      *(_QWORD *)&v151 = 0;
      *(_QWORD *)&v142 = v33;
      v34 = (int)v33;
      v35 = operator new[]((int)v33, MEMORY[0x1E0DE4E10]);
      if (!v35)
      {
        v42 = MEMORY[0x1E0C81028];
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)&v154[8] = 0;
          _os_log_impl(&dword_1B676B000, v42, OS_LOG_TYPE_DEFAULT, "Unable to allocate NALU buffer for SEI and slice(s) parsing!\n", &v154[8], 2u);
        }
        goto LABEL_96;
      }
      v36 = v35;
      if (CMBlockBufferAccessDataBytes(*((CMBlockBufferRef *)&v142 + 1), v32, v34, v35, (char **)&v151))
      {
        MEMORY[0x1BCC9811C](v36, 0x1000C8077774924);
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)&v154[8] = 67109120;
          *(_DWORD *)&v154[12] = v142;
          _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "SEI UserDataUnregistered Nal error unable to get data of size %uz", &v154[8], 8u);
        }
        v28 = 4294954394;
        goto LABEL_149;
      }
      *(_WORD *)&v154[8] = 0;
      memset(&v154[12], 0, 144);
      v155 = 0;
      *(_QWORD *)&v38 = -1;
      *((_QWORD *)&v38 + 1) = -1;
      **((_OWORD **)&v140 + 1) = v38;
      *(_OWORD *)(*((_QWORD *)&v140 + 1) + 16) = v38;
      *(_OWORD *)(*((_QWORD *)&v140 + 1) + 32) = v38;
      *(_OWORD *)(*((_QWORD *)&v140 + 1) + 48) = v38;
      **((_QWORD **)&v139 + 1) = 0;
      memset(&v156[64], 0, 129);
      *(_WORD *)(v140 + 8) = 0;
      *(_QWORD *)v140 = 0;
      v39 = sub_1B67848D4(v151, v34, 0, (uint64_t)&v154[8], *(_QWORD *)(a1 + 2352), v141 == 0, 2, v37, (uint64_t)v130, v131, v132, (uint64_t)v133, v134, *((uint64_t *)&v134 + 1), *(int *)v135, *(__int16 *)&v135[4], v136, v137, v138,
              v139,
              v140,
              v141,
              v142,
              v143,
              v144,
              v145,
              v146,
              v147,
              v148,
              v149,
              v150,
              v151,
              *(__int128 *)v152,
              *(__int128 *)&v152[16],
              v153[0],
              v153[1],
              *(__int128 *)v154,
              *(__int128 *)&v154[16],
              *(uint64_t *)&v154[32],
              *(uint64_t *)&v154[40],
              v154[48],
              *(__int16 *)&v154[50],
              v154[52],
              *(int *)&v154[56],
              v154[60],
              *(__int128 *)&v154[64],
              *(__int128 *)&v154[80],
              *(__int128 *)&v154[96],
              *(__int128 *)&v154[112],
              *(__int128 *)&v154[128]);
      if (v39 != 1)
      {
        if (v39 != 7)
        {
          v28 = 0;
          goto LABEL_95;
        }
        v40 = (__CFDictionary *)**((_QWORD **)&v138 + 1);
        *(_DWORD *)&v152[8] = v142;
        v41 = CFNumberCreate(0, kCFNumberSInt32Type, &v152[8]);
        if (v41)
        {
          CFDictionarySetValue(v40, CFSTR("PropagatableAttachmentsNALSize"), v41);
          CFRelease(v41);
        }
        else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)&v152[8] = 0;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Unable to set SEI NAL Size\n", &v152[8], 2u);
        }
        v28 = 0;
        if (!v160[0] || !v160[1])
          goto LABEL_93;
        *(_QWORD *)&v152[8] = 0;
        *(_QWORD *)&v152[16] = 0;
        *(_QWORD *)(v137 + 8) = 0;
        *(_QWORD *)(v137 + 16) = 0;
        *(_QWORD *)v137 = 0;
        *(_QWORD *)&v147 = &off_1E6A159D8;
        *((_QWORD *)&v147 + 1) = 2;
        *(_QWORD *)&v148 = 0;
        WORD4(v148) = -192;
        *(_QWORD *)&v149 = 0;
        *((_QWORD *)&v149 + 1) = sub_1B67AD728;
        *(_QWORD *)&v150 = 0;
        off_1EF137C48 = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_1B67AD840;
        sub_1B67B6B1C((uint64_t)&v147, (unsigned __int8 *)v151, v34);
        v146 = 0uLL;
        *((_QWORD *)&v136 + 1) = v8;
        if (sub_1B67C8EF8((void **)&v152[8], &v147))
        {
          MEMORY[0x1BCC9811C](v36, 0x1000C8077774924);
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
            WORD4(v145) = 0;
            _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "SEI UserDataUnregistered Nal error emulation prevention", (uint8_t *)&v145 + 8, 2u);
          }
          v50 = 0;
          v51 = 6;
          v28 = 4294954394;
LABEL_90:
          if (*(_QWORD *)&v152[8])
          {
            v68 = v50;
            free(*(void **)&v152[8]);
            v50 = v68;
          }
          v8 = (void *)*((_QWORD *)&v136 + 1);
          if ((v50 & 1) == 0)
            goto LABEL_97;
LABEL_93:
          v69 = *(_QWORD *)(a1 + 2224);
          if (v69)
            sub_1B6872E44(v69, (uint64_t *)"sei", (double)(int)v142);
LABEL_95:
          MEMORY[0x1BCC9811C](v36, 0x1000C8077774924);
LABEL_96:
          v51 = 0;
          v32 += v34;
          goto LABEL_97;
        }
        v52 = *(_QWORD *)&v152[24];
        v53 = sub_1B6882FF4((_DWORD *)&v150 + 3, *(uint64_t *)&v152[24], *((_QWORD *)&v153[0] + 1) - *(_QWORD *)&v152[24], (unint64_t *)&v146 + 1, (uint64_t *)&v146, 0);
        if ((_DWORD)v53)
        {
          v28 = v53;
          MEMORY[0x1BCC9811C](v36, 0x1000C8077774924);
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
            WORD4(v145) = 0;
            _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "SEI UserDataUnregistered Nal parsing error", (uint8_t *)&v145 + 8, 2u);
          }
          v50 = 0;
          v51 = 6;
          goto LABEL_90;
        }
        v56 = *((_QWORD *)&v146 + 1);
        v57 = (void *)(v52 + v146);
        *((_QWORD *)&v145 + 1) = 0;
        if (*(_DWORD *)(a1 + 2232) == 1)
        {
          TypeID = CFDictionaryGetTypeID();
          if (sub_1B67987D8((UInt8 *)v57, v56, TypeID, (CFTypeRef *)&v145 + 1))
          {
            v59 = *((_QWORD *)&v146 + 1);
            v60 = CFDictionaryGetTypeID();
            if (!sub_1B67985AC(v57, v59, v60, (CFTypeRef *)&v145 + 1))
            {
              v61 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT);
              v62 = 0;
              if (v61)
              {
                WORD4(v144) = 0;
                _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Switching to SEI deserialization mode=0 to match detected data\n", (uint8_t *)&v144 + 8, 2u);
                v62 = 0;
              }
              goto LABEL_82;
            }
          }
        }
        else
        {
          v63 = CFDictionaryGetTypeID();
          if (sub_1B67985AC(v57, v56, v63, (CFTypeRef *)&v145 + 1))
          {
            v64 = *((_QWORD *)&v146 + 1);
            v65 = CFDictionaryGetTypeID();
            if (!sub_1B67987D8((UInt8 *)v57, v64, v65, (CFTypeRef *)&v145 + 1))
            {
              v66 = MEMORY[0x1E0C81028];
              if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
              {
                WORD4(v144) = 0;
                _os_log_impl(&dword_1B676B000, v66, OS_LOG_TYPE_DEFAULT, "Switching to SEI deserialization mode=1 to match detected data\n", (uint8_t *)&v144 + 8, 2u);
              }
              v62 = 1;
LABEL_82:
              *(_DWORD *)(a1 + 2232) = v62;
            }
          }
        }
        if (*((_QWORD *)&v145 + 1))
        {
          if (CFDictionaryContainsKey(*((CFDictionaryRef *)&v145 + 1), CFSTR("PropagatableAttachments")))
          {
            Value = CFDictionaryGetValue(*((CFDictionaryRef *)&v145 + 1), CFSTR("PropagatableAttachments"));
            if (Value)
              CFDictionaryAddValue(**((CFMutableDictionaryRef **)&v138 + 1), CFSTR("PropagatableAttachments"), Value);
          }
          else
          {
            CFDictionaryAddValue(**((CFMutableDictionaryRef **)&v138 + 1), CFSTR("PropagatableAttachments"), *((const void **)&v145 + 1));
          }
          CFRelease(*((CFTypeRef *)&v145 + 1));
        }
        v28 = 0;
        v51 = 0;
        v50 = 1;
        goto LABEL_90;
      }
      if ((unint64_t)v141 < 4)
      {
        if (!(_QWORD)v141)
        {
          v46 = v154[9];
          *(_BYTE *)(v15 + 84) = v154[9];
          *(_BYTE *)(v15 + 85) = v154[8];
          v47 = v158;
          *(_BYTE *)(v15 + 86) = v158;
          v48 = *(_DWORD *)(a1 + 200);
          if (!v46)
          {
            v49 = *(_DWORD *)v139;
            if (v48 != -1)
              *(_DWORD *)(a1 + 204) = v49 - v48;
            *(_DWORD *)(a1 + 200) = v49;
            v48 = v49;
          }
          if (v48 != -1)
            *(_DWORD *)(v15 + 20) = *(_DWORD *)(v15 + 16) - v48;
          if (v46)
            v47 = *(_BYTE *)(a1 + 208);
          else
            *(_BYTE *)(a1 + 208) = v47;
          *(_BYTE *)(v15 + 87) = v47;
        }
        v28 = 0;
        *(_BYTE *)(v15 + v141 + 144) = v159;
        *(_DWORD *)(v15 + 4 * v141 + 128) = v142 + 4;
        *(_QWORD *)&v141 = v141 + 1;
        goto LABEL_95;
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        break;
LABEL_68:
      v28 = 0;
      v51 = 3;
LABEL_97:
      v30 = v32;
      if (v51)
      {
        if (v51 != 3)
          goto LABEL_116;
        goto LABEL_99;
      }
    }
    v43 = *(_DWORD *)(a1 + 24);
    if (v43 > 1718908519)
    {
      if (v43 == 1752589105)
        goto LABEL_66;
      v44 = "H.264";
      v45 = 1718908520;
    }
    else
    {
      if (v43 == 1684632424)
        goto LABEL_66;
      v44 = "H.264";
      v45 = 1685481521;
    }
    if (v43 != v45)
    {
LABEL_67:
      v54 = *(_DWORD *)(a1 + 112);
      v55 = *(_DWORD *)(a1 + 116);
      *(_DWORD *)&v152[8] = v134;
      *(_QWORD *)&v152[12] = a1;
      *(_WORD *)&v152[20] = 1024;
      *(_DWORD *)&v152[22] = v54;
      *(_WORD *)&v152[26] = 1024;
      *(_DWORD *)&v152[28] = v55;
      LOWORD(v153[0]) = 2080;
      *(_QWORD *)((char *)v153 + 2) = v44;
      WORD5(v153[0]) = 1024;
      HIDWORD(v153[0]) = 4;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): warning, got more than %d slices, ignored!\n", &v152[8], 0x28u);
      goto LABEL_68;
    }
LABEL_66:
    v44 = "HEVC";
    goto LABEL_67;
  }
  if (v25 == 1752589105)
    goto LABEL_26;
  v26 = 1718908520;
LABEL_25:
  if (v25 == v26)
    goto LABEL_26;
  if (sub_1B6798A18((uint64_t)v8, a1, v15, v22, v23, v24)
    && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v79 = *(_DWORD *)(a1 + 112);
    v80 = *(_DWORD *)(a1 + 116);
    *(_DWORD *)&v154[8] = 134218496;
    *(_QWORD *)&v154[12] = a1;
    *(_WORD *)&v154[20] = 1024;
    *(_DWORD *)&v154[22] = v79;
    *(_WORD *)&v154[26] = 1024;
    *(_DWORD *)&v154[28] = v80;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, H.264): Warning, VCPDecH264NaluParser() failed!\n", &v154[8], 0x18u);
  }
LABEL_121:
  v81 = (const __CFNumber *)CMGetAttachment(v8, CFSTR("rtpTimestsamp"), 0);
  if (v81)
    CFNumberGetValue(v81, kCFNumberSInt32Type, (void *)v139);
  SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray((CMSampleBufferRef)v8, 1u);
  if (SampleAttachmentsArray)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
    v84 = ValueAtIndex;
    if (ValueAtIndex)
    {
      if (CFDictionaryContainsKey(ValueAtIndex, CFSTR("RequestedRotationFlags")))
        sub_1B6790B00(v84, CFSTR("RequestedRotationFlags"), v133);
      if (CFDictionaryContainsKey(v84, CFSTR("TileID")))
        sub_1B6790B00(v84, CFSTR("TileID"), (void *)v138);
      if (CFDictionaryContainsKey(v84, CFSTR("TileOrder")))
        sub_1B679B914(v84, *((void **)&v137 + 1));
      if (*(int *)(a1 + 136) >= 2)
        *(_QWORD *)&v143 = (unsigned __int16)**((_WORD **)&v137 + 1) | ((unint64_t)*(unsigned int *)v138 << 32);
    }
  }
  v85 = *(unsigned __int8 *)(v15 + 86);
  v86 = *(unsigned __int8 *)(v15 + 87);
  if (v85 != v86 || *(_DWORD *)(a1 + 168) == 2 && *(_BYTE *)(v15 + 85) != 20)
  {
    *(_DWORD *)(a1 + 168) = 2;
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
LABEL_158:
      sub_1B6794F74(a1, (int *)v15, 4294954387, 1, 0, &xmmword_1B691FF40, &xmmword_1B691FF58);
      Mutable = 0;
      v28 = 0;
      goto LABEL_236;
    }
    v89 = *(_DWORD *)(a1 + 112);
    v88 = *(_DWORD *)(a1 + 116);
    v90 = *(_DWORD *)(a1 + 24);
    v91 = "H.264";
    if (v90 > 1718908519)
    {
      if (v90 == 1752589105)
        goto LABEL_154;
      v92 = 1718908520;
    }
    else
    {
      if (v90 == 1684632424)
        goto LABEL_154;
      v92 = 1685481521;
    }
    if (v90 != v92)
    {
LABEL_155:
      v93 = "Detected base layer missing";
      v94 = *(unsigned __int8 *)(v15 + 85);
      *(_DWORD *)&v154[8] = 134219266;
      if (v85 == v86)
        v93 = "Decoder has non-recoverable error";
      *(_QWORD *)&v154[12] = a1;
      *(_WORD *)&v154[20] = 1024;
      *(_DWORD *)&v154[22] = v89;
      *(_WORD *)&v154[26] = 1024;
      *(_DWORD *)&v154[28] = v88;
      *(_WORD *)&v154[32] = 2080;
      *(_QWORD *)&v154[34] = v91;
      *(_WORD *)&v154[42] = 2080;
      *(_QWORD *)&v154[44] = v93;
      *(_WORD *)&v154[52] = 1024;
      *(_DWORD *)&v154[54] = v94;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): %s for nal_type=%d, skip decoding until receive IDR to recover\n", &v154[8], 0x32u);
      goto LABEL_158;
    }
LABEL_154:
    v91 = "HEVC";
    goto LABEL_155;
  }
  kdebug_trace();
  *(_QWORD *)(v15 + 72) = v143;
  v87 = BYTE4(v136);
  *(_DWORD *)(v15 + 80) = DWORD1(v136);
  if (!*(_BYTE *)(a1 + 80))
  {
    v95 = 0;
    Mutable = 0;
    goto LABEL_230;
  }
  LODWORD(v147) = 0;
  if (*(_BYTE *)(a1 + 2368))
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (!Mutable)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)&v154[8] = 0;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "failed to create decode frame properties dictionary\n", &v154[8], 2u);
      }
      Mutable = 0;
      v28 = 1;
      goto LABEL_236;
    }
  }
  else
  {
    Mutable = 0;
  }
  v28 = sub_1B679B97C(a1, v15, (CMSampleBufferRef *)&v144);
  if ((_DWORD)v28)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)&v154[8] = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VCPDecompressionSessionDecodeFrame: VCPDecompressionControlByteProcessing failed\n", &v154[8], 2u);
    }
    goto LABEL_236;
  }
  v107 = *v130;
  if (*v130)
  {
    v108 = *(_DWORD *)(v15 + 100);
    v109 = v132;
    if (v108)
    {
      v110 = *(_DWORD *)(a1 + 212);
      v95 = v110 && (v111 = *(_DWORD *)(a1 + 216)) != 0 && (v110 != v107 || v111 != v108);
      *(_DWORD *)(a1 + 212) = v107;
      *(_DWORD *)(a1 + 216) = v108;
    }
    else
    {
      v95 = 0;
    }
  }
  else
  {
    v95 = 0;
    v109 = v132;
  }
  v116 = *(_QWORD *)v109;
  LODWORD(v147) = *(unsigned __int8 *)(*(_QWORD *)v109 + 80);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v116 + 24))(v116))
  {
    if (*(_BYTE *)(a1 + 2368))
    {
      sub_1B679BB88(Mutable, *(_WORD *)(*(_QWORD *)v132 + 16));
    }
    else
    {
      v117 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt16Type, (const void *)(*(_QWORD *)v132 + 16));
      if (v117)
      {
        VTDecompressionSessionSetProperty();
        CFRelease(v117);
      }
    }
  }
  if (*(_DWORD *)(v15 + 92) != -1)
  {
    if (*(_BYTE *)(a1 + 2368) && *(_WORD *)(a1 + 174) != 1)
      goto LABEL_209;
    v118 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (const void *)(v15 + 92));
    if (v118)
    {
      VTDecompressionSessionSetProperty();
      CFRelease(v118);
    }
  }
  if (*(_BYTE *)(a1 + 2368))
  {
LABEL_209:
    sub_1B6771DF8(Mutable, (const void *)*MEMORY[0x1E0CED308], v147);
    goto LABEL_212;
  }
  v119 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &v147);
  if (v119)
  {
    VTDecompressionSessionSetProperty();
    CFRelease(v119);
  }
LABEL_212:
  if ((*(_DWORD *)(v15 + 92) - 1) <= 2)
  {
    v121 = *(_DWORD *)(v15 + 96);
    v120 = *(_DWORD *)(v15 + 100);
    *((_QWORD *)&v143 + 1) = __PAIR64__(v121, v120);
    if (!v121 || !v120)
    {
      v122 = *(_DWORD *)(a1 + 112);
      DWORD2(v143) = *(_DWORD *)(a1 + 116);
      HIDWORD(v143) = v122;
    }
    v123 = *MEMORY[0x1E0CED438];
    *(_QWORD *)&v154[8] = *MEMORY[0x1E0CED440];
    *(_QWORD *)&v154[16] = v123;
    *(_QWORD *)&v152[8] = 0;
    *(_QWORD *)&v152[16] = 0;
    v124 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    *(_QWORD *)&v152[8] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (char *)&v143 + 12);
    v125 = CFNumberCreate(v124, kCFNumberIntType, (char *)&v143 + 8);
    *(_QWORD *)&v152[16] = v125;
    v126 = *(const void **)&v152[8];
    if (*(_QWORD *)&v152[8] && v125)
    {
      v127 = CFDictionaryCreate(v124, (const void **)&v154[8], (const void **)&v152[8], 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v127)
      {
        if (*(_BYTE *)(a1 + 2368))
          CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CED2D8], v127);
        else
          VTDecompressionSessionSetProperty();
        CFRelease(v127);
      }
      v126 = *(const void **)&v152[8];
    }
    if (v126)
      CFRelease(v126);
    if (*(_QWORD *)&v152[16])
      CFRelease(*(CFTypeRef *)&v152[16]);
  }
  if (*(_QWORD *)(a1 + 2240) || (v28 = VTDecompressionSessionCopyProperty(), !(_DWORD)v28))
  {
    v87 = BYTE4(v136);
LABEL_230:
    if ((v87 & 1) != 0)
    {
      if (!*(_BYTE *)(*(_QWORD *)v132 + 80))
      {
        kdebug_trace();
        if (v95)
          VTDecompressionSessionWaitForAsynchronousFrames(*(VTDecompressionSessionRef *)(a1 + 16));
        goto LABEL_235;
      }
      if (qword_1EF138CA8[0] != -1)
        dispatch_once_f(qword_1EF138CA8, 0, (dispatch_function_t)nullsub_7);
    }
    kdebug_trace();
LABEL_235:
    v28 = VTDecompressionSessionDecodeFrameWithOptions();
    kdebug_trace();
  }
LABEL_236:
  if ((_QWORD)v144)
    CFRelease((CFTypeRef)v144);
  if (Mutable)
    CFRelease(Mutable);
  kdebug_trace();
  if (v15 && (_DWORD)v28)
  {
    v128 = *(_QWORD *)(v15 + 120);
    if (v128)
      (*(void (**)(uint64_t))(*(_QWORD *)v128 + 8))(v128);
    *(_QWORD *)(v15 + 120) = 0;
    sub_1B67705C8((const void **)(v15 + 152));
    MEMORY[0x1BCC9814C](v15, 0x10A0C40B5D84229);
  }
  return v28;
}

void sub_1B679B8CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49)
{
  if (a49)
    free(a49);
  _Unwind_Resume(exception_object);
}

const __CFNumber *sub_1B679B914(const __CFDictionary *a1, void *a2)
{
  const __CFNumber *result;
  const __CFNumber *v4;
  CFTypeID v5;

  result = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("TileOrder"));
  if (result)
  {
    v4 = result;
    v5 = CFGetTypeID(result);
    result = (const __CFNumber *)CFNumberGetTypeID();
    if ((const __CFNumber *)v5 == result)
      return (const __CFNumber *)CFNumberGetValue(v4, kCFNumberSInt16Type, a2);
  }
  return result;
}

uint64_t sub_1B679B97C(uint64_t a1, uint64_t a2, CMSampleBufferRef *a3)
{
  OpaqueCMBlockBuffer *DataBuffer;
  int v7;
  int v8;
  BOOL v9;
  int v10;
  uint64_t v12;
  uint64_t appended;
  size_t v14;
  int v15;
  _QWORD *v16;
  int v17;
  _BYTE *v18;
  uint8_t v20[16];
  size_t offsetToData;
  size_t v22;
  uint64_t v23;
  CMBlockBufferRef blockBufferOut;

  v23 = 0;
  blockBufferOut = 0;
  offsetToData = 0;
  v22 = 0;
  DataBuffer = CMSampleBufferGetDataBuffer(*a3);
  v7 = 0;
  v8 = *(_DWORD *)(a1 + 24);
  if (v8 > 1718908519)
  {
    v9 = v8 == 1718908520;
    v10 = 1752589105;
  }
  else
  {
    v9 = v8 == 1684632424;
    v10 = 1685481521;
  }
  if (!v9 && v8 != v10)
    v7 = 1;
  v12 = sub_1B685CADC(*(_QWORD *)(a2 + 120), *(_QWORD *)(a1 + 2288), v7, DataBuffer, &v23, &v22, &offsetToData, 1);
  if ((_DWORD)v12)
  {
    appended = v12;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v20 = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VCPDecompressionControlByteProcessing: ParseControlByteFromBuffer failed ", v20, 2u);
    }
  }
  else
  {
    if (!v23
      || (appended = CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E0C9AE00], DataBuffer, 0, offsetToData - v23, 0, &blockBufferOut), !(_DWORD)appended)&& ((v14 = offsetToData, v14 >= CMBlockBufferGetDataLength(DataBuffer))|| (appended = CMBlockBufferAppendBufferReference(blockBufferOut, DataBuffer, offsetToData, 0, 0), !(_DWORD)appended))&& (appended = sub_1B6786C00(a3, blockBufferOut), !(_DWORD)appended))
    {
      v15 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 120) + 16))(*(_QWORD *)(a2 + 120));
      v16 = *(_QWORD **)(a2 + 120);
      if (v15)
      {
        *(_QWORD *)(a2 + 96) = v16[1];
        *(_DWORD *)(a2 + 92) = 3;
      }
      v17 = (*(uint64_t (**)(_QWORD *))(*v16 + 88))(v16);
      v18 = *(_BYTE **)(a2 + 120);
      if (v17)
        *(_BYTE *)(a2 + 14) = v18[96];
      appended = 0;
      if ((*(unsigned int (**)(_BYTE *))(*(_QWORD *)v18 + 96))(v18))
        *(_DWORD *)(a1 + 176) = *(_DWORD *)(*(_QWORD *)(a2 + 120) + 98);
    }
    if (blockBufferOut)
      CFRelease(blockBufferOut);
  }
  return appended;
}

const void **sub_1B679BB88(__CFDictionary *a1, __int16 a2)
{
  CFNumberRef v3;
  __int16 valuePtr;
  CFNumberRef v6;

  valuePtr = a2;
  v3 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  v6 = v3;
  if (v3)
    CFDictionarySetValue(a1, CFSTR("FrameChecksum"), v3);
  return sub_1B6770598((const void **)&v6);
}

void sub_1B679BBE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1B6770598((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t VCPDecompressionSessionCopyProperty(uint64_t a1)
{
  if (a1)
    return VTDecompressionSessionCopyProperty();
  else
    return 4294954394;
}

uint64_t VCPDecompressionSessionWaitForAsynchronousFrames(uint64_t a1)
{
  return VTDecompressionSessionWaitForAsynchronousFrames(*(VTDecompressionSessionRef *)(a1 + 16));
}

uint64_t VCPDecompressionSessionFinishDelayedFrames(uint64_t a1)
{
  return VTDecompressionSessionFinishDelayedFrames(*(VTDecompressionSessionRef *)(a1 + 16));
}

uint64_t VCPDecompressionSessionCopyBlackPixelBuffer(uint64_t a1, CVPixelBufferRef *a2)
{
  return VTDecompressionSessionCopyBlackPixelBuffer(*(VTDecompressionSessionRef *)(a1 + 16), a2);
}

uint64_t VCPDecompressionSessionCopySupportedPropertyDictionary()
{
  return VTDecompressionSessionCopySupportedPropertyDictionary();
}

uint64_t VCPDecompressionSessionSetProperties()
{
  return VTDecompressionSessionSetProperties();
}

uint64_t VCPDecompressionSessionCopySerializableProperties()
{
  return VTDecompressionSessionCopySerializableProperties();
}

uint64_t VCPDecompressionSessionCheckIfLastSubFrame(uint64_t a1, OpaqueCMBlockBuffer *a2, _BYTE *a3)
{
  uint64_t v4;
  int v7;
  char *v8;
  char *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  const char *v14;
  int v15;
  uint64_t v16;
  int v18;
  const char *v19;
  int v20;
  int v21;
  const char *v22;
  int v23;
  NSObject *v24;
  const char *v25;
  uint64_t v26;
  uint8_t buf[4];
  uint64_t v28;
  __int16 v29;
  const char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v26 = 0;
  if (!a1)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      return 4294954394;
    v14 = "NA";
    goto LABEL_37;
  }
  v4 = *(_QWORD *)(a1 + 2288);
  if (!v4 || (v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 88))(v4), !a3) || !a2 || !v7)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      return 4294954394;
    v13 = *(_DWORD *)(a1 + 24);
    v14 = "H.264";
    if (v13 > 1718908519)
    {
      if (v13 != 1752589105)
      {
        v15 = 1718908520;
LABEL_35:
        if (v13 == v15)
          goto LABEL_36;
LABEL_37:
        *(_DWORD *)buf = 134218242;
        v28 = a1;
        v29 = 2080;
        v30 = v14;
        v24 = MEMORY[0x1E0C81028];
        v25 = "VCPDec %p (%s) VCPDecompressionSessionCheckIfLastSubFrame incorrect parameter";
LABEL_38:
        _os_log_error_impl(&dword_1B676B000, v24, OS_LOG_TYPE_ERROR, v25, buf, 0x16u);
        return 4294954394;
      }
    }
    else if (v13 != 1684632424)
    {
      v15 = 1685481521;
      goto LABEL_35;
    }
LABEL_36:
    v14 = "HEVC";
    goto LABEL_37;
  }
  v8 = sub_1B685C8CC(*(char **)(a1 + 2288));
  if (v8)
  {
    v9 = v8;
    v10 = 0;
    v11 = *(_DWORD *)(a1 + 24);
    if (v11 > 1718908519)
    {
      if (v11 == 1718908520)
        goto LABEL_25;
      v12 = 1752589105;
    }
    else
    {
      if (v11 == 1684632424)
        goto LABEL_25;
      v12 = 1685481521;
    }
    if (v11 != v12)
      v10 = 1;
LABEL_25:
    v16 = sub_1B685CADC((uint64_t)v8, *(_QWORD *)(a1 + 2288), v10, a2, &v26, 0, 0, 0);
    if ((_DWORD)v16)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v21 = *(_DWORD *)(a1 + 24);
        v22 = "H.264";
        if (v21 > 1718908519)
        {
          if (v21 == 1752589105)
            goto LABEL_42;
          v23 = 1718908520;
        }
        else
        {
          if (v21 == 1684632424)
            goto LABEL_42;
          v23 = 1685481521;
        }
        if (v21 != v23)
        {
LABEL_43:
          *(_DWORD *)buf = 134218242;
          v28 = a1;
          v29 = 2080;
          v30 = v22;
          _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VCPDec %p (%s) VCPDecompressionSessionCheckIfLastSubFrame ParseControlByteFromBuffer failed", buf, 0x16u);
          goto LABEL_31;
        }
LABEL_42:
        v22 = "HEVC";
        goto LABEL_43;
      }
    }
    else
    {
      *a3 = v9[96];
    }
LABEL_31:
    (*(void (**)(char *))(*(_QWORD *)v9 + 8))(v9);
    return v16;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v18 = *(_DWORD *)(a1 + 24);
    v19 = "H.264";
    if (v18 > 1718908519)
    {
      if (v18 == 1752589105)
        goto LABEL_47;
      v20 = 1718908520;
    }
    else
    {
      if (v18 == 1684632424)
        goto LABEL_47;
      v20 = 1685481521;
    }
    if (v18 != v20)
    {
LABEL_48:
      *(_DWORD *)buf = 134218242;
      v28 = a1;
      v29 = 2080;
      v30 = v19;
      v24 = MEMORY[0x1E0C81028];
      v25 = "VCPDec %p (%s) Failed to create ControlByte";
      goto LABEL_38;
    }
LABEL_47:
    v19 = "HEVC";
    goto LABEL_48;
  }
  return 4294954394;
}

void VPModuleInitialize()
{
  if (qword_1EDBB4C38 != -1)
    dispatch_once(&qword_1EDBB4C38, &unk_1E6A16A60);
}

void sub_1B679BFE8()
{
  sub_1B6776074(1718908515, 1000, 0, -1);
  sub_1B6776074(1635148593, -1, CFSTR("com.apple.videotoolbox.videoencoder.h264.rtvc"), 0);
  sub_1B6776074(1752589105, -1, CFSTR("com.apple.videotoolbox.videoencoder.hevc.rtvc"), 0);
  if (qword_1EDBB4CB8 != -1)
    dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
  if (dword_1EDBB4CC4 >= 9)
    sub_1B6776074(1718908520, 1000, 0, -1);
}

uint64_t sub_1B679C0B0()
{
  void *v0;
  void *v1;
  void *v2;
  uint64_t v3;

  objc_msgSend(MEMORY[0x1E0D20C20], "sharedInstance");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  if ((objc_msgSend(v0, "isLoaded") & 1) != 0)
  {
    objc_msgSend(v0, "objectForKey:", CFSTR("vc-disable-lowdelayB"));
    v1 = (void *)objc_claimAutoreleasedReturnValue();
    v2 = v1;
    if (v1)
      v3 = objc_msgSend(v1, "BOOLValue");
    else
      v3 = 0;
  }
  else
  {
    v3 = 0;
    v2 = 0;
  }

  return v3;
}

void sub_1B679C140(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B679C1B8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B679C4D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B679C6CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B679C8F0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B679CA2C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B679CCE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  v13 = v11;

  _Unwind_Resume(a1);
}

void sub_1B679CE70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B679D280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

const void **sub_1B679D378(uint64_t *a1, VTPixelTransferSessionRef *a2, CVPixelBufferRef pixelBuffer, int *a4, int *a5)
{
  OSType PixelFormatType;
  size_t Width;
  size_t Height;
  int v12;
  double v13;
  int v14;
  double v15;
  __CVBuffer *v16;
  CVBufferRef *v17;
  __CFDictionary *Mutable;
  const __CFAllocator *v19;
  CFDictionaryRef DictionaryRepresentation;
  CFDictionaryRef v21;
  int v22;
  const void *v23;
  uint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  CFDictionaryRef propertyValue;
  CFMutableDictionaryRef value;
  const void *v31;
  const void *propertyValueOut;
  const void *v33;
  uint8_t buf[8];
  CGRect v35;
  CGRect v36;
  CGRect v37;

  propertyValueOut = 0;
  PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
  Width = CVPixelBufferGetWidth(pixelBuffer);
  Height = CVPixelBufferGetHeight(pixelBuffer);
  v12 = *a4;
  v35.origin.x = (double)*a4;
  v13 = (double)a4[1];
  v14 = *a5;
  v15 = (double)a5[1];
  v35.origin.y = v13;
  v35.size.width = (double)*a5;
  v35.size.height = v15;
  propertyValue = CGRectCreateDictionaryRepresentation(v35);
  if (!*a2 && VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2))
    goto LABEL_29;
  v17 = a2 + 1;
  v16 = a2[1];
  if (v16)
  {
    if (Width == CVPixelBufferGetWidth(v16) && Height == CVPixelBufferGetHeight(*v17))
    {
      if (*v17)
      {
        value = 0;
        Mutable = 0;
LABEL_12:
        if (PixelFormatType == 1882468912 && (v22 = v12 % 6, v12 % 6 >= 1))
        {
          v36.origin.x = (double)(v12 - v22);
          v36.size.width = (double)(v14 + v22);
          v36.origin.y = v13;
          v36.size.height = v15;
          propertyValue = CGRectCreateDictionaryRepresentation(v36);
          v37.origin.x = (double)v22;
          v37.origin.y = 0.0;
          v37.size.width = (double)v14;
          v37.size.height = v15;
          DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v37);
          v21 = propertyValue;
        }
        else
        {
          DictionaryRepresentation = 0;
          v21 = 0;
        }
        VTSessionSetProperty(*a2, (CFStringRef)*MEMORY[0x1E0CED850], propertyValue);
        VTSessionSetProperty(*a2, (CFStringRef)*MEMORY[0x1E0CED7D0], propertyValue);
        VTSessionSetProperty(*a2, (CFStringRef)*MEMORY[0x1E0CED810], (CFTypeRef)*MEMORY[0x1E0C9AE50]);
        VTSessionSetProperty(*a2, (CFStringRef)*MEMORY[0x1E0CED820], DictionaryRepresentation);
        CVBufferPropagateAttachments(pixelBuffer, *v17);
        if (!VTPixelTransferSessionTransferImage(*a2, pixelBuffer, a2[1]))
        {
          VTSessionCopyProperty(*a2, (CFStringRef)*MEMORY[0x1E0CED818], (CFAllocatorRef)*MEMORY[0x1E0C9AE00], &propertyValueOut);
          if (propertyValueOut)
          {
            CVBufferSetAttachment(*v17, CFSTR("histogram"), propertyValueOut, kCVAttachmentMode_ShouldPropagate);
          }
          else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Error: Empty histogram data\n", buf, 2u);
          }
        }
        goto LABEL_21;
      }
    }
    else
    {
      CFRelease(*v17);
      *v17 = 0;
    }
  }
  v19 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  value = CFDictionaryCreateMutable(v19, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA8FF0], value);
  if (!CVPixelBufferCreate(v19, Width, Height, PixelFormatType, Mutable, a2 + 1))
    goto LABEL_12;
  DictionaryRepresentation = 0;
  v21 = 0;
LABEL_21:
  if (Mutable)
    CFRelease(Mutable);
  if (value)
    CFRelease(value);
  if (v21)
    CFRelease(v21);
  if (DictionaryRepresentation)
    CFRelease(DictionaryRepresentation);
LABEL_29:
  v23 = propertyValueOut;
  if (propertyValueOut)
    CFRetain(propertyValueOut);
  v31 = 0;
  v33 = 0;
  *(_QWORD *)buf = v23;
  v24 = operator new();
  *(_QWORD *)(v24 + 8) = 0;
  v25 = (unint64_t *)(v24 + 8);
  *(_QWORD *)(v24 + 16) = 0;
  *(_QWORD *)(v24 + 24) = 850045863;
  *(_OWORD *)(v24 + 32) = 0u;
  *(_OWORD *)(v24 + 48) = 0u;
  *(_OWORD *)(v24 + 64) = 0u;
  *(_QWORD *)(v24 + 80) = 0;
  *(_QWORD *)(v24 + 88) = 1018212795;
  *(_OWORD *)(v24 + 96) = 0u;
  *(_OWORD *)(v24 + 112) = 0u;
  *(_QWORD *)(v24 + 128) = 0;
  *(_QWORD *)v24 = &off_1E6A14700;
  *(_QWORD *)(v24 + 152) = *(_QWORD *)buf;
  *(_QWORD *)buf = 0;
  *(_DWORD *)(v24 + 136) = 8;
  *a1 = v24;
  sub_1B67804AC(v24);
  do
    v26 = __ldaxr(v25);
  while (__stlxr(v26 - 1, v25));
  if (!v26)
    (*(void (**)(uint64_t))(*(_QWORD *)v24 + 16))(v24);
  sub_1B67704D8((const void **)buf);
  sub_1B67704D8(&v33);
  sub_1B67704D8(&v31);
  return sub_1B67704D8(&propertyValueOut);
}

void sub_1B679D7C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  sub_1B67704D8((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1B679D838(uint64_t a1)
{
  std::mutex *v2;

  *(_QWORD *)a1 = &off_1E6A14700;
  v2 = (std::mutex *)(a1 + 24);
  sub_1B67704D8((const void **)(a1 + 152));
  *(_QWORD *)a1 = MEMORY[0x1E0DE4FC8] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex(v2);
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_1B679D8A4(uint64_t a1)
{
  std::mutex *v2;

  *(_QWORD *)a1 = &off_1E6A14700;
  v2 = (std::mutex *)(a1 + 24);
  sub_1B67704D8((const void **)(a1 + 152));
  *(_QWORD *)a1 = MEMORY[0x1E0DE4FC8] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex(v2);
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
  JUMPOUT(0x1BCC9814CLL);
}

const void **sub_1B679D924(uint64_t a1)
{
  const void *v2;
  const void *v4;

  v2 = *(const void **)(a1 + 152);
  v4 = v2;
  if (v2)
    CFRetain(v2);
  sub_1B6780D7C(a1, &v4);
  return sub_1B67704D8(&v4);
}

void sub_1B679D96C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  std::__assoc_sub_state *v10;
  std::exception_ptr v11;

  __cxa_begin_catch(a1);
  std::current_exception();
  v11.__ptr_ = &a9;
  std::__assoc_sub_state::set_exception(v10, v11);
  std::exception_ptr::~exception_ptr((std::exception_ptr *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x1B679D95CLL);
}

void sub_1B679D9AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception_ptr a9)
{
  std::exception_ptr::~exception_ptr(&a9);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

const UInt8 *sub_1B679D9C8(const UInt8 *result, CFDataRef theData, unsigned int a3)
{
  const UInt8 *v4;
  unsigned int v5;
  const UInt8 *v6;
  uint64_t v7;
  float32x4_t *v8;
  float32x4_t *v9;
  uint64_t v10;
  float v11;
  uint32x4_t v12;
  uint32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  const UInt8 *v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;

  if (theData)
  {
    v4 = result;
    v5 = 1 << a3;
    v6 = &result[4 * *((unsigned int *)result + 2052)];
    *((_DWORD *)v6 + 2048) = 0;
    *((_DWORD *)v6 + 2050) = 0;
    result = CFDataGetBytePtr(theData);
    v7 = *((unsigned int *)v4 + 2052);
    if (a3 >= 3)
    {
      v8 = (float32x4_t *)&v4[4096 * v7];
      v9 = (float32x4_t *)&v4[4096 * (unint64_t)*((unsigned int *)v4 + 2053)];
      LODWORD(v10) = v5 >> 3;
      if (v5 >> 3 <= 1)
        v10 = 1;
      else
        v10 = v10;
      v11 = 0.0;
      do
      {
        v13 = *(uint32x4_t *)result;
        v12 = *((uint32x4_t *)result + 1);
        result += 32;
        v14 = vcvtq_f32_u32(v13);
        v15 = vcvtq_f32_u32(v12);
        *v8 = v14;
        v8[1] = v15;
        v16 = (int8x16_t)vaddq_f32(v14, v15);
        v7 = *((unsigned int *)v4 + 2052);
        v17 = &v4[4 * v7];
        *((float *)v17 + 2048) = *((float *)v17 + 2048)
                               + vaddv_f32(vadd_f32(*(float32x2_t *)v16.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL)));
        v18 = (int8x16_t)vaddq_f32(vmulq_f32(*v8, *v8), vmulq_f32(v8[1], v8[1]));
        *((float *)v17 + 2050) = *((float *)v17 + 2050)
                               + vaddv_f32(vadd_f32(*(float32x2_t *)v18.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL)));
        v19 = *v8;
        v20 = v8[1];
        v8 += 2;
        v21 = *v9;
        v22 = v9[1];
        v9 += 2;
        v23 = (int8x16_t)vaddq_f32(vmulq_f32(v19, v21), vmulq_f32(v20, v22));
        v11 = v11 + vaddv_f32(vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL)));
        --v10;
      }
      while (v10);
    }
    *((_DWORD *)v4 + 2053) = v7;
    *((_DWORD *)v4 + 2052) = v7 ^ 1;
  }
  return result;
}

void sub_1B679DB94(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B679DE1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  sub_1B6773B7C((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1B679E0F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  va_list va;

  va_start(va, a12);

  sub_1B67704D8((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1B679E1F0(uint64_t a1)
{
  sub_1B67704D8((const void **)(a1 + 24));

  return a1;
}

void sub_1B679E228(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E6A146D0;
  sub_1B67704D8((const void **)(a1 + 176));

  *(_QWORD *)a1 = MEMORY[0x1E0DE4FC8] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_1B679E290(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E6A146D0;
  sub_1B67704D8((const void **)(a1 + 176));

  *(_QWORD *)a1 = MEMORY[0x1E0DE4FC8] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);
  JUMPOUT(0x1BCC9814CLL);
}

const void **sub_1B679E30C(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int32x4_t *v10;
  int32x4_t v11;
  int32x4_t v12;
  int32x4_t v13;
  int32x4_t v14;
  int32x4_t v15;
  const void *v16;
  const void *v18;

  objc_msgSend(*(id *)(a1 + 152), "waitUntilCompleted");
  v2 = objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 160)), "contents");
  v3 = *(unsigned int *)(a1 + 168);
  if (v3 >= 8)
  {
    v4 = 0;
    v5 = v3 >> 3;
    v6 = 32 * (v3 >> 3);
    v7 = v2 + 96 * v5;
    v8 = v2 + (v5 << 6);
    v9 = v2 + 32 * v5;
    do
    {
      v10 = (int32x4_t *)(v2 + v4);
      v11 = vaddq_s32(*(int32x4_t *)(v2 + v4 + 16), *(int32x4_t *)(v9 + v4 + 16));
      v12 = vaddq_s32(*(int32x4_t *)(v2 + v4), *(int32x4_t *)(v9 + v4));
      *v10 = v12;
      v10[1] = v11;
      v13 = vaddq_s32(*(int32x4_t *)(v8 + v4), v12);
      v14 = vaddq_s32(*(int32x4_t *)(v8 + v4 + 16), v11);
      *v10 = v13;
      v10[1] = v14;
      v15 = vaddq_s32(*(int32x4_t *)(v7 + v4 + 16), v14);
      *v10 = vaddq_s32(*(int32x4_t *)(v7 + v4), v13);
      v10[1] = v15;
      v4 += 32;
    }
    while (v6 != v4);
  }
  v16 = *(const void **)(a1 + 176);
  v18 = v16;
  if (v16)
    CFRetain(v16);
  sub_1B6780D7C(a1, &v18);
  return sub_1B67704D8(&v18);
}

void sub_1B679E3E0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception_ptr a9, const void *a10)
{
  std::__assoc_sub_state *v10;
  std::exception_ptr v12;

  sub_1B67704D8(&a10);
  __cxa_begin_catch(a1);
  std::current_exception();
  v12.__ptr_ = &a9;
  std::__assoc_sub_state::set_exception(v10, v12);
  std::exception_ptr::~exception_ptr(&a9);
  __cxa_end_catch();
  JUMPOUT(0x1B679E3D0);
}

void sub_1B679E420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception_ptr a9)
{
  std::exception_ptr::~exception_ptr(&a9);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1B679E43C(_QWORD *a1, id *a2, uint64_t a3, _QWORD *a4, _QWORD *a5)
{
  void *v10;
  id v11;
  void *v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;

  v10 = (void *)MEMORY[0x1BCC98608]();
  v11 = *a2;
  v12 = v11;
  *(_QWORD *)&v13 = (int)*a4;
  *((_QWORD *)&v13 + 1) = (int)HIDWORD(*a4);
  v14 = v13;
  v15 = 0;
  *(_QWORD *)&v13 = (int)*a5;
  *((_QWORD *)&v13 + 1) = (int)HIDWORD(*a5);
  v16 = v13;
  v17 = 1;
  if (v11)
    objc_msgSend(v11, "generateHistogramMetal:forRegion:", a3, &v14);
  else
    *a1 = 0;

  objc_autoreleasePoolPop(v10);
}

void sub_1B679E4E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B679E558(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B679E810(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B679EA0C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B679EC30(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B679EDC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B679F2B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B679F5E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B679F734(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B679FB4C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B679FD50(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B679FF74(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B67A0080(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  sub_1B6773B7C((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1B67A0980(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,uint64_t a21,void *a22,void *a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,const void *a32)
{
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  uint64_t v37;

  sub_1B67704D8(&a32);
  sub_1B67704D8((const void **)(v37 - 136));
  sub_1B67704D8((const void **)(v37 - 128));

  _Unwind_Resume(a1);
}

void sub_1B67A0D94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

uint64_t sub_1B67A0EDC(uint32x4_t *a1, unint64_t a2)
{
  int64x2_t v2;
  int64x2_t v3;
  int64x2_t v4;
  int64x2_t v5;
  uint32x4_t v6;
  uint64x2_t v7;
  uint64x2_t v8;
  uint32x4_t v9;
  uint32x4_t v10;
  uint64_t v11;
  unsigned __int32 v12;

  v2 = 0uLL;
  if (a2 < 0x11)
  {
    if (!a2)
    {
      v11 = 0;
      v3 = 0uLL;
      v4 = 0uLL;
      v5 = 0uLL;
      return vaddvq_s64(vaddq_s64(vaddq_s64(v2, v4), vaddq_s64(v3, v5))) + v11;
    }
    v3 = 0uLL;
    v4 = 0uLL;
    v5 = 0uLL;
  }
  else
  {
    v3 = 0uLL;
    v4 = 0uLL;
    v5 = 0uLL;
    do
    {
      v6 = a1[1];
      v7 = vaddw_high_u32((uint64x2_t)v5, v6);
      v8 = vaddw_u32((uint64x2_t)v4, *(uint32x2_t *)v6.i8);
      v10 = a1[2];
      v9 = a1[3];
      v3 = (int64x2_t)vaddw_high_u32(vaddw_high_u32((uint64x2_t)v3, *a1), v10);
      v4 = (int64x2_t)vaddw_u32(v8, *(uint32x2_t *)v9.i8);
      v2 = (int64x2_t)vaddw_u32(vaddw_u32((uint64x2_t)v2, *(uint32x2_t *)a1->i8), *(uint32x2_t *)v10.i8);
      v5 = (int64x2_t)vaddw_high_u32(v7, v9);
      a1 += 4;
      a2 -= 16;
    }
    while (a2 > 0x10);
  }
  v11 = 0;
  do
  {
    v12 = a1->i32[0];
    a1 = (uint32x4_t *)((char *)a1 + 4);
    v11 += v12;
    --a2;
  }
  while (a2);
  return vaddvq_s64(vaddq_s64(vaddq_s64(v2, v4), vaddq_s64(v3, v5))) + v11;
}

uint64_t sub_1B67A0F84(int a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  const char *v6;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  VTVideoEncoderGetClassID();
  v5 = CMDerivedObjectCreate();
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    if (a1 == 1684632424 || a1 == 1752589105 || a1 == 1718908520)
      v6 = "HEVC";
    else
      v6 = "H.264";
    *(_DWORD *)buf = 136315394;
    v9 = v6;
    v10 = 1024;
    v11 = v5;
    _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: failed to create video encoder instance, err = %d\n", buf, 0x12u);
  }
  *a3 = 0;
  return v5;
}

uint64_t sub_1B67A12E8(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4)
{
  int v5;
  unint64_t v7;
  uint64_t DerivedStorage;
  const void *v9;

  v5 = a3;
  v7 = HIDWORD(a3);
  VTVideoEncoderGetCMBaseObject();
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  *(_QWORD *)DerivedStorage = a2;
  *(_DWORD *)(DerivedStorage + 340) = v5;
  *(_DWORD *)(DerivedStorage + 344) = v7;
  v9 = *(const void **)(DerivedStorage + 360);
  if (v9)
    CFRelease(v9);
  *(_QWORD *)(DerivedStorage + 360) = a4;
  if (a4)
    CFRetain(a4);
  FigFormatDescriptionRelease();
  *(_QWORD *)(DerivedStorage + 8) = 0;
  *(_DWORD *)(DerivedStorage + 1372) = 0;
  return sub_1B67C52D0(v5, v7, 0, *(_DWORD *)(DerivedStorage + 48));
}

uint64_t sub_1B67A1378(uint64_t a1, uint64_t a2, __CVBuffer *a3, CMTime *a4, __int128 *a5, uint64_t a6, _DWORD *a7)
{
  uint64_t DerivedStorage;
  __IOSurface *IOSurface;
  int v15;
  const char *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  CMTimeFlags v21;
  int v22;
  const char *v23;
  int v24;
  const char *v25;
  CFTypeRef v26;
  CFTypeRef v27;
  const void *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int IntegerCodePointForString;
  int v37;
  int v38;
  int v39;
  unsigned int v40;
  unsigned int v41;
  const char *v42;
  int v43;
  int v44;
  NSObject *v45;
  const char *v46;
  uint32_t v47;
  const float *v48;
  int32x2_t v49;
  CMTimeValue v50;
  int v51;
  _BOOL4 v53;
  uint64_t v54;
  _DWORD *v55;
  int *v56;
  int v57;
  _DWORD *v58;
  _DWORD *v59;
  int v60;
  int v61;
  uint64_t v62;
  int v64;
  int v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  __int16 v71;
  int v72;
  unsigned int v73;
  NSObject *v74;
  const char *v75;
  uint32_t v76;
  int v77;
  uint64_t v78;
  int v79;
  const char *v80;
  int v81;
  int v82;
  char *v83;
  uint64_t v84;
  int v85;
  uint64_t v86;
  int v87;
  const char *v88;
  int v89;
  const char *v90;
  int v91;
  const char *v92;
  NSObject *v93;
  const char *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  int v103;
  uint64_t v104;
  char *v105;
  _BOOL4 v106;
  uint64_t v107;
  const char *v108;
  float v109;
  uint64_t v110;
  uint64_t v111;
  char *v112;
  int v113;
  const char *v114;
  const char *v115;
  int v116;
  const char *v117;
  uint64_t v118;
  int v119;
  const char *v120;
  int v121;
  int v122;
  const char *v123;
  NSObject *v124;
  const char *v125;
  int v126;
  const char *v127;
  const char *v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  unsigned int v134;
  uint64_t v135;
  int v136;
  double v137;
  double v138;
  int v139;
  double v140;
  BOOL v141;
  const char *v142;
  id *v143;
  NSObject *v144;
  uint64_t v145;
  __int128 *v146;
  unsigned int v147;
  uint64_t v148;
  int v149;
  double v150;
  double v151;
  int v152;
  unsigned int v153;
  unsigned int v154;
  double v155;
  int v156;
  int v157;
  BOOL v158;
  const char *v159;
  uint64_t v160;
  double v161;
  double v162;
  int v163;
  int v164;
  std::__shared_weak_count *v165;
  unint64_t *v166;
  unint64_t v167;
  NSObject *v169;
  const char *v170;
  int v171;
  uint64_t v172;
  int v173;
  int v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  __int128 v178;
  CMTimeEpoch v179;
  uint64_t v180;
  unint64_t *v181;
  unint64_t v182;
  unsigned int v183;
  unsigned int v184;
  OSType PixelFormatType;
  int v186;
  __int128 *v187;
  uint64_t v188;
  _DWORD *v189;
  char *v190;
  int32x2_t *v191;
  uint64_t v192[2];
  __int128 v193;
  CMTimeEpoch v194;
  __int128 v195;
  uint64_t v196;
  __int128 v197;
  CMTimeEpoch epoch;
  uint64_t v199;
  uint64_t v200;
  uint8_t buf[4];
  _BYTE v202[32];
  _BYTE v203[6];
  int v204;
  __int16 v205;
  int v206;
  __int16 v207;
  int v208;
  __int16 v209;
  int v210;
  __int16 v211;
  int v212;
  __int16 v213;
  int v214;
  char __s[32];
  char __str[32];
  char v217[64];
  char v218[32];
  char v219[32];
  char v220[32];
  CMTime time;
  void *v222;
  _BYTE v223[12];
  char v224;
  uint64_t v225;
  int v226;
  char v227[1004];
  int v228;
  int v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  _QWORD v233[6];

  v233[3] = *MEMORY[0x1E0C80C00];
  VTVideoEncoderGetCMBaseObject();
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  v199 = 0;
  v200 = 0;
  time = *a4;
  CMTimeGetSeconds(&time);
  IOSurface = CVPixelBufferGetIOSurface(a3);
  if (IOSurface)
    IOSurfaceGetID(IOSurface);
  kdebug_trace();
  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(DerivedStorage + 1392), 0xFFFFFFFFFFFFFFFFLL);
  if (!*(_BYTE *)(DerivedStorage + 356))
  {
    v191 = (int32x2_t *)(DerivedStorage + 348);
    if (*(_QWORD *)(DerivedStorage + 1416))
    {
      if (*(int *)(DerivedStorage + 52) > 40000000)
      {
        *(_DWORD *)(DerivedStorage + 1400) = 0;
      }
      else if (v191->i32[0] >= 1
             && (v191->i32[0] & 0x7F) == 0
             && !dispatch_semaphore_wait(*(dispatch_semaphore_t *)(DerivedStorage + 1408), 0))
      {
        v17 = *(void **)(DerivedStorage + 1416);
        time.value = MEMORY[0x1E0C809B0];
        *(_QWORD *)&time.timescale = 0x40000000;
        time.epoch = (CMTimeEpoch)sub_1B67A3D54;
        v222 = &unk_1E6A16D60;
        *(_QWORD *)v223 = DerivedStorage;
        sub_1B67C2528(v17, (uint64_t)a3, 1u, 0, &time);
      }
    }
    v188 = a2;
    v189 = a7;
    v190 = (char *)operator new(0x40uLL, MEMORY[0x1E0DE4E10]);
    if (!v190)
    {
      v21 = -12904;
      goto LABEL_329;
    }
    if (!a3)
      goto LABEL_328;
    v187 = a5;
    v19 = *(_QWORD *)(DerivedStorage + 16);
    if (v19)
    {
      if (*(int *)(v19 + 3692) >= 1)
      {
        v20 = *(_QWORD *)(v19 + 13272);
        if (v20)
        {
          v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 56))(v20);
          if (v21)
          {
            if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
              goto LABEL_329;
            v22 = *(_DWORD *)(DerivedStorage + 48);
            if (v22 == 1684632424 || v22 == 1752589105 || v22 == 1718908520)
              v23 = "HEVC";
            else
              v23 = "H.264";
            LODWORD(time.value) = 136315394;
            *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)v23;
            LOWORD(time.flags) = 1024;
            *(CMTimeFlags *)((char *)&time.flags + 2) = v21;
            v93 = MEMORY[0x1E0C81028];
            v94 = "%s: video encoder is busy, err = %d\n";
LABEL_203:
            _os_log_error_impl(&dword_1B676B000, v93, OS_LOG_TYPE_ERROR, v94, (uint8_t *)&time, 0x12u);
            goto LABEL_329;
          }
        }
      }
      goto LABEL_299;
    }
    PixelFormatType = CVPixelBufferGetPixelFormatType(a3);
    v26 = CVBufferCopyAttachment(a3, (CFStringRef)*MEMORY[0x1E0CA8CE8], 0);
    v27 = CVBufferCopyAttachment(a3, (CFStringRef)*MEMORY[0x1E0CA8CE0], 0);
    v28 = v27;
    if (v26)
    {
      if (v27)
        CFEqual(v26, v27);
      CFEqual(v26, (CFTypeRef)*MEMORY[0x1E0CA8D10]);
      v29 = CFEqual(v26, (CFTypeRef)*MEMORY[0x1E0CA8D00]);
      v30 = CFEqual(v26, (CFTypeRef)*MEMORY[0x1E0CA8D20]);
      v31 = CFEqual(v26, (CFTypeRef)*MEMORY[0x1E0CA8D18]);
      v32 = CFEqual(v26, (CFTypeRef)*MEMORY[0x1E0CA8CF8]);
      v33 = CFEqual(v26, (CFTypeRef)*MEMORY[0x1E0CA8CF0]);
      v34 = v29 != 0;
      if (v30)
        v34 = 2;
      if (v31)
        v34 = 3;
      if (v32)
        v34 = 4;
      if (v33)
        v35 = 5;
      else
        v35 = v34;
      CFRelease(v26);
      if (!v28)
      {
LABEL_53:
        snprintf(__str, 0x20uLL, "%d", v35);
        IntegerCodePointForString = CVColorPrimariesGetIntegerCodePointForString(*(CFStringRef *)(DerivedStorage + 288));
        snprintf(v220, 0x20uLL, "%d", IntegerCodePointForString);
        v37 = CVTransferFunctionGetIntegerCodePointForString(*(CFStringRef *)(DerivedStorage + 296));
        snprintf(v219, 0x20uLL, "%d", v37);
        v38 = CVYCbCrMatrixGetIntegerCodePointForString(*(CFStringRef *)(DerivedStorage + 304));
        snprintf(v218, 0x20uLL, "%d", v38);
        snprintf(v217, 0x40uLL, "%d:%d", *(_DWORD *)(DerivedStorage + 332), *(_DWORD *)(DerivedStorage + 336));
        v39 = *(_DWORD *)(DerivedStorage + 48);
        v40 = *(_DWORD *)(DerivedStorage + 240);
        if (v39 == 1718908520 && (v40 > 0x2B || ((1 << v40) & 0xC4000100002) == 0))
        {
          if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
            goto LABEL_185;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)v202 = -12910;
          v45 = MEMORY[0x1E0C81028];
          v46 = "HEVC: unsupported codec type or usage, err = %d\n";
        }
        else
        {
          if (v40 != 43 || v39 == 1684632424 || v39 == 1718908520 || v39 == 1752589105)
          {
            v41 = *(_DWORD *)(DerivedStorage + 1488);
            if (v41 - 5 < 0xFFFFFFFC)
              goto LABEL_61;
            if (v41 < 2)
            {
              if (v40 != 43)
              {
                v44 = *(_DWORD *)(DerivedStorage + 344);
                v41 = 1;
                goto LABEL_85;
              }
            }
            else
            {
              if (v39 != 1684632424 && v39 != 1718908520 && v39 != 1752589105)
              {
LABEL_61:
                if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                {
                  if (v39 == 1684632424 || v39 == 1752589105 || v39 == 1718908520)
                    v42 = "HEVC";
                  else
                    v42 = "H264";
                  *(_DWORD *)buf = 67109634;
                  *(_DWORD *)v202 = v41;
                  *(_WORD *)&v202[4] = 2080;
                  *(_QWORD *)&v202[6] = v42;
                  *(_WORD *)&v202[14] = 1024;
                  *(_DWORD *)&v202[16] = -12910;
                  v45 = MEMORY[0x1E0C81028];
                  v46 = "Got numberOfSlices = %d doesn't supported by %s encoder, err = %d\n";
                  v47 = 24;
                  goto LABEL_184;
                }
LABEL_185:
                if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                  goto LABEL_186;
                v91 = *(_DWORD *)(DerivedStorage + 48);
                if (v91 == 1684632424 || v91 == 1752589105 || v91 == 1718908520)
                  v92 = "HEVC";
                else
                  v92 = "H.264";
                *(_DWORD *)buf = 136315138;
                *(_QWORD *)v202 = v92;
                v74 = MEMORY[0x1E0C81028];
                v75 = "%s: CompressParamsSetup failed\n";
                v76 = 12;
                goto LABEL_200;
              }
              if (v40 != 43)
                goto LABEL_78;
              if (v41 == 3)
              {
                v41 = 3;
LABEL_78:
                v44 = *(_DWORD *)(DerivedStorage + 344);
                if (v44 % (int)(v41 << 6))
                {
                  if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                    goto LABEL_185;
                  *(_DWORD *)buf = 67109376;
                  *(_DWORD *)v202 = v41;
                  *(_WORD *)&v202[4] = 1024;
                  *(_DWORD *)&v202[6] = v44;
                  v45 = MEMORY[0x1E0C81028];
                  v46 = "Error: number of slice = %d and picture height = %d don't meet AVE requirement!\n";
                  v47 = 14;
LABEL_184:
                  _os_log_error_impl(&dword_1B676B000, v45, OS_LOG_TYPE_ERROR, v46, buf, v47);
                  goto LABEL_185;
                }
                v40 = *(_DWORD *)(DerivedStorage + 240);
                v39 = *(_DWORD *)(DerivedStorage + 48);
LABEL_85:
                v48 = (const float *)(DerivedStorage + 228);
                v49 = (int32x2_t)vld1_dup_f32(v48);
                v50 = (CMTimeValue)vsub_s32(v49, (int32x2_t)vand_s8((int8x8_t)vadd_s32(v49, (int32x2_t)vshl_u32((uint32x2_t)vcltz_s32(v49), (uint32x2_t)0xFFFFFFE6FFFFFFE4)), (int8x8_t)0xFFFFFFC0FFFFFFF0));
                LODWORD(time.value) = v50;
                *(CMTimeValue *)((char *)&time.value + 4) = v50;
                LOBYTE(time.flags) = v40;
                *(_DWORD *)v223 = *(_DWORD *)(DerivedStorage + 52);
                v222 = *(void **)(DerivedStorage + 24);
                LOWORD(time.epoch) = v44;
                HIWORD(time.flags) = *(_DWORD *)(DerivedStorage + 340);
                v51 = *(_DWORD *)(DerivedStorage + 1380);
                v53 = v39 != 1752589105 && v39 != 1718908520;
                *(_DWORD *)&v223[4] = v53;
                *(_DWORD *)&v223[8] = 0;
                v224 = 1;
                v228 = v51;
                LODWORD(v225) = 0;
                v229 = 1;
                v231 = -1;
                v230 = -1;
                memset_pattern16(&v232, &unk_1B6918100, 0x10uLL);
                v233[1] = -1;
                v233[0] = -1;
                if (v41 >= 2)
                {
                  v229 = v41;
                  v54 = v41;
                  v55 = v233;
                  v56 = (int *)(DerivedStorage + 1524);
                  do
                  {
                    *(v55 - 8) = *(v56 - 8);
                    *(v55 - 4) = *(v56 - 4);
                    v57 = *v56++;
                    *v55++ = v57;
                    --v54;
                  }
                  while (v54);
                }
                strlcpy(v227, (const char *)(DerivedStorage + 368), 0x3E8uLL);
                if (qword_1EDBB4CB8 != -1)
                  dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
                if (dword_1EDBB4CC4 <= 0x11)
                {
                  if (((1 << dword_1EDBB4CC4) & 0x3FE00) != 0)
                  {
LABEL_98:
                    *(_DWORD *)&v223[8] = 2;
                    *(_BYTE *)(DerivedStorage + 1384) = 1;
                    goto LABEL_99;
                  }
                  if (((1 << dword_1EDBB4CC4) & 0x7C) != 0)
                  {
                    if (dword_1EF137CD0 >= 2)
                    {
                      fwrite("H6 or lower is not supported.\n", 0x1EuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
                      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "H6 or lower is not supported.\n", buf, 2u);
                      }
                    }
                    if (*(_DWORD *)&v223[8] != 1)
                    {
LABEL_99:
                      v58 = operator new(0x33F8uLL, MEMORY[0x1E0DE4E10]);
                      if (!v58)
                      {
                        *(_QWORD *)(DerivedStorage + 16) = 0;
                        v71 = -12904;
                        goto LABEL_187;
                      }
                      v59 = v58;
                      sub_1B68050D0((uint64_t)v58);
                      *(_QWORD *)(DerivedStorage + 16) = v59;
                      v59[250] = PixelFormatType;
                      v60 = sub_1B67C37F4(PixelFormatType);
                      v59[251] = v60;
                      v61 = CVYCbCrMatrixGetIntegerCodePointForString(*(CFStringRef *)(DerivedStorage + 304));
                      v62 = *(_QWORD *)(DerivedStorage + 16);
                      if (v61 != 9 && *(_DWORD *)(v62 + 1004) == 10)
                        v64 = 248;
                      else
                        v64 = v61;
                      *(_DWORD *)(v62 + 1008) = v64;
                      sub_1B680C490(v62, 0x456BDD095F7DB261, *(_DWORD *)(DerivedStorage + 248));
                      sub_1B680C408(*(_QWORD *)(DerivedStorage + 16), 0x9A91BC7C819464BDLL, *(_DWORD *)(DerivedStorage + 252));
                      v65 = *(_DWORD *)(DerivedStorage + 232);
                      if (v65)
                        sub_1B680C490(*(_QWORD *)(DerivedStorage + 16), 0x8ADD349E618BA10ELL, v65);
                      v66 = *(_DWORD *)(DerivedStorage + 236);
                      if (v66)
                        sub_1B680C490(*(_QWORD *)(DerivedStorage + 16), 0xE8DDC90A9D7C709DLL, v66);
                      if (v60 == 10)
                      {
                        v67 = *(_QWORD *)(DerivedStorage + 16);
                        buf[0] = 0;
                        sub_1B67EF12C(*(_QWORD *)(v67 + 3192), 0x8C49EF6ED9F28EA0, "10", 0, (uint64_t)buf);
                      }
                      if (!sub_1B67C3C48(PixelFormatType))
                      {
                        if (qword_1EDBB4CB8 != -1)
                          dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
                        v72 = dword_1EDBB4CC4;
                        v73 = *(_DWORD *)(DerivedStorage + 48);
                        if (v73 != 1684632424 && v73 != 1752589105 && v73 != 1718908520 || dword_1EDBB4CC4 <= 10)
                        {
                          if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                          {
LABEL_186:
                            v71 = -12910;
                            goto LABEL_187;
                          }
                          *(_DWORD *)buf = 67110144;
                          *(_DWORD *)v202 = HIBYTE(v73);
                          *(_WORD *)&v202[4] = 1024;
                          *(_DWORD *)&v202[6] = BYTE2(v73);
                          *(_WORD *)&v202[10] = 1024;
                          *(_DWORD *)&v202[12] = BYTE1(v73);
                          *(_WORD *)&v202[16] = 1024;
                          *(_DWORD *)&v202[18] = v73;
                          *(_WORD *)&v202[22] = 1024;
                          *(_DWORD *)&v202[24] = v72;
                          v74 = MEMORY[0x1E0C81028];
                          v75 = "mono chrome encoding only support HEVC on H11 and newer. Got %c%c%c%c on device %d\n";
                          v76 = 32;
LABEL_200:
                          _os_log_error_impl(&dword_1B676B000, v74, OS_LOG_TYPE_ERROR, v75, buf, v76);
                          goto LABEL_186;
                        }
                        sub_1B680C408(*(_QWORD *)(DerivedStorage + 16), 0x9D4699E02AD040AELL, 0);
                      }
                      sub_1B680C408(*(_QWORD *)(DerivedStorage + 16), 0x3B036542BE80F4D6, *(_DWORD *)(DerivedStorage + 56));
                      sub_1B680C408(*(_QWORD *)(DerivedStorage + 16), 0xDE9D01B25B989E98, *(_DWORD *)(DerivedStorage + 60));
                      sub_1B680C408(*(_QWORD *)(DerivedStorage + 16), 0xE86133FFF2272F7BLL, *(unsigned __int8 *)(DerivedStorage + 1454));
                      v68 = *(_QWORD *)(DerivedStorage + 16);
                      *(_BYTE *)(v68 + 1144) = *(_DWORD *)(DerivedStorage + 56) > 2;
                      v69 = *(_DWORD *)(DerivedStorage + 1468);
                      v70 = v69 - 1;
                      if (v69 >= 1)
                      {
                        if (v69 <= 2)
                        {
                          if (*(_DWORD *)(DerivedStorage + 1456))
                          {
                            if (dword_1EF137CD0 >= 2)
                            {
                              fprintf((FILE *)*MEMORY[0x1E0C80C10], "Number of LTR %d is too small. Disable LTR\n", v70);
                              if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                              {
                                *(_DWORD *)buf = 67109120;
                                *(_DWORD *)v202 = v70;
                                _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Number of LTR %d is too small. Disable LTR\n", buf, 8u);
                              }
                            }
                            v70 = 0;
                            *(_DWORD *)(DerivedStorage + 1456) = 0;
                            v69 = *(_DWORD *)(DerivedStorage + 1468);
                            v68 = *(_QWORD *)(DerivedStorage + 16);
                          }
                          else
                          {
                            v70 = 0;
                          }
                        }
                        if (v69 + 1 < *(char *)(v68 + 3332))
                          v77 = v69 + 1;
                        else
                          v77 = *(char *)(v68 + 3332);
                        snprintf(__s, 0x20uLL, "%d:%d:%d:%d", v69 - v70, v70, 1, 1);
                        if (dword_1EF137CD0 >= 2)
                        {
                          fprintf((FILE *)*MEMORY[0x1E0C80C10], "setting reference %s\n", __s);
                          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                          {
                            *(_DWORD *)buf = 136315138;
                            *(_QWORD *)v202 = __s;
                            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "setting reference %s\n", buf, 0xCu);
                          }
                        }
                        v78 = *(_QWORD *)(DerivedStorage + 16);
                        buf[0] = 0;
                        sub_1B67EF12C(*(_QWORD *)(v78 + 3192), 0x89E9C01960F4C582, __s, 0, (uint64_t)buf);
                        sub_1B680C408(*(_QWORD *)(DerivedStorage + 16), 0x38D9AFB7AB26693ALL, v77);
                        v68 = *(_QWORD *)(DerivedStorage + 16);
                      }
                      sub_1B680C490(v68, 0xBE39025BC18BBD08, *(_DWORD *)(DerivedStorage + 1456));
                      v71 = sub_1B680C1A8(*(_QWORD *)(DerivedStorage + 16), (uint64_t)&time);
                      if (v71)
                      {
                        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                        {
                          v79 = *(_DWORD *)(DerivedStorage + 48);
                          if (v79 == 1684632424 || v79 == 1752589105 || v79 == 1718908520)
                            v80 = "HEVC";
                          else
                            v80 = "H.264";
                          *(_DWORD *)buf = 136315138;
                          *(_QWORD *)v202 = v80;
                          v124 = MEMORY[0x1E0C81028];
                          v125 = "%s: ParseCompressParams failed\n";
                          goto LABEL_372;
                        }
                        goto LABEL_187;
                      }
                      sub_1B680BC40(*(_QWORD *)(DerivedStorage + 16), *(CFStringRef *)(DerivedStorage + 1480));
                      v81 = *(_DWORD *)(DerivedStorage + 1448);
                      if (v81 != -1)
                        sub_1B680C408(*(_QWORD *)(DerivedStorage + 16), 0xDA7CA283D396F91BLL, v81 != 0);
                      v82 = *(_DWORD *)(DerivedStorage + 1424);
                      if (v82 == 8)
                      {
                        v83 = "low";
                      }
                      else
                      {
                        if (v82)
                          goto LABEL_168;
                        v83 = "medium";
                      }
                      v84 = *(_QWORD *)(DerivedStorage + 16);
                      buf[0] = 0;
                      sub_1B67EF12C(*(_QWORD *)(v84 + 3192), 0xF5B6EA8C35AC1E89, v83, 0, (uint64_t)buf);
LABEL_168:
                      if ((int)PixelFormatType > 1278226735)
                      {
                        if (PixelFormatType == 1278226736 || PixelFormatType == 2019963440)
                          goto LABEL_176;
                        v85 = 1751411059;
                      }
                      else
                      {
                        if (PixelFormatType == 875704422 || PixelFormatType == 875836518)
                          goto LABEL_176;
                        v85 = 1278226488;
                      }
                      if (PixelFormatType != v85)
                      {
LABEL_206:
                        v95 = *(_QWORD *)(DerivedStorage + 16);
                        buf[0] = 0;
                        sub_1B67EF12C(*(_QWORD *)(v95 + 3192), 0xEADA4767E797268BLL, __str, 0, (uint64_t)buf);
                        v96 = *(_QWORD *)(DerivedStorage + 16);
                        buf[0] = 0;
                        sub_1B67EF12C(*(_QWORD *)(v96 + 3192), 0x9FFE593DC10E7CC4, v220, 0, (uint64_t)buf);
                        v97 = *(_QWORD *)(DerivedStorage + 16);
                        buf[0] = 0;
                        sub_1B67EF12C(*(_QWORD *)(v97 + 3192), 0x2660BA38B42FDFB5, v219, 0, (uint64_t)buf);
                        v98 = *(_QWORD *)(DerivedStorage + 16);
                        buf[0] = 0;
                        sub_1B67EF12C(*(_QWORD *)(v98 + 3192), 0xE961BACE8A163BCBLL, v218, 0, (uint64_t)buf);
                        v99 = *(_QWORD *)(DerivedStorage + 16);
                        buf[0] = 0;
                        sub_1B67EF12C(*(_QWORD *)(v99 + 3192), 0x4179B3C137C3CEB0, v217, 0, (uint64_t)buf);
                        v100 = *(_DWORD *)(DerivedStorage + 48);
                        if (v100 != 1684632424 && v100 != 1718908520 && v100 != 1752589105)
                          sub_1B680C490(*(_QWORD *)(DerivedStorage + 16), 0xF890AF2C24C4A032, *(_DWORD *)(DerivedStorage + 328));
                        v101 = *(_QWORD *)(DerivedStorage + 1440);
                        if (v101)
                        {
                          CFRetain(*(CFTypeRef *)(DerivedStorage + 1440));
                          *(_QWORD *)(*(_QWORD *)(DerivedStorage + 16) + 1112) = v101;
                        }
                        if (PixelFormatType == 1982882104)
                        {
                          v102 = *(_QWORD *)(DerivedStorage + 16);
                          *(_BYTE *)(v102 + 1016) = 1;
                          sub_1B680C408(v102, 0x8ADD349E618BA10ELL, 1);
                          v103 = CFEqual(*(CFTypeRef *)(DerivedStorage + 1472), (CFTypeRef)*MEMORY[0x1E0CECE88]);
                          v104 = *(_QWORD *)(DerivedStorage + 16);
                          v105 = v103 ? "straight" : "premultiplied";
                          buf[0] = 0;
                          sub_1B67EF12C(*(_QWORD *)(v104 + 3192), 0xDA3A876E9663D9D3, v105, 0, (uint64_t)buf);
                          v106 = v103 != 0;
                          v107 = *(_QWORD *)(DerivedStorage + 16);
                          *(_DWORD *)(v107 + 1020) = v106;
                          if (dword_1EF137CD0 >= 3 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                          {
                            if (*(_DWORD *)(v107 + 11004))
                              v108 = "Straight";
                            else
                              v108 = "Premultiplied";
                            *(_DWORD *)buf = 136315138;
                            *(_QWORD *)v202 = v108;
                            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "InitEncoder: Alpha encoding for input format v0a8 and forced main profile, alpha channel mode = %s\n", buf, 0xCu);
                          }
                        }
                        if (*(_BYTE *)(DerivedStorage + 1540))
                        {
                          if (PixelFormatType != 1751411059)
                          {
                            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                            {
                              v126 = *(_DWORD *)(DerivedStorage + 48);
                              if (v126 == 1684632424 || v126 == 1752589105 || v126 == 1718908520)
                                v127 = "HEVC";
                              else
                                v127 = "H.264";
                              *(_DWORD *)buf = 136316162;
                              *(_QWORD *)v202 = v127;
                              *(_WORD *)&v202[8] = 1024;
                              *(_DWORD *)&v202[10] = HIBYTE(PixelFormatType);
                              *(_WORD *)&v202[14] = 1024;
                              *(_DWORD *)&v202[16] = BYTE2(PixelFormatType);
                              *(_WORD *)&v202[20] = 1024;
                              *(_DWORD *)&v202[22] = BYTE1(PixelFormatType);
                              *(_WORD *)&v202[26] = 1024;
                              *(_DWORD *)&v202[28] = PixelFormatType;
                              _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: Disparity encoder expected input format 'hdis' but got '%c%c%c%c'\n", buf, 0x24u);
                            }
                            v71 = -12902;
                            goto LABEL_187;
                          }
                          sub_1B680C408(*(_QWORD *)(DerivedStorage + 16), 0xC86457BBA942E4AALL, 1);
                          sub_1B680C408(*(_QWORD *)(DerivedStorage + 16), 0x9D4699E02AD040AELL, 0);
                          v109 = *(float *)(DerivedStorage + 1544);
                          if (v109 >= 0.0 && *(float *)(DerivedStorage + 1548) >= 0.0)
                          {
                            sub_1B680C518(*(_QWORD *)(DerivedStorage + 16), 0xDE0ED602D6B626A9, v109);
                            sub_1B680C518(*(_QWORD *)(DerivedStorage + 16), 0xDDF3C802D69F4727, *(float *)(DerivedStorage + 1548));
                          }
                        }
                        v110 = *(_QWORD *)(DerivedStorage + 1552);
                        v111 = *(_QWORD *)(DerivedStorage + 16);
                        *(_QWORD *)(v111 + 1176) = v110;
                        v112 = (char *)(v111 + 1184);
                        v113 = *(_DWORD *)(DerivedStorage + 48);
                        if (v113 == 1684632424 || v113 == 1752589105 || v113 == 1718908520)
                          v114 = "HEVC";
                        else
                          v114 = "H.264";
                        if (*(_DWORD *)(v111 + 1004) == 8)
                          v115 = "SDR";
                        else
                          v115 = "HDR";
                        snprintf(v112, 0x7D0uLL, "CallerID 0x%llx (%dx%d, %s, %s)", v110, *(_DWORD *)(DerivedStorage + 340), *(_DWORD *)(DerivedStorage + 344), v114, v115);
                        v71 = sub_1B680C5A0(*(char ***)(DerivedStorage + 16));
                        if (v71)
                        {
                          if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                            goto LABEL_187;
                          v116 = *(_DWORD *)(DerivedStorage + 48);
                          if (v116 == 1684632424 || v116 == 1752589105 || v116 == 1718908520)
                            v117 = "HEVC";
                          else
                            v117 = "H.264";
                          *(_DWORD *)buf = 136315138;
                          *(_QWORD *)v202 = v117;
                          v124 = MEMORY[0x1E0C81028];
                          v125 = "%s: Encoder initialization failed\n";
LABEL_372:
                          _os_log_error_impl(&dword_1B676B000, v124, OS_LOG_TYPE_ERROR, v125, buf, 0xCu);
                          goto LABEL_187;
                        }
                        v118 = *(_QWORD *)(DerivedStorage + 16);
                        *(_QWORD *)(v118 + 13288) = sub_1B67A3DAC;
                        *(_QWORD *)(v118 + 13296) = DerivedStorage;
                        if (*(_BYTE *)(DerivedStorage + 1384)
                          || (v121 = sub_1B67A4B18(DerivedStorage), v71 = v121, !v121))
                        {
                          if (dword_1EF137CD0 >= 3 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                          {
                            v119 = *(_DWORD *)(DerivedStorage + 48);
                            if (v119 == 1684632424 || v119 == 1752589105 || v119 == 1718908520)
                              v120 = "HEVC";
                            else
                              v120 = "H.264";
                            v128 = "sw";
                            v129 = *(_DWORD *)(DerivedStorage + 340);
                            v130 = *(_DWORD *)(DerivedStorage + 344);
                            if (*(_DWORD *)&v223[8] == 2)
                              v128 = "hw";
                            v131 = *(_DWORD *)(*(_QWORD *)(DerivedStorage + 16) + 1004);
                            v132 = *(_DWORD *)(DerivedStorage + 240);
                            v133 = *(_DWORD *)(DerivedStorage + 1488);
                            *(_DWORD *)buf = 136317698;
                            *(_QWORD *)v202 = v120;
                            *(_WORD *)&v202[8] = 2080;
                            *(_QWORD *)&v202[10] = v128;
                            *(_WORD *)&v202[18] = 1024;
                            *(_DWORD *)&v202[20] = v129;
                            *(_WORD *)&v202[24] = 1024;
                            *(_DWORD *)&v202[26] = v130;
                            *(_WORD *)&v202[30] = 1024;
                            *(_DWORD *)v203 = HIBYTE(PixelFormatType);
                            *(_WORD *)&v203[4] = 1024;
                            v204 = BYTE2(PixelFormatType);
                            v205 = 1024;
                            v206 = BYTE1(PixelFormatType);
                            v207 = 1024;
                            v208 = PixelFormatType;
                            v209 = 1024;
                            v210 = v131;
                            v211 = 1024;
                            v212 = v132;
                            v213 = 1024;
                            v214 = v133;
                            _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%s: Init %s video encoder: dimension = %d x %d, pixfmt = %c%c%c%c, bit_depth = %d, usage = %d, number_slices = %d\n", buf, 0x4Cu);
                          }
                          v134 = *(_DWORD *)(DerivedStorage + 240);
                          if (v134 <= 0x2A && ((1 << v134) & 0x44000100000) != 0)
                          {
                            v135 = 0;
                            v136 = 0x7FFFFFFF;
                            do
                            {
                              v137 = *(double *)(DerivedStorage + v135 + 96);
                              if (v137 != 0.0)
                              {
                                v138 = *(double *)(DerivedStorage + v135 + 160);
                                if (v138 != 0.0 && v136 >= (int)(v137 * 8.0 / v138))
                                  v136 = (int)(v137 * 8.0 / v138);
                              }
                              v135 += 8;
                            }
                            while (v135 != 64);
                            if (v136 != 0x7FFFFFFF)
                            {
                              if (v134 == 38)
                              {
                                v139 = *(_DWORD *)(DerivedStorage + 48);
                                v140 = *(double *)(DerivedStorage + 24);
                                v183 = *(_DWORD *)(DerivedStorage + 340);
                                v184 = *(_DWORD *)(DerivedStorage + 344);
                                v186 = sub_1B6803DC8(v139, v136, *(_DWORD *)(DerivedStorage + 232), v183, v184, v140);
                                *(_DWORD *)(DerivedStorage + 52) = v186;
                                if (!*(_BYTE *)(DerivedStorage + 224)
                                  || (v186 != v136 ? (v141 = dword_1EF137CD0 < 3) : (v141 = 1),
                                      v141 || !os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT)))
                                {
                                  *(_BYTE *)(DerivedStorage + 224) = 0;
                                  goto LABEL_299;
                                }
                                if (v139 == 1684632424 || v139 == 1752589105 || v139 == 1718908520)
                                  v142 = "HEVC";
                                else
                                  v142 = "H.264";
                                *(_DWORD *)buf = 136316418;
                                *(_QWORD *)v202 = v142;
                                *(_WORD *)&v202[8] = 1024;
                                *(_DWORD *)&v202[10] = v183;
                                *(_WORD *)&v202[14] = 1024;
                                *(_DWORD *)&v202[16] = v184;
                                *(_WORD *)&v202[20] = 1024;
                                *(_DWORD *)&v202[22] = (int)v140;
                                *(_WORD *)&v202[26] = 1024;
                                *(_DWORD *)&v202[28] = v136;
                                *(_WORD *)v203 = 1024;
                                *(_DWORD *)&v203[2] = v186;
                                _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Carplay %s: dimension = %d x %d, framerate = %d, bitrate setting was clipped from %d to %d\n", buf, 0x2Au);
                                v134 = *(_DWORD *)(DerivedStorage + 240);
                              }
                              else
                              {
                                *(_DWORD *)(DerivedStorage + 52) = v136;
                              }
                            }
                          }
                          *(_BYTE *)(DerivedStorage + 224) = 0;
                          if (v134 == 20 && *(_DWORD *)(*(_QWORD *)(DerivedStorage + 16) + 1004) == 8)
                          {
                            if (qword_1EDBB4CB8 != -1)
                              dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
                            if (dword_1EDBB4CC4 >= 7
                              && *(_BYTE *)(*(_QWORD *)(DerivedStorage + 16) + 3308) == 1
                              && *(_DWORD *)(DerivedStorage + 56) == 1)
                            {
                              v143 = (id *)(DerivedStorage + 1416);
                              if (!sub_1B67C24BC((_QWORD *)(DerivedStorage + 1416)))
                              {
                                v144 = dispatch_semaphore_create(0);
                                *(_QWORD *)(DerivedStorage + 1408) = v144;
                                dispatch_semaphore_signal(v144);
                                if (!*(_QWORD *)(DerivedStorage + 1408))
                                {
                                  if (*v143)
                                  {
                                    objc_msgSend(*v143, "invalidate");
                                    CFRelease(*v143);
                                  }
                                }
                              }
                            }
                          }
LABEL_299:
                          v145 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 16) + 1168);
                          v146 = v187;
                          if (v145)
                            sub_1B6872E44(v145, (uint64_t *)"input_frames", 1.0);
                          v147 = *(_DWORD *)(DerivedStorage + 240);
                          if (v147 <= 0x2A && ((1 << v147) & 0x44000100000) != 0)
                          {
                            v148 = 0;
                            v149 = 0x7FFFFFFF;
                            do
                            {
                              v150 = *(double *)(DerivedStorage + v148 + 96);
                              if (v150 != 0.0)
                              {
                                v151 = *(double *)(DerivedStorage + v148 + 160);
                                if (v151 != 0.0 && v149 >= (int)(v150 * 8.0 / v151))
                                  v149 = (int)(v150 * 8.0 / v151);
                              }
                              v148 += 8;
                            }
                            while (v148 != 64);
                            if (v149 != 0x7FFFFFFF)
                            {
                              if (v147 == 38)
                              {
                                v152 = *(_DWORD *)(DerivedStorage + 48);
                                v153 = *(_DWORD *)(DerivedStorage + 340);
                                v154 = *(_DWORD *)(DerivedStorage + 344);
                                v155 = *(double *)(DerivedStorage + 24);
                                v156 = sub_1B6803DC8(v152, v149, *(_DWORD *)(DerivedStorage + 232), v153, v154, v155);
                                *(_DWORD *)(DerivedStorage + 52) = v156;
                                if (*(_BYTE *)(DerivedStorage + 224)
                                  && ((v157 = v156, v156 != v149) ? (v158 = dword_1EF137CD0 < 3) : (v158 = 1),
                                      !v158 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT)))
                                {
                                  if (v152 == 1684632424 || v152 == 1752589105 || v152 == 1718908520)
                                    v159 = "HEVC";
                                  else
                                    v159 = "H.264";
                                  LODWORD(time.value) = 136316418;
                                  *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)v159;
                                  LOWORD(time.flags) = 1024;
                                  *(CMTimeFlags *)((char *)&time.flags + 2) = v153;
                                  WORD1(time.epoch) = 1024;
                                  HIDWORD(time.epoch) = v154;
                                  LOWORD(v222) = 1024;
                                  *(_DWORD *)((char *)&v222 + 2) = (int)v155;
                                  HIWORD(v222) = 1024;
                                  *(_DWORD *)v223 = v149;
                                  *(_WORD *)&v223[4] = 1024;
                                  *(_DWORD *)&v223[6] = v157;
                                  _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Carplay %s: dimension = %d x %d, framerate = %d, bitrate setting was clipped from %d to %d\n", (uint8_t *)&time, 0x2Au);
                                  v147 = *(_DWORD *)(DerivedStorage + 240);
                                }
                                else
                                {
                                  v147 = 38;
                                }
                              }
                              else
                              {
                                *(_DWORD *)(DerivedStorage + 52) = v149;
                              }
                            }
                            v146 = v187;
                          }
                          *(_BYTE *)(DerivedStorage + 224) = 0;
                          v160 = *(_QWORD *)(DerivedStorage + 16);
                          *(_QWORD *)(v160 + 944) = a6;
                          *(_DWORD *)(v160 + 832) = *(_DWORD *)(DerivedStorage + 1372);
                          *(_DWORD *)(v160 + 120) = v147;
                          *(_QWORD *)(v160 + 128) = *(_QWORD *)(DerivedStorage + 24);
                          v161 = *(double *)(DerivedStorage + 32);
                          *(double *)(v160 + 136) = v161;
                          v162 = *(double *)(DerivedStorage + 40);
                          *(double *)(v160 + 144) = v162;
                          *(_QWORD *)(v160 + 984) = *(_QWORD *)(DerivedStorage + 1460);
                          *(_BYTE *)(v160 + 992) &= *(_BYTE *)(DerivedStorage + 1452);
                          *(_BYTE *)(v160 + 993) = *(_BYTE *)(DerivedStorage + 1453);
                          if (v161 < 0.0)
                            goto LABEL_325;
                          if (v161 == 0.5 || v161 == 1.0)
                          {
                            if (v161 == 1.0 || v162 > 0.0 && v162 < 1.0)
                            {
LABEL_325:
                              v163 = *(_DWORD *)(DerivedStorage + 56);
                              v164 = *(_DWORD *)(DerivedStorage + 60);
                              if (v164 > v163)
                              {
                                if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                                {
                                  LODWORD(time.value) = 67109376;
                                  HIDWORD(time.value) = v164;
                                  LOWORD(time.timescale) = 1024;
                                  *(CMTimeScale *)((char *)&time.timescale + 2) = v163;
                                  _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "min sublayer number (%d) cannot exceed max sublayer number (%d)\n", (uint8_t *)&time, 0xEu);
                                }
LABEL_328:
                                v21 = -12902;
                                goto LABEL_329;
                              }
                              *(_DWORD *)(v160 + 256) = *(_DWORD *)(DerivedStorage + 1400);
                              *(_DWORD *)(v160 + 476) = *(_DWORD *)(DerivedStorage + 1428);
                              *(_BYTE *)(v160 + 952) = *(_BYTE *)(DerivedStorage + 1385) != 0;
                              v171 = *(_DWORD *)(DerivedStorage + 52);
                              if (v171 >= 1)
                                *(_DWORD *)(v160 + 152) = v171;
                              if (v163 >= 1)
                              {
                                v172 = 0;
                                do
                                {
                                  v173 = *(_DWORD *)(DerivedStorage + 64 + 4 * v172);
                                  if (v173 <= 0)
                                    v173 = *(_DWORD *)(v160 + 152);
                                  *(_DWORD *)(v160 + 156 + 4 * v172++) = v173;
                                }
                                while (v172 < *(int *)(DerivedStorage + 56));
                              }
                              v174 = *(_DWORD *)(DerivedStorage + 92);
                              if (v174 > 0)
                                *(_DWORD *)(v160 + 184) = v174;
                              v197 = *(_OWORD *)&a4->value;
                              epoch = a4->epoch;
                              v195 = *v146;
                              v196 = *((_QWORD *)v146 + 2);
                              sub_1B67ABDE8((_DWORD *)(v160 + 120), (uint64_t *)&v197, (uint64_t *)&v195, *(_DWORD *)(DerivedStorage + 348), *(_DWORD *)(DerivedStorage + 352), *(_DWORD *)(DerivedStorage + 256), *(_DWORD *)(DerivedStorage + 1380), *(double *)(DerivedStorage + 264), *(double *)(DerivedStorage + 272));
                              sub_1B67ACB64(*(_QWORD *)(DerivedStorage + 16) + 120, a3);
                              v175 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 16) + 12728);
                              if (v175)
                              {
                                v21 = (*(uint64_t (**)(uint64_t, uint64_t *, __CVBuffer *))(*(_QWORD *)v175
                                                                                                  + 16))(v175, &v199, a3);
                                if (!v21)
                                {
                                  v176 = v199;
                                  *(_DWORD *)(v199 + 8) = *(_DWORD *)(DerivedStorage + 348);
                                  v177 = *(_QWORD *)(DerivedStorage + 16);
                                  *(_OWORD *)(v176 + 16) = *(_OWORD *)(v177 + 904);
                                  *(_DWORD *)(v176 + 32) = *(_DWORD *)(v177 + 920);
                                  *(_OWORD *)(v176 + 256) = *(_OWORD *)(v177 + 960);
                                  *((_QWORD *)v190 + 1) = v188;
                                  v178 = *(_OWORD *)&a4->value;
                                  *((_OWORD *)v190 + 1) = *(_OWORD *)&a4->value;
                                  v179 = a4->epoch;
                                  *((_QWORD *)v190 + 4) = v179;
                                  *(_OWORD *)(v190 + 40) = *v187;
                                  *((_QWORD *)v190 + 7) = *((_QWORD *)v187 + 2);
                                  *(_DWORD *)v190 = *v189;
                                  v194 = v179;
                                  v193 = v178;
                                  VTEncoderSessionEnqueuePresentationTimeStamp();
                                  v180 = *(_QWORD *)(DerivedStorage + 16);
                                  v192[0] = v199;
                                  v192[1] = v200;
                                  if (v200)
                                  {
                                    v181 = (unint64_t *)(v200 + 8);
                                    do
                                      v182 = __ldxr(v181);
                                    while (__stxr(v182 + 1, v181));
                                  }
                                  v18 = sub_1B680F980(v180, v192, (uint64_t)v190);
                                  sub_1B6772C88((uint64_t)v192);
                                  *v191 = vadd_s32(*v191, (int32x2_t)0x100000001);
                                  goto LABEL_334;
                                }
                              }
                              else
                              {
                                v21 = -12911;
                              }
LABEL_329:
                              *v191 = vadd_s32(*v191, (int32x2_t)0x100000001);
                              if (v21)
                                v18 = v21;
                              else
                                v18 = 4294954385;
                              VTEncoderSessionEmitEncodedFrame();
                              if (v190)
                                MEMORY[0x1BCC9814C](v190, 0x1020C40C238D3BALL);
LABEL_334:
                              dispatch_semaphore_signal(*(dispatch_semaphore_t *)(DerivedStorage + 1392));
                              goto LABEL_335;
                            }
                            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                            {
                              LOWORD(time.value) = 0;
                              v169 = MEMORY[0x1E0C81028];
                              v170 = "Baselayer bitrate fraction should be between 0 (exclusive) and 1 (exclusive)";
                              goto LABEL_365;
                            }
                          }
                          else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                          {
                            LOWORD(time.value) = 0;
                            v169 = MEMORY[0x1E0C81028];
                            v170 = "Baselayer framerate fraction should be either 0.5 or 1";
LABEL_365:
                            _os_log_error_impl(&dword_1B676B000, v169, OS_LOG_TYPE_ERROR, v170, (uint8_t *)&time, 2u);
                          }
                          v21 = -12910;
                          goto LABEL_329;
                        }
                        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                        {
                          v122 = *(_DWORD *)(DerivedStorage + 48);
                          if (v122 == 1684632424 || v122 == 1752589105 || v122 == 1718908520)
                            v123 = "HEVC";
                          else
                            v123 = "H.264";
                          *(_DWORD *)buf = 136315138;
                          *(_QWORD *)v202 = v123;
                          v124 = MEMORY[0x1E0C81028];
                          v125 = "%s: CreateAndSetHeaders failed\n";
                          goto LABEL_372;
                        }
LABEL_187:
                        v21 = v71;
                        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                          goto LABEL_329;
                        v89 = *(_DWORD *)(DerivedStorage + 48);
                        if (v89 == 1684632424 || v89 == 1752589105 || v89 == 1718908520)
                          v90 = "HEVC";
                        else
                          v90 = "H.264";
                        LODWORD(time.value) = 136315394;
                        *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)v90;
                        LOWORD(time.flags) = 1024;
                        *(CMTimeFlags *)((char *)&time.flags + 2) = v71;
                        v93 = MEMORY[0x1E0C81028];
                        v94 = "%s: failed to init video encoder, err = %d\n";
                        goto LABEL_203;
                      }
LABEL_176:
                      v86 = *(_QWORD *)(DerivedStorage + 16);
                      buf[0] = 0;
                      sub_1B67EF12C(*(_QWORD *)(v86 + 3192), 0x3BEB44829B7A4FABLL, "true", 0, (uint64_t)buf);
                      if (dword_1EF137CD0 >= 3 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                      {
                        v87 = *(_DWORD *)(DerivedStorage + 48);
                        if (v87 == 1684632424 || v87 == 1752589105 || v87 == 1718908520)
                          v88 = "HEVC";
                        else
                          v88 = "H.264";
                        *(_DWORD *)buf = 136316162;
                        *(_QWORD *)v202 = v88;
                        *(_WORD *)&v202[8] = 1024;
                        *(_DWORD *)&v202[10] = HIBYTE(PixelFormatType);
                        *(_WORD *)&v202[14] = 1024;
                        *(_DWORD *)&v202[16] = BYTE2(PixelFormatType);
                        *(_WORD *)&v202[20] = 1024;
                        *(_DWORD *)&v202[22] = BYTE1(PixelFormatType);
                        *(_WORD *)&v202[26] = 1024;
                        *(_DWORD *)&v202[28] = PixelFormatType;
                        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%s: get full range pixel buffer %c%c%c%c and set vui-full-range to true\n", buf, 0x24u);
                      }
                      goto LABEL_206;
                    }
LABEL_140:
                    if (*(int *)(DerivedStorage + 340) >= 321)
                    {
                      v225 = 1;
                      v226 = 4;
                    }
                    goto LABEL_99;
                  }
                  if (((1 << dword_1EDBB4CC4) & 0x180) != 0)
                  {
                    if (*(_DWORD *)&v223[4] == 1)
                      goto LABEL_98;
                    *(_DWORD *)&v223[8] = 1;
                    *(_BYTE *)(DerivedStorage + 1384) = 0;
                    goto LABEL_140;
                  }
                }
                if (dword_1EF137CD0 >= 2)
                {
                  fwrite("Unknown device type.\n", 0x15uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
                  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Unknown device type.\n", buf, 2u);
                  }
                }
                goto LABEL_98;
              }
            }
            if (dword_1EF137CD0 >= 2)
            {
              fprintf((FILE *)*MEMORY[0x1E0C80C10], "Warning: Got number_slices = %d for TrafficLight usage, forced number_slices = 3!\n", *(_DWORD *)(DerivedStorage + 1488));
              if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
              {
                v43 = *(_DWORD *)(DerivedStorage + 1488);
                *(_DWORD *)buf = 67109120;
                *(_DWORD *)v202 = v43;
                _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Warning: Got number_slices = %d for TrafficLight usage, forced number_slices = 3!\n", buf, 8u);
              }
            }
            v41 = 3;
            *(_DWORD *)(DerivedStorage + 1488) = 3;
            goto LABEL_78;
          }
          if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
            goto LABEL_185;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)v202 = -12910;
          v45 = MEMORY[0x1E0C81028];
          v46 = "TrafficLight usage only supported in HEVC, err = %d\n";
        }
        v47 = 8;
        goto LABEL_184;
      }
    }
    else
    {
      v35 = 0;
      if (!v27)
        goto LABEL_53;
    }
    CFRelease(v28);
    goto LABEL_53;
  }
  if (dword_1EF137CD0 < 1)
  {
    v18 = 4294954393;
  }
  else
  {
    v15 = *(_DWORD *)(DerivedStorage + 48);
    if (v15 == 1684632424 || v15 == 1752589105 || v15 == 1718908520)
      v16 = "HEVC";
    else
      v16 = "H.264";
    v18 = 4294954393;
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "%s: video encoder is invalid, err = %d\n", v16, -12903);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v24 = *(_DWORD *)(DerivedStorage + 48);
      if (v24 == 1684632424 || v24 == 1752589105 || v24 == 1718908520)
        v25 = "HEVC";
      else
        v25 = "H.264";
      LODWORD(time.value) = 136315394;
      *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)v25;
      LOWORD(time.flags) = 1024;
      v18 = 4294954393;
      *(CMTimeFlags *)((char *)&time.flags + 2) = -12903;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%s: video encoder is invalid, err = %d\n", (uint8_t *)&time, 0x12u);
    }
  }
LABEL_335:
  v165 = (std::__shared_weak_count *)v200;
  if (v200)
  {
    v166 = (unint64_t *)(v200 + 8);
    do
      v167 = __ldaxr(v166);
    while (__stlxr(v167 - 1, v166));
    if (!v167)
    {
      ((void (*)(std::__shared_weak_count *))v165->__on_zero_shared)(v165);
      std::__shared_weak_count::__release_weak(v165);
    }
  }
  return v18;
}

void sub_1B67A3624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  sub_1B6772C88((uint64_t)&a21);
  sub_1B6772C88((uint64_t)&a35);
  _Unwind_Resume(a1);
}

uint64_t sub_1B67A366C()
{
  uint64_t DerivedStorage;
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;

  VTVideoEncoderGetCMBaseObject();
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!DerivedStorage)
    return 0;
  v1 = DerivedStorage;
  v2 = *(NSObject **)(DerivedStorage + 1392);
  if (v2)
    dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
  v3 = *(_QWORD *)(v1 + 16);
  if (v3)
  {
    if (*(int *)(v3 + 3692) >= 1)
    {
      v4 = *(_QWORD *)(v3 + 13272);
      if (v4)
      {
        v5 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v4 + 56))(*(_QWORD *)(v3 + 13272));
        if ((_DWORD)v5)
          goto LABEL_12;
        v3 = *(_QWORD *)(v1 + 16);
      }
    }
    v5 = sub_1B6806E70(v3);
  }
  else
  {
    v5 = 0;
  }
LABEL_12:
  v6 = *(NSObject **)(v1 + 1392);
  if (v6)
    dispatch_semaphore_signal(v6);
  return v5;
}

uint64_t sub_1B67A3704(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;

  pthread_once(&stru_1EF137CB8, sub_1B67A3860);
  if (!a2)
    return FigSignalErrorAt();
  v3 = qword_1EF138D90;
  if (!qword_1EF138D90)
    return FigSignalErrorAt();
  CFRetain((CFTypeRef)qword_1EF138D90);
  *a2 = v3;
  return 0;
}

uint64_t sub_1B67A3780()
{
  int *DerivedStorage;
  uint64_t v1;
  uint8_t v3[16];
  uint8_t buf[16];

  VTVideoEncoderGetCMBaseObject();
  DerivedStorage = (int *)CMBaseObjectGetDerivedStorage();
  if (DerivedStorage)
  {
    v1 = sub_1B67C52D0(DerivedStorage[85], DerivedStorage[86], DerivedStorage[58], DerivedStorage[12]);
    if ((_DWORD)v1 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Error setting requested profile in HEVCVideoEncoder_PrepareToEncodeFrames\n", buf, 2u);
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v3 = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Error NULL encoder object recieved at HEVCVideoEncoder_PrepareToEncodeFrames\n", v3, 2u);
    }
    return 4294954385;
  }
  return v1;
}

void sub_1B67A3860()
{
  unsigned __int8 v0;
  CFMutableArrayRef Mutable;
  __CFArray *v2;
  const void **v3;
  uint64_t v4;
  const void **v5;
  uint64_t v6;
  const __CFAllocator *v7;
  void *v8;
  CFDictionaryRef v9;
  CFDictionaryRef v10;
  CFDictionaryRef v11;
  BOOL v12;
  uint64_t i;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _OWORD v31[26];
  uint64_t v32;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  v0 = atomic_load((unsigned __int8 *)&qword_1EF138F40);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_1EF138F40))
  {
    v14 = *MEMORY[0x1E0CECEC8];
    qword_1EF138D98 = *MEMORY[0x1E0CED248];
    unk_1EF138DA0 = v14;
    v15 = *MEMORY[0x1E0CED0A8];
    qword_1EF138DA8 = *MEMORY[0x1E0CECEB0];
    unk_1EF138DB0 = v15;
    v16 = *MEMORY[0x1E0CED0B0];
    qword_1EF138DB8 = v15;
    unk_1EF138DC0 = v16;
    v17 = *MEMORY[0x1E0CECEF0];
    qword_1EF138DC8 = *MEMORY[0x1E0CED120];
    unk_1EF138DD0 = v17;
    v18 = *MEMORY[0x1E0CECF20];
    qword_1EF138DD8 = *MEMORY[0x1E0CED000];
    unk_1EF138DE0 = v18;
    qword_1EF138DE8 = (uint64_t)CFSTR("CommandLineParametersExtraOptions");
    unk_1EF138DF0 = CFSTR("BPictures");
    qword_1EF138DF8 = (uint64_t)CFSTR("NegotiationDetailsBitField");
    unk_1EF138E00 = CFSTR("NegotiatedFLB");
    qword_1EF138E08 = (uint64_t)CFSTR("AverageTemporalBitRates");
    unk_1EF138E10 = CFSTR("MaxRefreshFrameIntervalDuration");
    v19 = *MEMORY[0x1E0CECF50];
    qword_1EF138E18 = (uint64_t)CFSTR("ThermalLevel");
    unk_1EF138E20 = v19;
    v20 = *MEMORY[0x1E0CECF78];
    qword_1EF138E28 = (uint64_t)CFSTR("AverageBitRateIntraLayer");
    unk_1EF138E30 = v20;
    v21 = *MEMORY[0x1E0CECF10];
    qword_1EF138E38 = *MEMORY[0x1E0CECFD0];
    unk_1EF138E40 = v21;
    v22 = *MEMORY[0x1E0CED098];
    qword_1EF138E48 = *MEMORY[0x1E0CECF00];
    unk_1EF138E50 = v22;
    v23 = *MEMORY[0x1E0CED1A8];
    qword_1EF138E58 = *MEMORY[0x1E0CED0C0];
    unk_1EF138E60 = v23;
    v24 = *MEMORY[0x1E0CED180];
    qword_1EF138E68 = *MEMORY[0x1E0CECF80];
    unk_1EF138E70 = v24;
    v25 = *MEMORY[0x1E0CED140];
    qword_1EF138E78 = *MEMORY[0x1E0CED1F8];
    unk_1EF138E80 = v25;
    v26 = *MEMORY[0x1E0CED238];
    qword_1EF138E88 = *MEMORY[0x1E0CECF48];
    unk_1EF138E90 = v26;
    v27 = *MEMORY[0x1E0CED0F8];
    qword_1EF138E98 = *MEMORY[0x1E0CED290];
    unk_1EF138EA0 = v27;
    qword_1EF138EA8 = *MEMORY[0x1E0CECFE0];
    unk_1EF138EB0 = CFSTR("UsingCellular");
    qword_1EF138EB8 = (uint64_t)CFSTR("FaceRect");
    unk_1EF138EC0 = CFSTR("RemoteMLScale");
    v28 = *MEMORY[0x1E0CED1B8];
    qword_1EF138EC8 = *MEMORY[0x1E0CED118];
    unk_1EF138ED0 = v28;
    qword_1EF138ED8 = *MEMORY[0x1E0CED070];
    unk_1EF138EE0 = CFSTR("EnableFrameDropping");
    qword_1EF138EE8 = (uint64_t)CFSTR("AllowQpModulation");
    unk_1EF138EF0 = CFSTR("MinNumberOfTemporalLayers");
    v29 = *MEMORY[0x1E0CECED0];
    qword_1EF138EF8 = *MEMORY[0x1E0CECF90];
    unk_1EF138F00 = v29;
    qword_1EF138F08 = *MEMORY[0x1E0CED110];
    unk_1EF138F10 = CFSTR("SliceQP");
    qword_1EF138F18 = (uint64_t)CFSTR("SliceDeltaQP");
    unk_1EF138F20 = CFSTR("SliceMaxQP");
    v30 = *MEMORY[0x1E0CED0C8];
    qword_1EF138F28 = *MEMORY[0x1E0CECFB8];
    unk_1EF138F30 = v30;
    qword_1EF138F38 = (uint64_t)CFSTR("CallerID");
    __cxa_guard_release(&qword_1EF138F40);
  }
  v32 = 0;
  memset(v31, 0, sizeof(v31));
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v2 = Mutable;
    v3 = (const void **)MEMORY[0x1E0CED9B0];
    v4 = 0x10u;
    do
    {
      CFArrayAppendValue(v2, *v3);
      v3 = *(const void ***)((char *)&off_1E6A16AD0 + v4);
      v4 += 16;
    }
    while (v4 != 112);
    v5 = (const void **)MEMORY[0x1E0CED870];
    v6 = 0x10u;
    do
    {
      CFArrayAppendValue(v2, *v5);
      v5 = *(const void ***)((char *)&off_1E6A16B40 + v6);
      v6 += 16;
    }
    while (v6 != 544);
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v8 = (void *)*MEMORY[0x1E0CED9F0];
    values = v2;
    keys[0] = v8;
    v9 = CFDictionaryCreate(v7, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFRelease(v2);
  }
  else
  {
    v9 = 0;
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  }
  v10 = CFDictionaryCreate(v7, 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v11 = v10;
  if (v10)
    v12 = v9 == 0;
  else
    v12 = 1;
  if (v12)
    goto LABEL_16;
  for (i = 0; i != 424; i += 8)
    *(_QWORD *)((char *)v31 + i) = v10;
  qword_1EF138D90 = (uint64_t)CFDictionaryCreate(v7, (const void **)&qword_1EF138D98, (const void **)v31, 53, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!qword_1EF138D90)
LABEL_16:
    FigSignalErrorAt();
  if (v11)
    CFRelease(v11);
  if (v9)
    CFRelease(v9);
}

intptr_t sub_1B67A3D54(uint64_t a1, int a2, CFDictionaryRef theDict)
{
  uint64_t v4;
  const __CFNumber *Value;

  if (a2)
  {
    v4 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)(v4 + 1400) = 0;
  }
  else
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E0D475F8]);
    CFNumberGetValue(Value, kCFNumberSInt32Type, (void *)(*(_QWORD *)(a1 + 32) + 1400));
    v4 = *(_QWORD *)(a1 + 32);
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v4 + 1408));
}

uint64_t sub_1B67A3DAC(uint64_t a1, uint64_t a2, int a3, const opaqueCMFormatDescription *a4, uint64_t a5, OpaqueCMBlockBuffer *a6, uint64_t *a7, uint64_t *a8)
{
  uint64_t v15;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  double v24;
  uint64_t v25;
  unint64_t v26;
  unsigned int v27;
  int v28;
  CMTimeEpoch v30;
  CMTimeEpoch v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  unsigned int v38;
  size_t v39;
  const __CFAllocator *v40;
  const __CFAllocator *v41;
  OSStatus v42;
  NSObject *v43;
  const char *v44;
  OSStatus v45;
  uint8_t *v46;
  OSStatus DataPointer;
  const __CFArray *SampleAttachmentsArray;
  __CFDictionary *ValueAtIndex;
  CFNumberRef v50;
  const void **v51;
  CFNumberRef v52;
  __CFArray *Mutable;
  unint64_t v54;
  float *i;
  uint64_t v56;
  unint64_t v57;
  CFNumberRef v58;
  OSStatus v59;
  const void **v60;
  CFNumberRef v61;
  const void *v62;
  CFNumberRef v63;
  const void *v64;
  const void *v65;
  const void *v66;
  CFNumberRef v67;
  CFNumberRef v68;
  CFNumberRef v69;
  CFNumberRef v70;
  const void *v71;
  CFNumberRef v72;
  CFNumberRef v73;
  CFNumberRef v74;
  int v75;
  const char *v76;
  BOOL v77;
  BOOL v78;
  BOOL v79;
  BOOL v80;
  char v81;
  BOOL v82;
  char v83;
  double v84;
  _DWORD v85[6];
  float v86[10];
  __int128 v87;
  double v88[3];
  uint64_t v89;
  unsigned int v90;
  CFNumberRef v91;
  size_t dataLength;
  CMSampleBufferRef sbuf;
  CMBlockBufferRef theBuffer;
  __int128 v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  CMSampleTimingInfo buf;
  uint8_t valuePtr[8];
  char *dataPointerOut[4];

  dataPointerOut[1] = *(char **)MEMORY[0x1E0C80C00];
  v84 = -1.0;
  v96 = 0;
  v97 = 0;
  v98 = 0;
  __asm { FMOV            V0.4S, #-1.0 }
  v95 = _Q0;
  v15 = *(_QWORD *)(a1 + 16);
  if (!*(_BYTE *)(v15 + 3786))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.duration.value) = 0;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Wrong output bitstream format", (uint8_t *)&buf, 2u);
    }
    goto LABEL_18;
  }
  v21 = *(_QWORD *)(v15 + 1168);
  if (!v21)
  {
LABEL_15:
    v25 = *a8;
    if (*a8)
      goto LABEL_16;
LABEL_20:
    v28 = 0;
    v27 = 0;
    v26 = 0;
    goto LABEL_21;
  }
  sub_1B6872E44(*(_QWORD *)(v15 + 1168), (uint64_t *)"encoded_frames", 1.0);
  if (!*a8)
    goto LABEL_20;
  LODWORD(v22) = *(_DWORD *)(*a8 + 272);
  sub_1B6872FAC(v21, (uint64_t *)"target_bitrate", (double)v22);
  if (*(_BYTE *)(*a8 + 111))
  {
    v23 = "dropped_frames";
    v24 = 1.0;
  }
  else
  {
    sub_1B6872E44(v21, (uint64_t *)"transmit_frames", 1.0);
    sub_1B6872E44(v21, (uint64_t *)"encoded_bits", (double)(unint64_t)(8 * *(_QWORD *)(*a8 + 40)));
    sub_1B6872E44(v21, (uint64_t *)"header_bits", (double)*(int *)(*a8 + 12));
    sub_1B6872E44(v21, (uint64_t *)"fec_bits", (double)*(int *)(*a8 + 8));
    sub_1B6872E44(v21, (uint64_t *)"rtx_bits", (double)*(int *)(*a8 + 20));
    sub_1B6872E44(v21, (uint64_t *)"encoding_time", *(double *)(*a8 + 280));
    sub_1B6872E44(v21, (uint64_t *)"frame_qp", *(float *)(*a8 + 116));
    v24 = (double)*(unint64_t *)(*a8 + 48);
    v23 = "min_frame_size";
  }
  sub_1B6872E44(v21, (uint64_t *)v23, v24);
  v25 = *a8;
  if (*(_BYTE *)(*a8 + 276))
  {
    sub_1B6872E44(v21, (uint64_t *)"repeated_frames", 1.0);
    v25 = *a8;
  }
  if (*(_BYTE *)(v25 + 109))
  {
    sub_1B6872E44(v21, (uint64_t *)"idr_frames", 1.0);
    v25 = *a8;
  }
  if (*(_BYTE *)(v25 + 108))
  {
    sub_1B6872E44(v21, (uint64_t *)"refresh_frames", 1.0);
    goto LABEL_15;
  }
LABEL_16:
  v26 = *(_QWORD *)(v25 + 40);
  v27 = *(char *)(v25 + 32);
  v28 = *(_DWORD *)(v25 + 132);
  v84 = *(float *)(v25 + 116);
  if (HIDWORD(v26))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v75 = *(_DWORD *)(a1 + 48);
      if (v75 == 1684632424 || v75 == 1752589105 || v75 == 1718908520)
        v76 = "HEVC";
      else
        v76 = "H.264";
      LODWORD(buf.duration.value) = 136315650;
      *(CMTimeValue *)((char *)&buf.duration.value + 4) = (CMTimeValue)v76;
      LOWORD(buf.duration.flags) = 2048;
      *(_QWORD *)((char *)&buf.duration.flags + 2) = v26;
      HIWORD(buf.duration.epoch) = 1024;
      LODWORD(buf.presentationTimeStamp.value) = -12911;
      _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s: compressed NALU is too large, size = %zu, err = %d\n", (uint8_t *)&buf, 0x1Cu);
    }
    goto LABEL_18;
  }
LABEL_21:
  *(_OWORD *)&buf.duration.value = *(_OWORD *)(a2 + 40);
  v30 = *(_QWORD *)(a2 + 56);
  *(_OWORD *)&buf.presentationTimeStamp.value = *(_OWORD *)(a2 + 16);
  v31 = *(_QWORD *)(a2 + 32);
  buf.duration.epoch = v30;
  buf.presentationTimeStamp.epoch = v31;
  VTEncoderSessionDequeueDecodeTimeStamp();
  if (a3 || !a6 || !v26)
  {
LABEL_18:
    VTEncoderSessionEmitEncodedFrame();
    return MEMORY[0x1BCC9814C](a2, 0x1020C40C238D3BALL);
  }
  if (*(_BYTE *)(a1 + 1384))
  {
    if (!*(_QWORD *)(a1 + 8))
    {
      CMFormatDescriptionGetExtensions(a4);
      if (VTEncoderSessionCreateVideoFormatDescription())
      {
        CFRetain(a4);
        *(_QWORD *)(a1 + 8) = a4;
      }
    }
  }
  if (v27 > 1)
  {
    v32 = *a7;
    v33 = (v27 & 0xFFFFFFFE) == 2 && *(_DWORD *)(v32 + 36) != 0;
  }
  else
  {
    v32 = *a7;
    v33 = 1;
  }
  v34 = 0;
  v80 = v33;
  v77 = v27 == 0;
  v78 = v27 == 1;
  v79 = v27 == 0;
  v82 = *(_DWORD *)(v32 + 40) == 1;
  v83 = *(_BYTE *)(v32 + 44);
  v85[0] = *(_DWORD *)(v32 + 8);
  v89 = *(_QWORD *)(v32 + 240);
  v90 = *(_DWORD *)(v32 + 12);
  v35 = *a8;
  v87 = *(_OWORD *)(*a8 + 288);
  v88[0] = *(double *)(v35 + 304);
  v36 = *(_QWORD *)(a1 + 16);
  v37 = *(unsigned __int8 *)(v36 + 1016);
  if (!*(_BYTE *)(v36 + 1016))
    goto LABEL_33;
LABEL_32:
  v38 = 5;
  while (v38 > v34)
  {
    v86[v34] = *((float *)&v95 + v34);
    ++v34;
    if (v37)
      goto LABEL_32;
LABEL_33:
    if (*(_DWORD *)(v36 + 3248) == 43)
      v38 = 10;
    else
      v38 = 4;
  }
  sbuf = 0;
  theBuffer = 0;
  v39 = CMBlockBufferGetDataLength(a6);
  dataLength = v39;
  v40 = *(const __CFAllocator **)(a1 + 360);
  if (!v40)
  {
    CFRetain(a6);
    theBuffer = a6;
    v41 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    goto LABEL_44;
  }
  dataPointerOut[0] = 0;
  v41 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v42 = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v39, v40, 0, 0, v39, 1u, &theBuffer);
  if (v42)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)valuePtr = 67109120;
      *(_DWORD *)&valuePtr[4] = v42;
      v43 = MEMORY[0x1E0C81028];
      v44 = "Block buffer creation failed, err = %d";
LABEL_78:
      v46 = valuePtr;
      goto LABEL_79;
    }
    goto LABEL_116;
  }
  DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, dataPointerOut);
  if (!DataPointer)
  {
    v59 = CMBlockBufferCopyDataBytes(a6, 0, dataLength, dataPointerOut[0]);
    if (v59)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)valuePtr = 67109120;
        *(_DWORD *)&valuePtr[4] = v59;
        v43 = MEMORY[0x1E0C81028];
        v44 = "Block buffer CopyDataBytes failed, err = %d";
        goto LABEL_78;
      }
      goto LABEL_116;
    }
    a6 = theBuffer;
LABEL_44:
    v45 = CMSampleBufferCreate(v41, a6, 1u, 0, 0, *(CMFormatDescriptionRef *)(a1 + 8), 1, 1, &buf, 1, &dataLength, &sbuf);
    if (!v45)
    {
      SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(sbuf, 1u);
      ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
      if (v82)
      {
        v50 = CFNumberCreate(v41, kCFNumberIntType, v85);
        v51 = (const void **)MEMORY[0x1E0CEDAA0];
        if (!*(_DWORD *)(a1 + 1456))
          v51 = (const void **)MEMORY[0x1E0CEDA98];
        CFDictionarySetValue(ValueAtIndex, *v51, v50);
        CFRelease(v50);
      }
      if (v83 && v27)
        CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CEDA90], (const void *)*MEMORY[0x1E0C9AE50]);
      if (*(int *)(a1 + 56) >= 2 && v90 <= 6)
      {
        v52 = CFNumberCreate(v41, kCFNumberSInt32Type, &v90);
        CFDictionarySetValue(ValueAtIndex, CFSTR("TemporalID"), v52);
        CFRelease(v52);
      }
      if (v86[0] > 0.0 || v86[1] > 0.0 || v86[2] > 0.0)
      {
        Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
        if (Mutable)
        {
          v54 = 0;
          for (i = v86; ; ++i)
          {
            v56 = *(_QWORD *)(a1 + 16);
            if (*(_BYTE *)(v56 + 1016))
              v57 = 5;
            else
              v57 = *(_DWORD *)(v56 + 3248) == 43 ? 10 : 4;
            if (v54 >= v57)
              break;
            v58 = CFNumberCreate(0, kCFNumberFloat32Type, i);
            if (v58)
            {
              CFArrayAppendValue(Mutable, v58);
              CFRelease(v58);
            }
            ++v54;
          }
          CFDictionarySetValue(ValueAtIndex, CFSTR("PSNRArray"), Mutable);
          CFRelease(Mutable);
        }
      }
      v60 = (const void **)MEMORY[0x1E0C9AE40];
      if (v28 <= 0)
      {
        v62 = (const void *)*MEMORY[0x1E0C9AE50];
      }
      else
      {
        LODWORD(dataPointerOut[0]) = v28;
        *(_DWORD *)valuePtr = 0;
        v61 = CFNumberCreate(v41, kCFNumberSInt32Type, valuePtr);
        if (v61)
        {
          CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CEDA60], v61);
          CFRelease(v61);
        }
        v62 = (const void *)*MEMORY[0x1E0C9AE50];
        CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CEDA68], (const void *)*MEMORY[0x1E0C9AE50]);
        v63 = CFNumberCreate(v41, kCFNumberSInt32Type, dataPointerOut);
        if (v63)
        {
          CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CEDA70], v63);
          CFRelease(v63);
        }
      }
      if (!v79)
        CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CA2620], v62);
      v64 = *v60;
      if (v80)
        v65 = v62;
      else
        v65 = v64;
      CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CA2618], v65);
      if (v77 || v78)
        v66 = v64;
      else
        v66 = v62;
      CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CA25C8], v66);
      if (v84 > 0.0)
      {
        dataPointerOut[0] = *(char **)&v84;
        v67 = CFNumberCreate(0, kCFNumberDoubleType, dataPointerOut);
        if (v67)
        {
          CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CEDA50], v67);
          CFRelease(v67);
        }
      }
      if (*(double *)&v87 >= 0.0 && *((double *)&v87 + 1) >= 0.0 && v88[0] >= 0.0)
      {
        dataPointerOut[0] = (char *)CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        *(_QWORD *)valuePtr = 0;
        v68 = CFNumberCreate(0, kCFNumberDoubleType, &v87);
        v91 = v68;
        if (*(_QWORD *)valuePtr)
          CFRelease(*(CFTypeRef *)valuePtr);
        *(_QWORD *)valuePtr = v68;
        v91 = 0;
        sub_1B6770598((const void **)&v91);
        CFDictionarySetValue((CFMutableDictionaryRef)dataPointerOut[0], (const void *)*MEMORY[0x1E0CEDAF0], *(const void **)valuePtr);
        v69 = CFNumberCreate(0, kCFNumberDoubleType, (char *)&v87 + 8);
        v91 = v69;
        if (*(_QWORD *)valuePtr)
          CFRelease(*(CFTypeRef *)valuePtr);
        *(_QWORD *)valuePtr = v69;
        v91 = 0;
        sub_1B6770598((const void **)&v91);
        CFDictionarySetValue((CFMutableDictionaryRef)dataPointerOut[0], (const void *)*MEMORY[0x1E0CEDAC0], *(const void **)valuePtr);
        v70 = CFNumberCreate(0, kCFNumberDoubleType, v88);
        v91 = v70;
        if (*(_QWORD *)valuePtr)
          CFRelease(*(CFTypeRef *)valuePtr);
        *(_QWORD *)valuePtr = v70;
        v91 = 0;
        sub_1B6770598((const void **)&v91);
        CFDictionarySetValue((CFMutableDictionaryRef)dataPointerOut[0], (const void *)*MEMORY[0x1E0CEDAC8], *(const void **)valuePtr);
        CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CEDA88], dataPointerOut[0]);
        sub_1B6770598((const void **)valuePtr);
        sub_1B67705C8((const void **)dataPointerOut);
      }
      if (v81)
        v71 = v62;
      else
        v71 = v64;
      CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CA25E0], v71);
      if ((int)v89 >= 1 && SHIDWORD(v89) >= 1)
      {
        v72 = CFNumberCreate(v41, kCFNumberSInt32Type, &v89);
        v73 = CFNumberCreate(v41, kCFNumberSInt32Type, (char *)&v89 + 4);
        if (v72)
        {
          v74 = v73;
          if (v73)
          {
            CFDictionarySetValue(ValueAtIndex, CFSTR("VRAWidth"), v72);
            CFDictionarySetValue(ValueAtIndex, CFSTR("VRAHeight"), v74);
            CFRelease(v72);
            CFRelease(v74);
          }
        }
      }
      goto LABEL_116;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      LODWORD(dataPointerOut[0]) = 67109120;
      HIDWORD(dataPointerOut[0]) = v45;
      v43 = MEMORY[0x1E0C81028];
      v44 = "Sample buffer creation failed, err = %d";
      v46 = (uint8_t *)dataPointerOut;
LABEL_79:
      _os_log_error_impl(&dword_1B676B000, v43, OS_LOG_TYPE_ERROR, v44, v46, 8u);
      goto LABEL_116;
    }
    goto LABEL_116;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)valuePtr = 67109120;
    *(_DWORD *)&valuePtr[4] = DataPointer;
    v43 = MEMORY[0x1E0C81028];
    v44 = "Block buffer GetDataPointer failed, err = %d";
    goto LABEL_78;
  }
LABEL_116:
  VTEncoderSessionEmitEncodedFrame();
  if (theBuffer)
  {
    CFRelease(theBuffer);
    theBuffer = 0;
  }
  if (sbuf)
    CFRelease(sbuf);
  return MEMORY[0x1BCC9814C](a2, 0x1020C40C238D3BALL);
}

void sub_1B67A4AD0(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
    sub_1B67704C8(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B67A4B18(uint64_t a1)
{
  const void *v2;
  size_t v3;
  void *v4;
  __int16 VideoFormatDescription;
  size_t v7;
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  _DWORD *v13;
  int v14;
  unint64_t v15;
  unsigned int v16;
  _DWORD *v17;
  unint64_t v18;
  _DWORD *v19;
  unint64_t v20;
  int v21;
  _DWORD *v22;
  int v23;
  unint64_t v24;
  int v25;
  _DWORD *v26;
  int v27;
  unint64_t v28;
  unsigned int v29;
  _DWORD *v30;
  unint64_t v31;
  int v32;
  _DWORD *v33;
  int v34;
  unint64_t v35;
  int v36;
  _DWORD *v37;
  int v38;
  unint64_t v39;
  int v40;
  _DWORD *v41;
  int v42;
  unint64_t v43;
  unint64_t v44;
  unsigned int v45;
  _DWORD *v46;
  unsigned int v47;
  unsigned __int8 v48;
  unint64_t v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  unint64_t v54;
  unsigned int v55;
  _DWORD *v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  uint64_t v61;
  unint64_t v62;
  unsigned int v63;
  _DWORD *v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  uint64_t v69;
  unint64_t v70;
  BOOL v71;
  unint64_t v72;
  int v73;
  _DWORD *v74;
  int v75;
  unsigned int v76;
  unsigned int v77;
  unsigned int v78;
  uint64_t v79;
  unint64_t v80;
  unsigned int v81;
  _DWORD *v82;
  unsigned int v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  char v88;
  _DWORD *v89;
  int v90;
  int v91;
  unsigned int v92;
  unint64_t v93;
  int v94;
  _DWORD *v95;
  char v96;
  unint64_t v97;
  int v98;
  _DWORD *v99;
  char v100;
  unsigned int v101;
  unint64_t v102;
  int v103;
  _DWORD *v104;
  char v105;
  unint64_t v106;
  int v107;
  _DWORD *v108;
  char v109;
  unint64_t v110;
  char v111;
  _DWORD *v112;
  int v113;
  int v114;
  unsigned int v115;
  unsigned int v116;
  unsigned int v117;
  uint64_t v118;
  unint64_t v119;
  unsigned int v120;
  unsigned int v121;
  unsigned int v122;
  uint64_t v123;
  unint64_t v124;
  unint64_t v125;
  FILE *v126;
  uint64_t v127;
  size_t v128;
  uint64_t v129;
  size_t v130;
  size_t v131;
  size_t v132;
  unsigned __int8 *v133;
  unint64_t v134;
  int v135;
  _DWORD *v136;
  int v137;
  unint64_t v138;
  unsigned int v139;
  _DWORD *v140;
  unint64_t v141;
  _DWORD *v142;
  unint64_t v143;
  int v144;
  _DWORD *v145;
  int v146;
  unint64_t v147;
  int v148;
  _DWORD *v149;
  int v150;
  unint64_t v151;
  int v152;
  _DWORD *v153;
  int v154;
  unint64_t v155;
  unsigned int v156;
  unsigned int v157;
  unsigned int v158;
  uint64_t v159;
  unint64_t v160;
  int v161;
  _DWORD *v162;
  char v163;
  unsigned int v164;
  unsigned int v165;
  int v166;
  _DWORD *v167;
  char v168;
  unint64_t v169;
  unint64_t v170;
  int v171;
  _DWORD *v172;
  char v173;
  unsigned int v174;
  unsigned int v175;
  unsigned int v176;
  uint64_t v177;
  unint64_t v178;
  int v179;
  _DWORD *v180;
  int v181;
  unsigned int v182;
  unsigned int v183;
  int v184;
  _DWORD *v185;
  char v186;
  unsigned int v187;
  unsigned int v188;
  unsigned int v189;
  uint64_t v190;
  unint64_t v191;
  int v192;
  _DWORD *v193;
  int v194;
  unint64_t v195;
  unsigned int v196;
  _DWORD *v197;
  unsigned int v198;
  unsigned __int8 v199;
  unint64_t v200;
  unsigned int v201;
  unsigned int v202;
  unsigned int v203;
  uint64_t v204;
  unint64_t v205;
  unsigned int v206;
  _DWORD *v207;
  unsigned int v208;
  unsigned int v209;
  unsigned int v210;
  unsigned int v211;
  uint64_t v212;
  unint64_t v213;
  unsigned int v214;
  _DWORD *v215;
  unsigned int v216;
  unsigned int v217;
  unsigned int v218;
  unsigned int v219;
  uint64_t v220;
  unint64_t v221;
  unsigned int v222;
  unsigned int v223;
  unsigned int v224;
  uint64_t v225;
  unint64_t v226;
  int v227;
  _DWORD *v228;
  char v229;
  unsigned int v230;
  unsigned int v231;
  int v232;
  _DWORD *v233;
  char v234;
  unsigned int v235;
  unsigned int v236;
  unsigned int v237;
  uint64_t v238;
  unint64_t v239;
  int v240;
  _DWORD *v241;
  int v242;
  unsigned int v243;
  unsigned int v244;
  int v245;
  _DWORD *v246;
  char v247;
  unsigned int v248;
  unsigned int v249;
  unsigned int v250;
  uint64_t v251;
  unint64_t v252;
  int v253;
  _DWORD *v254;
  int v255;
  unsigned int v256;
  unsigned int v257;
  int v258;
  _DWORD *v259;
  char v260;
  unint64_t v261;
  char v262;
  _DWORD *v263;
  int v264;
  int v265;
  unint64_t v266;
  unint64_t v267;
  int v268;
  _DWORD *v269;
  int v270;
  unint64_t v271;
  int v272;
  _DWORD *v273;
  int v274;
  unint64_t v275;
  char v276;
  _DWORD *v277;
  int v278;
  int v279;
  unint64_t v280;
  int v281;
  _DWORD *v282;
  int v283;
  unint64_t v284;
  int v285;
  _DWORD *v286;
  int v287;
  unsigned int v288;
  unsigned int v289;
  unsigned int v290;
  uint64_t v291;
  unint64_t v292;
  int v293;
  _DWORD *v294;
  int v295;
  unsigned int v296;
  unsigned int v297;
  int v298;
  _DWORD *v299;
  char v300;
  unint64_t v301;
  unsigned int v302;
  unsigned int v303;
  unsigned int v304;
  uint64_t v305;
  unint64_t v306;
  int v307;
  _DWORD *v308;
  char v309;
  uint64_t v310;
  unint64_t v311;
  unint64_t v312;
  char v313;
  _DWORD *v314;
  unsigned int v315;
  unsigned int v316;
  unsigned int v317;
  unsigned int v318;
  unsigned int v319;
  uint64_t v320;
  unint64_t v321;
  unint64_t v322;
  unsigned int v323;
  unsigned int v324;
  unsigned int v325;
  uint64_t v326;
  unint64_t v327;
  _DWORD *v328;
  unint64_t v329;
  unint64_t v330;
  int v331;
  _DWORD *v332;
  int v333;
  unint64_t v334;
  int v335;
  _DWORD *v336;
  int v337;
  unint64_t v338;
  _DWORD *v339;
  char v340;
  int v341;
  int v342;
  unsigned __int8 *v343;
  unint64_t v344;
  int v345;
  _DWORD *v346;
  int v347;
  unint64_t v348;
  unsigned int v349;
  _DWORD *v350;
  unint64_t v351;
  int v352;
  _DWORD *v353;
  int v354;
  unint64_t v355;
  int v356;
  _DWORD *v357;
  int v358;
  unsigned int v359;
  unsigned int v360;
  unsigned int v361;
  uint64_t v362;
  unint64_t v363;
  int v364;
  _DWORD *v365;
  int v366;
  unsigned int v367;
  unsigned int v368;
  int v369;
  _DWORD *v370;
  char v371;
  uint64_t v372;
  uint64_t v373;
  _QWORD *v374;
  _QWORD *v375;
  unint64_t v376;
  int v377;
  _DWORD *v378;
  int v379;
  unint64_t v380;
  int v381;
  _DWORD *v382;
  int v383;
  unint64_t v384;
  int v385;
  _DWORD *v386;
  int v387;
  unint64_t v388;
  int v389;
  _DWORD *v390;
  int v391;
  unint64_t v392;
  int v393;
  _DWORD *v394;
  int v395;
  unsigned int v396;
  unsigned int v397;
  unsigned int v398;
  uint64_t v399;
  unint64_t v400;
  int v401;
  _DWORD *v402;
  int v403;
  unsigned int v404;
  unsigned int v405;
  int v406;
  _DWORD *v407;
  char v408;
  int v409;
  int v410;
  unsigned int v411;
  unsigned int v412;
  unsigned int v413;
  uint64_t v414;
  unint64_t v415;
  int v416;
  _DWORD *v417;
  int v418;
  unint64_t v419;
  int v420;
  _DWORD *v421;
  int v422;
  unint64_t v423;
  int v424;
  _DWORD *v425;
  int v426;
  unint64_t v427;
  char v428;
  _DWORD *v429;
  int v430;
  int v431;
  unsigned int v432;
  unsigned int v433;
  unsigned int v434;
  uint64_t v435;
  unint64_t v436;
  int v437;
  int v438;
  unsigned int v439;
  unsigned int v440;
  uint64_t v441;
  unint64_t v442;
  int v443;
  _DWORD *v444;
  int v445;
  int v446;
  int v447;
  unsigned int v448;
  unsigned int v449;
  unint64_t v450;
  int v451;
  _DWORD *v452;
  int v453;
  unint64_t v454;
  int v455;
  _DWORD *v456;
  int v457;
  unint64_t v458;
  int v459;
  _DWORD *v460;
  int v461;
  unint64_t v462;
  int v463;
  _DWORD *v464;
  int v465;
  unint64_t v466;
  int v467;
  _DWORD *v468;
  int v469;
  unint64_t v470;
  int v471;
  _DWORD *v472;
  int v473;
  unint64_t v474;
  char v475;
  _DWORD *v476;
  int v477;
  int v478;
  unsigned int v479;
  unsigned int v480;
  unsigned int v481;
  uint64_t v482;
  unint64_t v483;
  int v484;
  _DWORD *v485;
  int v486;
  unsigned int v487;
  unsigned int v488;
  int v489;
  _DWORD *v490;
  char v491;
  unint64_t v492;
  unsigned int v493;
  _DWORD *v494;
  unsigned int v495;
  unint64_t v496;
  unsigned int v497;
  unsigned int v498;
  unsigned int v499;
  uint64_t v500;
  unint64_t v501;
  unint64_t v502;
  unsigned int v503;
  unsigned int v504;
  unsigned int v505;
  uint64_t v506;
  unint64_t v507;
  unint64_t v508;
  unint64_t v509;
  int v510;
  _DWORD *v511;
  int v512;
  char v513;
  _DWORD *v514;
  unint64_t v515;
  int v516;
  unint64_t v517;
  int v518;
  _DWORD *v519;
  int v520;
  char v521;
  int v522;
  int v523;
  unsigned int v524;
  unsigned int v525;
  uint64_t v526;
  unint64_t v527;
  int v528;
  int v529;
  int v530;
  int v531;
  unsigned int v532;
  unsigned int v533;
  unint64_t v534;
  unint64_t v535;
  unsigned int v536;
  _DWORD *v537;
  unsigned int v538;
  unint64_t v539;
  int v540;
  _DWORD *v541;
  int v542;
  unsigned int v543;
  unsigned int v544;
  unsigned int v545;
  uint64_t v546;
  unint64_t v547;
  int v548;
  _DWORD *v549;
  int v550;
  unint64_t v551;
  int v552;
  _DWORD *v553;
  int v554;
  unint64_t v555;
  FILE *v556;
  void *v557;
  size_t v558;
  CFIndex v559;
  const __CFAllocator *v560;
  CFDataRef v561;
  __CFDictionary *Mutable;
  __CFDictionary *v563;
  const void *v564;
  const void *v565;
  const void *v566;
  int v567;
  int v568;
  unsigned __int8 *v569;
  int v570;
  int v571;
  int v572;
  char v573;
  _DWORD *v574;
  unint64_t v575;
  int v576;
  unint64_t v577;
  int v578;
  _DWORD *v579;
  char v580;
  unint64_t v581;
  int v582;
  char v583;
  unint64_t v584;
  unint64_t v585;
  char v586;
  _DWORD *v587;
  int v588;
  int v589;
  unint64_t v590;
  unint64_t v591;
  char v592;
  _DWORD *v593;
  int v594;
  int v595;
  unint64_t v596;
  int v597;
  _DWORD *v598;
  int v599;
  unint64_t v600;
  int v601;
  _DWORD *v602;
  int v603;
  unint64_t v604;
  char v605;
  unint64_t v606;
  int v607;
  _DWORD *v608;
  char v609;
  unint64_t v610;
  int v611;
  _DWORD *v612;
  char v613;
  unint64_t v614;
  unint64_t v615;
  char v616;
  _DWORD *v617;
  int v618;
  int v619;
  unsigned int v620;
  unsigned int v621;
  unsigned int v622;
  uint64_t v623;
  unint64_t v624;
  int v625;
  _DWORD *v626;
  unsigned int v627;
  unsigned int v628;
  unint64_t v629;
  int v630;
  _DWORD *v631;
  int v632;
  unint64_t v633;
  int v634;
  _DWORD *v635;
  int v636;
  unint64_t v637;
  int v638;
  _DWORD *v639;
  int v640;
  unint64_t v641;
  char v642;
  _DWORD *v643;
  int v644;
  int v645;
  unsigned int v646;
  unsigned int v647;
  unsigned int v648;
  uint64_t v649;
  unint64_t v650;
  int v651;
  _DWORD *v652;
  int v653;
  unsigned int v654;
  unsigned int v655;
  int v656;
  _DWORD *v657;
  char v658;
  unsigned int v659;
  unsigned int v660;
  unsigned int v661;
  uint64_t v662;
  unint64_t v663;
  int v664;
  _DWORD *v665;
  unsigned int v666;
  unsigned int v667;
  unint64_t v668;
  char v669;
  _DWORD *v670;
  unsigned int v671;
  unsigned int v672;
  unsigned int v673;
  unint64_t v674;
  int v675;
  _DWORD *v676;
  char v677;
  unint64_t v678;
  int v679;
  _DWORD *v680;
  char v681;
  unsigned int v682;
  unint64_t v683;
  int v684;
  _DWORD *v685;
  char v686;
  unint64_t v687;
  int v688;
  _DWORD *v689;
  char v690;
  unint64_t v691;
  char v692;
  _DWORD *v693;
  int v694;
  int v695;
  unsigned int v696;
  unsigned int v697;
  unsigned int v698;
  uint64_t v699;
  unint64_t v700;
  unint64_t v701;
  unint64_t v702;
  unint64_t v703;
  int v704;
  _DWORD *v705;
  int v706;
  unint64_t v707;
  int v708;
  _DWORD *v709;
  int v710;
  unint64_t v711;
  int v712;
  _DWORD *v713;
  int v714;
  unsigned int v715;
  unsigned int v716;
  unsigned int v717;
  uint64_t v718;
  unint64_t v719;
  int v720;
  _DWORD *v721;
  int v722;
  unsigned int v723;
  unsigned int v724;
  unint64_t v725;
  int v726;
  _DWORD *v727;
  int v728;
  unsigned int v729;
  unsigned int v730;
  unsigned int v731;
  uint64_t v732;
  unint64_t v733;
  int v734;
  _DWORD *v735;
  int v736;
  unsigned int v737;
  unsigned int v738;
  unint64_t v739;
  int v740;
  _DWORD *v741;
  int v742;
  unsigned int v743;
  unsigned int v744;
  unsigned int v745;
  uint64_t v746;
  unint64_t v747;
  unint64_t v748;
  FILE *v749;
  size_t v750;
  size_t v751;
  size_t v752;
  void *v753;
  uint64_t v754;
  uint64_t v755;
  _DWORD *v756;
  _DWORD *v757;
  unint64_t v758;
  char v759;
  unint64_t *v760[5];
  unsigned __int8 *v761[5];
  _BYTE v762[3];
  char v763;
  _BYTE v764[3];
  _BYTE v765[5];
  _BYTE __ptr[3];
  _BYTE v767[505];

  *(_QWORD *)&v767[497] = *MEMORY[0x1E0C80C00];
  v751 = 0;
  v752 = 0;
  v750 = 0;
  v2 = (const void *)(a1 + 368);
  v3 = strnlen((const char *)(a1 + 368), 0x3E9uLL);
  v761[0] = v767;
  v761[1] = v765;
  v761[3] = 0;
  v761[4] = 0;
  v761[2] = (unsigned __int8 *)&v763;
  v760[0] = &v752;
  v760[1] = &v751;
  v760[3] = 0;
  v760[4] = 0;
  v760[2] = &v750;
  if (*(_BYTE *)(a1 + 1384))
  {
LABEL_2:
    FigSignalErrorAt();
    v4 = 0;
    VideoFormatDescription = 0;
LABEL_3:
    free(v4);
    return VideoFormatDescription;
  }
  v7 = v3;
  v8 = *(_QWORD *)(a1 + 16);
  v753 = 0;
  v754 = 0;
  v757 = 0;
  v758 = 0;
  v756 = 0;
  if (sub_1B67C8F84(&v753, 1024))
  {
    v9 = 0;
  }
  else
  {
    v10 = *(_QWORD *)(v8 + 12672);
    *v756 = bswap32(v758);
    v11 = SHIDWORD(v758) + 1;
    v12 = (_DWORD)v758 << (v11 & 0xF8);
    v13 = (_DWORD *)((char *)v756 + (v11 >> 3));
    v756 = v13;
    v14 = v11 & 7;
    HIDWORD(v758) = v14;
    if (v13 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v13 = v757;
    }
    LODWORD(v758) = (32 << (26 - v14)) | v12;
    *v13 = bswap32(v758);
    v15 = SHIDWORD(v758) + 6;
    v16 = (_DWORD)v758 << (v15 & 0xF8);
    v17 = (_DWORD *)((char *)v756 + (v15 >> 3));
    v756 = v17;
    LODWORD(v758) = v16;
    HIDWORD(v758) = v15 & 7;
    if (v17 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v17 = v757;
    }
    *v17 = bswap32(v16);
    v18 = SHIDWORD(v758) + 6;
    v19 = (_DWORD *)((char *)v756 + (v18 >> 3));
    v756 = v19;
    HIDWORD(v758) = v18 & 7;
    if (v19 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v19 = v757;
    }
    LODWORD(v758) = (1 << (29 - (v18 & 7))) | ((_DWORD)v758 << (v18 & 0xF8));
    *v19 = bswap32(v758);
    v20 = SHIDWORD(v758) + 3;
    v21 = (_DWORD)v758 << (v20 & 0xF8);
    v22 = (_DWORD *)((char *)v756 + (v20 >> 3));
    v756 = v22;
    v23 = v20 & 7;
    HIDWORD(v758) = v23;
    if (v22 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v22 = v757;
    }
    LODWORD(v758) = (*(unsigned __int8 *)(v10 + 168) << (28 - v23)) | v21;
    *v22 = bswap32(v758);
    v24 = SHIDWORD(v758) + 4;
    v25 = (_DWORD)v758 << (v24 & 0xF8);
    v26 = (_DWORD *)((char *)v756 + (v24 >> 3));
    v756 = v26;
    v27 = v24 & 7;
    HIDWORD(v758) = v27;
    if (v26 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v26 = v757;
    }
    LODWORD(v758) = (3 << (30 - v27)) | v25;
    *v26 = bswap32(v758);
    v28 = SHIDWORD(v758) + 2;
    v29 = (_DWORD)v758 << (v28 & 0xF8);
    v30 = (_DWORD *)((char *)v756 + (v28 >> 3));
    v756 = v30;
    LODWORD(v758) = v29;
    HIDWORD(v758) = v28 & 7;
    if (v30 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v30 = v757;
    }
    *v30 = bswap32(v29);
    v31 = SHIDWORD(v758) + 6;
    v32 = (_DWORD)v758 << (v31 & 0xF8);
    v33 = (_DWORD *)((char *)v756 + (v31 >> 3));
    v756 = v33;
    v34 = v31 & 7;
    HIDWORD(v758) = v34;
    if (v33 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v33 = v757;
    }
    LODWORD(v758) = (*(unsigned __int8 *)(v10 + 169) << (29 - v34)) | v32;
    *v33 = bswap32(v758);
    v35 = SHIDWORD(v758) + 3;
    v36 = (_DWORD)v758 << (v35 & 0xF8);
    v37 = (_DWORD *)((char *)v756 + (v35 >> 3));
    v756 = v37;
    v38 = v35 & 7;
    HIDWORD(v758) = v38;
    if (v37 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v37 = v757;
    }
    LODWORD(v758) = (*(unsigned __int8 *)(v10 + 170) << (v38 ^ 0x1F)) | v36;
    *v37 = bswap32(v758);
    v39 = SHIDWORD(v758) + 1;
    v40 = (_DWORD)v758 << (v39 & 0xF8);
    v41 = (_DWORD *)((char *)v756 + (v39 >> 3));
    v756 = v41;
    v42 = v39 & 7;
    HIDWORD(v758) = v42;
    if (v41 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v41 = v757;
    }
    LODWORD(v758) = (0xFFFF << (16 - v42)) | v40;
    *v41 = bswap32(v758);
    v43 = SHIDWORD(v758) + 16;
    v756 = (_DWORD *)((char *)v756 + (v43 >> 3));
    v758 = __PAIR64__(HIDWORD(v758), (_DWORD)v758 << (v43 & 0xF8)) & 0x7FFFFFFFFLL;
    if (v756 >= v757)
    {
      v759 = 1;
      v756 = v757;
    }
    sub_1B6803618((unsigned __int8 *)v10, *(unsigned __int8 *)(v10 + 169), (uint64_t)&v753);
    LODWORD(v758) = (*(unsigned __int8 *)(v10 + 171) << ~BYTE4(v758)) | v758;
    *v756 = bswap32(v758);
    v44 = SHIDWORD(v758) + 1;
    v45 = (_DWORD)v758 << (v44 & 0xF8);
    v46 = (_DWORD *)((char *)v756 + (v44 >> 3));
    v756 = v46;
    LOBYTE(v47) = v44 & 7;
    LODWORD(v758) = v45;
    HIDWORD(v758) = v44 & 7;
    if (v46 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v46 = v757;
    }
    if (*(_BYTE *)(v10 + 171))
      v48 = 0;
    else
      v48 = *(_BYTE *)(v10 + 169);
    v49 = v48;
    do
    {
      v50 = *(unsigned __int8 *)(v10 + v49 + 172) + 1;
      v51 = __clz(v50);
      v52 = 0x80000000 >> v51;
      v53 = (2 * v51) ^ 0x3F;
      LODWORD(v758) = (((v50 - v52) | v52) << (-(char)v47 - v53)) | v45;
      *v46 = bswap32(v758);
      v54 = SHIDWORD(v758) + v53;
      v55 = (_DWORD)v758 << (v54 & 0xF8);
      v56 = (_DWORD *)((char *)v756 + (v54 >> 3));
      v756 = v56;
      v57 = v54 & 7;
      v758 = __PAIR64__(v57, v55);
      if (v56 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v56 = v757;
      }
      v58 = *(unsigned __int8 *)(v10 + v49 + 179) + 1;
      v59 = __clz(v58);
      v60 = (v58 - (0x80000000 >> v59)) | (0x80000000 >> v59);
      v61 = (2 * v59) ^ 0x3F;
      LODWORD(v758) = (v60 << (-(char)v61 - v57)) | v55;
      *v56 = bswap32(v758);
      v62 = SHIDWORD(v758) + v61;
      v63 = (_DWORD)v758 << (v62 & 0xF8);
      v64 = (_DWORD *)((char *)v756 + (v62 >> 3));
      v756 = v64;
      v65 = v62 & 7;
      v758 = __PAIR64__(v65, v63);
      if (v64 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v64 = v757;
      }
      v66 = *(_DWORD *)(v10 + 4 * v49 + 188) + 1;
      v67 = __clz(v66);
      v68 = (v66 - (0x80000000 >> v67)) | (0x80000000 >> v67);
      v69 = 63 - 2 * v67;
      LODWORD(v758) = (v68 << (-(char)v69 - v65)) | v63;
      *v64 = bswap32(v758);
      v70 = SHIDWORD(v758) + v69;
      v45 = (_DWORD)v758 << (v70 & 0xF8);
      v46 = (_DWORD *)((char *)v756 + (v70 >> 3));
      v756 = v46;
      v47 = v70 & 7;
      v758 = __PAIR64__(v47, v45);
      if (v46 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v46 = v757;
      }
      v71 = v49++ >= *(unsigned __int8 *)(v10 + 169);
    }
    while (!v71);
    LODWORD(v758) = (*(unsigned __int8 *)(v10 + 216) << (26 - v47)) | v45;
    *v46 = bswap32(v758);
    v72 = SHIDWORD(v758) + 6;
    v73 = (_DWORD)v758 << (v72 & 0xF8);
    v74 = (_DWORD *)((char *)v756 + (v72 >> 3));
    v756 = v74;
    v75 = v72 & 7;
    HIDWORD(v758) = v75;
    if (v74 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v74 = v757;
    }
    v76 = *(unsigned __int16 *)(v10 + 218) + 1;
    v77 = __clz(v76);
    v78 = 0x80000000 >> v77;
    v79 = (2 * v77) ^ 0x3F;
    LODWORD(v758) = (((v76 - v78) | v78) << (-(char)v75 - v79)) | v73;
    *v74 = bswap32(v758);
    v80 = SHIDWORD(v758) + v79;
    v81 = (_DWORD)v758 << (v80 & 0xF8);
    v82 = (_DWORD *)((char *)v756 + (v80 >> 3));
    v756 = v82;
    v83 = v80 & 7;
    HIDWORD(v758) = v83;
    if (v82 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v82 = v757;
    }
    if (*(_WORD *)(v10 + 218))
    {
      v84 = 1;
      do
      {
        v85 = -1;
        do
        {
          LODWORD(v758) = (((*(_QWORD *)(*(_QWORD *)(v10 + 224) + 8 * v84) >> ++v85) & 1) << ~(_BYTE)v83) | v81;
          *v82 = bswap32(v758);
          v86 = SHIDWORD(v758) + 1;
          v81 = (_DWORD)v758 << (v86 & 0xF8);
          v82 = (_DWORD *)((char *)v756 + (v86 >> 3));
          v756 = v82;
          v83 = v86 & 7;
          v758 = __PAIR64__(v83, v81);
          if (v82 >= v757)
          {
            v759 = 1;
            v756 = v757;
            v82 = v757;
          }
        }
        while (v85 < *(unsigned __int8 *)(v10 + 216));
        v71 = v84++ >= *(unsigned __int16 *)(v10 + 218);
      }
      while (!v71);
    }
    LODWORD(v758) = (*(unsigned __int8 *)(v10 + 240) << (v83 ^ 0x1F)) | v81;
    *v82 = bswap32(v758);
    v87 = SHIDWORD(v758) + 1;
    v88 = v87 & 0xF8;
    v89 = (_DWORD *)((char *)v756 + (v87 >> 3));
    v756 = v89;
    v90 = v87 & 7;
    HIDWORD(v758) = v90;
    if (v89 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v89 = v757;
    }
    v91 = (_DWORD)v758 << v88;
    if (*(_BYTE *)(v10 + 240))
    {
      v92 = *(_DWORD *)(v10 + 244);
      LODWORD(v758) = (HIWORD(v92) << (16 - v90)) | v91;
      *v89 = bswap32(v758);
      v93 = SHIDWORD(v758) + 16;
      v94 = (_DWORD)v758 << (v93 & 0xF8);
      v95 = (_DWORD *)((char *)v756 + (v93 >> 3));
      v756 = v95;
      v96 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v95 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v95 = v757;
      }
      LODWORD(v758) = ((unsigned __int16)v92 << (16 - v96)) | v94;
      *v95 = bswap32(v758);
      v97 = SHIDWORD(v758) + 16;
      v98 = (_DWORD)v758 << (v97 & 0xF8);
      v99 = (_DWORD *)((char *)v756 + (v97 >> 3));
      v756 = v99;
      v100 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v99 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v99 = v757;
      }
      v101 = *(_DWORD *)(v10 + 248);
      LODWORD(v758) = (HIWORD(v101) << (16 - v100)) | v98;
      *v99 = bswap32(v758);
      v102 = SHIDWORD(v758) + 16;
      v103 = (_DWORD)v758 << (v102 & 0xF8);
      v104 = (_DWORD *)((char *)v756 + (v102 >> 3));
      v756 = v104;
      v105 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v104 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v104 = v757;
      }
      LODWORD(v758) = ((unsigned __int16)v101 << (16 - v105)) | v103;
      *v104 = bswap32(v758);
      v106 = SHIDWORD(v758) + 16;
      v107 = (_DWORD)v758 << (v106 & 0xF8);
      v108 = (_DWORD *)((char *)v756 + (v106 >> 3));
      v756 = v108;
      v109 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v108 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v108 = v757;
      }
      LODWORD(v758) = (*(unsigned __int8 *)(v10 + 252) << (v109 ^ 0x1F)) | v107;
      *v108 = bswap32(v758);
      v110 = SHIDWORD(v758) + 1;
      v111 = v110 & 0xF8;
      v112 = (_DWORD *)((char *)v756 + (v110 >> 3));
      v756 = v112;
      v113 = v110 & 7;
      HIDWORD(v758) = v113;
      if (v112 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v112 = v757;
      }
      v114 = (_DWORD)v758 << v111;
      if (*(_BYTE *)(v10 + 252))
      {
        v115 = *(_DWORD *)(v10 + 256) + 1;
        v116 = __clz(v115);
        v117 = (v115 - (0x80000000 >> v116)) | (0x80000000 >> v116);
        v118 = 63 - 2 * v116;
        LODWORD(v758) = (v117 << (-(char)v113 - v118)) | v114;
        *v112 = bswap32(v758);
        v119 = SHIDWORD(v758) + v118;
        v114 = (_DWORD)v758 << (v119 & 0xF8);
        v112 = (_DWORD *)((char *)v756 + (v119 >> 3));
        v756 = v112;
        v113 = v119 & 7;
        HIDWORD(v758) = v113;
        if (v112 >= v757)
        {
          v759 = 1;
          v756 = v757;
          v112 = v757;
        }
      }
      v120 = *(unsigned __int16 *)(v10 + 260) + 1;
      v121 = __clz(v120);
      v122 = 0x80000000 >> v121;
      v123 = (2 * v121) ^ 0x3F;
      LODWORD(v758) = (((v120 - v122) | v122) << (-(char)v113 - v123)) | v114;
      *v112 = bswap32(v758);
      v124 = SHIDWORD(v758) + v123;
      v91 = (_DWORD)v758 << (v124 & 0xF8);
      v89 = (_DWORD *)((char *)v756 + (v124 >> 3));
      v756 = v89;
      v90 = v124 & 7;
      HIDWORD(v758) = v90;
      if (v89 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v89 = v757;
      }
    }
    LODWORD(v758) = (*(unsigned __int8 *)(v10 + 262) << (v90 ^ 0x1F)) | v91;
    *v89 = bswap32(v758);
    v125 = SHIDWORD(v758) + 1;
    v756 = (_DWORD *)((char *)v756 + (v125 >> 3));
    LODWORD(v758) = (_DWORD)v758 << (v125 & 0xF8);
    HIDWORD(v758) = v125 & 7;
    if (v756 >= v757)
    {
      v759 = 1;
      v756 = v757;
    }
    sub_1B67C939C((uint64_t)&v753);
    v9 = off_1EF137C48(__ptr, 0, v755, (char *)v756 - v755, 2);
    *(_DWORD *)(v8 + 12720) += v9;
    v126 = *(FILE **)(v8 + 88);
    if (v126)
      fwrite(__ptr, 1uLL, v9, v126);
  }
  if (v753)
    free(v753);
  v752 = v9;
  v753 = 0;
  v127 = *(_QWORD *)(a1 + 16);
  v754 = 0;
  v757 = 0;
  v758 = 0;
  v756 = 0;
  if (sub_1B67C8F84(&v753, 1024))
    goto LABEL_78;
  v133 = *(unsigned __int8 **)(v127 + 12688);
  *v756 = bswap32(v758);
  v134 = SHIDWORD(v758) + 1;
  v135 = (_DWORD)v758 << (v134 & 0xF8);
  v136 = (_DWORD *)((char *)v756 + (v134 >> 3));
  v756 = v136;
  v137 = v134 & 7;
  HIDWORD(v758) = v137;
  if (v136 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v136 = v757;
  }
  LODWORD(v758) = (33 << (26 - v137)) | v135;
  *v136 = bswap32(v758);
  v138 = SHIDWORD(v758) + 6;
  v139 = (_DWORD)v758 << (v138 & 0xF8);
  v140 = (_DWORD *)((char *)v756 + (v138 >> 3));
  v756 = v140;
  LODWORD(v758) = v139;
  HIDWORD(v758) = v138 & 7;
  if (v140 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v140 = v757;
  }
  *v140 = bswap32(v139);
  v141 = SHIDWORD(v758) + 6;
  v142 = (_DWORD *)((char *)v756 + (v141 >> 3));
  v756 = v142;
  HIDWORD(v758) = v141 & 7;
  if (v142 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v142 = v757;
  }
  LODWORD(v758) = (1 << (29 - (v141 & 7))) | ((_DWORD)v758 << (v141 & 0xF8));
  *v142 = bswap32(v758);
  v143 = SHIDWORD(v758) + 3;
  v144 = (_DWORD)v758 << (v143 & 0xF8);
  v145 = (_DWORD *)((char *)v756 + (v143 >> 3));
  v756 = v145;
  v146 = v143 & 7;
  HIDWORD(v758) = v146;
  if (v145 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v145 = v757;
  }
  LODWORD(v758) = (*v133 << (28 - v146)) | v144;
  *v145 = bswap32(v758);
  v147 = SHIDWORD(v758) + 4;
  v148 = (_DWORD)v758 << (v147 & 0xF8);
  v149 = (_DWORD *)((char *)v756 + (v147 >> 3));
  v756 = v149;
  v150 = v147 & 7;
  HIDWORD(v758) = v150;
  if (v149 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v149 = v757;
  }
  LODWORD(v758) = (v133[1] << (29 - v150)) | v148;
  *v149 = bswap32(v758);
  v151 = SHIDWORD(v758) + 3;
  v152 = (_DWORD)v758 << (v151 & 0xF8);
  v153 = (_DWORD *)((char *)v756 + (v151 >> 3));
  v756 = v153;
  v154 = v151 & 7;
  HIDWORD(v758) = v154;
  if (v153 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v153 = v757;
  }
  LODWORD(v758) = (v133[2] << (v154 ^ 0x1F)) | v152;
  *v153 = bswap32(v758);
  v155 = SHIDWORD(v758) + 1;
  v756 = (_DWORD *)((char *)v756 + (v155 >> 3));
  LODWORD(v758) = (_DWORD)v758 << (v155 & 0xF8);
  HIDWORD(v758) = v155 & 7;
  if (v756 >= v757)
  {
    v759 = 1;
    v756 = v757;
  }
  sub_1B6803618(v133 + 4, v133[1], (uint64_t)&v753);
  v156 = v133[172] + 1;
  v157 = __clz(v156);
  v158 = (v156 - (0x80000000 >> v157)) | (0x80000000 >> v157);
  v159 = (2 * v157) ^ 0x3F;
  LODWORD(v758) = (v158 << (-BYTE4(v758) - v159)) | v758;
  *v756 = bswap32(v758);
  v160 = SHIDWORD(v758) + v159;
  v161 = (_DWORD)v758 << (v160 & 0xF8);
  v162 = (_DWORD *)((char *)v756 + (v160 >> 3));
  v756 = v162;
  v163 = v160 & 7;
  HIDWORD(v758) = v160 & 7;
  if (v162 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v162 = v757;
  }
  v164 = v133[173] + 1;
  v165 = __clz(v164);
  LODWORD(v758) = (((v164 - (0x80000000 >> v165)) | (0x80000000 >> v165)) << (-((2 * v165) ^ 0x3F) - v163)) | v161;
  *v162 = bswap32(v758);
  v166 = (_DWORD)v758 << ((BYTE4(v758) + ((2 * v165) ^ 0x3F)) & 0xF8);
  v167 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v165) ^ 0x3FuLL)) >> 3));
  v756 = v167;
  v168 = (BYTE4(v758) + ((2 * v165) ^ 0x3F)) & 7;
  LODWORD(v758) = v166;
  HIDWORD(v758) = (HIDWORD(v758) + ((2 * v165) ^ 0x3F)) & 7;
  if (v167 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v167 = v757;
  }
  if (v133[173] == 3)
  {
    LODWORD(v758) = (v133[174] << (v168 ^ 0x1F)) | v166;
    *v167 = bswap32(v758);
    v169 = SHIDWORD(v758) + 1;
    v756 = (_DWORD *)((char *)v756 + (v169 >> 3));
    LODWORD(v758) = (_DWORD)v758 << (v169 & 0xF8);
    HIDWORD(v758) = v169 & 7;
    if (v756 >= v757)
    {
      v759 = 1;
      v756 = v757;
    }
  }
  sub_1B67C9248((uint64_t)&v753, *((_DWORD *)v133 + 44));
  sub_1B67C9248((uint64_t)&v753, *((_DWORD *)v133 + 45));
  LODWORD(v758) = (v133[184] << ~BYTE4(v758)) | v758;
  *v756 = bswap32(v758);
  v170 = SHIDWORD(v758) + 1;
  v171 = (_DWORD)v758 << (v170 & 0xF8);
  v172 = (_DWORD *)((char *)v756 + (v170 >> 3));
  v756 = v172;
  v173 = v170 & 7;
  LODWORD(v758) = v171;
  HIDWORD(v758) = v170 & 7;
  if (v172 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v172 = v757;
  }
  if (v133[184])
  {
    sub_1B67C9248((uint64_t)&v753, *((unsigned __int16 *)v133 + 93));
    sub_1B67C9248((uint64_t)&v753, *((unsigned __int16 *)v133 + 94));
    sub_1B67C9248((uint64_t)&v753, *((unsigned __int16 *)v133 + 95));
    sub_1B67C9248((uint64_t)&v753, *((unsigned __int16 *)v133 + 96));
    v171 = v758;
    v173 = BYTE4(v758);
    v172 = v756;
  }
  v174 = v133[194] + 1;
  v175 = __clz(v174);
  v176 = 0x80000000 >> v175;
  v177 = (2 * v175) ^ 0x3F;
  LODWORD(v758) = (((v174 - v176) | v176) << (-v173 - v177)) | v171;
  *v172 = bswap32(v758);
  v178 = SHIDWORD(v758) + v177;
  v179 = (_DWORD)v758 << (v178 & 0xF8);
  v180 = (_DWORD *)((char *)v756 + (v178 >> 3));
  v756 = v180;
  v181 = v178 & 7;
  HIDWORD(v758) = v181;
  if (v180 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v180 = v757;
  }
  v182 = v133[195] + 1;
  v183 = __clz(v182);
  LODWORD(v758) = (((v182 - (0x80000000 >> v183)) | (0x80000000 >> v183)) << (-((2 * v183) ^ 0x3F) - v181)) | v179;
  *v180 = bswap32(v758);
  v184 = (_DWORD)v758 << ((BYTE4(v758) + ((2 * v183) ^ 0x3F)) & 0xF8);
  v185 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v183) ^ 0x3FuLL)) >> 3));
  v756 = v185;
  v186 = (BYTE4(v758) + ((2 * v183) ^ 0x3F)) & 7;
  HIDWORD(v758) = (HIDWORD(v758) + ((2 * v183) ^ 0x3F)) & 7;
  if (v185 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v185 = v757;
  }
  v187 = v133[196] + 1;
  v188 = __clz(v187);
  v189 = (v187 - (0x80000000 >> v188)) | (0x80000000 >> v188);
  v190 = (2 * v188) ^ 0x3F;
  LODWORD(v758) = (v189 << (-(char)v190 - v186)) | v184;
  *v185 = bswap32(v758);
  v191 = SHIDWORD(v758) + v190;
  v192 = (_DWORD)v758 << (v191 & 0xF8);
  v193 = (_DWORD *)((char *)v756 + (v191 >> 3));
  v756 = v193;
  v194 = v191 & 7;
  HIDWORD(v758) = v194;
  if (v193 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v193 = v757;
  }
  LODWORD(v758) = (v133[197] << (v194 ^ 0x1F)) | v192;
  *v193 = bswap32(v758);
  v195 = SHIDWORD(v758) + 1;
  v196 = (_DWORD)v758 << (v195 & 0xF8);
  v197 = (_DWORD *)((char *)v756 + (v195 >> 3));
  v756 = v197;
  LOBYTE(v198) = v195 & 7;
  LODWORD(v758) = v196;
  HIDWORD(v758) = v195 & 7;
  if (v197 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v197 = v757;
  }
  if (v133[197])
    v199 = 0;
  else
    v199 = v133[1];
  v200 = v199;
  do
  {
    v201 = v133[v200 + 198] + 1;
    v202 = __clz(v201);
    v203 = 0x80000000 >> v202;
    v204 = (2 * v202) ^ 0x3F;
    LODWORD(v758) = (((v201 - v203) | v203) << (-(char)v198 - v204)) | v196;
    *v197 = bswap32(v758);
    v205 = SHIDWORD(v758) + v204;
    v206 = (_DWORD)v758 << (v205 & 0xF8);
    v207 = (_DWORD *)((char *)v756 + (v205 >> 3));
    v756 = v207;
    v208 = v205 & 7;
    v758 = __PAIR64__(v208, v206);
    if (v207 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v207 = v757;
    }
    v209 = v133[v200 + 205] + 1;
    v210 = __clz(v209);
    v211 = (v209 - (0x80000000 >> v210)) | (0x80000000 >> v210);
    v212 = (2 * v210) ^ 0x3F;
    LODWORD(v758) = (v211 << (-(char)v212 - v208)) | v206;
    *v207 = bswap32(v758);
    v213 = SHIDWORD(v758) + v212;
    v214 = (_DWORD)v758 << (v213 & 0xF8);
    v215 = (_DWORD *)((char *)v756 + (v213 >> 3));
    v756 = v215;
    v216 = v213 & 7;
    v758 = __PAIR64__(v216, v214);
    if (v215 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v215 = v757;
    }
    v217 = *(_DWORD *)&v133[4 * v200 + 212] + 1;
    v218 = __clz(v217);
    v219 = (v217 - (0x80000000 >> v218)) | (0x80000000 >> v218);
    v220 = 63 - 2 * v218;
    LODWORD(v758) = (v219 << (-(char)v220 - v216)) | v214;
    *v215 = bswap32(v758);
    v221 = SHIDWORD(v758) + v220;
    v196 = (_DWORD)v758 << (v221 & 0xF8);
    v197 = (_DWORD *)((char *)v756 + (v221 >> 3));
    v756 = v197;
    v198 = v221 & 7;
    v758 = __PAIR64__(v198, v196);
    if (v197 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v197 = v757;
    }
    v71 = v200++ >= v133[1];
  }
  while (!v71);
  v222 = v133[240] + 1;
  v223 = __clz(v222);
  v224 = (v222 - (0x80000000 >> v223)) | (0x80000000 >> v223);
  v225 = (2 * v223) ^ 0x3F;
  LODWORD(v758) = (v224 << (-(char)v225 - v198)) | v196;
  *v197 = bswap32(v758);
  v226 = SHIDWORD(v758) + v225;
  v227 = (_DWORD)v758 << (v226 & 0xF8);
  v228 = (_DWORD *)((char *)v756 + (v226 >> 3));
  v756 = v228;
  v229 = v226 & 7;
  HIDWORD(v758) = v226 & 7;
  if (v228 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v228 = v757;
  }
  v230 = v133[241] + 1;
  v231 = __clz(v230);
  LODWORD(v758) = (((v230 - (0x80000000 >> v231)) | (0x80000000 >> v231)) << (-((2 * v231) ^ 0x3F) - v229)) | v227;
  *v228 = bswap32(v758);
  v232 = (_DWORD)v758 << ((BYTE4(v758) + ((2 * v231) ^ 0x3F)) & 0xF8);
  v233 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v231) ^ 0x3FuLL)) >> 3));
  v756 = v233;
  v234 = (BYTE4(v758) + ((2 * v231) ^ 0x3F)) & 7;
  HIDWORD(v758) = (HIDWORD(v758) + ((2 * v231) ^ 0x3F)) & 7;
  if (v233 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v233 = v757;
  }
  v235 = v133[242] + 1;
  v236 = __clz(v235);
  v237 = (v235 - (0x80000000 >> v236)) | (0x80000000 >> v236);
  v238 = (2 * v236) ^ 0x3F;
  LODWORD(v758) = (v237 << (-(char)v238 - v234)) | v232;
  *v233 = bswap32(v758);
  v239 = SHIDWORD(v758) + v238;
  v240 = (_DWORD)v758 << (v239 & 0xF8);
  v241 = (_DWORD *)((char *)v756 + (v239 >> 3));
  v756 = v241;
  v242 = v239 & 7;
  HIDWORD(v758) = v242;
  if (v241 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v241 = v757;
  }
  v243 = v133[243] + 1;
  v244 = __clz(v243);
  LODWORD(v758) = (((v243 - (0x80000000 >> v244)) | (0x80000000 >> v244)) << (-((2 * v244) ^ 0x3F) - v242)) | v240;
  *v241 = bswap32(v758);
  v245 = (_DWORD)v758 << ((BYTE4(v758) + ((2 * v244) ^ 0x3F)) & 0xF8);
  v246 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v244) ^ 0x3FuLL)) >> 3));
  v756 = v246;
  v247 = (BYTE4(v758) + ((2 * v244) ^ 0x3F)) & 7;
  HIDWORD(v758) = (HIDWORD(v758) + ((2 * v244) ^ 0x3F)) & 7;
  if (v246 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v246 = v757;
  }
  v248 = v133[244] + 1;
  v249 = __clz(v248);
  v250 = (v248 - (0x80000000 >> v249)) | (0x80000000 >> v249);
  v251 = (2 * v249) ^ 0x3F;
  LODWORD(v758) = (v250 << (-(char)v251 - v247)) | v245;
  *v246 = bswap32(v758);
  v252 = SHIDWORD(v758) + v251;
  v253 = (_DWORD)v758 << (v252 & 0xF8);
  v254 = (_DWORD *)((char *)v756 + (v252 >> 3));
  v756 = v254;
  v255 = v252 & 7;
  HIDWORD(v758) = v255;
  if (v254 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v254 = v757;
  }
  v256 = v133[245] + 1;
  v257 = __clz(v256);
  LODWORD(v758) = (((v256 - (0x80000000 >> v257)) | (0x80000000 >> v257)) << (-((2 * v257) ^ 0x3F) - v255)) | v253;
  *v254 = bswap32(v758);
  v258 = (_DWORD)v758 << ((BYTE4(v758) + ((2 * v257) ^ 0x3F)) & 0xF8);
  v259 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v257) ^ 0x3FuLL)) >> 3));
  v756 = v259;
  v260 = (BYTE4(v758) + ((2 * v257) ^ 0x3F)) & 7;
  HIDWORD(v758) = (HIDWORD(v758) + ((2 * v257) ^ 0x3F)) & 7;
  if (v259 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v259 = v757;
  }
  LODWORD(v758) = (v133[246] << (v260 ^ 0x1F)) | v258;
  *v259 = bswap32(v758);
  v261 = SHIDWORD(v758) + 1;
  v262 = v261 & 0xF8;
  v263 = (_DWORD *)((char *)v756 + (v261 >> 3));
  v756 = v263;
  v264 = v261 & 7;
  HIDWORD(v758) = v264;
  if (v263 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v263 = v757;
  }
  v265 = (_DWORD)v758 << v262;
  if (v133[246])
  {
    LODWORD(v758) = (v133[247] << (v264 ^ 0x1F)) | v265;
    *v263 = bswap32(v758);
    v266 = SHIDWORD(v758) + 1;
    v265 = (_DWORD)v758 << (v266 & 0xF8);
    v263 = (_DWORD *)((char *)v756 + (v266 >> 3));
    v756 = v263;
    v264 = v266 & 7;
    HIDWORD(v758) = v264;
    if (v263 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v263 = v757;
    }
  }
  LODWORD(v758) = (v133[248] << (v264 ^ 0x1F)) | v265;
  *v263 = bswap32(v758);
  v267 = SHIDWORD(v758) + 1;
  v268 = (_DWORD)v758 << (v267 & 0xF8);
  v269 = (_DWORD *)((char *)v756 + (v267 >> 3));
  v756 = v269;
  v270 = v267 & 7;
  HIDWORD(v758) = v270;
  if (v269 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v269 = v757;
  }
  LODWORD(v758) = (v133[249] << (v270 ^ 0x1F)) | v268;
  *v269 = bswap32(v758);
  v271 = SHIDWORD(v758) + 1;
  v272 = (_DWORD)v758 << (v271 & 0xF8);
  v273 = (_DWORD *)((char *)v756 + (v271 >> 3));
  v756 = v273;
  v274 = v271 & 7;
  HIDWORD(v758) = v274;
  if (v273 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v273 = v757;
  }
  LODWORD(v758) = (v133[250] << (v274 ^ 0x1F)) | v272;
  *v273 = bswap32(v758);
  v275 = SHIDWORD(v758) + 1;
  v276 = v275 & 0xF8;
  v277 = (_DWORD *)((char *)v756 + (v275 >> 3));
  v756 = v277;
  v278 = v275 & 7;
  HIDWORD(v758) = v278;
  if (v277 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v277 = v757;
  }
  v279 = (_DWORD)v758 << v276;
  if (v133[250])
  {
    LODWORD(v758) = (v133[251] << (28 - v278)) | v279;
    *v277 = bswap32(v758);
    v280 = SHIDWORD(v758) + 4;
    v281 = (_DWORD)v758 << (v280 & 0xF8);
    v282 = (_DWORD *)((char *)v756 + (v280 >> 3));
    v756 = v282;
    v283 = v280 & 7;
    HIDWORD(v758) = v283;
    if (v282 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v282 = v757;
    }
    LODWORD(v758) = (v133[252] << (28 - v283)) | v281;
    *v282 = bswap32(v758);
    v284 = SHIDWORD(v758) + 4;
    v285 = (_DWORD)v758 << (v284 & 0xF8);
    v286 = (_DWORD *)((char *)v756 + (v284 >> 3));
    v756 = v286;
    v287 = v284 & 7;
    HIDWORD(v758) = v287;
    if (v286 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v286 = v757;
    }
    v288 = v133[253] + 1;
    v289 = __clz(v288);
    v290 = 0x80000000 >> v289;
    v291 = (2 * v289) ^ 0x3F;
    LODWORD(v758) = (((v288 - v290) | v290) << (-(char)v287 - v291)) | v285;
    *v286 = bswap32(v758);
    v292 = SHIDWORD(v758) + v291;
    v293 = (_DWORD)v758 << (v292 & 0xF8);
    v294 = (_DWORD *)((char *)v756 + (v292 >> 3));
    v756 = v294;
    v295 = v292 & 7;
    HIDWORD(v758) = v295;
    if (v294 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v294 = v757;
    }
    v296 = v133[254] + 1;
    v297 = __clz(v296);
    LODWORD(v758) = (((v296 - (0x80000000 >> v297)) | (0x80000000 >> v297)) << (-((2 * v297) ^ 0x3F) - v295)) | v293;
    *v294 = bswap32(v758);
    v298 = (_DWORD)v758 << ((BYTE4(v758) + ((2 * v297) ^ 0x3F)) & 0xF8);
    v299 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v297) ^ 0x3FuLL)) >> 3));
    v756 = v299;
    v300 = (BYTE4(v758) + ((2 * v297) ^ 0x3F)) & 7;
    HIDWORD(v758) = (HIDWORD(v758) + ((2 * v297) ^ 0x3F)) & 7;
    if (v299 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v299 = v757;
    }
    LODWORD(v758) = (v133[255] << (v300 ^ 0x1F)) | v298;
    *v299 = bswap32(v758);
    v301 = SHIDWORD(v758) + 1;
    v279 = (_DWORD)v758 << (v301 & 0xF8);
    v277 = (_DWORD *)((char *)v756 + (v301 >> 3));
    v756 = v277;
    v278 = v301 & 7;
    HIDWORD(v758) = v278;
    if (v277 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v277 = v757;
    }
  }
  v302 = *((_DWORD *)v133 + 65) + 1;
  v303 = __clz(v302);
  v304 = (v302 - (0x80000000 >> v303)) | (0x80000000 >> v303);
  v305 = 63 - 2 * v303;
  LODWORD(v758) = (v304 << (-(char)v278 - v305)) | v279;
  *v277 = bswap32(v758);
  v306 = SHIDWORD(v758) + v305;
  v307 = (_DWORD)v758 << (v306 & 0xF8);
  v308 = (_DWORD *)((char *)v756 + (v306 >> 3));
  v756 = v308;
  v309 = v306 & 7;
  LODWORD(v758) = v307;
  HIDWORD(v758) = v306 & 7;
  if (v308 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v308 = v757;
  }
  if (*((_DWORD *)v133 + 65))
  {
    v310 = 0;
    v311 = 0;
    while (!sub_1B688F0F0(*((_QWORD *)v133 + 33) + v310, (uint64_t)&v753, (uint64_t)v133, v311))
    {
      ++v311;
      v310 += 248;
      if (v311 >= *((unsigned int *)v133 + 65))
      {
        v307 = v758;
        v309 = BYTE4(v758);
        v308 = v756;
        goto LABEL_177;
      }
    }
    goto LABEL_78;
  }
LABEL_177:
  LODWORD(v758) = (v133[280] << ~v309) | v307;
  *v308 = bswap32(v758);
  v312 = SHIDWORD(v758) + 1;
  v313 = v312 & 0xF8;
  v314 = (_DWORD *)((char *)v756 + (v312 >> 3));
  v756 = v314;
  v315 = v312 & 7;
  HIDWORD(v758) = v315;
  if (v314 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v314 = v757;
  }
  v316 = (_DWORD)v758 << v313;
  if (v133[280])
  {
    v317 = *((_DWORD *)v133 + 71) + 1;
    v318 = __clz(v317);
    v319 = (v317 - (0x80000000 >> v318)) | (0x80000000 >> v318);
    v320 = 63 - 2 * v318;
    LODWORD(v758) = (v319 << (-(char)v315 - v320)) | v316;
    *v314 = bswap32(v758);
    v321 = SHIDWORD(v758) + v320;
    v316 = (_DWORD)v758 << (v321 & 0xF8);
    v314 = (_DWORD *)((char *)v756 + (v321 >> 3));
    v756 = v314;
    v315 = v321 & 7;
    HIDWORD(v758) = v315;
    if (v314 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v314 = v757;
    }
    if (*((_DWORD *)v133 + 71))
    {
      v322 = 0;
      do
      {
        v323 = *(unsigned __int16 *)&v133[2 * v322 + 288] + 1;
        v324 = __clz(v323);
        v325 = 0x80000000 >> v324;
        v326 = (2 * v324) ^ 0x3F;
        LODWORD(v758) = (((v323 - v325) | v325) << (-(char)v315 - v326)) | v316;
        *v314 = bswap32(v758);
        v327 = SHIDWORD(v758) + v326;
        v328 = (_DWORD *)((char *)v756 + (v327 >> 3));
        v756 = v328;
        HIDWORD(v758) = v327 & 7;
        if (v328 >= v757)
        {
          v759 = 1;
          v756 = v757;
          v328 = v757;
        }
        LODWORD(v758) = (((*((unsigned __int16 *)v133 + 160) >> v322) & 1) << (v327 & 7 ^ 0x1F)) | ((_DWORD)v758 << (v327 & 0xF8));
        *v328 = bswap32(v758);
        v329 = SHIDWORD(v758) + 1;
        v316 = (_DWORD)v758 << (v329 & 0xF8);
        v314 = (_DWORD *)((char *)v756 + (v329 >> 3));
        v756 = v314;
        v315 = v329 & 7;
        v758 = __PAIR64__(v315, v316);
        if (v314 >= v757)
        {
          v759 = 1;
          v756 = v757;
          v314 = v757;
        }
        ++v322;
      }
      while (v322 < *((unsigned int *)v133 + 71));
    }
  }
  LODWORD(v758) = (v133[322] << (v315 ^ 0x1F)) | v316;
  *v314 = bswap32(v758);
  v330 = SHIDWORD(v758) + 1;
  v331 = (_DWORD)v758 << (v330 & 0xF8);
  v332 = (_DWORD *)((char *)v756 + (v330 >> 3));
  v756 = v332;
  v333 = v330 & 7;
  HIDWORD(v758) = v333;
  if (v332 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v332 = v757;
  }
  LODWORD(v758) = (v133[323] << (v333 ^ 0x1F)) | v331;
  *v332 = bswap32(v758);
  v334 = SHIDWORD(v758) + 1;
  v335 = (_DWORD)v758 << (v334 & 0xF8);
  v336 = (_DWORD *)((char *)v756 + (v334 >> 3));
  v756 = v336;
  v337 = v334 & 7;
  HIDWORD(v758) = v337;
  if (v336 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v336 = v757;
  }
  LODWORD(v758) = (v133[324] << (v337 ^ 0x1F)) | v335;
  *v336 = bswap32(v758);
  v338 = SHIDWORD(v758) + 1;
  v339 = (_DWORD *)((char *)v756 + (v338 >> 3));
  v756 = v339;
  v340 = v338 & 7;
  HIDWORD(v758) = v338 & 7;
  if (v339 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v339 = v757;
  }
  v341 = (_DWORD)v758 << (v338 & 0xF8);
  if (v133[324])
  {
    if (*((_WORD *)v133 + 948))
      v342 = 1;
    else
      v342 = *((_WORD *)v133 + 949) != 0;
    if (v133[1904] == 2 && v133[1905] == 2)
    {
      v567 = v133[1906];
      v568 = v567 != 2;
      v569 = v133 + 1903;
      v570 = 1;
      if (!v133[1903] && v567 == 2)
      {
        v568 = 0;
        v570 = v133[1902] != 5;
      }
    }
    else
    {
      v569 = v133 + 1903;
      v568 = 1;
      v570 = 1;
    }
    if (v133[1907])
      v571 = 1;
    else
      v571 = v133[1908] != 0;
    v572 = *((_WORD *)v133 + 956) || *((_WORD *)v133 + 957) || *((_WORD *)v133 + 958) || *((_WORD *)v133 + 959) != 0;
    LODWORD(v758) = (v342 << (v340 ^ 0x1F)) | v341;
    *v339 = bswap32(v758);
    v575 = SHIDWORD(v758) + 1;
    v573 = v575 & 0xF8;
    v574 = (_DWORD *)((char *)v756 + (v575 >> 3));
    v756 = v574;
    LODWORD(v575) = v575 & 7;
    HIDWORD(v758) = v575;
    if (v574 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v574 = v757;
    }
    v576 = (_DWORD)v758 << v573;
    if (v342)
    {
      LODWORD(v758) = (255 << (24 - v575)) | v576;
      *v574 = bswap32(v758);
      v577 = SHIDWORD(v758) + 8;
      v578 = (_DWORD)v758 << (v577 & 0xF8);
      v579 = (_DWORD *)((char *)v756 + (v577 >> 3));
      v756 = v579;
      v580 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v579 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v579 = v757;
      }
      LODWORD(v758) = (*((unsigned __int16 *)v133 + 948) << (16 - v580)) | v578;
      *v579 = bswap32(v758);
      v581 = SHIDWORD(v758) + 16;
      v582 = (_DWORD)v758 << (v581 & 0xF8);
      v575 = (unint64_t)v756 + (v581 >> 3);
      v756 = (_DWORD *)v575;
      v583 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v575 >= (unint64_t)v757)
      {
        v759 = 1;
        v756 = v757;
        v575 = (unint64_t)v757;
      }
      LODWORD(v758) = (*((unsigned __int16 *)v133 + 949) << (16 - v583)) | v582;
      *(_DWORD *)v575 = bswap32(v758);
      v584 = SHIDWORD(v758) + 16;
      v576 = (_DWORD)v758 << (v584 & 0xF8);
      v574 = (_DWORD *)((char *)v756 + (v584 >> 3));
      v756 = v574;
      LOBYTE(v575) = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v574 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v574 = v757;
      }
    }
    LODWORD(v758) = (v133[1900] << (v575 ^ 0x1F)) | v576;
    *v574 = bswap32(v758);
    v585 = SHIDWORD(v758) + 1;
    v586 = v585 & 0xF8;
    v587 = (_DWORD *)((char *)v756 + (v585 >> 3));
    v756 = v587;
    v588 = v585 & 7;
    HIDWORD(v758) = v588;
    if (v587 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v587 = v757;
    }
    v589 = (_DWORD)v758 << v586;
    if (v133[1900])
    {
      LODWORD(v758) = (v133[1901] << (v588 ^ 0x1F)) | v589;
      *v587 = bswap32(v758);
      v590 = SHIDWORD(v758) + 1;
      v589 = (_DWORD)v758 << (v590 & 0xF8);
      v587 = (_DWORD *)((char *)v756 + (v590 >> 3));
      v756 = v587;
      v588 = v590 & 7;
      HIDWORD(v758) = v588;
      if (v587 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v587 = v757;
      }
    }
    LODWORD(v758) = (v570 << (v588 ^ 0x1F)) | v589;
    *v587 = bswap32(v758);
    v591 = SHIDWORD(v758) + 1;
    v592 = v591 & 0xF8;
    v593 = (_DWORD *)((char *)v756 + (v591 >> 3));
    v756 = v593;
    v594 = v591 & 7;
    HIDWORD(v758) = v594;
    if (v593 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v593 = v757;
    }
    v595 = (_DWORD)v758 << v592;
    if (v570)
    {
      LODWORD(v758) = (v133[1902] << (29 - v594)) | v595;
      *v593 = bswap32(v758);
      v596 = SHIDWORD(v758) + 3;
      v597 = (_DWORD)v758 << (v596 & 0xF8);
      v598 = (_DWORD *)((char *)v756 + (v596 >> 3));
      v756 = v598;
      v599 = v596 & 7;
      HIDWORD(v758) = v599;
      if (v598 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v598 = v757;
      }
      LODWORD(v758) = (*v569 << (v599 ^ 0x1F)) | v597;
      *v598 = bswap32(v758);
      v600 = SHIDWORD(v758) + 1;
      v601 = (_DWORD)v758 << (v600 & 0xF8);
      v602 = (_DWORD *)((char *)v756 + (v600 >> 3));
      v756 = v602;
      v603 = v600 & 7;
      HIDWORD(v758) = v603;
      if (v602 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v602 = v757;
      }
      LODWORD(v758) = (v568 << (v603 ^ 0x1F)) | v601;
      *v602 = bswap32(v758);
      v604 = SHIDWORD(v758) + 1;
      v605 = v604 & 0xF8;
      v593 = (_DWORD *)((char *)v756 + (v604 >> 3));
      v756 = v593;
      v594 = v604 & 7;
      HIDWORD(v758) = v594;
      if (v593 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v593 = v757;
      }
      v595 = (_DWORD)v758 << v605;
      if (v568)
      {
        LODWORD(v758) = (v133[1904] << (24 - v594)) | v595;
        *v593 = bswap32(v758);
        v606 = SHIDWORD(v758) + 8;
        v607 = (_DWORD)v758 << (v606 & 0xF8);
        v608 = (_DWORD *)((char *)v756 + (v606 >> 3));
        v756 = v608;
        v609 = BYTE4(v758) & 7;
        HIDWORD(v758) = BYTE4(v758) & 7;
        if (v608 >= v757)
        {
          v759 = 1;
          v756 = v757;
          v608 = v757;
        }
        LODWORD(v758) = (v133[1905] << (24 - v609)) | v607;
        *v608 = bswap32(v758);
        v610 = SHIDWORD(v758) + 8;
        v611 = (_DWORD)v758 << (v610 & 0xF8);
        v612 = (_DWORD *)((char *)v756 + (v610 >> 3));
        v756 = v612;
        v613 = BYTE4(v758) & 7;
        HIDWORD(v758) = BYTE4(v758) & 7;
        if (v612 >= v757)
        {
          v759 = 1;
          v756 = v757;
          v612 = v757;
        }
        LODWORD(v758) = (v133[1906] << (24 - v613)) | v611;
        *v612 = bswap32(v758);
        v614 = SHIDWORD(v758) + 8;
        v595 = (_DWORD)v758 << (v614 & 0xF8);
        v593 = (_DWORD *)((char *)v756 + (v614 >> 3));
        v756 = v593;
        LOBYTE(v594) = BYTE4(v758) & 7;
        HIDWORD(v758) = BYTE4(v758) & 7;
        if (v593 >= v757)
        {
          v759 = 1;
          v756 = v757;
          v593 = v757;
        }
      }
    }
    LODWORD(v758) = (v571 << (v594 ^ 0x1F)) | v595;
    *v593 = bswap32(v758);
    v615 = SHIDWORD(v758) + 1;
    v616 = v615 & 0xF8;
    v617 = (_DWORD *)((char *)v756 + (v615 >> 3));
    v756 = v617;
    v618 = v615 & 7;
    HIDWORD(v758) = v618;
    if (v617 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v617 = v757;
    }
    v619 = (_DWORD)v758 << v616;
    if (v571)
    {
      v620 = v133[1907] + 1;
      v621 = __clz(v620);
      v622 = 0x80000000 >> v621;
      v623 = (2 * v621) ^ 0x3F;
      LODWORD(v758) = (((v620 - v622) | v622) << (-(char)v618 - v623)) | v619;
      *v617 = bswap32(v758);
      v624 = SHIDWORD(v758) + v623;
      v625 = (_DWORD)v758 << (v624 & 0xF8);
      v626 = (_DWORD *)((char *)v756 + (v624 >> 3));
      v756 = v626;
      v618 = v624 & 7;
      HIDWORD(v758) = v618;
      if (v626 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v626 = v757;
      }
      v627 = v133[1908] + 1;
      v628 = __clz(v627);
      LODWORD(v758) = (((v627 - (0x80000000 >> v628)) | (0x80000000 >> v628)) << (-((2 * v628) ^ 0x3F) - v618)) | v625;
      *v626 = bswap32(v758);
      v619 = (_DWORD)v758 << ((BYTE4(v758) + ((2 * v628) ^ 0x3F)) & 0xF8);
      v617 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v628) ^ 0x3FuLL)) >> 3));
      v756 = v617;
      LOBYTE(v618) = (BYTE4(v758) + ((2 * v628) ^ 0x3F)) & 7;
      HIDWORD(v758) = (HIDWORD(v758) + ((2 * v628) ^ 0x3F)) & 7;
      if (v617 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v617 = v757;
      }
    }
    LODWORD(v758) = (v133[1909] << (v618 ^ 0x1F)) | v619;
    *v617 = bswap32(v758);
    v629 = SHIDWORD(v758) + 1;
    v630 = (_DWORD)v758 << (v629 & 0xF8);
    v631 = (_DWORD *)((char *)v756 + (v629 >> 3));
    v756 = v631;
    v632 = v629 & 7;
    HIDWORD(v758) = v632;
    if (v631 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v631 = v757;
    }
    LODWORD(v758) = (v133[1910] << (v632 ^ 0x1F)) | v630;
    *v631 = bswap32(v758);
    v633 = SHIDWORD(v758) + 1;
    v634 = (_DWORD)v758 << (v633 & 0xF8);
    v635 = (_DWORD *)((char *)v756 + (v633 >> 3));
    v756 = v635;
    v636 = v633 & 7;
    HIDWORD(v758) = v636;
    if (v635 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v635 = v757;
    }
    LODWORD(v758) = (v133[1911] << (v636 ^ 0x1F)) | v634;
    *v635 = bswap32(v758);
    v637 = SHIDWORD(v758) + 1;
    v638 = (_DWORD)v758 << (v637 & 0xF8);
    v639 = (_DWORD *)((char *)v756 + (v637 >> 3));
    v756 = v639;
    v640 = v637 & 7;
    HIDWORD(v758) = v640;
    if (v639 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v639 = v757;
    }
    LODWORD(v758) = (v572 << (v640 ^ 0x1F)) | v638;
    *v639 = bswap32(v758);
    v641 = SHIDWORD(v758) + 1;
    v642 = v641 & 0xF8;
    v643 = (_DWORD *)((char *)v756 + (v641 >> 3));
    v756 = v643;
    v644 = v641 & 7;
    HIDWORD(v758) = v644;
    if (v643 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v643 = v757;
    }
    v645 = (_DWORD)v758 << v642;
    if (v572)
    {
      v646 = *((unsigned __int16 *)v133 + 956) + 1;
      v647 = __clz(v646);
      v648 = 0x80000000 >> v647;
      v649 = (2 * v647) ^ 0x3F;
      LODWORD(v758) = (((v646 - v648) | v648) << (-(char)v644 - v649)) | v645;
      *v643 = bswap32(v758);
      v650 = SHIDWORD(v758) + v649;
      v651 = (_DWORD)v758 << (v650 & 0xF8);
      v652 = (_DWORD *)((char *)v756 + (v650 >> 3));
      v756 = v652;
      v653 = v650 & 7;
      HIDWORD(v758) = v653;
      if (v652 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v652 = v757;
      }
      v654 = *((unsigned __int16 *)v133 + 957) + 1;
      v655 = __clz(v654);
      LODWORD(v758) = (((v654 - (0x80000000 >> v655)) | (0x80000000 >> v655)) << (-((2 * v655) ^ 0x3F) - v653)) | v651;
      *v652 = bswap32(v758);
      v656 = (_DWORD)v758 << ((BYTE4(v758) + ((2 * v655) ^ 0x3F)) & 0xF8);
      v657 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v655) ^ 0x3FuLL)) >> 3));
      v756 = v657;
      v658 = (BYTE4(v758) + ((2 * v655) ^ 0x3F)) & 7;
      HIDWORD(v758) = (HIDWORD(v758) + ((2 * v655) ^ 0x3F)) & 7;
      if (v657 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v657 = v757;
      }
      v659 = *((unsigned __int16 *)v133 + 958) + 1;
      v660 = __clz(v659);
      v661 = (v659 - (0x80000000 >> v660)) | (0x80000000 >> v660);
      v662 = (2 * v660) ^ 0x3F;
      LODWORD(v758) = (v661 << (-(char)v662 - v658)) | v656;
      *v657 = bswap32(v758);
      v663 = SHIDWORD(v758) + v662;
      v664 = (_DWORD)v758 << (v663 & 0xF8);
      v665 = (_DWORD *)((char *)v756 + (v663 >> 3));
      v756 = v665;
      v644 = v663 & 7;
      HIDWORD(v758) = v644;
      if (v665 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v665 = v757;
      }
      v666 = *((unsigned __int16 *)v133 + 959) + 1;
      v667 = __clz(v666);
      LODWORD(v758) = (((v666 - (0x80000000 >> v667)) | (0x80000000 >> v667)) << (-((2 * v667) ^ 0x3F) - v644)) | v664;
      *v665 = bswap32(v758);
      v645 = (_DWORD)v758 << ((BYTE4(v758) + ((2 * v667) ^ 0x3F)) & 0xF8);
      v643 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v667) ^ 0x3FuLL)) >> 3));
      v756 = v643;
      LOBYTE(v644) = (BYTE4(v758) + ((2 * v667) ^ 0x3F)) & 7;
      HIDWORD(v758) = (HIDWORD(v758) + ((2 * v667) ^ 0x3F)) & 7;
      if (v643 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v643 = v757;
      }
    }
    LODWORD(v758) = (v133[1920] << (v644 ^ 0x1F)) | v645;
    *v643 = bswap32(v758);
    v668 = SHIDWORD(v758) + 1;
    v669 = v668 & 0xF8;
    v670 = (_DWORD *)((char *)v756 + (v668 >> 3));
    v756 = v670;
    v671 = v668 & 7;
    HIDWORD(v758) = v671;
    if (v670 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v670 = v757;
    }
    v672 = (_DWORD)v758 << v669;
    if (v133[1920])
    {
      v673 = *((_DWORD *)v133 + 481);
      LODWORD(v758) = (HIWORD(v673) << (16 - v671)) | v672;
      *v670 = bswap32(v758);
      v674 = SHIDWORD(v758) + 16;
      v675 = (_DWORD)v758 << (v674 & 0xF8);
      v676 = (_DWORD *)((char *)v756 + (v674 >> 3));
      v756 = v676;
      v677 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v676 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v676 = v757;
      }
      LODWORD(v758) = ((unsigned __int16)v673 << (16 - v677)) | v675;
      *v676 = bswap32(v758);
      v678 = SHIDWORD(v758) + 16;
      v679 = (_DWORD)v758 << (v678 & 0xF8);
      v680 = (_DWORD *)((char *)v756 + (v678 >> 3));
      v756 = v680;
      v681 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v680 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v680 = v757;
      }
      v682 = *((_DWORD *)v133 + 482);
      LODWORD(v758) = (HIWORD(v682) << (16 - v681)) | v679;
      *v680 = bswap32(v758);
      v683 = SHIDWORD(v758) + 16;
      v684 = (_DWORD)v758 << (v683 & 0xF8);
      v685 = (_DWORD *)((char *)v756 + (v683 >> 3));
      v756 = v685;
      v686 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v685 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v685 = v757;
      }
      LODWORD(v758) = ((unsigned __int16)v682 << (16 - v686)) | v684;
      *v685 = bswap32(v758);
      v687 = SHIDWORD(v758) + 16;
      v688 = (_DWORD)v758 << (v687 & 0xF8);
      v689 = (_DWORD *)((char *)v756 + (v687 >> 3));
      v756 = v689;
      v690 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v689 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v689 = v757;
      }
      LODWORD(v758) = (v133[1932] << (v690 ^ 0x1F)) | v688;
      *v689 = bswap32(v758);
      v691 = SHIDWORD(v758) + 1;
      v692 = v691 & 0xF8;
      v693 = (_DWORD *)((char *)v756 + (v691 >> 3));
      v756 = v693;
      v694 = v691 & 7;
      HIDWORD(v758) = v694;
      if (v693 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v693 = v757;
      }
      v695 = (_DWORD)v758 << v692;
      if (v133[1932])
      {
        v696 = *((_DWORD *)v133 + 484) + 1;
        v697 = __clz(v696);
        v698 = (v696 - (0x80000000 >> v697)) | (0x80000000 >> v697);
        v699 = 63 - 2 * v697;
        LODWORD(v758) = (v698 << (-(char)v694 - v699)) | v695;
        *v693 = bswap32(v758);
        v700 = SHIDWORD(v758) + v699;
        v695 = (_DWORD)v758 << (v700 & 0xF8);
        v693 = (_DWORD *)((char *)v756 + (v700 >> 3));
        v756 = v693;
        v694 = v700 & 7;
        HIDWORD(v758) = v694;
        if (v693 >= v757)
        {
          v759 = 1;
          v756 = v757;
          v693 = v757;
        }
      }
      LODWORD(v758) = (v133[1940] << (v694 ^ 0x1F)) | v695;
      *v693 = bswap32(v758);
      v701 = SHIDWORD(v758) + 1;
      v672 = (_DWORD)v758 << (v701 & 0xF8);
      v670 = (_DWORD *)((char *)v756 + (v701 >> 3));
      v756 = v670;
      v671 = v701 & 7;
      v758 = __PAIR64__(v671, v672);
      if (v670 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v670 = v757;
      }
      if (v133[1940])
        goto LABEL_78;
    }
    LODWORD(v758) = (v133[1976] << (v671 ^ 0x1F)) | v672;
    *v670 = bswap32(v758);
    v702 = SHIDWORD(v758) + 1;
    v339 = (_DWORD *)((char *)v756 + (v702 >> 3));
    v756 = v339;
    v340 = v702 & 7;
    HIDWORD(v758) = v702 & 7;
    if (v339 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v339 = v757;
    }
    v341 = (_DWORD)v758 << (v702 & 0xF8);
    if (v133[1976])
    {
      LODWORD(v758) = (v133[1977] << (v340 ^ 0x1F)) | v341;
      *v339 = bswap32(v758);
      v703 = SHIDWORD(v758) + 1;
      v704 = (_DWORD)v758 << (v703 & 0xF8);
      v705 = (_DWORD *)((char *)v756 + (v703 >> 3));
      v756 = v705;
      v706 = v703 & 7;
      HIDWORD(v758) = v706;
      if (v705 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v705 = v757;
      }
      LODWORD(v758) = (v133[1978] << (v706 ^ 0x1F)) | v704;
      *v705 = bswap32(v758);
      v707 = SHIDWORD(v758) + 1;
      v708 = (_DWORD)v758 << (v707 & 0xF8);
      v709 = (_DWORD *)((char *)v756 + (v707 >> 3));
      v756 = v709;
      v710 = v707 & 7;
      HIDWORD(v758) = v710;
      if (v709 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v709 = v757;
      }
      LODWORD(v758) = (v133[1979] << (v710 ^ 0x1F)) | v708;
      *v709 = bswap32(v758);
      v711 = SHIDWORD(v758) + 1;
      v712 = (_DWORD)v758 << (v711 & 0xF8);
      v713 = (_DWORD *)((char *)v756 + (v711 >> 3));
      v756 = v713;
      v714 = v711 & 7;
      HIDWORD(v758) = v714;
      if (v713 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v713 = v757;
      }
      v715 = *((_DWORD *)v133 + 495) + 1;
      v716 = __clz(v715);
      v717 = (v715 - (0x80000000 >> v716)) | (0x80000000 >> v716);
      v718 = 63 - 2 * v716;
      LODWORD(v758) = (v717 << (-(char)v714 - v718)) | v712;
      *v713 = bswap32(v758);
      v719 = SHIDWORD(v758) + v718;
      v720 = (_DWORD)v758 << (v719 & 0xF8);
      v721 = (_DWORD *)((char *)v756 + (v719 >> 3));
      v756 = v721;
      v722 = v719 & 7;
      HIDWORD(v758) = v722;
      if (v721 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v721 = v757;
      }
      v723 = *((_DWORD *)v133 + 496) + 1;
      v724 = __clz(v723);
      LODWORD(v758) = (((v723 - (0x80000000 >> v724)) | (0x80000000 >> v724)) << (2 * v724 - 63 - v722)) | v720;
      *v721 = bswap32(v758);
      v725 = SHIDWORD(v758) + 63 - 2 * v724;
      v726 = (_DWORD)v758 << (v725 & 0xF8);
      v727 = (_DWORD *)((char *)v756 + (v725 >> 3));
      v756 = v727;
      v728 = v725 & 7;
      HIDWORD(v758) = v728;
      if (v727 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v727 = v757;
      }
      v729 = *((_DWORD *)v133 + 497) + 1;
      v730 = __clz(v729);
      v731 = (v729 - (0x80000000 >> v730)) | (0x80000000 >> v730);
      v732 = 63 - 2 * v730;
      LODWORD(v758) = (v731 << (-(char)v732 - v728)) | v726;
      *v727 = bswap32(v758);
      v733 = SHIDWORD(v758) + v732;
      v734 = (_DWORD)v758 << (v733 & 0xF8);
      v735 = (_DWORD *)((char *)v756 + (v733 >> 3));
      v756 = v735;
      v736 = v733 & 7;
      HIDWORD(v758) = v736;
      if (v735 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v735 = v757;
      }
      v737 = *((_DWORD *)v133 + 498) + 1;
      v738 = __clz(v737);
      LODWORD(v758) = (((v737 - (0x80000000 >> v738)) | (0x80000000 >> v738)) << (2 * v738 - 63 - v736)) | v734;
      *v735 = bswap32(v758);
      v739 = SHIDWORD(v758) + 63 - 2 * v738;
      v740 = (_DWORD)v758 << (v739 & 0xF8);
      v741 = (_DWORD *)((char *)v756 + (v739 >> 3));
      v756 = v741;
      v742 = v739 & 7;
      HIDWORD(v758) = v742;
      if (v741 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v741 = v757;
      }
      v743 = *((_DWORD *)v133 + 499) + 1;
      v744 = __clz(v743);
      v745 = (v743 - (0x80000000 >> v744)) | (0x80000000 >> v744);
      v746 = 63 - 2 * v744;
      LODWORD(v758) = (v745 << (-(char)v746 - v742)) | v740;
      *v741 = bswap32(v758);
      v747 = SHIDWORD(v758) + v746;
      v341 = (_DWORD)v758 << (v747 & 0xF8);
      v339 = (_DWORD *)((char *)v756 + (v747 >> 3));
      v756 = v339;
      v340 = v747 & 7;
      HIDWORD(v758) = v747 & 7;
      if (v339 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v339 = v757;
      }
    }
  }
  LODWORD(v758) = (v133[325] << (v340 ^ 0x1F)) | v341;
  *v339 = bswap32(v758);
  v748 = SHIDWORD(v758) + 1;
  v756 = (_DWORD *)((char *)v756 + (v748 >> 3));
  LODWORD(v758) = (_DWORD)v758 << (v748 & 0xF8);
  HIDWORD(v758) = v748 & 7;
  if (v756 >= v757)
  {
    v759 = 1;
    v756 = v757;
  }
  if (v133[325])
  {
LABEL_78:
    v128 = 0;
    goto LABEL_79;
  }
  sub_1B67C939C((uint64_t)&v753);
  v128 = off_1EF137C48(v764, 0, v755, (char *)v756 - v755, 2);
  *(_DWORD *)(v127 + 12720) += v128;
  v749 = *(FILE **)(v127 + 88);
  if (v749)
    fwrite(v764, 1uLL, v128, v749);
LABEL_79:
  if (v753)
    free(v753);
  v751 = v128;
  v129 = *(_QWORD *)(a1 + 16);
  v753 = 0;
  v754 = 0;
  v757 = 0;
  v758 = 0;
  v756 = 0;
  if (sub_1B67C8F84(&v753, 1024))
    goto LABEL_82;
  v343 = *(unsigned __int8 **)(v129 + 12704);
  *v756 = bswap32(v758);
  v344 = SHIDWORD(v758) + 1;
  v345 = (_DWORD)v758 << (v344 & 0xF8);
  v346 = (_DWORD *)((char *)v756 + (v344 >> 3));
  v756 = v346;
  v347 = v344 & 7;
  HIDWORD(v758) = v347;
  if (v346 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v346 = v757;
  }
  LODWORD(v758) = (34 << (26 - v347)) | v345;
  *v346 = bswap32(v758);
  v348 = SHIDWORD(v758) + 6;
  v349 = (_DWORD)v758 << (v348 & 0xF8);
  v350 = (_DWORD *)((char *)v756 + (v348 >> 3));
  v756 = v350;
  LODWORD(v758) = v349;
  HIDWORD(v758) = v348 & 7;
  if (v350 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v350 = v757;
  }
  *v350 = bswap32(v349);
  v351 = SHIDWORD(v758) + 6;
  v352 = (_DWORD)v758 << (v351 & 0xF8);
  v353 = (_DWORD *)((char *)v756 + (v351 >> 3));
  v756 = v353;
  v354 = v351 & 7;
  HIDWORD(v758) = v354;
  if (v353 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v353 = v757;
  }
  LODWORD(v758) = (1 << (29 - v354)) | v352;
  *v353 = bswap32(v758);
  v355 = SHIDWORD(v758) + 3;
  v356 = (_DWORD)v758 << (v355 & 0xF8);
  v357 = (_DWORD *)((char *)v756 + (v355 >> 3));
  v756 = v357;
  v358 = v355 & 7;
  HIDWORD(v758) = v358;
  if (v357 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v357 = v757;
  }
  v359 = *v343 + 1;
  v360 = __clz(v359);
  v361 = 0x80000000 >> v360;
  v362 = (2 * v360) ^ 0x3F;
  LODWORD(v758) = (((v359 - v361) | v361) << (-(char)v358 - v362)) | v356;
  *v357 = bswap32(v758);
  v363 = SHIDWORD(v758) + v362;
  v364 = (_DWORD)v758 << (v363 & 0xF8);
  v365 = (_DWORD *)((char *)v756 + (v363 >> 3));
  v756 = v365;
  v366 = v363 & 7;
  HIDWORD(v758) = v366;
  if (v365 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v365 = v757;
  }
  v367 = v343[1] + 1;
  v368 = __clz(v367);
  LODWORD(v758) = (((v367 - (0x80000000 >> v368)) | (0x80000000 >> v368)) << (-((2 * v368) ^ 0x3F) - v366)) | v364;
  *v365 = bswap32(v758);
  v369 = (_DWORD)v758 << ((BYTE4(v758) + ((2 * v368) ^ 0x3F)) & 0xF8);
  v370 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v368) ^ 0x3FuLL)) >> 3));
  v756 = v370;
  v371 = (BYTE4(v758) + ((2 * v368) ^ 0x3F)) & 7;
  LODWORD(v758) = v369;
  HIDWORD(v758) = (HIDWORD(v758) + ((2 * v368) ^ 0x3F)) & 7;
  if (v370 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v370 = v757;
  }
  v372 = *((_QWORD *)v343 + 214);
  v373 = v343[1];
  v374 = (_QWORD *)(v372 + 1552);
  v375 = (_QWORD *)(v372 + 16 * v373 + 256);
  if (v373 > 0xF)
    v375 = v374;
  if (!*v375)
    goto LABEL_82;
  LODWORD(v758) = (v343[2] << (v371 ^ 0x1F)) | v369;
  *v370 = bswap32(v758);
  v376 = SHIDWORD(v758) + 1;
  v377 = (_DWORD)v758 << (v376 & 0xF8);
  v378 = (_DWORD *)((char *)v756 + (v376 >> 3));
  v756 = v378;
  v379 = v376 & 7;
  HIDWORD(v758) = v379;
  if (v378 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v378 = v757;
  }
  LODWORD(v758) = (v343[3] << (v379 ^ 0x1F)) | v377;
  *v378 = bswap32(v758);
  v380 = SHIDWORD(v758) + 1;
  v381 = (_DWORD)v758 << (v380 & 0xF8);
  v382 = (_DWORD *)((char *)v756 + (v380 >> 3));
  v756 = v382;
  v383 = v380 & 7;
  HIDWORD(v758) = v383;
  if (v382 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v382 = v757;
  }
  LODWORD(v758) = (v343[4] << (29 - v383)) | v381;
  *v382 = bswap32(v758);
  v384 = SHIDWORD(v758) + 3;
  v385 = (_DWORD)v758 << (v384 & 0xF8);
  v386 = (_DWORD *)((char *)v756 + (v384 >> 3));
  v756 = v386;
  v387 = v384 & 7;
  HIDWORD(v758) = v387;
  if (v386 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v386 = v757;
  }
  LODWORD(v758) = (v343[5] << (v387 ^ 0x1F)) | v385;
  *v386 = bswap32(v758);
  v388 = SHIDWORD(v758) + 1;
  v389 = (_DWORD)v758 << (v388 & 0xF8);
  v390 = (_DWORD *)((char *)v756 + (v388 >> 3));
  v756 = v390;
  v391 = v388 & 7;
  HIDWORD(v758) = v391;
  if (v390 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v390 = v757;
  }
  LODWORD(v758) = (v343[6] << (v391 ^ 0x1F)) | v389;
  *v390 = bswap32(v758);
  v392 = SHIDWORD(v758) + 1;
  v393 = (_DWORD)v758 << (v392 & 0xF8);
  v394 = (_DWORD *)((char *)v756 + (v392 >> 3));
  v756 = v394;
  v395 = v392 & 7;
  HIDWORD(v758) = v395;
  if (v394 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v394 = v757;
  }
  v396 = v343[7] + 1;
  v397 = __clz(v396);
  v398 = 0x80000000 >> v397;
  v399 = (2 * v397) ^ 0x3F;
  LODWORD(v758) = (((v396 - v398) | v398) << (-(char)v395 - v399)) | v393;
  *v394 = bswap32(v758);
  v400 = SHIDWORD(v758) + v399;
  v401 = (_DWORD)v758 << (v400 & 0xF8);
  v402 = (_DWORD *)((char *)v756 + (v400 >> 3));
  v756 = v402;
  v403 = v400 & 7;
  HIDWORD(v758) = v403;
  if (v402 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v402 = v757;
  }
  v404 = v343[8] + 1;
  v405 = __clz(v404);
  LODWORD(v758) = (((v404 - (0x80000000 >> v405)) | (0x80000000 >> v405)) << (-((2 * v405) ^ 0x3F) - v403)) | v401;
  *v402 = bswap32(v758);
  v406 = (_DWORD)v758 << ((BYTE4(v758) + ((2 * v405) ^ 0x3F)) & 0xF8);
  v407 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v405) ^ 0x3FuLL)) >> 3));
  v756 = v407;
  v408 = (BYTE4(v758) + ((2 * v405) ^ 0x3F)) & 7;
  HIDWORD(v758) = (HIDWORD(v758) + ((2 * v405) ^ 0x3F)) & 7;
  if (v407 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v407 = v757;
  }
  v409 = (char)v343[9];
  if (v409 <= 0)
    v410 = -2 * v409;
  else
    v410 = 2 * v409 - 1;
  v411 = v410 + 1;
  v412 = __clz(v411);
  v413 = (v411 - (0x80000000 >> v412)) | (0x80000000 >> v412);
  v414 = 63 - 2 * v412;
  LODWORD(v758) = (v413 << (-v408 - v414)) | v406;
  *v407 = bswap32(v758);
  v415 = SHIDWORD(v758) + v414;
  v416 = (_DWORD)v758 << (v415 & 0xF8);
  v417 = (_DWORD *)((char *)v756 + (v415 >> 3));
  v756 = v417;
  v418 = v415 & 7;
  HIDWORD(v758) = v418;
  if (v417 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v417 = v757;
  }
  LODWORD(v758) = (v343[10] << (v418 ^ 0x1F)) | v416;
  *v417 = bswap32(v758);
  v419 = SHIDWORD(v758) + 1;
  v420 = (_DWORD)v758 << (v419 & 0xF8);
  v421 = (_DWORD *)((char *)v756 + (v419 >> 3));
  v756 = v421;
  v422 = v419 & 7;
  HIDWORD(v758) = v422;
  if (v421 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v421 = v757;
  }
  LODWORD(v758) = (v343[11] << (v422 ^ 0x1F)) | v420;
  *v421 = bswap32(v758);
  v423 = SHIDWORD(v758) + 1;
  v424 = (_DWORD)v758 << (v423 & 0xF8);
  v425 = (_DWORD *)((char *)v756 + (v423 >> 3));
  v756 = v425;
  v426 = v423 & 7;
  HIDWORD(v758) = v426;
  if (v425 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v425 = v757;
  }
  LODWORD(v758) = (v343[12] << (v426 ^ 0x1F)) | v424;
  *v425 = bswap32(v758);
  v427 = SHIDWORD(v758) + 1;
  v428 = v427 & 0xF8;
  v429 = (_DWORD *)((char *)v756 + (v427 >> 3));
  v756 = v429;
  v430 = v427 & 7;
  HIDWORD(v758) = v430;
  if (v429 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v429 = v757;
  }
  v431 = (_DWORD)v758 << v428;
  if (v343[12])
  {
    v432 = v343[13] + 1;
    v433 = __clz(v432);
    v434 = 0x80000000 >> v433;
    v435 = (2 * v433) ^ 0x3F;
    LODWORD(v758) = (((v432 - v434) | v434) << (-(char)v430 - v435)) | v431;
    *v429 = bswap32(v758);
    v436 = SHIDWORD(v758) + v435;
    v431 = (_DWORD)v758 << (v436 & 0xF8);
    v429 = (_DWORD *)((char *)v756 + (v436 >> 3));
    v756 = v429;
    v430 = v436 & 7;
    HIDWORD(v758) = v430;
    if (v429 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v429 = v757;
    }
  }
  v437 = (char)v343[14];
  if (v437 <= 0)
    v438 = -2 * v437;
  else
    v438 = 2 * v437 - 1;
  v439 = __clz(v438 + 1);
  v440 = (v438 + 1 - (0x80000000 >> v439)) | (0x80000000 >> v439);
  v441 = 63 - 2 * v439;
  LODWORD(v758) = (v440 << (-(char)v430 - v441)) | v431;
  *v429 = bswap32(v758);
  v442 = SHIDWORD(v758) + v441;
  v443 = (_DWORD)v758 << (v442 & 0xF8);
  v444 = (_DWORD *)((char *)v756 + (v442 >> 3));
  v756 = v444;
  v445 = v442 & 7;
  HIDWORD(v758) = v445;
  if (v444 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v444 = v757;
  }
  v446 = (char)v343[15];
  if (v446 <= 0)
    v447 = -2 * v446;
  else
    v447 = 2 * v446 - 1;
  v448 = v447 + 1;
  v449 = __clz(v448);
  LODWORD(v758) = (((v448 - (0x80000000 >> v449)) | (0x80000000 >> v449)) << (2 * v449 - 63 - v445)) | v443;
  *v444 = bswap32(v758);
  v450 = SHIDWORD(v758) + 63 - 2 * v449;
  v451 = (_DWORD)v758 << (v450 & 0xF8);
  v452 = (_DWORD *)((char *)v756 + (v450 >> 3));
  v756 = v452;
  v453 = v450 & 7;
  HIDWORD(v758) = v453;
  if (v452 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v452 = v757;
  }
  LODWORD(v758) = (v343[16] << (v453 ^ 0x1F)) | v451;
  *v452 = bswap32(v758);
  v454 = SHIDWORD(v758) + 1;
  v455 = (_DWORD)v758 << (v454 & 0xF8);
  v456 = (_DWORD *)((char *)v756 + (v454 >> 3));
  v756 = v456;
  v457 = v454 & 7;
  HIDWORD(v758) = v457;
  if (v456 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v456 = v757;
  }
  LODWORD(v758) = (v343[17] << (v457 ^ 0x1F)) | v455;
  *v456 = bswap32(v758);
  v458 = SHIDWORD(v758) + 1;
  v459 = (_DWORD)v758 << (v458 & 0xF8);
  v460 = (_DWORD *)((char *)v756 + (v458 >> 3));
  v756 = v460;
  v461 = v458 & 7;
  HIDWORD(v758) = v461;
  if (v460 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v460 = v757;
  }
  LODWORD(v758) = (v343[18] << (v461 ^ 0x1F)) | v459;
  *v460 = bswap32(v758);
  v462 = SHIDWORD(v758) + 1;
  v463 = (_DWORD)v758 << (v462 & 0xF8);
  v464 = (_DWORD *)((char *)v756 + (v462 >> 3));
  v756 = v464;
  v465 = v462 & 7;
  HIDWORD(v758) = v465;
  if (v464 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v464 = v757;
  }
  LODWORD(v758) = (v343[19] << (v465 ^ 0x1F)) | v463;
  *v464 = bswap32(v758);
  v466 = SHIDWORD(v758) + 1;
  v467 = (_DWORD)v758 << (v466 & 0xF8);
  v468 = (_DWORD *)((char *)v756 + (v466 >> 3));
  v756 = v468;
  v469 = v466 & 7;
  HIDWORD(v758) = v469;
  if (v468 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v468 = v757;
  }
  LODWORD(v758) = (v343[20] << (v469 ^ 0x1F)) | v467;
  *v468 = bswap32(v758);
  v470 = SHIDWORD(v758) + 1;
  v471 = (_DWORD)v758 << (v470 & 0xF8);
  v472 = (_DWORD *)((char *)v756 + (v470 >> 3));
  v756 = v472;
  v473 = v470 & 7;
  HIDWORD(v758) = v473;
  if (v472 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v472 = v757;
  }
  LODWORD(v758) = (v343[21] << (v473 ^ 0x1F)) | v471;
  *v472 = bswap32(v758);
  v474 = SHIDWORD(v758) + 1;
  v475 = v474 & 0xF8;
  v476 = (_DWORD *)((char *)v756 + (v474 >> 3));
  v756 = v476;
  v477 = v474 & 7;
  HIDWORD(v758) = v477;
  if (v476 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v476 = v757;
  }
  v478 = (_DWORD)v758 << v475;
  if (v343[20])
  {
    v479 = *((unsigned __int16 *)v343 + 11) + 1;
    v480 = __clz(v479);
    v481 = 0x80000000 >> v480;
    v482 = (2 * v480) ^ 0x3F;
    LODWORD(v758) = (((v479 - v481) | v481) << (-(char)v477 - v482)) | v478;
    *v476 = bswap32(v758);
    v483 = SHIDWORD(v758) + v482;
    v484 = (_DWORD)v758 << (v483 & 0xF8);
    v485 = (_DWORD *)((char *)v756 + (v483 >> 3));
    v756 = v485;
    v486 = v483 & 7;
    HIDWORD(v758) = v486;
    if (v485 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v485 = v757;
    }
    v487 = *((unsigned __int16 *)v343 + 12) + 1;
    v488 = __clz(v487);
    LODWORD(v758) = (((v487 - (0x80000000 >> v488)) | (0x80000000 >> v488)) << (-((2 * v488) ^ 0x3F) - v486)) | v484;
    *v485 = bswap32(v758);
    v489 = (_DWORD)v758 << ((BYTE4(v758) + ((2 * v488) ^ 0x3F)) & 0xF8);
    v490 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v488) ^ 0x3FuLL)) >> 3));
    v756 = v490;
    v491 = (BYTE4(v758) + ((2 * v488) ^ 0x3F)) & 7;
    HIDWORD(v758) = (HIDWORD(v758) + ((2 * v488) ^ 0x3F)) & 7;
    if (v490 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v490 = v757;
    }
    LODWORD(v758) = (v343[26] << (v491 ^ 0x1F)) | v489;
    *v490 = bswap32(v758);
    v492 = SHIDWORD(v758) + 1;
    v493 = (_DWORD)v758 << (v492 & 0xF8);
    v494 = (_DWORD *)((char *)v756 + (v492 >> 3));
    v756 = v494;
    v495 = v492 & 7;
    HIDWORD(v758) = v495;
    if (v494 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v494 = v757;
    }
    if (!v343[26])
    {
      if (*((_WORD *)v343 + 11))
      {
        v496 = 0;
        do
        {
          v497 = *(unsigned __int16 *)(*((_QWORD *)v343 + 203) + 2 * v496) + 1;
          v498 = __clz(v497);
          v499 = 0x80000000 >> v498;
          v500 = (2 * v498) ^ 0x3F;
          LODWORD(v758) = (((v497 - v499) | v499) << (-(char)v495 - v500)) | v493;
          *v494 = bswap32(v758);
          v501 = SHIDWORD(v758) + v500;
          v493 = (_DWORD)v758 << (v501 & 0xF8);
          v494 = (_DWORD *)((char *)v756 + (v501 >> 3));
          v756 = v494;
          v495 = v501 & 7;
          v758 = __PAIR64__(v495, v493);
          if (v494 >= v757)
          {
            v759 = 1;
            v756 = v757;
            v494 = v757;
          }
          ++v496;
        }
        while (v496 < *((unsigned __int16 *)v343 + 11));
      }
      if (*((_WORD *)v343 + 12))
      {
        v502 = 0;
        do
        {
          v503 = *(unsigned __int16 *)(*((_QWORD *)v343 + 205) + 2 * v502) + 1;
          v504 = __clz(v503);
          v505 = 0x80000000 >> v504;
          v506 = (2 * v504) ^ 0x3F;
          LODWORD(v758) = (((v503 - v505) | v505) << (-(char)v495 - v506)) | v493;
          *v494 = bswap32(v758);
          v507 = SHIDWORD(v758) + v506;
          v493 = (_DWORD)v758 << (v507 & 0xF8);
          v494 = (_DWORD *)((char *)v756 + (v507 >> 3));
          v756 = v494;
          v495 = v507 & 7;
          v758 = __PAIR64__(v495, v493);
          if (v494 >= v757)
          {
            v759 = 1;
            v756 = v757;
            v494 = v757;
          }
          ++v502;
        }
        while (v502 < *((unsigned __int16 *)v343 + 12));
      }
    }
    LODWORD(v758) = (v343[27] << (v495 ^ 0x1F)) | v493;
    *v494 = bswap32(v758);
    v508 = SHIDWORD(v758) + 1;
    v478 = (_DWORD)v758 << (v508 & 0xF8);
    v476 = (_DWORD *)((char *)v756 + (v508 >> 3));
    v756 = v476;
    v477 = v508 & 7;
    HIDWORD(v758) = v477;
    if (v476 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v476 = v757;
    }
  }
  LODWORD(v758) = (v343[28] << (v477 ^ 0x1F)) | v478;
  *v476 = bswap32(v758);
  v509 = SHIDWORD(v758) + 1;
  v510 = (_DWORD)v758 << (v509 & 0xF8);
  v511 = (_DWORD *)((char *)v756 + (v509 >> 3));
  v756 = v511;
  v512 = v509 & 7;
  HIDWORD(v758) = v512;
  if (v511 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v511 = v757;
  }
  LODWORD(v758) = (v343[29] << (v512 ^ 0x1F)) | v510;
  *v511 = bswap32(v758);
  v515 = SHIDWORD(v758) + 1;
  v513 = v515 & 0xF8;
  v514 = (_DWORD *)((char *)v756 + (v515 >> 3));
  v756 = v514;
  LODWORD(v515) = v515 & 7;
  HIDWORD(v758) = v515;
  if (v514 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v514 = v757;
  }
  v516 = (_DWORD)v758 << v513;
  if (v343[29])
  {
    LODWORD(v758) = (v343[30] << (v515 ^ 0x1F)) | v516;
    *v514 = bswap32(v758);
    v517 = SHIDWORD(v758) + 1;
    v518 = (_DWORD)v758 << (v517 & 0xF8);
    v519 = (_DWORD *)((char *)v756 + (v517 >> 3));
    v756 = v519;
    v520 = v517 & 7;
    HIDWORD(v758) = v520;
    if (v519 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v519 = v757;
    }
    LODWORD(v758) = (v343[31] << (v520 ^ 0x1F)) | v518;
    *v519 = bswap32(v758);
    v515 = SHIDWORD(v758) + 1;
    v521 = v515 & 0xF8;
    v514 = (_DWORD *)((char *)v756 + (v515 >> 3));
    v756 = v514;
    LODWORD(v515) = v515 & 7;
    HIDWORD(v758) = v515;
    if (v514 >= v757)
    {
      v759 = 1;
      v756 = v757;
      v514 = v757;
    }
    v516 = (_DWORD)v758 << v521;
    if (!v343[31])
    {
      v522 = (char)v343[32];
      if (v522 <= 0)
        v523 = -2 * v522;
      else
        v523 = 2 * v522 - 1;
      v524 = __clz(v523 + 1);
      v525 = (v523 + 1 - (0x80000000 >> v524)) | (0x80000000 >> v524);
      v526 = 63 - 2 * v524;
      LODWORD(v758) = (v525 << (-(char)v515 - v526)) | v516;
      *v514 = bswap32(v758);
      v527 = SHIDWORD(v758) + v526;
      v528 = (_DWORD)v758 << (v527 & 0xF8);
      v515 = (unint64_t)v756 + (v527 >> 3);
      v756 = (_DWORD *)v515;
      v529 = v527 & 7;
      HIDWORD(v758) = v529;
      if (v515 >= (unint64_t)v757)
      {
        v759 = 1;
        v756 = v757;
        v515 = (unint64_t)v757;
      }
      v530 = (char)v343[33];
      if (v530 <= 0)
        v531 = -2 * v530;
      else
        v531 = 2 * v530 - 1;
      v532 = v531 + 1;
      v533 = __clz(v532);
      LODWORD(v758) = (((v532 - (0x80000000 >> v533)) | (0x80000000 >> v533)) << (2 * v533 - 63 - v529)) | v528;
      *(_DWORD *)v515 = bswap32(v758);
      v534 = SHIDWORD(v758) + 63 - 2 * v533;
      v516 = (_DWORD)v758 << (v534 & 0xF8);
      v514 = (_DWORD *)((char *)v756 + (v534 >> 3));
      v756 = v514;
      LOBYTE(v515) = v534 & 7;
      HIDWORD(v758) = v534 & 7;
      if (v514 >= v757)
      {
        v759 = 1;
        v756 = v757;
        v514 = v757;
      }
    }
  }
  LODWORD(v758) = (v343[34] << (v515 ^ 0x1F)) | v516;
  *v514 = bswap32(v758);
  v535 = SHIDWORD(v758) + 1;
  v536 = (_DWORD)v758 << (v535 & 0xF8);
  v537 = (_DWORD *)((char *)v756 + (v535 >> 3));
  v756 = v537;
  v538 = v535 & 7;
  v758 = __PAIR64__(v538, v536);
  if (v537 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v537 = v757;
  }
  if (v343[34])
    goto LABEL_82;
  LODWORD(v758) = (v343[1595] << (v538 ^ 0x1F)) | v536;
  *v537 = bswap32(v758);
  v539 = SHIDWORD(v758) + 1;
  v540 = (_DWORD)v758 << (v539 & 0xF8);
  v541 = (_DWORD *)((char *)v756 + (v539 >> 3));
  v756 = v541;
  v542 = v539 & 7;
  HIDWORD(v758) = v542;
  if (v541 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v541 = v757;
  }
  if (*((_WORD *)v343 + 798))
    v543 = 2 * *((unsigned __int16 *)v343 + 798);
  else
    v543 = 1;
  v544 = __clz(v543);
  v545 = (v543 - (0x80000000 >> v544)) | (0x80000000 >> v544);
  v546 = 63 - 2 * v544;
  LODWORD(v758) = (v545 << (-(char)v542 - v546)) | v540;
  *v541 = bswap32(v758);
  v547 = SHIDWORD(v758) + v546;
  v548 = (_DWORD)v758 << (v547 & 0xF8);
  v549 = (_DWORD *)((char *)v756 + (v547 >> 3));
  v756 = v549;
  v550 = v547 & 7;
  HIDWORD(v758) = v550;
  if (v549 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v549 = v757;
  }
  LODWORD(v758) = (v343[1598] << (v550 ^ 0x1F)) | v548;
  *v549 = bswap32(v758);
  v551 = SHIDWORD(v758) + 1;
  v552 = (_DWORD)v758 << (v551 & 0xF8);
  v553 = (_DWORD *)((char *)v756 + (v551 >> 3));
  v756 = v553;
  v554 = v551 & 7;
  HIDWORD(v758) = v554;
  if (v553 >= v757)
  {
    v759 = 1;
    v756 = v757;
    v553 = v757;
  }
  LODWORD(v758) = (v343[1599] << (v554 ^ 0x1F)) | v552;
  *v553 = bswap32(v758);
  v555 = SHIDWORD(v758) + 1;
  v756 = (_DWORD *)((char *)v756 + (v555 >> 3));
  LODWORD(v758) = (_DWORD)v758 << (v555 & 0xF8);
  HIDWORD(v758) = v555 & 7;
  if (v756 >= v757)
  {
    v759 = 1;
    v756 = v757;
  }
  if (v343[1599])
  {
LABEL_82:
    v130 = 0;
  }
  else
  {
    sub_1B67C939C((uint64_t)&v753);
    v130 = off_1EF137C48(v762, 0, v755, (char *)v756 - v755, 2);
    *(_DWORD *)(v129 + 12720) += v130;
    v556 = *(FILE **)(v129 + 88);
    if (v556)
      fwrite(v762, 1uLL, v130, v556);
  }
  if (v753)
    free(v753);
  v750 = v130;
  v131 = v752;
  if (!v752)
    goto LABEL_2;
  v132 = v751;
  if (!v751 || !v130)
    goto LABEL_2;
  v751 -= 3;
  v752 -= 3;
  v750 = v130 - 3;
  v753 = (void *)(v7 + v131 - 3 + v132 - 3 + v130 - 3 + 64);
  v4 = malloc_type_calloc((size_t)v753, 1uLL, 0x100004077774924uLL);
  if (!v4)
  {
    VideoFormatDescription = FigSignalErrorAt();
    v4 = 0;
    goto LABEL_3;
  }
  VideoFormatDescription = sub_1B68910E4(v761, v760, byte_1B69202A4, v4, (size_t *)&v753);
  if (VideoFormatDescription)
  {
    FigSignalErrorAt();
    goto LABEL_3;
  }
  v557 = v753;
  v558 = v7 + 1;
  memcpy((char *)v753 + (_QWORD)v4, v2, v558);
  v559 = (CFIndex)v557 + v558;
  v560 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v561 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v4, v559);
  if (!v561)
  {
    VideoFormatDescription = FigSignalErrorAt();
    goto LABEL_3;
  }
  Mutable = CFDictionaryCreateMutable(v560, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable && (v563 = CFDictionaryCreateMutable(v560, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0])) != 0)
  {
    CFDictionaryAddValue(Mutable, CFSTR("ftvH"), v561);
    CFDictionaryAddValue(Mutable, CFSTR("hvcC"), v561);
    CFDictionaryAddValue(v563, (const void *)*MEMORY[0x1E0CA2240], Mutable);
    CFDictionaryAddValue(v563, (const void *)*MEMORY[0x1E0CA21C8], CFSTR("LRP"));
    v564 = *(const void **)(a1 + 288);
    if (v564)
      CFDictionaryAddValue(v563, (const void *)*MEMORY[0x1E0CA8D68], v564);
    v565 = *(const void **)(a1 + 296);
    if (v565)
      CFDictionaryAddValue(v563, (const void *)*MEMORY[0x1E0CA8E98], v565);
    v566 = *(const void **)(a1 + 304);
    if (v566)
      CFDictionaryAddValue(v563, (const void *)*MEMORY[0x1E0CA8EE8], v566);
    VideoFormatDescription = VTEncoderSessionCreateVideoFormatDescription();
    if (VideoFormatDescription)
      FigSignalErrorAt();
  }
  else
  {
    VideoFormatDescription = FigSignalErrorAt();
    v563 = 0;
  }
  free(v4);
  CFRelease(v561);
  if (Mutable)
    CFRelease(Mutable);
  if (v563)
    CFRelease(v563);
  return VideoFormatDescription;
}

void sub_1B67A9250(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  if (a13)
    free(a13);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B67A9284()
{
  uint64_t DerivedStorage;
  uint64_t v1;
  NSObject *v2;
  _QWORD *v3;
  _QWORD *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  NSObject *v11;
  const void *v12;
  const void *v13;
  void *v14;
  NSObject *v15;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (DerivedStorage)
  {
    v1 = DerivedStorage;
    if (!*(_BYTE *)(DerivedStorage + 356))
    {
      v2 = *(NSObject **)(DerivedStorage + 1392);
      if (v2)
        dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
      v3 = *(_QWORD **)(v1 + 16);
      if (v3)
      {
        v4 = sub_1B680B410(v3);
        MEMORY[0x1BCC9814C](v4, 0x10F0C4026B0C2FCLL);
      }
      *(_BYTE *)(v1 + 356) = 1;
      *(_QWORD *)v1 = 0;
      v5 = *(const void **)(v1 + 360);
      if (v5)
      {
        CFRelease(v5);
        *(_QWORD *)(v1 + 360) = 0;
      }
      FigFormatDescriptionRelease();
      *(_QWORD *)(v1 + 8) = 0;
      v6 = *(const void **)(v1 + 288);
      if (v6)
      {
        CFRelease(v6);
        *(_QWORD *)(v1 + 288) = 0;
      }
      v7 = *(const void **)(v1 + 296);
      if (v7)
      {
        CFRelease(v7);
        *(_QWORD *)(v1 + 296) = 0;
      }
      v8 = *(const void **)(v1 + 304);
      if (v8)
      {
        CFRelease(v8);
        *(_QWORD *)(v1 + 304) = 0;
      }
      v9 = *(const void **)(v1 + 312);
      if (v9)
      {
        CFRelease(v9);
        *(_QWORD *)(v1 + 312) = 0;
      }
      v10 = *(const void **)(v1 + 320);
      if (v10)
      {
        CFRelease(v10);
        *(_QWORD *)(v1 + 320) = 0;
      }
      v11 = *(NSObject **)(v1 + 1392);
      if (v11)
      {
        dispatch_semaphore_signal(v11);
        dispatch_release(*(dispatch_object_t *)(v1 + 1392));
      }
      v12 = *(const void **)(v1 + 1440);
      if (v12)
      {
        CFRelease(v12);
        *(_QWORD *)(v1 + 1440) = 0;
      }
      v13 = *(const void **)(v1 + 1472);
      if (v13)
      {
        CFRelease(v13);
        *(_QWORD *)(v1 + 1472) = 0;
      }
      v14 = *(void **)(v1 + 1416);
      if (v14)
      {
        objc_msgSend(v14, "invalidate");
        CFRelease(*(CFTypeRef *)(v1 + 1416));
      }
      v15 = *(NSObject **)(v1 + 1408);
      if (v15)
      {
        dispatch_semaphore_wait(v15, 0xFFFFFFFFFFFFFFFFLL);
        dispatch_release(*(dispatch_object_t *)(v1 + 1408));
        *(_QWORD *)(v1 + 1408) = 0;
      }
    }
  }
  return 0;
}

uint64_t sub_1B67A93C0()
{
  uint64_t result;

  result = CMBaseObjectGetDerivedStorage();
  if (result)
  {
    if (!*(_BYTE *)(result + 356))
      return sub_1B67A9284();
  }
  return result;
}

__CFString *sub_1B67A93FC(uint64_t a1)
{
  __CFString *Mutable;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<LRPVideoEncoder %p>"), a1);
  return Mutable;
}

uint64_t sub_1B67A9450(uint64_t a1, const void *a2, uint64_t a3, CFNumberRef *a4)
{
  uint64_t DerivedStorage;
  const void *v7;
  CFNumberType v8;
  CFNumberRef v9;
  const void **v10;
  int v11;
  const void *v12;
  __CFArray *Mutable;
  uint64_t v15;
  uint64_t v16;
  CFNumberRef v17;
  int v18;
  int v19;
  uint64_t v20;
  const __CFAllocator *v21;
  const void *v22;
  uint64_t v23;
  _DWORD *v24;
  CFNumberRef v25;
  uint64_t v26;
  _DWORD *v27;
  CFNumberRef v28;
  uint64_t v29;
  _DWORD *v30;
  CFNumberRef v31;
  uint64_t v32;
  const __CFAllocator *v33;
  const void *v34;
  void *values;
  CFNumberRef v36;
  const void *valuePtr;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  *a4 = 0;
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED248]))
  {
    v7 = (const void *)(DerivedStorage + 240);
LABEL_3:
    v8 = kCFNumberSInt32Type;
LABEL_4:
    v9 = CFNumberCreate(0, v8, v7);
LABEL_5:
    *a4 = v9;
    return 0;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECEC8]))
  {
    v10 = (const void **)MEMORY[0x1E0C9AE50];
    v11 = *(_DWORD *)(DerivedStorage + 244);
LABEL_10:
    if (!v11)
      v10 = (const void **)MEMORY[0x1E0C9AE40];
    v12 = *v10;
LABEL_13:
    CFRetain(v12);
    *a4 = (CFNumberRef)v12;
    return 0;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECEB0]))
  {
    v10 = (const void **)MEMORY[0x1E0C9AE50];
    v11 = *(_DWORD *)(DerivedStorage + 248);
    goto LABEL_10;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED0A8]))
  {
    v7 = (const void *)(DerivedStorage + 256);
    goto LABEL_3;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED0B0]))
  {
    v7 = (const void *)(DerivedStorage + 264);
LABEL_19:
    v8 = kCFNumberDoubleType;
    goto LABEL_4;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED120]))
  {
    v7 = (const void *)(DerivedStorage + 56);
    goto LABEL_3;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECEF0]))
  {
    LODWORD(valuePtr) = *(_DWORD *)(DerivedStorage + 52);
    v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    goto LABEL_5;
  }
  if (CFEqual(a2, CFSTR("BPictures")))
  {
    v7 = (const void *)(DerivedStorage + 252);
    goto LABEL_3;
  }
  if (CFEqual(a2, CFSTR("NegotiationDetailsBitField")) || CFEqual(a2, CFSTR("NegotiatedFLB")))
  {
    v9 = sub_1B685BF8C((char *)(DerivedStorage + 368));
    goto LABEL_5;
  }
  if (CFEqual(a2, CFSTR("AverageTemporalBitRates")))
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    v15 = 0;
    v16 = DerivedStorage + 64;
    do
    {
      if ((*(_DWORD *)(v16 + v15) & 0x80000000) != 0)
        break;
      v17 = CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(v16 + v15));
      CFArrayAppendValue(Mutable, v17);
      CFRelease(v17);
      v15 += 4;
    }
    while (v15 != 28);
LABEL_33:
    *a4 = Mutable;
    return 0;
  }
  if (CFEqual(a2, CFSTR("MaxRefreshFrameIntervalDuration")))
  {
    v7 = (const void *)(DerivedStorage + 272);
    goto LABEL_19;
  }
  if (CFEqual(a2, CFSTR("ThermalLevel")))
  {
    LODWORD(valuePtr) = *(_DWORD *)(DerivedStorage + 1372);
    v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    goto LABEL_5;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF50]))
  {
    LODWORD(valuePtr) = *(_DWORD *)(DerivedStorage + 228);
    v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    goto LABEL_5;
  }
  if (CFEqual(a2, CFSTR("AverageBitRateIntraLayer")))
  {
    LODWORD(valuePtr) = *(_DWORD *)(DerivedStorage + 92);
    v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    goto LABEL_5;
  }
  if (CFEqual(a2, CFSTR("FaceRect")))
  {
    v10 = (const void **)MEMORY[0x1E0C9AE50];
    v11 = *(unsigned __int8 *)(DerivedStorage + 1385);
    goto LABEL_10;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED118]))
  {
    LODWORD(valuePtr) = *(_DWORD *)(DerivedStorage + 1380);
    v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    goto LABEL_5;
  }
  if (!CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF78]))
  {
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECFD0]))
    {
      v7 = (const void *)(DerivedStorage + 24);
      goto LABEL_19;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF10]))
    {
      v7 = (const void *)(DerivedStorage + 32);
      goto LABEL_19;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF00]))
    {
      v7 = (const void *)(DerivedStorage + 40);
      goto LABEL_19;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED098]))
    {
      v7 = (const void *)(DerivedStorage + 1460);
      goto LABEL_3;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED0C0]))
    {
      v7 = (const void *)(DerivedStorage + 1464);
      goto LABEL_3;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED1A8]))
    {
      v7 = (const void *)(DerivedStorage + 1468);
      goto LABEL_3;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF20]))
    {
      v10 = (const void **)MEMORY[0x1E0C9AE50];
      v11 = *(unsigned __int8 *)(DerivedStorage + 1454);
      goto LABEL_10;
    }
    if (!CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF80]))
    {
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED180]))
      {
        v12 = *(const void **)(DerivedStorage + 312);
        if (!v12)
          return 0;
        goto LABEL_13;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED000]))
      {
        v12 = *(const void **)(DerivedStorage + 320);
        if (!v12)
          return 0;
        goto LABEL_13;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED1F8]))
      {
        v7 = (const void *)(DerivedStorage + 280);
        goto LABEL_3;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED140]))
      {
        v18 = *(_DWORD *)(DerivedStorage + 332);
        if (v18)
        {
          if (v18 == 1)
          {
            v19 = *(_DWORD *)(DerivedStorage + 336);
            if (v19 == 1)
              goto LABEL_82;
          }
          else
          {
            v19 = *(_DWORD *)(DerivedStorage + 336);
          }
          if (v19)
          {
            v20 = *MEMORY[0x1E0CA8E70];
            valuePtr = (const void *)*MEMORY[0x1E0CA8E60];
            v38 = v20;
            v21 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, (const void *)(DerivedStorage + 332));
            v36 = CFNumberCreate(v21, kCFNumberSInt32Type, (const void *)(DerivedStorage + 336));
            *a4 = CFDictionaryCreate(v21, &valuePtr, (const void **)&values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            CFRelease(values);
            CFRelease(v36);
            return 0;
          }
        }
LABEL_82:
        *a4 = 0;
        return 0;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF48]))
      {
        v12 = *(const void **)(DerivedStorage + 288);
        if (!v12)
          return 0;
        goto LABEL_13;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED238]))
      {
        v12 = *(const void **)(DerivedStorage + 296);
        if (!v12)
          return 0;
        goto LABEL_13;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED290]))
      {
        v12 = *(const void **)(DerivedStorage + 304);
        if (!v12)
          return 0;
        goto LABEL_13;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED070]))
      {
        v12 = *(const void **)(DerivedStorage + 1440);
        if (!v12)
          return 0;
        goto LABEL_13;
      }
      if (CFEqual(a2, CFSTR("EnableFrameDropping")))
      {
        v7 = (const void *)(DerivedStorage + 1448);
        goto LABEL_3;
      }
      if (CFEqual(a2, CFSTR("AllowQpModulation")))
      {
        v10 = (const void **)MEMORY[0x1E0C9AE50];
        v11 = *(unsigned __int8 *)(DerivedStorage + 1452);
        goto LABEL_10;
      }
      if (CFEqual(a2, CFSTR("RemoteMLScale")))
      {
        v10 = (const void **)MEMORY[0x1E0C9AE50];
        v11 = *(unsigned __int8 *)(DerivedStorage + 1453);
        goto LABEL_10;
      }
      if (CFEqual(a2, CFSTR("MinNumberOfTemporalLayers")))
      {
        v7 = (const void *)(DerivedStorage + 60);
        goto LABEL_3;
      }
      if (CFEqual(a2, CFSTR("CommandLineParametersExtraOptions")))
      {
        v22 = *(const void **)(DerivedStorage + 1480);
        if (v22)
        {
          CFRetain(v22);
          CFRetain(v22);
          valuePtr = v22;
          v34 = 0;
          *a4 = (CFNumberRef)v22;
          sub_1B6770508(&valuePtr);
          sub_1B6770508(&v34);
        }
        return 0;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF90]))
      {
        v10 = (const void **)MEMORY[0x1E0C9AE50];
        v11 = *(_DWORD *)(DerivedStorage + 1456);
        goto LABEL_10;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECED0]))
      {
        v12 = *(const void **)(DerivedStorage + 1472);
        if (!v12)
          return 0;
        goto LABEL_13;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED110]))
      {
        v7 = (const void *)(DerivedStorage + 1488);
        goto LABEL_3;
      }
      if (CFEqual(a2, CFSTR("SliceQP")))
      {
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
        if (*(int *)(DerivedStorage + 1488) >= 1)
        {
          v23 = 0;
          v24 = (_DWORD *)(DerivedStorage + 1492);
          do
          {
            if ((*v24 & 0x80000000) != 0)
              break;
            v25 = CFNumberCreate(0, kCFNumberSInt32Type, v24);
            CFArrayAppendValue(Mutable, v25);
            CFRelease(v25);
            ++v23;
            ++v24;
          }
          while (v23 < *(int *)(DerivedStorage + 1488));
        }
        goto LABEL_33;
      }
      if (CFEqual(a2, CFSTR("SliceDeltaQP")))
      {
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
        if (*(int *)(DerivedStorage + 1488) >= 1)
        {
          v26 = 0;
          v27 = (_DWORD *)(DerivedStorage + 1508);
          do
          {
            if ((*v27 & 0x80000000) != 0)
              break;
            v28 = CFNumberCreate(0, kCFNumberSInt32Type, v27);
            CFArrayAppendValue(Mutable, v28);
            CFRelease(v28);
            ++v26;
            ++v27;
          }
          while (v26 < *(int *)(DerivedStorage + 1488));
        }
        goto LABEL_33;
      }
      if (CFEqual(a2, CFSTR("SliceMaxQP")))
      {
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
        if (*(int *)(DerivedStorage + 1488) >= 1)
        {
          v29 = 0;
          v30 = (_DWORD *)(DerivedStorage + 1524);
          do
          {
            if ((*v30 & 0x80000000) != 0)
              break;
            v31 = CFNumberCreate(0, kCFNumberSInt32Type, v30);
            CFArrayAppendValue(Mutable, v31);
            CFRelease(v31);
            ++v29;
            ++v30;
          }
          while (v29 < *(int *)(DerivedStorage + 1488));
        }
        goto LABEL_33;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECFB8]))
      {
        v10 = (const void **)MEMORY[0x1E0C9AE50];
        v11 = *(unsigned __int8 *)(DerivedStorage + 1540);
        goto LABEL_10;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED0C8]))
      {
        v32 = *MEMORY[0x1E0CED6F0];
        valuePtr = (const void *)*MEMORY[0x1E0CED6F8];
        v38 = v32;
        v33 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloat32Type, (const void *)(DerivedStorage + 1544));
        v36 = CFNumberCreate(v33, kCFNumberFloat32Type, (const void *)(DerivedStorage + 1548));
        *a4 = CFDictionaryCreate(v33, &valuePtr, (const void **)&values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        CFRelease(values);
        CFRelease(v36);
        return 0;
      }
      if (CFEqual(a2, CFSTR("CallerID")))
      {
        v7 = (const void *)(DerivedStorage + 1552);
        v8 = kCFNumberSInt64Type;
        goto LABEL_4;
      }
    }
  }
  return FigSignalErrorAt();
}

void sub_1B67A9EFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_1B6770508(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1B67A9F18(uint64_t a1, const void *a2, const __CFString *a3)
{
  uint64_t DerivedStorage;
  CFTypeID TypeID;
  CFTypeID v7;
  uint64_t result;
  CFTypeID v9;
  CFTypeID v10;
  _BOOL4 v11;
  CFTypeID v12;
  CFTypeID v13;
  _BOOL4 v14;
  CFTypeID v15;
  void *v16;
  const __CFString *v17;
  CFNumberType v18;
  CFTypeID v19;
  CFTypeID v20;
  CFTypeID v21;
  int v22;
  CFTypeID v23;
  CFTypeID v24;
  char *v25;
  const char *v26;
  CFTypeID v27;
  CFTypeID v28;
  CFIndex Count;
  CFIndex v30;
  char *v31;
  const __CFNumber *ValueAtIndex;
  CFTypeID v33;
  CFTypeID v34;
  CFTypeID v35;
  CFTypeID v36;
  CFTypeID v37;
  int v38;
  CFTypeID v39;
  CFIndex v40;
  uint64_t v41;
  uint64_t v42;
  CFTypeID v43;
  CFTypeID v44;
  CFTypeID v45;
  double *v46;
  CFIndex v47;
  const void *v48;
  CFTypeID v49;
  CFNumberType Type;
  double v51;
  const void *v52;
  CFTypeID v53;
  CFNumberType v54;
  double v55;
  CFTypeID v56;
  CFTypeID v57;
  CFTypeID v58;
  CFTypeID v59;
  CFTypeID v60;
  BOOL v61;
  CFTypeID v62;
  CFTypeID v63;
  CFTypeID v64;
  const void *v65;
  const void *v66;
  const void *v67;
  CFTypeID v68;
  CFTypeID v69;
  int v70;
  unsigned int v71;
  unsigned int v72;
  CFTypeID v73;
  const void *v74;
  CFTypeID v75;
  const void *v76;
  CFTypeID v77;
  const void *v78;
  CFTypeID v79;
  CFTypeID v80;
  CFTypeID v81;
  BOOL v82;
  CFTypeID v83;
  BOOL v84;
  CFTypeID v85;
  int v86;
  int v87;
  CFTypeID v88;
  const void *v89;
  CFTypeID v90;
  CFTypeID v91;
  BOOL v92;
  CFTypeID v93;
  CFTypeID v94;
  CFTypeID v95;
  _BOOL4 v96;
  CFTypeID v97;
  const void *v98;
  CFTypeID v99;
  CFTypeID v100;
  CFIndex v101;
  CFIndex v102;
  uint64_t v103;
  CFTypeID v104;
  CFIndex v105;
  CFIndex v106;
  uint64_t v107;
  CFTypeID v108;
  CFIndex v109;
  CFIndex v110;
  uint64_t v111;
  CFTypeID v112;
  int v113;
  CFTypeID v114;
  float v115;
  CFTypeID v116;
  CFIndex v117;
  const void *v118;
  CFTypeID v119;
  uint64_t v120;
  CFIndex v121;
  const void *v122;
  CFTypeID v123;
  uint64_t v124;
  CFIndex v125;
  const void *v126;
  CFTypeID v127;
  uint64_t v128;
  float v129;
  float valuePtr;
  void *value;
  _BYTE buf[14];
  double v133;
  uint64_t v134;

  v134 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED248]))
  {
    if (a3)
    {
      TypeID = CFNumberGetTypeID();
      if (TypeID == CFGetTypeID(a3))
      {
        v7 = CFGetTypeID(a3);
        if (v7 == CFNumberGetTypeID())
          CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, (void *)(DerivedStorage + 240));
        if (*(_DWORD *)(DerivedStorage + 240) == 43)
        {
          result = 0;
          *(_DWORD *)(DerivedStorage + 1488) = 3;
          return result;
        }
        return 0;
      }
    }
    return FigSignalErrorAt();
  }
  if (!CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECEC8]))
  {
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECEB0]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v12 = CFBooleanGetTypeID();
      if (v12 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v13 = CFGetTypeID(a3);
      v14 = v13 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)a3) != 0;
      result = 0;
      *(_DWORD *)(DerivedStorage + 248) = v14;
      return result;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED0A8]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v15 = CFNumberGetTypeID();
      if (v15 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v16 = (void *)(DerivedStorage + 256);
      goto LABEL_22;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED0B0]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v19 = CFNumberGetTypeID();
      if (v19 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v16 = (void *)(DerivedStorage + 264);
      goto LABEL_29;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED120]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v20 = CFNumberGetTypeID();
      if (v20 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v16 = (void *)(DerivedStorage + 56);
      goto LABEL_22;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECEF0]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v21 = CFNumberGetTypeID();
      if (v21 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      *(_DWORD *)buf = 0;
      sub_1B67ABB28(a3, kCFNumberSInt32Type, buf);
      result = 0;
      v22 = *(_DWORD *)buf;
      *(double *)(DerivedStorage + 96) = (double)*(int *)buf * 0.125;
      *(_QWORD *)(DerivedStorage + 160) = 0x3FF0000000000000;
      *(_DWORD *)(DerivedStorage + 52) = v22;
LABEL_43:
      *(_BYTE *)(DerivedStorage + 224) = 1;
      return result;
    }
    if (CFEqual(a2, CFSTR("BPictures")))
    {
      if (!a3)
        return FigSignalErrorAt();
      v23 = CFNumberGetTypeID();
      if (v23 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v16 = (void *)(DerivedStorage + 252);
      goto LABEL_22;
    }
    if (CFEqual(a2, CFSTR("NegotiationDetailsBitField")))
    {
      *(_BYTE *)(DerivedStorage + 368) = 0;
      if (!a3)
        return 0;
      v24 = CFDataGetTypeID();
      if (v24 != CFGetTypeID(a3))
        return 0;
      v25 = (char *)(DerivedStorage + 368);
      v26 = "FLBA;";
      goto LABEL_56;
    }
    if (CFEqual(a2, CFSTR("NegotiatedFLB")))
    {
      *(_BYTE *)(DerivedStorage + 368) = 0;
      if (!a3)
        return 0;
      v27 = CFDataGetTypeID();
      if (v27 != CFGetTypeID(a3))
        return 0;
      v25 = (char *)(DerivedStorage + 368);
      v26 = "FLBN;";
LABEL_56:
      sub_1B685BEC8((const __CFData *)a3, v26, v25, 1000);
      return 0;
    }
    if (CFEqual(a2, CFSTR("AverageTemporalBitRates")))
    {
      if (!a3)
        return FigSignalErrorAt();
      v28 = CFArrayGetTypeID();
      if (v28 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      Count = CFArrayGetCount((CFArrayRef)a3);
      if ((unint64_t)(Count - 8) > 0xFFFFFFFFFFFFFFF8 || (FigSignalErrorAt(), Count >= 1))
      {
        v30 = 0;
        v31 = (char *)(DerivedStorage + 64);
        do
        {
          ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a3, v30);
          if (!ValueAtIndex)
          {
            FigSignalErrorAt();
            ValueAtIndex = 0;
          }
          CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, v31);
          result = 0;
          ++v30;
          v31 += 4;
        }
        while (Count != v30);
        return result;
      }
      return 0;
    }
    if (CFEqual(a2, CFSTR("MaxRefreshFrameIntervalDuration")))
    {
      if (!a3)
        return FigSignalErrorAt();
      v33 = CFNumberGetTypeID();
      if (v33 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v16 = (void *)(DerivedStorage + 272);
      goto LABEL_29;
    }
    if (CFEqual(a2, CFSTR("ThermalLevel")))
    {
      if (a3)
      {
        v34 = CFNumberGetTypeID();
        if (v34 == CFGetTypeID(a3))
        {
          *(_DWORD *)buf = 0;
          sub_1B67ABB28(a3, kCFNumberSInt32Type, buf);
          result = 0;
          *(_DWORD *)(DerivedStorage + 1372) = *(_DWORD *)buf;
          return result;
        }
      }
      return FigSignalErrorAt();
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF50]))
    {
      if (a3)
      {
        v35 = CFNumberGetTypeID();
        if (v35 == CFGetTypeID(a3))
        {
          *(_DWORD *)buf = 0;
          sub_1B67ABB28(a3, kCFNumberSInt32Type, buf);
          result = 0;
          *(_DWORD *)(DerivedStorage + 228) = *(_DWORD *)buf;
          return result;
        }
      }
      return FigSignalErrorAt();
    }
    if (CFEqual(a2, CFSTR("AverageBitRateIntraLayer")))
    {
      if (a3)
      {
        v36 = CFNumberGetTypeID();
        if (v36 == CFGetTypeID(a3))
        {
          *(_DWORD *)buf = 0;
          sub_1B67ABB28(a3, kCFNumberSInt32Type, buf);
          result = 0;
          *(_DWORD *)(DerivedStorage + 92) = *(_DWORD *)buf;
          return result;
        }
      }
      return FigSignalErrorAt();
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED118]))
    {
      if (a3)
      {
        v37 = CFNumberGetTypeID();
        if (v37 == CFGetTypeID(a3))
        {
          *(_DWORD *)buf = 1;
          sub_1B67ABB28(a3, kCFNumberSInt32Type, buf);
          result = 0;
          v38 = *(_DWORD *)buf;
          if (*(int *)buf <= 1)
            v38 = 1;
          *(_DWORD *)(DerivedStorage + 1380) = v38;
          return result;
        }
      }
      return 0;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF78]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v39 = CFArrayGetTypeID();
      if (v39 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v40 = CFArrayGetCount((CFArrayRef)a3);
      v41 = v40 >> 1;
      if (v40 < 18)
      {
        v42 = v40 >> 1;
        if (v40 < 2)
        {
LABEL_133:
          result = 0;
          goto LABEL_43;
        }
      }
      else if (dword_1EF137CD0 < 2)
      {
        v42 = 8;
      }
      else
      {
        v42 = 8;
        fprintf((FILE *)*MEMORY[0x1E0C80C10], "DataRateLimitsCount = %d -> we are able to read only %d", v41, 8);
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v41;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = 8;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "DataRateLimitsCount = %d -> we are able to read only %d", buf, 0xEu);
        }
      }
      v46 = (double *)(DerivedStorage + 160);
      v47 = 1;
      while (1)
      {
        v48 = CFArrayGetValueAtIndex((CFArrayRef)a3, v47 - 1);
        if (!v48)
          FigSignalErrorAt();
        v49 = CFNumberGetTypeID();
        if (v49 != CFGetTypeID(v48))
          FigSignalErrorAt();
        Type = CFNumberGetType((CFNumberRef)v48);
        if (Type == kCFNumberSInt64Type)
          break;
        if (Type == kCFNumberFloat64Type)
        {
          *(_QWORD *)buf = 0;
          CFNumberGetValue((CFNumberRef)v48, kCFNumberFloat64Type, buf);
          v51 = *(double *)buf;
LABEL_120:
          *(v46 - 8) = v51;
          goto LABEL_122;
        }
        FigSignalErrorAt();
LABEL_122:
        v52 = CFArrayGetValueAtIndex((CFArrayRef)a3, v47);
        if (!v52)
          FigSignalErrorAt();
        v53 = CFNumberGetTypeID();
        if (v53 != CFGetTypeID(v52))
          FigSignalErrorAt();
        v54 = CFNumberGetType((CFNumberRef)v52);
        if (v54 == kCFNumberSInt64Type)
        {
          *(_QWORD *)buf = 0;
          CFNumberGetValue((CFNumberRef)v52, kCFNumberSInt64Type, buf);
          v55 = (double)*(uint64_t *)buf;
        }
        else
        {
          if (v54 != kCFNumberFloat64Type)
          {
            FigSignalErrorAt();
            goto LABEL_132;
          }
          *(_QWORD *)buf = 0;
          CFNumberGetValue((CFNumberRef)v52, kCFNumberFloat64Type, buf);
          v55 = *(double *)buf;
        }
        *v46 = v55;
LABEL_132:
        ++v46;
        v47 += 2;
        if (!--v42)
          goto LABEL_133;
      }
      *(_QWORD *)buf = 0;
      CFNumberGetValue((CFNumberRef)v48, kCFNumberSInt64Type, buf);
      v51 = (double)*(uint64_t *)buf;
      goto LABEL_120;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECFD0]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v43 = CFNumberGetTypeID();
      if (v43 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v16 = (void *)(DerivedStorage + 24);
      goto LABEL_29;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED000]))
    {
      if (a3)
      {
        v44 = CFStringGetTypeID();
        if (v44 == CFGetTypeID(a3))
          return sub_1B67ABB84(DerivedStorage, a3);
      }
      return FigSignalErrorAt();
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF10]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v45 = CFNumberGetTypeID();
      if (v45 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v16 = (void *)(DerivedStorage + 32);
      goto LABEL_29;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF00]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v56 = CFNumberGetTypeID();
      if (v56 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v16 = (void *)(DerivedStorage + 40);
LABEL_29:
      v17 = a3;
      v18 = kCFNumberDoubleType;
      goto LABEL_30;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED098]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v57 = CFNumberGetTypeID();
      if (v57 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v16 = (void *)(DerivedStorage + 1460);
      goto LABEL_22;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED0C0]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v58 = CFNumberGetTypeID();
      if (v58 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v16 = (void *)(DerivedStorage + 1464);
      goto LABEL_22;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED1A8]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v59 = CFNumberGetTypeID();
      if (v59 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v16 = (void *)(DerivedStorage + 1468);
      goto LABEL_22;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF20]))
    {
      if (a3)
      {
        v60 = CFBooleanGetTypeID();
        if (v60 == CFGetTypeID(a3))
        {
          v61 = sub_1B67ABC40(a3);
          result = 0;
          *(_BYTE *)(DerivedStorage + 1454) = v61;
          return result;
        }
      }
      return FigSignalErrorAt();
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF80]))
    {
      if (a3)
      {
        CFNumberGetTypeID();
        CFGetTypeID(a3);
      }
      return FigSignalErrorAt();
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED180]))
    {
      if (a3)
      {
        v62 = CFStringGetTypeID();
        if (v62 == CFGetTypeID(a3))
          return sub_1B67ABC88(DerivedStorage, a3);
      }
      return FigSignalErrorAt();
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED1F8]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v63 = CFNumberGetTypeID();
      if (v63 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v16 = (void *)(DerivedStorage + 280);
      goto LABEL_22;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED140]))
    {
      if (!a3)
      {
        result = 0;
        *(_QWORD *)(DerivedStorage + 332) = 0x100000001;
        return result;
      }
      v64 = CFDictionaryGetTypeID();
      if (v64 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v65 = CFDictionaryGetValue((CFDictionaryRef)a3, (const void *)*MEMORY[0x1E0CA8E60]);
      v66 = CFDictionaryGetValue((CFDictionaryRef)a3, (const void *)*MEMORY[0x1E0CA8E70]);
      if (!v65)
        return FigSignalErrorAt();
      v67 = v66;
      v68 = CFNumberGetTypeID();
      if (v68 != CFGetTypeID(v65))
        return FigSignalErrorAt();
      if (!v67)
        return FigSignalErrorAt();
      v69 = CFNumberGetTypeID();
      if (v69 != CFGetTypeID(v67))
        return FigSignalErrorAt();
      *(_DWORD *)buf = 0;
      LODWORD(value) = 0;
      sub_1B67ABB28(v65, kCFNumberIntType, buf);
      sub_1B67ABB28(v67, kCFNumberIntType, &value);
      if (*(int *)buf > 0)
      {
        v70 = (int)value;
        if ((int)value >= 1)
        {
          v71 = *(_DWORD *)buf;
          v72 = value;
          do
          {
            if ((int)v71 <= (int)v72)
              v72 %= v71;
            else
              v71 %= v72;
          }
          while (v71 && v72);
          result = 0;
          if (!v71)
            v71 = v72;
          *(_DWORD *)(DerivedStorage + 332) = *(_DWORD *)buf / v71;
          *(_DWORD *)(DerivedStorage + 336) = v70 / (int)v71;
          return result;
        }
      }
      return FigSignalErrorAt();
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF48]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v73 = CFStringGetTypeID();
      if (v73 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v74 = *(const void **)(DerivedStorage + 288);
      if (v74)
        CFRelease(v74);
      CFRetain(a3);
      result = 0;
      *(_QWORD *)(DerivedStorage + 288) = a3;
      return result;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED238]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v75 = CFStringGetTypeID();
      if (v75 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v76 = *(const void **)(DerivedStorage + 296);
      if (v76)
        CFRelease(v76);
      CFRetain(a3);
      result = 0;
      *(_QWORD *)(DerivedStorage + 296) = a3;
      return result;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED290]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v77 = CFStringGetTypeID();
      if (v77 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v78 = *(const void **)(DerivedStorage + 304);
      if (v78)
        CFRelease(v78);
      CFRetain(a3);
      result = 0;
      *(_QWORD *)(DerivedStorage + 304) = a3;
      return result;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED0F8]))
    {
      *(_BYTE *)(DerivedStorage + 368) = 0;
      if (a3)
      {
        v79 = CFStringGetTypeID();
        if (v79 == CFGetTypeID(a3))
          CFStringGetCString(a3, (char *)(DerivedStorage + 368), 1001, 0);
      }
      return 0;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECFE0]))
    {
      if (a3)
      {
        v80 = CFNumberGetTypeID();
        if (v80 == CFGetTypeID(a3))
        {
          *(_DWORD *)buf = 0;
          sub_1B67ABB28(a3, kCFNumberSInt32Type, buf);
          result = 0;
          *(_DWORD *)(DerivedStorage + 1424) = *(_DWORD *)buf;
          return result;
        }
      }
      return FigSignalErrorAt();
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED178]))
      return 0;
    if (CFEqual(a2, CFSTR("UsingCellular")))
    {
      *(_DWORD *)buf = 0;
      sub_1B67ABB28(a3, kCFNumberSInt32Type, buf);
      result = 0;
      *(_DWORD *)(DerivedStorage + 1376) = *(_DWORD *)buf;
      return result;
    }
    if (CFEqual(a2, CFSTR("FaceRect")))
    {
      if (a3)
      {
        v81 = CFBooleanGetTypeID();
        if (v81 == CFGetTypeID(a3))
        {
          v82 = sub_1B67ABC40(a3);
          result = 0;
          *(_BYTE *)(DerivedStorage + 1385) = v82;
          return result;
        }
      }
      return 0;
    }
    if (CFEqual(a2, CFSTR("RemoteMLScale")))
    {
      if (a3)
      {
        v83 = CFBooleanGetTypeID();
        if (v83 == CFGetTypeID(a3))
        {
          v84 = sub_1B67ABC40(a3);
          result = 0;
          *(_BYTE *)(DerivedStorage + 1453) = v84;
          return result;
        }
      }
      return FigSignalErrorAt();
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED1B8]))
    {
      if (a3)
      {
        v85 = CFNumberGetTypeID();
        if (v85 == CFGetTypeID(a3))
        {
          LODWORD(value) = 0;
          sub_1B67ABB28(a3, kCFNumberSInt32Type, &value);
          if ((int)value >= 5000)
            v86 = 5000;
          else
            v86 = (int)value;
          if (v86 <= 50)
            v87 = 50;
          else
            v87 = v86;
          if ((_DWORD)value != v87 && dword_1EF137CD0 >= 2)
          {
            fprintf((FILE *)*MEMORY[0x1E0C80C10], "Requested max encoder latency %d. Clamped to %d\n", (_DWORD)value, v87);
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 67109376;
              *(_DWORD *)&buf[4] = (_DWORD)value;
              *(_WORD *)&buf[8] = 1024;
              *(_DWORD *)&buf[10] = v87;
              _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Requested max encoder latency %d. Clamped to %d\n", buf, 0xEu);
            }
          }
          result = 0;
          *(_DWORD *)(DerivedStorage + 1428) = v87;
          *(_BYTE *)(DerivedStorage + 1432) = 1;
          return result;
        }
      }
      return 0;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED070]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v88 = CFDataGetTypeID();
      if (v88 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v89 = *(const void **)(DerivedStorage + 1440);
      if (v89)
        CFRelease(v89);
      CFRetain(a3);
      result = 0;
      *(_QWORD *)(DerivedStorage + 1440) = a3;
      return result;
    }
    if (CFEqual(a2, CFSTR("EnableFrameDropping")))
    {
      if (!a3)
        return FigSignalErrorAt();
      v90 = CFNumberGetTypeID();
      if (v90 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v16 = (void *)(DerivedStorage + 1448);
      goto LABEL_22;
    }
    if (CFEqual(a2, CFSTR("AllowQpModulation")))
    {
      if (a3)
      {
        v91 = CFBooleanGetTypeID();
        if (v91 == CFGetTypeID(a3))
        {
          v92 = sub_1B67ABC40(a3);
          result = 0;
          *(_BYTE *)(DerivedStorage + 1452) = v92;
          return result;
        }
      }
      return FigSignalErrorAt();
    }
    if (CFEqual(a2, CFSTR("MinNumberOfTemporalLayers")))
    {
      if (!a3)
        return FigSignalErrorAt();
      v93 = CFNumberGetTypeID();
      if (v93 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v16 = (void *)(DerivedStorage + 60);
      goto LABEL_22;
    }
    if (CFEqual(a2, CFSTR("CommandLineParametersExtraOptions")))
    {
      if (!a3)
        return FigSignalErrorAt();
      v94 = CFStringGetTypeID();
      if (v94 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      *(_QWORD *)buf = CFRetain(a3);
      sub_1B67ABDA8((const void **)(DerivedStorage + 1480), (const void **)buf);
      sub_1B6770508((const void **)buf);
      return 0;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECF90]))
    {
      if (a3)
      {
        v95 = CFBooleanGetTypeID();
        if (v95 == CFGetTypeID(a3))
        {
          v96 = sub_1B67ABC40(a3);
          result = 0;
          *(_DWORD *)(DerivedStorage + 1456) = v96;
          return result;
        }
      }
      return FigSignalErrorAt();
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECED0]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v97 = CFStringGetTypeID();
      if (v97 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v98 = *(const void **)(DerivedStorage + 1472);
      if (v98)
        CFRelease(v98);
      CFRetain(a3);
      result = 0;
      *(_QWORD *)(DerivedStorage + 1472) = a3;
      return result;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED110]))
    {
      if (!a3)
        return FigSignalErrorAt();
      v99 = CFNumberGetTypeID();
      if (v99 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v16 = (void *)(DerivedStorage + 1488);
LABEL_22:
      v17 = a3;
      v18 = kCFNumberSInt32Type;
LABEL_30:
      sub_1B67ABB28(v17, v18, v16);
      return 0;
    }
    if (CFEqual(a2, CFSTR("SliceQP")))
    {
      if (!a3)
        return FigSignalErrorAt();
      v100 = CFArrayGetTypeID();
      if (v100 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v101 = CFArrayGetCount((CFArrayRef)a3);
      v102 = v101;
      if (v101 < 5)
      {
        v103 = v101;
        if (v101 < 1)
          goto LABEL_326;
      }
      else if (dword_1EF137CD0 < 2)
      {
        v103 = 4;
      }
      else
      {
        v103 = 4;
        fprintf((FILE *)*MEMORY[0x1E0C80C10], "SliceQPCount = %d > kMaxSliceNum(%d)", v101, 4);
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v102;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = 4;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "SliceQPCount = %d > kMaxSliceNum(%d)", buf, 0xEu);
        }
      }
      v117 = 0;
      do
      {
        v118 = CFArrayGetValueAtIndex((CFArrayRef)a3, v117);
        if (!v118)
          FigSignalErrorAt();
        v119 = CFNumberGetTypeID();
        if (v119 != CFGetTypeID(v118))
          FigSignalErrorAt();
        if (CFNumberGetType((CFNumberRef)v118) == kCFNumberSInt64Type)
        {
          *(_DWORD *)buf = 0;
          CFNumberGetValue((CFNumberRef)v118, kCFNumberSInt64Type, buf);
          *(_DWORD *)(DerivedStorage + 1492 + 4 * v117) = *(_DWORD *)buf;
        }
        else
        {
          FigSignalErrorAt();
        }
        ++v117;
      }
      while (v103 != v117);
      v102 = v103;
LABEL_326:
      if ((int)v102 <= 3)
      {
        v120 = (int)v102;
        do
        {
          result = 0;
          *(_DWORD *)(DerivedStorage + 1492 + 4 * v120++) = *(_DWORD *)(DerivedStorage + 1492 + 4 * v102 - 4);
        }
        while ((_DWORD)v120 != 4);
        return result;
      }
      return 0;
    }
    if (CFEqual(a2, CFSTR("SliceDeltaQP")))
    {
      if (!a3)
        return FigSignalErrorAt();
      v104 = CFArrayGetTypeID();
      if (v104 != CFGetTypeID(a3))
        return FigSignalErrorAt();
      v105 = CFArrayGetCount((CFArrayRef)a3);
      v106 = v105;
      if (v105 < 5)
      {
        v107 = v105;
        if (v105 < 1)
          goto LABEL_343;
      }
      else if (dword_1EF137CD0 < 2)
      {
        v107 = 4;
      }
      else
      {
        v107 = 4;
        fprintf((FILE *)*MEMORY[0x1E0C80C10], "SliceDeltaQPCount = %d > kMaxSliceNum(%d)", v105, 4);
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v106;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = 4;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "SliceDeltaQPCount = %d > kMaxSliceNum(%d)", buf, 0xEu);
        }
      }
      v121 = 0;
      do
      {
        v122 = CFArrayGetValueAtIndex((CFArrayRef)a3, v121);
        if (!v122)
          FigSignalErrorAt();
        v123 = CFNumberGetTypeID();
        if (v123 != CFGetTypeID(v122))
          FigSignalErrorAt();
        if (CFNumberGetType((CFNumberRef)v122) == kCFNumberSInt64Type)
        {
          *(_DWORD *)buf = 0;
          CFNumberGetValue((CFNumberRef)v122, kCFNumberSInt64Type, buf);
          *(_DWORD *)(DerivedStorage + 1508 + 4 * v121) = *(_DWORD *)buf;
        }
        else
        {
          FigSignalErrorAt();
        }
        ++v121;
      }
      while (v107 != v121);
      v106 = v107;
LABEL_343:
      if ((int)v106 <= 3)
      {
        v124 = (int)v106;
        do
        {
          result = 0;
          *(_DWORD *)(DerivedStorage + 1508 + 4 * v124++) = *(_DWORD *)(DerivedStorage + 1508 + 4 * v106 - 4);
        }
        while ((_DWORD)v124 != 4);
        return result;
      }
      return 0;
    }
    if (!CFEqual(a2, CFSTR("SliceMaxQP")))
    {
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CECFB8]))
      {
        if (a3 && (v112 = CFBooleanGetTypeID(), v112 == CFGetTypeID(a3)))
        {
          v113 = sub_1B67ABC40(a3);
          result = 0;
          *(_BYTE *)(DerivedStorage + 1540) = v113;
        }
        else
        {
          result = FigSignalErrorAt();
          v113 = *(unsigned __int8 *)(DerivedStorage + 1540);
        }
        if (v113)
          return sub_1B67ABC88(DerivedStorage, (CFTypeRef)*MEMORY[0x1E0CED9B8]);
        return result;
      }
      if (!CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CED0C8]))
      {
        if (!CFEqual(a2, CFSTR("CallerID")))
          return FigSignalErrorAt();
        if (!a3)
          return FigSignalErrorAt();
        v116 = CFNumberGetTypeID();
        if (v116 != CFGetTypeID(a3))
          return FigSignalErrorAt();
        v16 = (void *)(DerivedStorage + 1552);
        v17 = a3;
        v18 = kCFNumberSInt64Type;
        goto LABEL_30;
      }
      if (!a3)
        return FigSignalErrorAt();
      v114 = CFGetTypeID(a3);
      if (v114 != CFDictionaryGetTypeID())
        return FigSignalErrorAt();
      value = 0;
      v129 = -1.0;
      valuePtr = -1.0;
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)a3, (const void *)*MEMORY[0x1E0CED6F8], (const void **)&value))
        CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, &valuePtr);
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)a3, (const void *)*MEMORY[0x1E0CED6F0], (const void **)&value))
        CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, &v129);
      if (valuePtr >= 0.0)
      {
        v115 = v129;
        if (v129 >= 0.0 && valuePtr <= v129)
        {
          result = 0;
          *(float *)(DerivedStorage + 1544) = valuePtr;
          *(float *)(DerivedStorage + 1548) = v115;
          return result;
        }
      }
      if (dword_1EF137CD0 >= 2)
      {
        fprintf((FILE *)*MEMORY[0x1E0C80C10], "bad min and max disparity [%f, %f], ignored", valuePtr, v129);
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218240;
          *(double *)&buf[4] = valuePtr;
          *(_WORD *)&buf[12] = 2048;
          v133 = v129;
          _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "bad min and max disparity [%f, %f], ignored", buf, 0x16u);
        }
      }
      return FigSignalErrorAt();
    }
    if (!a3)
      return FigSignalErrorAt();
    v108 = CFArrayGetTypeID();
    if (v108 != CFGetTypeID(a3))
      return FigSignalErrorAt();
    v109 = CFArrayGetCount((CFArrayRef)a3);
    v110 = v109;
    if (v109 < 5)
    {
      v111 = v109;
      if (v109 < 1)
        goto LABEL_360;
    }
    else if (dword_1EF137CD0 < 2)
    {
      v111 = 4;
    }
    else
    {
      v111 = 4;
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "SliceMaxQPCount = %d > kMaxSliceNum(%d)", v109, 4);
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v110;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = 4;
        _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "SliceMaxQPCount = %d > kMaxSliceNum(%d)", buf, 0xEu);
      }
    }
    v125 = 0;
    do
    {
      v126 = CFArrayGetValueAtIndex((CFArrayRef)a3, v125);
      if (!v126)
        FigSignalErrorAt();
      v127 = CFNumberGetTypeID();
      if (v127 != CFGetTypeID(v126))
        FigSignalErrorAt();
      if (CFNumberGetType((CFNumberRef)v126) == kCFNumberSInt64Type)
      {
        *(_DWORD *)buf = 0;
        CFNumberGetValue((CFNumberRef)v126, kCFNumberSInt64Type, buf);
        *(_DWORD *)(DerivedStorage + 1524 + 4 * v125) = *(_DWORD *)buf;
      }
      else
      {
        FigSignalErrorAt();
      }
      ++v125;
    }
    while (v111 != v125);
    v110 = v111;
LABEL_360:
    if ((int)v110 <= 3)
    {
      v128 = (int)v110;
      do
      {
        result = 0;
        *(_DWORD *)(DerivedStorage + 1524 + 4 * v128++) = *(_DWORD *)(DerivedStorage + 1524 + 4 * v110 - 4);
      }
      while ((_DWORD)v128 != 4);
      return result;
    }
    return 0;
  }
  if (!a3)
    return FigSignalErrorAt();
  v9 = CFBooleanGetTypeID();
  if (v9 != CFGetTypeID(a3))
    return FigSignalErrorAt();
  v10 = CFGetTypeID(a3);
  v11 = v10 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)a3) != 0;
  result = 0;
  *(_DWORD *)(DerivedStorage + 244) = v11;
  return result;
}

CFTypeID sub_1B67ABB28(const void *a1, CFNumberType a2, void *a3)
{
  CFTypeID v6;
  CFTypeID result;

  v6 = CFGetTypeID(a1);
  result = CFNumberGetTypeID();
  if (v6 == result)
    return CFNumberGetValue((CFNumberRef)a1, a2, a3);
  return result;
}

uint64_t sub_1B67ABB84(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4;
  const void *v5;
  uint64_t v6;
  uint64_t *v7;
  CFTypeRef *v8;
  CFTypeRef *v9;

  v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID())
    return 4294954394;
  v5 = *(const void **)(a1 + 320);
  if (v5)
    CFRelease(v5);
  CFRetain(cf);
  v6 = 0;
  *(_QWORD *)(a1 + 320) = cf;
  *(_DWORD *)(a1 + 328) = 0;
  v7 = &qword_1E6A16AC0;
  v8 = (CFTypeRef *)MEMORY[0x1E0CED678];
  while (!CFEqual(cf, *v8))
  {
    ++v6;
    v9 = (CFTypeRef *)*v7;
    v7 += 2;
    v8 = v9;
    if (!v9)
      goto LABEL_10;
  }
  *(_DWORD *)(a1 + 328) = dword_1E6A16AB0[4 * v6 + 2];
LABEL_10:
  if (*(_DWORD *)(a1 + 232))
    return 0;
  else
    return 4294954394;
}

BOOL sub_1B67ABC40(const void *a1)
{
  CFTypeID v2;

  v2 = CFGetTypeID(a1);
  return v2 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)a1) != 0;
}

uint64_t sub_1B67ABC88(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4;
  const void *v5;
  int v6;
  CFTypeRef **v7;
  int v8;
  CFTypeRef *v9;
  uint64_t v10;
  CFTypeRef **v11;
  CFTypeRef *v12;

  if (!cf)
  {
    v8 = *(_DWORD *)(a1 + 232);
    return sub_1B67C52D0(*(_DWORD *)(a1 + 340), *(_DWORD *)(a1 + 344), v8, *(_DWORD *)(a1 + 48));
  }
  v4 = CFGetTypeID(cf);
  if (v4 == CFStringGetTypeID())
  {
    v5 = *(const void **)(a1 + 312);
    if (v5)
      CFRelease(v5);
    CFRetain(cf);
    *(_QWORD *)(a1 + 312) = cf;
    v6 = *(_DWORD *)(a1 + 48);
    if (v6 == 1684632424 || v6 == 1752589105 || v6 == 1718908520)
      v7 = (CFTypeRef **)&off_1E6A16AD0;
    else
      v7 = (CFTypeRef **)&off_1E6A16B40;
    v9 = *v7;
    if (*v7)
    {
      v10 = 0;
      v11 = v7 + 2;
      while (!CFEqual(cf, *v9))
      {
        ++v10;
        v12 = *v11;
        v11 += 2;
        v9 = v12;
        if (!v12)
          goto LABEL_17;
      }
      *(_QWORD *)(a1 + 232) = v7[2 * v10 + 1];
    }
LABEL_17:
    v8 = *(_DWORD *)(a1 + 232);
    if (v8)
      return sub_1B67C52D0(*(_DWORD *)(a1 + 340), *(_DWORD *)(a1 + 344), v8, *(_DWORD *)(a1 + 48));
  }
  return 4294954394;
}

const void **sub_1B67ABDA8(const void **a1, const void **a2)
{
  const void *v4;

  v4 = *a1;
  if (v4)
    CFRelease(v4);
  *a1 = *a2;
  *a2 = 0;
  return a1;
}

CFTypeID sub_1B67ABDE8(_DWORD *a1, uint64_t *a2, uint64_t *a3, int a4, int a5, int a6, int a7, double a8, double a9)
{
  _BOOL4 v15;
  uint64_t v16;
  void *v17;
  void *v18;
  int *v19;
  CFTypeID result;
  const void *Value;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  CFTypeID TypeID;
  const void **v28;
  const __CFArray *v29;
  const __CFArray *v30;
  CFTypeID v31;
  unsigned int Count;
  int v33;
  unint64_t v34;
  char *v35;
  const __CFNumber *ValueAtIndex;
  const __CFNumber *v37;
  const __CFNumber *v38;
  CFTypeID v39;
  const __CFNumber *v40;
  const __CFNumber *v41;
  CFTypeID v42;
  const __CFNumber *v43;
  const __CFNumber *v44;
  CFTypeID v45;
  const __CFNumber *v46;
  const __CFNumber *v47;
  CFTypeID v48;
  const __CFNumber *v49;
  const __CFNumber *v50;
  CFTypeID v51;
  const __CFNumber *v52;
  const __CFNumber *v53;
  CFTypeID v54;
  const void *v55;
  const void *v56;
  const __CFNumber *v57;
  const __CFNumber *v58;
  CFTypeID v59;
  const __CFNumber *v60;
  const __CFNumber *v61;
  CFTypeID v62;
  const __CFNumber *v63;
  const __CFNumber *v64;
  CFTypeID v65;
  const __CFDictionary *v66;
  const void *v67;
  int v68;
  const __CFNumber *v69;
  const __CFNumber *v70;
  CFTypeID v71;
  const __CFNumber *v72;
  const __CFNumber *v73;
  CFTypeID v74;
  const __CFArray *v75;
  const __CFArray *v76;
  CFTypeID v77;
  CFIndex v78;
  CFIndex v79;
  CFIndex v80;
  char *v81;
  const __CFNumber *v82;
  const __CFDictionary *v83;
  const __CFDictionary *v84;
  CFTypeID v85;
  const __CFNumber *v86;
  const __CFNumber *v87;
  CFTypeID v88;
  const __CFNumber *v89;
  const __CFNumber *v90;
  CFTypeID v91;
  const __CFNumber *v92;
  const __CFNumber *v93;
  CFTypeID v94;
  const __CFNumber *v95;
  const __CFNumber *v96;
  CFTypeID v97;
  const __CFDictionary *v98;
  const __CFDictionary *v99;
  CFTypeID v100;
  const __CFNumber *v101;
  const __CFNumber *v102;
  CFTypeID v103;
  BOOL v104;
  const __CFNumber *v105;
  const __CFNumber *v106;
  CFTypeID v107;
  const __CFNumber *v108;
  const __CFNumber *v109;
  CFTypeID v110;
  const __CFNumber *v111;
  const __CFNumber *v112;
  CFTypeID v113;
  const __CFArray *v114;
  CFTypeID v115;
  const __CFNumber *v116;
  const __CFNumber *v117;
  CFTypeID v118;
  const __CFNumber *v119;
  const __CFNumber *v120;
  CFTypeID v121;
  const __CFNumber *v122;
  CFTypeID v123;
  uint64_t v124;
  int v125;
  double v126;
  double v127;
  double v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  BOOL v132;
  int v133;
  uint64_t v134;
  double v135;
  float v136;
  int v137;
  BOOL v138;
  unsigned int v139;
  unint64_t v140;
  uint64_t v141;
  _DWORD *v142;
  unsigned int v143;
  float v144;
  int v145;
  uint64_t v146;
  uint64_t v147;
  double v148;
  int v149;
  int *v150;
  uint64_t *v151;
  int *v152;
  int v153;
  int v154;
  uint8_t buf[4];
  int v156;
  uint64_t v157;

  v15 = 0;
  v157 = *MEMORY[0x1E0C80C00];
  v16 = *a2;
  *((_QWORD *)a1 + 98) = *a2;
  a1[200] = *((_DWORD *)a2 + 2);
  *((_BYTE *)a1 + 204) = 0;
  a1[54] = 0;
  a1[71] = 0;
  v17 = a1 + 74;
  a1[174] = 0;
  v18 = a1 + 85;
  *((_WORD *)a1 + 70) = 0;
  v19 = a1 + 210;
  a1[49] = 0;
  *(_OWORD *)(a1 + 45) = 0u;
  *(_QWORD *)(a1 + 43) = 0;
  *((_QWORD *)a1 + 41) = 0;
  *(_OWORD *)(a1 + 74) = 0u;
  *(_OWORD *)(a1 + 78) = 0u;
  *(_OWORD *)(a1 + 85) = 0u;
  *(_OWORD *)(a1 + 210) = 0u;
  if (!a4)
  {
    *((_QWORD *)a1 + 19) = v16;
    a1[40] = 0;
    v15 = 1;
    *((_QWORD *)a1 + 26) = v16;
  }
  *((_WORD *)a1 + 101) = 0;
  *((_BYTE *)a1 + 200) = 0;
  result = *((_QWORD *)a1 + 103);
  if (result)
  {
    v151 = a3;
    v153 = a7;
    v154 = a5;
    Value = CFDictionaryGetValue((CFDictionaryRef)result, (const void *)*MEMORY[0x1E0CED5B8]);
    v152 = v19;
    if (Value)
    {
      v22 = Value;
      if (CFGetTypeID(Value))
      {
        if (CFBooleanGetTypeID())
          v15 = CFEqual(v22, (CFTypeRef)*MEMORY[0x1E0C9AE50]) != 0;
      }
    }
    if (v15 && dword_1EF137CD0 >= 3 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      v156 = a4;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "frame %d: key frame requested\n", buf, 8u);
    }
    v23 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E0CED5C0]);
    if (v23)
    {
      v24 = v23;
      if (CFGetTypeID(v23))
      {
        if (CFBooleanGetTypeID())
          *((_BYTE *)a1 + 204) = CFEqual(v24, (CFTypeRef)*MEMORY[0x1E0C9AE50]) != 0;
      }
    }
    v25 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E0CED5A8]);
    if (v25)
    {
      v26 = v25;
      TypeID = CFDataGetTypeID();
      if (TypeID == CFGetTypeID(v26))
        *((_BYTE *)a1 + 204) = 1;
    }
    if (*((_BYTE *)a1 + 204) && dword_1EF137CD0 >= 3 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      v156 = a4;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "frame %d: refresh frame requested\n", buf, 8u);
    }
    v28 = (const void **)MEMORY[0x1E0CED498];
    if (!a1[214])
      v28 = (const void **)MEMORY[0x1E0CED4A0];
    v29 = (const __CFArray *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), *v28);
    if (v29)
    {
      v30 = v29;
      v31 = CFArrayGetTypeID();
      if (v31 == CFGetTypeID(v30))
      {
        Count = CFArrayGetCount(v30);
        v33 = Count >= 0x10 ? 16 : Count;
        a1[54] = v33;
        if (v33)
        {
          v34 = 0;
          v35 = (char *)(a1 + 55);
          do
          {
            ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v30, v34);
            CFNumberGetValue(ValueAtIndex, kCFNumberIntType, v35);
            ++v34;
            v35 += 4;
          }
          while (v34 < a1[54]);
        }
      }
    }
    v37 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), CFSTR("PadFrameToMinimumSize"));
    if (v37)
    {
      v38 = v37;
      v39 = CFGetTypeID(v37);
      if (v39 == CFNumberGetTypeID())
        CFNumberGetValue(v38, kCFNumberSInt32Type, a1 + 84);
    }
    v40 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E0CED630]);
    if (v40)
    {
      v41 = v40;
      v42 = CFGetTypeID(v40);
      if (v42 == CFNumberGetTypeID())
        CFNumberGetValue(v41, kCFNumberSInt32Type, a1 + 71);
    }
    v43 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E0CED5E8]);
    if (v43)
    {
      v44 = v43;
      v45 = CFGetTypeID(v43);
      if (v45 == CFNumberGetTypeID())
        CFNumberGetValue(v44, kCFNumberDoubleType, v17);
    }
    v46 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E0CED4B8]);
    if (v46)
    {
      v47 = v46;
      v48 = CFGetTypeID(v46);
      if (v48 == CFNumberGetTypeID())
        CFNumberGetValue(v47, kCFNumberSInt32Type, a1 + 76);
    }
    v49 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E0CED590]);
    if (v49)
    {
      v50 = v49;
      v51 = CFGetTypeID(v49);
      if (v51 == CFNumberGetTypeID())
        CFNumberGetValue(v50, kCFNumberSInt32Type, a1 + 77);
    }
    v52 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E0CED5F0]);
    if (v52)
    {
      v53 = v52;
      v54 = CFGetTypeID(v52);
      if (v54 == CFNumberGetTypeID())
        CFNumberGetValue(v53, kCFNumberSInt32Type, a1 + 78);
    }
    v55 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E0CED620]);
    if (v55)
    {
      v56 = v55;
      if (CFGetTypeID(v55))
      {
        if (CFBooleanGetTypeID())
          *((_BYTE *)a1 + 200) = CFEqual(v56, (CFTypeRef)*MEMORY[0x1E0C9AE50]) != 0;
      }
    }
    v57 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), CFSTR("MediaQueueDelayLimit"));
    if (v57)
    {
      v58 = v57;
      v59 = CFGetTypeID(v57);
      if (v59 == CFNumberGetTypeID())
        CFNumberGetValue(v58, kCFNumberSInt32Type, a1 + 181);
    }
    v60 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), CFSTR("MediaQueueDelay"));
    if (v60)
    {
      v61 = v60;
      v62 = CFGetTypeID(v60);
      if (v62 == CFNumberGetTypeID())
        CFNumberGetValue(v61, kCFNumberSInt32Type, a1 + 180);
    }
    v63 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E0CED608]);
    if (v63)
    {
      v64 = v63;
      v65 = CFGetTypeID(v63);
      if (v65 == CFNumberGetTypeID())
        CFNumberGetValue(v64, kCFNumberSInt32Type, a1 + 79);
    }
    v66 = (const __CFDictionary *)*((_QWORD *)a1 + 103);
    v67 = (const void *)*MEMORY[0x1E0CED4C0];
    v68 = -1;
    *(_DWORD *)buf = -1;
    v69 = (const __CFNumber *)CFDictionaryGetValue(v66, v67);
    if (v69)
    {
      v70 = v69;
      v71 = CFGetTypeID(v69);
      if (v71 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v70, kCFNumberSInt32Type, buf);
        v68 = *(_DWORD *)buf;
      }
      else
      {
        v68 = -1;
      }
    }
    a1[215] = v68;
    if (CFDictionaryContainsKey(*((CFDictionaryRef *)a1 + 103), CFSTR("HistCorr")))
    {
      v72 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), CFSTR("HistCorr"));
      if (v72)
      {
        v73 = v72;
        v74 = CFGetTypeID(v72);
        if (v74 == CFNumberGetTypeID())
          CFNumberGetValue(v73, kCFNumberFloatType, a1 + 179);
      }
    }
    else
    {
      a1[179] = 2139095039;
    }
    v75 = (const __CFArray *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), CFSTR("ResilienceNumBitsAddedArray"));
    if (v75)
    {
      v76 = v75;
      v77 = CFArrayGetTypeID();
      if (v77 == CFGetTypeID(v76))
      {
        v78 = CFArrayGetCount(v76);
        if (v78 >= 1)
        {
          v79 = v78;
          v80 = 0;
          v81 = (char *)(a1 + 43);
          do
          {
            v82 = (const __CFNumber *)CFArrayGetValueAtIndex(v76, v80);
            CFNumberGetValue(v82, kCFNumberSInt32Type, v81);
            ++v80;
            v81 += 4;
          }
          while (v79 != v80);
        }
      }
    }
    v83 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E0CED670]);
    v19 = v152;
    if (v83)
    {
      v84 = v83;
      v85 = CFGetTypeID(v83);
      if (v85 == CFDictionaryGetTypeID())
      {
        v86 = (const __CFNumber *)CFDictionaryGetValue(v84, (const void *)*MEMORY[0x1E0CA8D60]);
        if (v86)
        {
          v87 = v86;
          v88 = CFGetTypeID(v86);
          if (v88 == CFNumberGetTypeID())
            CFNumberGetValue(v87, kCFNumberSInt32Type, v18);
        }
        v89 = (const __CFNumber *)CFDictionaryGetValue(v84, (const void *)*MEMORY[0x1E0CA8D40]);
        if (v89)
        {
          v90 = v89;
          v91 = CFGetTypeID(v89);
          if (v91 == CFNumberGetTypeID())
            CFNumberGetValue(v90, kCFNumberSInt32Type, a1 + 86);
        }
        v92 = (const __CFNumber *)CFDictionaryGetValue(v84, (const void *)*MEMORY[0x1E0CA8D48]);
        if (v92)
        {
          v93 = v92;
          v94 = CFGetTypeID(v92);
          if (v94 == CFNumberGetTypeID())
            CFNumberGetValue(v93, kCFNumberSInt32Type, a1 + 87);
        }
        v95 = (const __CFNumber *)CFDictionaryGetValue(v84, (const void *)*MEMORY[0x1E0CA8D58]);
        if (v95)
        {
          v96 = v95;
          v97 = CFGetTypeID(v95);
          if (v97 == CFNumberGetTypeID())
            CFNumberGetValue(v96, kCFNumberSInt32Type, a1 + 88);
        }
      }
    }
    v98 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), CFSTR("FECPercentage"));
    if (v98)
    {
      v99 = v98;
      v100 = CFGetTypeID(v98);
      if (v100 == CFDictionaryGetTypeID())
      {
        v101 = (const __CFNumber *)CFDictionaryGetValue(v99, CFSTR("FECPercentageIFrame"));
        if (v101)
        {
          v102 = v101;
          v103 = CFGetTypeID(v101);
          v104 = v103 == CFNumberGetTypeID();
          v19 = v152;
          if (v104)
            CFNumberGetValue(v102, kCFNumberFloat64Type, a1 + 80);
        }
        v105 = (const __CFNumber *)CFDictionaryGetValue(v99, CFSTR("FECPercentagePFrame"));
        if (v105)
        {
          v106 = v105;
          v107 = CFGetTypeID(v105);
          if (v107 == CFNumberGetTypeID())
            CFNumberGetValue(v106, kCFNumberFloat64Type, a1 + 82);
        }
      }
    }
    v108 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), CFSTR("CameraFacingType"));
    if (v108)
    {
      v109 = v108;
      v110 = CFGetTypeID(v108);
      if (v110 == CFNumberGetTypeID())
        CFNumberGetValue(v109, kCFNumberSInt32Type, a1 + 174);
    }
    v111 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E0CED638]);
    if (v111)
    {
      v112 = v111;
      v113 = CFGetTypeID(v111);
      if (v113 == CFNumberGetTypeID())
        CFNumberGetValue(v112, kCFNumberSInt32Type, v19);
    }
    result = (CFTypeID)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E0CED640]);
    if (result)
    {
      v114 = (const __CFArray *)result;
      v115 = CFGetTypeID((CFTypeRef)result);
      result = CFArrayGetTypeID();
      if (v115 == result)
      {
        v116 = (const __CFNumber *)CFArrayGetValueAtIndex(v114, 0);
        if (v116)
        {
          v117 = v116;
          v118 = CFGetTypeID(v116);
          if (v118 == CFNumberGetTypeID())
            CFNumberGetValue(v117, kCFNumberIntType, a1 + 211);
        }
        v119 = (const __CFNumber *)CFArrayGetValueAtIndex(v114, 1);
        if (v119)
        {
          v120 = v119;
          v121 = CFGetTypeID(v119);
          if (v121 == CFNumberGetTypeID())
            CFNumberGetValue(v120, kCFNumberIntType, a1 + 212);
        }
        result = (CFTypeID)CFArrayGetValueAtIndex(v114, 2);
        if (result)
        {
          v122 = (const __CFNumber *)result;
          v123 = CFGetTypeID((CFTypeRef)result);
          result = CFNumberGetTypeID();
          if (v123 == result)
            result = CFNumberGetValue(v122, kCFNumberIntType, a1 + 213);
        }
      }
    }
    a7 = v153;
    a5 = v154;
    a3 = v151;
  }
  v124 = *a2;
  if (*a2)
    v125 = *((_DWORD *)a2 + 2);
  else
    v125 = 3000;
  v126 = *((double *)a1 + 1);
  v127 = 30.0;
  if (v126 > 0.0)
    v127 = *((double *)a1 + 1);
  v128 = (double)v125 / v127;
  v129 = *a3;
  if (!*a3)
  {
    v130 = v124 - *((_QWORD *)a1 + 101);
    v132 = v130 <= 0;
    v131 = v130 & ~(v130 >> 63);
    v129 = (uint64_t)v128;
    v132 = v132 && a4 <= 0;
    if (!v132)
      v129 = v131;
    *a3 = v129;
    v124 = *a2;
    *((_QWORD *)a1 + 101) = *a2;
    *((_QWORD *)a1 + 102) = v129;
  }
  if ((*((_DWORD *)a2 + 3) & 0x1D) == 1 && v129 >= 1)
  {
    *((_QWORD *)a1 + 98) = v124;
    v133 = *((_DWORD *)a2 + 2);
    a1[200] = v133;
    *((_QWORD *)a1 + 99) = v129;
  }
  else if (v126 <= 0.0)
  {
    v129 = *((_QWORD *)a1 + 99);
    v133 = a1[200];
  }
  else
  {
    v133 = (int)((double)(uint64_t)(v128 + 0.5) * v126 + 0.5);
    v134 = (uint64_t)(v128 * (double)a4);
    *((_QWORD *)a1 + 98) = v134;
    v129 = (uint64_t)(v128 * (double)(a4 + 1)) - v134;
    *((_QWORD *)a1 + 99) = v129;
    a1[200] = v133;
  }
  if (v133 < 2 * v129)
  {
    v135 = (double)v133 / v126;
LABEL_140:
    v136 = v126;
    *((float *)a1 + 22) = v136;
    v129 = (uint64_t)v135;
LABEL_141:
    *(_QWORD *)&a1[2 * (a4 % 5) + 24] = v129;
    goto LABEL_142;
  }
  v135 = (double)v133 / v126;
  if (v135 > (double)v129)
    goto LABEL_140;
  if (v129 >= 1)
  {
    v136 = (float)v133 / (float)v129;
    *((float *)a1 + 22) = v136;
    goto LABEL_141;
  }
  v136 = v126;
  *((float *)a1 + 22) = v136;
  if (v126 > 0.0)
  {
    v129 = (uint64_t)(3000.0 / v126);
    goto LABEL_141;
  }
LABEL_142:
  if (a4 >= 4)
    v137 = 4;
  else
    v137 = a4;
  v138 = __CFADD__(v137, 1);
  v139 = v137 + 1;
  if (!v138)
  {
    v140 = 0;
    v141 = 0;
    v142 = a1 + 24;
    v143 = v139;
    do
    {
      v141 += *(_QWORD *)&v142[-10 * (v140 / 5)];
      v142 += 2;
      ++v140;
      --v143;
    }
    while (v143);
    if (v141 > 0)
      v136 = (float)((float)v139 * (float)v133) / (float)v141;
  }
  *((float *)a1 + 23) = v136;
  *((_BYTE *)a1 + 140) = v15;
  a1[36] = 0;
  a1[41] = a6;
  v144 = a8;
  *((float *)a1 + 42) = v144;
  if (a8 > 2.22044605e-16 && (double)((*((_QWORD *)a1 + 98) - *((_QWORD *)a1 + 19)) / v133) >= a8
    || a6 >= 1 && a5 - a1[40] >= a6)
  {
    v15 = 1;
    *((_BYTE *)a1 + 140) = 1;
  }
  v145 = *a1;
  if (*a1 == 20 || v145 == 42)
  {
    if (a4 < 1 || a7 < 2)
      goto LABEL_169;
  }
  else if (a4 < 1 || a7 < 2 || v145 != 38)
  {
    goto LABEL_169;
  }
  if (v15)
  {
    if (*v19 < 1)
    {
      v15 = 1;
    }
    else
    {
      v15 = 0;
      *((_WORD *)a1 + 70) = 256;
    }
  }
LABEL_169:
  if (a9 > 2.22044605e-16 && (v146 = *((_QWORD *)a1 + 98), (double)(v146 - *((_QWORD *)a1 + 26)) / (double)v133 >= a9))
  {
    *((_BYTE *)a1 + 204) = 1;
  }
  else
  {
    if (!*((_BYTE *)a1 + 204))
      goto LABEL_175;
    v146 = *((_QWORD *)a1 + 98);
  }
  *((_QWORD *)a1 + 26) = v146;
LABEL_175:
  if (v15)
  {
    v147 = *((_QWORD *)a1 + 98);
    *((_QWORD *)a1 + 19) = v147;
    *((_QWORD *)a1 + 26) = v147;
    a1[40] = a5;
  }
  v148 = *((double *)a1 + 2);
  if (v148 > 0.0)
  {
    v149 = a1[8];
    if (v148 == 1.0)
    {
      v150 = a1 + 9;
      a1[10] = v149;
    }
    else
    {
      a1[9] = (int)(*((double *)a1 + 3) * (double)v149);
      v150 = a1 + 10;
    }
    *v150 = v149;
  }
  return result;
}

void sub_1B67ACB64(uint64_t a1, CVBufferRef buffer)
{
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  const void *v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const void *v9;
  CFTypeID v10;
  unsigned int Count;
  int v12;
  unint64_t v13;
  const void *v14;
  const void *v15;
  const void *v16;
  float32x4_t *v17;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v19;
  CFTypeID v20;
  unint64_t v21;
  const __CFDictionary *v22;
  _OWORD *v23;
  int v24;
  unint64_t v25;
  _OWORD *v26;
  uint64_t v27;
  CGSize v33;
  OSType PixelFormatType;
  const __CFDictionary *DescriptionWithPixelFormatType;
  const __CFNumber *v36;
  int IsSubsampled;
  size_t Width;
  size_t Height;
  char *BaseAddressOfPlane;
  int v41;
  unint64_t v42;
  int v43;
  unint64_t v44;
  unint64_t v45;
  unsigned int v46;
  int v47;
  float64x2_t v48;
  CGSize size;
  int32x2_t v50;
  int64x2_t v51;
  float64x2_t v52;
  int32x2_t v53;
  int32x2_t v54;
  int8x16_t v55;
  int8x16_t v56;
  int32x2_t v57;
  __int32 v58;
  char *v59;
  __int32 v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  char *v64;
  unsigned int v65;
  int i;
  uint64_t v67;
  int v68;
  uint64x2_t v69;
  int32x2_t v70;
  int64x2_t v71;
  float64x2_t v72;
  double v73;
  int32x2_t v74;
  int32x2_t v75;
  int8x16_t v76;
  double v77;
  float64x2_t v78;
  int8x16_t v79;
  char *v80;
  int v81;
  uint64_t v82;
  int v83;
  int j;
  uint64_t v85;
  int v86;
  uint64x2_t v87;
  float64x2_t v88;
  CGSize v89;
  int32x2_t v90;
  int64x2_t v91;
  float64x2_t v92;
  int32x2_t v93;
  int32x2_t v94;
  int64x2_t v95;
  int v96;
  int8x16_t v97;
  int32x2_t v98;
  char *v99;
  uint64_t v100;
  int v101;
  int k;
  uint64_t v103;
  float64x2_t v104;
  int32x2_t v105;
  int64x2_t v106;
  float64x2_t v107;
  int32x2_t v108;
  int32x2_t v109;
  int8x16_t v110;
  int8x16_t v111;
  int v112;
  float64x2_t v113;
  CGSize v114;
  int32x2_t v115;
  int64x2_t v116;
  float64x2_t v117;
  int32x2_t v118;
  int32x2_t v119;
  int32x2_t v120;
  int8x16_t v121;
  int8x16_t v122;
  int32x2_t v123;
  __int32 v124;
  __int32 v125;
  __int32 v126;
  char *v127;
  char *v128;
  int v129;
  char *v130;
  int v131;
  __int32 v132;
  float64x2_t v133;
  int32x2_t v134;
  int64x2_t v135;
  float64x2_t v136;
  int32x2_t v137;
  int32x2_t v138;
  int32x2_t v139;
  int8x16_t v140;
  int8x16_t v141;
  int v142;
  const __CFDictionary *v143;
  void *v144;
  int BytesPerRowOfPlane;
  char *valuePtr;
  const void *key;
  void *keya[2];
  CGRect rect;
  void *value;
  int32x2_t v151;
  int32x2_t v152;
  char *v153;
  int v154;
  int v155;
  int v156[3];

  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 652) = 0u;
  *(_OWORD *)(a1 + 668) = 0u;
  *(_OWORD *)(a1 + 680) = 0u;
  *(_QWORD *)(a1 + 664) = 0x3FF0000000000000;
  value = 0;
  v4 = CVBufferCopyAttachments(buffer, kCVAttachmentMode_ShouldPropagate);
  if (v4)
  {
    v5 = v4;
    v6 = (const void *)*MEMORY[0x1E0D04138];
    if (!CFDictionaryContainsKey(v4, (const void *)*MEMORY[0x1E0D04138]))
    {
LABEL_121:
      CFRelease(v5);
      return;
    }
    v143 = v5;
    v7 = (const __CFDictionary *)CFDictionaryGetValue(v5, v6);
    if (!v7)
      goto LABEL_30;
    v8 = v7;
    v9 = CFDictionaryGetValue(v7, (const void *)*MEMORY[0x1E0D05350]);
    if (!v9)
    {
      if (qword_1EF138F48 != -1)
        dispatch_once(&qword_1EF138F48, &unk_1E6A16DA0);
      if ((byte_1EF138F50 & 1) != 0)
        goto LABEL_30;
      v22 = (const __CFDictionary *)CFDictionaryGetValue(v8, CFSTR("MetadataCVA"));
      if (!v22)
        goto LABEL_30;
      v9 = CFDictionaryGetValue(v22, (const void *)*MEMORY[0x1E0CFCCF0]);
      if (!v9)
        goto LABEL_30;
    }
    v10 = CFGetTypeID(v9);
    if (v10 == CFArrayGetTypeID())
    {
      Count = CFArrayGetCount((CFArrayRef)v9);
      if (Count >= 5)
        v12 = 5;
      else
        v12 = Count;
      *(_DWORD *)(a1 + 500) = v12;
      if (!v12)
      {
        if (*(float *)(a1 + 88) <= 30.0)
          goto LABEL_120;
        goto LABEL_37;
      }
      v13 = 0;
      v14 = (const void *)*MEMORY[0x1E0D05358];
      key = (const void *)*MEMORY[0x1E0D05368];
      v15 = (const void *)*MEMORY[0x1E0D05370];
      v16 = (const void *)*MEMORY[0x1E0D05360];
      v17 = (float32x4_t *)(a1 + 364);
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v9, v13);
        if (ValueAtIndex)
        {
          v19 = ValueAtIndex;
          v20 = CFGetTypeID(ValueAtIndex);
          if (v20 == CFDictionaryGetTypeID())
          {
            if (CFDictionaryGetValueIfPresent(v19, v14, (const void **)&value))
              CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, (char *)&v17[-1].u64[1] + 4);
            if (!v13)
            {
              if (CFDictionaryGetValueIfPresent(v19, key, (const void **)&value))
                CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, (void *)(a1 + 380));
              if (CFDictionaryGetValueIfPresent(v19, v15, (const void **)&value))
                CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, (void *)(a1 + 384));
            }
            if (CFDictionaryGetValueIfPresent(v19, v16, (const void **)&value)
              && CGRectMakeWithDictionaryRepresentation((CFDictionaryRef)value, &rect))
            {
              *v17 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64((float64x2_t)rect.origin), (float64x2_t)rect.size);
            }
          }
        }
        ++v13;
        v21 = *(unsigned int *)(a1 + 500);
        v17 = (float32x4_t *)((char *)v17 + 28);
      }
      while (v13 < v21);
    }
    else
    {
LABEL_30:
      LODWORD(v21) = *(_DWORD *)(a1 + 500);
    }
    if (*(float *)(a1 + 88) <= 30.0)
    {
LABEL_41:
      if ((_DWORD)v21)
        goto LABEL_42;
LABEL_120:
      v5 = v143;
      goto LABEL_121;
    }
    if ((_DWORD)v21)
    {
      *(_DWORD *)(a1 + 644) = v21;
      v21 = v21;
      v23 = (_OWORD *)(a1 + 504);
      do
      {
        *v23 = *(v23 - 9);
        *(_OWORD *)((char *)v23 + 12) = *(_OWORD *)((char *)v23 - 132);
        v23 = (_OWORD *)((char *)v23 + 28);
        --v21;
      }
      while (v21);
LABEL_42:
      if (*(_DWORD *)(a1 + 836))
      {
        v27 = 0;
        v144 = (void *)*MEMORY[0x1E0CA90F0];
        __asm { FMOV            V0.2D, #-1.0 }
        *(_OWORD *)keya = _Q0;
        while (1)
        {
          v33 = (CGSize)vcvtq_f64_f32(*(float32x2_t *)(a1 + 28 * v27 + 372));
          rect.origin = (CGPoint)vcvtq_f64_f32(*(float32x2_t *)(a1 + 28 * v27 + 364));
          rect.size = v33;
          if (CVPixelBufferLockBaseAddress(buffer, 0))
            goto LABEL_45;
          PixelFormatType = CVPixelBufferGetPixelFormatType(buffer);
          DescriptionWithPixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
          if (!DescriptionWithPixelFormatType)
            goto LABEL_45;
          v36 = (const __CFNumber *)CFDictionaryGetValue(DescriptionWithPixelFormatType, v144);
          if (!v36)
            goto LABEL_45;
          v156[0] = 0;
          CFNumberGetValue(v36, kCFNumberSInt32Type, v156);
          IsSubsampled = CVPixelFormatTypeIsSubsampled();
          Width = CVPixelBufferGetWidth(buffer);
          Height = CVPixelBufferGetHeight(buffer);
          valuePtr = (char *)CVPixelBufferGetBaseAddressOfPlane(buffer, 0);
          BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(buffer, 1uLL);
          BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(buffer, 0);
          v41 = CVPixelBufferGetBytesPerRowOfPlane(buffer, 1uLL);
          v42 = Width;
          v43 = IsSubsampled;
          v44 = Width << (IsSubsampled == 0);
          v45 = Height >> (IsSubsampled != 0);
          if (IsSubsampled)
            v46 = 1;
          else
            v46 = 2;
          if ((PixelFormatType & 0xFFFFFFEF) == 0x34323066)
          {
            v47 = 0;
            v48.f64[0] = (double)v44 * 0.5;
            v48.f64[1] = (double)v45;
            size = rect.size;
            v50 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.origin, v48))), 0);
            v51.i64[0] = v50.u32[0];
            v51.i64[1] = v50.u32[1];
            v52 = vcvtq_f64_s64(v51);
            v53 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v48, v52), (int8x16_t)v52, (int8x16_t)vaddq_f64(v48, *(float64x2_t *)keya))));
            *(int32x2_t *)&v52.f64[0] = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.size, v48))), 0);
            v54 = vadd_s32(*(int32x2_t *)&v52.f64[0], v53);
            v51.i64[0] = v54.i32[0];
            v51.i64[1] = v54.i32[1];
            v55 = (int8x16_t)vcgeq_f64(v48, vcvtq_f64_s64(v51));
            v51.i64[0] = LODWORD(v52.f64[0]);
            v51.i64[1] = HIDWORD(v52.f64[0]);
            v56 = (int8x16_t)vcvtq_f64_s64(v51);
            v51.i64[0] = v53.i32[0];
            v51.i64[1] = v53.i32[1];
            v57 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8(v55, v56, (int8x16_t)vsubq_f64(v48, vcvtq_f64_s64(v51)))));
            v58 = 2 * v53.i32[0];
            v59 = &BaseAddressOfPlane[(v53.i32[1] * v41 + 2 * v53.i32[0]) & 0x1FFFFFFF];
            v60 = v57.i32[0];
            do
            {
              if (v57.i32[0] >= 1)
              {
                v61 = 0;
                do
                  *(_WORD *)&v59[2 * v61++] = -32640;
                while (v57.i32[0] != (_DWORD)v61);
              }
              ++v47;
              v59 += v41;
            }
            while (v47 != v46);
            if ((int)(v57.i32[1] - 2 * v46) > 0)
            {
              v62 = 0;
              do
              {
                v63 = 0;
                do
                  *(_WORD *)&v59[2 * v63++] = -32640;
                while (v46 != (_DWORD)v63);
                v64 = &v59[2 * v57.i32[0] + -2 * v46];
                v65 = v46;
                do
                {
                  *(_WORD *)v64 = -32640;
                  v64 += 2;
                  --v65;
                }
                while (v65);
                ++v62;
                v59 += v41;
              }
              while (v62 != v57.i32[1] - 2 * v46);
            }
            for (i = 0; i != v46; ++i)
            {
              if (v57.i32[0] >= 1)
              {
                v67 = 0;
                do
                  *(_WORD *)&v59[2 * v67++] = -32640;
                while (v57.i32[0] != (_DWORD)v67);
              }
              v59 += v41;
            }
            v68 = 0;
            v69.i64[0] = Width;
            v69.i64[1] = Height;
            v78 = vcvtq_f64_u64(v69);
            v70 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.origin, v78))), 0);
            v71.i64[0] = v70.u32[0];
            v71.i64[1] = v70.u32[1];
            v72 = vcvtq_f64_s64(v71);
            v73 = COERCE_DOUBLE(vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v78, v72), (int8x16_t)v72, (int8x16_t)vaddq_f64(v78, *(float64x2_t *)keya)))));
            v74 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)size, v78))), 0);
            v75 = vadd_s32(v74, *(int32x2_t *)&v73);
            v71.i64[0] = v75.i32[0];
            v71.i64[1] = v75.i32[1];
            v79 = (int8x16_t)vcgeq_f64(v78, vcvtq_f64_s64(v71));
            v71.i64[0] = v74.u32[0];
            v71.i64[1] = v74.u32[1];
            v76 = (int8x16_t)vcvtq_f64_s64(v71);
            v71.i64[0] = SLODWORD(v73);
            v71.i64[1] = SHIDWORD(v73);
            v77 = COERCE_DOUBLE(vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8(v79, v76, (int8x16_t)vsubq_f64(v78, vcvtq_f64_s64(v71))))));
            HIDWORD(v78.f64[0]) = HIDWORD(v73);
            v79.i32[1] = HIDWORD(v77);
            if (IsSubsampled)
            {
              v79.i32[0] = 2 * v60;
              v77 = *(double *)v79.i64;
            }
            else
            {
              v78.f64[0] = v73;
              v58 = LODWORD(v73);
            }
            v80 = &valuePtr[(v58 + HIDWORD(v78.f64[0]) * BytesPerRowOfPlane) & 0x1FFFFFFF];
            if (SLODWORD(v77) <= 1)
              v81 = 1;
            else
              v81 = LODWORD(v77);
            do
            {
              if (SLODWORD(v77) >= 1)
              {
                v82 = 0;
                do
                  v80[v82++] = -21;
                while (v81 != (_DWORD)v82);
              }
              ++v68;
              v80 += BytesPerRowOfPlane;
            }
            while (v68 != 2);
            if (SHIDWORD(v77) >= 5)
            {
              v83 = HIDWORD(v77) - 4;
              do
              {
                *(_WORD *)v80 = -5141;
                *(_WORD *)&v80[SLODWORD(v77) - 2] = -5141;
                v80 += BytesPerRowOfPlane;
                --v83;
              }
              while (v83);
            }
            for (j = 0; j != 2; ++j)
            {
              if (SLODWORD(v77) >= 1)
              {
                v85 = 0;
                do
                  v80[v85++] = -21;
                while (v81 != (_DWORD)v85);
              }
              v80 += BytesPerRowOfPlane;
            }
            goto LABEL_45;
          }
          if (PixelFormatType == 1882468912)
            break;
          if (PixelFormatType == 2016686640)
          {
            v86 = 0;
            v87.i64[0] = Width;
            v87.i64[1] = Height;
            v88 = vcvtq_f64_u64(v87);
            v89 = rect.size;
            v90 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.origin, v88))), 0);
            v91.i64[0] = v90.u32[0];
            v91.i64[1] = v90.u32[1];
            v92 = vcvtq_f64_s64(v91);
            *(int32x2_t *)&v92.f64[0] = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v88, v92), (int8x16_t)v92, (int8x16_t)vaddq_f64(v88, *(float64x2_t *)keya))));
            v93 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.size, v88))), 0);
            v94 = vadd_s32(v93, *(int32x2_t *)&v92.f64[0]);
            v91.i64[0] = SLODWORD(v92.f64[0]);
            v91.i64[1] = SHIDWORD(v92.f64[0]);
            v95 = v91;
            v96 = HIDWORD(v92.f64[0]) * BytesPerRowOfPlane + 2 * LODWORD(v92.f64[0]);
            v91.i64[0] = v94.i32[0];
            v91.i64[1] = v94.i32[1];
            v97 = (int8x16_t)vcgeq_f64(v88, vcvtq_f64_s64(v91));
            v91.i64[0] = v93.u32[0];
            v91.i64[1] = v93.u32[1];
            v98 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8(v97, (int8x16_t)vcvtq_f64_s64(v91), (int8x16_t)vsubq_f64(v88, vcvtq_f64_s64(v95)))));
            v154 = 0;
            v99 = &valuePtr[v96 & 0x1FFFFFFF];
            do
            {
              if (v98.i32[0] >= 1)
              {
                v100 = 0;
                do
                  *(_WORD *)&v99[2 * v100++] = 235;
                while (v98.i32[0] != (_DWORD)v100);
              }
              ++v86;
              v99 += BytesPerRowOfPlane;
            }
            while (v86 != 2);
            if (v98.i32[1] >= 5)
            {
              v101 = v98.i32[1] - 4;
              do
              {
                *(_DWORD *)v99 = 15401195;
                *(_DWORD *)&v99[2 * v98.i32[0] - 4] = 15401195;
                v99 += BytesPerRowOfPlane;
                --v101;
              }
              while (v101);
            }
            for (k = 0; k != 2; ++k)
            {
              if (v98.i32[0] >= 1)
              {
                v103 = 0;
                do
                  *(_WORD *)&v99[2 * v103++] = 235;
                while (v98.i32[0] != (_DWORD)v103);
              }
              v99 += BytesPerRowOfPlane;
            }
            v104.f64[0] = (double)v44 * 0.5;
            v104.f64[1] = (double)v45;
            v105 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.origin, v104))), 0);
            v106.i64[0] = v105.u32[0];
            v106.i64[1] = v105.u32[1];
            v107 = vcvtq_f64_s64(v106);
            *(int32x2_t *)&v107.f64[0] = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v104, v107), (int8x16_t)v107, (int8x16_t)vaddq_f64(v104, *(float64x2_t *)keya))));
            v108 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)v89, v104))), 0);
            v109 = vadd_s32(v108, *(int32x2_t *)&v107.f64[0]);
            v106.i64[0] = v109.i32[0];
            v106.i64[1] = v109.i32[1];
            v110 = (int8x16_t)vcgeq_f64(v104, vcvtq_f64_s64(v106));
            v106.i64[0] = v108.u32[0];
            v106.i64[1] = v108.u32[1];
            v111 = (int8x16_t)vcvtq_f64_s64(v106);
            v106.i64[0] = SLODWORD(v107.f64[0]);
            v106.i64[1] = SHIDWORD(v107.f64[0]);
            v151 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8(v110, v111, (int8x16_t)vsubq_f64(v104, vcvtq_f64_s64(v106)))));
            v152 = *(int32x2_t *)&v107.f64[0];
            v153 = &BaseAddressOfPlane[(HIDWORD(v107.f64[0]) * v41 + 4 * LODWORD(v107.f64[0])) & 0x1FFFFFFF];
            v155 = v41;
            v112 = 8388736;
LABEL_118:
            sub_1B67D58DC((uint64_t *)&v153, (int *)&v151, v112, v46);
          }
LABEL_45:
          CVPixelBufferUnlockBaseAddress(buffer, 1uLL);
          if (++v27 >= (unint64_t)*(unsigned int *)(a1 + 500))
            goto LABEL_120;
        }
        v113.f64[0] = (double)v44 / 6.0;
        v113.f64[1] = (double)v45;
        v114 = rect.size;
        v115 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.origin, v113))), 0);
        v116.i64[0] = v115.u32[0];
        v116.i64[1] = v115.u32[1];
        v117 = vcvtq_f64_s64(v116);
        v118 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v113, v117), (int8x16_t)v117, (int8x16_t)vaddq_f64(v113, *(float64x2_t *)keya))));
        v119 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.size, v113))), 0);
        v120 = vadd_s32(v119, v118);
        v116.i64[0] = v120.i32[0];
        v116.i64[1] = v120.i32[1];
        v121 = (int8x16_t)vcgeq_f64(v113, vcvtq_f64_s64(v116));
        v116.i64[0] = v119.u32[0];
        v116.i64[1] = v119.u32[1];
        v122 = (int8x16_t)vcvtq_f64_s64(v116);
        v116.i64[0] = v118.i32[0];
        v116.i64[1] = v118.i32[1];
        v123 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8(v121, v122, (int8x16_t)vsubq_f64(v113, vcvtq_f64_s64(v116)))));
        v124 = v118.i32[0];
        v154 = 0;
        v155 = v41;
        v125 = v123.i32[0];
        v126 = v123.i32[0];
        v127 = &BaseAddressOfPlane[(v118.i32[1] * v41 + 8 * v118.i32[0]) & 0x1FFFFFFF];
        if (v123.i32[0] >= 1)
        {
          do
          {
            *(_QWORD *)v127 = 0x802008008020080;
            v127 += 8;
            --v126;
          }
          while (v126);
        }
        v128 = &BaseAddressOfPlane[((v118.i32[1] * v41 + 8 * v118.i32[0]) & 0x1FFFFFFF) + v41];
        v153 = v128;
        v129 = v123.i32[1] - 2;
        if (v123.i32[1] <= 2)
        {
          v131 = BytesPerRowOfPlane;
          v130 = valuePtr;
        }
        else
        {
          v131 = BytesPerRowOfPlane;
          v130 = valuePtr;
          do
          {
            *(_QWORD *)v128 = 0x802008008020080;
            *(_QWORD *)&v128[8 * v123.i32[0] - 8] = 0x802008008020080;
            v128 += v41;
            --v129;
          }
          while (v129);
        }
        v132 = v123.i32[0];
        if (v123.i32[0] >= 1)
        {
          do
          {
            *(_QWORD *)v128 = 0x802008008020080;
            v128 += 8;
            --v132;
          }
          while (v132);
        }
        v133.f64[0] = (double)v42 / 3.0;
        v133.f64[1] = (double)Height;
        v134 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.origin, v133))), 0);
        v135.i64[0] = v134.u32[0];
        v135.i64[1] = v134.u32[1];
        v136 = vcvtq_f64_s64(v135);
        v137 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v133, v136), (int8x16_t)v136, (int8x16_t)vaddq_f64(v133, *(float64x2_t *)keya))));
        v138 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)v114, v133))), 0);
        v139 = vadd_s32(v138, v137);
        v135.i64[0] = v139.i32[0];
        v135.i64[1] = v139.i32[1];
        v140 = (int8x16_t)vcgeq_f64(v133, vcvtq_f64_s64(v135));
        v135.i64[0] = v138.u32[0];
        v135.i64[1] = v138.u32[1];
        v141 = (int8x16_t)vcvtq_f64_s64(v135);
        v135.i64[0] = v137.i32[0];
        v135.i64[1] = v137.i32[1];
        v151 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8(v140, v141, (int8x16_t)vsubq_f64(v133, vcvtq_f64_s64(v135)))));
        v152 = v137;
        if (v43)
        {
          v142 = 2 * v124;
          v152.i32[0] = v142;
          v151.i32[0] = 2 * v125;
        }
        else
        {
          v142 = v137.i32[0];
        }
        v153 = &v130[(v137.i32[1] * v131 + 4 * v142) & 0x1FFFFFFF];
        v155 = v131;
        v112 = 246656235;
        v46 = 2;
        goto LABEL_118;
      }
      goto LABEL_120;
    }
LABEL_37:
    v24 = *(_DWORD *)(a1 + 644);
    *(_DWORD *)(a1 + 500) = v24;
    *(_DWORD *)(a1 + 644) = 0;
    if (!v24)
      goto LABEL_120;
    v25 = 0;
    v26 = (_OWORD *)(a1 + 360);
    do
    {
      *v26 = v26[9];
      *(_OWORD *)((char *)v26 + 12) = *(_OWORD *)((char *)v26 + 156);
      ++v25;
      v26 = (_OWORD *)((char *)v26 + 28);
    }
    while (v25 < *(unsigned int *)(a1 + 500));
    LODWORD(v21) = *(_DWORD *)(a1 + 500);
    goto LABEL_41;
  }
}

void sub_1B67AD6F4()
{
  if (!*MEMORY[0x1E0CFCCF0])
    byte_1EF138F50 = 1;
}

uint64_t sub_1B67AD728(_QWORD *a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  int8x16_t v5;
  int64x2_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int v10;
  unsigned __int8 *v11;
  int v12;

  v2 = a1[1];
  v3 = a1[4];
  if (v2 + 15 >= v3)
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    do
    {
      v5 = *(int8x16_t *)(a1[2] + v2);
      *(int8x16_t *)(a2 + v4) = v5;
      v6 = (int64x2_t)vceqzq_s8(v5);
      if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v6, 1), (int8x16_t)v6).u64[0])
      {
        v7 = a1[2];
        do
        {
          v8 = v2;
          v9 = v4++;
          ++v2;
        }
        while (*(_BYTE *)(v7 + v8));
        if (v8 + 2 < a1[4])
        {
          v10 = *(unsigned __int8 *)(v7 + v2);
          if ((*(unsigned __int8 *)(v7 + v8 + 2) | (v10 << 8)) == 3)
          {
            *(_BYTE *)(a2 + v4) = v10;
            v2 = v8 + 3;
            v4 = v9 + 2;
          }
        }
      }
      else
      {
        v2 += 16;
        v4 += 16;
      }
      v3 = a1[4];
    }
    while (v2 + 15 < v3);
  }
  while (v2 < v3)
  {
    v11 = (unsigned __int8 *)(a1[2] + v2);
    v12 = *v11;
    if (v2 + 2 < v3 && ((v12 << 16) | (v11[1] << 8) | v11[2]) == 3)
    {
      *(_BYTE *)(a2 + v4++) = v12;
      LOBYTE(v12) = *(_BYTE *)(v2 + a1[2] + 1);
      v2 += 2;
    }
    *(_BYTE *)(a2 + v4++) = v12;
    ++v2;
    v3 = a1[4];
  }
  return v4;
}

uint64_t sub_1B67AD840(char *a1, int a2, int8x16_t *a3, uint64_t a4, uint64_t a5)
{
  size_t v9;
  int8x16_t *v10;
  uint64_t v11;
  __int8 v12;
  unint64_t v13;
  int8x16_t v14;
  uint64_t v15;
  unint64_t v17;
  unsigned __int8 *v18;
  int v19;
  unsigned int v20;
  int v21;
  int v22;
  unsigned int v23;

  v9 = (a2 + 2);
  bzero(a1, v9);
  a1[v9] = 1;
  v10 = (int8x16_t *)&a1[v9 + 1];
  if (a5)
  {
    v11 = a5;
    do
    {
      v12 = a3->i8[0];
      a3 = (int8x16_t *)((char *)a3 + 1);
      v10->i8[0] = v12;
      v10 = (int8x16_t *)((char *)v10 + 1);
      --v11;
    }
    while (v11);
  }
  v13 = a4 - a5;
  if ((unint64_t)(a4 - a5) < 0x10)
    goto LABEL_22;
  while (1)
  {
    v14 = *a3;
    *v10 = *a3;
    if (!vaddvq_s32((int32x4_t)vceqzq_s8(v14)))
    {
      ++v10;
      ++a3;
      v13 -= 16;
      goto LABEL_21;
    }
    v15 = 0;
    while (v10->u8[v15++])
      ;
    v10 = (int8x16_t *)((char *)v10 + v15);
    v17 = v13 - v15;
    if (!v17)
      return (char *)v10 - a1;
    v18 = &a3->u8[v15];
    v19 = 1;
    while (v19 != 2)
    {
      v19 = 2;
LABEL_14:
      v21 = *v18;
      v10->i8[0] = v21;
      v10 = (int8x16_t *)((char *)v10 + 1);
      if (v21)
      {
        a3 = (int8x16_t *)(v18 + 1);
        goto LABEL_20;
      }
      ++v18;
      if (!--v17)
        return (char *)v10 - a1;
    }
    v20 = *v18;
    if (v20 < 4)
    {
      v10->i8[0] = 3;
      v10 = (int8x16_t *)((char *)v10 + 1);
      v19 = 1;
      goto LABEL_14;
    }
    a3 = (int8x16_t *)(v18 + 1);
    v10->i8[0] = v20;
    v10 = (int8x16_t *)((char *)v10 + 1);
LABEL_20:
    v13 = v17 - 1;
LABEL_21:
    if (v13 <= 0xF)
    {
LABEL_22:
      if (v13)
      {
        v22 = 0;
        do
        {
          v23 = a3->u8[0];
          if (v22 == 2)
          {
            if (v23 > 3)
            {
              v22 = 2;
            }
            else
            {
              v22 = 0;
              v10->i8[0] = 3;
              v10 = (int8x16_t *)((char *)v10 + 1);
              v23 = a3->u8[0];
            }
          }
          if (v23)
            v22 = 0;
          else
            ++v22;
          a3 = (int8x16_t *)((char *)a3 + 1);
          v10->i8[0] = v23;
          v10 = (int8x16_t *)((char *)v10 + 1);
          --v13;
        }
        while (v13);
      }
      return (char *)v10 - a1;
    }
  }
}

unint64_t sub_1B67AD9B8(uint64_t *a1)
{
  unint64_t v2;
  int v3;
  char v4;
  uint64_t v5;
  int v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t i;
  int8x16_t v11;
  int8x16_t v12;
  int8x16_t *v13;
  uint64_t v14;
  int8x16_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t *v23;
  uint64_t v24;
  int8x16_t v25;
  unint64_t v26;

  v2 = *((unsigned int *)a1 + 70);
  v3 = *((_DWORD *)a1 + 69);
  if (*((_BYTE *)a1 + 284) == 8)
    v4 = 3;
  else
    v4 = 2;
  v5 = (*(uint64_t (**)(uint64_t *, _QWORD))(*a1 + 32))(a1, 0);
  v6 = v3 / 16;
  if ((int)v2 < 8)
  {
    v7 = 0;
  }
  else
  {
    v7 = 0;
    v8 = a1[14] >> v4;
    v9 = v5 + 56 * v8 + 16;
    for (i = 7; i < v2; i += 16)
    {
      v11 = 0uLL;
      v12 = 0uLL;
      if (v3 >= 32)
      {
        v13 = (int8x16_t *)v9;
        v14 = v6 >> 1;
        do
        {
          v12 = veorq_s8(v13[-1], v12);
          v11 = veorq_s8(*v13, v11);
          v13 += 2;
          --v14;
        }
        while (v14);
      }
      if ((v6 & 1) != 0)
        v12 = veorq_s8(*(int8x16_t *)(v5 + 8 * v8 * i + 8 * (2 * v6 - 2)), v12);
      v15 = veorq_s8(v12, v11);
      v7 ^= *(_QWORD *)&veor_s8(*(int8x8_t *)v15.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL));
      v9 += v8 << 7;
    }
  }
  v16 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 32))(a1, 1);
  if ((int)v2 < 16)
  {
    v17 = 0;
  }
  else
  {
    v17 = 0;
    v18 = a1[15] >> v4;
    v19 = v16 + 56 * v18 + 16;
    v20 = 7;
    do
    {
      v21 = 0uLL;
      v22 = 0uLL;
      if (v3 >= 32)
      {
        v23 = (int8x16_t *)v19;
        v24 = v6 >> 1;
        do
        {
          v22 = veorq_s8(v23[-1], v22);
          v21 = veorq_s8(*v23, v21);
          v23 += 2;
          --v24;
        }
        while (v24);
      }
      if ((v6 & 1) != 0)
        v22 = veorq_s8(*(int8x16_t *)(v16 + 8 * v18 * v20 + 8 * (2 * v6 - 2)), v22);
      v25 = veorq_s8(v22, v21);
      v17 ^= *(_QWORD *)&veor_s8(*(int8x8_t *)v25.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL));
      v20 += 8;
      v19 += v18 << 6;
    }
    while (v20 < v2 >> 1);
  }
  v26 = v17 ^ HIDWORD(v17);
  return ((unsigned __int16)(WORD1(v26) ^ v26) ^ (unsigned __int16)((WORD1(v26) ^ (unsigned __int16)v26) << 8)) & 0xFF00 | (((v7 ^ HIDWORD(v7)) >> 16) ^ v7 ^ BYTE4(v7)) ^ ((((v7 ^ HIDWORD(v7)) >> 16) ^ (unsigned __int16)(v7 ^ WORD2(v7))) >> 8);
}

uint64_t sub_1B67ADBCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unsigned __int16 v7;
  uint64_t v12;
  char *v13;
  char v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t *v22;
  uint64_t v23;
  int8x16_t v24;
  uint64_t v25;
  char v26;
  char v27;
  _QWORD v29[2];
  int v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v35 = a5;
  v36 = a7;
  v34 = a4;
  v39 = *MEMORY[0x1E0C80C00];
  v7 = (unsigned __int16)off_1EF1391B8;
  if (off_1EF1391B8)
  {
    v29[1] = v29;
    v37 = 0;
    v38 = 0;
    MEMORY[0x1E0C80A78]();
    v13 = (char *)v29 - v12;
    v14 = 0;
    v15 = 0;
    v31 = (char *)&v29[2] - v12;
    v16 = 1;
    do
    {
      v30 = v16;
      if (*(int *)(a3 + 4 * v15) >= 8)
      {
        v17 = *(_DWORD *)(a2 + 4 * v15);
        v18 = (*(_DWORD *)(a6 + 4 * v15) + 7);
        v32 = 2 * (v17 >> 4) - 2;
        v33 = (v17 >> 4) >> 1;
        do
        {
          off_1EF1391B8(v13, *(_QWORD *)(a1 + 8 * v15), v18, *(unsigned int *)(a2 + 4 * v15), *(unsigned int *)(v34 + 4 * v15), v36, v14 & 1);
          v19 = *(int *)(v35 + 4 * v15);
          v20 = 0uLL;
          v21 = 0uLL;
          if (v17 >= 32)
          {
            v22 = (int8x16_t *)&v31[v19];
            v23 = v33;
            do
            {
              v21 = veorq_s8(v22[-1], v21);
              v20 = veorq_s8(*v22, v20);
              v22 += 2;
              --v23;
            }
            while (v23);
          }
          if ((v17 & 0x10) != 0)
            v21 = veorq_s8(*(int8x16_t *)&v13[8 * v32 + v19], v21);
          v24 = veorq_s8(v21, v20);
          *(&v37 + v15) ^= *(_QWORD *)&veor_s8(*(int8x8_t *)v24.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL));
          v18 = (dword_1B69202AC[v15] + v18);
        }
        while ((int)v18 < *(_DWORD *)(a6 + 4 * v15) + *(_DWORD *)(a3 + 4 * v15));
      }
      v16 = 0;
      v14 = 1;
      v15 = 1;
    }
    while ((v30 & 1) != 0);
    v25 = 0;
    v26 = 1;
    do
    {
      v27 = v26;
      *(&v37 + v25) = (*(&v37 + v25) ^ HIDWORD(*(&v37 + v25)) ^ ((*(&v37 + v25) ^ HIDWORD(*(&v37 + v25))) >> 16)) ^ (((unsigned __int16)(*(&v37 + v25) ^ HIDWORD(*(&v37 + v25))) ^ ((*(&v37 + v25) ^ HIDWORD(*(&v37 + v25))) >> 16)) >> 8);
      v25 = 1;
      v26 = 0;
    }
    while ((v27 & 1) != 0);
    return (unsigned __int16)(v37 | ((_WORD)v38 << 8));
  }
  return v7;
}

uint64_t sub_1B67ADE0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int8x16_t *v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  _DWORD *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  int8x16x4_t *v29;
  uint64_t v30;
  uint64_t v31;
  int8x16_t *v32;
  int v33;
  int8x16_t v34;
  int8x16_t v35;
  int8x16_t v36;
  int8x16_t *v37;
  int v38;
  uint64_t v39;
  int8x16_t v40;
  int8x16_t v41;
  int8x16_t *v42;
  uint64_t v43;
  int8x16_t v44;
  uint64_t v45;
  char v46;
  char v47;
  _QWORD v49[2];
  int v50;
  char *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  v54 = a1;
  v55 = a4;
  v49[1] = v49;
  v59 = *MEMORY[0x1E0C80C00];
  v57 = 0;
  v58 = 0;
  MEMORY[0x1E0C80A78]();
  v9 = (int8x16_t *)((char *)v49 - v8);
  v10 = 0;
  v51 = (char *)&v49[2] - v8;
  v11 = 1;
  do
  {
    v50 = v11;
    if (*(int *)(v5 + 4 * v10) >= 8)
    {
      v12 = *(_DWORD *)(v7 + 4 * v10) + 7;
      v13 = *(_DWORD *)(v4 + 4 * v10);
      v52 = 2 * (v13 >> 4) - 2;
      v53 = (v13 >> 4) >> 1;
      v14 = 264;
      if ((v50 & 1) != 0)
        v14 = 0;
      v15 = (_DWORD *)((char *)&unk_1B692B0D0 + v14);
      v16 = v15[1];
      v17 = v15[2];
      v18 = v15[3] / (v17 * v16);
      v19 = v18 * v16;
      v20 = 8 * v18;
      v56 = v15 + 5;
      v21 = v16 / 8;
      v22 = dword_1B69202AC[v10];
      while (1)
      {
        v23 = *(_DWORD *)(v4 + 4 * v10);
        if (v23 >= 1)
          break;
LABEL_26:
        v39 = *(int *)(v6 + 4 * v10);
        v40 = 0uLL;
        v41 = 0uLL;
        if (v13 >= 32)
        {
          v42 = (int8x16_t *)&v51[v39];
          v43 = v53;
          do
          {
            v41 = veorq_s8(v42[-1], v41);
            v40 = veorq_s8(*v42, v40);
            v42 += 2;
            --v43;
          }
          while (v43);
        }
        if ((v13 & 0x10) != 0)
          v41 = veorq_s8(*(int8x16_t *)((char *)v9 + 8 * v52 + v39), v41);
        v44 = veorq_s8(v41, v40);
        *(&v57 + v10) ^= *(_QWORD *)&veor_s8(*(int8x8_t *)v44.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v44, v44, 8uLL));
        v12 += v22;
        if (v12 >= *(_DWORD *)(v7 + 4 * v10) + *(_DWORD *)(v5 + 4 * v10))
          goto LABEL_32;
      }
      v24 = 0;
      v25 = *v56;
      v26 = v25 * v21;
      v27 = v12 % v17;
      if (v12 % v17 >= 0)
        v28 = v12 % v17;
      else
        v28 = v12 % v17 + 3;
      v29 = (int8x16x4_t *)(*(_QWORD *)(v54 + 8 * v10)
                          + v17 * *(_DWORD *)(v55 + 4 * v10) * (v12 / v17)
                          + v26 * (v28 >> 2));
      v30 = v26 * (v17 / 4 - 1);
      v31 = (int)(v27 - (v28 & 0xFFFFFFFC));
      v32 = v9;
      while (1)
      {
        v33 = 8 * v18;
        if (v19 >= 1)
          break;
LABEL_25:
        v29 = (int8x16x4_t *)((char *)v29 + v30);
        v24 += v19;
        if (v24 >= v23)
          goto LABEL_26;
      }
      while (1)
      {
        if (v18 == 2)
        {
          v37 = (int8x16_t *)&xmmword_1EF139260;
          if (v31 <= 2)
            v37 = (int8x16_t *)*((_QWORD *)&off_1E6A17690 + v31);
          *v32 = vqtbl4q_s8(*v29, *v37);
          goto LABEL_23;
        }
        if (v18 == 1)
          break;
LABEL_23:
        v29 = (int8x16x4_t *)((char *)v29 + v25);
        v32 = (int8x16_t *)((char *)v32 + v20);
        if (v33 < v19)
        {
          v38 = v24 + v33;
          v33 += v20;
          if (v38 < v23)
            continue;
        }
        goto LABEL_25;
      }
      v34 = v29->val[0];
      v35 = v29->val[1];
      if ((int)v31 > 1)
      {
        v36 = vqtbl2q_s8(*(int8x16x2_t *)v34.i8, (int8x16_t)xmmword_1B6917490);
        if ((v27 & 1) == 0)
        {
LABEL_22:
          v32->i64[0] = v36.i64[0];
          goto LABEL_23;
        }
      }
      else
      {
        v36 = vqtbl2q_s8(*(int8x16x2_t *)v34.i8, (int8x16_t)xmmword_1B69174A0);
        if ((v27 & 1) == 0)
          goto LABEL_22;
      }
      v36.i64[0] = vextq_s8(v36, v36, 8uLL).u64[0];
      goto LABEL_22;
    }
LABEL_32:
    v11 = 0;
    v10 = 1;
  }
  while ((v50 & 1) != 0);
  v45 = 0;
  v46 = 1;
  do
  {
    v47 = v46;
    *(&v57 + v45) = (*(&v57 + v45) ^ HIDWORD(*(&v57 + v45)) ^ ((*(&v57 + v45) ^ HIDWORD(*(&v57 + v45))) >> 16)) ^ (((unsigned __int16)(*(&v57 + v45) ^ HIDWORD(*(&v57 + v45))) ^ ((*(&v57 + v45) ^ HIDWORD(*(&v57 + v45))) >> 16)) >> 8);
    v45 = 1;
    v46 = 0;
  }
  while ((v47 & 1) != 0);
  return (v58 << 8) | (unsigned __int16)v57;
}

int16x8_t *sub_1B67AE180(int16x8_t *result, uint64_t a2, uint64_t *a3, int a4, __int16 *a5, uint64_t a6, int a7)
{
  int16x8_t v7;
  int16x8_t v8;
  int8x16_t v9;
  int v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int16x8_t v15;
  const __int16 *v16;
  int16x8_t v17;
  int8x16_t v23;
  uint16x8_t v24;
  uint16x8_t v25;
  int16x8_t v26;

  v9 = (int8x16_t)vdupq_n_s16(~a4);
  v8 = (int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1B69174B0);
  v9.i64[0] = *a3;
  _X8 = result + 1;
  v11 = a7 + 1;
  v12 = (int8x16_t)vceqzq_s16(v8);
  v13.i64[0] = 0x2000200020002;
  v13.i64[1] = 0x2000200020002;
  v14.i64[0] = 0x3000300030003;
  v14.i64[1] = 0x3000300030003;
  v15.i64[0] = 0xFC00FC00FC00FC00;
  v15.i64[1] = 0xFC00FC00FC00FC00;
  v16 = a5;
  do
  {
    v17 = _X8[-1];
    __asm { PRFM            #0, [X8] }
    v23 = (int8x16_t)vld1q_dup_s16(v16++);
    v24 = (uint16x8_t)vextq_s8(v23, (int8x16_t)v17, 0xEuLL);
    *a5 = v17.i16[7];
    v7.i16[0] = _X8->i16[0];
    v25 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v7, 2uLL);
    v26 = (int16x8_t)vcgtq_u16((uint16x8_t)v17, v25);
    v7 = (int16x8_t)vcgtq_u16(v25, (uint16x8_t)v17);
    _X8[-1] = (int16x8_t)vbslq_s8(v12, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v17, vqtbl1_s8(v9, (int8x8_t)vqmovn_u16((uint16x8_t)vaddq_s16(vsubq_s16(vaddq_s16((int16x8_t)vbslq_s8((int8x16_t)vcgtq_u16((uint16x8_t)v17, v24), v14, v13), (int16x8_t)vcgtq_u16(v24, (uint16x8_t)v17)), v26), v7)))),
                                          (int16x8_t)0),
                                        v15),
                           (int8x16_t)v17);
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v11;
    a5 = (__int16 *)v16;
  }
  while (v11 > 1);
  return result;
}

int8x8_t *sub_1B67AE22C(int8x8_t *result, uint64_t a2, int8x16_t *a3, int a4, char *a5, double a6, double a7, double a8, double a9, double a10, double a11, int8x8_t a12, uint64_t a13, int a14)
{
  int8x16_t v14;
  int v16;
  int8x8_t v17;
  const char *v18;
  int8x8_t v19;
  int8x8_t v25;
  uint8x8_t v26;
  uint8x8_t v27;

  v14 = *a3;
  _X8 = result + 1;
  v16 = a14 + 1;
  v17 = vceqz_s8(vand_s8(vdup_n_s8(~a4), (int8x8_t)0x200000000000001));
  v18 = a5;
  do
  {
    v19 = _X8[-1];
    __asm { PRFM            #0, [X8] }
    v25 = vld1_dup_s8(v18++);
    v26 = (uint8x8_t)vext_s8(v25, v19, 7uLL);
    *a5 = v19.i8[7];
    a12.i8[0] = _X8->i8[0];
    v27 = (uint8x8_t)vext_s8(v19, a12, 1uLL);
    a12 = (int8x8_t)vsqadd_u8((uint8x8_t)v19, vqtbl1_s8(v14, vadd_s8(vsub_s8(vadd_s8(vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)v19, v26), (int8x8_t)0x303030303030303, (int8x8_t)0x202020202020202), (int8x8_t)vcgt_u8(v26, (uint8x8_t)v19)), (int8x8_t)vcgt_u8((uint8x8_t)v19, v27)), (int8x8_t)vcgt_u8(v27, (uint8x8_t)v19))));
    _X8[-1] = vbsl_s8(v17, a12, v19);
    _X8 = (int8x8_t *)((char *)_X8 + a2);
    --v16;
    a5 = (char *)v18;
  }
  while (v16 > 1);
  return result;
}

uint16x8_t *sub_1B67AE2C4(uint16x8_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _WORD *a5, uint16x8_t *a6, int a7)
{
  int8x16_t v7;
  int v8;
  uint16x8_t v10;
  uint16x8_t v11;
  int16x8_t v18;
  uint64_t v20;
  int v21;
  int8x16_t v22;
  int8x16_t v23;
  int16x8_t v24;
  uint16x8_t v26;

  v7 = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i16[7];
    a6 = result;
    result = (uint16x8_t *)((char *)result + 2 * a2);
    --a7;
  }
  v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = result->i16[(v8 + 1) * a2 + 7];
  v10 = *a6;
  _X5 = a6 + 1;
  v11 = v10;
  __asm { PRFM            #0, [X5] }
  _X8 = result + 1;
  v18 = *(int16x8_t *)result;
  v7.i64[1] = 0;
  __asm { PRFM            #0, [X8] }
  v20 = 2 * a2;
  v21 = v8 + 2;
  v22.i64[0] = 0x2000200020002;
  v22.i64[1] = 0x2000200020002;
  v23.i64[0] = 0x3000300030003;
  v23.i64[1] = 0x3000300030003;
  v24.i64[0] = 0xFC00FC00FC00FC00;
  v24.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    _X11 = (uint64_t)result[1].i64 + v20;
    v26 = *(uint16x8_t *)((char *)result + 2 * a2);
    __asm { PRFM            #0, [X11] }
    *a5++ = v18.i16[7];
    --v21;
    *(int16x8_t *)result = vminq_s16(vmaxq_s16(vaddw_s8(v18, vqtbl1_s8(v7, (int8x8_t)vqmovn_u16((uint16x8_t)vaddq_s16(vsubq_s16(vaddq_s16((int16x8_t)vbslq_s8((int8x16_t)vcgtq_u16((uint16x8_t)v18, v11), v23, v22), (int16x8_t)vcgtq_u16(v11, (uint16x8_t)v18)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v26)), (int16x8_t)vcgtq_u16(v26, (uint16x8_t)v18))))), (int16x8_t)0), v24);
    result = (uint16x8_t *)((char *)result + v20);
    v11 = (uint16x8_t)v18;
    v18 = (int16x8_t)v26;
  }
  while (v21 > 1);
  return result;
}

uint8x8_t *sub_1B67AE39C(uint8x8_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _BYTE *a5, uint8x8_t *a6, int a7)
{
  int8x16_t v7;
  int v8;
  uint8x8_t v10;
  uint8x8_t v11;
  uint8x8_t v18;
  int v20;
  uint8x8_t v22;
  int8x8_t v24;

  v7 = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i8[7];
    a6 = result;
    result = (uint8x8_t *)((char *)result + a2);
    --a7;
  }
  v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = result->i8[(v8 + 1) * a2 + 7];
  v10 = *a6;
  _X5 = a6 + 1;
  v11 = v10;
  __asm { PRFM            #0, [X5] }
  _X9 = result + 1;
  v18 = *result;
  __asm { PRFM            #0, [X9] }
  v20 = v8 + 2;
  do
  {
    _X10 = (uint64_t)&result[1] + a2;
    v22 = *(uint8x8_t *)((char *)result + a2);
    __asm { PRFM            #0, [X10] }
    *a5++ = v18.i8[7];
    v24 = vqtbl1_s8(v7, vadd_s8(vsub_s8(vadd_s8(vbsl_s8((int8x8_t)vcgt_u8(v18, v11), (int8x8_t)0x303030303030303, (int8x8_t)0x202020202020202), (int8x8_t)vcgt_u8(v11, v18)), (int8x8_t)vcgt_u8(v18, v22)), (int8x8_t)vcgt_u8(v22, v18)));
    v11 = v18;
    *result = vsqadd_u8(v18, v24);
    --v20;
    v18 = v22;
    result = (uint8x8_t *)((char *)result + a2);
  }
  while (v20 > 1);
  return result;
}

int8x16_t *sub_1B67AE454(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, __int16 *a5, int8x16_t *a6, int a7)
{
  int16x8_t v7;
  int8x16_t v8;
  const __int16 *v9;
  int8x16_t v10;
  const __int16 *v11;
  int v12;
  int8x16_t v14;
  int8x16_t v15;
  int16x8_t v22;
  uint64_t v24;
  int v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int16x8_t v29;
  const __int16 *v30;
  int8x16_t v32;
  uint16x8_t v34;
  uint16x8_t v35;

  v8 = *a3;
  if ((a4 & 4) != 0)
  {
    v11 = &a6[-1].i16[7];
    v10 = (int8x16_t)vld1q_dup_s16(v11);
  }
  else
  {
    v9 = a5;
    v10 = (int8x16_t)vld1q_dup_s16(v9++);
    *a5 = result->i16[7];
    a6 = result;
    result = (int8x16_t *)((char *)result + 2 * a2);
    --a7;
    a5 = (__int16 *)v9;
  }
  v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = result->i16[(v12 + 1) * a2 + 7];
  v14 = *a6;
  _X5 = a6 + 1;
  v15 = v14;
  __asm { PRFM            #0, [X5] }
  _X8 = result + 1;
  v22 = *(int16x8_t *)result;
  __asm { PRFM            #0, [X8] }
  v8.i64[1] = 0;
  v24 = 2 * a2;
  v25 = v12 + 2;
  v26 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_n_s16(~a4), (int8x16_t)xmmword_1B69174B0));
  v27.i64[0] = 0x2000200020002;
  v27.i64[1] = 0x2000200020002;
  v28.i64[0] = 0x3000300030003;
  v28.i64[1] = 0x3000300030003;
  v29.i64[0] = 0xFC00FC00FC00FC00;
  v29.i64[1] = 0xFC00FC00FC00FC00;
  v30 = a5;
  do
  {
    _X11 = (uint64_t)result->i64 + v24;
    v32 = *(int8x16_t *)((char *)result + 2 * a2);
    __asm { PRFM            #0, [X11,#0x10] }
    v7.i16[0] = result[1].i16[(unint64_t)v24 / 2];
    v34 = (uint16x8_t)vextq_s8(v10, v15, 0xEuLL);
    v35 = (uint16x8_t)vextq_s8(v32, (int8x16_t)v7, 2uLL);
    v7 = (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u16((uint16x8_t)v22, v34), v28, v27);
    *result = vbslq_s8(v26, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v22, vqtbl1_s8(v8, (int8x8_t)vqmovn_u16((uint16x8_t)vaddq_s16(vsubq_s16(vaddq_s16(v7, (int16x8_t)vcgtq_u16(v34, (uint16x8_t)v22)), (int16x8_t)vcgtq_u16((uint16x8_t)v22, v35)), (int16x8_t)vcgtq_u16(v35, (uint16x8_t)v22))))), (int16x8_t)0), v29), (int8x16_t)v22);
    v10 = (int8x16_t)vld1q_dup_s16(v30++);
    --v25;
    result = (int8x16_t *)((char *)result + v24);
    *a5 = v22.i16[7];
    v15 = (int8x16_t)v22;
    v22 = (int16x8_t)v32;
    a5 = (__int16 *)v30;
  }
  while (v25 > 1);
  return result;
}

int8x8_t *sub_1B67AE574(int8x8_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, char *a5, int8x8_t *a6, int a7)
{
  int8x8_t v7;
  int8x16_t v8;
  const char *v9;
  int8x8_t v10;
  const char *v11;
  int v12;
  int8x8_t v14;
  int8x8_t v15;
  int8x8_t v22;
  int v24;
  int8x8_t v25;
  const char *v26;
  int8x8_t v28;
  uint8x8_t v30;
  uint8x8_t v31;

  v8 = *a3;
  if ((a4 & 4) != 0)
  {
    v11 = (char *)&a6[-1] + 7;
    v10 = (int8x8_t)vld1q_dup_s8(v11).u64[0];
  }
  else
  {
    v9 = a5;
    v10 = (int8x8_t)vld1q_dup_s8(v9++).u64[0];
    *a5 = result->i8[7];
    a6 = result;
    result = (int8x8_t *)((char *)result + a2);
    --a7;
    a5 = (char *)v9;
  }
  v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = result->i8[(v12 + 1) * a2 + 7];
  v14 = *a6;
  _X5 = a6 + 1;
  v15 = v14;
  __asm { PRFM            #0, [X5] }
  _X9 = result + 1;
  v22 = *result;
  __asm { PRFM            #0, [X9] }
  v24 = v12 + 2;
  v25 = vceqz_s8(vand_s8(vdup_n_s8(~a4), (int8x8_t)0x200000000000001));
  v26 = a5;
  do
  {
    _X10 = (char *)result + a2;
    v28 = *(int8x8_t *)((char *)result + a2);
    __asm { PRFM            #0, [X10,#8] }
    v7.i8[0] = result[1].i8[a2];
    v30 = (uint8x8_t)vext_s8(v10, v15, 7uLL);
    v31 = (uint8x8_t)vext_s8(v28, v7, 1uLL);
    v7 = vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)v22, v30), (int8x8_t)0x303030303030303, (int8x8_t)0x202020202020202);
    *result = vbsl_s8(v25, (int8x8_t)vsqadd_u8((uint8x8_t)v22, vqtbl1_s8(v8, vadd_s8(vsub_s8(vadd_s8(v7, (int8x8_t)vcgt_u8(v30, (uint8x8_t)v22)), (int8x8_t)vcgt_u8((uint8x8_t)v22, v31)), (int8x8_t)vcgt_u8(v31, (uint8x8_t)v22)))), v22);
    v10 = (int8x8_t)vld1q_dup_s8(v26++).u64[0];
    --v24;
    v15 = v22;
    *a5 = v22.i8[7];
    v22 = v28;
    a5 = (char *)v26;
    result = (int8x8_t *)((char *)result + a2);
  }
  while (v24 > 1);
  return result;
}

int8x16_t *sub_1B67AE67C(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _WORD *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  int16x8_t v15;
  const __int16 *i16;
  int8x16_t v18;
  __int16 *v19;
  uint64_t v20;
  int v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int16x8_t v25;
  const __int16 *v26;
  int8x16_t v28;
  int8x16_t v30;
  uint16x8_t v31;
  uint16x8_t v32;
  const __int16 *v33;

  v7 = *a3;
  if ((~a4 & 9) == 0)
    a5[a7] = result->i16[a7 * a2 - 1];
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i16[7];
    _X5 = result;
    result = (int8x16_t *)((char *)result + 2 * a2);
    --a7;
  }
  v8 = *_X5;
  __asm { PRFM            #0, [X5,#0x10] }
  _X8 = result + 1;
  v15 = *(int16x8_t *)result;
  __asm { PRFM            #0, [X8] }
  i16 = _X5[1].i16;
  v18 = (int8x16_t)vld1q_dup_s16(i16);
  *a5 = HIWORD(*(unsigned __int128 *)result);
  v19 = a5 + 1;
  v7.i64[1] = 0;
  v20 = 2 * a2;
  v21 = a7 + ((a4 >> 3) & 1);
  v22 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_n_s16(~a4), (int8x16_t)xmmword_1B69174B0));
  v23.i64[0] = 0x2000200020002;
  v23.i64[1] = 0x2000200020002;
  v24.i64[0] = 0x3000300030003;
  v24.i64[1] = 0x3000300030003;
  v25.i64[0] = 0xFC00FC00FC00FC00;
  v25.i64[1] = 0xFC00FC00FC00FC00;
  v26 = v19;
  do
  {
    _X12 = (uint64_t)result[1].i64 + v20;
    v28 = *(int8x16_t *)((char *)result + 2 * a2);
    __asm { PRFM            #0, [X12] }
    v30 = (int8x16_t)vld1q_dup_s16(v26++);
    *v19 = v28.i16[7];
    v31 = (uint16x8_t)vextq_s8(v8, v18, 2uLL);
    v32 = (uint16x8_t)vextq_s8(v30, v28, 0xEuLL);
    *result = vbslq_s8(v22, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v15, vqtbl1_s8(v7, (int8x8_t)vqmovn_u16((uint16x8_t)vaddq_s16(vsubq_s16(vaddq_s16((int16x8_t)vbslq_s8((int8x16_t)vcgtq_u16((uint16x8_t)v15, v31), v24, v23), (int16x8_t)vcgtq_u16(v31, (uint16x8_t)v15)), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v32)), (int16x8_t)vcgtq_u16(v32, (uint16x8_t)v15))))),
                               (int16x8_t)0),
                             v25),
                (int8x16_t)v15);
    v33 = result[1].i16;
    --v21;
    result = (int8x16_t *)((char *)result + v20);
    v18 = (int8x16_t)vld1q_dup_s16(v33);
    v19 = (__int16 *)v26;
    v8 = (int8x16_t)v15;
    v15 = (int16x8_t)v28;
  }
  while (v21 > 1);
  return result;
}

int8x8_t *sub_1B67AE798(int8x8_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _BYTE *a5, int8x8_t *_X5, int a7)
{
  int8x16_t v7;
  int8x8_t v8;
  const char *v9;
  int8x8_t v16;
  int8x8_t v18;
  char *v19;
  int v20;
  int8x8_t v21;
  const char *v22;
  int8x8_t v24;
  int8x8_t v26;
  uint8x8_t v27;
  uint8x8_t v28;
  const char *v29;

  v7 = *a3;
  if ((~a4 & 9) == 0)
    a5[a7] = result->i8[a7 * a2 - 1];
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i8[7];
    _X5 = result;
    result = (int8x8_t *)((char *)result + a2);
    --a7;
  }
  v8 = *_X5;
  v9 = (const char *)&_X5[1];
  __asm { PRFM            #0, [X5,#8] }
  _X10 = result + 1;
  v16 = *result;
  __asm { PRFM            #0, [X10] }
  v18 = (int8x8_t)vld1q_dup_s8(v9).u64[0];
  *a5 = HIBYTE(*(unint64_t *)result);
  v19 = a5 + 1;
  v20 = a7 + ((a4 >> 3) & 1);
  v21 = vceqz_s8(vand_s8(vdup_n_s8(~a4), (int8x8_t)0x200000000000001));
  v22 = v19;
  do
  {
    _X11 = (uint64_t)&result[1] + a2;
    v24 = *(int8x8_t *)((char *)result + a2);
    __asm { PRFM            #0, [X11] }
    v26 = vld1_dup_s8(v22++);
    *v19 = v24.i8[7];
    v27 = (uint8x8_t)vext_s8(v8, v18, 1uLL);
    v28 = (uint8x8_t)vext_s8(v26, v24, 7uLL);
    *result = vbsl_s8(v21, (int8x8_t)vsqadd_u8((uint8x8_t)v16, vqtbl1_s8(v7, vadd_s8(vsub_s8(vadd_s8(vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)v16, v27), (int8x8_t)0x303030303030303, (int8x8_t)0x202020202020202), (int8x8_t)vcgt_u8(v27, (uint8x8_t)v16)), (int8x8_t)vcgt_u8((uint8x8_t)v16, v28)), (int8x8_t)vcgt_u8(v28, (uint8x8_t)v16)))), v16);
    v29 = (const char *)&result[1];
    --v20;
    v19 = (char *)v22;
    v18 = (int8x8_t)vld1q_dup_s8(v29).u64[0];
    v8 = v16;
    v16 = v24;
    result = (int8x8_t *)((char *)result + a2);
  }
  while (v20 > 1);
  return result;
}

int16x8_t *sub_1B67AE89C(int16x8_t *result, uint64_t a2, __int128 *a3, uint64_t a4, _WORD *a5, uint64_t a6, int a7)
{
  __int128 v7;
  __int128 v8;
  int v9;
  int16x8_t v10;
  int16x8_t v11;

  v7 = *a3;
  v8 = a3[1];
  v9 = a7 + 1;
  v10.i64[0] = 0xFC00FC00FC00FC00;
  v10.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    v11 = *result;
    __asm { PRFM            #0, [X0,#0x10] }
    *a5++ = HIWORD(*(unsigned __int128 *)result);
    *result = vminq_s16(vmaxq_s16(vaddw_s8(v11, vqtbl2_s8(*(int8x16x2_t *)&v7, vshrn_n_s16(v11, 5uLL))), (int16x8_t)0), v10);
    result = (int16x8_t *)((char *)result + 2 * a2);
    --v9;
  }
  while (v9 > 1);
  return result;
}

uint8x8_t *sub_1B67AE8E8(uint8x8_t *result, uint64_t a2, __int128 *a3, uint64_t a4, _BYTE *a5, uint64_t a6, int a7)
{
  __int128 v7;
  __int128 v8;
  int v9;
  uint8x8_t v10;

  v7 = *a3;
  v8 = a3[1];
  v9 = a7 + 1;
  do
  {
    v10 = *result;
    __asm { PRFM            #0, [X0,#8] }
    *a5++ = HIBYTE(*(unint64_t *)result);
    *result = vsqadd_u8(v10, vqtbl2_s8(*(int8x16x2_t *)&v7, (int8x8_t)vshr_n_u8(v10, 3uLL)));
    result = (uint8x8_t *)((char *)result + a2);
    --v9;
  }
  while (v9 > 1);
  return result;
}

int16x8_t *sub_1B67AE920(int16x8_t *result, uint64_t a2, int8x16_t *a3, int a4, __int16 *a5, uint64_t a6, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int16x8_t v10;
  int v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int16x8_t v16;
  const __int16 *v17;
  int16x8_t v18;
  int16x8_t v19;
  int8x16_t v25;
  uint16x8_t v26;
  uint16x8_t v27;
  uint16x8_t v28;
  uint16x8_t v29;
  int8x16_t v30;

  v8 = *a3;
  v9 = (int8x16_t)vdupq_n_s16(~a4);
  v10 = (int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1B6917470);
  _X8 = result + 2;
  v12 = a7 + 1;
  v13 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1B69174C0));
  v14 = (int8x16_t)vceqzq_s16(v10);
  v15.i64[0] = 0x202020202020202;
  v15.i64[1] = 0x202020202020202;
  v16.i64[0] = 0xFC00FC00FC00FC00;
  v16.i64[1] = 0xFC00FC00FC00FC00;
  v17 = a5;
  do
  {
    v18 = _X8[-2];
    v19 = _X8[-1];
    __asm { PRFM            #0, [X8] }
    v25 = (int8x16_t)vld1q_dup_s16(v17++);
    *a5 = v19.i16[7];
    v7.i16[0] = _X8->i16[0];
    v26 = (uint16x8_t)vextq_s8(v25, (int8x16_t)v18, 0xEuLL);
    v27 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 0xEuLL);
    v28 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 2uLL);
    v29 = (uint16x8_t)vextq_s8((int8x16_t)v19, v7, 2uLL);
    v30 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v28, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v28)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v26)), (int16x8_t)vcgtq_u16(v26, (uint16x8_t)v18))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v27, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v27)), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v29)), (int16x8_t)vcgtq_u16(v29, (uint16x8_t)v19))), v15));
    v7 = (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v18, *(int8x8_t *)v30.i8), (int16x8_t)0), v16);
    _X8[-2] = (int16x8_t)vbslq_s8(v14, v7, (int8x16_t)v18);
    _X8[-1] = (int16x8_t)vbslq_s8(v13, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v19, v30), (int16x8_t)0), v16), (int8x16_t)v19);
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v12;
    a5 = (__int16 *)v17;
  }
  while (v12 > 1);
  return result;
}

uint64_t sub_1B67AEA10(uint64_t result, uint64_t a2, int8x16_t *a3, int a4, char *a5, double a6, double a7, double a8, double a9, double a10, double a11, int8x16_t a12, uint64_t a13, int a14)
{
  int8x16_t v14;
  int v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  const char *v20;
  int8x16_t v21;
  int8x16_t v27;
  uint8x16_t v28;
  uint8x16_t v29;

  v14 = *a3;
  _X8 = (unsigned __int8 *)(result + 16);
  v16 = a14 + 1;
  v17 = vceqzq_s8(vandq_s8(vdupq_n_s8(~a4), (int8x16_t)xmmword_1B69174D0));
  v18.i64[0] = 0x202020202020202;
  v18.i64[1] = 0x202020202020202;
  v19.i64[0] = 0x303030303030303;
  v19.i64[1] = 0x303030303030303;
  v20 = a5;
  do
  {
    v21 = *((int8x16_t *)_X8 - 1);
    __asm { PRFM            #0, [X8] }
    v27 = vld1q_dup_s8(v20++);
    v28 = (uint8x16_t)vextq_s8(v27, v21, 0xFuLL);
    *a5 = v21.i8[15];
    a12.i8[0] = *_X8;
    v29 = (uint8x16_t)vextq_s8(v21, a12, 1uLL);
    a12 = (int8x16_t)vsqaddq_u8((uint8x16_t)v21, vqtbl1q_s8(v14, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v21, v28), v19, v18), (int8x16_t)vcgtq_u8(v28, (uint8x16_t)v21)), (int8x16_t)vcgtq_u8((uint8x16_t)v21, v29)), (int8x16_t)vcgtq_u8(v29, (uint8x16_t)v21))));
    *((int8x16_t *)_X8 - 1) = vbslq_s8(v17, a12, v21);
    _X8 += a2;
    --v16;
    a5 = (char *)v20;
  }
  while (v16 > 1);
  return result;
}

uint16x8_t *sub_1B67AEAA8(uint16x8_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _WORD *a5, uint16x8_t *_X5, int a7)
{
  int8x16_t v7;
  int v8;
  uint16x8_t v9;
  uint16x8_t v10;
  uint16x8_t v16;
  uint16x8_t v17;
  uint64_t v19;
  int v20;
  int8x16_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int8x16_t v27;

  v7 = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = result[1].i16[7];
    _X5 = result;
    result = (uint16x8_t *)((char *)result + 2 * a2);
    --a7;
  }
  v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = result[1].i16[(v8 + 1) * a2 + 7];
  v10 = *_X5;
  v9 = _X5[1];
  __asm { PRFM            #0, [X5,#0x20] }
  v16 = *result;
  v17 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  v19 = 2 * a2;
  v20 = v8 + 2;
  v21.i64[0] = 0x202020202020202;
  v21.i64[1] = 0x202020202020202;
  v22.i64[0] = 0xFC00FC00FC00FC00;
  v22.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    v23 = (int16x8_t)v16;
    v24 = (int16x8_t)v17;
    _X10 = (uint64_t)result->i64 + v19;
    v16 = *(uint16x8_t *)((char *)result + 2 * a2);
    v17 = *(uint16x8_t *)((char *)&result[1] + v19);
    __asm { PRFM            #0, [X10,#0x20] }
    *a5++ = v24.i16[7];
    v27 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v10, (uint16x8_t)v23), (int16x8_t)vcgtq_u16((uint16x8_t)v23, v10)), (int16x8_t)vcgtq_u16((uint16x8_t)v23, v16)), (int16x8_t)vcgtq_u16(v16, (uint16x8_t)v23))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v9, (uint16x8_t)v24), (int16x8_t)vcgtq_u16((uint16x8_t)v24, v9)), (int16x8_t)vcgtq_u16((uint16x8_t)v24, v17)), (int16x8_t)vcgtq_u16(v17, (uint16x8_t)v24))), v21));
    --v20;
    *(int16x8_t *)result = vminq_s16(vmaxq_s16(vaddw_s8(v23, *(int8x8_t *)v27.i8), (int16x8_t)0), v22);
    result[1] = (uint16x8_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v24, v27), (int16x8_t)0), v22);
    result = (uint16x8_t *)((char *)result + v19);
    v10 = (uint16x8_t)v23;
    v9 = (uint16x8_t)v24;
  }
  while (v20 > 1);
  return result;
}

uint8x16_t *sub_1B67AEBA4(uint8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _BYTE *a5, uint8x16_t *a6, int a7)
{
  int8x16_t v7;
  int v8;
  uint8x16_t v10;
  uint8x16_t v11;
  uint8x16_t v18;
  int v20;
  int8x16_t v21;
  int8x16_t v22;
  uint8x16_t v24;
  int8x16_t v26;

  v7 = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i8[15];
    a6 = result;
    result = (uint8x16_t *)((char *)result + a2);
    --a7;
  }
  v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = result->i8[(v8 + 1) * a2 + 15];
  v10 = *a6;
  _X5 = a6 + 1;
  v11 = v10;
  __asm { PRFM            #0, [X5] }
  _X9 = result + 1;
  v18 = *result;
  __asm { PRFM            #0, [X9] }
  v20 = v8 + 2;
  v21.i64[0] = 0x202020202020202;
  v21.i64[1] = 0x202020202020202;
  v22.i64[0] = 0x303030303030303;
  v22.i64[1] = 0x303030303030303;
  do
  {
    _X10 = (uint64_t)result[1].i64 + a2;
    v24 = *(uint8x16_t *)((char *)result + a2);
    __asm { PRFM            #0, [X10] }
    *a5++ = v18.i8[15];
    v26 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v18, v11), v22, v21), (int8x16_t)vcgtq_u8(v11, v18)), (int8x16_t)vcgtq_u8(v18, v24)), (int8x16_t)vcgtq_u8(v24, v18)));
    v11 = v18;
    *result = vsqaddq_u8(v18, v26);
    --v20;
    v18 = v24;
    result = (uint8x16_t *)((char *)result + a2);
  }
  while (v20 > 1);
  return result;
}

uint64_t sub_1B67AEC5C(uint64_t result, uint64_t a2, int8x16_t *a3, unsigned int a4, __int16 *a5, _OWORD *_X5, int a7)
{
  int16x8_t v7;
  int8x16_t v8;
  const __int16 *v9;
  int8x16_t v10;
  const __int16 *v11;
  int v12;
  int8x16_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int8x16_t v17;
  int8x16_t v23;
  int8x16_t v24;
  uint64_t v26;
  int v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int16x8_t v31;
  const __int16 *v32;
  uint16x8_t v33;
  int16x8_t v34;
  uint16x8_t v35;
  uint16x8_t v38;
  uint16x8_t v39;
  int16x8_t v40;
  int8x16_t v41;

  v8 = *a3;
  if ((a4 & 4) != 0)
  {
    v11 = (const __int16 *)_X5 - 1;
    v10 = (int8x16_t)vld1q_dup_s16(v11);
  }
  else
  {
    v9 = a5;
    v10 = (int8x16_t)vld1q_dup_s16(v9++);
    *a5 = *(_WORD *)(result + 30);
    _X5 = (_OWORD *)result;
    result += 2 * a2;
    --a7;
    a5 = (__int16 *)v9;
  }
  v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = *(_WORD *)(result + 2 * (v12 + 1) * a2 + 30);
  v13 = (int8x16_t)vdupq_n_s16(~a4);
  v14 = (int16x8_t)vandq_s8(v13, (int8x16_t)xmmword_1B6917470);
  v15 = (int16x8_t)vandq_s8(v13, (int8x16_t)xmmword_1B69174C0);
  v16 = *(int16x8_t *)_X5;
  v17 = *((int8x16_t *)_X5 + 1);
  __asm { PRFM            #0, [X5,#0x20] }
  v23 = *(int8x16_t *)result;
  v24 = *(int8x16_t *)(result + 16);
  __asm { PRFM            #0, [X0,#0x20] }
  v26 = 2 * a2;
  v27 = v12 + 2;
  v28 = (int8x16_t)vceqzq_s16(v15);
  v29 = (int8x16_t)vceqzq_s16(v14);
  v30.i64[0] = 0x202020202020202;
  v30.i64[1] = 0x202020202020202;
  v31.i64[0] = 0xFC00FC00FC00FC00;
  v31.i64[1] = 0xFC00FC00FC00FC00;
  v32 = a5;
  do
  {
    v33 = (uint16x8_t)vextq_s8((int8x16_t)v16, v17, 0xEuLL);
    v34 = (int16x8_t)v24;
    v35 = (uint16x8_t)vextq_s8(v10, (int8x16_t)v16, 0xEuLL);
    v16 = (int16x8_t)v23;
    _X11 = result + v26;
    v23 = *(int8x16_t *)(result + 2 * a2);
    v24 = *(int8x16_t *)(result + v26 + 16);
    __asm { PRFM            #0, [X11,#0x20] }
    v7.i16[0] = *(_WORD *)(result + v26 + 32);
    v38 = (uint16x8_t)vextq_s8(v23, v24, 2uLL);
    v39 = (uint16x8_t)vextq_s8(v24, (int8x16_t)v7, 2uLL);
    v40 = (int16x8_t)vcgtq_u16((uint16x8_t)v34, v39);
    v7 = (int16x8_t)vcgtq_u16(v39, (uint16x8_t)v34);
    v41 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v35, (uint16x8_t)v16), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v35)), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v38)), (int16x8_t)vcgtq_u16(v38, (uint16x8_t)v16))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v33, (uint16x8_t)v34), (int16x8_t)vcgtq_u16((uint16x8_t)v34, v33)), v40), v7)), v30));
    *(int8x16_t *)result = vbslq_s8(v29, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v16, *(int8x8_t *)v41.i8), (int16x8_t)0), v31), (int8x16_t)v16);
    *(int8x16_t *)(result + 16) = vbslq_s8(v28, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v34, v41), (int16x8_t)0), v31), (int8x16_t)v34);
    v10 = (int8x16_t)vld1q_dup_s16(v32++);
    --v27;
    result += v26;
    *a5 = v34.i16[7];
    v17 = (int8x16_t)v34;
    a5 = (__int16 *)v32;
  }
  while (v27 > 1);
  return result;
}

int8x16_t *sub_1B67AEDBC(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, char *a5, int8x16_t *a6, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  const char *v9;
  int8x16_t v10;
  const char *v11;
  int v12;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v22;
  int v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  const char *v28;
  int8x16_t v30;
  uint8x16_t v32;
  uint8x16_t v33;

  v8 = *a3;
  if ((a4 & 4) != 0)
  {
    v11 = &a6[-1].i8[15];
    v10 = vld1q_dup_s8(v11);
  }
  else
  {
    v9 = a5;
    v10 = vld1q_dup_s8(v9++);
    *a5 = result->i8[15];
    a6 = result;
    result = (int8x16_t *)((char *)result + a2);
    --a7;
    a5 = (char *)v9;
  }
  v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = result->i8[(v12 + 1) * a2 + 15];
  v14 = *a6;
  _X5 = a6 + 1;
  v15 = v14;
  __asm { PRFM            #0, [X5] }
  _X9 = result + 1;
  v22 = *result;
  __asm { PRFM            #0, [X9] }
  v24 = v12 + 2;
  v25 = vceqzq_s8(vandq_s8(vdupq_n_s8(~a4), (int8x16_t)xmmword_1B69174D0));
  v26.i64[0] = 0x202020202020202;
  v26.i64[1] = 0x202020202020202;
  v27.i64[0] = 0x303030303030303;
  v27.i64[1] = 0x303030303030303;
  v28 = a5;
  do
  {
    _X10 = (uint64_t)result->i64 + a2;
    v30 = *(int8x16_t *)((char *)result + a2);
    __asm { PRFM            #0, [X10,#0x10] }
    v7.i8[0] = result[1].i8[a2];
    v32 = (uint8x16_t)vextq_s8(v10, v15, 0xFuLL);
    v33 = (uint8x16_t)vextq_s8(v30, v7, 1uLL);
    v7 = vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v22, v32), v27, v26);
    *result = vbslq_s8(v25, (int8x16_t)vsqaddq_u8((uint8x16_t)v22, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(v7, (int8x16_t)vcgtq_u8(v32, (uint8x16_t)v22)), (int8x16_t)vcgtq_u8((uint8x16_t)v22, v33)), (int8x16_t)vcgtq_u8(v33, (uint8x16_t)v22)))), v22);
    v10 = vld1q_dup_s8(v28++);
    --v24;
    v15 = v22;
    *a5 = v22.i8[15];
    v22 = v30;
    a5 = (char *)v28;
    result = (int8x16_t *)((char *)result + a2);
  }
  while (v24 > 1);
  return result;
}

int8x16_t *sub_1B67AEEC4(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _WORD *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  int16x8_t v9;
  int8x16_t v10;
  int8x16_t v11;
  const __int16 *i16;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v21;
  __int16 *v22;
  uint64_t v23;
  int v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int16x8_t v28;
  const __int16 *v29;
  uint16x8_t v30;
  int16x8_t v31;
  int16x8_t v32;
  int8x16_t v35;
  uint16x8_t v36;
  uint16x8_t v37;
  uint16x8_t v38;
  int8x16_t v39;
  const __int16 *v40;

  v7 = *a3;
  if ((~a4 & 9) == 0)
    a5[a7] = result->i16[a7 * a2 - 1];
  if ((a4 & 4) == 0)
  {
    *a5++ = result[1].i16[7];
    _X5 = result;
    result = (int8x16_t *)((char *)result + 2 * a2);
    --a7;
  }
  v8 = (int8x16_t)vdupq_n_s16(~a4);
  v9 = (int16x8_t)vandq_s8(v8, (int8x16_t)xmmword_1B6917470);
  v11 = *_X5;
  v10 = _X5[1];
  i16 = _X5[2].i16;
  __asm { PRFM            #0, [X5,#0x20] }
  v18 = *result;
  v19 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  v21 = (int8x16_t)vld1q_dup_s16(i16);
  *a5 = v19.i16[7];
  v22 = a5 + 1;
  v23 = 2 * a2;
  v24 = a7 + ((a4 >> 3) & 1);
  v25 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8(v8, (int8x16_t)xmmword_1B69174C0));
  v26 = (int8x16_t)vceqzq_s16(v9);
  v27.i64[0] = 0x202020202020202;
  v27.i64[1] = 0x202020202020202;
  v28.i64[0] = 0xFC00FC00FC00FC00;
  v28.i64[1] = 0xFC00FC00FC00FC00;
  v29 = v22;
  do
  {
    v30 = (uint16x8_t)vextq_s8(v11, v10, 2uLL);
    v31 = (int16x8_t)v19;
    v32 = (int16x8_t)v18;
    _X11 = (uint64_t)result->i64 + v23;
    v18 = *(int8x16_t *)((char *)result + 2 * a2);
    v19 = *(int8x16_t *)((char *)&result[1] + v23);
    __asm { PRFM            #0, [X11,#0x20] }
    v35 = (int8x16_t)vld1q_dup_s16(v29++);
    v36 = (uint16x8_t)vextq_s8(v10, v21, 2uLL);
    *v22 = v19.i16[7];
    v37 = (uint16x8_t)vextq_s8(v35, v18, 0xEuLL);
    v38 = (uint16x8_t)vextq_s8(v18, v19, 0xEuLL);
    v39 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v30, (uint16x8_t)v32), (int16x8_t)vcgtq_u16((uint16x8_t)v32, v30)), (int16x8_t)vcgtq_u16((uint16x8_t)v32, v37)), (int16x8_t)vcgtq_u16(v37, (uint16x8_t)v32))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v36, (uint16x8_t)v31), (int16x8_t)vcgtq_u16((uint16x8_t)v31, v36)), (int16x8_t)vcgtq_u16((uint16x8_t)v31, v38)), (int16x8_t)vcgtq_u16(v38, (uint16x8_t)v31))), v27));
    *result = vbslq_s8(v26, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v32, *(int8x8_t *)v39.i8), (int16x8_t)0), v28), (int8x16_t)v32);
    result[1] = vbslq_s8(v25, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v31, v39), (int16x8_t)0), v28), (int8x16_t)v31);
    v40 = result[2].i16;
    --v24;
    result = (int8x16_t *)((char *)result + v23);
    v21 = (int8x16_t)vld1q_dup_s16(v40);
    v22 = (__int16 *)v29;
    v11 = (int8x16_t)v32;
    v10 = (int8x16_t)v31;
  }
  while (v24 > 1);
  return result;
}

int8x16_t *sub_1B67AF020(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _BYTE *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  const char *i8;
  int8x16_t v16;
  int8x16_t v18;
  char *v19;
  int v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  const char *v24;
  int8x16_t v26;
  int8x16_t v28;
  uint8x16_t v29;
  uint8x16_t v30;
  const char *v31;

  v7 = *a3;
  if ((~a4 & 9) == 0)
    a5[a7] = result->i8[a7 * a2 - 1];
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i8[15];
    _X5 = result;
    result = (int8x16_t *)((char *)result + a2);
    --a7;
  }
  v8 = *_X5;
  i8 = _X5[1].i8;
  __asm { PRFM            #0, [X5,#0x10] }
  _X10 = result + 1;
  v16 = *result;
  __asm { PRFM            #0, [X10] }
  v18 = vld1q_dup_s8(i8);
  *a5 = HIBYTE(*(unsigned __int128 *)result);
  v19 = a5 + 1;
  v20 = a7 + ((a4 >> 3) & 1);
  v21 = vceqzq_s8(vandq_s8(vdupq_n_s8(~a4), (int8x16_t)xmmword_1B69174D0));
  v22.i64[0] = 0x202020202020202;
  v22.i64[1] = 0x202020202020202;
  v23.i64[0] = 0x303030303030303;
  v23.i64[1] = 0x303030303030303;
  v24 = v19;
  do
  {
    _X11 = (uint64_t)result[1].i64 + a2;
    v26 = *(int8x16_t *)((char *)result + a2);
    __asm { PRFM            #0, [X11] }
    v28 = vld1q_dup_s8(v24++);
    *v19 = v26.i8[15];
    v29 = (uint8x16_t)vextq_s8(v8, v18, 1uLL);
    v30 = (uint8x16_t)vextq_s8(v28, v26, 0xFuLL);
    *result = vbslq_s8(v21, (int8x16_t)vsqaddq_u8((uint8x16_t)v16, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v16, v29), v23, v22), (int8x16_t)vcgtq_u8(v29, (uint8x16_t)v16)), (int8x16_t)vcgtq_u8((uint8x16_t)v16, v30)), (int8x16_t)vcgtq_u8(v30, (uint8x16_t)v16)))), v16);
    v31 = result[1].i8;
    --v20;
    v19 = (char *)v24;
    v18 = vld1q_dup_s8(v31);
    v8 = v16;
    v16 = v26;
    result = (int8x16_t *)((char *)result + a2);
  }
  while (v20 > 1);
  return result;
}

int16x8_t *sub_1B67AF124(int16x8_t *result, uint64_t a2, __int128 *a3, uint64_t a4, _WORD *a5, uint64_t a6, int a7)
{
  __int128 v7;
  __int128 v8;
  int v10;
  int16x8_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int8x16_t v19;

  v7 = *a3;
  v8 = a3[1];
  _X8 = result + 1;
  v10 = a7 + 1;
  v11.i64[0] = 0xFC00FC00FC00FC00;
  v11.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    v12 = _X8[-1];
    v13 = *_X8;
    __asm { PRFM            #0, [X8,#0x10] }
    *a5++ = HIWORD(*(unsigned __int128 *)_X8);
    v19 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v12, 5uLL), v13, 5uLL));
    _X8[-1] = vminq_s16(vmaxq_s16(vaddw_s8(v12, *(int8x8_t *)v19.i8), (int16x8_t)0), v11);
    *_X8 = vminq_s16(vmaxq_s16(vaddw_high_s8(v13, v19), (int16x8_t)0), v11);
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v10;
  }
  while (v10 > 1);
  return result;
}

uint8x16_t *sub_1B67AF184(uint8x16_t *result, uint64_t a2, __int128 *a3, uint64_t a4, _BYTE *a5, uint64_t a6, int a7)
{
  __int128 v7;
  __int128 v8;
  int v9;
  uint8x16_t v10;

  v7 = *a3;
  v8 = a3[1];
  v9 = a7 + 1;
  do
  {
    v10 = *result;
    __asm { PRFM            #0, [X0,#0x10] }
    *a5++ = HIBYTE(*(unsigned __int128 *)result);
    *result = vsqaddq_u8(v10, vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8(v10, 3uLL)));
    result = (uint8x16_t *)((char *)result + a2);
    --v9;
  }
  while (v9 > 1);
  return result;
}

int16x8_t *sub_1B67AF1BC(int16x8_t *result, uint64_t a2, int8x16_t *a3, int a4, __int16 *a5, uint64_t a6, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int16x8_t v10;
  int v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int16x8_t v16;
  const __int16 *v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int8x16_t v27;
  uint16x8_t v28;
  uint16x8_t v29;
  uint16x8_t v30;
  uint16x8_t v31;
  uint16x8_t v32;
  uint16x8_t v33;
  uint16x8_t v34;
  uint16x8_t v35;
  int8x16_t v36;
  int8x16_t v37;
  int16x8_t v38;

  v8 = *a3;
  v9 = (int8x16_t)vdupq_n_s16(~a4);
  v10 = (int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1B6917470);
  _X8 = result + 2;
  v12 = a7 + 1;
  v13 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1B69174C0));
  v14 = (int8x16_t)vceqzq_s16(v10);
  v15.i64[0] = 0x202020202020202;
  v15.i64[1] = 0x202020202020202;
  v16.i64[0] = 0xFC00FC00FC00FC00;
  v16.i64[1] = 0xFC00FC00FC00FC00;
  v17 = a5;
  do
  {
    v18 = _X8[-2];
    v19 = _X8[-1];
    v21 = *_X8;
    v20 = _X8[1];
    __asm { PRFM            #0, [X8,#0x20] }
    v27 = (int8x16_t)vld1q_dup_s16(v17++);
    *a5 = v20.i16[7];
    v7.i16[0] = _X8[2].i16[0];
    v28 = (uint16x8_t)vextq_s8(v27, (int8x16_t)v18, 0xEuLL);
    v29 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 0xEuLL);
    v30 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v21, 0xEuLL);
    v31 = (uint16x8_t)vextq_s8((int8x16_t)v21, (int8x16_t)v20, 0xEuLL);
    v32 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 2uLL);
    v33 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v21, 2uLL);
    v34 = (uint16x8_t)vextq_s8((int8x16_t)v21, (int8x16_t)v20, 2uLL);
    v35 = (uint16x8_t)vextq_s8((int8x16_t)v20, v7, 2uLL);
    v36 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v32, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v32)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v28)), (int16x8_t)vcgtq_u16(v28, (uint16x8_t)v18))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v29, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v29)), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v33)), (int16x8_t)vcgtq_u16(v33, (uint16x8_t)v19))), v15));
    v37 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v30, (uint16x8_t)v21), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v30)), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v34)), (int16x8_t)vcgtq_u16(v34, (uint16x8_t)v21))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v31, (uint16x8_t)v20), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v31)), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v35)), (int16x8_t)vcgtq_u16(v35, (uint16x8_t)v20))), v15));
    v38 = vaddw_s8(v21, *(int8x8_t *)v37.i8);
    v7 = (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v20, v37), (int16x8_t)0), v16);
    _X8[-2] = (int16x8_t)vbslq_s8(v14, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v18, *(int8x8_t *)v36.i8), (int16x8_t)0), v16), (int8x16_t)v18);
    _X8[-1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v19, v36), (int16x8_t)0), v16);
    *_X8 = vminq_s16(vmaxq_s16(v38, (int16x8_t)0), v16);
    _X8[1] = (int16x8_t)vbslq_s8(v13, v7, (int8x16_t)v20);
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v12;
    a5 = (__int16 *)v17;
  }
  while (v12 > 1);
  return result;
}

int8x16_t *sub_1B67AF324(int8x16_t *result, uint64_t a2, int8x16_t *a3, int a4, char *a5, uint64_t a6, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  const char *v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v25;
  uint8x16_t v26;
  uint8x16_t v27;
  uint8x16_t v28;
  uint8x16_t v29;

  v8 = *a3;
  v9 = vdupq_n_s8(~a4);
  v10 = vandq_s8(v9, (int8x16_t)xmmword_1B6917470);
  _X8 = result + 2;
  v12 = a7 + 1;
  v13 = vceqzq_s8(vandq_s8(v9, (int8x16_t)xmmword_1B69174E0));
  v14 = vceqzq_s8(v10);
  v15.i64[0] = 0x202020202020202;
  v15.i64[1] = 0x202020202020202;
  v16.i64[0] = 0x303030303030303;
  v16.i64[1] = 0x303030303030303;
  v17 = a5;
  do
  {
    v18 = _X8[-2];
    v19 = _X8[-1];
    __asm { PRFM            #0, [X8] }
    v25 = vld1q_dup_s8(v17++);
    *a5 = v19.i8[15];
    v7.i8[0] = _X8->i8[0];
    v26 = (uint8x16_t)vextq_s8(v25, v18, 0xFuLL);
    v27 = (uint8x16_t)vextq_s8(v18, v19, 0xFuLL);
    v28 = (uint8x16_t)vextq_s8(v18, v19, 1uLL);
    v29 = (uint8x16_t)vextq_s8(v19, v7, 1uLL);
    v7 = (int8x16_t)vsqaddq_u8((uint8x16_t)v19, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v19, v27), v16, v15), (int8x16_t)vcgtq_u8(v27, (uint8x16_t)v19)), (int8x16_t)vcgtq_u8((uint8x16_t)v19, v29)), (int8x16_t)vcgtq_u8(v29, (uint8x16_t)v19))));
    _X8[-2] = vbslq_s8(v14, (int8x16_t)vsqaddq_u8((uint8x16_t)v18, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v18, v28), v16, v15), (int8x16_t)vcgtq_u8(v28, (uint8x16_t)v18)), (int8x16_t)vcgtq_u8((uint8x16_t)v18, v26)), (int8x16_t)vcgtq_u8(v26, (uint8x16_t)v18)))), v18);
    _X8[-1] = vbslq_s8(v13, v7, v19);
    _X8 = (int8x16_t *)((char *)_X8 + a2);
    --v12;
    a5 = (char *)v17;
  }
  while (v12 > 1);
  return result;
}

uint16x8_t *sub_1B67AF404(uint16x8_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _WORD *a5, uint16x8_t *_X5, int a7)
{
  int8x16_t v7;
  int v8;
  uint16x8_t v9;
  uint16x8_t v10;
  uint16x8_t v11;
  uint16x8_t v12;
  uint16x8_t v18;
  uint16x8_t v19;
  uint16x8_t v20;
  uint16x8_t v21;
  int v23;
  uint64_t v24;
  int8x16_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int8x16_t v33;
  int8x16_t v34;

  v7 = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = result[3].i16[7];
    _X5 = result;
    result = (uint16x8_t *)((char *)result + 2 * a2);
    --a7;
  }
  v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = result[3].i16[(v8 + 1) * a2 + 7];
  v10 = *_X5;
  v9 = _X5[1];
  v12 = _X5[2];
  v11 = _X5[3];
  __asm { PRFM            #0, [X5,#0x40] }
  v18 = *result;
  v19 = result[1];
  v20 = result[2];
  v21 = result[3];
  __asm { PRFM            #0, [X0,#0x40] }
  v23 = v8 + 2;
  v24 = 2 * a2;
  v25.i64[0] = 0x202020202020202;
  v25.i64[1] = 0x202020202020202;
  v26.i64[0] = 0xFC00FC00FC00FC00;
  v26.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    v27 = (int16x8_t)v18;
    v28 = (int16x8_t)v19;
    v29 = (int16x8_t)v20;
    v30 = (int16x8_t)v21;
    _X10 = (uint64_t)result->i64 + v24;
    v18 = *(uint16x8_t *)((char *)result + 2 * a2);
    v19 = *(uint16x8_t *)((char *)&result[1] + v24);
    v20 = *(uint16x8_t *)((char *)&result[2] + v24);
    v21 = *(uint16x8_t *)((char *)&result[3] + v24);
    __asm { PRFM            #0, [X10,#0x40] }
    *a5++ = v30.i16[7];
    v33 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v10, (uint16x8_t)v27), (int16x8_t)vcgtq_u16((uint16x8_t)v27, v10)), (int16x8_t)vcgtq_u16((uint16x8_t)v27, v18)), (int16x8_t)vcgtq_u16(v18, (uint16x8_t)v27))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v9, (uint16x8_t)v28), (int16x8_t)vcgtq_u16((uint16x8_t)v28, v9)), (int16x8_t)vcgtq_u16((uint16x8_t)v28, v19)), (int16x8_t)vcgtq_u16(v19, (uint16x8_t)v28))), v25));
    v34 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v12, (uint16x8_t)v29), (int16x8_t)vcgtq_u16((uint16x8_t)v29, v12)), (int16x8_t)vcgtq_u16((uint16x8_t)v29, v20)), (int16x8_t)vcgtq_u16(v20, (uint16x8_t)v29))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v11, (uint16x8_t)v30), (int16x8_t)vcgtq_u16((uint16x8_t)v30, v11)), (int16x8_t)vcgtq_u16((uint16x8_t)v30, v21)), (int16x8_t)vcgtq_u16(v21, (uint16x8_t)v30))), v25));
    *(int16x8_t *)result = vminq_s16(vmaxq_s16(vaddw_s8(v27, *(int8x8_t *)v33.i8), (int16x8_t)0), v26);
    result[1] = (uint16x8_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v28, v33), (int16x8_t)0), v26);
    result[2] = (uint16x8_t)vminq_s16(vmaxq_s16(vaddw_s8(v29, *(int8x8_t *)v34.i8), (int16x8_t)0), v26);
    result[3] = (uint16x8_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v30, v34), (int16x8_t)0), v26);
    --v23;
    result = (uint16x8_t *)((char *)result + v24);
    v10 = (uint16x8_t)v27;
    v9 = (uint16x8_t)v28;
    v12 = (uint16x8_t)v29;
    v11 = (uint16x8_t)v30;
  }
  while (v23 > 1);
  return result;
}

uint8x16_t *sub_1B67AF580(uint8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _BYTE *a5, uint8x16_t *_X5, int a7)
{
  int8x16_t v7;
  int v8;
  uint8x16_t v9;
  uint8x16_t v10;
  uint8x16_t v16;
  uint8x16_t v17;
  int v19;
  int8x16_t v20;
  int8x16_t v21;
  uint8x16_t v22;
  uint8x16_t v23;
  int8x16_t v26;
  uint8x16_t v27;
  int8x16_t v28;

  v7 = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = result[1].i8[15];
    _X5 = result;
    result = (uint8x16_t *)((char *)result + a2);
    --a7;
  }
  v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = result[1].i8[(v8 + 1) * a2 + 15];
  v10 = *_X5;
  v9 = _X5[1];
  __asm { PRFM            #0, [X5,#0x20] }
  v16 = *result;
  v17 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  v19 = v8 + 2;
  v20.i64[0] = 0x202020202020202;
  v20.i64[1] = 0x202020202020202;
  v21.i64[0] = 0x303030303030303;
  v21.i64[1] = 0x303030303030303;
  do
  {
    v22 = v16;
    v23 = v17;
    _X9 = (uint64_t)result->i64 + a2;
    v16 = *(uint8x16_t *)((char *)result + a2);
    v17 = *(uint8x16_t *)((char *)&result[1] + a2);
    __asm { PRFM            #0, [X9,#0x20] }
    *a5++ = v23.i8[15];
    v26 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v22, v10), v21, v20), (int8x16_t)vcgtq_u8(v10, v22)), (int8x16_t)vcgtq_u8(v22, v16)), (int8x16_t)vcgtq_u8(v16, v22)));
    v10 = v22;
    v27 = vsqaddq_u8(v22, v26);
    v28 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v23, v9), v21, v20), (int8x16_t)vcgtq_u8(v9, v23)), (int8x16_t)vcgtq_u8(v23, v17)), (int8x16_t)vcgtq_u8(v17, v23)));
    v9 = v23;
    *result = v27;
    result[1] = vsqaddq_u8(v23, v28);
    --v19;
    result = (uint8x16_t *)((char *)result + a2);
  }
  while (v19 > 1);
  return result;
}

uint64_t sub_1B67AF660(uint64_t result, uint64_t a2, int8x16_t *a3, unsigned int a4, __int16 *a5, int16x8_t *_X5, int a7)
{
  int16x8_t v7;
  int8x16_t v8;
  const __int16 *v9;
  int8x16_t v10;
  const __int16 *v11;
  int v12;
  int8x16_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int v30;
  uint64_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  int16x8_t v35;
  const __int16 *v36;
  uint16x8_t v37;
  uint16x8_t v38;
  uint16x8_t v39;
  uint16x8_t v40;
  uint16x8_t v43;
  uint16x8_t v44;
  uint16x8_t v45;
  uint16x8_t v46;
  int8x16_t v47;
  int16x8_t v48;
  int8x16_t v49;

  v8 = *a3;
  if ((a4 & 4) != 0)
  {
    v11 = &_X5[-1].i16[7];
    v10 = (int8x16_t)vld1q_dup_s16(v11);
  }
  else
  {
    v9 = a5;
    v10 = (int8x16_t)vld1q_dup_s16(v9++);
    *a5 = *(_WORD *)(result + 62);
    _X5 = (int16x8_t *)result;
    result += 2 * a2;
    --a7;
    a5 = (__int16 *)v9;
  }
  v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = *(_WORD *)(result + 2 * (v12 + 1) * a2 + 62);
  v13 = (int8x16_t)vdupq_n_s16(~a4);
  v14 = (int16x8_t)vandq_s8(v13, (int8x16_t)xmmword_1B6917470);
  v16 = *_X5;
  v15 = _X5[1];
  v17 = (int16x8_t)vandq_s8(v13, (int8x16_t)xmmword_1B69174C0);
  v19 = _X5[2];
  v18 = _X5[3];
  __asm { PRFM            #0, [X5,#0x40] }
  v25 = *(int8x16_t *)result;
  v26 = *(int8x16_t *)(result + 16);
  v27 = *(int8x16_t *)(result + 32);
  v28 = *(int8x16_t *)(result + 48);
  __asm { PRFM            #0, [X0,#0x40] }
  v30 = v12 + 2;
  v31 = 2 * a2;
  v32 = (int8x16_t)vceqzq_s16(v17);
  v33 = (int8x16_t)vceqzq_s16(v14);
  v34.i64[0] = 0x202020202020202;
  v34.i64[1] = 0x202020202020202;
  v35.i64[0] = 0xFC00FC00FC00FC00;
  v35.i64[1] = 0xFC00FC00FC00FC00;
  v36 = a5;
  do
  {
    v37 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v18, 0xEuLL);
    v18 = (int16x8_t)v28;
    v38 = (uint16x8_t)vextq_s8((int8x16_t)v15, (int8x16_t)v19, 0xEuLL);
    v19 = (int16x8_t)v27;
    v39 = (uint16x8_t)vextq_s8((int8x16_t)v16, (int8x16_t)v15, 0xEuLL);
    v15 = (int16x8_t)v26;
    v40 = (uint16x8_t)vextq_s8(v10, (int8x16_t)v16, 0xEuLL);
    v16 = (int16x8_t)v25;
    _X11 = result + v31;
    v25 = *(int8x16_t *)(result + 2 * a2);
    v26 = *(int8x16_t *)(result + v31 + 16);
    v27 = *(int8x16_t *)(result + v31 + 32);
    v28 = *(int8x16_t *)(result + v31 + 48);
    __asm { PRFM            #0, [X11,#0x40] }
    v7.i16[0] = *(_WORD *)(result + v31 + 64);
    v43 = (uint16x8_t)vextq_s8(v25, v26, 2uLL);
    v44 = (uint16x8_t)vextq_s8(v26, v27, 2uLL);
    v45 = (uint16x8_t)vextq_s8(v27, v28, 2uLL);
    v46 = (uint16x8_t)vextq_s8(v28, (int8x16_t)v7, 2uLL);
    v47 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v40, (uint16x8_t)v16), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v40)), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v43)), (int16x8_t)vcgtq_u16(v43, (uint16x8_t)v16))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v39, (uint16x8_t)v15), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v39)), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v44)), (int16x8_t)vcgtq_u16(v44, (uint16x8_t)v15))), v34));
    v48 = (int16x8_t)vcgtq_u16((uint16x8_t)v18, v46);
    v7 = (int16x8_t)vcgtq_u16(v46, (uint16x8_t)v18);
    v49 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v38, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v38)), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v45)), (int16x8_t)vcgtq_u16(v45, (uint16x8_t)v19))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v37, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v37)), v48), v7)), v34));
    *(int8x16_t *)result = vbslq_s8(v33, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v16, *(int8x8_t *)v47.i8), (int16x8_t)0), v35), (int8x16_t)v16);
    *(int16x8_t *)(result + 16) = vminq_s16(vmaxq_s16(vaddw_high_s8(v15, v47), (int16x8_t)0), v35);
    *(int16x8_t *)(result + 32) = vminq_s16(vmaxq_s16(vaddw_s8(v19, *(int8x8_t *)v49.i8), (int16x8_t)0), v35);
    *(int8x16_t *)(result + 48) = vbslq_s8(v32, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v18, v49), (int16x8_t)0), v35), (int8x16_t)v18);
    v10 = (int8x16_t)vld1q_dup_s16(v36++);
    --v30;
    result += v31;
    *a5 = v18.i16[7];
    a5 = (__int16 *)v36;
  }
  while (v30 > 1);
  return result;
}

int8x16_t *sub_1B67AF844(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, char *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  const char *v9;
  int8x16_t v10;
  const char *v11;
  int v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v23;
  int8x16_t v24;
  int v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  const char *v31;
  uint8x16_t v32;
  int8x16_t v33;
  uint8x16_t v34;
  uint8x16_t v37;
  uint8x16_t v38;
  int8x16_t v39;

  v8 = *a3;
  if ((a4 & 4) != 0)
  {
    v11 = &_X5[-1].i8[15];
    v10 = vld1q_dup_s8(v11);
  }
  else
  {
    v9 = a5;
    v10 = vld1q_dup_s8(v9++);
    *a5 = result[1].i8[15];
    _X5 = result;
    result = (int8x16_t *)((char *)result + a2);
    --a7;
    a5 = (char *)v9;
  }
  v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = result[1].i8[(v12 + 1) * a2 + 15];
  v13 = vdupq_n_s8(~a4);
  v14 = vandq_s8(v13, (int8x16_t)xmmword_1B6917470);
  v15 = vandq_s8(v13, (int8x16_t)xmmword_1B69174E0);
  v16 = *_X5;
  v17 = _X5[1];
  __asm { PRFM            #0, [X5,#0x20] }
  v23 = *result;
  v24 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  v26 = v12 + 2;
  v27 = vceqzq_s8(v15);
  v28 = vceqzq_s8(v14);
  v29.i64[0] = 0x202020202020202;
  v29.i64[1] = 0x202020202020202;
  v30.i64[0] = 0x303030303030303;
  v30.i64[1] = 0x303030303030303;
  v31 = a5;
  do
  {
    v32 = (uint8x16_t)vextq_s8(v16, v17, 0xFuLL);
    v33 = v24;
    v34 = (uint8x16_t)vextq_s8(v10, v16, 0xFuLL);
    v16 = v23;
    _X10 = (uint64_t)result->i64 + a2;
    v23 = *(int8x16_t *)((char *)result + a2);
    v24 = *(int8x16_t *)((char *)&result[1] + a2);
    __asm { PRFM            #0, [X10,#0x20] }
    v7.i8[0] = result[2].i8[a2];
    v37 = (uint8x16_t)vextq_s8(v23, v24, 1uLL);
    v38 = (uint8x16_t)vextq_s8(v24, v7, 1uLL);
    v39 = (int8x16_t)vcgtq_u8((uint8x16_t)v33, v38);
    v7 = (int8x16_t)vcgtq_u8(v38, (uint8x16_t)v33);
    *result = vbslq_s8(v28, (int8x16_t)vsqaddq_u8((uint8x16_t)v16, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v16, v34), v30, v29), (int8x16_t)vcgtq_u8(v34, (uint8x16_t)v16)), (int8x16_t)vcgtq_u8((uint8x16_t)v16, v37)), (int8x16_t)vcgtq_u8(v37, (uint8x16_t)v16)))), v16);
    result[1] = vbslq_s8(v27, (int8x16_t)vsqaddq_u8((uint8x16_t)v33, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v33, v32), v30, v29), (int8x16_t)vcgtq_u8(v32, (uint8x16_t)v33)), v39), v7))), v33);
    v10 = vld1q_dup_s8(v31++);
    --v26;
    *a5 = v33.i8[15];
    v17 = v33;
    a5 = (char *)v31;
    result = (int8x16_t *)((char *)result + a2);
  }
  while (v26 > 1);
  return result;
}

uint64_t sub_1B67AF994(uint64_t result, uint64_t a2, int8x16_t *a3, unsigned int a4, _WORD *a5, _OWORD *_X5, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  int16x8_t v9;
  int16x8_t v10;
  int16x8_t v11;
  int16x8_t v12;
  int8x16_t v13;
  int8x16_t v14;
  const __int16 *v15;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v26;
  const __int16 *v27;
  __int16 *v28;
  uint64_t v29;
  int v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int16x8_t v34;
  const __int16 *v35;
  int16x8_t v36;
  uint16x8_t v37;
  int16x8_t v38;
  uint16x8_t v39;
  int8x16_t v42;
  uint16x8_t v43;
  uint16x8_t v44;
  uint16x8_t v45;
  uint16x8_t v46;
  uint16x8_t v47;
  uint16x8_t v48;
  int8x16_t v49;
  int8x16_t v50;

  v7 = *a3;
  if ((~a4 & 9) == 0)
    a5[a7] = *(_WORD *)(result + 2 * a7 * a2 - 2);
  if ((a4 & 4) == 0)
  {
    *a5++ = *(_WORD *)(result + 62);
    _X5 = (_OWORD *)result;
    result += 2 * a2;
    --a7;
  }
  v8 = (int8x16_t)vdupq_n_s16(~a4);
  v9 = (int16x8_t)vandq_s8(v8, (int8x16_t)xmmword_1B6917470);
  v10 = (int16x8_t)vandq_s8(v8, (int8x16_t)xmmword_1B69174C0);
  v12 = *(int16x8_t *)_X5;
  v11 = *((int16x8_t *)_X5 + 1);
  v13 = *((int8x16_t *)_X5 + 2);
  v14 = *((int8x16_t *)_X5 + 3);
  v15 = (const __int16 *)(_X5 + 4);
  __asm { PRFM            #0, [X5,#0x40] }
  v21 = *(int8x16_t *)result;
  v22 = *(int8x16_t *)(result + 16);
  v23 = *(int8x16_t *)(result + 32);
  v24 = *(int8x16_t *)(result + 48);
  __asm { PRFM            #0, [X0,#0x40] }
  v26 = (int8x16_t)vld1q_dup_s16(v15);
  v27 = (const __int16 *)(result + 64);
  *a5 = v24.i16[7];
  v28 = a5 + 1;
  v29 = a2;
  v30 = a7 + ((a4 >> 3) & 1);
  v31 = (int8x16_t)vceqzq_s16(v10);
  v32 = (int8x16_t)vceqzq_s16(v9);
  v33.i64[0] = 0x202020202020202;
  v33.i64[1] = 0x202020202020202;
  v34.i64[0] = 0xFC00FC00FC00FC00;
  v34.i64[1] = 0xFC00FC00FC00FC00;
  v35 = v28;
  do
  {
    v36 = (int16x8_t)v24;
    v37 = (uint16x8_t)vextq_s8((int8x16_t)v11, v13, 2uLL);
    v38 = (int16x8_t)v23;
    v39 = (uint16x8_t)vextq_s8((int8x16_t)v12, (int8x16_t)v11, 2uLL);
    v11 = (int16x8_t)v22;
    v12 = (int16x8_t)v21;
    _X12 = &v27[v29];
    v21 = *(int8x16_t *)&v27[v29 - 32];
    v22 = *(int8x16_t *)&v27[v29 - 24];
    v23 = *(int8x16_t *)&v27[v29 - 16];
    v24 = *(int8x16_t *)&v27[v29 - 8];
    __asm { PRFM            #0, [X12] }
    v42 = (int8x16_t)vld1q_dup_s16(v35++);
    v43 = (uint16x8_t)vextq_s8(v13, v14, 2uLL);
    v44 = (uint16x8_t)vextq_s8(v14, v26, 2uLL);
    *v28 = v24.i16[7];
    v45 = (uint16x8_t)vextq_s8(v42, v21, 0xEuLL);
    v46 = (uint16x8_t)vextq_s8(v21, v22, 0xEuLL);
    v47 = (uint16x8_t)vextq_s8(v22, v23, 0xEuLL);
    v48 = (uint16x8_t)vextq_s8(v23, v24, 0xEuLL);
    v49 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v39, (uint16x8_t)v12), (int16x8_t)vcgtq_u16((uint16x8_t)v12, v39)), (int16x8_t)vcgtq_u16((uint16x8_t)v12, v45)), (int16x8_t)vcgtq_u16(v45, (uint16x8_t)v12))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v37, (uint16x8_t)v11), (int16x8_t)vcgtq_u16((uint16x8_t)v11, v37)), (int16x8_t)vcgtq_u16((uint16x8_t)v11, v46)), (int16x8_t)vcgtq_u16(v46, (uint16x8_t)v11))), v33));
    v50 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v43, (uint16x8_t)v38), (int16x8_t)vcgtq_u16((uint16x8_t)v38, v43)), (int16x8_t)vcgtq_u16((uint16x8_t)v38, v47)), (int16x8_t)vcgtq_u16(v47, (uint16x8_t)v38))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v44, (uint16x8_t)v36), (int16x8_t)vcgtq_u16((uint16x8_t)v36, v44)), (int16x8_t)vcgtq_u16((uint16x8_t)v36, v48)), (int16x8_t)vcgtq_u16(v48, (uint16x8_t)v36))), v33));
    *((int8x16_t *)v27 - 4) = vbslq_s8(v32, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v12, *(int8x8_t *)v49.i8), (int16x8_t)0), v34), (int8x16_t)v12);
    *((int16x8_t *)v27 - 3) = vminq_s16(vmaxq_s16(vaddw_high_s8(v11, v49), (int16x8_t)0), v34);
    *((int16x8_t *)v27 - 2) = vminq_s16(vmaxq_s16(vaddw_s8(v38, *(int8x8_t *)v50.i8), (int16x8_t)0), v34);
    *((int8x16_t *)v27 - 1) = vbslq_s8(v31, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v36, v50), (int16x8_t)0), v34), (int8x16_t)v36);
    v26 = (int8x16_t)vld1q_dup_s16(v27);
    --v30;
    v27 = (const __int16 *)((char *)v27 + v29 * 2);
    v28 = (__int16 *)v35;
    v13 = (int8x16_t)v38;
    v14 = (int8x16_t)v36;
  }
  while (v30 > 1);
  return result;
}

int8x16_t *sub_1B67AFB78(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _BYTE *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int8x16_t v12;
  const char *i8;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v22;
  char *v23;
  int v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  const char *v29;
  uint8x16_t v30;
  uint8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v36;
  uint8x16_t v37;
  uint8x16_t v38;
  const char *v39;

  v7 = *a3;
  if ((~a4 & 9) == 0)
    a5[a7] = result->i8[a7 * a2 - 1];
  if ((a4 & 4) == 0)
  {
    *a5++ = result[1].i8[15];
    _X5 = result;
    result = (int8x16_t *)((char *)result + a2);
    --a7;
  }
  v8 = vdupq_n_s8(~a4);
  v9 = vandq_s8(v8, (int8x16_t)xmmword_1B6917470);
  v10 = vandq_s8(v8, (int8x16_t)xmmword_1B69174E0);
  v11 = *_X5;
  v12 = _X5[1];
  i8 = _X5[2].i8;
  __asm { PRFM            #0, [X5,#0x20] }
  v19 = *result;
  v20 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  v22 = vld1q_dup_s8(i8);
  *a5 = v20.i8[15];
  v23 = a5 + 1;
  v24 = a7 + ((a4 >> 3) & 1);
  v25 = vceqzq_s8(v10);
  v26 = vceqzq_s8(v9);
  v27.i64[0] = 0x202020202020202;
  v27.i64[1] = 0x202020202020202;
  v28.i64[0] = 0x303030303030303;
  v28.i64[1] = 0x303030303030303;
  v29 = v23;
  do
  {
    v30 = (uint8x16_t)vextq_s8(v11, v12, 1uLL);
    v31 = (uint8x16_t)vextq_s8(v12, v22, 1uLL);
    v32 = v20;
    v33 = v19;
    _X10 = (uint64_t)result->i64 + a2;
    v19 = *(int8x16_t *)((char *)result + a2);
    v20 = *(int8x16_t *)((char *)&result[1] + a2);
    __asm { PRFM            #0, [X10,#0x20] }
    v36 = vld1q_dup_s8(v29++);
    *v23 = v20.i8[15];
    v37 = (uint8x16_t)vextq_s8(v36, v19, 0xFuLL);
    v38 = (uint8x16_t)vextq_s8(v19, v20, 0xFuLL);
    *result = vbslq_s8(v26, (int8x16_t)vsqaddq_u8((uint8x16_t)v33, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v33, v30), v28, v27), (int8x16_t)vcgtq_u8(v30, (uint8x16_t)v33)), (int8x16_t)vcgtq_u8((uint8x16_t)v33, v37)), (int8x16_t)vcgtq_u8(v37, (uint8x16_t)v33)))), v33);
    result[1] = vbslq_s8(v25, (int8x16_t)vsqaddq_u8((uint8x16_t)v32, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v32, v31), v28, v27), (int8x16_t)vcgtq_u8(v31, (uint8x16_t)v32)), (int8x16_t)vcgtq_u8((uint8x16_t)v32, v38)), (int8x16_t)vcgtq_u8(v38, (uint8x16_t)v32)))), v32);
    v39 = result[2].i8;
    --v24;
    v23 = (char *)v29;
    v22 = vld1q_dup_s8(v39);
    v11 = v33;
    v12 = v32;
    result = (int8x16_t *)((char *)result + a2);
  }
  while (v24 > 1);
  return result;
}

int16x8_t *sub_1B67AFCC4(int16x8_t *result, uint64_t a2, __int128 *a3, uint64_t a4, _WORD *a5, uint64_t a6, int a7)
{
  __int128 v7;
  __int128 v8;
  int v10;
  int16x8_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int8x16_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int8x16_t v24;

  v7 = *a3;
  v8 = a3[1];
  _X8 = result + 2;
  v10 = a7 + 1;
  v11.i64[0] = 0xFC00FC00FC00FC00;
  v11.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    v12 = _X8[-2];
    v13 = _X8[-1];
    v14 = *_X8;
    v15 = _X8[1];
    __asm { PRFM            #0, [X8,#0x20] }
    *a5++ = v15.i16[7];
    v21 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v12, 5uLL), v13, 5uLL));
    v22 = vminq_s16(vmaxq_s16(vaddw_s8(v12, *(int8x8_t *)v21.i8), (int16x8_t)0), v11);
    v23 = vminq_s16(vmaxq_s16(vaddw_high_s8(v13, v21), (int16x8_t)0), v11);
    v24 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v14, 5uLL), v15, 5uLL));
    _X8[-2] = v22;
    _X8[-1] = v23;
    *_X8 = vminq_s16(vmaxq_s16(vaddw_s8(v14, *(int8x8_t *)v24.i8), (int16x8_t)0), v11);
    _X8[1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v15, v24), (int16x8_t)0), v11);
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v10;
  }
  while (v10 > 1);
  return result;
}

uint8x16_t *sub_1B67AFD50(uint8x16_t *result, uint64_t a2, __int128 *a3, uint64_t a4, _BYTE *a5, uint64_t a6, int a7)
{
  __int128 v7;
  __int128 v8;
  int v10;
  uint8x16_t v11;
  uint8x16_t v12;

  v7 = *a3;
  v8 = a3[1];
  _X8 = result + 1;
  v10 = a7 + 1;
  do
  {
    v11 = _X8[-1];
    v12 = *_X8;
    __asm { PRFM            #0, [X8,#0x10] }
    *a5++ = HIBYTE(*(unsigned __int128 *)_X8);
    _X8[-1] = vsqaddq_u8(v11, vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8(v11, 3uLL)));
    *_X8 = vsqaddq_u8(v12, vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8(v12, 3uLL)));
    _X8 = (uint8x16_t *)((char *)_X8 + a2);
    --v10;
  }
  while (v10 > 1);
  return result;
}

int16x8_t *sub_1B67AFD98(int16x8_t *result, uint64_t a2, int8x16_t *a3, int a4, __int16 *a5, uint64_t a6, int a7)
{
  int16x8_t v7;
  int8x16_t v8;
  int16x8_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int v13;
  int8x16_t v14;
  int16x8_t v15;
  const __int16 *v16;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int8x16_t v31;
  uint16x8_t v32;
  uint16x8_t v33;
  uint16x8_t v34;
  uint16x8_t v35;
  uint16x8_t v36;
  uint16x8_t v37;
  uint16x8_t v38;
  uint16x8_t v39;
  uint16x8_t v40;
  uint16x8_t v41;
  uint16x8_t v42;
  uint16x8_t v43;
  uint16x8_t v44;
  uint16x8_t v45;
  uint16x8_t v46;
  uint16x8_t v47;
  int8x16_t v48;
  int8x16_t v49;
  int8x16_t v50;
  int16x8_t v51;
  int16x8_t v52;
  int16x8_t v53;
  int8x16_t v54;

  v8 = *a3;
  v9 = vdupq_n_s16(~a4);
  v10 = (int8x16_t)vtstq_s16(v9, (int16x8_t)xmmword_1B6917470);
  v11 = (int8x16_t)vtstq_s16(v9, (int16x8_t)xmmword_1B69174C0);
  _X8 = result + 6;
  v13 = a7 + 1;
  v14.i64[0] = 0x202020202020202;
  v14.i64[1] = 0x202020202020202;
  v15.i64[0] = 0xFC00FC00FC00FC00;
  v15.i64[1] = 0xFC00FC00FC00FC00;
  v16 = a5;
  do
  {
    v17 = _X8[-6];
    v18 = _X8[-5];
    v19 = _X8[-4];
    v20 = _X8[-3];
    v21 = _X8[-2];
    v22 = _X8[-1];
    v24 = *_X8;
    v23 = _X8[1];
    __asm
    {
      PRFM            #0, [X8,#0x20]
      PRFM            #0, [X8,#0x60]
    }
    v31 = (int8x16_t)vld1q_dup_s16(v16++);
    *a5 = v23.i16[7];
    v32 = (uint16x8_t)vextq_s8(v31, (int8x16_t)v17, 0xEuLL);
    v33 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v18, 0xEuLL);
    v34 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 0xEuLL);
    v35 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v20, 0xEuLL);
    v36 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v21, 0xEuLL);
    v37 = (uint16x8_t)vextq_s8((int8x16_t)v21, (int8x16_t)v22, 0xEuLL);
    v38 = (uint16x8_t)vextq_s8((int8x16_t)v22, (int8x16_t)v24, 0xEuLL);
    v39 = (uint16x8_t)vextq_s8((int8x16_t)v24, (int8x16_t)v23, 0xEuLL);
    v40 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v18, 2uLL);
    v41 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 2uLL);
    v42 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v20, 2uLL);
    v43 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v21, 2uLL);
    v44 = (uint16x8_t)vextq_s8((int8x16_t)v21, (int8x16_t)v22, 2uLL);
    v45 = (uint16x8_t)vextq_s8((int8x16_t)v22, (int8x16_t)v24, 2uLL);
    v46 = (uint16x8_t)vextq_s8((int8x16_t)v24, (int8x16_t)v23, 2uLL);
    v7.i16[0] = _X8[2].i16[0];
    v47 = (uint16x8_t)vextq_s8((int8x16_t)v23, (int8x16_t)v7, 2uLL);
    v48 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v40, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v40)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v32)), (int16x8_t)vcgtq_u16(v32, (uint16x8_t)v17))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v33, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v33)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v41)), (int16x8_t)vcgtq_u16(v41, (uint16x8_t)v18))), v14));
    v49 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v34, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v34)), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v42)), (int16x8_t)vcgtq_u16(v42, (uint16x8_t)v19))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v35, (uint16x8_t)v20), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v35)), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v43)), (int16x8_t)vcgtq_u16(v43, (uint16x8_t)v20))), v14));
    v50 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v36, (uint16x8_t)v21), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v36)), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v44)), (int16x8_t)vcgtq_u16(v44, (uint16x8_t)v21))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v37, (uint16x8_t)v22), (int16x8_t)vcgtq_u16((uint16x8_t)v22, v37)), (int16x8_t)vcgtq_u16((uint16x8_t)v22, v45)), (int16x8_t)vcgtq_u16(v45, (uint16x8_t)v22))), v14));
    v51 = vminq_s16(vmaxq_s16(vaddw_s8(v21, *(int8x8_t *)v50.i8), (int16x8_t)0), v15);
    v52 = vminq_s16(vmaxq_s16(vaddw_high_s8(v22, v50), (int16x8_t)0), v15);
    v53 = (int16x8_t)vcgtq_u16((uint16x8_t)v23, v47);
    v7 = (int16x8_t)vcgtq_u16(v47, (uint16x8_t)v23);
    v54 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v38, (uint16x8_t)v24), (int16x8_t)vcgtq_u16((uint16x8_t)v24, v38)), (int16x8_t)vcgtq_u16((uint16x8_t)v24, v46)), (int16x8_t)vcgtq_u16(v46, (uint16x8_t)v24))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v39, (uint16x8_t)v23), (int16x8_t)vcgtq_u16((uint16x8_t)v23, v39)), v53), v7)), v14));
    _X8[-6] = (int16x8_t)vbslq_s8(v10, (int8x16_t)v17, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v17, *(int8x8_t *)v48.i8), (int16x8_t)0), v15));
    _X8[-5] = vminq_s16(vmaxq_s16(vaddw_high_s8(v18, v48), (int16x8_t)0), v15);
    _X8[-4] = vminq_s16(vmaxq_s16(vaddw_s8(v19, *(int8x8_t *)v49.i8), (int16x8_t)0), v15);
    _X8[-3] = vminq_s16(vmaxq_s16(vaddw_high_s8(v20, v49), (int16x8_t)0), v15);
    _X8[-2] = v51;
    _X8[-1] = v52;
    *_X8 = vminq_s16(vmaxq_s16(vaddw_s8(v24, *(int8x8_t *)v54.i8), (int16x8_t)0), v15);
    _X8[1] = (int16x8_t)vbslq_s8(v11, (int8x16_t)v23, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v23, v54), (int16x8_t)0), v15));
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v13;
    a5 = (__int16 *)v16;
  }
  while (v13 > 1);
  return result;
}

int8x16_t *sub_1B67B000C(int8x16_t *result, uint64_t a2, int8x16_t *a3, int a4, char *a5, uint64_t a6, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  const char *v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v27;
  uint8x16_t v28;
  uint8x16_t v29;
  uint8x16_t v30;
  uint8x16_t v31;
  uint8x16_t v32;
  uint8x16_t v33;
  uint8x16_t v34;
  uint8x16_t v35;

  v8 = *a3;
  v9 = vdupq_n_s8(~a4);
  v10 = vandq_s8(v9, (int8x16_t)xmmword_1B6917470);
  _X8 = result + 2;
  v12 = a7 + 1;
  v13 = vceqzq_s8(vandq_s8(v9, (int8x16_t)xmmword_1B69174E0));
  v14 = vceqzq_s8(v10);
  v15.i64[0] = 0x202020202020202;
  v15.i64[1] = 0x202020202020202;
  v16.i64[0] = 0x303030303030303;
  v16.i64[1] = 0x303030303030303;
  v17 = a5;
  do
  {
    v19 = _X8[-2];
    v18 = _X8[-1];
    v20 = *_X8;
    v21 = _X8[1];
    __asm { PRFM            #0, [X8,#0x20] }
    v27 = vld1q_dup_s8(v17++);
    *a5 = v21.i8[15];
    v7.i8[0] = _X8[2].i8[0];
    v28 = (uint8x16_t)vextq_s8(v27, v19, 0xFuLL);
    v29 = (uint8x16_t)vextq_s8(v19, v18, 0xFuLL);
    v30 = (uint8x16_t)vextq_s8(v18, v20, 0xFuLL);
    v31 = (uint8x16_t)vextq_s8(v20, v21, 0xFuLL);
    v32 = (uint8x16_t)vextq_s8(v19, v18, 1uLL);
    v33 = (uint8x16_t)vextq_s8(v18, v20, 1uLL);
    v34 = (uint8x16_t)vextq_s8(v20, v21, 1uLL);
    v35 = (uint8x16_t)vextq_s8(v21, v7, 1uLL);
    v7 = (int8x16_t)vsqaddq_u8((uint8x16_t)v21, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v21, v31), v16, v15), (int8x16_t)vcgtq_u8(v31, (uint8x16_t)v21)), (int8x16_t)vcgtq_u8((uint8x16_t)v21, v35)), (int8x16_t)vcgtq_u8(v35, (uint8x16_t)v21))));
    _X8[-2] = vbslq_s8(v14, (int8x16_t)vsqaddq_u8((uint8x16_t)v19, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v19, v32), v16, v15), (int8x16_t)vcgtq_u8(v32, (uint8x16_t)v19)), (int8x16_t)vcgtq_u8((uint8x16_t)v19, v28)), (int8x16_t)vcgtq_u8(v28, (uint8x16_t)v19)))), v19);
    _X8[-1] = (int8x16_t)vsqaddq_u8((uint8x16_t)v18, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v18, v29), v16, v15), (int8x16_t)vcgtq_u8(v29, (uint8x16_t)v18)), (int8x16_t)vcgtq_u8((uint8x16_t)v18, v33)), (int8x16_t)vcgtq_u8(v33, (uint8x16_t)v18))));
    *(uint8x16_t *)_X8 = vsqaddq_u8((uint8x16_t)v20, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v20, v30), v16, v15), (int8x16_t)vcgtq_u8(v30, (uint8x16_t)v20)), (int8x16_t)vcgtq_u8((uint8x16_t)v20, v34)), (int8x16_t)vcgtq_u8(v34, (uint8x16_t)v20))));
    _X8[1] = vbslq_s8(v13, v7, v21);
    _X8 = (int8x16_t *)((char *)_X8 + a2);
    --v12;
    a5 = (char *)v17;
  }
  while (v12 > 1);
  return result;
}

uint64_t sub_1B67B0154(uint64_t result, uint64_t a2, int8x16_t *a3, unsigned int a4, _WORD *a5, uint16x8_t *_X5, int a7)
{
  int8x16_t v7;
  int v8;
  uint16x8_t v9;
  uint16x8_t v10;
  uint16x8_t v11;
  uint16x8_t v12;
  uint16x8_t v13;
  uint16x8_t v14;
  uint16x8_t v15;
  uint16x8_t v16;
  uint16x8_t v23;
  uint16x8_t v24;
  uint16x8_t v25;
  uint16x8_t v26;
  uint16x8_t v27;
  uint16x8_t v28;
  int16x8_t *v29;
  uint16x8_t v30;
  uint16x8_t v31;
  int v34;
  uint64_t v35;
  int8x16_t v36;
  int16x8_t v37;
  int16x8_t v38;
  int16x8_t v39;
  int16x8_t v40;
  int16x8_t v41;
  int16x8_t v42;
  int16x8_t v43;
  int16x8_t v44;
  int16x8_t v45;
  int8x16_t v49;
  int8x16_t v50;
  int8x16_t v51;
  int8x16_t v52;

  v7 = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = *(_WORD *)(result + 126);
    _X5 = (uint16x8_t *)result;
    result += 2 * a2;
    --a7;
  }
  v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = *(_WORD *)(result + 2 * (v8 + 1) * a2 + 126);
  v10 = *_X5;
  v9 = _X5[1];
  v12 = _X5[2];
  v11 = _X5[3];
  v14 = _X5[4];
  v13 = _X5[5];
  v16 = _X5[6];
  v15 = _X5[7];
  __asm
  {
    PRFM            #0, [X5,#0x80]
    PRFM            #0, [X5,#0xC0]
  }
  v23 = *(uint16x8_t *)result;
  v24 = *(uint16x8_t *)(result + 16);
  v25 = *(uint16x8_t *)(result + 32);
  v26 = *(uint16x8_t *)(result + 48);
  v27 = *(uint16x8_t *)(result + 64);
  v28 = *(uint16x8_t *)(result + 80);
  v29 = (int16x8_t *)(result + 96);
  v30 = *(uint16x8_t *)(result + 96);
  v31 = *(uint16x8_t *)(result + 112);
  __asm
  {
    PRFM            #0, [X0,#0x80]
    PRFM            #0, [X0,#0xC0]
  }
  v34 = v8 + 2;
  v35 = 2 * a2;
  v36.i64[0] = 0x202020202020202;
  v36.i64[1] = 0x202020202020202;
  v37.i64[0] = 0xFC00FC00FC00FC00;
  v37.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    v38 = (int16x8_t)v31;
    v39 = (int16x8_t)v30;
    v40 = (int16x8_t)v28;
    v41 = (int16x8_t)v27;
    v42 = (int16x8_t)v26;
    v43 = (int16x8_t)v25;
    v44 = (int16x8_t)v24;
    v45 = (int16x8_t)v23;
    _X11 = &v29->i8[v35];
    v23 = *(uint16x8_t *)((char *)&v29[-6] + v35);
    v24 = *(uint16x8_t *)((char *)&v29[-5] + v35);
    v25 = *(uint16x8_t *)((char *)&v29[-4] + v35);
    v26 = *(uint16x8_t *)((char *)&v29[-3] + v35);
    v27 = *(uint16x8_t *)((char *)&v29[-2] + v35);
    v28 = *(uint16x8_t *)((char *)&v29[-1] + v35);
    v30 = *(uint16x8_t *)((char *)v29 + 2 * a2);
    v31 = *(uint16x8_t *)((char *)&v29[1] + v35);
    __asm
    {
      PRFM            #0, [X11,#0x20]
      PRFM            #0, [X11,#0x60]
    }
    *a5++ = v38.i16[7];
    v49 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v10, (uint16x8_t)v45), (int16x8_t)vcgtq_u16((uint16x8_t)v45, v10)), (int16x8_t)vcgtq_u16((uint16x8_t)v45, v23)), (int16x8_t)vcgtq_u16(v23, (uint16x8_t)v45))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v9, (uint16x8_t)v44), (int16x8_t)vcgtq_u16((uint16x8_t)v44, v9)), (int16x8_t)vcgtq_u16((uint16x8_t)v44, v24)), (int16x8_t)vcgtq_u16(v24, (uint16x8_t)v44))), v36));
    v50 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v12, (uint16x8_t)v43), (int16x8_t)vcgtq_u16((uint16x8_t)v43, v12)), (int16x8_t)vcgtq_u16((uint16x8_t)v43, v25)), (int16x8_t)vcgtq_u16(v25, (uint16x8_t)v43))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v11, (uint16x8_t)v42), (int16x8_t)vcgtq_u16((uint16x8_t)v42, v11)), (int16x8_t)vcgtq_u16((uint16x8_t)v42, v26)), (int16x8_t)vcgtq_u16(v26, (uint16x8_t)v42))), v36));
    v51 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v14, (uint16x8_t)v41), (int16x8_t)vcgtq_u16((uint16x8_t)v41, v14)), (int16x8_t)vcgtq_u16((uint16x8_t)v41, v27)), (int16x8_t)vcgtq_u16(v27, (uint16x8_t)v41))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v13, (uint16x8_t)v40), (int16x8_t)vcgtq_u16((uint16x8_t)v40, v13)), (int16x8_t)vcgtq_u16((uint16x8_t)v40, v28)), (int16x8_t)vcgtq_u16(v28, (uint16x8_t)v40))), v36));
    v52 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v16, (uint16x8_t)v39), (int16x8_t)vcgtq_u16((uint16x8_t)v39, v16)), (int16x8_t)vcgtq_u16((uint16x8_t)v39, v30)), (int16x8_t)vcgtq_u16(v30, (uint16x8_t)v39))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v15, (uint16x8_t)v38), (int16x8_t)vcgtq_u16((uint16x8_t)v38, v15)), (int16x8_t)vcgtq_u16((uint16x8_t)v38, v31)), (int16x8_t)vcgtq_u16(v31, (uint16x8_t)v38))), v36));
    v29[-6] = vminq_s16(vmaxq_s16(vaddw_s8(v45, *(int8x8_t *)v49.i8), (int16x8_t)0), v37);
    v29[-5] = vminq_s16(vmaxq_s16(vaddw_high_s8(v44, v49), (int16x8_t)0), v37);
    v29[-4] = vminq_s16(vmaxq_s16(vaddw_s8(v43, *(int8x8_t *)v50.i8), (int16x8_t)0), v37);
    v29[-3] = vminq_s16(vmaxq_s16(vaddw_high_s8(v42, v50), (int16x8_t)0), v37);
    v29[-2] = vminq_s16(vmaxq_s16(vaddw_s8(v41, *(int8x8_t *)v51.i8), (int16x8_t)0), v37);
    v29[-1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v40, v51), (int16x8_t)0), v37);
    --v34;
    *v29 = vminq_s16(vmaxq_s16(vaddw_s8(v39, *(int8x8_t *)v52.i8), (int16x8_t)0), v37);
    v29[1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v38, v52), (int16x8_t)0), v37);
    v29 = (int16x8_t *)((char *)v29 + v35);
    v10 = (uint16x8_t)v45;
    v9 = (uint16x8_t)v44;
    v12 = (uint16x8_t)v43;
    v11 = (uint16x8_t)v42;
    v14 = (uint16x8_t)v41;
    v13 = (uint16x8_t)v40;
    v16 = (uint16x8_t)v39;
    v15 = (uint16x8_t)v38;
  }
  while (v34 > 1);
  return result;
}

uint8x16_t *sub_1B67B0404(uint8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _BYTE *a5, uint8x16_t *_X5, int a7)
{
  int8x16_t v7;
  int v8;
  uint8x16_t v9;
  uint8x16_t v10;
  uint8x16_t v11;
  uint8x16_t v12;
  uint8x16_t v18;
  uint8x16_t v19;
  uint8x16_t v20;
  uint8x16_t v21;
  int v23;
  int8x16_t v24;
  int8x16_t v25;
  uint8x16_t v26;
  uint8x16_t v27;
  uint8x16_t v28;
  uint8x16_t v29;
  int8x16_t v32;
  uint8x16_t v33;
  int8x16_t v34;
  uint8x16_t v35;
  int8x16_t v36;
  uint8x16_t v37;
  int8x16_t v38;

  v7 = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = result[3].i8[15];
    _X5 = result;
    result = (uint8x16_t *)((char *)result + a2);
    --a7;
  }
  v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = result[3].i8[(v8 + 1) * a2 + 15];
  v10 = *_X5;
  v9 = _X5[1];
  v11 = _X5[2];
  v12 = _X5[3];
  __asm { PRFM            #0, [X5,#0x40] }
  v18 = *result;
  v19 = result[1];
  v20 = result[2];
  v21 = result[3];
  __asm { PRFM            #0, [X0,#0x40] }
  v23 = v8 + 2;
  v24.i64[0] = 0x202020202020202;
  v24.i64[1] = 0x202020202020202;
  v25.i64[0] = 0x303030303030303;
  v25.i64[1] = 0x303030303030303;
  do
  {
    v26 = v18;
    v27 = v19;
    v28 = v20;
    v29 = v21;
    _X9 = (uint64_t)result->i64 + a2;
    v18 = *(uint8x16_t *)((char *)result + a2);
    v19 = *(uint8x16_t *)((char *)&result[1] + a2);
    v20 = *(uint8x16_t *)((char *)&result[2] + a2);
    v21 = *(uint8x16_t *)((char *)&result[3] + a2);
    __asm { PRFM            #0, [X9,#0x40] }
    *a5++ = v29.i8[15];
    v32 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v26, v10), v25, v24), (int8x16_t)vcgtq_u8(v10, v26)), (int8x16_t)vcgtq_u8(v26, v18)), (int8x16_t)vcgtq_u8(v18, v26)));
    v10 = v26;
    v33 = vsqaddq_u8(v26, v32);
    v34 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v27, v9), v25, v24), (int8x16_t)vcgtq_u8(v9, v27)), (int8x16_t)vcgtq_u8(v27, v19)), (int8x16_t)vcgtq_u8(v19, v27)));
    v9 = v27;
    v35 = vsqaddq_u8(v27, v34);
    v36 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v28, v11), v25, v24), (int8x16_t)vcgtq_u8(v11, v28)), (int8x16_t)vcgtq_u8(v28, v20)), (int8x16_t)vcgtq_u8(v20, v28)));
    v11 = v28;
    v37 = vsqaddq_u8(v28, v36);
    v38 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v29, v12), v25, v24), (int8x16_t)vcgtq_u8(v12, v29)), (int8x16_t)vcgtq_u8(v29, v21)), (int8x16_t)vcgtq_u8(v21, v29)));
    v12 = v29;
    *result = v33;
    result[1] = v35;
    result[2] = v37;
    result[3] = vsqaddq_u8(v29, v38);
    --v23;
    result = (uint8x16_t *)((char *)result + a2);
  }
  while (v23 > 1);
  return result;
}

uint64_t sub_1B67B0554(uint64_t result, uint64_t a2, int8x16_t *a3, unsigned int a4, __int16 *a5, int16x8_t *_X5, int a7)
{
  int8x16_t v7;
  const __int16 *v8;
  int8x16_t v9;
  const __int16 *v10;
  int v11;
  int8x16_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  uint64_t v33;
  int8x16_t v34;
  int8x16_t v35;
  int8x16_t v36;
  int8x16_t v37;
  int v40;
  uint64_t v41;
  int8x16_t v42;
  int8x16_t v43;
  int8x16_t v44;
  int16x8_t v45;
  const __int16 *v46;
  uint16x8_t v47;
  uint16x8_t v48;
  uint16x8_t v49;
  uint16x8_t v50;
  uint16x8_t v51;
  uint16x8_t v52;
  uint16x8_t v53;
  uint16x8_t v54;
  uint16x8_t v56;
  uint16x8_t v57;
  int16x8_t v58;
  uint16x8_t v59;
  int16x8_t v60;
  uint16x8_t v61;
  int8x16_t v62;
  int16x8_t v63;
  int16x8_t v64;
  int16x8_t v65;
  uint16x8_t v66;
  int8x16_t v67;
  uint16x8_t v68;
  int16x8_t v71;
  uint16x8_t v72;
  int8x16_t v73;
  int16x8_t v74;
  int16x8_t v75;
  uint16x8_t v76;
  int8x16_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int8x16_t v80;
  int8x16_t v81;

  v7 = *a3;
  if ((a4 & 4) != 0)
  {
    v10 = &_X5[-1].i16[7];
    v9 = (int8x16_t)vld1q_dup_s16(v10);
  }
  else
  {
    v8 = a5;
    v9 = (int8x16_t)vld1q_dup_s16(v8++);
    *a5 = *(_WORD *)(result + 126);
    _X5 = (int16x8_t *)result;
    result += 2 * a2;
    --a7;
    a5 = (__int16 *)v8;
  }
  v11 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v11 + 1] = *(_WORD *)(result + 2 * (v11 + 1) * a2 + 126);
  v12 = (int8x16_t)vdupq_n_s16(~a4);
  v13 = (int16x8_t)vandq_s8(v12, (int8x16_t)xmmword_1B6917470);
  v15 = *_X5;
  v14 = _X5[1];
  v16 = (int16x8_t)vandq_s8(v12, (int8x16_t)xmmword_1B69174C0);
  v18 = _X5[2];
  v17 = _X5[3];
  v20 = _X5[4];
  v19 = _X5[5];
  v22 = _X5[6];
  v21 = _X5[7];
  __asm
  {
    PRFM            #0, [X5,#0x80]
    PRFM            #0, [X5,#0xC0]
  }
  v29 = *(int8x16_t *)result;
  v30 = *(int8x16_t *)(result + 16);
  v31 = *(int8x16_t *)(result + 32);
  v32 = *(int8x16_t *)(result + 48);
  v33 = result + 96;
  v34 = *(int8x16_t *)(result + 96);
  v35 = *(int8x16_t *)(result + 64);
  v36 = *(int8x16_t *)(result + 80);
  v37 = *(int8x16_t *)(result + 112);
  __asm
  {
    PRFM            #0, [X0,#0x80]
    PRFM            #0, [X0,#0xC0]
  }
  v40 = v11 + 2;
  v41 = 2 * a2;
  v42 = (int8x16_t)vceqzq_s16(v16);
  v43 = (int8x16_t)vceqzq_s16(v13);
  v44.i64[0] = 0x202020202020202;
  v44.i64[1] = 0x202020202020202;
  v45.i64[0] = 0xFC00FC00FC00FC00;
  v45.i64[1] = 0xFC00FC00FC00FC00;
  v46 = a5;
  do
  {
    v47 = (uint16x8_t)vextq_s8((int8x16_t)v22, (int8x16_t)v21, 0xEuLL);
    v21 = (int16x8_t)v37;
    v48 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v22, 0xEuLL);
    v22 = (int16x8_t)v34;
    v49 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v19, 0xEuLL);
    v19 = (int16x8_t)v36;
    v50 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v20, 0xEuLL);
    v20 = (int16x8_t)v35;
    v51 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v17, 0xEuLL);
    v17 = (int16x8_t)v32;
    v52 = (uint16x8_t)vextq_s8((int8x16_t)v14, (int8x16_t)v18, 0xEuLL);
    v18 = (int16x8_t)v31;
    v53 = (uint16x8_t)vextq_s8((int8x16_t)v15, (int8x16_t)v14, 0xEuLL);
    v14 = (int16x8_t)v30;
    v54 = (uint16x8_t)vextq_s8(v9, (int8x16_t)v15, 0xEuLL);
    v15 = (int16x8_t)v29;
    _X12 = v33 + v41;
    v29 = *(int8x16_t *)(v33 + v41 - 96);
    v30 = *(int8x16_t *)(v33 + v41 - 80);
    v31 = *(int8x16_t *)(v33 + v41 - 64);
    v32 = *(int8x16_t *)(v33 + v41 - 48);
    v35 = *(int8x16_t *)(v33 + v41 - 32);
    v36 = *(int8x16_t *)(v33 + v41 - 16);
    v56 = (uint16x8_t)vextq_s8(v29, v30, 2uLL);
    v57 = (uint16x8_t)vextq_s8(v30, v31, 2uLL);
    v58 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v54, (uint16x8_t)v15), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v54)), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v56)), (int16x8_t)vcgtq_u16(v56, (uint16x8_t)v15));
    v59 = (uint16x8_t)vextq_s8(v31, v32, 2uLL);
    v60 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v53, (uint16x8_t)v14), (int16x8_t)vcgtq_u16((uint16x8_t)v14, v53)), (int16x8_t)vcgtq_u16((uint16x8_t)v14, v57)), (int16x8_t)vcgtq_u16(v57, (uint16x8_t)v14));
    v61 = (uint16x8_t)vextq_s8(v32, v35, 2uLL);
    v62 = vqmovn_high_s16(vqmovn_s16(v58), v60);
    v63 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v52, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v52)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v59)), (int16x8_t)vcgtq_u16(v59, (uint16x8_t)v18));
    v64 = vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v51, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v51)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v61));
    v34 = *(int8x16_t *)(v33 + 2 * a2);
    v37 = *(int8x16_t *)(v33 + v41 + 16);
    v65 = vaddq_s16(v64, (int16x8_t)vcgtq_u16(v61, (uint16x8_t)v17));
    v66 = (uint16x8_t)vextq_s8(v35, v36, 2uLL);
    v67 = vqmovn_high_s16(vqmovn_s16(v63), v65);
    v68 = (uint16x8_t)vextq_s8(v36, v34, 2uLL);
    __asm
    {
      PRFM            #0, [X12,#0x20]
      PRFM            #0, [X12,#0x60]
    }
    v71 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v49, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v49)), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v68)), (int16x8_t)vcgtq_u16(v68, (uint16x8_t)v19));
    v72 = (uint16x8_t)vextq_s8(v34, v37, 2uLL);
    v73 = vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v50, (uint16x8_t)v20), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v50)), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v66)), (int16x8_t)vcgtq_u16(v66, (uint16x8_t)v20))), v71);
    v74 = (int16x8_t)vcgtq_u16((uint16x8_t)v22, v72);
    v75 = vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v48, (uint16x8_t)v22), (int16x8_t)vcgtq_u16((uint16x8_t)v22, v48)), v74);
    v74.i16[0] = *(_WORD *)(v33 + v41 + 32);
    v76 = (uint16x8_t)vextq_s8(v37, (int8x16_t)v74, 2uLL);
    v77 = vqtbl1q_s8(v7, vaddq_s8(v62, v44));
    v78 = vqmovn_high_s16(vqmovn_s16(vaddq_s16(v75, (int16x8_t)vcgtq_u16(v72, (uint16x8_t)v22))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v47, (uint16x8_t)v21), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v47)), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v76)), (int16x8_t)vcgtq_u16(v76, (uint16x8_t)v21)));
    *(int8x16_t *)(v33 - 96) = vbslq_s8(v43, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v15, *(int8x8_t *)v77.i8), (int16x8_t)0), v45), (int8x16_t)v15);
    *(int16x8_t *)(v33 - 80) = vminq_s16(vmaxq_s16(vaddw_high_s8(v14, v77), (int16x8_t)0), v45);
    v79 = vqtbl1q_s8(v7, vaddq_s8(v67, v44));
    *(int16x8_t *)(v33 - 64) = vminq_s16(vmaxq_s16(vaddw_s8(v18, *(int8x8_t *)v79.i8), (int16x8_t)0), v45);
    *(int16x8_t *)(v33 - 48) = vminq_s16(vmaxq_s16(vaddw_high_s8(v17, v79), (int16x8_t)0), v45);
    v80 = vqtbl1q_s8(v7, vaddq_s8(v73, v44));
    *(int16x8_t *)(v33 - 32) = vminq_s16(vmaxq_s16(vaddw_s8(v20, *(int8x8_t *)v80.i8), (int16x8_t)0), v45);
    *(int16x8_t *)(v33 - 16) = vminq_s16(vmaxq_s16(vaddw_high_s8(v19, v80), (int16x8_t)0), v45);
    v81 = vqtbl1q_s8(v7, vaddq_s8(v78, v44));
    *(int16x8_t *)v33 = vminq_s16(vmaxq_s16(vaddw_s8(v22, *(int8x8_t *)v81.i8), (int16x8_t)0), v45);
    *(int8x16_t *)(v33 + 16) = vbslq_s8(v42, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v21, v81), (int16x8_t)0), v45), (int8x16_t)v21);
    v9 = (int8x16_t)vld1q_dup_s16(v46++);
    --v40;
    v33 += v41;
    *a5 = v21.i16[7];
    a5 = (__int16 *)v46;
  }
  while (v40 > 1);
  return result;
}

int8x16_t *sub_1B67B0874(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, char *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7;
  const char *v8;
  int8x16_t v9;
  const char *v10;
  int v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  const char *v34;
  uint8x16_t v35;
  uint8x16_t v36;
  uint8x16_t v37;
  uint8x16_t v38;
  uint8x16_t v39;
  uint8x16_t v42;
  uint8x16_t v43;
  uint8x16_t v44;
  uint8x16_t v45;
  uint8x16_t v46;
  int8x16_t v47;
  uint8x16_t v48;
  int8x16_t v49;

  v7 = *a3;
  if ((a4 & 4) != 0)
  {
    v10 = &_X5[-1].i8[15];
    v9 = vld1q_dup_s8(v10);
  }
  else
  {
    v8 = a5;
    v9 = vld1q_dup_s8(v8++);
    *a5 = result[3].i8[15];
    _X5 = result;
    result = (int8x16_t *)((char *)result + a2);
    --a7;
    a5 = (char *)v8;
  }
  v11 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v11 + 1] = result[3].i8[(v11 + 1) * a2 + 15];
  v12 = vdupq_n_s8(~a4);
  v13 = vandq_s8(v12, (int8x16_t)xmmword_1B6917470);
  v14 = vandq_s8(v12, (int8x16_t)xmmword_1B69174E0);
  v15 = *_X5;
  v16 = _X5[1];
  v18 = _X5[2];
  v17 = _X5[3];
  __asm { PRFM            #0, [X5,#0x40] }
  v24 = *result;
  v25 = result[1];
  v26 = result[2];
  v27 = result[3];
  __asm { PRFM            #0, [X0,#0x40] }
  v29 = v11 + 2;
  v30 = vceqzq_s8(v14);
  v31 = vceqzq_s8(v13);
  v32.i64[0] = 0x202020202020202;
  v32.i64[1] = 0x202020202020202;
  v33.i64[0] = 0x303030303030303;
  v33.i64[1] = 0x303030303030303;
  v34 = a5;
  do
  {
    v35 = (uint8x16_t)vextq_s8(v18, v17, 0xFuLL);
    v17 = v27;
    v36 = (uint8x16_t)v26;
    v37 = (uint8x16_t)v25;
    v38 = (uint8x16_t)vextq_s8(v9, v15, 0xFuLL);
    v39 = (uint8x16_t)vextq_s8(v15, v16, 0xFuLL);
    v15 = v24;
    _X10 = (uint64_t)result->i64 + a2;
    v24 = *(int8x16_t *)((char *)result + a2);
    v25 = *(int8x16_t *)((char *)&result[1] + a2);
    v26 = *(int8x16_t *)((char *)&result[2] + a2);
    v27 = *(int8x16_t *)((char *)&result[3] + a2);
    __asm { PRFM            #0, [X10,#0x40] }
    v9.i8[0] = result[4].i8[a2];
    v42 = (uint8x16_t)vextq_s8(v16, v18, 0xFuLL);
    v43 = (uint8x16_t)vextq_s8(v24, v25, 1uLL);
    v44 = (uint8x16_t)vextq_s8(v25, v26, 1uLL);
    v45 = (uint8x16_t)vextq_s8(v26, v27, 1uLL);
    v46 = (uint8x16_t)vextq_s8(v27, v9, 1uLL);
    v47 = (int8x16_t)vsqaddq_u8((uint8x16_t)v15, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v15, v38), v33, v32), (int8x16_t)vcgtq_u8(v38, (uint8x16_t)v15)), (int8x16_t)vcgtq_u8((uint8x16_t)v15, v43)), (int8x16_t)vcgtq_u8(v43, (uint8x16_t)v15))));
    v16 = (int8x16_t)v37;
    v48 = vsqaddq_u8(v37, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v37, v39), v33, v32), (int8x16_t)vcgtq_u8(v39, v37)), (int8x16_t)vcgtq_u8(v37, v44)), (int8x16_t)vcgtq_u8(v44, v37))));
    v49 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v36, v42), v33, v32), (int8x16_t)vcgtq_u8(v42, v36)), (int8x16_t)vcgtq_u8(v36, v45)), (int8x16_t)vcgtq_u8(v45, v36)));
    v18 = (int8x16_t)v36;
    *result = vbslq_s8(v31, v47, v15);
    result[1] = (int8x16_t)v48;
    result[2] = (int8x16_t)vsqaddq_u8(v36, v49);
    result[3] = vbslq_s8(v30, (int8x16_t)vsqaddq_u8((uint8x16_t)v17, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v17, v35), v33, v32), (int8x16_t)vcgtq_u8(v35, (uint8x16_t)v17)), (int8x16_t)vcgtq_u8((uint8x16_t)v17, v46)), (int8x16_t)vcgtq_u8(v46, (uint8x16_t)v17)))), v17);
    v9 = vld1q_dup_s8(v34++);
    --v29;
    *a5 = v17.i8[15];
    a5 = (char *)v34;
    result = (int8x16_t *)((char *)result + a2);
  }
  while (v29 > 1);
  return result;
}

uint64_t sub_1B67B0A40(uint64_t result, uint64_t a2, int8x16_t *a3, unsigned int a4, _WORD *a5, _OWORD *_X5, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  int16x8_t v9;
  int16x8_t v10;
  int16x8_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int8x16_t v18;
  const __int16 *v19;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  uint64_t v32;
  int8x16_t v33;
  uint64_t v34;
  int v35;
  int8x16_t v36;
  int8x16_t v38;
  int8x16_t v39;
  int8x16_t v41;
  int16x8_t v42;
  int8x16_t v43;
  __int16 *v44;
  const __int16 *v45;
  uint16x8_t v46;
  int16x8_t v47;
  uint16x8_t v48;
  uint16x8_t v49;
  uint16x8_t v50;
  uint16x8_t v51;
  uint16x8_t v52;
  uint16x8_t v53;
  int8x16_t v57;
  uint16x8_t v58;
  uint16x8_t v59;
  uint16x8_t v60;
  int16x8_t v61;
  uint16x8_t v62;
  int8x16_t v63;
  uint16x8_t v64;
  int16x8_t v65;
  uint16x8_t v66;
  int8x16_t v67;
  uint16x8_t v68;
  int16x8_t v69;
  uint16x8_t v70;
  int8x16_t v71;
  uint16x8_t v72;
  int8x16_t v73;
  int8x16_t v74;
  int8x16_t v75;
  int8x16_t v76;
  int8x16_t v77;
  const __int16 *v78;

  v7 = *a3;
  if ((~a4 & 9) == 0)
    a5[a7] = *(_WORD *)(result + 2 * a7 * a2 - 2);
  if ((a4 & 4) == 0)
  {
    *a5++ = *(_WORD *)(result + 126);
    _X5 = (_OWORD *)result;
    result += 2 * a2;
    --a7;
  }
  v8 = (int8x16_t)vdupq_n_s16(~a4);
  v9 = (int16x8_t)vandq_s8(v8, (int8x16_t)xmmword_1B6917470);
  v10 = (int16x8_t)vandq_s8(v8, (int8x16_t)xmmword_1B69174C0);
  v12 = *(int16x8_t *)_X5;
  v11 = *((int16x8_t *)_X5 + 1);
  v14 = *((int16x8_t *)_X5 + 2);
  v13 = *((int16x8_t *)_X5 + 3);
  v16 = *((int16x8_t *)_X5 + 4);
  v15 = *((int16x8_t *)_X5 + 5);
  v17 = *((int16x8_t *)_X5 + 6);
  v18 = *((int8x16_t *)_X5 + 7);
  v19 = (const __int16 *)(_X5 + 8);
  __asm
  {
    PRFM            #0, [X5,#0x80]
    PRFM            #0, [X5,#0xC0]
  }
  v26 = *(int8x16_t *)result;
  v27 = *(int8x16_t *)(result + 16);
  v28 = *(int8x16_t *)(result + 32);
  v29 = *(int8x16_t *)(result + 48);
  v30 = *(int8x16_t *)(result + 64);
  v31 = *(int8x16_t *)(result + 80);
  v32 = result + 96;
  v33 = *(int8x16_t *)(result + 96);
  v34 = 2 * a2;
  v35 = a7 + ((a4 >> 3) & 1);
  v36 = *(int8x16_t *)(result + 112);
  __asm { PRFM            #0, [X0,#0x80] }
  v38 = (int8x16_t)vceqzq_s16(v10);
  v39 = (int8x16_t)vceqzq_s16(v9);
  __asm { PRFM            #0, [X0,#0xC0] }
  v41.i64[0] = 0x202020202020202;
  v41.i64[1] = 0x202020202020202;
  v42.i64[0] = 0xFC00FC00FC00FC00;
  v42.i64[1] = 0xFC00FC00FC00FC00;
  v43 = (int8x16_t)vld1q_dup_s16(v19);
  *a5 = v36.i16[7];
  v44 = a5 + 1;
  v45 = v44;
  do
  {
    v46 = (uint16x8_t)vextq_s8((int8x16_t)v17, v18, 2uLL);
    v47 = (int16x8_t)v36;
    v48 = (uint16x8_t)vextq_s8((int8x16_t)v15, (int8x16_t)v17, 2uLL);
    v17 = (int16x8_t)v33;
    v49 = (uint16x8_t)vextq_s8((int8x16_t)v16, (int8x16_t)v15, 2uLL);
    v15 = (int16x8_t)v31;
    v50 = (uint16x8_t)vextq_s8((int8x16_t)v13, (int8x16_t)v16, 2uLL);
    v16 = (int16x8_t)v30;
    v51 = (uint16x8_t)vextq_s8((int8x16_t)v14, (int8x16_t)v13, 2uLL);
    v13 = (int16x8_t)v29;
    v52 = (uint16x8_t)vextq_s8((int8x16_t)v11, (int8x16_t)v14, 2uLL);
    v14 = (int16x8_t)v28;
    v53 = (uint16x8_t)vextq_s8((int8x16_t)v12, (int8x16_t)v11, 2uLL);
    v11 = (int16x8_t)v27;
    v12 = (int16x8_t)v26;
    _X12 = v32 + v34;
    v26 = *(int8x16_t *)(v32 + v34 - 96);
    v27 = *(int8x16_t *)(v32 + v34 - 80);
    v28 = *(int8x16_t *)(v32 + v34 - 64);
    v29 = *(int8x16_t *)(v32 + v34 - 48);
    v30 = *(int8x16_t *)(v32 + v34 - 32);
    v31 = *(int8x16_t *)(v32 + v34 - 16);
    v33 = *(int8x16_t *)(v32 + 2 * a2);
    v36 = *(int8x16_t *)(v32 + v34 + 16);
    __asm
    {
      PRFM            #0, [X12,#0x20]
      PRFM            #0, [X12,#0x60]
    }
    v57 = (int8x16_t)vld1q_dup_s16(v45++);
    v58 = (uint16x8_t)vextq_s8(v18, v43, 2uLL);
    v59 = (uint16x8_t)vextq_s8(v57, v26, 0xEuLL);
    v60 = (uint16x8_t)vextq_s8(v26, v27, 0xEuLL);
    v61 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v53, (uint16x8_t)v12), (int16x8_t)vcgtq_u16((uint16x8_t)v12, v53)), (int16x8_t)vcgtq_u16((uint16x8_t)v12, v59)), (int16x8_t)vcgtq_u16(v59, (uint16x8_t)v12));
    v62 = (uint16x8_t)vextq_s8(v27, v28, 0xEuLL);
    v63 = vqmovn_high_s16(vqmovn_s16(v61), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v52, (uint16x8_t)v11), (int16x8_t)vcgtq_u16((uint16x8_t)v11, v52)), (int16x8_t)vcgtq_u16((uint16x8_t)v11, v60)), (int16x8_t)vcgtq_u16(v60, (uint16x8_t)v11)));
    v64 = (uint16x8_t)vextq_s8(v28, v29, 0xEuLL);
    v65 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v51, (uint16x8_t)v14), (int16x8_t)vcgtq_u16((uint16x8_t)v14, v51)), (int16x8_t)vcgtq_u16((uint16x8_t)v14, v62)), (int16x8_t)vcgtq_u16(v62, (uint16x8_t)v14));
    v66 = (uint16x8_t)vextq_s8(v29, v30, 0xEuLL);
    v67 = vqmovn_high_s16(vqmovn_s16(v65), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v50, (uint16x8_t)v13), (int16x8_t)vcgtq_u16((uint16x8_t)v13, v50)), (int16x8_t)vcgtq_u16((uint16x8_t)v13, v64)), (int16x8_t)vcgtq_u16(v64, (uint16x8_t)v13)));
    v68 = (uint16x8_t)vextq_s8(v30, v31, 0xEuLL);
    v69 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v48, (uint16x8_t)v15), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v48)), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v68)), (int16x8_t)vcgtq_u16(v68, (uint16x8_t)v15));
    v70 = (uint16x8_t)vextq_s8(v31, v33, 0xEuLL);
    v71 = vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v49, (uint16x8_t)v16), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v49)), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v66)), (int16x8_t)vcgtq_u16(v66, (uint16x8_t)v16))), v69);
    v72 = (uint16x8_t)vextq_s8(v33, v36, 0xEuLL);
    *v44 = v36.i16[7];
    v73 = vqtbl1q_s8(v7, vaddq_s8(v63, v41));
    v74 = vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v46, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v46)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v70)), (int16x8_t)vcgtq_u16(v70, (uint16x8_t)v17))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v58, (uint16x8_t)v47), (int16x8_t)vcgtq_u16((uint16x8_t)v47, v58)), (int16x8_t)vcgtq_u16((uint16x8_t)v47, v72)), (int16x8_t)vcgtq_u16(v72, (uint16x8_t)v47)));
    *(int8x16_t *)(v32 - 96) = vbslq_s8(v39, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v12, *(int8x8_t *)v73.i8), (int16x8_t)0), v42), (int8x16_t)v12);
    *(int16x8_t *)(v32 - 80) = vminq_s16(vmaxq_s16(vaddw_high_s8(v11, v73), (int16x8_t)0), v42);
    v75 = vqtbl1q_s8(v7, vaddq_s8(v67, v41));
    *(int16x8_t *)(v32 - 64) = vminq_s16(vmaxq_s16(vaddw_s8(v14, *(int8x8_t *)v75.i8), (int16x8_t)0), v42);
    *(int16x8_t *)(v32 - 48) = vminq_s16(vmaxq_s16(vaddw_high_s8(v13, v75), (int16x8_t)0), v42);
    v76 = vqtbl1q_s8(v7, vaddq_s8(v71, v41));
    *(int16x8_t *)(v32 - 32) = vminq_s16(vmaxq_s16(vaddw_s8(v16, *(int8x8_t *)v76.i8), (int16x8_t)0), v42);
    *(int16x8_t *)(v32 - 16) = vminq_s16(vmaxq_s16(vaddw_high_s8(v15, v76), (int16x8_t)0), v42);
    v77 = vqtbl1q_s8(v7, vaddq_s8(v74, v41));
    *(int16x8_t *)v32 = vminq_s16(vmaxq_s16(vaddw_s8(v17, *(int8x8_t *)v77.i8), (int16x8_t)0), v42);
    *(int8x16_t *)(v32 + 16) = vbslq_s8(v38, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v47, v77), (int16x8_t)0), v42), (int8x16_t)v47);
    v78 = (const __int16 *)(v32 + 32);
    --v35;
    v32 += v34;
    v44 = (__int16 *)v45;
    v18 = (int8x16_t)v47;
    v43 = (int8x16_t)vld1q_dup_s16(v78);
  }
  while (v35 > 1);
  return result;
}

int8x16_t *sub_1B67B0D64(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _BYTE *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  const char *i8;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  const char *v25;
  int8x16_t v27;
  char *v28;
  int v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  const char *v34;
  uint8x16_t v35;
  int8x16_t v36;
  uint8x16_t v37;
  uint8x16_t v38;
  uint8x16_t v39;
  int8x16_t v42;
  uint8x16_t v43;
  uint8x16_t v44;
  uint8x16_t v45;
  uint8x16_t v46;
  uint8x16_t v47;
  uint8x16_t v48;
  int8x16_t v49;
  int8x16_t v50;
  uint8x16_t v51;
  int8x16_t v52;

  v7 = *a3;
  if ((~a4 & 9) == 0)
    a5[a7] = result->i8[a7 * a2 - 1];
  if ((a4 & 4) == 0)
  {
    *a5++ = result[3].i8[15];
    _X5 = result;
    result = (int8x16_t *)((char *)result + a2);
    --a7;
  }
  v8 = vdupq_n_s8(~a4);
  v9 = vandq_s8(v8, (int8x16_t)xmmword_1B6917470);
  v10 = vandq_s8(v8, (int8x16_t)xmmword_1B69174E0);
  v12 = *_X5;
  v11 = _X5[1];
  v13 = _X5[2];
  v14 = _X5[3];
  i8 = _X5[4].i8;
  __asm { PRFM            #0, [X5,#0x40] }
  v21 = *result;
  v22 = result[1];
  v23 = result[2];
  v24 = result[3];
  v25 = result[4].i8;
  __asm { PRFM            #0, [X0,#0x40] }
  v27 = vld1q_dup_s8(i8);
  *a5 = v24.i8[15];
  v28 = a5 + 1;
  v29 = a7 + ((a4 >> 3) & 1);
  v30 = vceqzq_s8(v10);
  v31 = vceqzq_s8(v9);
  v32.i64[0] = 0x202020202020202;
  v32.i64[1] = 0x202020202020202;
  v33.i64[0] = 0x303030303030303;
  v33.i64[1] = 0x303030303030303;
  v34 = v28;
  do
  {
    v35 = (uint8x16_t)vextq_s8(v13, v14, 1uLL);
    v36 = v24;
    v37 = (uint8x16_t)v23;
    v38 = (uint8x16_t)v22;
    v39 = (uint8x16_t)vextq_s8(v12, v11, 1uLL);
    v12 = v21;
    _X11 = &v25[a2];
    v21 = *(int8x16_t *)&v25[a2 - 64];
    v22 = *(int8x16_t *)&v25[a2 - 48];
    v23 = *(int8x16_t *)&v25[a2 - 32];
    v24 = *(int8x16_t *)&v25[a2 - 16];
    __asm { PRFM            #0, [X11] }
    v42 = vld1q_dup_s8(v34++);
    *v28 = v24.i8[15];
    v43 = (uint8x16_t)vextq_s8(v14, v27, 1uLL);
    v44 = (uint8x16_t)vextq_s8(v11, v13, 1uLL);
    v45 = (uint8x16_t)vextq_s8(v42, v21, 0xFuLL);
    v46 = (uint8x16_t)vextq_s8(v21, v22, 0xFuLL);
    v47 = (uint8x16_t)vextq_s8(v22, v23, 0xFuLL);
    v48 = (uint8x16_t)vextq_s8(v23, v24, 0xFuLL);
    v49 = (int8x16_t)vsqaddq_u8((uint8x16_t)v12, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v12, v39), v33, v32), (int8x16_t)vcgtq_u8(v39, (uint8x16_t)v12)), (int8x16_t)vcgtq_u8((uint8x16_t)v12, v45)), (int8x16_t)vcgtq_u8(v45, (uint8x16_t)v12))));
    v50 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v38, v44), v33, v32), (int8x16_t)vcgtq_u8(v44, v38)), (int8x16_t)vcgtq_u8(v38, v46)), (int8x16_t)vcgtq_u8(v46, v38)));
    v11 = (int8x16_t)v38;
    v51 = vsqaddq_u8(v38, v50);
    v13 = (int8x16_t)v37;
    v52 = vbslq_s8(v30, (int8x16_t)vsqaddq_u8((uint8x16_t)v36, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v36, v43), v33, v32), (int8x16_t)vcgtq_u8(v43, (uint8x16_t)v36)), (int8x16_t)vcgtq_u8((uint8x16_t)v36, v48)), (int8x16_t)vcgtq_u8(v48, (uint8x16_t)v36)))), v36);
    *((int8x16_t *)v25 - 4) = vbslq_s8(v31, v49, v12);
    *((uint8x16_t *)v25 - 3) = v51;
    v27 = vld1q_dup_s8(v25);
    --v29;
    *((uint8x16_t *)v25 - 2) = vsqaddq_u8(v37, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v37, v35), v33, v32), (int8x16_t)vcgtq_u8(v35, v37)), (int8x16_t)vcgtq_u8(v37, v47)), (int8x16_t)vcgtq_u8(v47, v37))));
    *((int8x16_t *)v25 - 1) = v52;
    v25 += a2;
    v28 = (char *)v34;
    v14 = v36;
  }
  while (v29 > 1);
  return result;
}

int16x8_t *sub_1B67B0F2C(int16x8_t *result, uint64_t a2, __int128 *a3, uint64_t a4, _WORD *a5, uint64_t a6, int a7)
{
  __int128 v7;
  __int128 v8;
  int v9;
  int16x8_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int8x16_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int8x16_t v29;
  int16x8_t v30;
  int16x8_t v31;
  int8x16_t v32;
  int16x8_t v33;
  int16x8_t v34;
  int8x16_t v35;

  v7 = *a3;
  v8 = a3[1];
  v9 = a7 + 1;
  _X9 = result + 6;
  v11.i64[0] = 0xFC00FC00FC00FC00;
  v11.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    v12 = _X9[-6];
    v13 = _X9[-5];
    v14 = _X9[-4];
    v15 = _X9[-3];
    v16 = _X9[-2];
    v17 = _X9[-1];
    v18 = *_X9;
    v19 = _X9[1];
    __asm
    {
      PRFM            #0, [X9,#0x20]
      PRFM            #0, [X9,#0x60]
    }
    *a5++ = v19.i16[7];
    v26 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v12, 5uLL), v13, 5uLL));
    v27 = vminq_s16(vmaxq_s16(vaddw_s8(v12, *(int8x8_t *)v26.i8), (int16x8_t)0), v11);
    v28 = vminq_s16(vmaxq_s16(vaddw_high_s8(v13, v26), (int16x8_t)0), v11);
    v29 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v14, 5uLL), v15, 5uLL));
    v30 = vminq_s16(vmaxq_s16(vaddw_s8(v14, *(int8x8_t *)v29.i8), (int16x8_t)0), v11);
    v31 = vminq_s16(vmaxq_s16(vaddw_high_s8(v15, v29), (int16x8_t)0), v11);
    v32 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v16, 5uLL), v17, 5uLL));
    v33 = vminq_s16(vmaxq_s16(vaddw_s8(v16, *(int8x8_t *)v32.i8), (int16x8_t)0), v11);
    v34 = vminq_s16(vmaxq_s16(vaddw_high_s8(v17, v32), (int16x8_t)0), v11);
    v35 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v18, 5uLL), v19, 5uLL));
    _X9[-6] = v27;
    _X9[-5] = v28;
    _X9[-4] = v30;
    _X9[-3] = v31;
    _X9[-2] = v33;
    _X9[-1] = v34;
    *_X9 = vminq_s16(vmaxq_s16(vaddw_s8(v18, *(int8x8_t *)v35.i8), (int16x8_t)0), v11);
    _X9[1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v19, v35), (int16x8_t)0), v11);
    --v9;
    _X9 = (int16x8_t *)((char *)_X9 + 2 * a2);
  }
  while (v9 > 1);
  return result;
}

uint8x16_t *sub_1B67B1014(uint8x16_t *result, uint64_t a2, __int128 *a3, uint64_t a4, _BYTE *a5, uint64_t a6, int a7)
{
  __int128 v7;
  __int128 v8;
  int v10;
  uint8x16_t v11;
  uint8x16_t v12;
  uint8x16_t v13;
  uint8x16_t v14;

  v7 = *a3;
  v8 = a3[1];
  _X8 = result + 2;
  v10 = a7 + 1;
  do
  {
    v11 = _X8[-2];
    v12 = _X8[-1];
    v13 = *_X8;
    v14 = _X8[1];
    __asm { PRFM            #0, [X8,#0x20] }
    *a5++ = v14.i8[15];
    _X8[-2] = vsqaddq_u8(v11, vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8(v11, 3uLL)));
    _X8[-1] = vsqaddq_u8(v12, vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8(v12, 3uLL)));
    *_X8 = vsqaddq_u8(v13, vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8(v13, 3uLL)));
    _X8[1] = vsqaddq_u8(v14, vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8(v14, 3uLL)));
    _X8 = (uint8x16_t *)((char *)_X8 + a2);
    --v10;
  }
  while (v10 > 1);
  return result;
}

int16x8_t *sub_1B67B107C(int16x8_t *result, uint64_t a2, unint64_t *a3, int a4, float *a5, int8x16_t a6, uint64_t a7, int a8)
{
  int16x8_t v8;
  int v10;
  int8x16_t v11;
  int16x8_t v12;
  const float *v13;
  int16x8_t v14;
  int8x16_t v20;
  uint16x8_t v21;
  uint16x8_t v22;
  int16x8_t v23;

  a6.i64[0] = *a3;
  _X8 = result + 1;
  v10 = a8 + 1;
  v11 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_n_s16(~a4), (int8x16_t)xmmword_1B69174F0));
  v12.i64[0] = 0xFC00FC00FC00FC00;
  v12.i64[1] = 0xFC00FC00FC00FC00;
  v13 = a5;
  do
  {
    v14 = _X8[-1];
    __asm { PRFM            #0, [X8] }
    v20 = (int8x16_t)vld1q_dup_f32(v13++);
    v21 = (uint16x8_t)vextq_s8(v20, (int8x16_t)v14, 0xCuLL);
    *a5 = *(float *)&v14.i32[3];
    v8.i32[0] = _X8->i32[0];
    v22 = (uint16x8_t)vextq_s8((int8x16_t)v14, (int8x16_t)v8, 4uLL);
    v23 = (int16x8_t)vcgtq_u16((uint16x8_t)v14, v22);
    v8 = (int16x8_t)vcgtq_u16(v22, (uint16x8_t)v14);
    _X8[-1] = (int16x8_t)vbslq_s8(v11, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v14, vqtbl1_s8(a6, (int8x8_t)vqmovn_u16((uint16x8_t)vaddq_s16(vsubq_s16(vaddq_s16((int16x8_t)vbslq_s8((int8x16_t)vcgtq_u16((uint16x8_t)v14, v21), (int8x16_t)xmmword_1B6917510, (int8x16_t)xmmword_1B6917500), (int16x8_t)vcgtq_u16(v21, (uint16x8_t)v14)), v23), v8)))),
                                          (int16x8_t)0),
                                        v12),
                           (int8x16_t)v14);
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v10;
    a5 = (float *)v13;
  }
  while (v10 > 1);
  return result;
}

int8x8_t *sub_1B67B1130(int8x8_t *result, uint64_t a2, uint64_t *a3, int a4, __int16 *a5, double a6, double a7, double a8, double a9, double a10, double a11, int8x8_t a12, uint64_t a13, int a14)
{
  int8x16_t v14;
  int v16;
  int8x8_t v17;
  const __int16 *v18;
  int8x8_t v19;
  int8x8_t v25;
  uint8x8_t v26;
  uint8x8_t v27;

  v14.i64[0] = *a3;
  v14.i64[1] = a3[4];
  _X8 = result + 1;
  v16 = a14 + 1;
  v17 = vceqz_s8(vand_s8(vdup_n_s8(~a4), (int8x8_t)0x202000000000101));
  v18 = a5;
  do
  {
    v19 = _X8[-1];
    __asm { PRFM            #0, [X8] }
    v25 = (int8x8_t)vld1_dup_s16(v18++);
    v26 = (uint8x8_t)vext_s8(v25, v19, 6uLL);
    *a5 = v19.i16[3];
    a12.i16[0] = _X8->i16[0];
    v27 = (uint8x8_t)vext_s8(v19, a12, 2uLL);
    a12 = (int8x8_t)vsqadd_u8((uint8x8_t)v19, vqtbl1_s8(v14, vadd_s8(vsub_s8(vadd_s8(vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)v19, v26), (int8x8_t)0xB030B030B030B03, (int8x8_t)0xA020A020A020A02), (int8x8_t)vcgt_u8(v26, (uint8x8_t)v19)), (int8x8_t)vcgt_u8((uint8x8_t)v19, v27)), (int8x8_t)vcgt_u8(v27, (uint8x8_t)v19))));
    _X8[-1] = vbsl_s8(v17, a12, v19);
    _X8 = (int8x8_t *)((char *)_X8 + a2);
    --v16;
    a5 = (__int16 *)v18;
  }
  while (v16 > 1);
  return result;
}

uint16x8_t *sub_1B67B11D8(uint16x8_t *result, uint64_t a2, unint64_t *a3, unsigned int a4, _DWORD *a5, uint16x8_t *a6, int a7, int8x16_t a8)
{
  int v8;
  uint16x8_t v10;
  uint16x8_t v11;
  int16x8_t v18;
  uint64_t v20;
  int v21;
  int16x8_t v22;
  uint16x8_t v24;

  a8.i64[0] = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i32[3];
    a6 = result;
    result = (uint16x8_t *)((char *)result + 2 * a2);
    --a7;
  }
  v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = *(__int32 *)((char *)&result->i32[3] + 2 * (v8 + 1) * a2);
  v10 = *a6;
  _X5 = a6 + 1;
  v11 = v10;
  __asm { PRFM            #0, [X5] }
  _X8 = result + 1;
  v18 = *(int16x8_t *)result;
  __asm { PRFM            #0, [X8] }
  v20 = 2 * a2;
  v21 = v8 + 2;
  v22.i64[0] = 0xFC00FC00FC00FC00;
  v22.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    _X11 = (uint64_t)result[1].i64 + v20;
    v24 = *(uint16x8_t *)((char *)result + 2 * a2);
    __asm { PRFM            #0, [X11] }
    *a5++ = v18.i32[3];
    --v21;
    *(int16x8_t *)result = vminq_s16(vmaxq_s16(vaddw_s8(v18, vqtbl1_s8(a8, (int8x8_t)vqmovn_u16((uint16x8_t)vaddq_s16(vsubq_s16(vaddq_s16((int16x8_t)vbslq_s8((int8x16_t)vcgtq_u16((uint16x8_t)v18, v11), (int8x16_t)xmmword_1B6917510, (int8x16_t)xmmword_1B6917500), (int16x8_t)vcgtq_u16(v11, (uint16x8_t)v18)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v24)), (int16x8_t)vcgtq_u16(v24, (uint16x8_t)v18))))), (int16x8_t)0), v22);
    result = (uint16x8_t *)((char *)result + v20);
    v11 = (uint16x8_t)v18;
    v18 = (int16x8_t)v24;
  }
  while (v21 > 1);
  return result;
}

uint8x8_t *sub_1B67B12BC(uint8x8_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, uint8x8_t *a6, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  int v9;
  uint8x8_t v11;
  uint8x8_t v12;
  uint8x8_t v19;
  int v21;
  uint8x8_t v23;
  int8x8_t v25;

  v7.i64[0] = *a3;
  v8 = a3[4];
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i16[3];
    a6 = result;
    result = (uint8x8_t *)((char *)result + a2);
    --a7;
  }
  v7.i64[1] = v8;
  v9 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v9 + 1] = *(__int16 *)((char *)&result->i16[3] + (v9 + 1) * a2);
  v11 = *a6;
  _X5 = a6 + 1;
  v12 = v11;
  __asm { PRFM            #0, [X5] }
  _X9 = result + 1;
  v19 = *result;
  __asm { PRFM            #0, [X9] }
  v21 = v9 + 2;
  do
  {
    _X10 = (uint64_t)&result[1] + a2;
    v23 = *(uint8x8_t *)((char *)result + a2);
    __asm { PRFM            #0, [X10] }
    *a5++ = v19.i16[3];
    v25 = vqtbl1_s8(v7, vadd_s8(vsub_s8(vadd_s8(vbsl_s8((int8x8_t)vcgt_u8(v19, v12), (int8x8_t)0xB030B030B030B03, (int8x8_t)0xA020A020A020A02), (int8x8_t)vcgt_u8(v12, v19)), (int8x8_t)vcgt_u8(v19, v23)), (int8x8_t)vcgt_u8(v23, v19)));
    v12 = v19;
    *result = vsqadd_u8(v19, v25);
    --v21;
    v19 = v23;
    result = (uint8x8_t *)((char *)result + a2);
  }
  while (v21 > 1);
  return result;
}

uint64_t sub_1B67B1384(uint64_t result, uint64_t a2, unint64_t *a3, unsigned int a4, float *a5, int8x16_t *a6, int a7, int8x16_t a8)
{
  int16x8_t v8;
  const float *v9;
  int8x16_t v10;
  const float *v11;
  int v12;
  int8x16_t v14;
  int8x16_t v15;
  int16x8_t v22;
  uint64_t v24;
  int v25;
  int8x16_t v26;
  int16x8_t v27;
  const float *v28;
  int8x16_t v30;
  uint16x8_t v32;
  uint16x8_t v33;

  a8.i64[0] = *a3;
  if ((a4 & 4) != 0)
  {
    v11 = (const float *)&a6[-1].i32[3];
    v10 = (int8x16_t)vld1q_dup_f32(v11);
  }
  else
  {
    v9 = a5;
    v10 = (int8x16_t)vld1q_dup_f32(v9++);
    *a5 = *(float *)(result + 12);
    a6 = (int8x16_t *)result;
    result += 2 * a2;
    --a7;
    a5 = (float *)v9;
  }
  v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = *(float *)(result + 2 * (v12 + 1) * a2 + 12);
  v14 = *a6;
  _X5 = a6 + 1;
  v15 = v14;
  __asm { PRFM            #0, [X5] }
  _X8 = result + 16;
  v22 = *(int16x8_t *)result;
  __asm { PRFM            #0, [X8] }
  v24 = 2 * a2;
  v25 = v12 + 2;
  v26 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_n_s16(~a4), (int8x16_t)xmmword_1B69174F0));
  v27.i64[0] = 0xFC00FC00FC00FC00;
  v27.i64[1] = 0xFC00FC00FC00FC00;
  v28 = a5;
  do
  {
    _X11 = result + v24;
    v30 = *(int8x16_t *)(result + 2 * a2);
    __asm { PRFM            #0, [X11,#0x10] }
    v8.i32[0] = *(_DWORD *)(result + v24 + 16);
    v32 = (uint16x8_t)vextq_s8(v10, v15, 0xCuLL);
    v33 = (uint16x8_t)vextq_s8(v30, (int8x16_t)v8, 4uLL);
    v8 = (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u16((uint16x8_t)v22, v32), (int8x16_t)xmmword_1B6917510, (int8x16_t)xmmword_1B6917500);
    *(int8x16_t *)result = vbslq_s8(v26, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v22, vqtbl1_s8(a8, (int8x8_t)vqmovn_u16((uint16x8_t)vaddq_s16(vsubq_s16(vaddq_s16(v8, (int16x8_t)vcgtq_u16(v32, (uint16x8_t)v22)), (int16x8_t)vcgtq_u16((uint16x8_t)v22, v33)), (int16x8_t)vcgtq_u16(v33,
                                                                                                (uint16x8_t)v22))))),
                                            (int16x8_t)0),
                                          v27),
                             (int8x16_t)v22);
    v10 = (int8x16_t)vld1q_dup_f32(v28++);
    --v25;
    result += v24;
    *a5 = *(float *)&v22.i32[3];
    v15 = (int8x16_t)v22;
    v22 = (int16x8_t)v30;
    a5 = (float *)v28;
  }
  while (v25 > 1);
  return result;
}

int8x8_t *sub_1B67B14B0(int8x8_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, __int16 *a5, int8x8_t *a6, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  const __int16 *v9;
  int8x8_t v10;
  const __int16 *v11;
  int v12;
  int8x8_t v14;
  int8x8_t v15;
  int8x8_t v22;
  int v24;
  int8x8_t v25;
  const __int16 *v26;
  int8x8_t v28;
  uint8x8_t v30;
  uint8x8_t v31;

  v7.i64[0] = *a3;
  v8 = a3[4];
  if ((a4 & 4) != 0)
  {
    v11 = (const __int16 *)&a6[-1] + 3;
    v10 = (int8x8_t)vld1q_dup_s16(v11).u64[0];
  }
  else
  {
    v9 = a5;
    v10 = (int8x8_t)vld1q_dup_s16(v9++).u64[0];
    *a5 = result->i16[3];
    a6 = result;
    result = (int8x8_t *)((char *)result + a2);
    --a7;
    a5 = (__int16 *)v9;
  }
  v7.i64[1] = v8;
  v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = *(__int16 *)((char *)&result->i16[3] + (v12 + 1) * a2);
  v14 = *a6;
  _X5 = a6 + 1;
  v15 = v14;
  __asm { PRFM            #0, [X5] }
  _X9 = result + 1;
  v22 = *result;
  __asm { PRFM            #0, [X9] }
  v24 = v12 + 2;
  v25 = vceqz_s8(vand_s8(vdup_n_s8(~a4), (int8x8_t)0x202000000000101));
  v26 = a5;
  do
  {
    _X10 = (char *)result + a2;
    v28 = *(int8x8_t *)((char *)result + a2);
    __asm { PRFM            #0, [X10,#8] }
    v30 = (uint8x8_t)vext_s8(v10, v15, 6uLL);
    v15.i16[0] = *(__int16 *)((char *)result[1].i16 + a2);
    v31 = (uint8x8_t)vext_s8(v28, v15, 2uLL);
    *result = vbsl_s8(v25, (int8x8_t)vsqadd_u8((uint8x8_t)v22, vqtbl1_s8(v7, vadd_s8(vsub_s8(vadd_s8(vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)v22, v30), (int8x8_t)0xB030B030B030B03, (int8x8_t)0xA020A020A020A02), (int8x8_t)vcgt_u8(v30, (uint8x8_t)v22)), (int8x8_t)vcgt_u8((uint8x8_t)v22, v31)), (int8x8_t)vcgt_u8(v31, (uint8x8_t)v22)))), v22);
    v10 = (int8x8_t)vld1q_dup_s16(v26++).u64[0];
    --v24;
    v15 = v22;
    *a5 = v22.i16[3];
    v22 = v28;
    a5 = (__int16 *)v26;
    result = (int8x8_t *)((char *)result + a2);
  }
  while (v24 > 1);
  return result;
}

uint64_t sub_1B67B15C8(uint64_t result, uint64_t a2, unint64_t *a3, unsigned int a4, _DWORD *a5, _OWORD *_X5, int a7, int8x16_t a8)
{
  int8x16_t v8;
  const float *v9;
  int16x8_t v16;
  int8x16_t v18;
  float *v19;
  uint64_t v20;
  signed int v21;
  int8x16_t v22;
  int16x8_t v23;
  const float *v24;
  int8x16_t v26;
  int8x16_t v28;
  uint16x8_t v29;
  uint16x8_t v30;
  const float *v31;

  a8.i64[0] = *a3;
  a5[a7] = *(_DWORD *)(result + 2 * a7 * a2 - 4);
  if ((a4 & 4) == 0)
  {
    *a5++ = *(_DWORD *)(result + 12);
    _X5 = (_OWORD *)result;
    result += 2 * a2;
    --a7;
  }
  v8 = *(int8x16_t *)_X5;
  v9 = (const float *)(_X5 + 1);
  __asm { PRFM            #0, [X5,#0x10] }
  _X10 = result + 16;
  v16 = *(int16x8_t *)result;
  __asm { PRFM            #0, [X10] }
  v18 = (int8x16_t)vld1q_dup_f32(v9);
  *a5 = HIDWORD(*(_OWORD *)result);
  v19 = (float *)(a5 + 1);
  v20 = 2 * a2;
  v21 = a7 + ((a4 >> 3) | 0xFFFFFFFE) + 2;
  v22 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_n_s16(~a4), (int8x16_t)xmmword_1B69174F0));
  v23.i64[0] = 0xFC00FC00FC00FC00;
  v23.i64[1] = 0xFC00FC00FC00FC00;
  v24 = v19;
  do
  {
    _X12 = result + v20 + 16;
    v26 = *(int8x16_t *)(result + 2 * a2);
    __asm { PRFM            #0, [X12] }
    v28 = (int8x16_t)vld1q_dup_f32(v24++);
    *v19 = *(float *)&v26.i32[3];
    v29 = (uint16x8_t)vextq_s8(v8, v18, 4uLL);
    v30 = (uint16x8_t)vextq_s8(v28, v26, 0xCuLL);
    *(int8x16_t *)result = vbslq_s8(v22, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v16, vqtbl1_s8(a8, (int8x8_t)vqmovn_u16((uint16x8_t)vaddq_s16(vsubq_s16(vaddq_s16((int16x8_t)vbslq_s8((int8x16_t)vcgtq_u16((uint16x8_t)v16, v29), (int8x16_t)xmmword_1B6917510, (int8x16_t)xmmword_1B6917500), (int16x8_t)vcgtq_u16(v29, (uint16x8_t)v16)), (int16x8_t)vcgtq_u16((uint16x8_t)v16,
                                                                                                  v30)),
                                                                                   (int16x8_t)vcgtq_u16(v30, (uint16x8_t)v16))))), (int16x8_t)0), v23), (int8x16_t)v16);
    v31 = (const float *)(result + 16);
    --v21;
    result += v20;
    v18 = (int8x16_t)vld1q_dup_f32(v31);
    v19 = (float *)v24;
    v8 = (int8x16_t)v16;
    v16 = (int16x8_t)v26;
  }
  while (v21 > 1);
  return result;
}

int8x8_t *sub_1B67B16EC(int8x8_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, int8x8_t *_X5, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  int8x8_t v9;
  const __int16 *v10;
  int8x8_t v17;
  int8x8_t v19;
  __int16 *v20;
  signed int v21;
  int8x8_t v22;
  const __int16 *v23;
  int8x8_t v25;
  int8x8_t v27;
  uint8x8_t v28;
  uint8x8_t v29;
  const __int16 *v30;

  v7.i64[0] = *a3;
  v8 = a3[4];
  a5[a7] = *(__int16 *)((char *)&result->i16[-1] + a7 * a2);
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i16[3];
    _X5 = result;
    result = (int8x8_t *)((char *)result + a2);
    --a7;
  }
  v7.i64[1] = v8;
  v9 = *_X5;
  v10 = (const __int16 *)&_X5[1];
  __asm { PRFM            #0, [X5,#8] }
  _X10 = result + 1;
  v17 = *result;
  __asm { PRFM            #0, [X10] }
  v19 = (int8x8_t)vld1q_dup_s16(v10).u64[0];
  *a5 = HIWORD(*(unint64_t *)result);
  v20 = a5 + 1;
  v21 = a7 + ((a4 >> 3) | 0xFFFFFFFE) + 2;
  v22 = vceqz_s8(vand_s8(vdup_n_s8(~a4), (int8x8_t)0x202000000000101));
  v23 = v20;
  do
  {
    _X11 = (uint64_t)&result[1] + a2;
    v25 = *(int8x8_t *)((char *)result + a2);
    __asm { PRFM            #0, [X11] }
    v27 = (int8x8_t)vld1_dup_s16(v23++);
    *v20 = v25.i16[3];
    v28 = (uint8x8_t)vext_s8(v9, v19, 2uLL);
    v29 = (uint8x8_t)vext_s8(v27, v25, 6uLL);
    *result = vbsl_s8(v22, (int8x8_t)vsqadd_u8((uint8x8_t)v17, vqtbl1_s8(v7, vadd_s8(vsub_s8(vadd_s8(vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)v17, v28), (int8x8_t)0xB030B030B030B03, (int8x8_t)0xA020A020A020A02), (int8x8_t)vcgt_u8(v28, (uint8x8_t)v17)), (int8x8_t)vcgt_u8((uint8x8_t)v17, v29)), (int8x8_t)vcgt_u8(v29, (uint8x8_t)v17)))), v17);
    v30 = (const __int16 *)&result[1];
    --v21;
    v20 = (__int16 *)v23;
    v19 = (int8x8_t)vld1q_dup_s16(v30).u64[0];
    v9 = v17;
    v17 = v25;
    result = (int8x8_t *)((char *)result + a2);
  }
  while (v21 > 1);
  return result;
}

int16x8_t *sub_1B67B17FC(int16x8_t *result, uint64_t a2, uint64_t *a3, int a4, float *a5, uint64_t a6, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int16x8_t v10;
  int v12;
  int8x16_t v13;
  int8x16_t v14;
  int16x8_t v15;
  const float *v16;
  int16x8_t v17;
  int16x8_t v18;
  int8x16_t v24;
  uint16x8_t v25;
  uint16x8_t v26;
  uint16x8_t v27;
  uint16x8_t v28;
  int8x16_t v29;

  v8.i64[0] = *a3;
  v8.i64[1] = a3[4];
  v9 = (int8x16_t)vdupq_n_s16(~a4);
  v10 = (int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1B69174F0);
  _X8 = result + 2;
  v12 = a7 + 1;
  v13 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1B6917520));
  v14 = (int8x16_t)vceqzq_s16(v10);
  v15.i64[0] = 0xFC00FC00FC00FC00;
  v15.i64[1] = 0xFC00FC00FC00FC00;
  v16 = a5;
  do
  {
    v17 = _X8[-2];
    v18 = _X8[-1];
    __asm { PRFM            #0, [X8] }
    v24 = (int8x16_t)vld1q_dup_f32(v16++);
    *a5 = *(float *)&v18.i32[3];
    v7.i32[0] = _X8->i32[0];
    v25 = (uint16x8_t)vextq_s8(v24, (int8x16_t)v17, 0xCuLL);
    v26 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v18, 0xCuLL);
    v27 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v18, 4uLL);
    v28 = (uint16x8_t)vextq_s8((int8x16_t)v18, v7, 4uLL);
    v29 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v27, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v27)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v25)), (int16x8_t)vcgtq_u16(v25, (uint16x8_t)v17))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v26, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v26)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v28)), (int16x8_t)vcgtq_u16(v28, (uint16x8_t)v18))), (int8x16_t)xmmword_1B6917530));
    v7 = (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v17, *(int8x8_t *)v29.i8), (int16x8_t)0), v15);
    _X8[-2] = (int16x8_t)vbslq_s8(v14, v7, (int8x16_t)v17);
    _X8[-1] = (int16x8_t)vbslq_s8(v13, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v18, v29), (int16x8_t)0), v15), (int8x16_t)v18);
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v12;
    a5 = (float *)v16;
  }
  while (v12 > 1);
  return result;
}

uint64_t sub_1B67B18F8(uint64_t result, uint64_t a2, uint64_t *a3, int a4, __int16 *a5, double a6, double a7, double a8, double a9, double a10, double a11, int8x16_t a12, uint64_t a13, int a14)
{
  int8x16_t v14;
  int v16;
  int8x16_t v17;
  const __int16 *v18;
  int8x16_t v19;
  int8x16_t v25;
  uint8x16_t v26;
  uint8x16_t v27;

  v14.i64[0] = *a3;
  v14.i64[1] = a3[4];
  _X8 = (unsigned __int16 *)(result + 16);
  v16 = a14 + 1;
  v17 = vceqzq_s8(vandq_s8(vdupq_n_s8(~a4), (int8x16_t)xmmword_1B6917540));
  v18 = a5;
  do
  {
    v19 = *((int8x16_t *)_X8 - 1);
    __asm { PRFM            #0, [X8] }
    v25 = (int8x16_t)vld1q_dup_s16(v18++);
    v26 = (uint8x16_t)vextq_s8(v25, v19, 0xEuLL);
    *a5 = v19.i16[7];
    a12.i16[0] = *_X8;
    v27 = (uint8x16_t)vextq_s8(v19, a12, 2uLL);
    a12 = (int8x16_t)vsqaddq_u8((uint8x16_t)v19, vqtbl1q_s8(v14, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v19, v26), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v26, (uint8x16_t)v19)), (int8x16_t)vcgtq_u8((uint8x16_t)v19, v27)), (int8x16_t)vcgtq_u8(v27, (uint8x16_t)v19))));
    *((int8x16_t *)_X8 - 1) = vbslq_s8(v17, a12, v19);
    _X8 = (unsigned __int16 *)((char *)_X8 + a2);
    --v16;
    a5 = (__int16 *)v18;
  }
  while (v16 > 1);
  return result;
}

uint16x8_t *sub_1B67B19A0(uint16x8_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _DWORD *a5, uint16x8_t *_X5, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  int v9;
  uint16x8_t v10;
  uint16x8_t v11;
  uint16x8_t v17;
  uint16x8_t v18;
  uint64_t v20;
  int v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int8x16_t v27;

  v7.i64[0] = *a3;
  v8 = a3[4];
  if ((a4 & 4) == 0)
  {
    *a5++ = result[1].i32[3];
    _X5 = result;
    result = (uint16x8_t *)((char *)result + 2 * a2);
    --a7;
  }
  v7.i64[1] = v8;
  v9 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v9 + 1] = *(__int32 *)((char *)&result[1].i32[3] + 2 * (v9 + 1) * a2);
  v11 = *_X5;
  v10 = _X5[1];
  __asm { PRFM            #0, [X5,#0x20] }
  v17 = *result;
  v18 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  v20 = 2 * a2;
  v21 = v9 + 2;
  v22.i64[0] = 0xFC00FC00FC00FC00;
  v22.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    v23 = (int16x8_t)v17;
    v24 = (int16x8_t)v18;
    _X10 = (uint64_t)result->i64 + v20;
    v17 = *(uint16x8_t *)((char *)result + 2 * a2);
    v18 = *(uint16x8_t *)((char *)&result[1] + v20);
    __asm { PRFM            #0, [X10,#0x20] }
    *a5++ = v24.i32[3];
    v27 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v11, (uint16x8_t)v23), (int16x8_t)vcgtq_u16((uint16x8_t)v23, v11)), (int16x8_t)vcgtq_u16((uint16x8_t)v23, v17)), (int16x8_t)vcgtq_u16(v17, (uint16x8_t)v23))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v10, (uint16x8_t)v24), (int16x8_t)vcgtq_u16((uint16x8_t)v24, v10)), (int16x8_t)vcgtq_u16((uint16x8_t)v24, v18)), (int16x8_t)vcgtq_u16(v18, (uint16x8_t)v24))), (int8x16_t)xmmword_1B6917530));
    --v21;
    *(int16x8_t *)result = vminq_s16(vmaxq_s16(vaddw_s8(v23, *(int8x8_t *)v27.i8), (int16x8_t)0), v22);
    result[1] = (uint16x8_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v24, v27), (int16x8_t)0), v22);
    result = (uint16x8_t *)((char *)result + v20);
    v11 = (uint16x8_t)v23;
    v10 = (uint16x8_t)v24;
  }
  while (v21 > 1);
  return result;
}

uint8x16_t *sub_1B67B1AB0(uint8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, uint8x16_t *a6, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  int v9;
  uint8x16_t v11;
  uint8x16_t v12;
  uint8x16_t v19;
  int v21;
  uint8x16_t v23;
  int8x16_t v25;

  v7.i64[0] = *a3;
  v8 = a3[4];
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i16[7];
    a6 = result;
    result = (uint8x16_t *)((char *)result + a2);
    --a7;
  }
  v7.i64[1] = v8;
  v9 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v9 + 1] = *(__int16 *)((char *)&result->i16[7] + (v9 + 1) * a2);
  v11 = *a6;
  _X5 = a6 + 1;
  v12 = v11;
  __asm { PRFM            #0, [X5] }
  _X9 = result + 1;
  v19 = *result;
  __asm { PRFM            #0, [X9] }
  v21 = v9 + 2;
  do
  {
    _X10 = (uint64_t)result[1].i64 + a2;
    v23 = *(uint8x16_t *)((char *)result + a2);
    __asm { PRFM            #0, [X10] }
    *a5++ = v19.i16[7];
    v25 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v19, v12), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v12, v19)), (int8x16_t)vcgtq_u8(v19, v23)), (int8x16_t)vcgtq_u8(v23, v19)));
    v12 = v19;
    *result = vsqaddq_u8(v19, v25);
    --v21;
    v19 = v23;
    result = (uint8x16_t *)((char *)result + a2);
  }
  while (v21 > 1);
  return result;
}

uint64_t sub_1B67B1B78(uint64_t result, uint64_t a2, uint64_t *a3, unsigned int a4, float *a5, _OWORD *_X5, int a7)
{
  int16x8_t v7;
  int8x16_t v8;
  uint64_t v9;
  const float *v10;
  int8x16_t v11;
  const float *v12;
  int v13;
  int8x16_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int8x16_t v18;
  int8x16_t v24;
  int8x16_t v25;
  uint64_t v27;
  int v28;
  int8x16_t v29;
  int8x16_t v30;
  int16x8_t v31;
  const float *v32;
  uint16x8_t v33;
  int16x8_t v34;
  uint16x8_t v35;
  uint16x8_t v38;
  uint16x8_t v39;
  int16x8_t v40;
  int8x16_t v41;

  v8.i64[0] = *a3;
  v9 = a3[4];
  if ((a4 & 4) != 0)
  {
    v12 = (const float *)_X5 - 1;
    v11 = (int8x16_t)vld1q_dup_f32(v12);
  }
  else
  {
    v10 = a5;
    v11 = (int8x16_t)vld1q_dup_f32(v10++);
    *a5 = *(float *)(result + 28);
    _X5 = (_OWORD *)result;
    result += 2 * a2;
    --a7;
    a5 = (float *)v10;
  }
  v8.i64[1] = v9;
  v13 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v13 + 1] = *(float *)(result + 2 * (v13 + 1) * a2 + 28);
  v14 = (int8x16_t)vdupq_n_s16(~a4);
  v15 = (int16x8_t)vandq_s8(v14, (int8x16_t)xmmword_1B69174F0);
  v16 = (int16x8_t)vandq_s8(v14, (int8x16_t)xmmword_1B6917520);
  v17 = *(int16x8_t *)_X5;
  v18 = *((int8x16_t *)_X5 + 1);
  __asm { PRFM            #0, [X5,#0x20] }
  v24 = *(int8x16_t *)result;
  v25 = *(int8x16_t *)(result + 16);
  __asm { PRFM            #0, [X0,#0x20] }
  v27 = 2 * a2;
  v28 = v13 + 2;
  v29 = (int8x16_t)vceqzq_s16(v16);
  v30 = (int8x16_t)vceqzq_s16(v15);
  v31.i64[0] = 0xFC00FC00FC00FC00;
  v31.i64[1] = 0xFC00FC00FC00FC00;
  v32 = a5;
  do
  {
    v33 = (uint16x8_t)vextq_s8((int8x16_t)v17, v18, 0xCuLL);
    v34 = (int16x8_t)v25;
    v35 = (uint16x8_t)vextq_s8(v11, (int8x16_t)v17, 0xCuLL);
    v17 = (int16x8_t)v24;
    _X11 = result + v27;
    v24 = *(int8x16_t *)(result + 2 * a2);
    v25 = *(int8x16_t *)(result + v27 + 16);
    __asm { PRFM            #0, [X11,#0x20] }
    v7.i32[0] = *(_DWORD *)(result + v27 + 32);
    v38 = (uint16x8_t)vextq_s8(v24, v25, 4uLL);
    v39 = (uint16x8_t)vextq_s8(v25, (int8x16_t)v7, 4uLL);
    v40 = (int16x8_t)vcgtq_u16((uint16x8_t)v34, v39);
    v7 = (int16x8_t)vcgtq_u16(v39, (uint16x8_t)v34);
    v41 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v35, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v35)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v38)), (int16x8_t)vcgtq_u16(v38, (uint16x8_t)v17))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v33, (uint16x8_t)v34), (int16x8_t)vcgtq_u16((uint16x8_t)v34, v33)), v40), v7)), (int8x16_t)xmmword_1B6917530));
    *(int8x16_t *)result = vbslq_s8(v30, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v17, *(int8x8_t *)v41.i8), (int16x8_t)0), v31), (int8x16_t)v17);
    *(int8x16_t *)(result + 16) = vbslq_s8(v29, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v34, v41), (int16x8_t)0), v31), (int8x16_t)v34);
    v11 = (int8x16_t)vld1q_dup_f32(v32++);
    --v28;
    result += v27;
    *a5 = *(float *)&v34.i32[3];
    v18 = (int8x16_t)v34;
    a5 = (float *)v32;
  }
  while (v28 > 1);
  return result;
}

int8x16_t *sub_1B67B1CEC(int8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, __int16 *a5, int8x16_t *a6, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  uint64_t v9;
  const __int16 *v10;
  int8x16_t v11;
  const __int16 *v12;
  int v13;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v23;
  int v25;
  int8x16_t v26;
  const __int16 *v27;
  int8x16_t v29;
  uint8x16_t v31;
  uint8x16_t v32;

  v8.i64[0] = *a3;
  v9 = a3[4];
  if ((a4 & 4) != 0)
  {
    v12 = &a6[-1].i16[7];
    v11 = (int8x16_t)vld1q_dup_s16(v12);
  }
  else
  {
    v10 = a5;
    v11 = (int8x16_t)vld1q_dup_s16(v10++);
    *a5 = result->i16[7];
    a6 = result;
    result = (int8x16_t *)((char *)result + a2);
    --a7;
    a5 = (__int16 *)v10;
  }
  v8.i64[1] = v9;
  v13 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v13 + 1] = *(__int16 *)((char *)&result->i16[7] + (v13 + 1) * a2);
  v15 = *a6;
  _X5 = a6 + 1;
  v16 = v15;
  __asm { PRFM            #0, [X5] }
  _X9 = result + 1;
  v23 = *result;
  __asm { PRFM            #0, [X9] }
  v25 = v13 + 2;
  v26 = vceqzq_s8(vandq_s8(vdupq_n_s8(~a4), (int8x16_t)xmmword_1B6917540));
  v27 = a5;
  do
  {
    _X10 = (uint64_t)result->i64 + a2;
    v29 = *(int8x16_t *)((char *)result + a2);
    __asm { PRFM            #0, [X10,#0x10] }
    v7.i16[0] = *(__int16 *)((char *)result[1].i16 + a2);
    v31 = (uint8x16_t)vextq_s8(v11, v16, 0xEuLL);
    v32 = (uint8x16_t)vextq_s8(v29, v7, 2uLL);
    v7 = vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v23, v31), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530);
    *result = vbslq_s8(v26, (int8x16_t)vsqaddq_u8((uint8x16_t)v23, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(v7, (int8x16_t)vcgtq_u8(v31, (uint8x16_t)v23)), (int8x16_t)vcgtq_u8((uint8x16_t)v23, v32)), (int8x16_t)vcgtq_u8(v32, (uint8x16_t)v23)))), v23);
    v11 = (int8x16_t)vld1q_dup_s16(v27++);
    --v25;
    v16 = v23;
    *a5 = v23.i16[7];
    v23 = v29;
    a5 = (__int16 *)v27;
    result = (int8x16_t *)((char *)result + a2);
  }
  while (v25 > 1);
  return result;
}

uint64_t sub_1B67B1E04(uint64_t result, uint64_t a2, uint64_t *a3, unsigned int a4, _DWORD *a5, _OWORD *_X5, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  int8x16_t v9;
  int16x8_t v10;
  int8x16_t v11;
  int8x16_t v12;
  const float *v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v22;
  float *v23;
  uint64_t v24;
  signed int v25;
  int8x16_t v26;
  int8x16_t v27;
  int16x8_t v28;
  const float *v29;
  uint16x8_t v30;
  int16x8_t v31;
  int16x8_t v32;
  int8x16_t v35;
  uint16x8_t v36;
  uint16x8_t v37;
  uint16x8_t v38;
  int8x16_t v39;
  const float *v40;

  v7.i64[0] = *a3;
  v8 = a3[4];
  a5[a7] = *(_DWORD *)(result + 2 * a7 * a2 - 4);
  if ((a4 & 4) == 0)
  {
    *a5++ = *(_DWORD *)(result + 28);
    _X5 = (_OWORD *)result;
    result += 2 * a2;
    --a7;
  }
  v7.i64[1] = v8;
  v9 = (int8x16_t)vdupq_n_s16(~a4);
  v10 = (int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1B69174F0);
  v12 = *(int8x16_t *)_X5;
  v11 = *((int8x16_t *)_X5 + 1);
  __asm { PRFM            #0, [X5,#0x20] }
  v18 = (const float *)(_X5 + 2);
  v19 = *(int8x16_t *)result;
  v20 = *(int8x16_t *)(result + 16);
  __asm { PRFM            #0, [X0,#0x20] }
  v22 = (int8x16_t)vld1q_dup_f32(v18);
  *a5 = v20.i32[3];
  v23 = (float *)(a5 + 1);
  v24 = 2 * a2;
  v25 = a7 + ((a4 >> 3) | 0xFFFFFFFE) + 2;
  v26 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1B6917520));
  v27 = (int8x16_t)vceqzq_s16(v10);
  v28.i64[0] = 0xFC00FC00FC00FC00;
  v28.i64[1] = 0xFC00FC00FC00FC00;
  v29 = v23;
  do
  {
    v30 = (uint16x8_t)vextq_s8(v12, v11, 4uLL);
    v31 = (int16x8_t)v20;
    v32 = (int16x8_t)v19;
    _X11 = result + v24;
    v19 = *(int8x16_t *)(result + 2 * a2);
    v20 = *(int8x16_t *)(result + v24 + 16);
    __asm { PRFM            #0, [X11,#0x20] }
    v35 = (int8x16_t)vld1q_dup_f32(v29++);
    v36 = (uint16x8_t)vextq_s8(v11, v22, 4uLL);
    *v23 = *(float *)&v20.i32[3];
    v37 = (uint16x8_t)vextq_s8(v35, v19, 0xCuLL);
    v38 = (uint16x8_t)vextq_s8(v19, v20, 0xCuLL);
    v39 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v30, (uint16x8_t)v32), (int16x8_t)vcgtq_u16((uint16x8_t)v32, v30)), (int16x8_t)vcgtq_u16((uint16x8_t)v32, v37)), (int16x8_t)vcgtq_u16(v37, (uint16x8_t)v32))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v36, (uint16x8_t)v31), (int16x8_t)vcgtq_u16((uint16x8_t)v31, v36)), (int16x8_t)vcgtq_u16((uint16x8_t)v31, v38)), (int16x8_t)vcgtq_u16(v38, (uint16x8_t)v31))), (int8x16_t)xmmword_1B6917530));
    *(int8x16_t *)result = vbslq_s8(v27, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v32, *(int8x8_t *)v39.i8), (int16x8_t)0), v28), (int8x16_t)v32);
    *(int8x16_t *)(result + 16) = vbslq_s8(v26, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v31, v39), (int16x8_t)0), v28), (int8x16_t)v31);
    v40 = (const float *)(result + 32);
    --v25;
    result += v24;
    v22 = (int8x16_t)vld1q_dup_f32(v40);
    v23 = (float *)v29;
    v12 = (int8x16_t)v32;
    v11 = (int8x16_t)v31;
  }
  while (v25 > 1);
  return result;
}

int8x16_t *sub_1B67B1F70(int8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  int8x16_t v9;
  const __int16 *i16;
  int8x16_t v17;
  int8x16_t v19;
  __int16 *v20;
  signed int v21;
  int8x16_t v22;
  const __int16 *v23;
  int8x16_t v25;
  int8x16_t v27;
  uint8x16_t v28;
  uint8x16_t v29;
  const __int16 *v30;

  v7.i64[0] = *a3;
  v8 = a3[4];
  a5[a7] = *(__int16 *)((char *)&result->i16[-1] + a7 * a2);
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i16[7];
    _X5 = result;
    result = (int8x16_t *)((char *)result + a2);
    --a7;
  }
  v7.i64[1] = v8;
  v9 = *_X5;
  i16 = _X5[1].i16;
  __asm { PRFM            #0, [X5,#0x10] }
  _X10 = result + 1;
  v17 = *result;
  __asm { PRFM            #0, [X10] }
  v19 = (int8x16_t)vld1q_dup_s16(i16);
  *a5 = HIWORD(*(unsigned __int128 *)result);
  v20 = a5 + 1;
  v21 = a7 + ((a4 >> 3) | 0xFFFFFFFE) + 2;
  v22 = vceqzq_s8(vandq_s8(vdupq_n_s8(~a4), (int8x16_t)xmmword_1B6917540));
  v23 = v20;
  do
  {
    _X11 = (uint64_t)result[1].i64 + a2;
    v25 = *(int8x16_t *)((char *)result + a2);
    __asm { PRFM            #0, [X11] }
    v27 = (int8x16_t)vld1q_dup_s16(v23++);
    *v20 = v25.i16[7];
    v28 = (uint8x16_t)vextq_s8(v9, v19, 2uLL);
    v29 = (uint8x16_t)vextq_s8(v27, v25, 0xEuLL);
    *result = vbslq_s8(v22, (int8x16_t)vsqaddq_u8((uint8x16_t)v17, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v17, v28), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v28, (uint8x16_t)v17)), (int8x16_t)vcgtq_u8((uint8x16_t)v17, v29)), (int8x16_t)vcgtq_u8(v29, (uint8x16_t)v17)))), v17);
    v30 = result[1].i16;
    --v21;
    v20 = (__int16 *)v23;
    v19 = (int8x16_t)vld1q_dup_s16(v30);
    v9 = v17;
    v17 = v25;
    result = (int8x16_t *)((char *)result + a2);
  }
  while (v21 > 1);
  return result;
}

int16x8_t *sub_1B67B2080(int16x8_t *result, uint64_t a2, uint64_t *a3, int a4, float *a5, uint64_t a6, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int16x8_t v10;
  int v12;
  int8x16_t v13;
  int8x16_t v14;
  int16x8_t v15;
  const float *v16;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int8x16_t v26;
  uint16x8_t v27;
  uint16x8_t v28;
  uint16x8_t v29;
  uint16x8_t v30;
  uint16x8_t v31;
  uint16x8_t v32;
  uint16x8_t v33;
  uint16x8_t v34;
  int8x16_t v35;
  int8x16_t v36;
  int16x8_t v37;

  v8.i64[0] = *a3;
  v8.i64[1] = a3[4];
  v9 = (int8x16_t)vdupq_n_s16(~a4);
  v10 = (int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1B69174F0);
  _X8 = result + 2;
  v12 = a7 + 1;
  v13 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1B6917520));
  v14 = (int8x16_t)vceqzq_s16(v10);
  v15.i64[0] = 0xFC00FC00FC00FC00;
  v15.i64[1] = 0xFC00FC00FC00FC00;
  v16 = a5;
  do
  {
    v17 = _X8[-2];
    v18 = _X8[-1];
    v20 = *_X8;
    v19 = _X8[1];
    __asm { PRFM            #0, [X8,#0x20] }
    v26 = (int8x16_t)vld1q_dup_f32(v16++);
    *a5 = *(float *)&v19.i32[3];
    v7.i32[0] = _X8[2].i32[0];
    v27 = (uint16x8_t)vextq_s8(v26, (int8x16_t)v17, 0xCuLL);
    v28 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v18, 0xCuLL);
    v29 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v20, 0xCuLL);
    v30 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v19, 0xCuLL);
    v31 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v18, 4uLL);
    v32 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v20, 4uLL);
    v33 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v19, 4uLL);
    v34 = (uint16x8_t)vextq_s8((int8x16_t)v19, v7, 4uLL);
    v35 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v31, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v31)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v27)), (int16x8_t)vcgtq_u16(v27, (uint16x8_t)v17))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v28, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v28)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v32)), (int16x8_t)vcgtq_u16(v32, (uint16x8_t)v18))), (int8x16_t)xmmword_1B6917530));
    v36 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v29, (uint16x8_t)v20), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v29)), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v33)), (int16x8_t)vcgtq_u16(v33, (uint16x8_t)v20))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v30, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v30)), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v34)), (int16x8_t)vcgtq_u16(v34, (uint16x8_t)v19))), (int8x16_t)xmmword_1B6917530));
    v37 = vaddw_s8(v20, *(int8x8_t *)v36.i8);
    v7 = (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v19, v36), (int16x8_t)0), v15);
    _X8[-2] = (int16x8_t)vbslq_s8(v14, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v17, *(int8x8_t *)v35.i8), (int16x8_t)0), v15), (int8x16_t)v17);
    _X8[-1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v18, v35), (int16x8_t)0), v15);
    *_X8 = vminq_s16(vmaxq_s16(v37, (int16x8_t)0), v15);
    _X8[1] = (int16x8_t)vbslq_s8(v13, v7, (int8x16_t)v19);
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v12;
    a5 = (float *)v16;
  }
  while (v12 > 1);
  return result;
}

int8x16_t *sub_1B67B21F4(int8x16_t *result, uint64_t a2, uint64_t *a3, int a4, __int16 *a5, uint64_t a6, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int v12;
  int8x16_t v13;
  int8x16_t v14;
  const __int16 *v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v23;
  uint8x16_t v24;
  uint8x16_t v25;
  uint8x16_t v26;
  uint8x16_t v27;

  v8.i64[0] = *a3;
  v8.i64[1] = a3[4];
  v9 = vdupq_n_s8(~a4);
  v10 = vandq_s8(v9, (int8x16_t)xmmword_1B6917560);
  _X8 = result + 2;
  v12 = a7 + 1;
  v13 = vceqzq_s8(vandq_s8(v9, (int8x16_t)xmmword_1B6917570));
  v14 = vceqzq_s8(v10);
  v15 = a5;
  do
  {
    v16 = _X8[-2];
    v17 = _X8[-1];
    __asm { PRFM            #0, [X8] }
    v23 = (int8x16_t)vld1q_dup_s16(v15++);
    *a5 = v17.i16[7];
    v7.i16[0] = _X8->i16[0];
    v24 = (uint8x16_t)vextq_s8(v23, v16, 0xEuLL);
    v25 = (uint8x16_t)vextq_s8(v16, v17, 0xEuLL);
    v26 = (uint8x16_t)vextq_s8(v16, v17, 2uLL);
    v27 = (uint8x16_t)vextq_s8(v17, v7, 2uLL);
    v7 = (int8x16_t)vsqaddq_u8((uint8x16_t)v17, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v17, v25), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v25, (uint8x16_t)v17)), (int8x16_t)vcgtq_u8((uint8x16_t)v17, v27)), (int8x16_t)vcgtq_u8(v27, (uint8x16_t)v17))));
    _X8[-2] = vbslq_s8(v14, (int8x16_t)vsqaddq_u8((uint8x16_t)v16, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v16, v26), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v26, (uint8x16_t)v16)), (int8x16_t)vcgtq_u8((uint8x16_t)v16, v24)), (int8x16_t)vcgtq_u8(v24, (uint8x16_t)v16)))), v16);
    _X8[-1] = vbslq_s8(v13, v7, v17);
    _X8 = (int8x16_t *)((char *)_X8 + a2);
    --v12;
    a5 = (__int16 *)v15;
  }
  while (v12 > 1);
  return result;
}

uint16x8_t *sub_1B67B22E4(uint16x8_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _DWORD *a5, uint16x8_t *_X5, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  int v9;
  uint16x8_t v10;
  uint16x8_t v11;
  uint16x8_t v12;
  uint16x8_t v13;
  uint16x8_t v19;
  uint16x8_t v20;
  uint16x8_t v21;
  uint16x8_t v22;
  int v24;
  uint64_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int8x16_t v33;
  int8x16_t v34;

  v7.i64[0] = *a3;
  v8 = a3[4];
  if ((a4 & 4) == 0)
  {
    *a5++ = result[3].i32[3];
    _X5 = result;
    result = (uint16x8_t *)((char *)result + 2 * a2);
    --a7;
  }
  v7.i64[1] = v8;
  v9 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v9 + 1] = *(__int32 *)((char *)&result[3].i32[3] + 2 * (v9 + 1) * a2);
  v11 = *_X5;
  v10 = _X5[1];
  v13 = _X5[2];
  v12 = _X5[3];
  __asm { PRFM            #0, [X5,#0x40] }
  v19 = *result;
  v20 = result[1];
  v21 = result[2];
  v22 = result[3];
  __asm { PRFM            #0, [X0,#0x40] }
  v24 = v9 + 2;
  v25 = 2 * a2;
  v26.i64[0] = 0xFC00FC00FC00FC00;
  v26.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    v27 = (int16x8_t)v19;
    v28 = (int16x8_t)v20;
    v29 = (int16x8_t)v21;
    v30 = (int16x8_t)v22;
    _X10 = (uint64_t)result->i64 + v25;
    v19 = *(uint16x8_t *)((char *)result + 2 * a2);
    v20 = *(uint16x8_t *)((char *)&result[1] + v25);
    v21 = *(uint16x8_t *)((char *)&result[2] + v25);
    v22 = *(uint16x8_t *)((char *)&result[3] + v25);
    __asm { PRFM            #0, [X10,#0x40] }
    *a5++ = v30.i32[3];
    v33 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v11, (uint16x8_t)v27), (int16x8_t)vcgtq_u16((uint16x8_t)v27, v11)), (int16x8_t)vcgtq_u16((uint16x8_t)v27, v19)), (int16x8_t)vcgtq_u16(v19, (uint16x8_t)v27))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v10, (uint16x8_t)v28), (int16x8_t)vcgtq_u16((uint16x8_t)v28, v10)), (int16x8_t)vcgtq_u16((uint16x8_t)v28, v20)), (int16x8_t)vcgtq_u16(v20, (uint16x8_t)v28))), (int8x16_t)xmmword_1B6917530));
    v34 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v13, (uint16x8_t)v29), (int16x8_t)vcgtq_u16((uint16x8_t)v29, v13)), (int16x8_t)vcgtq_u16((uint16x8_t)v29, v21)), (int16x8_t)vcgtq_u16(v21, (uint16x8_t)v29))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v12, (uint16x8_t)v30), (int16x8_t)vcgtq_u16((uint16x8_t)v30, v12)), (int16x8_t)vcgtq_u16((uint16x8_t)v30, v22)), (int16x8_t)vcgtq_u16(v22, (uint16x8_t)v30))), (int8x16_t)xmmword_1B6917530));
    *(int16x8_t *)result = vminq_s16(vmaxq_s16(vaddw_s8(v27, *(int8x8_t *)v33.i8), (int16x8_t)0), v26);
    result[1] = (uint16x8_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v28, v33), (int16x8_t)0), v26);
    result[2] = (uint16x8_t)vminq_s16(vmaxq_s16(vaddw_s8(v29, *(int8x8_t *)v34.i8), (int16x8_t)0), v26);
    result[3] = (uint16x8_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v30, v34), (int16x8_t)0), v26);
    --v24;
    result = (uint16x8_t *)((char *)result + v25);
    v11 = (uint16x8_t)v27;
    v10 = (uint16x8_t)v28;
    v13 = (uint16x8_t)v29;
    v12 = (uint16x8_t)v30;
  }
  while (v24 > 1);
  return result;
}

uint8x16_t *sub_1B67B2474(uint8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, uint8x16_t *_X5, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  int v9;
  uint8x16_t v10;
  uint8x16_t v11;
  uint8x16_t v17;
  uint8x16_t v18;
  int v20;
  uint8x16_t v21;
  uint8x16_t v22;
  int8x16_t v25;
  uint8x16_t v26;
  int8x16_t v27;

  v7.i64[0] = *a3;
  v8 = a3[4];
  if ((a4 & 4) == 0)
  {
    *a5++ = result[1].i16[7];
    _X5 = result;
    result = (uint8x16_t *)((char *)result + a2);
    --a7;
  }
  v7.i64[1] = v8;
  v9 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v9 + 1] = *(__int16 *)((char *)&result[1].i16[7] + (v9 + 1) * a2);
  v11 = *_X5;
  v10 = _X5[1];
  __asm { PRFM            #0, [X5,#0x20] }
  v17 = *result;
  v18 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  v20 = v9 + 2;
  do
  {
    v21 = v17;
    v22 = v18;
    _X9 = (uint64_t)result->i64 + a2;
    v17 = *(uint8x16_t *)((char *)result + a2);
    v18 = *(uint8x16_t *)((char *)&result[1] + a2);
    __asm { PRFM            #0, [X9,#0x20] }
    *a5++ = v22.i16[7];
    v25 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v21, v11), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v11, v21)), (int8x16_t)vcgtq_u8(v21, v17)), (int8x16_t)vcgtq_u8(v17, v21)));
    v11 = v21;
    v26 = vsqaddq_u8(v21, v25);
    v27 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v22, v10), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v10, v22)), (int8x16_t)vcgtq_u8(v22, v18)), (int8x16_t)vcgtq_u8(v18, v22)));
    v10 = v22;
    *result = v26;
    result[1] = vsqaddq_u8(v22, v27);
    --v20;
    result = (uint8x16_t *)((char *)result + a2);
  }
  while (v20 > 1);
  return result;
}

uint64_t sub_1B67B2564(uint64_t result, uint64_t a2, uint64_t *a3, unsigned int a4, float *a5, int16x8_t *_X5, int a7)
{
  int16x8_t v7;
  int8x16_t v8;
  uint64_t v9;
  const float *v10;
  int8x16_t v11;
  const float *v12;
  int v13;
  int8x16_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int v31;
  uint64_t v32;
  int8x16_t v33;
  int8x16_t v34;
  int16x8_t v35;
  const float *v36;
  uint16x8_t v37;
  uint16x8_t v38;
  uint16x8_t v39;
  uint16x8_t v40;
  uint16x8_t v43;
  uint16x8_t v44;
  uint16x8_t v45;
  uint16x8_t v46;
  int8x16_t v47;
  int16x8_t v48;
  int8x16_t v49;

  v8.i64[0] = *a3;
  v9 = a3[4];
  if ((a4 & 4) != 0)
  {
    v12 = (const float *)&_X5[-1].i32[3];
    v11 = (int8x16_t)vld1q_dup_f32(v12);
  }
  else
  {
    v10 = a5;
    v11 = (int8x16_t)vld1q_dup_f32(v10++);
    *a5 = *(float *)(result + 60);
    _X5 = (int16x8_t *)result;
    result += 2 * a2;
    --a7;
    a5 = (float *)v10;
  }
  v8.i64[1] = v9;
  v13 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v13 + 1] = *(float *)(result + 2 * (v13 + 1) * a2 + 60);
  v14 = (int8x16_t)vdupq_n_s16(~a4);
  v15 = (int16x8_t)vandq_s8(v14, (int8x16_t)xmmword_1B69174F0);
  v16 = (int16x8_t)vandq_s8(v14, (int8x16_t)xmmword_1B6917520);
  v18 = *_X5;
  v17 = _X5[1];
  v20 = _X5[2];
  v19 = _X5[3];
  __asm { PRFM            #0, [X5,#0x40] }
  v26 = *(int8x16_t *)result;
  v27 = *(int8x16_t *)(result + 16);
  v28 = *(int8x16_t *)(result + 32);
  v29 = *(int8x16_t *)(result + 48);
  __asm { PRFM            #0, [X0,#0x40] }
  v31 = v13 + 2;
  v32 = 2 * a2;
  v33 = (int8x16_t)vceqzq_s16(v16);
  v34 = (int8x16_t)vceqzq_s16(v15);
  v35.i64[0] = 0xFC00FC00FC00FC00;
  v35.i64[1] = 0xFC00FC00FC00FC00;
  v36 = a5;
  do
  {
    v37 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v19, 0xCuLL);
    v19 = (int16x8_t)v29;
    v38 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v20, 0xCuLL);
    v20 = (int16x8_t)v28;
    v39 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v17, 0xCuLL);
    v17 = (int16x8_t)v27;
    v40 = (uint16x8_t)vextq_s8(v11, (int8x16_t)v18, 0xCuLL);
    v18 = (int16x8_t)v26;
    _X11 = result + v32;
    v26 = *(int8x16_t *)(result + 2 * a2);
    v27 = *(int8x16_t *)(result + v32 + 16);
    v28 = *(int8x16_t *)(result + v32 + 32);
    v29 = *(int8x16_t *)(result + v32 + 48);
    __asm { PRFM            #0, [X11,#0x40] }
    v7.i32[0] = *(_DWORD *)(result + v32 + 64);
    v43 = (uint16x8_t)vextq_s8(v26, v27, 4uLL);
    v44 = (uint16x8_t)vextq_s8(v27, v28, 4uLL);
    v45 = (uint16x8_t)vextq_s8(v28, v29, 4uLL);
    v46 = (uint16x8_t)vextq_s8(v29, (int8x16_t)v7, 4uLL);
    v47 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v40, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v40)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v43)), (int16x8_t)vcgtq_u16(v43, (uint16x8_t)v18))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v39, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v39)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v44)), (int16x8_t)vcgtq_u16(v44, (uint16x8_t)v17))), (int8x16_t)xmmword_1B6917530));
    v48 = (int16x8_t)vcgtq_u16((uint16x8_t)v19, v46);
    v7 = (int16x8_t)vcgtq_u16(v46, (uint16x8_t)v19);
    v49 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v38, (uint16x8_t)v20), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v38)), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v45)), (int16x8_t)vcgtq_u16(v45, (uint16x8_t)v20))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v37, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v37)), v48), v7)), (int8x16_t)xmmword_1B6917530));
    *(int8x16_t *)result = vbslq_s8(v34, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v18, *(int8x8_t *)v47.i8), (int16x8_t)0), v35), (int8x16_t)v18);
    *(int16x8_t *)(result + 16) = vminq_s16(vmaxq_s16(vaddw_high_s8(v17, v47), (int16x8_t)0), v35);
    *(int16x8_t *)(result + 32) = vminq_s16(vmaxq_s16(vaddw_s8(v20, *(int8x8_t *)v49.i8), (int16x8_t)0), v35);
    *(int8x16_t *)(result + 48) = vbslq_s8(v33, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v19, v49), (int16x8_t)0), v35), (int8x16_t)v19);
    v11 = (int8x16_t)vld1q_dup_f32(v36++);
    --v31;
    result += v32;
    *a5 = *(float *)&v19.i32[3];
    a5 = (float *)v36;
  }
  while (v31 > 1);
  return result;
}

int8x16_t *sub_1B67B275C(int8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, __int16 *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  uint64_t v9;
  const __int16 *v10;
  int8x16_t v11;
  const __int16 *v12;
  int v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v24;
  int8x16_t v25;
  int v27;
  int8x16_t v28;
  int8x16_t v29;
  const __int16 *v30;
  uint8x16_t v31;
  int8x16_t v32;
  uint8x16_t v33;
  uint8x16_t v36;
  uint8x16_t v37;
  int8x16_t v38;

  v8.i64[0] = *a3;
  v9 = a3[4];
  if ((a4 & 4) != 0)
  {
    v12 = &_X5[-1].i16[7];
    v11 = (int8x16_t)vld1q_dup_s16(v12);
  }
  else
  {
    v10 = a5;
    v11 = (int8x16_t)vld1q_dup_s16(v10++);
    *a5 = result[1].i16[7];
    _X5 = result;
    result = (int8x16_t *)((char *)result + a2);
    --a7;
    a5 = (__int16 *)v10;
  }
  v8.i64[1] = v9;
  v13 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v13 + 1] = *(__int16 *)((char *)&result[1].i16[7] + (v13 + 1) * a2);
  v14 = vdupq_n_s8(~a4);
  v15 = vandq_s8(v14, (int8x16_t)xmmword_1B6917560);
  v16 = vandq_s8(v14, (int8x16_t)xmmword_1B6917570);
  v17 = *_X5;
  v18 = _X5[1];
  __asm { PRFM            #0, [X5,#0x20] }
  v24 = *result;
  v25 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  v27 = v13 + 2;
  v28 = vceqzq_s8(v16);
  v29 = vceqzq_s8(v15);
  v30 = a5;
  do
  {
    v31 = (uint8x16_t)vextq_s8(v17, v18, 0xEuLL);
    v32 = v25;
    v33 = (uint8x16_t)vextq_s8(v11, v17, 0xEuLL);
    v17 = v24;
    _X10 = (uint64_t)result->i64 + a2;
    v24 = *(int8x16_t *)((char *)result + a2);
    v25 = *(int8x16_t *)((char *)&result[1] + a2);
    __asm { PRFM            #0, [X10,#0x20] }
    v7.i16[0] = *(__int16 *)((char *)result[2].i16 + a2);
    v36 = (uint8x16_t)vextq_s8(v24, v25, 2uLL);
    v37 = (uint8x16_t)vextq_s8(v25, v7, 2uLL);
    v38 = (int8x16_t)vcgtq_u8((uint8x16_t)v32, v37);
    v7 = (int8x16_t)vcgtq_u8(v37, (uint8x16_t)v32);
    *result = vbslq_s8(v29, (int8x16_t)vsqaddq_u8((uint8x16_t)v17, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v17, v33), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v33, (uint8x16_t)v17)), (int8x16_t)vcgtq_u8((uint8x16_t)v17, v36)), (int8x16_t)vcgtq_u8(v36, (uint8x16_t)v17)))), v17);
    result[1] = vbslq_s8(v28, (int8x16_t)vsqaddq_u8((uint8x16_t)v32, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v32, v31), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v31, (uint8x16_t)v32)), v38), v7))), v32);
    v11 = (int8x16_t)vld1q_dup_s16(v30++);
    --v27;
    *a5 = v32.i16[7];
    v18 = v32;
    a5 = (__int16 *)v30;
    result = (int8x16_t *)((char *)result + a2);
  }
  while (v27 > 1);
  return result;
}

uint64_t sub_1B67B28BC(uint64_t result, uint64_t a2, uint64_t *a3, unsigned int a4, _DWORD *a5, _OWORD *_X5, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  int8x16_t v9;
  int16x8_t v10;
  int16x8_t v11;
  int16x8_t v12;
  int8x16_t v13;
  int8x16_t v14;
  const float *v15;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v26;
  float *v27;
  const float *v28;
  uint64_t v29;
  signed int v30;
  int8x16_t v31;
  int8x16_t v32;
  int16x8_t v33;
  const float *v34;
  int16x8_t v35;
  uint16x8_t v36;
  int16x8_t v37;
  uint16x8_t v38;
  int8x16_t v41;
  uint16x8_t v42;
  uint16x8_t v43;
  uint16x8_t v44;
  uint16x8_t v45;
  uint16x8_t v46;
  uint16x8_t v47;
  int8x16_t v48;
  int8x16_t v49;

  v7.i64[0] = *a3;
  v8 = a3[4];
  a5[a7] = *(_DWORD *)(result + 2 * a7 * a2 - 4);
  if ((a4 & 4) == 0)
  {
    *a5++ = *(_DWORD *)(result + 60);
    _X5 = (_OWORD *)result;
    result += 2 * a2;
    --a7;
  }
  v7.i64[1] = v8;
  v9 = (int8x16_t)vdupq_n_s16(~a4);
  v10 = (int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1B69174F0);
  v12 = *(int16x8_t *)_X5;
  v11 = *((int16x8_t *)_X5 + 1);
  v13 = *((int8x16_t *)_X5 + 2);
  v14 = *((int8x16_t *)_X5 + 3);
  v15 = (const float *)(_X5 + 4);
  __asm { PRFM            #0, [X5,#0x40] }
  v21 = *(int8x16_t *)result;
  v22 = *(int8x16_t *)(result + 16);
  v23 = *(int8x16_t *)(result + 32);
  v24 = *(int8x16_t *)(result + 48);
  __asm { PRFM            #0, [X0,#0x40] }
  v26 = (int8x16_t)vld1q_dup_f32(v15);
  *a5 = v24.i32[3];
  v27 = (float *)(a5 + 1);
  v28 = (const float *)(result + 64);
  v29 = 2 * a2;
  v30 = a7 + ((a4 >> 3) | 0xFFFFFFFE) + 2;
  v31 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1B6917520));
  v32 = (int8x16_t)vceqzq_s16(v10);
  v33.i64[0] = 0xFC00FC00FC00FC00;
  v33.i64[1] = 0xFC00FC00FC00FC00;
  v34 = v27;
  do
  {
    v35 = (int16x8_t)v24;
    v36 = (uint16x8_t)vextq_s8((int8x16_t)v11, v13, 4uLL);
    v37 = (int16x8_t)v23;
    v38 = (uint16x8_t)vextq_s8((int8x16_t)v12, (int8x16_t)v11, 4uLL);
    v11 = (int16x8_t)v22;
    v12 = (int16x8_t)v21;
    _X12 = (char *)v28 + v29;
    v21 = *(int8x16_t *)((char *)v28 + v29 - 64);
    v22 = *(int8x16_t *)((char *)v28 + v29 - 48);
    v23 = *(int8x16_t *)((char *)v28 + v29 - 32);
    v24 = *(int8x16_t *)((char *)v28 + v29 - 16);
    __asm { PRFM            #0, [X12] }
    v41 = (int8x16_t)vld1q_dup_f32(v34++);
    v42 = (uint16x8_t)vextq_s8(v13, v14, 4uLL);
    v43 = (uint16x8_t)vextq_s8(v14, v26, 4uLL);
    *v27 = *(float *)&v24.i32[3];
    v44 = (uint16x8_t)vextq_s8(v41, v21, 0xCuLL);
    v45 = (uint16x8_t)vextq_s8(v21, v22, 0xCuLL);
    v46 = (uint16x8_t)vextq_s8(v22, v23, 0xCuLL);
    v47 = (uint16x8_t)vextq_s8(v23, v24, 0xCuLL);
    v48 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v38, (uint16x8_t)v12), (int16x8_t)vcgtq_u16((uint16x8_t)v12, v38)), (int16x8_t)vcgtq_u16((uint16x8_t)v12, v44)), (int16x8_t)vcgtq_u16(v44, (uint16x8_t)v12))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v36, (uint16x8_t)v11), (int16x8_t)vcgtq_u16((uint16x8_t)v11, v36)), (int16x8_t)vcgtq_u16((uint16x8_t)v11, v45)), (int16x8_t)vcgtq_u16(v45, (uint16x8_t)v11))), (int8x16_t)xmmword_1B6917530));
    v49 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v42, (uint16x8_t)v37), (int16x8_t)vcgtq_u16((uint16x8_t)v37, v42)), (int16x8_t)vcgtq_u16((uint16x8_t)v37, v46)), (int16x8_t)vcgtq_u16(v46, (uint16x8_t)v37))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v43, (uint16x8_t)v35), (int16x8_t)vcgtq_u16((uint16x8_t)v35, v43)), (int16x8_t)vcgtq_u16((uint16x8_t)v35, v47)), (int16x8_t)vcgtq_u16(v47, (uint16x8_t)v35))), (int8x16_t)xmmword_1B6917530));
    *((int8x16_t *)v28 - 4) = vbslq_s8(v32, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v12, *(int8x8_t *)v48.i8), (int16x8_t)0), v33), (int8x16_t)v12);
    *((int16x8_t *)v28 - 3) = vminq_s16(vmaxq_s16(vaddw_high_s8(v11, v48), (int16x8_t)0), v33);
    *((int16x8_t *)v28 - 2) = vminq_s16(vmaxq_s16(vaddw_s8(v37, *(int8x8_t *)v49.i8), (int16x8_t)0), v33);
    *((int8x16_t *)v28 - 1) = vbslq_s8(v31, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v35, v49), (int16x8_t)0), v33), (int8x16_t)v35);
    v26 = (int8x16_t)vld1q_dup_f32(v28);
    --v30;
    v28 = (const float *)((char *)v28 + v29);
    v27 = (float *)v34;
    v13 = (int8x16_t)v37;
    v14 = (int8x16_t)v35;
  }
  while (v30 > 1);
  return result;
}

int8x16_t *sub_1B67B2AB0(int8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int8x16_t v12;
  int8x16_t v13;
  const __int16 *i16;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v23;
  __int16 *v24;
  signed int v25;
  int8x16_t v26;
  int8x16_t v27;
  const __int16 *v28;
  uint8x16_t v29;
  uint8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v35;
  uint8x16_t v36;
  uint8x16_t v37;
  const __int16 *v38;

  v7.i64[0] = *a3;
  v8 = a3[4];
  a5[a7] = *(__int16 *)((char *)&result->i16[-1] + a7 * a2);
  if ((a4 & 4) == 0)
  {
    *a5++ = result[1].i16[7];
    _X5 = result;
    result = (int8x16_t *)((char *)result + a2);
    --a7;
  }
  v7.i64[1] = v8;
  v9 = vdupq_n_s8(~a4);
  v10 = vandq_s8(v9, (int8x16_t)xmmword_1B6917560);
  v11 = vandq_s8(v9, (int8x16_t)xmmword_1B6917570);
  v12 = *_X5;
  v13 = _X5[1];
  i16 = _X5[2].i16;
  __asm { PRFM            #0, [X5,#0x20] }
  v20 = *result;
  v21 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  v23 = (int8x16_t)vld1q_dup_s16(i16);
  *a5 = v21.i16[7];
  v24 = a5 + 1;
  v25 = a7 + ((a4 >> 3) | 0xFFFFFFFE) + 2;
  v26 = vceqzq_s8(v11);
  v27 = vceqzq_s8(v10);
  v28 = v24;
  do
  {
    v29 = (uint8x16_t)vextq_s8(v12, v13, 2uLL);
    v30 = (uint8x16_t)vextq_s8(v13, v23, 2uLL);
    v31 = v21;
    v32 = v20;
    _X10 = (uint64_t)result->i64 + a2;
    v20 = *(int8x16_t *)((char *)result + a2);
    v21 = *(int8x16_t *)((char *)&result[1] + a2);
    __asm { PRFM            #0, [X10,#0x20] }
    v35 = (int8x16_t)vld1q_dup_s16(v28++);
    *v24 = v21.i16[7];
    v36 = (uint8x16_t)vextq_s8(v35, v20, 0xEuLL);
    v37 = (uint8x16_t)vextq_s8(v20, v21, 0xEuLL);
    *result = vbslq_s8(v27, (int8x16_t)vsqaddq_u8((uint8x16_t)v32, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v32, v29), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v29, (uint8x16_t)v32)), (int8x16_t)vcgtq_u8((uint8x16_t)v32, v36)), (int8x16_t)vcgtq_u8(v36, (uint8x16_t)v32)))), v32);
    result[1] = vbslq_s8(v26, (int8x16_t)vsqaddq_u8((uint8x16_t)v31, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v31, v30), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v30, (uint8x16_t)v31)), (int8x16_t)vcgtq_u8((uint8x16_t)v31, v37)), (int8x16_t)vcgtq_u8(v37, (uint8x16_t)v31)))), v31);
    v38 = result[2].i16;
    --v25;
    v24 = (__int16 *)v28;
    v23 = (int8x16_t)vld1q_dup_s16(v38);
    v12 = v32;
    v13 = v31;
    result = (int8x16_t *)((char *)result + a2);
  }
  while (v25 > 1);
  return result;
}

int16x8_t *sub_1B67B2C08(int16x8_t *result, uint64_t a2, uint64_t *a3, int a4, float *a5, uint64_t a6, int a7)
{
  int16x8_t v7;
  int8x16_t v8;
  int16x8_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int v13;
  int16x8_t v14;
  const float *v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int8x16_t v30;
  uint16x8_t v31;
  uint16x8_t v32;
  uint16x8_t v33;
  uint16x8_t v34;
  uint16x8_t v35;
  uint16x8_t v36;
  uint16x8_t v37;
  uint16x8_t v38;
  uint16x8_t v39;
  uint16x8_t v40;
  uint16x8_t v41;
  uint16x8_t v42;
  uint16x8_t v43;
  uint16x8_t v44;
  uint16x8_t v45;
  uint16x8_t v46;
  int8x16_t v47;
  int8x16_t v48;
  int8x16_t v49;
  int16x8_t v50;
  int16x8_t v51;
  int16x8_t v52;
  int8x16_t v53;

  v8.i64[0] = *a3;
  v8.i64[1] = a3[4];
  v9 = vdupq_n_s16(~a4);
  v10 = (int8x16_t)vtstq_s16(v9, (int16x8_t)xmmword_1B69174F0);
  v11 = (int8x16_t)vtstq_s16(v9, (int16x8_t)xmmword_1B6917520);
  _X8 = result + 6;
  v13 = a7 + 1;
  v14.i64[0] = 0xFC00FC00FC00FC00;
  v14.i64[1] = 0xFC00FC00FC00FC00;
  v15 = a5;
  do
  {
    v16 = _X8[-6];
    v17 = _X8[-5];
    v18 = _X8[-4];
    v19 = _X8[-3];
    v20 = _X8[-2];
    v21 = _X8[-1];
    v23 = *_X8;
    v22 = _X8[1];
    __asm
    {
      PRFM            #0, [X8,#0x20]
      PRFM            #0, [X8,#0x60]
    }
    v30 = (int8x16_t)vld1q_dup_f32(v15++);
    *a5 = *(float *)&v22.i32[3];
    v31 = (uint16x8_t)vextq_s8(v30, (int8x16_t)v16, 0xCuLL);
    v32 = (uint16x8_t)vextq_s8((int8x16_t)v16, (int8x16_t)v17, 0xCuLL);
    v33 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v18, 0xCuLL);
    v34 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 0xCuLL);
    v35 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v20, 0xCuLL);
    v36 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v21, 0xCuLL);
    v37 = (uint16x8_t)vextq_s8((int8x16_t)v21, (int8x16_t)v23, 0xCuLL);
    v38 = (uint16x8_t)vextq_s8((int8x16_t)v23, (int8x16_t)v22, 0xCuLL);
    v39 = (uint16x8_t)vextq_s8((int8x16_t)v16, (int8x16_t)v17, 4uLL);
    v40 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v18, 4uLL);
    v41 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 4uLL);
    v42 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v20, 4uLL);
    v43 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v21, 4uLL);
    v44 = (uint16x8_t)vextq_s8((int8x16_t)v21, (int8x16_t)v23, 4uLL);
    v45 = (uint16x8_t)vextq_s8((int8x16_t)v23, (int8x16_t)v22, 4uLL);
    v7.i32[0] = _X8[2].i32[0];
    v46 = (uint16x8_t)vextq_s8((int8x16_t)v22, (int8x16_t)v7, 4uLL);
    v47 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v39, (uint16x8_t)v16), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v39)), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v31)), (int16x8_t)vcgtq_u16(v31, (uint16x8_t)v16))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v32, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v32)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v40)), (int16x8_t)vcgtq_u16(v40, (uint16x8_t)v17))), (int8x16_t)xmmword_1B6917530));
    v48 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v33, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v33)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v41)), (int16x8_t)vcgtq_u16(v41, (uint16x8_t)v18))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v34, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v34)), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v42)), (int16x8_t)vcgtq_u16(v42, (uint16x8_t)v19))), (int8x16_t)xmmword_1B6917530));
    v49 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v35, (uint16x8_t)v20), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v35)), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v43)), (int16x8_t)vcgtq_u16(v43, (uint16x8_t)v20))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v36, (uint16x8_t)v21), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v36)), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v44)), (int16x8_t)vcgtq_u16(v44, (uint16x8_t)v21))), (int8x16_t)xmmword_1B6917530));
    v50 = vminq_s16(vmaxq_s16(vaddw_s8(v20, *(int8x8_t *)v49.i8), (int16x8_t)0), v14);
    v51 = vminq_s16(vmaxq_s16(vaddw_high_s8(v21, v49), (int16x8_t)0), v14);
    v52 = (int16x8_t)vcgtq_u16((uint16x8_t)v22, v46);
    v7 = (int16x8_t)vcgtq_u16(v46, (uint16x8_t)v22);
    v53 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v37, (uint16x8_t)v23), (int16x8_t)vcgtq_u16((uint16x8_t)v23, v37)), (int16x8_t)vcgtq_u16((uint16x8_t)v23, v45)), (int16x8_t)vcgtq_u16(v45, (uint16x8_t)v23))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v38, (uint16x8_t)v22), (int16x8_t)vcgtq_u16((uint16x8_t)v22, v38)), v52), v7)), (int8x16_t)xmmword_1B6917530));
    _X8[-6] = (int16x8_t)vbslq_s8(v10, (int8x16_t)v16, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v16, *(int8x8_t *)v47.i8), (int16x8_t)0), v14));
    _X8[-5] = vminq_s16(vmaxq_s16(vaddw_high_s8(v17, v47), (int16x8_t)0), v14);
    _X8[-4] = vminq_s16(vmaxq_s16(vaddw_s8(v18, *(int8x8_t *)v48.i8), (int16x8_t)0), v14);
    _X8[-3] = vminq_s16(vmaxq_s16(vaddw_high_s8(v19, v48), (int16x8_t)0), v14);
    _X8[-2] = v50;
    _X8[-1] = v51;
    *_X8 = vminq_s16(vmaxq_s16(vaddw_s8(v23, *(int8x8_t *)v53.i8), (int16x8_t)0), v14);
    _X8[1] = (int16x8_t)vbslq_s8(v11, (int8x16_t)v22, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v22, v53), (int16x8_t)0), v14));
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v13;
    a5 = (float *)v15;
  }
  while (v13 > 1);
  return result;
}

int8x16_t *sub_1B67B2E88(int8x16_t *result, uint64_t a2, uint64_t *a3, int a4, __int16 *a5, uint64_t a6, int a7)
{
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int v12;
  int8x16_t v13;
  int8x16_t v14;
  const __int16 *v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v25;
  uint8x16_t v26;
  uint8x16_t v27;
  uint8x16_t v28;
  uint8x16_t v29;
  uint8x16_t v30;
  uint8x16_t v31;
  uint8x16_t v32;
  uint8x16_t v33;

  v8.i64[0] = *a3;
  v8.i64[1] = a3[4];
  v9 = vdupq_n_s8(~a4);
  v10 = vandq_s8(v9, (int8x16_t)xmmword_1B6917560);
  _X8 = result + 2;
  v12 = a7 + 1;
  v13 = vceqzq_s8(vandq_s8(v9, (int8x16_t)xmmword_1B6917570));
  v14 = vceqzq_s8(v10);
  v15 = a5;
  do
  {
    v17 = _X8[-2];
    v16 = _X8[-1];
    v18 = *_X8;
    v19 = _X8[1];
    __asm { PRFM            #0, [X8,#0x20] }
    v25 = (int8x16_t)vld1q_dup_s16(v15++);
    *a5 = v19.i16[7];
    v7.i16[0] = _X8[2].i16[0];
    v26 = (uint8x16_t)vextq_s8(v25, v17, 0xEuLL);
    v27 = (uint8x16_t)vextq_s8(v17, v16, 0xEuLL);
    v28 = (uint8x16_t)vextq_s8(v16, v18, 0xEuLL);
    v29 = (uint8x16_t)vextq_s8(v18, v19, 0xEuLL);
    v30 = (uint8x16_t)vextq_s8(v17, v16, 2uLL);
    v31 = (uint8x16_t)vextq_s8(v16, v18, 2uLL);
    v32 = (uint8x16_t)vextq_s8(v18, v19, 2uLL);
    v33 = (uint8x16_t)vextq_s8(v19, v7, 2uLL);
    v7 = (int8x16_t)vsqaddq_u8((uint8x16_t)v19, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v19, v29), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v29, (uint8x16_t)v19)), (int8x16_t)vcgtq_u8((uint8x16_t)v19, v33)), (int8x16_t)vcgtq_u8(v33, (uint8x16_t)v19))));
    _X8[-2] = vbslq_s8(v14, (int8x16_t)vsqaddq_u8((uint8x16_t)v17, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v17, v30), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v30, (uint8x16_t)v17)), (int8x16_t)vcgtq_u8((uint8x16_t)v17, v26)), (int8x16_t)vcgtq_u8(v26, (uint8x16_t)v17)))), v17);
    _X8[-1] = (int8x16_t)vsqaddq_u8((uint8x16_t)v16, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v16, v27), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v27, (uint8x16_t)v16)), (int8x16_t)vcgtq_u8((uint8x16_t)v16, v31)), (int8x16_t)vcgtq_u8(v31, (uint8x16_t)v16))));
    *(uint8x16_t *)_X8 = vsqaddq_u8((uint8x16_t)v18, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v18, v28), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v28, (uint8x16_t)v18)), (int8x16_t)vcgtq_u8((uint8x16_t)v18, v32)), (int8x16_t)vcgtq_u8(v32, (uint8x16_t)v18))));
    _X8[1] = vbslq_s8(v13, v7, v19);
    _X8 = (int8x16_t *)((char *)_X8 + a2);
    --v12;
    a5 = (__int16 *)v15;
  }
  while (v12 > 1);
  return result;
}

uint64_t sub_1B67B2FE0(uint64_t result, uint64_t a2, uint64_t *a3, unsigned int a4, _DWORD *a5, uint16x8_t *_X5, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  int v9;
  uint16x8_t v10;
  uint16x8_t v11;
  uint16x8_t v12;
  uint16x8_t v13;
  uint16x8_t v14;
  uint16x8_t v15;
  uint16x8_t v16;
  uint16x8_t v17;
  uint16x8_t v24;
  uint16x8_t v25;
  uint16x8_t v26;
  uint16x8_t v27;
  uint16x8_t v28;
  uint16x8_t v29;
  int16x8_t *v30;
  uint16x8_t v31;
  uint16x8_t v32;
  int v35;
  uint64_t v36;
  int16x8_t v37;
  int16x8_t v38;
  int16x8_t v39;
  int16x8_t v40;
  int16x8_t v41;
  int16x8_t v42;
  int16x8_t v43;
  int16x8_t v44;
  int16x8_t v45;
  int8x16_t v49;
  int8x16_t v50;
  int8x16_t v51;
  int8x16_t v52;

  v7.i64[0] = *a3;
  v8 = a3[4];
  if ((a4 & 4) == 0)
  {
    *a5++ = *(_DWORD *)(result + 124);
    _X5 = (uint16x8_t *)result;
    result += 2 * a2;
    --a7;
  }
  v7.i64[1] = v8;
  v9 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v9 + 1] = *(_DWORD *)(result + 2 * (v9 + 1) * a2 + 124);
  v11 = *_X5;
  v10 = _X5[1];
  v13 = _X5[2];
  v12 = _X5[3];
  v15 = _X5[4];
  v14 = _X5[5];
  v17 = _X5[6];
  v16 = _X5[7];
  __asm
  {
    PRFM            #0, [X5,#0x80]
    PRFM            #0, [X5,#0xC0]
  }
  v24 = *(uint16x8_t *)result;
  v25 = *(uint16x8_t *)(result + 16);
  v26 = *(uint16x8_t *)(result + 32);
  v27 = *(uint16x8_t *)(result + 48);
  v28 = *(uint16x8_t *)(result + 64);
  v29 = *(uint16x8_t *)(result + 80);
  v30 = (int16x8_t *)(result + 96);
  v31 = *(uint16x8_t *)(result + 96);
  v32 = *(uint16x8_t *)(result + 112);
  __asm
  {
    PRFM            #0, [X0,#0x80]
    PRFM            #0, [X0,#0xC0]
  }
  v35 = v9 + 2;
  v36 = 2 * a2;
  v37.i64[0] = 0xFC00FC00FC00FC00;
  v37.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    v38 = (int16x8_t)v32;
    v39 = (int16x8_t)v31;
    v40 = (int16x8_t)v29;
    v41 = (int16x8_t)v28;
    v42 = (int16x8_t)v27;
    v43 = (int16x8_t)v26;
    v44 = (int16x8_t)v25;
    v45 = (int16x8_t)v24;
    _X11 = &v30->i8[v36];
    v24 = *(uint16x8_t *)((char *)&v30[-6] + v36);
    v25 = *(uint16x8_t *)((char *)&v30[-5] + v36);
    v26 = *(uint16x8_t *)((char *)&v30[-4] + v36);
    v27 = *(uint16x8_t *)((char *)&v30[-3] + v36);
    v28 = *(uint16x8_t *)((char *)&v30[-2] + v36);
    v29 = *(uint16x8_t *)((char *)&v30[-1] + v36);
    v31 = *(uint16x8_t *)((char *)v30 + 2 * a2);
    v32 = *(uint16x8_t *)((char *)&v30[1] + v36);
    __asm
    {
      PRFM            #0, [X11,#0x20]
      PRFM            #0, [X11,#0x60]
    }
    *a5++ = v38.i32[3];
    v49 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v11, (uint16x8_t)v45), (int16x8_t)vcgtq_u16((uint16x8_t)v45, v11)), (int16x8_t)vcgtq_u16((uint16x8_t)v45, v24)), (int16x8_t)vcgtq_u16(v24, (uint16x8_t)v45))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v10, (uint16x8_t)v44), (int16x8_t)vcgtq_u16((uint16x8_t)v44, v10)), (int16x8_t)vcgtq_u16((uint16x8_t)v44, v25)), (int16x8_t)vcgtq_u16(v25, (uint16x8_t)v44))), (int8x16_t)xmmword_1B6917530));
    v50 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v13, (uint16x8_t)v43), (int16x8_t)vcgtq_u16((uint16x8_t)v43, v13)), (int16x8_t)vcgtq_u16((uint16x8_t)v43, v26)), (int16x8_t)vcgtq_u16(v26, (uint16x8_t)v43))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v12, (uint16x8_t)v42), (int16x8_t)vcgtq_u16((uint16x8_t)v42, v12)), (int16x8_t)vcgtq_u16((uint16x8_t)v42, v27)), (int16x8_t)vcgtq_u16(v27, (uint16x8_t)v42))), (int8x16_t)xmmword_1B6917530));
    v51 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v15, (uint16x8_t)v41), (int16x8_t)vcgtq_u16((uint16x8_t)v41, v15)), (int16x8_t)vcgtq_u16((uint16x8_t)v41, v28)), (int16x8_t)vcgtq_u16(v28, (uint16x8_t)v41))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v14, (uint16x8_t)v40), (int16x8_t)vcgtq_u16((uint16x8_t)v40, v14)), (int16x8_t)vcgtq_u16((uint16x8_t)v40, v29)), (int16x8_t)vcgtq_u16(v29, (uint16x8_t)v40))), (int8x16_t)xmmword_1B6917530));
    v52 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v17, (uint16x8_t)v39), (int16x8_t)vcgtq_u16((uint16x8_t)v39, v17)), (int16x8_t)vcgtq_u16((uint16x8_t)v39, v31)), (int16x8_t)vcgtq_u16(v31, (uint16x8_t)v39))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v16, (uint16x8_t)v38), (int16x8_t)vcgtq_u16((uint16x8_t)v38, v16)), (int16x8_t)vcgtq_u16((uint16x8_t)v38, v32)), (int16x8_t)vcgtq_u16(v32, (uint16x8_t)v38))), (int8x16_t)xmmword_1B6917530));
    v30[-6] = vminq_s16(vmaxq_s16(vaddw_s8(v45, *(int8x8_t *)v49.i8), (int16x8_t)0), v37);
    v30[-5] = vminq_s16(vmaxq_s16(vaddw_high_s8(v44, v49), (int16x8_t)0), v37);
    v30[-4] = vminq_s16(vmaxq_s16(vaddw_s8(v43, *(int8x8_t *)v50.i8), (int16x8_t)0), v37);
    v30[-3] = vminq_s16(vmaxq_s16(vaddw_high_s8(v42, v50), (int16x8_t)0), v37);
    v30[-2] = vminq_s16(vmaxq_s16(vaddw_s8(v41, *(int8x8_t *)v51.i8), (int16x8_t)0), v37);
    v30[-1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v40, v51), (int16x8_t)0), v37);
    --v35;
    *v30 = vminq_s16(vmaxq_s16(vaddw_s8(v39, *(int8x8_t *)v52.i8), (int16x8_t)0), v37);
    v30[1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v38, v52), (int16x8_t)0), v37);
    v30 = (int16x8_t *)((char *)v30 + v36);
    v11 = (uint16x8_t)v45;
    v10 = (uint16x8_t)v44;
    v13 = (uint16x8_t)v43;
    v12 = (uint16x8_t)v42;
    v15 = (uint16x8_t)v41;
    v14 = (uint16x8_t)v40;
    v17 = (uint16x8_t)v39;
    v16 = (uint16x8_t)v38;
  }
  while (v35 > 1);
  return result;
}

uint8x16_t *sub_1B67B32A4(uint8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, uint8x16_t *_X5, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  int v9;
  uint8x16_t v10;
  uint8x16_t v11;
  uint8x16_t v12;
  uint8x16_t v13;
  uint8x16_t v19;
  uint8x16_t v20;
  uint8x16_t v21;
  uint8x16_t v22;
  int v24;
  uint8x16_t v25;
  uint8x16_t v26;
  uint8x16_t v27;
  uint8x16_t v28;
  int8x16_t v31;
  uint8x16_t v32;
  int8x16_t v33;
  uint8x16_t v34;
  int8x16_t v35;
  uint8x16_t v36;
  int8x16_t v37;

  v7.i64[0] = *a3;
  v8 = a3[4];
  if ((a4 & 4) == 0)
  {
    *a5++ = result[3].i16[7];
    _X5 = result;
    result = (uint8x16_t *)((char *)result + a2);
    --a7;
  }
  v7.i64[1] = v8;
  v9 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v9 + 1] = *(__int16 *)((char *)&result[3].i16[7] + (v9 + 1) * a2);
  v11 = *_X5;
  v10 = _X5[1];
  v12 = _X5[2];
  v13 = _X5[3];
  __asm { PRFM            #0, [X5,#0x40] }
  v19 = *result;
  v20 = result[1];
  v21 = result[2];
  v22 = result[3];
  __asm { PRFM            #0, [X0,#0x40] }
  v24 = v9 + 2;
  do
  {
    v25 = v19;
    v26 = v20;
    v27 = v21;
    v28 = v22;
    _X9 = (uint64_t)result->i64 + a2;
    v19 = *(uint8x16_t *)((char *)result + a2);
    v20 = *(uint8x16_t *)((char *)&result[1] + a2);
    v21 = *(uint8x16_t *)((char *)&result[2] + a2);
    v22 = *(uint8x16_t *)((char *)&result[3] + a2);
    __asm { PRFM            #0, [X9,#0x40] }
    *a5++ = v28.i16[7];
    v31 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v25, v11), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v11, v25)), (int8x16_t)vcgtq_u8(v25, v19)), (int8x16_t)vcgtq_u8(v19, v25)));
    v11 = v25;
    v32 = vsqaddq_u8(v25, v31);
    v33 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v26, v10), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v10, v26)), (int8x16_t)vcgtq_u8(v26, v20)), (int8x16_t)vcgtq_u8(v20, v26)));
    v10 = v26;
    v34 = vsqaddq_u8(v26, v33);
    v35 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v27, v12), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v12, v27)), (int8x16_t)vcgtq_u8(v27, v21)), (int8x16_t)vcgtq_u8(v21, v27)));
    v12 = v27;
    v36 = vsqaddq_u8(v27, v35);
    v37 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v28, v13), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v13, v28)), (int8x16_t)vcgtq_u8(v28, v22)), (int8x16_t)vcgtq_u8(v22, v28)));
    v13 = v28;
    *result = v32;
    result[1] = v34;
    result[2] = v36;
    result[3] = vsqaddq_u8(v28, v37);
    --v24;
    result = (uint8x16_t *)((char *)result + a2);
  }
  while (v24 > 1);
  return result;
}

uint64_t sub_1B67B3404(uint64_t result, uint64_t a2, uint64_t *a3, unsigned int a4, float *a5, int16x8_t *_X5, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  const float *v9;
  int8x16_t v10;
  const float *v11;
  int v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int8x16_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  uint64_t v34;
  int8x16_t v35;
  int8x16_t v36;
  int8x16_t v37;
  int8x16_t v38;
  uint64_t v41;
  int v42;
  int8x16_t v43;
  int16x8_t v44;
  const float *v45;
  uint16x8_t v46;
  uint16x8_t v47;
  uint16x8_t v48;
  uint16x8_t v49;
  uint16x8_t v50;
  uint16x8_t v51;
  uint16x8_t v52;
  uint16x8_t v53;
  uint16x8_t v55;
  uint16x8_t v56;
  int16x8_t v57;
  uint16x8_t v58;
  int16x8_t v59;
  uint16x8_t v60;
  int8x16_t v61;
  int16x8_t v62;
  int16x8_t v63;
  int16x8_t v64;
  uint16x8_t v65;
  int8x16_t v66;
  uint16x8_t v67;
  int16x8_t v70;
  uint16x8_t v71;
  int8x16_t v72;
  int16x8_t v73;
  int16x8_t v74;
  uint16x8_t v75;
  int8x16_t v76;
  int8x16_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int8x16_t v80;

  v7.i64[0] = *a3;
  v8 = a3[4];
  if ((a4 & 4) != 0)
  {
    v11 = (const float *)&_X5[-1].i32[3];
    v10 = (int8x16_t)vld1q_dup_f32(v11);
  }
  else
  {
    v9 = a5;
    v10 = (int8x16_t)vld1q_dup_f32(v9++);
    *a5 = *(float *)(result + 124);
    _X5 = (int16x8_t *)result;
    result += 2 * a2;
    --a7;
    a5 = (float *)v9;
  }
  v7.i64[1] = v8;
  v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = *(float *)(result + 2 * (v12 + 1) * a2 + 124);
  v13 = vdupq_n_s16(~a4);
  v15 = *_X5;
  v14 = _X5[1];
  v16 = (int16x8_t)vandq_s8((int8x16_t)v13, (int8x16_t)xmmword_1B69174F0);
  v17 = (int8x16_t)vtstq_s16(v13, (int16x8_t)xmmword_1B6917520);
  v19 = _X5[2];
  v18 = _X5[3];
  v21 = _X5[4];
  v20 = _X5[5];
  v23 = _X5[6];
  v22 = _X5[7];
  __asm
  {
    PRFM            #0, [X5,#0x80]
    PRFM            #0, [X5,#0xC0]
  }
  v30 = *(int8x16_t *)result;
  v31 = *(int8x16_t *)(result + 16);
  v32 = *(int8x16_t *)(result + 32);
  v33 = *(int8x16_t *)(result + 48);
  v34 = result + 96;
  v35 = *(int8x16_t *)(result + 96);
  v36 = *(int8x16_t *)(result + 64);
  v37 = *(int8x16_t *)(result + 80);
  v38 = *(int8x16_t *)(result + 112);
  __asm
  {
    PRFM            #0, [X0,#0x80]
    PRFM            #0, [X0,#0xC0]
  }
  v41 = 2 * a2;
  v42 = v12 + 2;
  v43 = (int8x16_t)vceqzq_s16(v16);
  v44.i64[0] = 0xFC00FC00FC00FC00;
  v44.i64[1] = 0xFC00FC00FC00FC00;
  v45 = a5;
  do
  {
    v46 = (uint16x8_t)vextq_s8((int8x16_t)v23, (int8x16_t)v22, 0xCuLL);
    v22 = (int16x8_t)v38;
    v47 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v23, 0xCuLL);
    v23 = (int16x8_t)v35;
    v48 = (uint16x8_t)vextq_s8((int8x16_t)v21, (int8x16_t)v20, 0xCuLL);
    v20 = (int16x8_t)v37;
    v49 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v21, 0xCuLL);
    v21 = (int16x8_t)v36;
    v50 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v18, 0xCuLL);
    v18 = (int16x8_t)v33;
    v51 = (uint16x8_t)vextq_s8((int8x16_t)v14, (int8x16_t)v19, 0xCuLL);
    v19 = (int16x8_t)v32;
    v52 = (uint16x8_t)vextq_s8((int8x16_t)v15, (int8x16_t)v14, 0xCuLL);
    v14 = (int16x8_t)v31;
    v53 = (uint16x8_t)vextq_s8(v10, (int8x16_t)v15, 0xCuLL);
    v15 = (int16x8_t)v30;
    _X12 = v34 + v41;
    v30 = *(int8x16_t *)(v34 + v41 - 96);
    v31 = *(int8x16_t *)(v34 + v41 - 80);
    v32 = *(int8x16_t *)(v34 + v41 - 64);
    v33 = *(int8x16_t *)(v34 + v41 - 48);
    v36 = *(int8x16_t *)(v34 + v41 - 32);
    v37 = *(int8x16_t *)(v34 + v41 - 16);
    v55 = (uint16x8_t)vextq_s8(v30, v31, 4uLL);
    v56 = (uint16x8_t)vextq_s8(v31, v32, 4uLL);
    v57 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v53, (uint16x8_t)v15), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v53)), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v55)), (int16x8_t)vcgtq_u16(v55, (uint16x8_t)v15));
    v58 = (uint16x8_t)vextq_s8(v32, v33, 4uLL);
    v59 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v52, (uint16x8_t)v14), (int16x8_t)vcgtq_u16((uint16x8_t)v14, v52)), (int16x8_t)vcgtq_u16((uint16x8_t)v14, v56)), (int16x8_t)vcgtq_u16(v56, (uint16x8_t)v14));
    v60 = (uint16x8_t)vextq_s8(v33, v36, 4uLL);
    v61 = vqmovn_high_s16(vqmovn_s16(v57), v59);
    v62 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v51, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v51)), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v58)), (int16x8_t)vcgtq_u16(v58, (uint16x8_t)v19));
    v63 = vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v50, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v50)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v60));
    v35 = *(int8x16_t *)(v34 + 2 * a2);
    v38 = *(int8x16_t *)(v34 + v41 + 16);
    v64 = vaddq_s16(v63, (int16x8_t)vcgtq_u16(v60, (uint16x8_t)v18));
    v65 = (uint16x8_t)vextq_s8(v36, v37, 4uLL);
    v66 = vqmovn_high_s16(vqmovn_s16(v62), v64);
    v67 = (uint16x8_t)vextq_s8(v37, v35, 4uLL);
    __asm
    {
      PRFM            #0, [X12,#0x20]
      PRFM            #0, [X12,#0x60]
    }
    v70 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v48, (uint16x8_t)v20), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v48)), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v67)), (int16x8_t)vcgtq_u16(v67, (uint16x8_t)v20));
    v71 = (uint16x8_t)vextq_s8(v35, v38, 4uLL);
    v72 = vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v49, (uint16x8_t)v21), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v49)), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v65)), (int16x8_t)vcgtq_u16(v65, (uint16x8_t)v21))), v70);
    v73 = (int16x8_t)vcgtq_u16((uint16x8_t)v23, v71);
    v74 = vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v47, (uint16x8_t)v23), (int16x8_t)vcgtq_u16((uint16x8_t)v23, v47)), v73);
    v73.i32[0] = *(_DWORD *)(v34 + v41 + 32);
    v75 = (uint16x8_t)vextq_s8(v38, (int8x16_t)v73, 4uLL);
    v76 = vqtbl1q_s8(v7, vaddq_s8(v61, (int8x16_t)xmmword_1B6917530));
    v77 = vqmovn_high_s16(vqmovn_s16(vaddq_s16(v74, (int16x8_t)vcgtq_u16(v71, (uint16x8_t)v23))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v46, (uint16x8_t)v22), (int16x8_t)vcgtq_u16((uint16x8_t)v22, v46)), (int16x8_t)vcgtq_u16((uint16x8_t)v22, v75)), (int16x8_t)vcgtq_u16(v75, (uint16x8_t)v22)));
    *(int8x16_t *)(v34 - 96) = vbslq_s8(v43, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v15, *(int8x8_t *)v76.i8), (int16x8_t)0), v44), (int8x16_t)v15);
    *(int16x8_t *)(v34 - 80) = vminq_s16(vmaxq_s16(vaddw_high_s8(v14, v76), (int16x8_t)0), v44);
    v78 = vqtbl1q_s8(v7, vaddq_s8(v66, (int8x16_t)xmmword_1B6917530));
    *(int16x8_t *)(v34 - 64) = vminq_s16(vmaxq_s16(vaddw_s8(v19, *(int8x8_t *)v78.i8), (int16x8_t)0), v44);
    *(int16x8_t *)(v34 - 48) = vminq_s16(vmaxq_s16(vaddw_high_s8(v18, v78), (int16x8_t)0), v44);
    v79 = vqtbl1q_s8(v7, vaddq_s8(v72, (int8x16_t)xmmword_1B6917530));
    *(int16x8_t *)(v34 - 32) = vminq_s16(vmaxq_s16(vaddw_s8(v21, *(int8x8_t *)v79.i8), (int16x8_t)0), v44);
    *(int16x8_t *)(v34 - 16) = vminq_s16(vmaxq_s16(vaddw_high_s8(v20, v79), (int16x8_t)0), v44);
    v80 = vqtbl1q_s8(v7, vaddq_s8(v77, (int8x16_t)xmmword_1B6917530));
    *(int16x8_t *)v34 = vminq_s16(vmaxq_s16(vaddw_s8(v23, *(int8x8_t *)v80.i8), (int16x8_t)0), v44);
    *(int8x16_t *)(v34 + 16) = vbslq_s8(v17, (int8x16_t)v22, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v22, v80), (int16x8_t)0), v44));
    v10 = (int8x16_t)vld1q_dup_f32(v45++);
    --v42;
    v34 += v41;
    *a5 = *(float *)&v22.i32[3];
    a5 = (float *)v45;
  }
  while (v42 > 1);
  return result;
}

int8x16_t *sub_1B67B3734(int8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, __int16 *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  const __int16 *v9;
  int8x16_t v10;
  const __int16 *v11;
  int v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int v30;
  int8x16_t v31;
  int8x16_t v32;
  const __int16 *v33;
  uint8x16_t v34;
  uint8x16_t v35;
  uint8x16_t v36;
  uint8x16_t v37;
  uint8x16_t v38;
  uint8x16_t v41;
  uint8x16_t v42;
  uint8x16_t v43;
  uint8x16_t v44;
  uint8x16_t v45;
  int8x16_t v46;
  uint8x16_t v47;
  int8x16_t v48;

  v7.i64[0] = *a3;
  v8 = a3[4];
  if ((a4 & 4) != 0)
  {
    v11 = &_X5[-1].i16[7];
    v10 = (int8x16_t)vld1q_dup_s16(v11);
  }
  else
  {
    v9 = a5;
    v10 = (int8x16_t)vld1q_dup_s16(v9++);
    *a5 = result[3].i16[7];
    _X5 = result;
    result = (int8x16_t *)((char *)result + a2);
    --a7;
    a5 = (__int16 *)v9;
  }
  v7.i64[1] = v8;
  v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = *(__int16 *)((char *)&result[3].i16[7] + (v12 + 1) * a2);
  v13 = vdupq_n_s8(~a4);
  v14 = vandq_s8(v13, (int8x16_t)xmmword_1B6917560);
  v15 = vandq_s8(v13, (int8x16_t)xmmword_1B6917570);
  v16 = *_X5;
  v17 = _X5[1];
  v19 = _X5[2];
  v18 = _X5[3];
  __asm { PRFM            #0, [X5,#0x40] }
  v25 = *result;
  v26 = result[1];
  v27 = result[2];
  v28 = result[3];
  __asm { PRFM            #0, [X0,#0x40] }
  v30 = v12 + 2;
  v31 = vceqzq_s8(v15);
  v32 = vceqzq_s8(v14);
  v33 = a5;
  do
  {
    v34 = (uint8x16_t)vextq_s8(v19, v18, 0xEuLL);
    v18 = v28;
    v35 = (uint8x16_t)v27;
    v36 = (uint8x16_t)v26;
    v37 = (uint8x16_t)vextq_s8(v10, v16, 0xEuLL);
    v38 = (uint8x16_t)vextq_s8(v16, v17, 0xEuLL);
    v16 = v25;
    _X10 = (uint64_t)result->i64 + a2;
    v25 = *(int8x16_t *)((char *)result + a2);
    v26 = *(int8x16_t *)((char *)&result[1] + a2);
    v27 = *(int8x16_t *)((char *)&result[2] + a2);
    v28 = *(int8x16_t *)((char *)&result[3] + a2);
    __asm { PRFM            #0, [X10,#0x40] }
    v10.i16[0] = *(__int16 *)((char *)result[4].i16 + a2);
    v41 = (uint8x16_t)vextq_s8(v17, v19, 0xEuLL);
    v42 = (uint8x16_t)vextq_s8(v25, v26, 2uLL);
    v43 = (uint8x16_t)vextq_s8(v26, v27, 2uLL);
    v44 = (uint8x16_t)vextq_s8(v27, v28, 2uLL);
    v45 = (uint8x16_t)vextq_s8(v28, v10, 2uLL);
    v46 = (int8x16_t)vsqaddq_u8((uint8x16_t)v16, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v16, v37), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v37, (uint8x16_t)v16)), (int8x16_t)vcgtq_u8((uint8x16_t)v16, v42)), (int8x16_t)vcgtq_u8(v42, (uint8x16_t)v16))));
    v17 = (int8x16_t)v36;
    v47 = vsqaddq_u8(v36, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v36, v38), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v38, v36)), (int8x16_t)vcgtq_u8(v36, v43)), (int8x16_t)vcgtq_u8(v43, v36))));
    v48 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v35, v41), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v41, v35)), (int8x16_t)vcgtq_u8(v35, v44)), (int8x16_t)vcgtq_u8(v44, v35)));
    v19 = (int8x16_t)v35;
    *result = vbslq_s8(v32, v46, v16);
    result[1] = (int8x16_t)v47;
    result[2] = (int8x16_t)vsqaddq_u8(v35, v48);
    result[3] = vbslq_s8(v31, (int8x16_t)vsqaddq_u8((uint8x16_t)v18, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v18, v34), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v34, (uint8x16_t)v18)), (int8x16_t)vcgtq_u8((uint8x16_t)v18, v45)), (int8x16_t)vcgtq_u8(v45, (uint8x16_t)v18)))), v18);
    v10 = (int8x16_t)vld1q_dup_s16(v33++);
    --v30;
    *a5 = v18.i16[7];
    a5 = (__int16 *)v33;
    result = (int8x16_t *)((char *)result + a2);
  }
  while (v30 > 1);
  return result;
}

uint64_t sub_1B67B3910(uint64_t result, uint64_t a2, uint64_t *a3, unsigned int a4, _DWORD *a5, _OWORD *_X5, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  int16x8_t v9;
  int16x8_t v10;
  int8x16_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int8x16_t v19;
  const float *v20;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  uint64_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  int8x16_t v35;
  uint64_t v37;
  signed int v38;
  int8x16_t v40;
  float *v41;
  int8x16_t v42;
  int16x8_t v43;
  const float *v44;
  uint16x8_t v45;
  int16x8_t v46;
  uint16x8_t v47;
  uint16x8_t v48;
  uint16x8_t v49;
  uint16x8_t v50;
  uint16x8_t v51;
  uint16x8_t v52;
  int8x16_t v56;
  uint16x8_t v57;
  uint16x8_t v58;
  uint16x8_t v59;
  int16x8_t v60;
  uint16x8_t v61;
  int8x16_t v62;
  uint16x8_t v63;
  int16x8_t v64;
  uint16x8_t v65;
  int8x16_t v66;
  uint16x8_t v67;
  int16x8_t v68;
  uint16x8_t v69;
  int8x16_t v70;
  uint16x8_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int8x16_t v74;
  int8x16_t v75;
  int8x16_t v76;
  const float *v77;

  v7.i64[0] = *a3;
  v8 = a3[4];
  a5[a7] = *(_DWORD *)(result + 2 * a7 * a2 - 4);
  if ((a4 & 4) == 0)
  {
    *a5++ = *(_DWORD *)(result + 124);
    _X5 = (_OWORD *)result;
    result += 2 * a2;
    --a7;
  }
  v7.i64[1] = v8;
  v9 = vdupq_n_s16(~a4);
  v10 = (int16x8_t)vandq_s8((int8x16_t)v9, (int8x16_t)xmmword_1B69174F0);
  v11 = (int8x16_t)vtstq_s16(v9, (int16x8_t)xmmword_1B6917520);
  v13 = *(int16x8_t *)_X5;
  v12 = *((int16x8_t *)_X5 + 1);
  v15 = *((int16x8_t *)_X5 + 2);
  v14 = *((int16x8_t *)_X5 + 3);
  v17 = *((int16x8_t *)_X5 + 4);
  v16 = *((int16x8_t *)_X5 + 5);
  v18 = *((int16x8_t *)_X5 + 6);
  v19 = *((int8x16_t *)_X5 + 7);
  v20 = (const float *)(_X5 + 8);
  __asm
  {
    PRFM            #0, [X5,#0x80]
    PRFM            #0, [X5,#0xC0]
  }
  v27 = *(int8x16_t *)result;
  v28 = *(int8x16_t *)(result + 16);
  v29 = *(int8x16_t *)(result + 32);
  v30 = *(int8x16_t *)(result + 48);
  v31 = result + 96;
  v32 = *(int8x16_t *)(result + 96);
  v33 = *(int8x16_t *)(result + 64);
  v34 = *(int8x16_t *)(result + 80);
  v35 = *(int8x16_t *)(result + 112);
  __asm { PRFM            #0, [X0,#0x80] }
  v37 = 2 * a2;
  v38 = a7 + ((a4 >> 3) | 0xFFFFFFFE) + 2;
  __asm { PRFM            #0, [X0,#0xC0] }
  v40 = (int8x16_t)vld1q_dup_f32(v20);
  *a5 = v35.i32[3];
  v41 = (float *)(a5 + 1);
  v42 = (int8x16_t)vceqzq_s16(v10);
  v43.i64[0] = 0xFC00FC00FC00FC00;
  v43.i64[1] = 0xFC00FC00FC00FC00;
  v44 = v41;
  do
  {
    v45 = (uint16x8_t)vextq_s8((int8x16_t)v18, v19, 4uLL);
    v46 = (int16x8_t)v35;
    v47 = (uint16x8_t)vextq_s8((int8x16_t)v16, (int8x16_t)v18, 4uLL);
    v18 = (int16x8_t)v32;
    v48 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v16, 4uLL);
    v16 = (int16x8_t)v34;
    v49 = (uint16x8_t)vextq_s8((int8x16_t)v14, (int8x16_t)v17, 4uLL);
    v17 = (int16x8_t)v33;
    v50 = (uint16x8_t)vextq_s8((int8x16_t)v15, (int8x16_t)v14, 4uLL);
    v14 = (int16x8_t)v30;
    v51 = (uint16x8_t)vextq_s8((int8x16_t)v12, (int8x16_t)v15, 4uLL);
    v15 = (int16x8_t)v29;
    v52 = (uint16x8_t)vextq_s8((int8x16_t)v13, (int8x16_t)v12, 4uLL);
    v12 = (int16x8_t)v28;
    v13 = (int16x8_t)v27;
    _X12 = v31 + v37;
    v27 = *(int8x16_t *)(v31 + v37 - 96);
    v28 = *(int8x16_t *)(v31 + v37 - 80);
    v29 = *(int8x16_t *)(v31 + v37 - 64);
    v30 = *(int8x16_t *)(v31 + v37 - 48);
    v33 = *(int8x16_t *)(v31 + v37 - 32);
    v34 = *(int8x16_t *)(v31 + v37 - 16);
    v32 = *(int8x16_t *)(v31 + 2 * a2);
    v35 = *(int8x16_t *)(v31 + v37 + 16);
    __asm
    {
      PRFM            #0, [X12,#0x20]
      PRFM            #0, [X12,#0x60]
    }
    v56 = (int8x16_t)vld1q_dup_f32(v44++);
    v57 = (uint16x8_t)vextq_s8(v19, v40, 4uLL);
    v58 = (uint16x8_t)vextq_s8(v56, v27, 0xCuLL);
    v59 = (uint16x8_t)vextq_s8(v27, v28, 0xCuLL);
    v60 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v52, (uint16x8_t)v13), (int16x8_t)vcgtq_u16((uint16x8_t)v13, v52)), (int16x8_t)vcgtq_u16((uint16x8_t)v13, v58)), (int16x8_t)vcgtq_u16(v58, (uint16x8_t)v13));
    v61 = (uint16x8_t)vextq_s8(v28, v29, 0xCuLL);
    v62 = vqmovn_high_s16(vqmovn_s16(v60), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v51, (uint16x8_t)v12), (int16x8_t)vcgtq_u16((uint16x8_t)v12, v51)), (int16x8_t)vcgtq_u16((uint16x8_t)v12, v59)), (int16x8_t)vcgtq_u16(v59, (uint16x8_t)v12)));
    v63 = (uint16x8_t)vextq_s8(v29, v30, 0xCuLL);
    v64 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v50, (uint16x8_t)v15), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v50)), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v61)), (int16x8_t)vcgtq_u16(v61, (uint16x8_t)v15));
    v65 = (uint16x8_t)vextq_s8(v30, v33, 0xCuLL);
    v66 = vqmovn_high_s16(vqmovn_s16(v64), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v49, (uint16x8_t)v14), (int16x8_t)vcgtq_u16((uint16x8_t)v14, v49)), (int16x8_t)vcgtq_u16((uint16x8_t)v14, v63)), (int16x8_t)vcgtq_u16(v63, (uint16x8_t)v14)));
    v67 = (uint16x8_t)vextq_s8(v33, v34, 0xCuLL);
    v68 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v47, (uint16x8_t)v16), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v47)), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v67)), (int16x8_t)vcgtq_u16(v67, (uint16x8_t)v16));
    v69 = (uint16x8_t)vextq_s8(v34, v32, 0xCuLL);
    v70 = vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v48, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v48)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v65)), (int16x8_t)vcgtq_u16(v65, (uint16x8_t)v17))), v68);
    v71 = (uint16x8_t)vextq_s8(v32, v35, 0xCuLL);
    *v41 = *(float *)&v35.i32[3];
    v72 = vqtbl1q_s8(v7, vaddq_s8(v62, (int8x16_t)xmmword_1B6917530));
    v73 = vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v45, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v45)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v69)), (int16x8_t)vcgtq_u16(v69, (uint16x8_t)v18))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v57, (uint16x8_t)v46), (int16x8_t)vcgtq_u16((uint16x8_t)v46, v57)), (int16x8_t)vcgtq_u16((uint16x8_t)v46, v71)), (int16x8_t)vcgtq_u16(v71, (uint16x8_t)v46)));
    *(int8x16_t *)(v31 - 96) = vbslq_s8(v42, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v13, *(int8x8_t *)v72.i8), (int16x8_t)0), v43), (int8x16_t)v13);
    *(int16x8_t *)(v31 - 80) = vminq_s16(vmaxq_s16(vaddw_high_s8(v12, v72), (int16x8_t)0), v43);
    v74 = vqtbl1q_s8(v7, vaddq_s8(v66, (int8x16_t)xmmword_1B6917530));
    *(int16x8_t *)(v31 - 64) = vminq_s16(vmaxq_s16(vaddw_s8(v15, *(int8x8_t *)v74.i8), (int16x8_t)0), v43);
    *(int16x8_t *)(v31 - 48) = vminq_s16(vmaxq_s16(vaddw_high_s8(v14, v74), (int16x8_t)0), v43);
    v75 = vqtbl1q_s8(v7, vaddq_s8(v70, (int8x16_t)xmmword_1B6917530));
    *(int16x8_t *)(v31 - 32) = vminq_s16(vmaxq_s16(vaddw_s8(v17, *(int8x8_t *)v75.i8), (int16x8_t)0), v43);
    *(int16x8_t *)(v31 - 16) = vminq_s16(vmaxq_s16(vaddw_high_s8(v16, v75), (int16x8_t)0), v43);
    v76 = vqtbl1q_s8(v7, vaddq_s8(v73, (int8x16_t)xmmword_1B6917530));
    *(int16x8_t *)v31 = vminq_s16(vmaxq_s16(vaddw_s8(v18, *(int8x8_t *)v76.i8), (int16x8_t)0), v43);
    *(int8x16_t *)(v31 + 16) = vbslq_s8(v11, (int8x16_t)v46, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v46, v76), (int16x8_t)0), v43));
    v77 = (const float *)(v31 + 32);
    --v38;
    v31 += v37;
    v41 = (float *)v44;
    v19 = (int8x16_t)v46;
    v40 = (int8x16_t)vld1q_dup_f32(v77);
  }
  while (v38 > 1);
  return result;
}

int8x16_t *sub_1B67B3C40(int8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7;
  uint64_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  const __int16 *i16;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  const __int16 *v26;
  int8x16_t v28;
  __int16 *v29;
  signed int v30;
  int8x16_t v31;
  int8x16_t v32;
  const __int16 *v33;
  uint8x16_t v34;
  int8x16_t v35;
  uint8x16_t v36;
  uint8x16_t v37;
  uint8x16_t v38;
  int8x16_t v41;
  uint8x16_t v42;
  uint8x16_t v43;
  uint8x16_t v44;
  uint8x16_t v45;
  uint8x16_t v46;
  uint8x16_t v47;
  int8x16_t v48;
  int8x16_t v49;
  uint8x16_t v50;
  int8x16_t v51;

  v7.i64[0] = *a3;
  v8 = a3[4];
  a5[a7] = *(__int16 *)((char *)&result->i16[-1] + a7 * a2);
  if ((a4 & 4) == 0)
  {
    *a5++ = result[3].i16[7];
    _X5 = result;
    result = (int8x16_t *)((char *)result + a2);
    --a7;
  }
  v7.i64[1] = v8;
  v9 = vdupq_n_s8(~a4);
  v10 = vandq_s8(v9, (int8x16_t)xmmword_1B6917560);
  v11 = vandq_s8(v9, (int8x16_t)xmmword_1B6917570);
  v13 = *_X5;
  v12 = _X5[1];
  v14 = _X5[2];
  v15 = _X5[3];
  i16 = _X5[4].i16;
  __asm { PRFM            #0, [X5,#0x40] }
  v22 = *result;
  v23 = result[1];
  v24 = result[2];
  v25 = result[3];
  v26 = result[4].i16;
  __asm { PRFM            #0, [X0,#0x40] }
  v28 = (int8x16_t)vld1q_dup_s16(i16);
  *a5 = v25.i16[7];
  v29 = a5 + 1;
  v30 = a7 + ((a4 >> 3) | 0xFFFFFFFE) + 2;
  v31 = vceqzq_s8(v11);
  v32 = vceqzq_s8(v10);
  v33 = v29;
  do
  {
    v34 = (uint8x16_t)vextq_s8(v14, v15, 2uLL);
    v35 = v25;
    v36 = (uint8x16_t)v24;
    v37 = (uint8x16_t)v23;
    v38 = (uint8x16_t)vextq_s8(v13, v12, 2uLL);
    v13 = v22;
    _X11 = (char *)v26 + a2;
    v22 = *(int8x16_t *)((char *)v26 + a2 - 64);
    v23 = *(int8x16_t *)((char *)v26 + a2 - 48);
    v24 = *(int8x16_t *)((char *)v26 + a2 - 32);
    v25 = *(int8x16_t *)((char *)v26 + a2 - 16);
    __asm { PRFM            #0, [X11] }
    v41 = (int8x16_t)vld1q_dup_s16(v33++);
    *v29 = v25.i16[7];
    v42 = (uint8x16_t)vextq_s8(v15, v28, 2uLL);
    v43 = (uint8x16_t)vextq_s8(v12, v14, 2uLL);
    v44 = (uint8x16_t)vextq_s8(v41, v22, 0xEuLL);
    v45 = (uint8x16_t)vextq_s8(v22, v23, 0xEuLL);
    v46 = (uint8x16_t)vextq_s8(v23, v24, 0xEuLL);
    v47 = (uint8x16_t)vextq_s8(v24, v25, 0xEuLL);
    v48 = (int8x16_t)vsqaddq_u8((uint8x16_t)v13, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v13, v38), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v38, (uint8x16_t)v13)), (int8x16_t)vcgtq_u8((uint8x16_t)v13, v44)), (int8x16_t)vcgtq_u8(v44, (uint8x16_t)v13))));
    v49 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v37, v43), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v43, v37)), (int8x16_t)vcgtq_u8(v37, v45)), (int8x16_t)vcgtq_u8(v45, v37)));
    v12 = (int8x16_t)v37;
    v50 = vsqaddq_u8(v37, v49);
    v14 = (int8x16_t)v36;
    v51 = vbslq_s8(v31, (int8x16_t)vsqaddq_u8((uint8x16_t)v35, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v35, v42), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v42, (uint8x16_t)v35)), (int8x16_t)vcgtq_u8((uint8x16_t)v35, v47)), (int8x16_t)vcgtq_u8(v47, (uint8x16_t)v35)))), v35);
    *((int8x16_t *)v26 - 4) = vbslq_s8(v32, v48, v13);
    *((uint8x16_t *)v26 - 3) = v50;
    v28 = (int8x16_t)vld1q_dup_s16(v26);
    --v30;
    *((uint8x16_t *)v26 - 2) = vsqaddq_u8(v36, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v36, v34), (int8x16_t)xmmword_1B6917550, (int8x16_t)xmmword_1B6917530), (int8x16_t)vcgtq_u8(v34, v36)), (int8x16_t)vcgtq_u8(v36, v46)), (int8x16_t)vcgtq_u8(v46, v36))));
    *((int8x16_t *)v26 - 1) = v51;
    v26 = (const __int16 *)((char *)v26 + a2);
    v29 = (__int16 *)v33;
    v15 = v35;
  }
  while (v30 > 1);
  return result;
}

__int16 *sub_1B67B3E14(__int16 *result, uint64_t a2, __int128 *a3, uint64_t a4, _QWORD *a5, uint64_t a6, int a7)
{
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int16x8_t v14;
  const __int16 *v15;
  __int16 *v16;
  uint64_t v24;
  int16x8x2_t v25;
  int8x16x2_t v26;
  int16x8x2_t v27;

  v7 = *a3;
  v8 = a3[1];
  v9 = a3[2];
  v10 = a3[3];
  v13 = a7 + 2;
  v14.i64[0] = 0xFC00FC00FC00FC00;
  v14.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    v15 = result;
    v25 = vld2q_s16(v15);
    v11 = a2;
    v16 = (__int16 *)&v15[v11];
    __asm { PRFM            #0, [X0,#0x20] }
    _X12 = v16;
    v26 = (int8x16x2_t)vld2q_s16(_X12);
    _X12 += 16;
    __asm { PRFM            #0, [X12] }
    LODWORD(v24) = vqtbl2q_s8((int8x16x2_t)v25, (int8x16_t)xmmword_1B69173B0).u32[0];
    HIDWORD(v24) = vqtbl2q_s8(v26, (int8x16_t)xmmword_1B69173A0).i32[1];
    *a5++ = v24;
    v27.val[0] = vminq_s16(vmaxq_s16(vaddw_s8(v25.val[0], vqtbl2_s8(*(int8x16x2_t *)&v7, vshrn_n_s16(v25.val[0], 5uLL))), (int16x8_t)0), v14);
    v27.val[1] = vminq_s16(vmaxq_s16(vaddw_s8(v25.val[1], vqtbl2_s8(*(int8x16x2_t *)&v9, vshrn_n_s16(v25.val[1], 5uLL))), (int16x8_t)0), v14);
    v25.val[0] = vminq_s16(vmaxq_s16(vaddw_s8((int16x8_t)v26.val[0], vqtbl2_s8(*(int8x16x2_t *)&v7, vshrn_n_s16((int16x8_t)v26.val[0], 5uLL))), (int16x8_t)0), v14);
    v25.val[1] = vminq_s16(vmaxq_s16(vaddw_s8((int16x8_t)v26.val[1], vqtbl2_s8(*(int8x16x2_t *)&v9, vshrn_n_s16((int16x8_t)v26.val[1], 5uLL))), (int16x8_t)0), v14);
    vst2q_s16(result, v27);
    v12 = 4 * a2;
    result = (__int16 *)((char *)result + v12);
    vst2q_s16(v16, v25);
    v13 -= 2;
  }
  while (v13 > 2);
  return result;
}

char *sub_1B67B3ED0(char *result, uint64_t a2, __int128 *a3, uint64_t a4, _BYTE *a5, uint64_t a6, int a7)
{
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  int v12;
  const char *v13;
  char *v14;
  int8x8x2_t v22;
  int8x8x2_t v23;

  v7 = *a3;
  v8 = a3[1];
  v9 = a3[2];
  v10 = a3[3];
  v12 = a7 + 2;
  do
  {
    v13 = result;
    v22 = vld2_s8(v13);
    v14 = (char *)&v13[a2];
    __asm { PRFM            #0, [X0,#0x10] }
    _X11 = v14;
    v23 = vld2_s8(_X11);
    _X11 += 16;
    __asm { PRFM            #0, [X11] }
    *a5 = v22.val[0].i8[7];
    a5[1] = v22.val[1].i8[7];
    a5[2] = v23.val[0].i8[7];
    a5[3] = v23.val[1].i8[7];
    v22.val[0] = (int8x8_t)vsqadd_u8((uint8x8_t)v22.val[0], vqtbl2_s8(*(int8x16x2_t *)&v7, (int8x8_t)vshr_n_u8((uint8x8_t)v22.val[0], 3uLL)));
    v22.val[1] = (int8x8_t)vsqadd_u8((uint8x8_t)v22.val[1], vqtbl2_s8(*(int8x16x2_t *)&v9, (int8x8_t)vshr_n_u8((uint8x8_t)v22.val[1], 3uLL)));
    v23.val[0] = (int8x8_t)vsqadd_u8((uint8x8_t)v23.val[0], vqtbl2_s8(*(int8x16x2_t *)&v7, (int8x8_t)vshr_n_u8((uint8x8_t)v23.val[0], 3uLL)));
    vst2_s8(result, v22);
    v11 = 2 * a2;
    result += v11;
    v23.val[1] = (int8x8_t)vsqadd_u8((uint8x8_t)v23.val[1], vqtbl2_s8(*(int8x16x2_t *)&v9, (int8x8_t)vshr_n_u8((uint8x8_t)v23.val[1], 3uLL)));
    vst2_s8(v14, v23);
    v12 -= 2;
    a5 += 4;
  }
  while (v12 > 2);
  return result;
}

__int16 *sub_1B67B3F60(__int16 *result, uint64_t a2, __int128 *a3, uint64_t a4, _QWORD *a5, uint64_t a6, int a7)
{
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int16x8_t v14;
  const __int16 *v15;
  __int16 *v17;
  __int16 *v23;
  uint64_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int16x8_t v29;
  int8x16x2_t v30;
  int16x8x2_t v31;
  int16x8x2_t v32;
  int8x16x2_t v33;
  int16x8x2_t v34;

  v7 = *a3;
  v8 = a3[1];
  v9 = a3[2];
  v10 = a3[3];
  v12 = a7 + 2;
  v14.i64[0] = 0xFC00FC00FC00FC00;
  v14.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    v15 = result;
    v32 = vld2q_s16(v15);
    v11 = a2;
    _X11 = (__int16 *)&v15[v11];
    v17 = result + 16;
    v33 = (int8x16x2_t)vld2q_s16(v17);
    __asm { PRFM            #0, [X0,#0x40] }
    v23 = _X11;
    v31 = vld2q_s16(v23);
    v23 += 16;
    v30 = (int8x16x2_t)vld2q_s16(v23);
    __asm { PRFM            #0, [X11,#0x40] }
    LODWORD(v25) = vqtbl2q_s8(v33, (int8x16_t)xmmword_1B69173B0).u32[0];
    HIDWORD(v25) = vqtbl2q_s8(v30, (int8x16_t)xmmword_1B69173A0).i32[1];
    *a5++ = v25;
    v26 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v32.val[0], 5uLL), (int16x8_t)v33.val[0], 5uLL));
    v34.val[0] = vminq_s16(vmaxq_s16(vaddw_s8(v32.val[0], *(int8x8_t *)v26.i8), (int16x8_t)0), v14);
    v27 = vqtbl2q_s8(*(int8x16x2_t *)&v9, vshrn_high_n_s16(vshrn_n_s16(v32.val[1], 5uLL), (int16x8_t)v33.val[1], 5uLL));
    v34.val[1] = vminq_s16(vmaxq_s16(vaddw_s8(v32.val[1], *(int8x8_t *)v27.i8), (int16x8_t)0), v14);
    v32.val[0] = vminq_s16(vmaxq_s16(vaddw_high_s8((int16x8_t)v33.val[0], v26), (int16x8_t)0), v14);
    v32.val[1] = vminq_s16(vmaxq_s16(vaddw_high_s8((int16x8_t)v33.val[1], v27), (int16x8_t)0), v14);
    v33.val[0] = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v31.val[0], 5uLL), (int16x8_t)v30.val[0], 5uLL));
    v33.val[1] = (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v31.val[0], *(int8x8_t *)v33.val[0].i8), (int16x8_t)0), v14);
    v28 = vqtbl2q_s8(*(int8x16x2_t *)&v9, vshrn_high_n_s16(vshrn_n_s16(v31.val[1], 5uLL), (int16x8_t)v30.val[1], 5uLL));
    v29 = vminq_s16(vmaxq_s16(vaddw_s8(v31.val[1], *(int8x8_t *)v28.i8), (int16x8_t)0), v14);
    vst2q_s16(result, v34);
    v13 = 4 * a2;
    result = (__int16 *)((char *)result + v13);
    v31.val[0] = vminq_s16(vmaxq_s16(vaddw_high_s8((int16x8_t)v30.val[0], v33.val[0]), (int16x8_t)0), v14);
    vst2q_s16(v17, v32);
    v31.val[1] = vminq_s16(vmaxq_s16(vaddw_high_s8((int16x8_t)v30.val[1], v28), (int16x8_t)0), v14);
    vst2q_s16(_X11, *(int16x8x2_t *)((char *)&v33 + 16));
    vst2q_s16(v23, v31);
    v12 -= 2;
  }
  while (v12 > 2);
  return result;
}

char *sub_1B67B4070(char *result, uint64_t a2, __int128 *a3, uint64_t a4, _BYTE *a5, uint64_t a6, int a7)
{
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  int v12;
  const char *v13;
  char *v14;
  int8x16x2_t v22;
  int8x16x2_t v23;

  v7 = *a3;
  v8 = a3[1];
  v9 = a3[2];
  v10 = a3[3];
  v12 = a7 + 2;
  do
  {
    v13 = result;
    v22 = vld2q_s8(v13);
    v14 = (char *)&v13[a2];
    __asm { PRFM            #0, [X0,#0x20] }
    _X11 = v14;
    v23 = vld2q_s8(_X11);
    _X11 += 32;
    __asm { PRFM            #0, [X11] }
    *a5 = v22.val[0].i8[15];
    a5[1] = v22.val[1].i8[15];
    a5[2] = v23.val[0].i8[15];
    a5[3] = v23.val[1].i8[15];
    v22.val[0] = (int8x16_t)vsqaddq_u8((uint8x16_t)v22.val[0], vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8((uint8x16_t)v22.val[0], 3uLL)));
    v22.val[1] = (int8x16_t)vsqaddq_u8((uint8x16_t)v22.val[1], vqtbl2q_s8(*(int8x16x2_t *)&v9, (int8x16_t)vshrq_n_u8((uint8x16_t)v22.val[1], 3uLL)));
    v23.val[0] = (int8x16_t)vsqaddq_u8((uint8x16_t)v23.val[0], vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8((uint8x16_t)v23.val[0], 3uLL)));
    vst2q_s8(result, v22);
    v11 = 2 * a2;
    result += v11;
    v23.val[1] = (int8x16_t)vsqaddq_u8((uint8x16_t)v23.val[1], vqtbl2q_s8(*(int8x16x2_t *)&v9, (int8x16_t)vshrq_n_u8((uint8x16_t)v23.val[1], 3uLL)));
    vst2q_s8(v14, v23);
    v12 -= 2;
    a5 += 4;
  }
  while (v12 > 2);
  return result;
}

__int16 *sub_1B67B4100(__int16 *result, uint64_t a2, __int128 *a3, uint64_t a4, _QWORD *a5, uint64_t a6, int a7)
{
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int16x8_t v14;
  const __int16 *v15;
  __int16 *v17;
  __int16 *v18;
  __int16 *v19;
  __int16 *v26;
  __int16 *v27;
  __int16 *v28;
  uint64_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int16x8_t v34;
  int8x16_t v35;
  int16x8x2_t v36;
  int16x8x2_t v37;
  int16x8x2_t v38;
  int8x16x2_t v39;
  int16x8x2_t v40;
  int16x8x2_t v41;
  int16x8x2_t v42;
  int16x8x2_t v43;
  int8x16x2_t v44;
  int16x8x2_t v45;

  v7 = *a3;
  v8 = a3[1];
  v9 = a3[2];
  v10 = a3[3];
  v12 = a7 + 2;
  v14.i64[0] = 0xFC00FC00FC00FC00;
  v14.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    v15 = result;
    v42 = vld2q_s16(v15);
    v11 = a2;
    _X11 = (__int16 *)&v15[v11];
    v17 = result + 16;
    v36 = vld2q_s16(v17);
    v18 = result + 32;
    v45 = vld2q_s16(v18);
    v19 = result + 48;
    v44 = (int8x16x2_t)vld2q_s16(v19);
    __asm
    {
      PRFM            #0, [X0,#0x80]
      PRFM            #0, [X0,#0xC0]
    }
    v26 = _X11;
    v41 = vld2q_s16(v26);
    v26 += 16;
    v40 = vld2q_s16(v26);
    v27 = _X11 + 32;
    v38 = vld2q_s16(v27);
    v28 = _X11 + 48;
    v39 = (int8x16x2_t)vld2q_s16(v28);
    LODWORD(v29) = vqtbl2q_s8(v44, (int8x16_t)xmmword_1B69173B0).u32[0];
    HIDWORD(v29) = vqtbl2q_s8(v39, (int8x16_t)xmmword_1B69173A0).i32[1];
    v30 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v42.val[0], 5uLL), v36.val[0], 5uLL));
    v31 = vqtbl2q_s8(*(int8x16x2_t *)&v9, vshrn_high_n_s16(vshrn_n_s16(v42.val[1], 5uLL), v36.val[1], 5uLL));
    v42.val[0] = vminq_s16(vmaxq_s16(vaddw_s8(v42.val[0], *(int8x8_t *)v30.i8), (int16x8_t)0), v14);
    __asm
    {
      PRFM            #0, [X11,#0x80]
      PRFM            #0, [X11,#0xC0]
    }
    v42.val[1] = vminq_s16(vmaxq_s16(vaddw_s8(v42.val[1], *(int8x8_t *)v31.i8), (int16x8_t)0), v14);
    *a5++ = v29;
    v43.val[0] = vminq_s16(vmaxq_s16(vaddw_high_s8(v36.val[0], v30), (int16x8_t)0), v14);
    v43.val[1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v36.val[1], v31), (int16x8_t)0), v14);
    v36.val[0] = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v45.val[0], 5uLL), (int16x8_t)v44.val[0], 5uLL));
    v34 = vaddw_high_s8((int16x8_t)v44.val[0], (int8x16_t)v36.val[0]);
    v36.val[0] = vminq_s16(vmaxq_s16(vaddw_s8(v45.val[0], *(int8x8_t *)v36.val[0].i8), (int16x8_t)0), v14);
    v35 = vqtbl2q_s8(*(int8x16x2_t *)&v9, vshrn_high_n_s16(vshrn_n_s16(v45.val[1], 5uLL), (int16x8_t)v44.val[1], 5uLL));
    v36.val[1] = vminq_s16(vmaxq_s16(vaddw_s8(v45.val[1], *(int8x8_t *)v35.i8), (int16x8_t)0), v14);
    v45.val[0] = vminq_s16(vmaxq_s16(v34, (int16x8_t)0), v14);
    v45.val[1] = vminq_s16(vmaxq_s16(vaddw_high_s8((int16x8_t)v44.val[1], v35), (int16x8_t)0), v14);
    v44.val[0] = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v41.val[0], 5uLL), v40.val[0], 5uLL));
    v37.val[0] = vminq_s16(vmaxq_s16(vaddw_s8(v41.val[0], *(int8x8_t *)v44.val[0].i8), (int16x8_t)0), v14);
    v44.val[1] = vqtbl2q_s8(*(int8x16x2_t *)&v9, vshrn_high_n_s16(vshrn_n_s16(v41.val[1], 5uLL), v40.val[1], 5uLL));
    v37.val[1] = vminq_s16(vmaxq_s16(vaddw_s8(v41.val[1], *(int8x8_t *)v44.val[1].i8), (int16x8_t)0), v14);
    v41.val[0] = vminq_s16(vmaxq_s16(vaddw_high_s8(v40.val[0], v44.val[0]), (int16x8_t)0), v14);
    v41.val[1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v40.val[1], v44.val[1]), (int16x8_t)0), v14);
    v40.val[0] = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v38.val[0], 5uLL), (int16x8_t)v39.val[0], 5uLL));
    vst2q_s16(result, v42);
    v13 = 4 * a2;
    result = (__int16 *)((char *)result + v13);
    v42.val[0] = vminq_s16(vmaxq_s16(vaddw_s8(v38.val[0], *(int8x8_t *)v40.val[0].i8), (int16x8_t)0), v14);
    vst2q_s16(v17, v43);
    v40.val[1] = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)&v9, vshrn_high_n_s16(vshrn_n_s16(v38.val[1], 5uLL), (int16x8_t)v39.val[1], 5uLL));
    vst2q_s16(v18, v36);
    vst2q_s16(v19, v45);
    v42.val[1] = vminq_s16(vmaxq_s16(vaddw_s8(v38.val[1], *(int8x8_t *)v40.val[1].i8), (int16x8_t)0), v14);
    vst2q_s16(_X11, v37);
    v38.val[0] = vminq_s16(vmaxq_s16(vaddw_high_s8((int16x8_t)v39.val[0], (int8x16_t)v40.val[0]), (int16x8_t)0), v14);
    vst2q_s16(v26, v41);
    v38.val[1] = vminq_s16(vmaxq_s16(vaddw_high_s8((int16x8_t)v39.val[1], (int8x16_t)v40.val[1]), (int16x8_t)0), v14);
    vst2q_s16(v27, v42);
    vst2q_s16(v28, v38);
    v12 -= 2;
  }
  while (v12 > 2);
  return result;
}

char *sub_1B67B42F0(char *result, uint64_t a2, __int128 *a3, uint64_t a4, _BYTE *a5, uint64_t a6, int a7)
{
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  int v12;
  const char *v13;
  char *v15;
  char *v21;
  int8x16x2_t v23;
  int8x16x2_t v24;
  int8x16x2_t v25;
  int8x16x2_t v26;

  v7 = *a3;
  v8 = a3[1];
  v9 = a3[2];
  v10 = a3[3];
  v12 = a7 + 2;
  do
  {
    v13 = result;
    v23 = vld2q_s8(v13);
    _X10 = (char *)&v13[a2];
    v15 = result + 32;
    v24 = vld2q_s8(v15);
    __asm { PRFM            #0, [X0,#0x40] }
    v21 = _X10;
    v25 = vld2q_s8(v21);
    v21 += 32;
    v26 = vld2q_s8(v21);
    __asm { PRFM            #0, [X10,#0x40] }
    *a5 = v24.val[0].i8[15];
    a5[1] = v24.val[1].i8[15];
    a5[2] = v26.val[0].i8[15];
    a5[3] = v26.val[1].i8[15];
    v23.val[0] = (int8x16_t)vsqaddq_u8((uint8x16_t)v23.val[0], vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8((uint8x16_t)v23.val[0], 3uLL)));
    v23.val[1] = (int8x16_t)vsqaddq_u8((uint8x16_t)v23.val[1], vqtbl2q_s8(*(int8x16x2_t *)&v9, (int8x16_t)vshrq_n_u8((uint8x16_t)v23.val[1], 3uLL)));
    v24.val[0] = (int8x16_t)vsqaddq_u8((uint8x16_t)v24.val[0], vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8((uint8x16_t)v24.val[0], 3uLL)));
    v24.val[1] = (int8x16_t)vsqaddq_u8((uint8x16_t)v24.val[1], vqtbl2q_s8(*(int8x16x2_t *)&v9, (int8x16_t)vshrq_n_u8((uint8x16_t)v24.val[1], 3uLL)));
    v25.val[0] = (int8x16_t)vsqaddq_u8((uint8x16_t)v25.val[0], vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8((uint8x16_t)v25.val[0], 3uLL)));
    v25.val[1] = (int8x16_t)vsqaddq_u8((uint8x16_t)v25.val[1], vqtbl2q_s8(*(int8x16x2_t *)&v9, (int8x16_t)vshrq_n_u8((uint8x16_t)v25.val[1], 3uLL)));
    vst2q_s8(result, v23);
    v11 = 2 * a2;
    result += v11;
    vst2q_s8(v15, v24);
    v26.val[0] = (int8x16_t)vsqaddq_u8((uint8x16_t)v26.val[0], vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8((uint8x16_t)v26.val[0], 3uLL)));
    vst2q_s8(_X10, v25);
    v26.val[1] = (int8x16_t)vsqaddq_u8((uint8x16_t)v26.val[1], vqtbl2q_s8(*(int8x16x2_t *)&v9, (int8x16_t)vshrq_n_u8((uint8x16_t)v26.val[1], 3uLL)));
    vst2q_s8(v21, v26);
    v12 -= 2;
    a5 += 4;
  }
  while (v12 > 2);
  return result;
}

uint64_t sub_1B67B43C4(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v6;
  char *v7;
  unsigned __int8 *v8;
  void *v9;
  uint64_t v10;
  unsigned __int8 *v11;
  void *v12;
  uint64_t v13;
  unsigned __int8 *v14;
  unsigned int v15;
  unint64_t v16;
  unsigned int *v17;
  unsigned int *v18;
  unsigned int v19;
  unint64_t v20;
  unsigned int *v21;
  unsigned int *v22;
  unsigned int v23;
  int v24;
  unint64_t v25;
  unsigned int *v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int v29;
  unint64_t v30;
  unsigned int *v31;
  unsigned int v32;
  int v33;
  unint64_t v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned __int8 v37;
  unsigned int v38;
  unint64_t v39;
  char v40;
  unsigned int *v41;
  unsigned int v42;
  unsigned int v43;
  unint64_t v44;
  char v45;
  unsigned int *v46;
  int v47;
  unint64_t v48;
  unsigned int *v49;
  unsigned int v50;
  unsigned int v51;
  unint64_t v52;
  unsigned int *v53;
  unsigned int v54;
  unint64_t v55;
  char v56;
  unsigned int *v57;
  unsigned int v58;
  unsigned int v59;
  unint64_t v60;
  char v61;
  unsigned int *v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  unint64_t v66;
  unsigned int *v67;
  unsigned int v68;
  int v69;
  int v70;
  int v71;
  unint64_t v72;
  unsigned int *v73;
  unsigned int v74;
  unint64_t v75;
  unsigned int v76;
  unsigned int *v77;
  unsigned int v78;
  int v79;
  int v80;
  unint64_t v81;
  unsigned int *v82;
  unsigned int *v83;
  unsigned int v84;
  int v85;
  unint64_t v86;
  unsigned int *v87;
  unsigned int v88;
  int v89;
  unint64_t v90;
  unsigned int *v91;
  BOOL v92;
  unsigned int v93;
  unsigned __int8 v94;
  int v95;
  int v96;
  int v97;
  unint64_t v98;
  unsigned int *v99;
  unsigned int *v100;
  unsigned int v101;
  int v102;
  unint64_t v103;
  unsigned int *v104;
  unsigned int v105;
  int v106;
  unint64_t v107;
  unsigned int *v108;
  unsigned int v109;
  int v110;
  unint64_t v111;
  unsigned int *v112;
  unsigned int v113;
  int v114;
  unint64_t v115;
  unsigned int *v116;
  unsigned int v117;
  int v118;
  unint64_t v119;
  int v120;
  unsigned int *v121;
  unsigned int v122;
  int v123;
  unsigned int v124;
  unsigned int v125;
  int v126;
  unsigned int *v127;
  unsigned int v128;
  unsigned __int16 v129;
  int v130;
  unint64_t v131;
  char v132;
  unsigned int *v133;
  unsigned int v134;
  int v135;
  uint64_t v136;
  int v137;
  unsigned int *v138;
  unsigned int v139;
  int v140;
  unsigned int v141;
  uint64_t v142;
  int v143;
  unsigned int *v144;
  unsigned int v145;
  unsigned int v146;
  unsigned int *v147;
  std::__shared_weak_count *v148;
  unint64_t *v149;
  unint64_t v150;
  unsigned int v151;
  unint64_t v152;
  unint64_t v153;
  unint64_t v154;
  unsigned int v155;
  unint64_t v156;
  unsigned int v157;
  int v158;
  unint64_t v159;
  char v160;
  unsigned int *v161;
  unsigned int v162;
  int v163;
  unsigned int v164;
  unsigned int v165;
  int v166;
  int v167;
  unsigned int v168;
  int v169;
  unint64_t v170;
  char v171;
  unsigned int *v172;
  BOOL v173;
  unsigned int v174;
  unsigned __int8 v175;
  unint64_t *v176;
  int v177;
  unint64_t v178;
  char v179;
  unsigned int *v180;
  unsigned int v181;
  unint64_t v182;
  unsigned __int8 *v183;
  int v184;
  unsigned int v185;
  unsigned int v186;
  BOOL v187;
  int v188;
  unint64_t v189;
  int v190;
  unsigned int *v191;
  unsigned int *v192;
  unsigned int v193;
  unint64_t v194;
  unsigned __int8 *v195;
  int v196;
  unsigned int v197;
  unint64_t v198;
  char v199;
  unsigned int *v200;
  unsigned int v201;
  unint64_t v202;
  int v203;
  unsigned int *v204;
  unsigned int v205;
  int v206;
  unint64_t v207;
  char v208;
  unsigned int *v209;
  BOOL v210;
  unsigned int v211;
  unint64_t v212;
  unint64_t v213;
  unsigned int *v214;
  unsigned int v215;
  int v216;
  unint64_t v217;
  unsigned int v218;
  unsigned int *v219;
  unsigned int v220;
  int v221;
  _BOOL4 v222;
  unsigned int v223;
  unint64_t v224;
  unsigned int *v225;
  unsigned int v226;
  unsigned int v227;
  unint64_t v228;
  unsigned int v229;
  unint64_t v230;
  unsigned int *v231;
  unsigned int v232;
  int v233;
  unint64_t v234;
  char v235;
  unsigned int v236;
  unsigned __int8 v237;
  uint64_t v238;
  int v239;
  int v240;
  unint64_t v241;
  unsigned int *v242;
  signed int v243;
  unint64_t *p_shared_owners;
  int v245;
  unint64_t v246;
  unsigned int v247;
  unsigned __int16 v248;
  int v249;
  int v250;
  unint64_t v251;
  unsigned int *v252;
  BOOL v253;
  unsigned int v254;
  unint64_t v255;
  unsigned int *v256;
  unsigned int v257;
  int v258;
  unint64_t v259;
  unsigned int *v260;
  unsigned int v261;
  int v262;
  unint64_t v263;
  unsigned int *v264;
  unsigned int v265;
  unsigned int v266;
  unsigned int v267;
  unint64_t v268;
  unsigned int *v269;
  unsigned int v270;
  unint64_t v271;
  unsigned int *v272;
  unsigned int v273;
  unsigned int v274;
  unint64_t v275;
  char v276;
  unsigned int *v277;
  unsigned int v278;
  unsigned int v279;
  int32x4_t v280;
  uint64_t v281;
  unint64_t v282;
  int v283;
  unint64_t v284;
  int v285;
  unint64_t v286;
  unsigned int *v287;
  unsigned int v288;
  int v289;
  unint64_t v290;
  unsigned int v291;
  unint64_t v292;
  unsigned int *v293;
  unsigned int v294;
  unsigned int *v295;
  int v296;
  unint64_t v297;
  char v298;
  unsigned int *v299;
  BOOL v300;
  unsigned int v301;
  int v302;
  unint64_t v303;
  unsigned int *v304;
  unsigned int v305;
  int v306;
  unint64_t v307;
  unsigned int *v308;
  unsigned int v309;
  int v310;
  unint64_t v311;
  unsigned int v312;
  unsigned int *v313;
  unsigned int v314;
  int v315;
  unint64_t v316;
  int v317;
  unsigned int *v318;
  unsigned int v319;
  int v320;
  _BOOL4 v321;
  unsigned int v322;
  unsigned int v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  char v327;
  uint64_t v328;
  unint64_t v329;
  unsigned int *v330;
  unsigned int v331;
  unsigned int v332;
  unint64_t v333;
  unsigned int v334;
  unint64_t v335;
  unsigned int *v336;
  unsigned int v337;
  unsigned __int16 v338;
  uint64_t v339;
  unint64_t v340;
  unsigned int v341;
  unint64_t v342;
  char v343;
  unsigned int *v344;
  unsigned int v345;
  int v346;
  unsigned int v347;
  unsigned int v348;
  unint64_t v349;
  unsigned int v350;
  unsigned int v351;
  int v352;
  unsigned int *v353;
  unsigned int v354;
  int v355;
  uint64_t v356;
  int v357;
  unsigned int *v358;
  unsigned int v359;
  int v360;
  unsigned int v361;
  int v362;
  unsigned int *v363;
  unsigned int v364;
  int v365;
  unsigned int v366;
  int v367;
  unsigned int *v368;
  unsigned int v369;
  int v370;
  unsigned int v371;
  int v372;
  unsigned int *v373;
  unsigned int v374;
  int v375;
  unsigned int v376;
  int v377;
  unsigned int *v378;
  unsigned int v379;
  int v380;
  unsigned int v381;
  int v382;
  unsigned int *v383;
  unsigned int v384;
  int v385;
  uint64_t v386;
  int v387;
  unsigned int *v388;
  unsigned int v389;
  int v390;
  unsigned int v391;
  unsigned int *v392;
  signed int v393;
  unsigned __int8 v394;
  unsigned __int8 v395;
  unsigned __int8 v396;
  unsigned __int8 v397;
  unsigned __int8 v398;
  uint64_t v399;
  char v400;
  unsigned __int8 v401;
  unsigned int v402;
  int v403;
  unsigned __int8 *v404;
  uint32x4_t v405;
  unsigned __int8 v406;
  unsigned __int8 *v407;
  std::__shared_weak_count *v408;
  void *v409[3];
  unsigned int *v410;
  unsigned int *v411;
  unint64_t v412;

  v409[0] = 0;
  v409[1] = 0;
  v411 = 0;
  v412 = 0;
  v410 = 0;
  v4 = sub_1B67C8EF8(v409, (_QWORD *)a2);
  if ((_DWORD)v4)
    goto LABEL_2;
  v6 = *(unsigned __int8 *)(a2 + 24);
  if (v6 == 34)
  {
    v12 = operator new(0x6B8uLL, MEMORY[0x1E0DE4E10]);
    v13 = (uint64_t)v12;
    if (v12)
      sub_1B67E7D44((uint64_t)v12, a1);
    sub_1B67B6744(&v407, v13);
    v14 = v407;
    if (!v407)
    {
      v4 = 4294954392;
      goto LABEL_314;
    }
    if (v407[1704])
    {
      v4 = 4294954385;
LABEL_314:
      v148 = v408;
      if (!v408)
        goto LABEL_2;
      p_shared_owners = (unint64_t *)&v408->__shared_owners_;
      do
        v150 = __ldaxr(p_shared_owners);
      while (__stlxr(v150 - 1, p_shared_owners));
      goto LABEL_317;
    }
    v407[1704] = 1;
    *v14 = sub_1B67C9140((uint64_t)v409);
    v14[1] = sub_1B67C9140((uint64_t)v409);
    v24 = v412;
    v25 = SHIDWORD(v412) + 1;
    HIDWORD(v412) = v25 & 7;
    v26 = v411;
    v27 = (unsigned int *)((char *)v410 + (v25 >> 3));
    v410 = v27;
    if (v27 >= v411)
    {
      if (v27 > v411)
        v27 = v411;
      v28 = v412;
    }
    else
    {
      v28 = bswap32(*v27);
    }
    v47 = v28 << (v25 & 7);
    LODWORD(v412) = v47;
    v14[2] = v24 < 0;
    v48 = (v25 & 7) + 1;
    HIDWORD(v412) = v48 & 7;
    v49 = (unsigned int *)((char *)v27 + (v48 >> 3));
    v410 = v49;
    if (v49 >= v26)
    {
      if (v49 > v26)
        v49 = v26;
      v50 = v47;
    }
    else
    {
      v50 = bswap32(*v49);
    }
    v54 = v50 << (v48 & 7);
    LODWORD(v412) = v54;
    v14[3] = v47 < 0;
    v55 = (v48 & 7) + 3;
    v56 = v55 & 7;
    HIDWORD(v412) = v55 & 7;
    v57 = (unsigned int *)((char *)v49 + (v55 >> 3));
    v410 = v57;
    if (v57 >= v26)
    {
      if (v57 > v26)
        v57 = v26;
      v58 = v54;
    }
    else
    {
      v58 = bswap32(*v57);
    }
    v64 = v54 >> 29;
    v65 = v58 << v56;
    LODWORD(v412) = v58 << v56;
    v14[4] = v64;
    v66 = (v55 & 7) + 1;
    HIDWORD(v412) = v66 & 7;
    v67 = (unsigned int *)((char *)v57 + (v66 >> 3));
    v410 = v67;
    if (v67 >= v26)
    {
      if (v67 > v26)
        v67 = v26;
      v68 = v65;
    }
    else
    {
      v68 = bswap32(*v67);
    }
    v71 = v68 << (v66 & 7);
    LODWORD(v412) = v71;
    v14[5] = v65 < 0;
    v72 = (v66 & 7) + 1;
    HIDWORD(v412) = v72 & 7;
    v73 = (unsigned int *)((char *)v67 + (v72 >> 3));
    v410 = v73;
    if (v73 >= v26)
    {
      if (v73 > v26)
        v410 = v26;
      v74 = v71;
    }
    else
    {
      v74 = bswap32(*v73);
    }
    LODWORD(v412) = v74 << (v72 & 7);
    v14[6] = v71 < 0;
    v14[7] = sub_1B67C9140((uint64_t)v409);
    v14[8] = sub_1B67C9140((uint64_t)v409);
    v79 = sub_1B67C9140((uint64_t)v409);
    v14[9] = (-((v79 + 1) & 1) ^ ((v79 + 1) >> 1)) + ((v79 + 1) & 1);
    v80 = v412;
    v81 = SHIDWORD(v412) + 1;
    HIDWORD(v412) = v81 & 7;
    v82 = v411;
    v83 = (unsigned int *)((char *)v410 + (v81 >> 3));
    v410 = v83;
    if (v83 >= v411)
    {
      if (v83 > v411)
        v83 = v411;
      v84 = v412;
    }
    else
    {
      v84 = bswap32(*v83);
    }
    v85 = v84 << (v81 & 7);
    LODWORD(v412) = v85;
    v14[10] = v80 < 0;
    v86 = (v81 & 7) + 1;
    HIDWORD(v412) = v86 & 7;
    v87 = (unsigned int *)((char *)v83 + (v86 >> 3));
    v410 = v87;
    if (v87 >= v82)
    {
      if (v87 > v82)
        v87 = v82;
      v88 = v85;
    }
    else
    {
      v88 = bswap32(*v87);
    }
    v89 = v88 << (v86 & 7);
    LODWORD(v412) = v89;
    v14[11] = v85 < 0;
    v90 = (v86 & 7) + 1;
    HIDWORD(v412) = v90 & 7;
    v91 = (unsigned int *)((char *)v87 + (v90 >> 3));
    v410 = v91;
    v92 = v91 > v82;
    if (v91 >= v82)
    {
      v93 = v89;
      if (v92)
      {
        v410 = v82;
        v93 = v89;
      }
    }
    else
    {
      v93 = bswap32(*v91);
    }
    LODWORD(v412) = v93 << (v90 & 7);
    v14[12] = v89 < 0;
    if (v89 < 0)
      v94 = sub_1B67C9140((uint64_t)v409);
    else
      v94 = 0;
    v14[13] = v94;
    v95 = sub_1B67C9140((uint64_t)v409);
    v14[14] = (-((v95 + 1) & 1) ^ ((v95 + 1) >> 1)) + ((v95 + 1) & 1);
    v96 = sub_1B67C9140((uint64_t)v409);
    v14[15] = (-((v96 + 1) & 1) ^ ((v96 + 1) >> 1)) + ((v96 + 1) & 1);
    v97 = v412;
    v98 = SHIDWORD(v412) + 1;
    HIDWORD(v412) = v98 & 7;
    v99 = v411;
    v100 = (unsigned int *)((char *)v410 + (v98 >> 3));
    v410 = v100;
    if (v100 >= v411)
    {
      if (v100 > v411)
        v100 = v411;
      v101 = v412;
    }
    else
    {
      v101 = bswap32(*v100);
    }
    v102 = v101 << (v98 & 7);
    LODWORD(v412) = v102;
    v14[16] = v97 < 0;
    v103 = (v98 & 7) + 1;
    HIDWORD(v412) = v103 & 7;
    v104 = (unsigned int *)((char *)v100 + (v103 >> 3));
    v410 = v104;
    if (v104 >= v99)
    {
      if (v104 > v99)
        v104 = v99;
      v105 = v102;
    }
    else
    {
      v105 = bswap32(*v104);
    }
    v106 = v105 << (v103 & 7);
    LODWORD(v412) = v106;
    v14[17] = v102 < 0;
    v107 = (v103 & 7) + 1;
    HIDWORD(v412) = v107 & 7;
    v108 = (unsigned int *)((char *)v104 + (v107 >> 3));
    v410 = v108;
    if (v108 >= v99)
    {
      if (v108 > v99)
        v108 = v99;
      v109 = v106;
    }
    else
    {
      v109 = bswap32(*v108);
    }
    v110 = v109 << (v107 & 7);
    LODWORD(v412) = v110;
    v14[18] = v106 < 0;
    v111 = (v107 & 7) + 1;
    HIDWORD(v412) = v111 & 7;
    v112 = (unsigned int *)((char *)v108 + (v111 >> 3));
    v410 = v112;
    if (v112 >= v99)
    {
      if (v112 > v99)
        v112 = v99;
      v113 = v110;
    }
    else
    {
      v113 = bswap32(*v112);
    }
    v114 = v113 << (v111 & 7);
    LODWORD(v412) = v114;
    v14[19] = v110 < 0;
    v115 = (v111 & 7) + 1;
    HIDWORD(v412) = v115 & 7;
    v116 = (unsigned int *)((char *)v112 + (v115 >> 3));
    v410 = v116;
    if (v116 >= v99)
    {
      if (v116 > v99)
        v116 = v99;
      v117 = v114;
    }
    else
    {
      v117 = bswap32(*v116);
    }
    v118 = v117 << (v115 & 7);
    LODWORD(v412) = v118;
    v14[20] = v114 < 0;
    v119 = (v115 & 7) + 1;
    v120 = v119 & 7;
    HIDWORD(v412) = v120;
    v121 = (unsigned int *)((char *)v116 + (v119 >> 3));
    v410 = v121;
    if (v121 >= v99)
    {
      if (v121 > v99)
      {
        v410 = v99;
        v121 = v99;
      }
      v122 = v118;
    }
    else
    {
      v122 = bswap32(*v121);
    }
    v123 = v122 << v120;
    LODWORD(v412) = v123;
    v14[21] = v118 < 0;
    v14[1696] = v114 < 0;
    if (v114 < 0)
    {
      *((_WORD *)v14 + 11) = sub_1B67C9140((uint64_t)v409);
      v129 = sub_1B67C9140((uint64_t)v409);
      *((_WORD *)v14 + 12) = v129;
      v130 = v412;
      v131 = SHIDWORD(v412) + 1;
      v132 = v131 & 7;
      HIDWORD(v412) = v131 & 7;
      v133 = (unsigned int *)((char *)v410 + (v131 >> 3));
      v410 = v133;
      if (v133 >= v411)
      {
        if (v133 > v411)
          v410 = v411;
        v134 = v412;
      }
      else
      {
        v134 = bswap32(*v133);
      }
      LODWORD(v412) = v134 << v132;
      v14[26] = v130 < 0;
      v152 = *((unsigned __int16 *)v14 + 11);
      v4 = 4294954387;
      if (v152 > 0x13)
        goto LABEL_314;
      if (v129 > 0x15u)
        goto LABEL_314;
      v4 = sub_1B67C8CAC((void **)v14 + 203, v152 + 1);
      if ((_DWORD)v4)
        goto LABEL_314;
      v4 = sub_1B67C8CAC((void **)v14 + 205, *((unsigned __int16 *)v14 + 12) + 1);
      if ((_DWORD)v4)
        goto LABEL_314;
      if (!v14[26])
      {
        if (*((_WORD *)v14 + 11))
        {
          v153 = 0;
          do
            *(_WORD *)(*((_QWORD *)v14 + 203) + 2 * v153++) = sub_1B67C9140((uint64_t)v409);
          while (v153 < *((unsigned __int16 *)v14 + 11));
        }
        if (*((_WORD *)v14 + 12))
        {
          v154 = 0;
          do
            *(_WORD *)(*((_QWORD *)v14 + 205) + 2 * v154++) = sub_1B67C9140((uint64_t)v409);
          while (v154 < *((unsigned __int16 *)v14 + 12));
        }
      }
      v155 = v412;
      v156 = SHIDWORD(v412) + 1;
      v120 = v156 & 7;
      HIDWORD(v412) = v120;
      v99 = v411;
      v121 = (unsigned int *)((char *)v410 + (v156 >> 3));
      v410 = v121;
      if (v121 >= v411)
      {
        if (v121 > v411)
          v121 = v411;
        v157 = v412;
      }
      else
      {
        v157 = bswap32(*v121);
      }
      v123 = v157 << v120;
      LODWORD(v412) = v123;
      v124 = v155 >> 31;
    }
    else
    {
      LOBYTE(v124) = 1;
    }
    v14[27] = v124;
    v125 = v120 + 1;
    v126 = v125 & 7;
    HIDWORD(v412) = v126;
    v127 = (unsigned int *)((char *)v121 + (v125 >> 3));
    v410 = v127;
    if (v127 >= v99)
    {
      if (v127 > v99)
        v127 = v99;
      v128 = v123;
    }
    else
    {
      v128 = bswap32(*v127);
    }
    v135 = v128 << v126;
    LODWORD(v412) = v128 << v126;
    v14[28] = v123 < 0;
    v136 = (v126 + 1) >> 3;
    v137 = (v126 + 1) & 7;
    HIDWORD(v412) = v137;
    v138 = (unsigned int *)((char *)v127 + v136);
    v410 = (unsigned int *)((char *)v127 + v136);
    if ((unsigned int *)((char *)v127 + v136) >= v99)
    {
      if ((unsigned int *)((char *)v127 + v136) > v99)
        v138 = v99;
      v139 = v135;
    }
    else
    {
      v139 = bswap32(*v138);
    }
    v140 = v139 << v137;
    LODWORD(v412) = v140;
    v14[29] = v135 < 0;
    if (v135 < 0)
    {
      v141 = v137 + 1;
      v142 = v141 >> 3;
      v143 = v141 & 7;
      HIDWORD(v412) = v143;
      v144 = (unsigned int *)((char *)v138 + v142);
      v410 = v144;
      if (v144 >= v99)
      {
        if (v144 > v99)
          v144 = v99;
        v145 = v140;
      }
      else
      {
        v145 = bswap32(*v144);
      }
      v163 = v145 << v143;
      LODWORD(v412) = v163;
      v14[30] = v140 < 0;
      v164 = v143 + 1;
      v137 = ((_BYTE)v143 + 1) & 7;
      HIDWORD(v412) = v137;
      v138 = (unsigned int *)((char *)v144 + (v164 >> 3));
      v410 = v138;
      if (v138 >= v99)
      {
        v165 = v163;
        if (v138 > v99)
        {
          v410 = v99;
          v138 = v99;
          v165 = v163;
        }
      }
      else
      {
        v165 = bswap32(*v138);
      }
      v140 = v165 << v137;
      LODWORD(v412) = v140;
      v14[31] = v163 < 0;
      if (v163 < 0)
      {
        LOBYTE(v168) = 0;
        v14[32] = 0;
      }
      else
      {
        v166 = sub_1B67C9140((uint64_t)v409);
        v14[32] = (-((v166 + 1) & 1) ^ ((v166 + 1) >> 1)) + ((v166 + 1) & 1);
        v167 = sub_1B67C9140((uint64_t)v409);
        v168 = (-((v167 + 1) & 1) ^ ((v167 + 1) >> 1)) + ((v167 + 1) & 1);
        v140 = v412;
        v137 = HIDWORD(v412);
        v138 = v410;
        v99 = v411;
      }
      v14[33] = v168;
    }
    v202 = v137 + 1;
    v203 = v202 & 7;
    HIDWORD(v412) = v203;
    v204 = (unsigned int *)((char *)v138 + (v202 >> 3));
    v410 = v204;
    if (v204 >= v99)
    {
      v205 = v140;
      if (v204 > v99)
      {
        v410 = v99;
        v204 = v99;
        v205 = v140;
      }
    }
    else
    {
      v205 = bswap32(*v204);
    }
    v206 = v205 << v203;
    LODWORD(v412) = v206;
    v14[34] = v140 < 0;
    if (v140 < 0)
    {
      sub_1B67CBF08((uint64_t)(v14 + 35), (uint64_t)v409);
      v206 = v412;
      v203 = HIDWORD(v412);
      v204 = v410;
      v99 = v411;
    }
    v207 = v203 + 1;
    v208 = v207 & 7;
    HIDWORD(v412) = v207 & 7;
    v209 = (unsigned int *)((char *)v204 + (v207 >> 3));
    v410 = v209;
    v210 = v209 > v99;
    if (v209 >= v99)
    {
      v211 = v206;
      if (v210)
      {
        v410 = v99;
        v211 = v206;
      }
    }
    else
    {
      v211 = bswap32(*v209);
    }
    LODWORD(v412) = v211 << v208;
    v14[1595] = v206 < 0;
    *((_WORD *)v14 + 798) = sub_1B67C9140((uint64_t)v409);
    v212 = SHIDWORD(v412) + 1;
    HIDWORD(v412) = v212 & 7;
    v213 = (unint64_t)v411;
    v214 = (unsigned int *)((char *)v410 + (v212 >> 3));
    v410 = v214;
    if (v214 >= v411)
    {
      if (v214 > v411)
        v214 = v411;
      v215 = v412;
    }
    else
    {
      v215 = bswap32(*v214);
    }
    v216 = v215 << (v212 & 7);
    v14[1598] = (v412 & 0x80000000) != 0;
    v217 = (v212 & 7) + 1;
    v218 = v217 & 7;
    v412 = __PAIR64__(v218, v216);
    v219 = (unsigned int *)((char *)v214 + (v217 >> 3));
    v410 = v219;
    if ((unint64_t)v219 >= v213)
    {
      v220 = v216;
      if ((unint64_t)v219 > v213)
      {
        v410 = (unsigned int *)v213;
        v219 = (unsigned int *)v213;
        v220 = v216;
      }
    }
    else
    {
      v220 = bswap32(*v219);
    }
    v221 = v220 << v218;
    LODWORD(v412) = v221;
    v14[1599] = v216 < 0;
    if (v216 < 0)
    {
      v224 = (v217 & 7) + 1;
      HIDWORD(v412) = v224 & 7;
      v225 = (unsigned int *)((char *)v219 + (v224 >> 3));
      v410 = v225;
      if ((unint64_t)v225 >= v213)
      {
        if ((unint64_t)v225 > v213)
          v225 = (unsigned int *)v213;
        v226 = v221;
      }
      else
      {
        v226 = bswap32(*v225);
      }
      v227 = v226 << (v224 & 7);
      v223 = v221 >> 31;
      v14[1600] = v221 < 0;
      v228 = (v224 & 7) + 7;
      v218 = v228 & 7;
      v412 = __PAIR64__(v218, v227);
      v219 = (unsigned int *)((char *)v225 + (v228 >> 3));
      v410 = v219;
      if ((unint64_t)v219 >= v213)
      {
        if ((unint64_t)v219 > v213)
        {
          v410 = (unsigned int *)v213;
          v219 = (unsigned int *)v213;
        }
        v229 = v227;
      }
      else
      {
        v229 = bswap32(*v219);
      }
      v221 = v229 << v218;
      LODWORD(v412) = v221;
      v222 = (v227 & 0xFE000000) != 0;
    }
    else
    {
      v222 = 0;
      v223 = v14[1600];
    }
    if (v223)
    {
      if (v14[11])
      {
        v14[1601] = sub_1B67C9140((uint64_t)v409);
        v221 = v412;
        v218 = HIDWORD(v412);
        v219 = v410;
        v213 = (unint64_t)v411;
      }
      v230 = (int)v218 + 1;
      HIDWORD(v412) = v230 & 7;
      v231 = (unsigned int *)((char *)v219 + (v230 >> 3));
      v410 = v231;
      if ((unint64_t)v231 >= v213)
      {
        if ((unint64_t)v231 > v213)
          v231 = (unsigned int *)v213;
        v232 = v221;
      }
      else
      {
        v232 = bswap32(*v231);
      }
      v233 = v232 << (v230 & 7);
      v14[1602] = v221 < 0;
      v234 = (v230 & 7) + 1;
      v235 = v234 & 7;
      LODWORD(v412) = v233;
      HIDWORD(v412) = v234 & 7;
      v219 = (unsigned int *)((char *)v231 + (v234 >> 3));
      v410 = v219;
      if ((unint64_t)v219 >= v213)
      {
        v236 = v233;
        if ((unint64_t)v219 > v213)
        {
          v410 = (unsigned int *)v213;
          v219 = (unsigned int *)v213;
          v236 = v233;
        }
      }
      else
      {
        v236 = bswap32(*v219);
      }
      LODWORD(v412) = v236 << v235;
      v14[1603] = v233 < 0;
      if (v233 < 0)
      {
        v14[1604] = sub_1B67C9140((uint64_t)v409);
        v237 = sub_1B67C9140((uint64_t)v409);
        v14[1605] = v237;
        if ((v237 & 0xFEu) > 5)
          goto LABEL_313;
        v238 = 1612;
        do
        {
          v239 = sub_1B67C9140((uint64_t)v409);
          v14[v238 - 6] = (-((v239 + 1) & 1) ^ ((v239 + 1) >> 1)) + ((v239 + 1) & 1);
          v240 = sub_1B67C9140((uint64_t)v409);
          v14[v238] = (-((v240 + 1) & 1) ^ ((v240 + 1) >> 1)) + ((v240 + 1) & 1);
          v241 = v238 - 1612;
          ++v238;
        }
        while (v241 < v14[1605]);
        v14[1618] = sub_1B67C9140((uint64_t)v409);
        v14[1619] = sub_1B67C9140((uint64_t)v409);
        v219 = v410;
        v213 = (unint64_t)v411;
      }
    }
    if (v222)
    {
      v242 = (unsigned int *)(v213 - 1);
      while (!*(_BYTE *)v242)
      {
        v92 = v242 > v219;
        v242 = (unsigned int *)((char *)v242 - 1);
        if (!v92)
          goto LABEL_313;
      }
      v243 = __clz(__rbit32(*(unsigned __int8 *)v242)) ^ 7;
      if (v242 == v219 && SHIDWORD(v412) > v243)
        goto LABEL_313;
      HIDWORD(v412) = v243;
      v410 = v242;
      LODWORD(v412) = bswap32(*v242) << v243;
    }
    else
    {
      v242 = v219;
    }
    v410 = (unsigned int *)((char *)v242 + 1);
    HIDWORD(v412) = 0;
    if ((unint64_t)v242 + 1 > v213)
      v410 = (unsigned int *)v213;
    if (*v14 <= 0x3Fu && v14[1] <= 0xFu)
    {
      sub_1B67B665C((_QWORD *)(a1 + 16 * *v407 + 512), (uint64_t)v407, (uint64_t)v408);
      v4 = 0;
      goto LABEL_314;
    }
LABEL_313:
    v4 = 4294954387;
    goto LABEL_314;
  }
  if (v6 != 33)
  {
    if (v6 != 32)
    {
      v4 = 4294954385;
      goto LABEL_2;
    }
    v7 = (char *)operator new(0x120uLL, MEMORY[0x1E0DE4E10]);
    if (v7)
    {
      *(_QWORD *)(v7 + 7) = 0;
      *(_QWORD *)v7 = 0;
      *((_OWORD *)v7 + 1) = 0u;
      *((_OWORD *)v7 + 2) = 0u;
      *((_OWORD *)v7 + 3) = 0u;
      *((_WORD *)v7 + 32) = 0;
      *(_OWORD *)(v7 + 68) = 0u;
      *(_OWORD *)(v7 + 84) = 0u;
      *(_OWORD *)(v7 + 100) = 0u;
      *(_OWORD *)(v7 + 116) = 0u;
      *(_OWORD *)(v7 + 132) = 0u;
      *(_OWORD *)(v7 + 148) = 0u;
      *((_WORD *)v7 + 82) = 0;
      *((_WORD *)v7 + 109) = 0;
      *((_DWORD *)v7 + 64) = 0;
      *((_WORD *)v7 + 130) = 0;
      v7[262] = 0;
      *((_QWORD *)v7 + 21) = 0;
      *((_QWORD *)v7 + 22) = 0;
      *((_WORD *)v7 + 92) = 0;
      *(_QWORD *)(v7 + 204) = 0;
      *(_QWORD *)(v7 + 209) = 0;
      *(_QWORD *)(v7 + 188) = 0;
      *(_QWORD *)(v7 + 196) = 0;
      *((_QWORD *)v7 + 28) = 0;
      *((_QWORD *)v7 + 29) = 0;
      v7[240] = 0;
      *(_QWORD *)(v7 + 244) = 0;
      v7[252] = 0;
      *((_QWORD *)v7 + 33) = 0;
      *((_QWORD *)v7 + 34) = 0;
      v7[280] = 0;
    }
    sub_1B67B65E8(&v407, (uint64_t)v7);
    v8 = v407;
    if (v407)
    {
      if (v407[280])
      {
        v4 = 4294954385;
      }
      else
      {
        v407[280] = 1;
        v20 = SHIDWORD(v412) + 4;
        HIDWORD(v412) = v20 & 7;
        v21 = v411;
        v22 = (unsigned int *)((char *)v410 + (v20 >> 3));
        v410 = v22;
        if (v22 >= v411)
        {
          if (v22 > v411)
            v22 = v411;
          v23 = v412;
        }
        else
        {
          v23 = bswap32(*v22);
        }
        v43 = v23 << (v20 & 7);
        v8[168] = v412 >> 28;
        v44 = (v20 & 7) + 2;
        v45 = v44 & 7;
        LODWORD(v412) = v43;
        HIDWORD(v412) = v44 & 7;
        v46 = (unsigned int *)((char *)v22 + (v44 >> 3));
        v410 = v46;
        if (v46 >= v21)
        {
          if (v46 > v21)
            v46 = v21;
        }
        else
        {
          v43 = bswap32(*v46);
        }
        v51 = v43 << v45;
        v52 = (v44 & 7) + 6;
        LODWORD(v412) = v43 << v45;
        HIDWORD(v412) = v52 & 7;
        v53 = (unsigned int *)((char *)v46 + (v52 >> 3));
        v410 = v53;
        if (v53 >= v21)
        {
          if (v53 > v21)
            v53 = v21;
        }
        else
        {
          v51 = bswap32(*v53);
        }
        v59 = v51 << (v52 & 7);
        v60 = (v52 & 7) + 3;
        v61 = v60 & 7;
        LODWORD(v412) = v59;
        HIDWORD(v412) = v60 & 7;
        v62 = (unsigned int *)((char *)v53 + (v60 >> 3));
        v410 = v62;
        if (v62 >= v21)
        {
          if (v62 > v21)
          {
            v410 = v21;
            v62 = v21;
          }
          v63 = v59;
        }
        else
        {
          v63 = bswap32(*v62);
        }
        v69 = v59 >> 29;
        v70 = v63 << v61;
        LODWORD(v412) = v63 << v61;
        v8[169] = v69;
        if (v69 != 7)
        {
          v75 = (v60 & 7) + 1;
          v76 = v75 & 7;
          HIDWORD(v412) = v76;
          v77 = (unsigned int *)((char *)v62 + (v75 >> 3));
          v410 = v77;
          if (v77 >= v21)
          {
            if (v77 > v21)
              v77 = v21;
            v78 = v70;
          }
          else
          {
            v78 = bswap32(*v77);
          }
          v146 = v78 << v76;
          v8[170] = v70 < 0;
          v412 = __PAIR64__(v76, v146);
          v147 = (unsigned int *)((char *)v77 + 2);
          v410 = v147;
          if (v147 >= v21)
          {
            if (v147 > v21)
              v410 = v21;
          }
          else
          {
            v146 = bswap32(*v147);
          }
          LODWORD(v412) = v146 << v76;
          v4 = sub_1B68031DC((uint64_t)v8, v69, (uint64_t)v409);
          if ((_DWORD)v4)
            goto LABEL_166;
          v158 = v412;
          v159 = SHIDWORD(v412) + 1;
          v160 = v159 & 7;
          HIDWORD(v412) = v159 & 7;
          v161 = (unsigned int *)((char *)v410 + (v159 >> 3));
          v410 = v161;
          if (v161 >= v411)
          {
            if (v161 > v411)
              v410 = v411;
            v162 = v412;
          }
          else
          {
            v162 = bswap32(*v161);
          }
          v194 = 0;
          LODWORD(v412) = v162 << v160;
          v8[171] = v158 < 0;
          while (1)
          {
            if (!v194 || v8[171])
            {
              v8[v194 + 172] = sub_1B67C9140((uint64_t)v409);
              v8[v194 + 179] = sub_1B67C9140((uint64_t)v409);
              v196 = sub_1B67C91C8((uint64_t)v409);
            }
            else
            {
              v195 = &v8[v194];
              v195[172] = v8[172];
              v195[179] = v8[179];
              v196 = *((_DWORD *)v8 + 47);
            }
            *(_DWORD *)&v8[4 * v194 + 188] = v196;
            if (v8[v194 + 172] > 0xFu)
              break;
            v187 = v194++ >= v8[169];
            if (v187)
            {
              v197 = v412;
              v198 = SHIDWORD(v412) + 6;
              v199 = v198 & 7;
              HIDWORD(v412) = v198 & 7;
              v200 = (unsigned int *)((char *)v410 + (v198 >> 3));
              v410 = v200;
              if (v200 >= v411)
              {
                if (v200 > v411)
                  v410 = v411;
                v201 = v412;
              }
              else
              {
                v201 = bswap32(*v200);
              }
              LODWORD(v412) = v201 << v199;
              v8[216] = v197 >> 26;
              v248 = sub_1B67C9140((uint64_t)v409);
              *((_WORD *)v8 + 109) = v248;
              if (v248 > 0x3FFu)
                break;
              if (v248)
              {
                v4 = 4294954386;
                goto LABEL_166;
              }
              v250 = v412;
              v251 = SHIDWORD(v412) + 1;
              HIDWORD(v412) = v251 & 7;
              v252 = (unsigned int *)((char *)v410 + (v251 >> 3));
              v410 = v252;
              v253 = v252 > v411;
              if (v252 >= v411)
              {
                v254 = v412;
                if (v253)
                {
                  v410 = v411;
                  v254 = v412;
                }
              }
              else
              {
                v254 = bswap32(*v252);
              }
              LODWORD(v412) = v254 << (v251 & 7);
              v8[240] = v250 < 0;
              if (v250 < 0)
              {
                *((_DWORD *)v8 + 61) = sub_1B67C90EC((uint64_t)v409, 32);
                *((_DWORD *)v8 + 62) = sub_1B67C90EC((uint64_t)v409, 32);
                v296 = v412;
                v297 = SHIDWORD(v412) + 1;
                v298 = v297 & 7;
                HIDWORD(v412) = v297 & 7;
                v299 = (unsigned int *)((char *)v410 + (v297 >> 3));
                v410 = v299;
                v300 = v299 > v411;
                if (v299 >= v411)
                {
                  v301 = v412;
                  if (v300)
                  {
                    v410 = v411;
                    v301 = v412;
                  }
                }
                else
                {
                  v301 = bswap32(*v299);
                }
                LODWORD(v412) = v301 << v298;
                v8[252] = v296 < 0;
                if (v296 < 0)
                  *((_DWORD *)v8 + 64) = sub_1B67C91C8((uint64_t)v409);
                v338 = sub_1B67C9140((uint64_t)v409);
                *((_WORD *)v8 + 130) = v338;
                if (v338)
                {
                  v4 = sub_1B6803C98((uint64_t)(v8 + 264), v338);
                  if ((_DWORD)v4)
                    goto LABEL_166;
                  if (*((_WORD *)v8 + 130))
                  {
                    v339 = 0;
                    v340 = 0;
                    do
                    {
                      sub_1B67C9140((uint64_t)v409);
                      if (v340)
                      {
                        v341 = v412;
                        v342 = SHIDWORD(v412) + 1;
                        v343 = v342 & 7;
                        HIDWORD(v412) = v342 & 7;
                        v344 = (unsigned int *)((char *)v410 + (v342 >> 3));
                        v410 = v344;
                        if (v344 >= v411)
                        {
                          if (v344 > v411)
                            v410 = v411;
                          v345 = v412;
                        }
                        else
                        {
                          v345 = bswap32(*v344);
                        }
                        LODWORD(v412) = v345 << v343;
                        v346 = v341 >> 31;
                      }
                      else
                      {
                        v346 = 1;
                      }
                      v4 = sub_1B6803730(*((_QWORD *)v8 + 33) + v339, (uint64_t)v409, v346, v8[169] + 1);
                      if ((_DWORD)v4)
                        goto LABEL_166;
                      ++v340;
                      v339 += 32;
                    }
                    while (v340 < *((unsigned __int16 *)v8 + 130));
                  }
                }
              }
              v289 = v412;
              v290 = SHIDWORD(v412) + 1;
              v291 = v290 & 7;
              HIDWORD(v412) = v291;
              v292 = (unint64_t)v411;
              v293 = (unsigned int *)((char *)v410 + (v290 >> 3));
              v410 = v293;
              if (v293 >= v411)
              {
                v294 = v412;
                if (v293 > v411)
                {
                  v410 = v411;
                  v293 = v411;
                  v294 = v412;
                }
              }
              else
              {
                v294 = bswap32(*v293);
              }
              LODWORD(v412) = v294 << v291;
              v8[262] = v289 < 0;
              if (v289 < 0)
              {
                v295 = (unsigned int *)(v292 - 1);
                v4 = 4294954387;
                while (!*(_BYTE *)v295)
                {
                  v92 = v295 > v293;
                  v295 = (unsigned int *)((char *)v295 - 1);
                  if (!v92)
                    goto LABEL_166;
                }
                v347 = __clz(__rbit32(*(unsigned __int8 *)v295)) ^ 7;
                if (v295 == v293 && v291 > v347)
                  break;
                HIDWORD(v412) = v347;
                v410 = v295;
                LODWORD(v412) = bswap32(*v295) << v347;
              }
              else
              {
                v295 = v293;
              }
              v410 = (unsigned int *)((char *)v295 + 1);
              HIDWORD(v412) = 0;
              if ((unint64_t)v295 + 1 > v292)
                v410 = (unsigned int *)v292;
              if (sub_1B6803D34((uint64_t)v8))
              {
                sub_1B67B665C((_QWORD *)(a1 + 16 * v407[168]), (uint64_t)v407, (uint64_t)v408);
                v4 = 0;
                goto LABEL_166;
              }
              break;
            }
          }
        }
        v4 = 4294954387;
      }
    }
    else
    {
      v4 = 4294954392;
    }
LABEL_166:
    v148 = v408;
    if (!v408)
      goto LABEL_2;
    v149 = (unint64_t *)&v408->__shared_owners_;
    do
      v150 = __ldaxr(v149);
    while (__stlxr(v150 - 1, v149));
    goto LABEL_317;
  }
  v9 = operator new(0x820uLL, MEMORY[0x1E0DE4E10]);
  v10 = (uint64_t)v9;
  if (v9)
    sub_1B6890838((uint64_t)v9, a1);
  sub_1B67B66D0(&v407, v10);
  v11 = v407;
  if (v407)
  {
    if (v407[2064])
    {
      v4 = 4294954385;
    }
    else
    {
      v407[2064] = 1;
      v15 = v412;
      v16 = SHIDWORD(v412) + 4;
      HIDWORD(v412) = v16 & 7;
      v17 = v411;
      v18 = (unsigned int *)((char *)v410 + (v16 >> 3));
      v410 = v18;
      if (v18 >= v411)
      {
        if (v18 > v411)
          v18 = v411;
        v19 = v412;
      }
      else
      {
        v19 = bswap32(*v18);
      }
      v29 = v19 << (v16 & 7);
      LODWORD(v412) = v29;
      *v11 = v15 >> 28;
      v30 = (v16 & 7) + 3;
      HIDWORD(v412) = v30 & 7;
      v31 = (unsigned int *)((char *)v18 + (v30 >> 3));
      v410 = v31;
      if (v31 >= v17)
      {
        if (v31 > v17)
          v31 = v17;
        v32 = v29;
      }
      else
      {
        v32 = bswap32(*v31);
      }
      v33 = v29 >> 29;
      LODWORD(v412) = v32 << (v30 & 7);
      v11[1] = v29 >> 29;
      v34 = (v30 & 7) + 1;
      HIDWORD(v412) = v34 & 7;
      v35 = (unsigned int *)((char *)v31 + (v34 >> 3));
      v410 = v35;
      if (v35 >= v17)
      {
        if (v35 > v17)
          v410 = v17;
        v36 = v32 << (v30 & 7);
      }
      else
      {
        v36 = bswap32(*v35);
      }
      LODWORD(v412) = v36 << (v34 & 7);
      v11[2] = ((v32 << (v30 & 7)) & 0x80000000) != 0;
      v4 = sub_1B68031DC((uint64_t)(v11 + 4), v33, (uint64_t)v409);
      if (!(_DWORD)v4)
      {
        v11[172] = sub_1B67C9140((uint64_t)v409);
        v37 = sub_1B67C9140((uint64_t)v409);
        v11[173] = v37;
        if (v37 == 3)
        {
          v38 = v412;
          v39 = SHIDWORD(v412) + 1;
          v40 = v39 & 7;
          HIDWORD(v412) = v39 & 7;
          v41 = (unsigned int *)((char *)v410 + (v39 >> 3));
          v410 = v41;
          if (v41 >= v411)
          {
            if (v41 > v411)
              v410 = v411;
            v42 = v412;
          }
          else
          {
            v42 = bswap32(*v41);
          }
          LODWORD(v412) = v42 << v40;
          v151 = v38 >> 31;
        }
        else
        {
          LOBYTE(v151) = 0;
        }
        v11[174] = v151;
        *((_DWORD *)v11 + 44) = sub_1B67C91C8((uint64_t)v409);
        *((_DWORD *)v11 + 45) = sub_1B67C91C8((uint64_t)v409);
        v169 = v412;
        v170 = SHIDWORD(v412) + 1;
        v171 = v170 & 7;
        HIDWORD(v412) = v170 & 7;
        v172 = (unsigned int *)((char *)v410 + (v170 >> 3));
        v410 = v172;
        v173 = v172 > v411;
        if (v172 >= v411)
        {
          v174 = v412;
          if (v173)
          {
            v410 = v411;
            v174 = v412;
          }
        }
        else
        {
          v174 = bswap32(*v172);
        }
        LODWORD(v412) = v174 << v171;
        v11[184] = v169 < 0;
        if (v169 < 0)
        {
          *((_WORD *)v11 + 93) = sub_1B67C91C8((uint64_t)v409);
          *((_WORD *)v11 + 94) = sub_1B67C91C8((uint64_t)v409);
          *((_WORD *)v11 + 95) = sub_1B67C91C8((uint64_t)v409);
          *((_WORD *)v11 + 96) = sub_1B67C91C8((uint64_t)v409);
        }
        v11[194] = sub_1B67C9140((uint64_t)v409);
        v11[195] = sub_1B67C9140((uint64_t)v409);
        v175 = sub_1B67C9140((uint64_t)v409);
        v11[196] = v175;
        if (v175 <= 0xCu)
        {
          v177 = v412;
          v178 = SHIDWORD(v412) + 1;
          v179 = v178 & 7;
          HIDWORD(v412) = v178 & 7;
          v180 = (unsigned int *)((char *)v410 + (v178 >> 3));
          v410 = v180;
          if (v180 >= v411)
          {
            if (v180 > v411)
              v410 = v411;
            v181 = v412;
          }
          else
          {
            v181 = bswap32(*v180);
          }
          v182 = 0;
          LODWORD(v412) = v181 << v179;
          v11[197] = v177 < 0;
          *((_WORD *)v11 + 1012) = 0;
          while (1)
          {
            if (!v182 || v11[197])
            {
              v11[v182 + 198] = sub_1B67C9140((uint64_t)v409);
              v11[v182 + 205] = sub_1B67C9140((uint64_t)v409);
              v184 = sub_1B67C91C8((uint64_t)v409);
            }
            else
            {
              v183 = &v11[v182];
              v183[198] = v11[198];
              v183[205] = v11[205];
              v184 = *((_DWORD *)v11 + 53);
            }
            *(_DWORD *)&v11[4 * v182 + 212] = v184;
            v185 = v11[v182 + 198];
            if (v185 > 0xF)
              break;
            if (v11[2024] > v185)
              LOBYTE(v185) = v11[2024];
            v11[2024] = v185;
            v186 = v11[v182 + 205];
            if (v11[2025] > v186)
              LOBYTE(v186) = v11[2025];
            v11[2025] = v186;
            v187 = v182++ >= v11[1];
            if (v187)
            {
              v11[240] = sub_1B67C9140((uint64_t)v409);
              v11[241] = sub_1B67C9140((uint64_t)v409);
              v11[242] = sub_1B67C9140((uint64_t)v409);
              v11[243] = sub_1B67C9140((uint64_t)v409);
              v11[244] = sub_1B67C9140((uint64_t)v409);
              v11[245] = sub_1B67C9140((uint64_t)v409);
              v188 = v412;
              v189 = SHIDWORD(v412) + 1;
              v190 = v189 & 7;
              HIDWORD(v412) = v190;
              v191 = v411;
              v192 = (unsigned int *)((char *)v410 + (v189 >> 3));
              v410 = v192;
              if (v192 >= v411)
              {
                if (v192 > v411)
                  v192 = v411;
                v193 = v412;
              }
              else
              {
                v193 = bswap32(*v192);
              }
              v245 = v193 << v190;
              LODWORD(v412) = v245;
              v11[246] = v188 < 0;
              if (v188 < 0)
              {
                v246 = (v189 & 7) + 1;
                v190 = v246 & 7;
                HIDWORD(v412) = v190;
                v192 = (unsigned int *)((char *)v192 + (v246 >> 3));
                v410 = v192;
                if (v192 >= v191)
                {
                  v247 = v245;
                  if (v192 > v191)
                  {
                    v410 = v191;
                    v192 = v191;
                    v247 = v245;
                  }
                }
                else
                {
                  v247 = bswap32(*v192);
                }
                v249 = v247 << v190;
                LODWORD(v412) = v249;
                v11[247] = v245 < 0;
                if (v245 < 0)
                {
                  sub_1B67CBF08((uint64_t)(v11 + 336), (uint64_t)v409);
                  v245 = v412;
                  v190 = HIDWORD(v412);
                  v192 = v410;
                  v191 = v411;
                }
                else
                {
                  v245 = v249;
                }
              }
              v255 = v190 + 1;
              HIDWORD(v412) = v255 & 7;
              v256 = (unsigned int *)((char *)v192 + (v255 >> 3));
              v410 = v256;
              if (v256 >= v191)
              {
                if (v256 > v191)
                  v256 = v191;
                v257 = v245;
              }
              else
              {
                v257 = bswap32(*v256);
              }
              v258 = v257 << (v255 & 7);
              v11[248] = v245 < 0;
              v259 = (v255 & 7) + 1;
              LODWORD(v412) = v258;
              HIDWORD(v412) = v259 & 7;
              v260 = (unsigned int *)((char *)v256 + (v259 >> 3));
              v410 = v260;
              if (v260 >= v191)
              {
                if (v260 > v191)
                  v260 = v191;
                v261 = v258;
              }
              else
              {
                v261 = bswap32(*v260);
              }
              v262 = v261 << (v259 & 7);
              v11[249] = v258 < 0;
              v263 = (v259 & 7) + 1;
              LODWORD(v412) = v262;
              HIDWORD(v412) = v263 & 7;
              v264 = (unsigned int *)((char *)v260 + (v263 >> 3));
              v410 = v264;
              if (v264 >= v191)
              {
                v265 = v261 << (v259 & 7);
                if (v264 > v191)
                {
                  v410 = v191;
                  v264 = v191;
                  v265 = v262;
                }
              }
              else
              {
                v265 = bswap32(*v264);
              }
              v266 = v265 << (v263 & 7);
              LODWORD(v412) = v266;
              v11[250] = v262 < 0;
              if (v262 < 0)
              {
                v268 = (v263 & 7) + 4;
                HIDWORD(v412) = v268 & 7;
                v269 = (unsigned int *)((char *)v264 + (v268 >> 3));
                v410 = v269;
                if (v269 >= v191)
                {
                  if (v269 > v191)
                    v269 = v191;
                  v270 = v266;
                }
                else
                {
                  v270 = bswap32(*v269);
                }
                v11[251] = v266 >> 28;
                v271 = (v268 & 7) + 4;
                LODWORD(v412) = v270 << (v268 & 7);
                HIDWORD(v412) = v271 & 7;
                v272 = (unsigned int *)((char *)v269 + (v271 >> 3));
                v410 = v272;
                if (v272 >= v191)
                {
                  if (v272 > v191)
                    v410 = v191;
                  v273 = v270 << (v268 & 7);
                }
                else
                {
                  v273 = bswap32(*v272);
                }
                LODWORD(v412) = v273 << (v271 & 7);
                v11[252] = v270 << (v268 & 7) >> 28;
                v11[253] = sub_1B67C9140((uint64_t)v409);
                v11[254] = sub_1B67C9140((uint64_t)v409);
                v274 = v412;
                v275 = SHIDWORD(v412) + 1;
                v276 = v275 & 7;
                HIDWORD(v412) = v275 & 7;
                v277 = (unsigned int *)((char *)v410 + (v275 >> 3));
                v410 = v277;
                if (v277 >= v411)
                {
                  if (v277 > v411)
                    v410 = v411;
                  v278 = v412;
                }
                else
                {
                  v278 = bswap32(*v277);
                }
                LODWORD(v412) = v278 << v276;
                v267 = v274 >> 31;
              }
              else
              {
                LOBYTE(v267) = 0;
              }
              v11[255] = v267;
              v279 = sub_1B67C9140((uint64_t)v409);
              *((_DWORD *)v11 + 65) = v279;
              if (v279 > 0x40)
                break;
              v4 = sub_1B680EB20((void **)v11 + 33, v279);
              if ((_DWORD)v4)
                goto LABEL_211;
              if (*((_DWORD *)v11 + 65))
              {
                v281 = 0;
                v282 = 0;
                do
                {
                  v4 = sub_1B688EE54(*((_QWORD *)v11 + 33) + v281, (uint64_t)v409, (uint64_t)v11, v282);
                  if ((_DWORD)v4)
                    goto LABEL_211;
                  ++v282;
                  v281 += 248;
                }
                while (v282 < *((unsigned int *)v11 + 65));
              }
              v283 = v412;
              v284 = SHIDWORD(v412) + 1;
              v285 = v284 & 7;
              HIDWORD(v412) = v285;
              v286 = (unint64_t)v411;
              v287 = (unsigned int *)((char *)v410 + (v284 >> 3));
              v410 = v287;
              if (v287 >= v411)
              {
                v288 = v412;
                if (v287 > v411)
                {
                  v410 = v411;
                  v287 = v411;
                  v288 = v412;
                }
              }
              else
              {
                v288 = bswap32(*v287);
              }
              v302 = v288 << v285;
              LODWORD(v412) = v302;
              v11[280] = v283 < 0;
              if (v283 < 0)
              {
                v323 = sub_1B67C9140((uint64_t)v409);
                *((_DWORD *)v11 + 71) = v323;
                if (v323 > 0x20)
                  break;
                *((_WORD *)v11 + 160) = 0;
                v302 = v412;
                v285 = HIDWORD(v412);
                v287 = v410;
                v286 = (unint64_t)v411;
                if (v323)
                {
                  v324 = 0;
                  v325 = v11[196];
                  v326 = v325 + 4;
                  v327 = 28 - v325;
                  v328 = v323;
                  do
                  {
                    v329 = v326 + v285;
                    HIDWORD(v412) = v329 & 7;
                    v330 = (unsigned int *)((char *)v287 + (v329 >> 3));
                    v410 = v330;
                    if ((unint64_t)v330 >= v286)
                    {
                      if ((unint64_t)v330 > v286)
                        v330 = (unsigned int *)v286;
                      v331 = v302;
                    }
                    else
                    {
                      v331 = bswap32(*v330);
                    }
                    v332 = v331 << (v329 & 7);
                    LODWORD(v412) = v332;
                    *(_WORD *)&v11[2 * v324 + 288] = v302 >> v327;
                    v333 = (v329 & 7) + 1;
                    v285 = v333 & 7;
                    HIDWORD(v412) = v285;
                    v287 = (unsigned int *)((char *)v330 + (v333 >> 3));
                    v410 = v287;
                    if ((unint64_t)v287 >= v286)
                    {
                      if ((unint64_t)v287 > v286)
                      {
                        v410 = (unsigned int *)v286;
                        v287 = (unsigned int *)v286;
                      }
                      v334 = v332;
                    }
                    else
                    {
                      v334 = bswap32(*v287);
                    }
                    v302 = v334 << v285;
                    LODWORD(v412) = v302;
                    *((_WORD *)v11 + 160) |= v332 >> 31 << v324++;
                  }
                  while (v328 != v324);
                }
              }
              v303 = v285 + 1;
              HIDWORD(v412) = v303 & 7;
              v304 = (unsigned int *)((char *)v287 + (v303 >> 3));
              v410 = v304;
              if ((unint64_t)v304 >= v286)
              {
                if ((unint64_t)v304 > v286)
                  v304 = (unsigned int *)v286;
                v305 = v302;
              }
              else
              {
                v305 = bswap32(*v304);
              }
              v306 = v305 << (v303 & 7);
              v11[322] = v302 < 0;
              v307 = (v303 & 7) + 1;
              LODWORD(v412) = v306;
              HIDWORD(v412) = v307 & 7;
              v308 = (unsigned int *)((char *)v304 + (v307 >> 3));
              v410 = v308;
              if ((unint64_t)v308 >= v286)
              {
                if ((unint64_t)v308 > v286)
                  v308 = (unsigned int *)v286;
                v309 = v305 << (v303 & 7);
              }
              else
              {
                v309 = bswap32(*v308);
              }
              v310 = v309 << (v307 & 7);
              v11[323] = v306 < 0;
              v311 = (v307 & 7) + 1;
              v312 = v311 & 7;
              v412 = __PAIR64__(v312, v310);
              v313 = (unsigned int *)((char *)v308 + (v311 >> 3));
              v410 = v313;
              if ((unint64_t)v313 >= v286)
              {
                v314 = v310;
                if ((unint64_t)v313 > v286)
                {
                  v410 = (unsigned int *)v286;
                  v313 = (unsigned int *)v286;
                  v314 = v310;
                }
              }
              else
              {
                v314 = bswap32(*v313);
              }
              v315 = v314 << v312;
              LODWORD(v412) = v315;
              v11[324] = v310 < 0;
              if (v310 < 0)
              {
                sub_1B67CE9A8((uint64_t)(v11 + 1896), (uint64_t)v409, (uint64_t)v11);
                v315 = v412;
                v312 = HIDWORD(v412);
                v313 = v410;
                v286 = (unint64_t)v411;
              }
              v316 = (int)v312 + 1;
              v317 = v316 & 7;
              HIDWORD(v412) = v317;
              v318 = (unsigned int *)((char *)v313 + (v316 >> 3));
              v410 = v318;
              if ((unint64_t)v318 >= v286)
              {
                v319 = v315;
                if ((unint64_t)v318 > v286)
                {
                  v410 = (unsigned int *)v286;
                  v318 = (unsigned int *)v286;
                  v319 = v315;
                }
              }
              else
              {
                v319 = bswap32(*v318);
              }
              v320 = v319 << v317;
              LODWORD(v412) = v320;
              v11[325] = v315 < 0;
              if (v315 < 0)
              {
                v335 = (v316 & 7) + 1;
                HIDWORD(v412) = v335 & 7;
                v336 = (unsigned int *)((char *)v318 + (v335 >> 3));
                v410 = v336;
                if ((unint64_t)v336 >= v286)
                {
                  if ((unint64_t)v336 > v286)
                    v336 = (unsigned int *)v286;
                  v337 = v320;
                }
                else
                {
                  v337 = bswap32(*v336);
                }
                v348 = v337 << (v335 & 7);
                v322 = v320 >> 31;
                v11[326] = v320 < 0;
                v349 = (v335 & 7) + 7;
                v317 = v349 & 7;
                v412 = __PAIR64__(v317, v348);
                v318 = (unsigned int *)((char *)v336 + (v349 >> 3));
                v410 = v318;
                if ((unint64_t)v318 >= v286)
                {
                  if ((unint64_t)v318 > v286)
                  {
                    v410 = (unsigned int *)v286;
                    v318 = (unsigned int *)v286;
                  }
                  v350 = v348;
                }
                else
                {
                  v350 = bswap32(*v318);
                }
                v320 = v350 << v317;
                LODWORD(v412) = v320;
                v321 = (v348 & 0xFE000000) != 0;
              }
              else
              {
                v321 = 0;
                v322 = v11[326];
              }
              if (v322)
              {
                v351 = v317 + 1;
                v352 = v351 & 7;
                HIDWORD(v412) = v352;
                v353 = (unsigned int *)((char *)v318 + (v351 >> 3));
                v410 = v353;
                if ((unint64_t)v353 >= v286)
                {
                  if ((unint64_t)v353 > v286)
                    v353 = (unsigned int *)v286;
                  v354 = v320;
                }
                else
                {
                  v354 = bswap32(*v353);
                }
                v355 = v354 << v352;
                v11[327] = v320 < 0;
                v356 = (v352 + 1) >> 3;
                v357 = (v352 + 1) & 7;
                v412 = __PAIR64__(v357, v355);
                v358 = (unsigned int *)((char *)v353 + v356);
                v410 = (unsigned int *)((char *)v353 + v356);
                if ((unint64_t)v353 + v356 >= v286)
                {
                  if ((unint64_t)v353 + v356 > v286)
                    v358 = (unsigned int *)v286;
                  v359 = v355;
                }
                else
                {
                  v359 = bswap32(*v358);
                }
                v360 = v359 << v357;
                v11[328] = v355 < 0;
                v361 = v357 + 1;
                v362 = ((_BYTE)v357 + 1) & 7;
                v412 = __PAIR64__(v362, v360);
                v363 = (unsigned int *)((char *)v358 + (v361 >> 3));
                v410 = v363;
                if ((unint64_t)v363 >= v286)
                {
                  if ((unint64_t)v363 > v286)
                    v363 = (unsigned int *)v286;
                  v364 = v360;
                }
                else
                {
                  v364 = bswap32(*v363);
                }
                v365 = v364 << v362;
                v11[329] = v360 < 0;
                v366 = v362 + 1;
                v367 = ((_BYTE)v362 + 1) & 7;
                v412 = __PAIR64__(v367, v365);
                v368 = (unsigned int *)((char *)v363 + (v366 >> 3));
                v410 = v368;
                if ((unint64_t)v368 >= v286)
                {
                  if ((unint64_t)v368 > v286)
                    v368 = (unsigned int *)v286;
                  v369 = v365;
                }
                else
                {
                  v369 = bswap32(*v368);
                }
                v370 = v369 << v367;
                v11[330] = v365 < 0;
                v371 = v367 + 1;
                v372 = ((_BYTE)v367 + 1) & 7;
                v412 = __PAIR64__(v372, v370);
                v373 = (unsigned int *)((char *)v368 + (v371 >> 3));
                v410 = v373;
                if ((unint64_t)v373 >= v286)
                {
                  if ((unint64_t)v373 > v286)
                    v373 = (unsigned int *)v286;
                  v374 = v370;
                }
                else
                {
                  v374 = bswap32(*v373);
                }
                v375 = v374 << v372;
                v11[331] = v370 < 0;
                v376 = v372 + 1;
                v377 = ((_BYTE)v372 + 1) & 7;
                v412 = __PAIR64__(v377, v375);
                v378 = (unsigned int *)((char *)v373 + (v376 >> 3));
                v410 = v378;
                if ((unint64_t)v378 >= v286)
                {
                  if ((unint64_t)v378 > v286)
                    v378 = (unsigned int *)v286;
                  v379 = v375;
                }
                else
                {
                  v379 = bswap32(*v378);
                }
                v380 = v379 << v377;
                v11[332] = v375 < 0;
                v381 = v377 + 1;
                v382 = ((_BYTE)v377 + 1) & 7;
                v412 = __PAIR64__(v382, v380);
                v383 = (unsigned int *)((char *)v378 + (v381 >> 3));
                v410 = v383;
                if ((unint64_t)v383 >= v286)
                {
                  if ((unint64_t)v383 > v286)
                    v383 = (unsigned int *)v286;
                  v384 = v380;
                }
                else
                {
                  v384 = bswap32(*v383);
                }
                v385 = v384 << v382;
                v11[333] = v380 < 0;
                v386 = (v382 + 1) >> 3;
                v387 = (v382 + 1) & 7;
                v412 = __PAIR64__(v387, v385);
                v388 = (unsigned int *)((char *)v383 + v386);
                v410 = (unsigned int *)((char *)v383 + v386);
                if ((unint64_t)v383 + v386 >= v286)
                {
                  if ((unint64_t)v383 + v386 > v286)
                    v388 = (unsigned int *)v286;
                  v389 = v385;
                }
                else
                {
                  v389 = bswap32(*v388);
                }
                v390 = v389 << v387;
                v11[334] = v385 < 0;
                v317 = ((_BYTE)v387 + 1) & 7;
                v412 = __PAIR64__(v317, v390);
                v318 = (unsigned int *)((char *)v388 + ((v387 + 1) >> 3));
                v410 = v318;
                if ((unint64_t)v318 >= v286)
                {
                  if ((unint64_t)v318 > v286)
                  {
                    v410 = (unsigned int *)v286;
                    v318 = (unsigned int *)v286;
                  }
                  v391 = v390;
                }
                else
                {
                  v391 = bswap32(*v318);
                }
                LODWORD(v412) = v391 << v317;
                v11[335] = v390 < 0;
              }
              if (v321)
              {
                v392 = (unsigned int *)(v286 - 1);
                v4 = 4294954387;
                while (!*(_BYTE *)v392)
                {
                  v92 = v392 > v318;
                  v392 = (unsigned int *)((char *)v392 - 1);
                  if (!v92)
                    goto LABEL_211;
                }
                v393 = __clz(__rbit32(*(unsigned __int8 *)v392)) ^ 7;
                if (v392 == v318 && v317 > v393)
                  break;
                HIDWORD(v412) = v393;
                v410 = v392;
                LODWORD(v412) = bswap32(*v392) << v393;
              }
              else
              {
                v392 = v318;
              }
              v410 = (unsigned int *)((char *)v392 + 1);
              HIDWORD(v412) = 0;
              if ((unint64_t)v392 + 1 > v286)
                v410 = (unsigned int *)v286;
              v394 = v11[194];
              v11[2000] = v394 + 8;
              v11[2001] = 6 * v394;
              v395 = v11[195];
              v11[2002] = v395 + 8;
              v11[2003] = 6 * v395;
              *((_DWORD *)v11 + 501) = 16 << v11[196];
              v396 = v11[240] + 3;
              v11[2008] = v396;
              v397 = v11[241] + v396;
              v11[2009] = v397;
              v398 = v11[242] + 2;
              v11[2010] = v398;
              v11[2011] = v11[243] + v398;
              v399 = v11[173];
              v400 = v398;
              if (v398 <= 3u)
                v400 = 3;
              v401 = v400 - 1;
              if ((v399 - 1) < 2)
                v398 = v401;
              v11[2012] = v398;
              v402 = v397;
              v403 = 1 << v397;
              v11[2013] = v403;
              *((int32x2_t *)v11 + 252) = vshl_s32(vadd_s32(vdup_n_s32(v403 - 1), *(int32x2_t *)(v11 + 176)), vneg_s32(vdup_n_s32(v402)));
              if (v11[184])
              {
                v404 = &byte_1B692BFF0[2 * v399];
                v280.i32[0] = *v404;
                v280.i32[1] = v404[1];
                v405 = vmull_u16((uint16x4_t)vmovn_s32(vzip1q_s32(v280, v280)), *(uint16x4_t *)(v11 + 186));
              }
              else
              {
                v405 = 0uLL;
              }
              *(uint32x4_t *)(v11 + 2028) = v405;
              if (v11[250])
              {
                v11[256] = v11[251] + 1;
                v11[257] = v11[252] + 1;
                v406 = v11[253] + 3;
                v11[258] = v406;
                v11[259] = v11[254] + v406;
              }
              if (*v11 <= 0xFu && v11[172] <= 0xFu)
              {
                sub_1B67B665C((_QWORD *)(a1 + 16 * v407[172] + 256), (uint64_t)v407, (uint64_t)v408);
                v4 = 0;
                goto LABEL_211;
              }
              break;
            }
          }
        }
        v4 = 4294954387;
      }
    }
  }
  else
  {
    v4 = 4294954392;
  }
LABEL_211:
  v148 = v408;
  if (v408)
  {
    v176 = (unint64_t *)&v408->__shared_owners_;
    do
      v150 = __ldaxr(v176);
    while (__stlxr(v150 - 1, v176));
LABEL_317:
    if (!v150)
    {
      ((void (*)(std::__shared_weak_count *))v148->__on_zero_shared)(v148);
      std::__shared_weak_count::__release_weak(v148);
    }
  }
LABEL_2:
  if (v409[0])
    free(v409[0]);
  return v4;
}

void sub_1B67B658C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *a12)
{
  sub_1B6772C88((uint64_t)&a10);
  if (a12)
    free(a12);
  _Unwind_Resume(a1);
}

_QWORD *sub_1B67B65E8(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_1E6A15C00;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1B67B6648(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1B67B6910((uint64_t *)va);
  _Unwind_Resume(a1);
}

_QWORD *sub_1B67B665C(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  if (a3)
  {
    v4 = (unint64_t *)(a3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = (std::__shared_weak_count *)a1[1];
  *a1 = a2;
  a1[1] = a3;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return a1;
}

_QWORD *sub_1B67B66D0(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_1E6A15CF8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1B67B6730(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1B67B6874((_QWORD **)va);
  _Unwind_Resume(a1);
}

_QWORD *sub_1B67B6744(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_1E6A15C80;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1B67B6798(_Unwind_Exception *exception_object)
{
  _QWORD *v1;

  if (v1)
    sub_1B67B67B0(v1);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1B67B67B0(_QWORD *result)
{
  _QWORD *v1;
  void *v2;
  void *v3;
  void **v4;
  void *v5;

  if (result)
  {
    v1 = result;
    v2 = (void *)result[209];
    if (v2)
    {
      free(v2);
      v1[209] = 0;
      v1[210] = 0;
    }
    v3 = (void *)v1[207];
    if (v3)
    {
      free(v3);
      v1[207] = 0;
      v1[208] = 0;
    }
    v4 = (void **)(v1 + 203);
    v5 = (void *)v1[205];
    if (v5)
    {
      free(v5);
      v1[205] = 0;
      v1[206] = 0;
    }
    if (*v4)
    {
      free(*v4);
      *v4 = 0;
      v1[204] = 0;
    }
    JUMPOUT(0x1BCC9814CLL);
  }
  return result;
}

void sub_1B67B6844(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC9814CLL);
}

_QWORD *sub_1B67B6868(uint64_t a1)
{
  return sub_1B67B67B0(*(_QWORD **)(a1 + 24));
}

_QWORD *sub_1B67B6874(_QWORD **a1)
{
  _QWORD *result;

  result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_1B68909E8(result);
    JUMPOUT(0x1BCC9814CLL);
  }
  return result;
}

void sub_1B67B68B4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC9814CLL);
}

_QWORD *sub_1B67B68D8(uint64_t a1)
{
  _QWORD *result;

  result = *(_QWORD **)(a1 + 24);
  if (result)
  {
    sub_1B68909E8(result);
    JUMPOUT(0x1BCC9814CLL);
  }
  return result;
}

uint64_t sub_1B67B6910(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_1B6803C5C(result);
    JUMPOUT(0x1BCC9814CLL);
  }
  return result;
}

void sub_1B67B6950(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC9814CLL);
}

uint64_t sub_1B67B6974(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
  {
    sub_1B6803C5C(result);
    JUMPOUT(0x1BCC9814CLL);
  }
  return result;
}

void sub_1B67B69B0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC9814CLL);
}

uint64_t sub_1B67B69D4(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x1BCC9814CLL);
  return result;
}

void sub_1B67B69FC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC9814CLL);
}

uint64_t sub_1B67B6A20(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x1BCC9814CLL);
  return result;
}

uint64_t sub_1B67B6A44(char *a1, int a2, char *a3, uint64_t a4, uint64_t a5)
{
  size_t v9;
  char *v10;
  uint64_t v11;
  char v12;
  int v13;
  uint64_t v14;
  unsigned int v15;

  v9 = (a2 + 2);
  bzero(a1, v9);
  a1[v9] = 1;
  v10 = &a1[v9 + 1];
  if (a5)
  {
    v11 = a5;
    do
    {
      v12 = *a3++;
      *v10++ = v12;
      --v11;
    }
    while (v11);
  }
  if (a4 != a5)
  {
    v13 = 0;
    v14 = a5 - a4;
    do
    {
      v15 = *a3;
      if (v13 == 2)
      {
        if (v15 > 3)
        {
          v13 = 2;
        }
        else
        {
          v13 = 0;
          *v10++ = 3;
          v15 = *a3;
        }
      }
      if (v15)
        v13 = 0;
      else
        ++v13;
      ++a3;
      *v10++ = v15;
    }
    while (!__CFADD__(v14++, 1));
  }
  return v10 - a1;
}

void sub_1B67B6B08()
{
  JUMPOUT(0x1BCC9814CLL);
}

uint64_t sub_1B67B6B1C(uint64_t a1, unsigned __int8 *a2, unint64_t a3)
{
  unint64_t v3;
  unsigned __int8 v4;
  unsigned int v5;
  int v6;
  uint64_t result;

  *(_QWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 32) = a3;
  *(_BYTE *)(a1 + 24) = 64;
  v3 = *(_QWORD *)(a1 + 8);
  if (v3 > a3)
    return 4294954387;
  if ((char)*a2 < 0)
    return 4294954387;
  v4 = *a2;
  v5 = *a2 >> 1;
  *(_BYTE *)(a1 + 24) = v5;
  if (v3 >= a3 && (v4 & 0xFC) != 0x48)
    return 4294954387;
  if ((a2[1] & 7) == 0)
    return 4294954387;
  v6 = (a2[1] & 7) - 1;
  *(_BYTE *)(a1 + 25) = v6;
  if (v5 > 0x28)
    return 0;
  if (((1 << v5) & 0x183003F0000) != 0)
  {
    if (v6)
      return 4294954387;
    return 0;
  }
  if (((1 << v5) & 0x3C) != 0)
  {
    if (!v6)
      return 4294954387;
    return 0;
  }
  if (((1 << v5) & 0x3000000000) == 0)
    return 0;
  result = 4294954387;
  if (v3 >= a3 && !v6)
    return 0;
  return result;
}

uint64_t sub_1B67B6BE0(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 24) < 0x16uLL) & (0x3F03FFu >> *(_BYTE *)(a1 + 24));
}

uint64_t sub_1B67B6C00(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 24) < 0x29uLL) & (0x18700000000uLL >> *(_BYTE *)(a1 + 24));
}

BOOL sub_1B67B6C1C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 24) - 39 < 2;
}

uint64_t sub_1B67B6C38(uint64_t a1, int a2, int a3, int a4)
{
  return *(_QWORD *)(a1 + 8 * a4 + 88)
       + ((*(_QWORD *)(a1 + 8 * a4 + 112) * a3 + (a2 << a4)) << *(_BYTE *)(a1 + 286));
}

uint64_t sub_1B67B6C64(uint64_t a1, int a2, int a3, int a4)
{
  return *(_QWORD *)(a1 + 8 * a4 + 88)
       + ((*(_QWORD *)(a1 + 8 * a4 + 112) * a3 + (a2 << a4)) << *(_BYTE *)(a1 + 286));
}

uint64_t sub_1B67B6C90(uint64_t a1, int a2)
{
  return *(_QWORD *)(a1 + 8 * a2 + 88);
}

uint64_t sub_1B67B6C9C(uint64_t a1, int a2)
{
  return *(_QWORD *)(a1 + 8 * a2 + 88);
}

uint64_t sub_1B67B6CA8(uint64_t a1, int a2)
{
  return *(_QWORD *)(a1 + 8 * a2 + 144);
}

uint64_t sub_1B67B6CB4(uint64_t a1, int a2)
{
  return *(_QWORD *)(a1 + 8 * a2 + 144);
}

uint64_t sub_1B67B6CC4(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  float *v3;
  float32x2x2_t v4;
  unint64_t v5;
  unint64_t v6;

  *(_QWORD *)(a1 + 276) = *(_QWORD *)(a2 + 176);
  v2 = *(unsigned __int8 *)(a2 + 2000);
  *(_BYTE *)(a1 + 284) = v2;
  *(_DWORD *)(a1 + 1096) = *(unsigned __int8 *)(a2 + 2009);
  v3 = (float *)(a1 + 400);
  v4 = *(float32x2x2_t *)(a2 + 2028);
  v5 = vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL).u64[0];
  vst2_f32(v3, v4);
  if (v2 - 8 > 2)
    return 4294954386;
  *(_QWORD *)(a1 + 464) = off_1E6A16DC0[(v2 - 8)];
  *(_BYTE *)(a1 + 286) = v2 > 8;
  v6 = *(unsigned __int8 *)(a2 + 173);
  if (v6 > 3)
    return 4294954394;
  if (*(_BYTE *)(a2 + 174))
    return 4294954386;
  (*(&off_1E6A15F50 + 4 * v6 + 2 * (v2 > 8)))();
  return 0;
}

_QWORD *sub_1B67B6D78(_QWORD *result)
{
  result[53] = sub_1B67C0C60;
  result[54] = sub_1B67C0D1C;
  result[55] = sub_1B67C0DD8;
  result[56] = sub_1B67C1074;
  result[57] = sub_1B67C1794;
  result[134] = sub_1B67B9A08;
  result[136] = sub_1B67C1988;
  return result;
}

_QWORD *sub_1B67B6DC8(_QWORD *result)
{
  result[53] = sub_1B67BFCC0;
  result[54] = sub_1B67BFD80;
  result[55] = sub_1B67BFE40;
  result[56] = sub_1B67C00F4;
  result[57] = sub_1B67C082C;
  result[134] = sub_1B67B81F8;
  result[136] = sub_1B67C0A30;
  return result;
}

_QWORD *sub_1B67B6E18(_QWORD *result)
{
  result[53] = sub_1B67BE580;
  result[54] = sub_1B67BE6A4;
  result[55] = sub_1B67BE898;
  result[56] = sub_1B67BEB84;
  result[57] = sub_1B67BF40C;
  result[134] = sub_1B67B9A08;
  result[135] = sub_1B67BF75C;
  result[136] = sub_1B67BF848;
  return result;
}

_QWORD *sub_1B67B6E74(_QWORD *result)
{
  result[53] = sub_1B67BCDB4;
  result[54] = sub_1B67BCEE0;
  result[55] = sub_1B67BD0E8;
  result[56] = sub_1B67BD3F0;
  result[57] = sub_1B67BDCA8;
  result[134] = sub_1B67B81F8;
  result[135] = sub_1B67BE020;
  result[136] = sub_1B67BE110;
  return result;
}

_QWORD *sub_1B67B6ED0(_QWORD *result)
{
  result[53] = sub_1B67BB734;
  result[54] = sub_1B67BB840;
  result[55] = sub_1B67BBA28;
  result[56] = sub_1B67BBD04;
  result[57] = sub_1B67BC560;
  result[134] = sub_1B67B9A08;
  result[135] = sub_1B67BC88C;
  result[136] = sub_1B67BC96C;
  return result;
}

_QWORD *sub_1B67B6F2C(_QWORD *result)
{
  result[53] = sub_1B67BA004;
  result[54] = sub_1B67BA118;
  result[55] = sub_1B67BA314;
  result[56] = sub_1B67BA60C;
  result[57] = sub_1B67BAEA4;
  result[134] = sub_1B67B81F8;
  result[135] = sub_1B67BB1F8;
  result[136] = sub_1B67BB2DC;
  return result;
}

_QWORD *sub_1B67B6F88(_QWORD *result)
{
  result[53] = sub_1B67B88FC;
  result[54] = sub_1B67B8A04;
  result[55] = sub_1B67B8BE8;
  result[56] = sub_1B67B8EAC;
  result[57] = sub_1B67B96E8;
  result[134] = sub_1B67B9A08;
  result[135] = sub_1B67B9AD4;
  result[136] = sub_1B67B9BA8;
  return result;
}

_QWORD *sub_1B67B6FE4(_QWORD *result)
{
  result[53] = sub_1B67B7040;
  result[54] = sub_1B67B7150;
  result[55] = sub_1B67B7348;
  result[56] = sub_1B67B7628;
  result[57] = sub_1B67B7EB0;
  result[134] = sub_1B67B81F8;
  result[135] = sub_1B67B82CC;
  result[136] = sub_1B67B83A4;
  return result;
}

uint64_t sub_1B67B7040(uint64_t a1, FILE *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a2)
    return 4294954394;
  v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  v5 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  v6 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v7 = *(int *)(a1 + 404);
  if ((int)v7 < (int)v5)
  {
    v8 = v6 + 2 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v8 + 2 * *(_QWORD *)(a1 + 112) * v7++), 1uLL, 2 * v4, a2);
    while (v7 < v5);
  }
  v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v10 = *(int *)(a1 + 404);
  if ((int)v10 < (int)v5)
  {
    v11 = v9 + 4 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v11 + 2 * *(_QWORD *)(a1 + 120) * v10++), 1uLL, 4 * v4, a2);
    while (v10 < (int)v5);
  }
  return 0;
}

uint64_t sub_1B67B7150(uint64_t a1, FILE *a2)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  size_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  __int16 *v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;

  if (!a2)
    return 4294954394;
  v4 = *(int *)(a1 + 276);
  v5 = *(_DWORD *)(a1 + 408) + *(_DWORD *)(a1 + 400);
  v6 = v4 - v5;
  v7 = *(_DWORD *)(a1 + 280);
  v8 = *(_DWORD *)(a1 + 412);
  v31 = v8 + *(_DWORD *)(a1 + 404);
  v32 = v7 - v31;
  v9 = v7 - v8;
  v10 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v11 = *(int *)(a1 + 404);
  if ((int)v11 < v9)
  {
    v12 = v10 + 2 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v12 + 2 * *(_QWORD *)(a1 + 112) * v11++), 1uLL, 2 * v6, a2);
    while (v11 < v9);
  }
  v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v29 = *(int *)(a1 + 400);
  v30 = v13;
  v14 = *(int *)(a1 + 404);
  v15 = *(_QWORD *)(a1 + 120);
  v16 = v32 * v6;
  if (v16 < 0)
    v17 = -1;
  else
    v17 = 4 * v16;
  v18 = (char *)operator new[](v17, MEMORY[0x1E0DE4E10]);
  if (!v18)
    return 4294954392;
  v19 = v18;
  if (v7 != v31)
  {
    v20 = v32;
    v21 = &v18[2 * v16];
    v22 = 2 * v4 - 2 * v5;
    v23 = 2 * v15 * v14 + 4 * v4 + 4 * v29 - 4 * v5 + v30 - 2;
    v24 = v18;
    do
    {
      if ((_DWORD)v4 != v5)
      {
        v25 = (__int16 *)v23;
        v26 = ~(uint64_t)v5 + v4;
        do
        {
          *(_WORD *)&v24[2 * v26] = *(v25 - 1);
          v27 = *v25;
          v25 -= 2;
          *(_WORD *)&v21[2 * v26--] = v27;
        }
        while (v26 != -1);
      }
      v21 += v22;
      v24 += v22;
      v23 += 2 * v15;
      --v20;
    }
    while (v20);
  }
  fwrite(v18, 1uLL, 4 * v16, a2);
  MEMORY[0x1BCC9811C](v19, 0x1000C80BDFB0063);
  return 0;
}

uint64_t sub_1B67B7348(uint64_t *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  uint64_t v4;
  char *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  signed int v17;
  void *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  __int16 *v24;
  uint64_t v25;
  __int16 v26;
  char v27;
  char v28;
  uint64_t v29;
  char v30;
  BOOL v31;
  uint64_t v32;
  void *data[3];
  CC_MD5_CTX c;
  char v36;
  CC_MD5_CTX v37;
  char v38;
  CC_MD5_CTX v39;
  char v40;
  uint64_t v41;

  v2 = a2;
  v41 = *MEMORY[0x1E0C80C00];
  memset(data, 0, sizeof(data));
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  v4 = *a1;
  if (*((_BYTE *)a1 + 136))
  {
    v5 = (char *)(*(uint64_t (**)(uint64_t *, _QWORD))(v4 + 56))(a1, 0);
    v6 = a1 + 22;
    v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, 1);
    v8 = a1 + 21;
  }
  else
  {
    v5 = (char *)(*(uint64_t (**)(uint64_t *, _QWORD))(v4 + 40))(a1, 0);
    v6 = a1 + 15;
    v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, 1);
    v8 = a1 + 14;
  }
  v9 = 0;
  v10 = *v6;
  v11 = *v8;
  do
  {
    *((_BYTE *)&c + v9 + 92) = 1;
    *((_BYTE *)&c + v9 + 92) = CC_MD5_Init((CC_MD5_CTX *)((char *)&c + v9)) != 0;
    v9 += 96;
  }
  while (v9 != 288);
  if (*((_DWORD *)a1 + 70))
  {
    v12 = 0;
    do
    {
      v13 = CC_MD5_Update(&c, v5, 2 * *((_DWORD *)a1 + 69));
      v36 &= v13;
      ++v12;
      v14 = *((_DWORD *)a1 + 70);
      v5 += 2 * v11;
    }
    while (v12 < v14);
    v15 = v14;
    if (v7)
      goto LABEL_10;
  }
  else
  {
    v14 = 0;
    v15 = 0;
    if (v7)
    {
LABEL_10:
      v16 = *((int *)a1 + 69);
      v17 = 2 * v16 * v14;
      sub_1B67B8800((char **)data, v17);
      v18 = data[0];
      v19 = (char *)data[0] + 2 * (int)v16 * v14;
      if (v14)
      {
        v20 = 2 * v16;
        v21 = v7 + 4 * v16 - 2;
        v22 = (char *)data[0];
        v23 = (char *)data[0] + 2 * (int)v16 * v14;
        do
        {
          if ((_DWORD)v16)
          {
            v24 = (__int16 *)v21;
            v25 = v16 - 1;
            do
            {
              *(_WORD *)&v22[2 * v25] = *(v24 - 1);
              v26 = *v24;
              v24 -= 2;
              *(_WORD *)&v23[2 * v25--] = v26;
            }
            while (v25 != -1);
          }
          v23 += v20;
          v22 += v20;
          v21 += 2 * v10;
          --v15;
        }
        while (v15);
      }
      v27 = CC_MD5_Update(&v37, v18, v17);
      v38 &= v27;
      v28 = CC_MD5_Update(&v39, v19, v17);
      v40 &= v28;
      goto LABEL_19;
    }
  }
  v18 = 0;
LABEL_19:
  v29 = 0;
  while (1)
  {
    v30 = CC_MD5_Final(v2, (CC_MD5_CTX *)((char *)&c + v29));
    v31 = (v30 & *((_BYTE *)&c + v29 + 92)) == 0;
    *((_BYTE *)&c + v29 + 92) &= v30;
    if (v31)
      break;
    v29 += 96;
    v2 += 16;
    if (v29 == 288)
    {
      v32 = 0;
      if (!v18)
        return v32;
      goto LABEL_25;
    }
  }
  v32 = 4294954385;
  if (!v18)
    return v32;
LABEL_25:
  operator delete(v18);
  return v32;
}

void sub_1B67B75F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B67B7628(uint64_t a1, int *a2, double *a3, int a4)
{
  __CVBuffer *v8;
  OSType PixelFormatType;
  int v10;
  int v11;
  uint64_t v12;
  __CVBuffer *v13;
  signed int v14;
  char v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFAllocator *v20;
  OSStatus v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double *v28;
  const __CFDictionary *DescriptionWithPixelFormatType;
  const void *Value;
  CVReturn v31;
  NSObject *v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unsigned __int16 *v38;
  unsigned __int16 *v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  unsigned __int16 *v46;
  unsigned __int16 *v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned __int16 *v65;
  unsigned __int16 *v66;
  uint64_t v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  OSStatus v72;
  uint32_t v73;
  size_t Height;
  size_t Width;
  uint64_t v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  double *v84;
  CFMutableDictionaryRef Mutable;
  VTPixelTransferSessionRef pixelTransferSessionOut;
  CVPixelBufferRef pixelBufferOut;
  uint8_t v88[4];
  CVReturn v89;
  uint8_t buf[8];
  uint64_t (**v91)();
  int v92;
  int v93;
  uint64_t v94;
  __int16 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  char v100;
  uint64_t v101;
  __int16 v102;
  char v103;
  char v104;
  __int128 v105;
  __int128 v106;
  uint64_t v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  uint64_t v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  uint64_t v118;
  __int128 v119;
  int v120;
  uint64_t (***v121)();
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  _BYTE v126[21];
  __int128 v127;
  __int128 v128;
  uint64_t v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  uint64_t v133;
  uint64_t v134;
  __int128 v135;
  __int128 v136;
  uint64_t v137;
  uint64_t v138;
  int v139;
  uint64_t v140;
  char v141;
  uint64_t v142;

  v142 = *MEMORY[0x1E0C80C00];
  v92 = 0;
  v93 = 0;
  v100 = 1;
  v108 = 0u;
  v109 = 0u;
  v119 = 0u;
  v101 = 0;
  v102 = 0;
  v112 = 0u;
  v113 = 0u;
  v116 = 0u;
  v117 = 0u;
  v121 = &v91;
  memset(v126, 0, sizeof(v126));
  v125 = 0u;
  v124 = 0u;
  v123 = 0u;
  v122 = 0u;
  v128 = 0u;
  v127 = 0u;
  v129 = 850045863;
  v130 = 0u;
  v131 = 0u;
  v132 = 0u;
  v133 = 0;
  v134 = 1018212795;
  v135 = 0u;
  v136 = 0u;
  v137 = 0;
  v118 = 0;
  v95 = 0;
  v120 = 0;
  v94 = 0;
  v103 = 0;
  v104 = 0;
  v105 = 0u;
  v99 = 0u;
  v106 = 0u;
  v107 = 0;
  v110 = 0u;
  v111 = 0;
  v114 = 0u;
  v115 = 0u;
  v96 = 0u;
  v97 = 0u;
  v98 = 0u;
  v91 = &off_1E6A15040;
  v138 = 0;
  v139 = 0;
  v140 = 0;
  v141 = 0;
  pixelTransferSessionOut = 0;
  pixelBufferOut = 0;
  v8 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  PixelFormatType = CVPixelBufferGetPixelFormatType(v8);
  v10 = a2[69];
  v82 = a2[102];
  v83 = a2[100];
  v11 = a2[70];
  v80 = a2[103];
  v81 = a2[101];
  v12 = *((_QWORD *)a2 + 14);
  v13 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  v14 = CVPixelBufferGetPixelFormatType(v13);
  v15 = 0;
  v78 = v11;
  v79 = v10;
  if (v14 <= 2016687155)
  {
    if (v14 != 1278226736)
    {
      v16 = 2016686640;
LABEL_7:
      if (v14 != v16)
        goto LABEL_9;
    }
  }
  else if (v14 != 2016687156 && v14 != 2019963956)
  {
    v16 = 2019963440;
    goto LABEL_7;
  }
  v15 = 16 - sub_1B67C37F4(v14);
LABEL_9:
  v17 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
  v18 = a2[100];
  v19 = a2[101];
  if (CVIsCompressedPixelFormatAvailable(PixelFormatType))
  {
    v76 = v12;
    v77 = a4;
    v20 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v21 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &pixelTransferSessionOut);
    if (v21)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v21;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate for PSNR calculation failed with error: %d\n", buf, 8u);
      }
      goto LABEL_45;
    }
    Width = CVPixelBufferGetWidth(v8);
    Height = CVPixelBufferGetHeight(v8);
    *(_QWORD *)buf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, (const void *)*MEMORY[0x1E0CA8FF0], Mutable);
    v28 = a3;
    DescriptionWithPixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
    Value = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E0CA9120]);
    if (sub_1B67C37F4(PixelFormatType) != 8 || !CFEqual(Value, (CFTypeRef)*MEMORY[0x1E0CA9130]))
    {
      a3 = v28;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v88 = 0;
        v32 = MEMORY[0x1E0C81028];
        v33 = "Bit depth of source pixel buffer is not 8 or source pixel buffer is not video range for PSNR calculation";
        v73 = 2;
        goto LABEL_71;
      }
      goto LABEL_34;
    }
    v31 = CVPixelBufferCreate(v20, Width, Height, 0x34323076u, *(CFDictionaryRef *)buf, &pixelBufferOut);
    a3 = v28;
    if (v31)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v88 = 67109120;
        v89 = v31;
        v32 = MEMORY[0x1E0C81028];
        v33 = "CVPixelBufferCreate for PSNR calculation failed with error: %d\n";
LABEL_68:
        v73 = 8;
LABEL_71:
        _os_log_error_impl(&dword_1B676B000, v32, OS_LOG_TYPE_ERROR, v33, v88, v73);
        goto LABEL_34;
      }
      goto LABEL_34;
    }
    v72 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v8, pixelBufferOut);
    if (v72)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v88 = 67109120;
        v89 = v72;
        v32 = MEMORY[0x1E0C81028];
        v33 = "Pixel transfer from compressed to linear format for PSNR calculation failed with error: %d\n";
        goto LABEL_68;
      }
LABEL_34:
      sub_1B67705C8((const void **)&Mutable);
      sub_1B67705C8((const void **)buf);
LABEL_45:
      v36 = 0;
      goto LABEL_46;
    }
    CVPixelBufferGetPixelFormatType(pixelBufferOut);
    sub_1B67C28B8((uint64_t)&v91, pixelBufferOut, 0);
    sub_1B67705C8((const void **)&Mutable);
    sub_1B67705C8((const void **)buf);
    a3 = v28;
    a4 = v77;
    v12 = v76;
  }
  else
  {
    sub_1B67C28B8((uint64_t)&v91, v8, 0);
  }
  v22 = (v79 - (v83 + v82));
  v23 = (v78 - (v81 + v80));
  v24 = v17 + 2 * v18 + 2 * v12 * v19;
  v25 = v96;
  if (a4)
  {
    v26 = *((_QWORD *)&v98 + 1);
    if ((_QWORD)v96 || !sub_1B67C3B94((uint64_t)&v91))
      v27 = v97;
    else
      v27 = 0;
    if ((int)v23 < 1)
      goto LABEL_45;
    v44 = 0;
    v36 = 0;
    v45 = v27 + 2 * (int)v105 + 2 * v26 * SDWORD1(v105);
    do
    {
      if ((int)v22 >= 1)
      {
        v46 = (unsigned __int16 *)v24;
        v47 = (unsigned __int16 *)v45;
        v48 = (v79 - (v83 + v82));
        do
        {
          v50 = *v46++;
          v49 = v50;
          v51 = *v47++;
          v36 += ((v49 - v51) * (v49 - v51));
          --v48;
        }
        while (v48);
      }
      ++v44;
      v45 += 2 * v26;
      v24 += 2 * v12;
    }
    while (v44 != v23);
  }
  else
  {
    v34 = *((_QWORD *)&v97 + 1);
    if (!(_QWORD)v96)
    {
      if (sub_1B67C3B94((uint64_t)&v91))
        v25 = 0;
      else
        v25 = v96;
    }
    if ((int)v23 < 1)
    {
      v36 = 0;
      goto LABEL_53;
    }
    v35 = 0;
    v36 = 0;
    v37 = v25 + 2 * (int)v105 + 2 * v34 * SDWORD1(v105);
    do
    {
      if ((int)v22 >= 1)
      {
        v38 = (unsigned __int16 *)v24;
        v39 = (unsigned __int16 *)v37;
        v40 = (v79 - (v83 + v82));
        do
        {
          v42 = *v38++;
          v41 = v42;
          v43 = *v39++;
          v36 += ((v41 >> v15) - (v43 >> v15)) * ((v41 >> v15) - (v43 >> v15));
          --v40;
        }
        while (v40);
      }
      ++v35;
      v37 += 2 * v34;
      v24 += 2 * v12;
    }
    while (v35 != v23);
  }
  if ((a4 & 1) != 0)
  {
LABEL_46:
    v52 = 0;
    v53 = 0;
    goto LABEL_47;
  }
LABEL_53:
  v84 = a3;
  v55 = v98;
  v56 = *((_QWORD *)a2 + 15);
  v57 = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a2 + 40))(a2, 1);
  v58 = a2[100];
  v59 = a2[101];
  if ((_QWORD)v96 || !sub_1B67C3B94((uint64_t)&v91))
    v60 = *((_QWORD *)&v96 + 1);
  else
    v60 = 0;
  if ((int)v23 < 1)
  {
    v52 = 0;
    v53 = 0;
    a3 = v84;
  }
  else
  {
    v61 = 0;
    v53 = 0;
    v62 = v57;
    v52 = 0;
    v63 = 2 * v55 * SDWORD1(v105) + 4 * (int)v105 + v60 + 2;
    v64 = 2 * v56 * v59 + 4 * v58 + v62 + 2;
    a3 = v84;
    do
    {
      if ((int)v22 >= 1)
      {
        v65 = (unsigned __int16 *)v64;
        v66 = (unsigned __int16 *)v63;
        v67 = v22;
        do
        {
          v68 = (*(v65 - 1) >> v15) - (*(v66 - 1) >> v15);
          v69 = *v65;
          v65 += 2;
          v70 = v69 >> v15;
          v71 = *v66;
          v66 += 2;
          v52 += (v68 * v68);
          v53 += (v70 - (v71 >> v15)) * (v70 - (v71 >> v15));
          --v67;
        }
        while (v67);
      }
      ++v61;
      v63 += 2 * v55;
      v64 += 2 * v56;
    }
    while (v61 != v23);
  }
LABEL_47:
  if (pixelBufferOut)
    CVPixelBufferRelease(pixelBufferOut);
  if (pixelTransferSessionOut)
    CFRelease(pixelTransferSessionOut);
  *a3 = (double)v36;
  a3[1] = (double)v52;
  a3[2] = (double)v53;
  return sub_1B67C3D28((uint64_t)&v91);
}

void sub_1B67B7E40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  const void *v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  va_list va1;
  va_list va2;

  va_start(va2, a8);
  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, const void *);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v15 = va_arg(va2, const void *);
  sub_1B67705C8((const void **)va);
  sub_1B67705C8((const void **)va1);
  sub_1B67C3D28((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t *sub_1B67B7EB0(int *a1, int *a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t *v21;
  uint64_t v22;
  unsigned __int16 *v23;
  unsigned __int16 *v24;
  uint64_t v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t *result;
  int v46;
  char *v47;
  uint64_t *v48;
  uint64_t v49;
  unsigned __int16 *v50;
  unsigned __int16 *v51;
  uint64_t v52;
  uint64_t v53;
  unsigned __int16 *v54;
  unsigned __int16 *v55;
  uint64_t v56;
  int v57;
  int v58;
  int v59;
  int v60;
  uint64_t v61;
  _OWORD *v62;
  uint64_t i;
  _OWORD v64[4];
  uint64_t v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v65 = 0;
  memset(v64, 0, sizeof(v64));
  v6 = (a2[69] - (a2[100] + a2[102]));
  v7 = a2[70] - (a2[101] + a2[103]);
  v8 = *((_QWORD *)a2 + 14);
  v9 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
  v10 = a2[100];
  v11 = a2[101];
  v12 = *((_QWORD *)a1 + 14);
  v13 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v14 = 0;
  v15 = v13 + 2 * a1[100];
  v16 = 2 * a1[101];
  v17 = v9 + 2 * v10;
  do
  {
    v18 = v7 * (int)v14 / 3;
    v19 = v14 + 1;
    v20 = v7 * ((int)v14 + 1) / 3;
    if (v18 < v20)
    {
      v21 = (uint64_t *)v64 + 3 * v14;
      v22 = v18;
      v23 = (unsigned __int16 *)(v15 + v12 * (v16 + 2 * v18));
      v24 = (unsigned __int16 *)(v17 + v8 * (2 * v11 + 2 * v18));
      do
      {
        if ((int)v6 >= 1)
        {
          v25 = *v21;
          v26 = v24;
          v27 = v23;
          v28 = v6;
          do
          {
            v30 = *v26++;
            v29 = v30;
            v31 = *v27++;
            v25 += ((v29 - v31) * (v29 - v31));
            --v28;
          }
          while (v28);
          *v21 = v25;
        }
        ++v22;
        v23 += v12;
        v24 += v8;
      }
      while (v22 != v20);
    }
    v14 = v19;
  }
  while (v19 != 3);
  v32 = *((_QWORD *)a1 + 15);
  v33 = *((_QWORD *)a2 + 15);
  v34 = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a2 + 40))(a2, 1);
  v35 = a2[100];
  v36 = a2[101];
  v37 = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v38 = 0;
  v39 = v37 + 4 * a1[100] + 2;
  v40 = 2 * a1[101];
  v41 = v34 + 4 * v35 + 2;
  v42 = 2 * v36;
  do
  {
    v43 = v7 * (int)v38 / 3;
    v44 = v38 + 1;
    result = (uint64_t *)((unint64_t)(1431655766 * v7 * ((int)v38 + 1)) >> 32);
    v46 = v7 * ((int)v38 + 1) / 3;
    if (v43 < v46)
    {
      v47 = (char *)v64 + 24 * v38;
      result = (uint64_t *)(v47 + 8);
      v48 = (uint64_t *)(v47 + 16);
      v49 = v43;
      v50 = (unsigned __int16 *)(v39 + v32 * (v40 + 2 * v43));
      v51 = (unsigned __int16 *)(v41 + v33 * (v42 + 2 * v43));
      do
      {
        if ((int)v6 >= 1)
        {
          v52 = *result;
          v53 = *v48;
          v54 = v51;
          v55 = v50;
          v56 = v6;
          do
          {
            v57 = *(v54 - 1) - *(v55 - 1);
            v59 = *v54;
            v54 += 2;
            v58 = v59;
            v60 = *v55;
            v55 += 2;
            v52 += (v57 * v57);
            v53 += ((v58 - v60) * (v58 - v60));
            --v56;
          }
          while (v56);
          *result = v52;
          *v48 = v53;
        }
        ++v49;
        v50 += v32;
        v51 += v33;
      }
      while (v49 != v46);
    }
    v38 = v44;
  }
  while (v44 != 3);
  v61 = 0;
  v62 = v64;
  do
  {
    for (i = 0; i != 24; i += 8)
      *(double *)(a3 + i) = (double)(unint64_t)(3 * *(_QWORD *)((char *)v62 + i));
    ++v61;
    a3 += 24;
    v62 = (_OWORD *)((char *)v62 + 24);
  }
  while (v61 != 3);
  return result;
}

__int16 *sub_1B67B81F8(__int16 *result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  int v10;
  int v11;
  uint64_t v12;
  __int16 *v13;
  __int16 v14;
  __int16 v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  __int16 v19;
  __int16 *v20;

  v10 = (int)result;
  if (a5)
  {
    v11 = *(_DWORD *)(a6 + 276);
    v12 = (a3 + (_DWORD)result - v11);
    if ((int)v12 >= 1)
    {
      v13 = (__int16 *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a6 + 16))(a6, (v11 - 1), (a2 - 1), 0);
      v15 = *v13;
      result = v13 + 1;
      v14 = v15;
      do
      {
        *result++ = v14;
        --v12;
      }
      while (v12);
    }
  }
  if (a4)
  {
    v16 = *(_DWORD *)(a6 + 280);
    v17 = (a3 + a2 - v16);
    if ((int)v17 >= 1)
    {
      v18 = *(_QWORD *)(a6 + 112);
      result = (__int16 *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a6 + 16))(a6, (v10 - 1), (v16 - 1), 0);
      v19 = *result;
      v20 = &result[v18];
      do
      {
        *v20 = v19;
        v20 += v18;
        --v17;
      }
      while (v17);
    }
  }
  return result;
}

int *sub_1B67B82CC(int *result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  int v10;
  int v11;
  uint64_t v12;
  int *v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  unint64_t v20;
  _DWORD *v21;

  v10 = (int)result;
  if (a5)
  {
    v11 = *(_DWORD *)(a6 + 276);
    v12 = (a3 + (_DWORD)result - v11);
    if ((int)v12 >= 1)
    {
      v13 = (int *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a6 + 16))(a6, (v11 - 1), (a2 - 1), 1);
      v15 = *v13;
      result = v13 + 1;
      v14 = v15;
      do
      {
        *result++ = v14;
        --v12;
      }
      while (v12);
    }
  }
  if (a4)
  {
    v16 = *(_DWORD *)(a6 + 280);
    v17 = (a3 + a2 - v16);
    if ((int)v17 >= 1)
    {
      v18 = *(_QWORD *)(a6 + 120);
      result = (int *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a6 + 16))(a6, (v10 - 1), (v16 - 1), 1);
      v19 = *result;
      v20 = (2 * v18) & 0xFFFFFFFFFFFFFFFCLL;
      v21 = (int *)((char *)result + v20);
      do
      {
        *v21 = v19;
        v21 = (_DWORD *)((char *)v21 + v20);
        --v17;
      }
      while (v17);
    }
  }
  return result;
}

_DWORD *sub_1B67B83A4(int a1, int a2, int a3, int a4, int a5, int a6, int *a7)
{
  uint64_t v14;
  uint64_t v15;
  _DWORD *result;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int16 v23;
  _WORD *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  _DWORD *v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  __int16 v42;
  _WORD *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  char *v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  _DWORD *v54;
  uint64_t v55;
  int v56;
  int v57;
  int v58;
  int v59;
  char *v60;
  char *v61;
  BOOL v62;
  int v63;
  char *v64;
  char *v65;
  uint64_t v66;
  int v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  _DWORD *v76;
  uint64_t v77;
  _DWORD *v78;
  uint64_t v79;
  uint64_t v80;
  int v81;

  v14 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a7 + 32))(a7, 0);
  v15 = *((_QWORD *)a7 + 14);
  result = (_DWORD *)(*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a7 + 32))(a7, 1);
  v79 = *((_QWORD *)a7 + 15);
  v17 = v79 >> 1;
  if (a1 <= 2)
  {
    if (a2 <= 3)
      v18 = 3;
    else
      v18 = a2;
    v19 = a7[70];
    LODWORD(v20) = a2 + a6 + 4;
    if ((int)v20 >= v19)
      v20 = v19;
    else
      v20 = v20;
    if ((int)v18 - 3 < (int)v20)
    {
      v21 = v18 - 3;
      v22 = v14 + 2 * v15 * v21 - 2;
      do
      {
        v23 = *(_WORD *)(v14 + 2 * v15 * v21);
        v24 = (_WORD *)v22;
        v25 = (3 - a1);
        do
        {
          *v24-- = v23;
          --v25;
        }
        while (v25);
        ++v21;
        v22 += 2 * v15;
      }
      while (v21 != v20);
    }
    if (a4 <= 1)
      v26 = 1;
    else
      v26 = a4;
    v27 = a4 + a6 + 2;
    if (v27 >= v19)
      v28 = v19;
    else
      v28 = a4 + a6 + 2;
    if ((int)v26 <= v28)
    {
      v29 = v26 - 1;
      v30 = (uint64_t)&result[v17 * v29 - 1];
      do
      {
        if (a3 <= 0)
        {
          v31 = result[v17 * v29];
          v32 = (_DWORD *)v30;
          v33 = (1 - a3) & ~((1 - a3) >> 31);
          do
          {
            *v32-- = v31;
            --v33;
          }
          while (v33);
          v19 = a7[70];
        }
        ++v29;
        if (v27 >= v19)
          v34 = v19;
        else
          v34 = a4 + a6 + 2;
        v30 += 4 * v17;
      }
      while (v29 < v34);
    }
  }
  v35 = a1 + a5 + 4;
  v36 = a7[69];
  if (v35 > (int)v36)
  {
    if (a2 <= 3)
      v37 = 3;
    else
      v37 = a2;
    v38 = a7[70];
    LODWORD(v39) = a2 + a6 + 4;
    if ((int)v39 >= v38)
      v39 = v38;
    else
      v39 = v39;
    if ((int)v37 - 3 < (int)v39)
    {
      v40 = v37 - 3;
      v41 = 2 * v15 * v40 + 2 * (v36 - 1) + v14 + 2;
      do
      {
        if (v35 != (_DWORD)v36)
        {
          v42 = *(_WORD *)(v14 + 2 * (v36 - 1 + v15 * v40));
          v43 = (_WORD *)v41;
          v44 = v35 - (int)v36;
          do
          {
            *v43++ = v42;
            --v44;
          }
          while (v44);
        }
        ++v40;
        v41 += 2 * v15;
      }
      while (v40 != v39);
    }
    if (a4 <= 1)
      v45 = 1;
    else
      v45 = a4;
    v46 = a4 + a6 + 2;
    if (v46 >= v38)
      v47 = v38;
    else
      v47 = a4 + a6 + 2;
    if ((int)v45 <= v47)
    {
      v48 = 2 * (int)v36 - 2;
      v49 = (char *)result + 2 * v48;
      v50 = a3 + a5 - v36 + 2;
      v51 = v45 - 1;
      v52 = (uint64_t)&result[v17 * v51 + 1] + 2 * v48;
      do
      {
        if (v50 >= 1)
        {
          v53 = *(_DWORD *)&v49[4 * v17 * v51];
          v54 = (_DWORD *)v52;
          v55 = v50 & ~(v50 >> 31);
          do
          {
            *v54++ = v53;
            --v55;
          }
          while (v55);
          v38 = a7[70];
        }
        ++v51;
        if (v46 >= v38)
          v56 = v38;
        else
          v56 = a4 + a6 + 2;
        v52 += 4 * v17;
      }
      while (v51 < v56);
    }
  }
  v78 = result;
  v81 = a5;
  v57 = a6;
  v80 = v14 + 2 * a1;
  v58 = a2;
  if (a2 <= 2)
  {
    v59 = a2 - 3;
    v60 = (char *)(v80 - 6);
    do
    {
      v61 = &v60[-2 * v15];
      result = memcpy(v61, v60, 2 * (v81 + 7));
      v60 = v61;
      v62 = __CFADD__(v59++, 1);
    }
    while (!v62);
    if (a4 <= 0)
    {
      v63 = a4 - 1;
      v64 = (char *)&v78[a3 - 1];
      do
      {
        v65 = &v64[-2 * v79];
        result = memcpy(v65, v64, 2 * (2 * v81 + 6));
        v64 = v65;
        v62 = __CFADD__(v63++, 1);
      }
      while (!v62);
    }
  }
  v66 = a7[70];
  if (a2 + v57 + 4 > (int)v66)
  {
    v67 = a4;
    v68 = v57 + v58 - v66 + 4;
    v69 = 2 * v15 * (v66 - 1);
    v70 = v80 - 6;
    v71 = 2 * v15;
    v72 = v15 * (2 * (v66 - 1) + 2);
    do
    {
      result = memcpy((void *)(v70 + v72), (const void *)(v70 + v69), 2 * (v81 + 7));
      v70 += v71;
      --v68;
    }
    while (v68);
    v73 = a7[70];
    if ((int)v73 < v67 + v57 + 2)
    {
      v74 = v57 + v67 - v73 + 2;
      v75 = 2 * v79 * (v73 - 1);
      v76 = &v78[a3 - 1];
      v77 = v79 * (2 * (v73 - 1) + 2);
      do
      {
        result = memcpy((char *)v76 + v77, (char *)v76 + v75, 2 * (2 * v81 + 6));
        v76 = (_DWORD *)((char *)v76 + 2 * v79);
        --v74;
      }
      while (v74);
    }
  }
  return result;
}

void sub_1B67B8800(char **a1, unint64_t a2)
{
  char *v3;
  char *v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  __int16 v15;
  char *v16;

  v3 = *a1;
  v4 = a1[1];
  v5 = (v4 - *a1) >> 1;
  if (a2 <= v5)
  {
    if (a2 >= v5)
      return;
    v16 = &v3[2 * a2];
    goto LABEL_17;
  }
  v6 = a2 - v5;
  v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 1)
  {
    bzero(a1[1], 2 * v6);
    v16 = &v4[2 * v6];
LABEL_17:
    a1[1] = v16;
    return;
  }
  if ((a2 & 0x8000000000000000) != 0)
    sub_1B6773BAC();
  v8 = v7 - v3;
  if (v8 <= a2)
    v9 = a2;
  else
    v9 = v8;
  if (v8 >= 0x7FFFFFFFFFFFFFFELL)
    v10 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v10 = v9;
  if (v10 < 0)
    sub_1B6773BF4();
  v11 = (char *)operator new(2 * v10);
  v12 = &v11[2 * v5];
  v13 = &v11[2 * v10];
  bzero(v12, 2 * v6);
  v14 = &v12[2 * v6];
  while (v4 != v3)
  {
    v15 = *((_WORD *)v4 - 1);
    v4 -= 2;
    *((_WORD *)v12 - 1) = v15;
    v12 -= 2;
  }
  *a1 = v12;
  a1[1] = v14;
  a1[2] = v13;
  if (v3)
    operator delete(v3);
}

uint64_t sub_1B67B88FC(uint64_t a1, FILE *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a2)
    return 4294954394;
  v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  v5 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  v6 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v7 = *(int *)(a1 + 404);
  if ((int)v7 < (int)v5)
  {
    v8 = v6 + *(int *)(a1 + 400);
    do
      fwrite((const void *)(v8 + *(_QWORD *)(a1 + 112) * v7++), 1uLL, v4, a2);
    while (v7 < v5);
  }
  v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v10 = *(int *)(a1 + 404);
  if ((int)v10 < (int)v5)
  {
    v11 = v9 + 2 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v11 + *(_QWORD *)(a1 + 120) * v10++), 1uLL, 2 * v4, a2);
    while (v10 < (int)v5);
  }
  return 0;
}

uint64_t sub_1B67B8A04(uint64_t a1, FILE *a2)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  char *v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char v25;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;

  if (!a2)
    return 4294954394;
  v4 = *(int *)(a1 + 276);
  v5 = *(_DWORD *)(a1 + 408) + *(_DWORD *)(a1 + 400);
  v6 = v4 - v5;
  v7 = *(_DWORD *)(a1 + 280);
  v8 = *(_DWORD *)(a1 + 412);
  v9 = v8 + *(_DWORD *)(a1 + 404);
  v30 = v7 - v9;
  v10 = v7 - v8;
  v11 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v12 = *(int *)(a1 + 404);
  if ((int)v12 < v10)
  {
    v13 = v11 + *(int *)(a1 + 400);
    do
      fwrite((const void *)(v13 + *(_QWORD *)(a1 + 112) * v12++), 1uLL, v4 - v5, a2);
    while (v12 < v10);
  }
  v14 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v28 = *(int *)(a1 + 400);
  v29 = v14;
  v27 = *(int *)(a1 + 404);
  v15 = *(_QWORD *)(a1 + 120);
  v16 = v30 * (uint64_t)v6;
  v17 = (char *)operator new[](2 * (int)v16, MEMORY[0x1E0DE4E10]);
  if (!v17)
    return 4294954392;
  v18 = v17;
  if (v7 != v9)
  {
    v19 = v30;
    v20 = &v17[v16];
    v21 = v29 + ~(2 * v5) + v15 * v27 + 2 * v4 + 2 * v28;
    v22 = v17;
    do
    {
      if ((_DWORD)v4 != v5)
      {
        v23 = (char *)v21;
        v24 = v6;
        do
        {
          v22[v24 - 1] = *(v23 - 1);
          v25 = *v23;
          v23 -= 2;
          v20[--v24] = v25;
        }
        while (v24);
      }
      v22 += v6;
      v20 += v6;
      v21 += v15;
      --v19;
    }
    while (v19);
  }
  fwrite(v17, 1uLL, 2 * (int)v16, a2);
  MEMORY[0x1BCC9811C](v18, 0x1000C8077774924);
  return 0;
}

uint64_t sub_1B67B8BE8(uint64_t *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  uint64_t v4;
  char *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t i;
  char v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char v25;
  char v26;
  char v27;
  uint64_t v28;
  char v29;
  BOOL v30;
  uint64_t v31;
  void *__p[3];
  CC_MD5_CTX c;
  char v35;
  CC_MD5_CTX v36;
  char v37;
  CC_MD5_CTX v38;
  char v39;
  uint64_t v40;

  v2 = a2;
  v40 = *MEMORY[0x1E0C80C00];
  memset(__p, 0, sizeof(__p));
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  v4 = *a1;
  if (*((_BYTE *)a1 + 136))
  {
    v5 = (char *)(*(uint64_t (**)(uint64_t *, _QWORD))(v4 + 56))(a1, 0);
    v6 = a1 + 22;
    v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, 1);
    v8 = a1 + 21;
  }
  else
  {
    v5 = (char *)(*(uint64_t (**)(uint64_t *, _QWORD))(v4 + 40))(a1, 0);
    v6 = a1 + 15;
    v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, 1);
    v8 = a1 + 14;
  }
  v9 = 0;
  v10 = *v6;
  v11 = *v8;
  do
  {
    *((_BYTE *)&c + v9 + 92) = 1;
    *((_BYTE *)&c + v9 + 92) = CC_MD5_Init((CC_MD5_CTX *)((char *)&c + v9)) != 0;
    v9 += 96;
  }
  while (v9 != 288);
  if (*((_DWORD *)a1 + 70))
  {
    for (i = 0; i < v14; ++i)
    {
      v13 = CC_MD5_Update(&c, v5, *((_DWORD *)a1 + 69));
      v35 &= v13;
      v5 += v11;
      v14 = *((_DWORD *)a1 + 70);
    }
    v15 = v14;
    if (!v7)
      goto LABEL_22;
LABEL_12:
    v16 = *((int *)a1 + 69);
    v17 = (int)v16 * (uint64_t)v14;
    if ((_DWORD)v17)
    {
      sub_1B6773C90((unint64_t *)__p, 2 * (int)v17);
      v18 = (char *)__p[0];
    }
    else
    {
      v18 = 0;
    }
    v19 = &v18[v17];
    if (v14)
    {
      v20 = v7 + 2 * v16 - 1;
      v21 = v18;
      v22 = &v18[v17];
      do
      {
        if ((_DWORD)v16)
        {
          v23 = (char *)v20;
          v24 = v16;
          do
          {
            v21[v24 - 1] = *(v23 - 1);
            v25 = *v23;
            v23 -= 2;
            v22[--v24] = v25;
          }
          while (v24);
        }
        v21 += v16;
        v22 += v16;
        v20 += v10;
        --v15;
      }
      while (v15);
    }
    v26 = CC_MD5_Update(&v36, v18, v16 * v14);
    v37 &= v26;
    v27 = CC_MD5_Update(&v38, v19, v16 * v14);
    v39 &= v27;
    goto LABEL_22;
  }
  v14 = 0;
  v15 = 0;
  if (v7)
    goto LABEL_12;
LABEL_22:
  v28 = 0;
  while (1)
  {
    v29 = CC_MD5_Final(v2, (CC_MD5_CTX *)((char *)&c + v28));
    v30 = (v29 & *((_BYTE *)&c + v28 + 92)) == 0;
    *((_BYTE *)&c + v28 + 92) &= v29;
    if (v30)
      break;
    v28 += 96;
    v2 += 16;
    if (v28 == 288)
    {
      v31 = 0;
      goto LABEL_27;
    }
  }
  v31 = 4294954385;
LABEL_27:
  if (__p[0])
    operator delete(__p[0]);
  return v31;
}

void sub_1B67B8E88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B67B8EAC(uint64_t a1, int *a2, uint64_t a3, int a4)
{
  __CVBuffer *v8;
  OSType PixelFormatType;
  int v10;
  int v11;
  uint64_t v12;
  __CVBuffer *v13;
  signed int v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  const __CFAllocator *v19;
  OSStatus v20;
  _BOOL4 v21;
  uint64x2_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int8 *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const __CFDictionary *DescriptionWithPixelFormatType;
  const void *Value;
  CVReturn v33;
  NSObject *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  unsigned __int8 *v38;
  unsigned __int8 *v39;
  unsigned __int8 *v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  unsigned __int8 *v46;
  unsigned __int8 *v47;
  unsigned __int8 *v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint32x2_t v62;
  unsigned __int8 *v63;
  unsigned __int8 *v64;
  uint64_t v65;
  uint32x2_t v66;
  uint32x2_t v67;
  int32x2_t v68;
  OSStatus v70;
  uint32_t v71;
  size_t Height;
  size_t Width;
  int v74;
  int v75;
  uint64_t v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  uint64x2_t v82;
  CFMutableDictionaryRef Mutable;
  VTPixelTransferSessionRef pixelTransferSessionOut;
  CVPixelBufferRef pixelBufferOut;
  uint8_t buf[4];
  CVReturn v87;
  CFMutableDictionaryRef theDict;
  uint64_t (**v89)();
  int v90;
  int v91;
  uint64_t v92;
  __int16 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  char v98;
  uint64_t v99;
  __int16 v100;
  char v101;
  char v102;
  __int128 v103;
  __int128 v104;
  uint64_t v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  uint64_t v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  uint64_t v116;
  __int128 v117;
  int v118;
  uint64_t (***v119)();
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  _BYTE v124[21];
  __int128 v125;
  __int128 v126;
  uint64_t v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  uint64_t v131;
  uint64_t v132;
  __int128 v133;
  __int128 v134;
  uint64_t v135;
  uint64_t v136;
  int v137;
  uint64_t v138;
  char v139;
  uint64_t v140;

  v140 = *MEMORY[0x1E0C80C00];
  v90 = 0;
  v91 = 0;
  v98 = 1;
  v106 = 0u;
  v107 = 0u;
  v117 = 0u;
  v99 = 0;
  v100 = 0;
  v110 = 0u;
  v111 = 0u;
  v114 = 0u;
  v115 = 0u;
  v119 = &v89;
  memset(v124, 0, sizeof(v124));
  v123 = 0u;
  v122 = 0u;
  v121 = 0u;
  v120 = 0u;
  v126 = 0u;
  v125 = 0u;
  v127 = 850045863;
  v128 = 0u;
  v129 = 0u;
  v130 = 0u;
  v131 = 0;
  v132 = 1018212795;
  v133 = 0u;
  v134 = 0u;
  v135 = 0;
  v116 = 0;
  v93 = 0;
  v118 = 0;
  v92 = 0;
  v101 = 0;
  v102 = 0;
  v103 = 0u;
  v97 = 0u;
  v104 = 0u;
  v105 = 0;
  v108 = 0u;
  v109 = 0;
  v112 = 0u;
  v113 = 0u;
  v94 = 0u;
  v95 = 0u;
  v96 = 0u;
  v89 = &off_1E6A15040;
  v136 = 0;
  v137 = 0;
  v138 = 0;
  v139 = 0;
  pixelTransferSessionOut = 0;
  pixelBufferOut = 0;
  v8 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  PixelFormatType = CVPixelBufferGetPixelFormatType(v8);
  v10 = a2[69];
  v80 = a2[102];
  v81 = a2[100];
  v11 = a2[70];
  v78 = a2[103];
  v79 = a2[101];
  v12 = *((_QWORD *)a2 + 14);
  v13 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  v14 = CVPixelBufferGetPixelFormatType(v13);
  v15 = 0;
  v77 = v11;
  if (v14 <= 2016687155)
  {
    if (v14 != 1278226736)
    {
      v16 = 2016686640;
LABEL_7:
      if (v14 != v16)
        goto LABEL_9;
    }
  }
  else if (v14 != 2016687156 && v14 != 2019963956)
  {
    v16 = 2019963440;
    goto LABEL_7;
  }
  v15 = 8 - sub_1B67C37F4(v14);
LABEL_9:
  v76 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
  v17 = a2[100];
  v18 = a2[101];
  if (CVIsCompressedPixelFormatAvailable(PixelFormatType))
  {
    v74 = v10;
    v75 = a4;
    v19 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v20 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &pixelTransferSessionOut);
    if (v20)
    {
      v21 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      v22 = 0uLL;
      if (v21)
      {
        LODWORD(theDict) = 67109120;
        HIDWORD(theDict) = v20;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate for PSNR calculation failed with error: %d\n", (uint8_t *)&theDict, 8u);
        v22 = 0uLL;
      }
      v23 = 0;
      goto LABEL_59;
    }
    Width = CVPixelBufferGetWidth(v8);
    Height = CVPixelBufferGetHeight(v8);
    theDict = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E0CA8FF0], Mutable);
    v30 = a3;
    DescriptionWithPixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
    Value = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E0CA9120]);
    if (sub_1B67C37F4(PixelFormatType) != 8 || !CFEqual(Value, (CFTypeRef)*MEMORY[0x1E0CA9130]))
    {
      a3 = v30;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        v34 = MEMORY[0x1E0C81028];
        v35 = "Bit depth of source pixel buffer is not 8 or source pixel buffer is not video range for PSNR calculation";
        v71 = 2;
        goto LABEL_70;
      }
      goto LABEL_35;
    }
    v33 = CVPixelBufferCreate(v19, Width, Height, 0x34323076u, theDict, &pixelBufferOut);
    a3 = v30;
    if (v33)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        v87 = v33;
        v34 = MEMORY[0x1E0C81028];
        v35 = "CVPixelBufferCreate for PSNR calculation failed with error: %d\n";
LABEL_67:
        v71 = 8;
LABEL_70:
        _os_log_error_impl(&dword_1B676B000, v34, OS_LOG_TYPE_ERROR, v35, buf, v71);
        goto LABEL_35;
      }
      goto LABEL_35;
    }
    v70 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v8, pixelBufferOut);
    if (v70)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        v87 = v70;
        v34 = MEMORY[0x1E0C81028];
        v35 = "Pixel transfer from compressed to linear format for PSNR calculation failed with error: %d\n";
        goto LABEL_67;
      }
LABEL_35:
      sub_1B67705C8((const void **)&Mutable);
      sub_1B67705C8((const void **)&theDict);
LABEL_46:
      v23 = 0;
LABEL_47:
      v22 = 0uLL;
      goto LABEL_59;
    }
    CVPixelBufferGetPixelFormatType(pixelBufferOut);
    sub_1B67C28B8((uint64_t)&v89, pixelBufferOut, 0);
    sub_1B67705C8((const void **)&Mutable);
    sub_1B67705C8((const void **)&theDict);
    a3 = v30;
    v10 = v74;
    a4 = v75;
  }
  else
  {
    sub_1B67C28B8((uint64_t)&v89, v8, 0);
  }
  v24 = (v10 - (v81 + v80));
  v25 = (v77 - (v79 + v78));
  v26 = (unsigned __int8 *)(v76 + v17 + v12 * v18);
  v27 = v94;
  if (a4)
  {
    v28 = *((_QWORD *)&v96 + 1);
    if ((_QWORD)v94 || !sub_1B67C3B94((uint64_t)&v89))
      v29 = v95;
    else
      v29 = 0;
    if ((int)v25 < 1)
      goto LABEL_46;
    v45 = 0;
    v23 = 0;
    v46 = (unsigned __int8 *)(v29 + (int)v103 + v28 * SDWORD1(v103));
    do
    {
      if ((int)v24 >= 1)
      {
        v47 = v26;
        v48 = v46;
        v49 = v24;
        do
        {
          v51 = *v47++;
          v50 = v51;
          v52 = *v48++;
          v23 += ((v50 - v52) * (v50 - v52));
          --v49;
        }
        while (v49);
      }
      ++v45;
      v46 += v28;
      v26 += v12;
    }
    while (v45 != v25);
  }
  else
  {
    v36 = *((_QWORD *)&v95 + 1);
    if (!(_QWORD)v94)
    {
      if (sub_1B67C3B94((uint64_t)&v89))
        v27 = 0;
      else
        v27 = v94;
    }
    if ((int)v25 < 1)
    {
      v23 = 0;
      goto LABEL_49;
    }
    v37 = 0;
    v23 = 0;
    v38 = (unsigned __int8 *)(v27 + (int)v103 + v36 * SDWORD1(v103));
    do
    {
      if ((int)v24 >= 1)
      {
        v39 = v26;
        v40 = v38;
        v41 = v24;
        do
        {
          v43 = *v39++;
          v42 = v43;
          v44 = *v40++;
          v23 += ((v42 >> v15) - (v44 >> v15)) * ((v42 >> v15) - (v44 >> v15));
          --v41;
        }
        while (v41);
      }
      ++v37;
      v38 += v36;
      v26 += v12;
    }
    while (v37 != v25);
  }
  v22 = 0uLL;
  if ((a4 & 1) != 0)
    goto LABEL_59;
LABEL_49:
  v53 = v96;
  v54 = *((_QWORD *)a2 + 15);
  v55 = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a2 + 40))(a2, 1);
  v56 = a2[100];
  v57 = a2[101];
  if ((_QWORD)v94 || !sub_1B67C3B94((uint64_t)&v89))
    v58 = *((_QWORD *)&v94 + 1);
  else
    v58 = 0;
  if ((int)v25 < 1)
    goto LABEL_47;
  v59 = 0;
  v60 = v55 + 2 * v56 + v54 * v57;
  v61 = v58 + 2 * (int)v103 + v53 * SDWORD1(v103);
  v22 = 0uLL;
  v62 = (uint32x2_t)vneg_s32(vdup_n_s32(v15));
  do
  {
    if ((int)v24 >= 1)
    {
      v63 = (unsigned __int8 *)v60;
      v64 = (unsigned __int8 *)v61;
      v65 = v24;
      do
      {
        v66.i32[0] = *v63;
        v66.i32[1] = v63[1];
        v67.i32[0] = *v64;
        v67.i32[1] = v64[1];
        v68 = vsub_s32((int32x2_t)vshl_u32(v66, v62), (int32x2_t)vshl_u32(v67, v62));
        v22 = vaddw_u32(v22, (uint32x2_t)vmul_s32(v68, v68));
        v64 += 2;
        v63 += 2;
        --v65;
      }
      while (v65);
    }
    ++v59;
    v61 += v53;
    v60 += v54;
  }
  while (v59 != v25);
LABEL_59:
  v82 = v22;
  if (pixelBufferOut)
    CVPixelBufferRelease(pixelBufferOut);
  if (pixelTransferSessionOut)
    CFRelease(pixelTransferSessionOut);
  *(double *)a3 = (double)v23;
  *(float64x2_t *)(a3 + 8) = vcvtq_f64_u64(v82);
  return sub_1B67C3D28((uint64_t)&v89);
}

void sub_1B67B9678(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  const void *v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  va_list va1;
  va_list va2;

  va_start(va2, a10);
  va_start(va1, a10);
  va_start(va, a10);
  v11 = va_arg(va1, const void *);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v17 = va_arg(va2, const void *);
  sub_1B67705C8((const void **)va);
  sub_1B67705C8((const void **)va1);
  sub_1B67C3D28((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_1B67B96E8(int *a1, int *a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  uint64_t v24;
  unsigned __int8 *v25;
  unsigned __int8 *v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t result;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  int v42;
  uint64x2_t *v43;
  uint64_t v44;
  uint64_t v45;
  uint64x2_t v46;
  unsigned __int8 *v47;
  unsigned __int8 *v48;
  uint64_t v49;
  int32x2_t v50;
  int32x2_t v51;
  int32x2_t v52;
  uint64_t v53;
  _OWORD *v54;
  uint64_t i;
  _OWORD v56[4];
  uint64_t v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v57 = 0;
  memset(v56, 0, sizeof(v56));
  v6 = (a2[69] - (a2[100] + a2[102]));
  v7 = a2[70] - (a2[101] + a2[103]);
  v8 = *((_QWORD *)a2 + 14);
  v9 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
  v10 = a2[100];
  v11 = a2[101];
  v12 = *((_QWORD *)a1 + 14);
  v13 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v14 = 0;
  v15 = v13 + a1[100];
  v16 = a1[101];
  do
  {
    v17 = v7 * (int)v14 / 3;
    v18 = v14 + 1;
    v19 = v7 * ((int)v14 + 1) / 3;
    if (v17 < v19)
    {
      v20 = (uint64_t *)v56 + 3 * v14;
      v21 = v17;
      v22 = (unsigned __int8 *)(v15 + v12 * (v16 + v17));
      v23 = (unsigned __int8 *)(v9 + v10 + v8 * (v11 + v17));
      do
      {
        if ((int)v6 >= 1)
        {
          v24 = *v20;
          v25 = v23;
          v26 = v22;
          v27 = v6;
          do
          {
            v29 = *v25++;
            v28 = v29;
            v30 = *v26++;
            v24 += ((v28 - v30) * (v28 - v30));
            --v27;
          }
          while (v27);
          *v20 = v24;
        }
        ++v21;
        v22 += v12;
        v23 += v8;
      }
      while (v21 != v19);
    }
    v14 = v18;
  }
  while (v18 != 3);
  v31 = *((_QWORD *)a1 + 15);
  v32 = *((_QWORD *)a2 + 15);
  v33 = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a2 + 40))(a2, 1);
  v34 = a2[100];
  v35 = a2[101];
  result = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v37 = 0;
  v38 = a1[101];
  v39 = result + 2 * a1[100];
  do
  {
    v40 = v7 * (int)v37 / 3;
    v41 = v37 + 1;
    v42 = v7 * ((int)v37 + 1) / 3;
    if (v40 < v42)
    {
      v43 = (uint64x2_t *)((char *)v56 + 24 * v37 + 8);
      v44 = v40;
      result = v39 + v31 * (v38 + v40);
      v45 = v33 + 2 * v34 + v32 * (v35 + v40);
      do
      {
        if ((int)v6 >= 1)
        {
          v46 = *v43;
          v47 = (unsigned __int8 *)v45;
          v48 = (unsigned __int8 *)result;
          v49 = v6;
          do
          {
            v50.i32[0] = *v47;
            v50.i32[1] = v47[1];
            v51.i32[0] = *v48;
            v51.i32[1] = v48[1];
            v52 = vsub_s32(v50, v51);
            v46 = vaddw_u32(v46, (uint32x2_t)vmul_s32(v52, v52));
            v48 += 2;
            v47 += 2;
            --v49;
          }
          while (v49);
          *v43 = v46;
        }
        ++v44;
        result += v31;
        v45 += v32;
      }
      while (v44 != v42);
    }
    v37 = v41;
  }
  while (v41 != 3);
  v53 = 0;
  v54 = v56;
  do
  {
    for (i = 0; i != 24; i += 8)
      *(double *)(a3 + i) = (double)(unint64_t)(3 * *(_QWORD *)((char *)v54 + i));
    ++v53;
    a3 += 24;
    v54 = (_OWORD *)((char *)v54 + 24);
  }
  while (v53 != 3);
  return result;
}

char *sub_1B67B9A08(char *result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  int v10;
  int v11;
  size_t v12;
  unsigned __int8 *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  char *v18;

  v10 = (int)result;
  if (a5)
  {
    v11 = *(_DWORD *)(a6 + 276);
    v12 = (a3 + (_DWORD)result - v11);
    if ((int)v12 >= 1)
    {
      v13 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a6 + 16))(a6, (v11 - 1), (a2 - 1), 0);
      result = (char *)memset(v13 + 1, *v13, v12);
    }
  }
  if (a4)
  {
    v14 = *(_DWORD *)(a6 + 280);
    v15 = (a3 + a2 - v14);
    if ((int)v15 >= 1)
    {
      v16 = *(_QWORD *)(a6 + 112);
      result = (char *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a6 + 16))(a6, (v10 - 1), (v14 - 1), 0);
      v17 = *result;
      v18 = &result[v16];
      do
      {
        *v18 = v17;
        v18 += v16;
        --v15;
      }
      while (v15);
    }
  }
  return result;
}

__int16 *sub_1B67B9AD4(__int16 *result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  int v10;
  int v11;
  uint64_t v12;
  __int16 *v13;
  __int16 v14;
  __int16 v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  __int16 v19;
  _WORD *v20;

  v10 = (int)result;
  if (a5)
  {
    v11 = *(_DWORD *)(a6 + 276);
    v12 = (a3 + (_DWORD)result - v11);
    if ((int)v12 >= 1)
    {
      v13 = (__int16 *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a6 + 16))(a6, (v11 - 1), (a2 - 1), 1);
      v15 = *v13;
      result = v13 + 1;
      v14 = v15;
      do
      {
        *result++ = v14;
        --v12;
      }
      while (v12);
    }
  }
  if (a4)
  {
    v16 = *(_DWORD *)(a6 + 280);
    v17 = (a3 + a2 - v16);
    if ((int)v17 >= 1)
    {
      v18 = *(_QWORD *)(a6 + 120);
      result = (__int16 *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a6 + 16))(a6, (v10 - 1), (v16 - 1), 1);
      v19 = *result;
      v20 = (__int16 *)((char *)result + (v18 & 0xFFFFFFFFFFFFFFFELL));
      do
      {
        *v20 = v19;
        v20 = (_WORD *)((char *)v20 + (v18 & 0xFFFFFFFFFFFFFFFELL));
        --v17;
      }
      while (v17);
    }
  }
  return result;
}

uint64_t sub_1B67B9BA8(int a1, int a2, int a3, int a4, int a5, int a6, _QWORD *a7)
{
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  size_t v22;
  int v23;
  uint64_t v24;
  int v25;
  unsigned __int8 *v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  __int16 v33;
  _WORD *v34;
  uint64_t v35;
  int v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  size_t v45;
  char *v46;
  int v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  __int16 v56;
  _WORD *v57;
  int v58;
  uint64_t v59;
  int v60;
  char *v61;
  char *v62;
  BOOL v63;
  int v64;
  char *v65;
  char *v66;
  uint64_t v67;
  uint64_t v68;
  size_t v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  int v85;

  v83 = (*(uint64_t (**)(_QWORD *, _QWORD))(*a7 + 32))(a7, 0);
  v13 = a7[14];
  result = (*(uint64_t (**)(_QWORD *, uint64_t))(*a7 + 32))(a7, 1);
  v15 = result;
  v16 = a7[15];
  v17 = v16;
  v84 = a6;
  v85 = a2;
  v82 = result;
  if (a1 <= 2)
  {
    if (a2 <= 3)
      v18 = 3;
    else
      v18 = a2;
    v19 = a2 + a6 + 4;
    LODWORD(v20) = *((_DWORD *)a7 + 70);
    if (v19 >= (int)v20)
      v21 = *((_DWORD *)a7 + 70);
    else
      v21 = v19;
    if ((int)v18 - 3 < v21)
    {
      v79 = a5;
      v22 = (3 - a1);
      v23 = a1;
      v24 = v18 - 3;
      v25 = v23;
      v26 = (unsigned __int8 *)(v83 + v13 * (v18 - 3));
      v27 = v23 - 3;
      do
      {
        result = (uint64_t)memset(&v26[v27], *v26, v22);
        LODWORD(v20) = *((_DWORD *)a7 + 70);
        ++v24;
        if (v19 >= (int)v20)
          v28 = *((_DWORD *)a7 + 70);
        else
          v28 = v19;
        v26 += v13;
      }
      while (v24 < v28);
      v17 = a7[15];
      a6 = v84;
      v15 = v82;
      a5 = v79;
      a1 = v25;
    }
    if (a4 <= 1)
      v29 = 1;
    else
      v29 = a4;
    v30 = a4 + a6 + 2;
    if (v30 >= (int)v20)
      v20 = v20;
    else
      v20 = v30;
    if ((int)v29 <= (int)v20)
    {
      v31 = v29 - 1;
      v32 = v15 + 2 * (v17 >> 1) * v31 - 2;
      a2 = v85;
      do
      {
        if (a3 <= 0)
        {
          v33 = *(_WORD *)(v15 + 2 * (v17 >> 1) * v31);
          v34 = (_WORD *)v32;
          v35 = (1 - a3) & ~((1 - a3) >> 31);
          do
          {
            *v34-- = v33;
            --v35;
          }
          while (v35);
        }
        ++v31;
        v32 += 2 * (v17 >> 1);
      }
      while (v31 != v20);
    }
    else
    {
      a2 = v85;
    }
  }
  v36 = a1 + a5 + 4;
  v37 = *((_DWORD *)a7 + 69);
  v38 = v36 - v37;
  if (v36 > v37)
  {
    v39 = a1;
    if (a2 <= 3)
      v40 = 3;
    else
      v40 = a2;
    v41 = a2 + a6 + 4;
    LODWORD(v42) = *((_DWORD *)a7 + 70);
    if (v41 >= (int)v42)
      v43 = *((_DWORD *)a7 + 70);
    else
      v43 = a2 + a6 + 4;
    if ((int)v40 - 3 < v43)
    {
      v80 = a5;
      v44 = v40 - 3;
      v45 = v38;
      v46 = (char *)(v37 + v13 * (v40 - 3) + v83);
      do
      {
        result = (uint64_t)memset(v46, *(v46 - 1), v45);
        ++v44;
        LODWORD(v42) = *((_DWORD *)a7 + 70);
        if (v41 >= (int)v42)
          v47 = *((_DWORD *)a7 + 70);
        else
          v47 = v41;
        v46 += v13;
      }
      while (v44 < v47);
      v37 = *((_DWORD *)a7 + 69);
      v17 = a7[15];
      a6 = v84;
      a2 = v85;
      a5 = v80;
    }
    a1 = v39;
    if (a4 <= 1)
      v48 = 1;
    else
      v48 = a4;
    v49 = a4 + a6 + 2;
    if (v49 >= (int)v42)
      v42 = v42;
    else
      v42 = v49;
    if ((int)v48 <= (int)v42)
    {
      v50 = 2 * v37 - 2;
      v51 = v15 + v50;
      v52 = v17 >> 1;
      v53 = a3 + a5 - v37 + 2;
      v54 = v48 - 1;
      v55 = v50 + 2 * v52 * v54 + v15 + 2;
      do
      {
        if (v53 >= 1)
        {
          v56 = *(_WORD *)(v51 + 2 * v52 * v54);
          v57 = (_WORD *)v55;
          result = v53 & ~(v53 >> 31);
          do
          {
            *v57++ = v56;
            --result;
          }
          while (result);
        }
        ++v54;
        v55 += 2 * v52;
      }
      while (v54 != v42);
    }
  }
  v58 = a5;
  v81 = 2 * a5;
  v59 = v83 + a1;
  if (a2 <= 2)
  {
    v60 = v85 - 3;
    v61 = (char *)(v59 - 3);
    do
    {
      v62 = &v61[-v13];
      result = (uint64_t)memcpy(&v61[-v13], v61, v58 + 7);
      v61 = v62;
      v63 = __CFADD__(v60++, 1);
    }
    while (!v63);
    if (a4 <= 0)
    {
      v64 = a4 - 1;
      v65 = (char *)(v82 + 2 * a3 - 2);
      do
      {
        v66 = &v65[-v16];
        result = (uint64_t)memcpy(&v65[-v16], v65, v81 + 6);
        v65 = v66;
        v63 = __CFADD__(v64++, 1);
      }
      while (!v63);
    }
  }
  v67 = *((int *)a7 + 70);
  if (v85 + v84 + 4 > (int)v67)
  {
    v68 = v13 * (v67 - 1);
    v69 = v58 + 7;
    v70 = v84 + v85 - v67 + 4;
    v71 = v59 - 3;
    v72 = v13 * v67;
    do
    {
      result = (uint64_t)memcpy((void *)(v71 + v72), (const void *)(v71 + v68), v69);
      v71 += v13;
      --v70;
    }
    while (v70);
    v73 = *((int *)a7 + 70);
    if ((int)v73 < a4 + v84 + 2)
    {
      v74 = v16 * (v73 - 1);
      v75 = 2 * a3 - 2;
      v76 = v84 + a4 - v73 + 2;
      v77 = v82 + v75;
      v78 = v16 * v73;
      do
      {
        result = (uint64_t)memcpy((void *)(v77 + v78), (const void *)(v77 + v74), v81 + 6);
        v77 += v16;
        --v76;
      }
      while (v76);
    }
  }
  return result;
}

uint64_t sub_1B67BA004(uint64_t a1, FILE *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a2)
    return 4294954394;
  v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  v5 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  v6 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v7 = *(int *)(a1 + 404);
  if ((int)v7 < (int)v5)
  {
    v8 = v6 + 2 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v8 + 2 * *(_QWORD *)(a1 + 112) * v7++), 1uLL, 2 * v4, a2);
    while (v7 < v5);
  }
  v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v10 = *(int *)(a1 + 404);
  if ((int)v10 < (int)v5)
  {
    v11 = v9 + 2 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v11 + 2 * *(_QWORD *)(a1 + 120) * v10++), 1uLL, 2 * (v4 & 0x3FFFFFFFFFFFFFFFLL), a2);
    while (v10 < (int)v5);
  }
  return 0;
}

uint64_t sub_1B67BA118(uint64_t a1, FILE *a2)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  size_t v20;
  size_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  __int16 *v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v33;
  uint64_t v34;

  if (!a2)
    return 4294954394;
  v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  v5 = *(_DWORD *)(a1 + 280);
  v6 = *(_DWORD *)(a1 + 412);
  v7 = v5 - (*(_DWORD *)(a1 + 404) + v6);
  v8 = v5 - v6;
  v9 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v10 = *(int *)(a1 + 404);
  if ((int)v10 < v8)
  {
    v11 = v9 + 2 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v11 + 2 * *(_QWORD *)(a1 + 112) * v10++), 1uLL, 2 * v4, a2);
    while (v10 < v8);
  }
  if (v4 >= 0)
    v12 = v4;
  else
    v12 = v4 + 1;
  v13 = v12 >> 1;
  if (v7 >= 0)
    v14 = v7;
  else
    v14 = v7 + 1;
  v15 = v14 >> 1;
  v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v33 = *(int *)(a1 + 400);
  v34 = v16;
  v17 = *(int *)(a1 + 404);
  v18 = *(_QWORD *)(a1 + 120);
  v19 = 2 * v15 * v13;
  v20 = 2 * v19;
  if (v15 * v13 < 0)
    v21 = -1;
  else
    v21 = 2 * v19;
  v22 = (char *)operator new[](v21, MEMORY[0x1E0DE4E10]);
  if (!v22)
    return 4294954392;
  v23 = v22;
  if ((v7 + 1) >= 3)
  {
    v24 = v15;
    v25 = &v22[2 * v15 * v13];
    v26 = 2 * v13;
    v27 = 2 * v18 * v17 + 4 * v13 + 2 * v33 + v34 - 2;
    v28 = v22;
    do
    {
      if ((v4 + 1) >= 3)
      {
        v29 = (__int16 *)v27;
        v30 = v13 - 1;
        do
        {
          *(_WORD *)&v28[2 * v30] = *(v29 - 1);
          v31 = *v29;
          v29 -= 2;
          *(_WORD *)&v25[2 * v30--] = v31;
        }
        while (v30 != -1);
      }
      v25 += v26;
      v28 += v26;
      v27 += 2 * v18;
      --v24;
    }
    while (v24);
  }
  fwrite(v22, 1uLL, v20, a2);
  MEMORY[0x1BCC9811C](v23, 0x1000C80BDFB0063);
  return 0;
}

uint64_t sub_1B67BA314(uint64_t *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  uint64_t v4;
  char *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  CC_LONG v21;
  void *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  char *v27;
  __int16 *v28;
  uint64_t v29;
  __int16 v30;
  char v31;
  char v32;
  uint64_t v33;
  char v34;
  BOOL v35;
  uint64_t v36;
  void *data[3];
  CC_MD5_CTX c;
  char v40;
  CC_MD5_CTX v41;
  char v42;
  CC_MD5_CTX v43;
  char v44;
  uint64_t v45;

  v2 = a2;
  v45 = *MEMORY[0x1E0C80C00];
  memset(data, 0, sizeof(data));
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  v4 = *a1;
  if (*((_BYTE *)a1 + 136))
  {
    v5 = (char *)(*(uint64_t (**)(uint64_t *, _QWORD))(v4 + 56))(a1, 0);
    v6 = a1 + 22;
    v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, 1);
    v8 = a1 + 21;
  }
  else
  {
    v5 = (char *)(*(uint64_t (**)(uint64_t *, _QWORD))(v4 + 40))(a1, 0);
    v6 = a1 + 15;
    v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, 1);
    v8 = a1 + 14;
  }
  v9 = 0;
  v10 = *v6;
  v11 = *v8;
  do
  {
    *((_BYTE *)&c + v9 + 92) = 1;
    *((_BYTE *)&c + v9 + 92) = CC_MD5_Init((CC_MD5_CTX *)((char *)&c + v9)) != 0;
    v9 += 96;
  }
  while (v9 != 288);
  if (*((_DWORD *)a1 + 70))
  {
    v12 = 0;
    v13 = 2 * v11;
    do
    {
      v14 = CC_MD5_Update(&c, v5, 2 * *((_DWORD *)a1 + 69));
      v40 &= v14;
      ++v12;
      v15 = *((_DWORD *)a1 + 70);
      v5 += v13;
    }
    while (v12 < v15);
    v16 = v15;
    if (v7)
    {
LABEL_10:
      v17 = *((_DWORD *)a1 + 69);
      if (v17 >= 0)
        v18 = *((_DWORD *)a1 + 69);
      else
        v18 = v17 + 1;
      v19 = v18 >> 1;
      v20 = (v18 >> 1) * v15;
      v21 = 2 * v20;
      sub_1B67B8800((char **)data, 2 * v20);
      v22 = data[0];
      v23 = (char *)data[0] + 2 * v20;
      if (v15)
      {
        v24 = 2 * v19;
        v25 = v7 + 4 * v19 - 2;
        v26 = (char *)data[0];
        v27 = v23;
        do
        {
          if ((v17 + 1) >= 3)
          {
            v28 = (__int16 *)v25;
            v29 = v19 - 1;
            do
            {
              *(_WORD *)&v26[2 * v29] = *(v28 - 1);
              v30 = *v28;
              v28 -= 2;
              *(_WORD *)&v27[2 * v29--] = v30;
            }
            while (v29 != -1);
          }
          v27 += v24;
          v26 += v24;
          v25 += 2 * v10;
          --v16;
        }
        while (v16);
      }
      v31 = CC_MD5_Update(&v41, v22, v21);
      v42 &= v31;
      v32 = CC_MD5_Update(&v43, v23, v21);
      v44 &= v32;
      goto LABEL_22;
    }
  }
  else
  {
    v15 = 0;
    v16 = 0;
    if (v7)
      goto LABEL_10;
  }
  v22 = 0;
LABEL_22:
  v33 = 0;
  while (1)
  {
    v34 = CC_MD5_Final(v2, (CC_MD5_CTX *)((char *)&c + v33));
    v35 = (v34 & *((_BYTE *)&c + v33 + 92)) == 0;
    *((_BYTE *)&c + v33 + 92) &= v34;
    if (v35)
      break;
    v33 += 96;
    v2 += 16;
    if (v33 == 288)
    {
      v36 = 0;
      if (!v22)
        return v36;
      goto LABEL_28;
    }
  }
  v36 = 4294954385;
  if (!v22)
    return v36;
LABEL_28:
  operator delete(v22);
  return v36;
}

void sub_1B67BA5D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B67BA60C(uint64_t a1, int *a2, double *a3, int a4)
{
  __CVBuffer *v8;
  OSType PixelFormatType;
  int v10;
  int v11;
  uint64_t v12;
  __CVBuffer *v13;
  signed int v14;
  char v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFAllocator *v20;
  OSStatus v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double *v28;
  const __CFDictionary *DescriptionWithPixelFormatType;
  const void *Value;
  CVReturn v31;
  NSObject *v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unsigned __int16 *v38;
  unsigned __int16 *v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  unsigned __int16 *v46;
  unsigned __int16 *v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  unint64_t v52;
  unint64_t v53;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unsigned __int16 *v66;
  unsigned __int16 *v67;
  uint64_t v68;
  int v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int v72;
  OSStatus v73;
  uint32_t v74;
  size_t Height;
  size_t Width;
  uint64_t v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  uint64_t v84;
  int v85;
  double *v86;
  CFMutableDictionaryRef Mutable;
  VTPixelTransferSessionRef pixelTransferSessionOut;
  CVPixelBufferRef pixelBufferOut;
  uint8_t v90[4];
  CVReturn v91;
  uint8_t buf[8];
  uint64_t (**v93)();
  int v94;
  int v95;
  uint64_t v96;
  __int16 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  char v102;
  uint64_t v103;
  __int16 v104;
  char v105;
  char v106;
  __int128 v107;
  __int128 v108;
  uint64_t v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  uint64_t v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  uint64_t v120;
  __int128 v121;
  int v122;
  uint64_t (***v123)();
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  _BYTE v128[21];
  __int128 v129;
  __int128 v130;
  uint64_t v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  uint64_t v135;
  uint64_t v136;
  __int128 v137;
  __int128 v138;
  uint64_t v139;
  uint64_t v140;
  int v141;
  uint64_t v142;
  char v143;
  uint64_t v144;

  v144 = *MEMORY[0x1E0C80C00];
  v94 = 0;
  v95 = 0;
  v102 = 1;
  v110 = 0u;
  v111 = 0u;
  v121 = 0u;
  v103 = 0;
  v104 = 0;
  v114 = 0u;
  v115 = 0u;
  v118 = 0u;
  v119 = 0u;
  v123 = &v93;
  memset(v128, 0, sizeof(v128));
  v127 = 0u;
  v126 = 0u;
  v125 = 0u;
  v124 = 0u;
  v130 = 0u;
  v129 = 0u;
  v131 = 850045863;
  v132 = 0u;
  v133 = 0u;
  v134 = 0u;
  v135 = 0;
  v136 = 1018212795;
  v137 = 0u;
  v138 = 0u;
  v139 = 0;
  v120 = 0;
  v97 = 0;
  v122 = 0;
  v96 = 0;
  v105 = 0;
  v106 = 0;
  v107 = 0u;
  v101 = 0u;
  v108 = 0u;
  v109 = 0;
  v112 = 0u;
  v113 = 0;
  v116 = 0u;
  v117 = 0u;
  v98 = 0u;
  v99 = 0u;
  v100 = 0u;
  v93 = &off_1E6A15040;
  v140 = 0;
  v141 = 0;
  v142 = 0;
  v143 = 0;
  pixelTransferSessionOut = 0;
  pixelBufferOut = 0;
  v8 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  PixelFormatType = CVPixelBufferGetPixelFormatType(v8);
  v10 = a2[69];
  v85 = a2[100];
  v11 = a2[70];
  v82 = a2[101];
  v83 = a2[102];
  v81 = a2[103];
  v12 = *((_QWORD *)a2 + 14);
  v13 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  v14 = CVPixelBufferGetPixelFormatType(v13);
  v15 = 0;
  v79 = v11;
  v80 = v10;
  if (v14 <= 2016687155)
  {
    if (v14 != 1278226736)
    {
      v16 = 2016686640;
LABEL_7:
      if (v14 != v16)
        goto LABEL_9;
    }
  }
  else if (v14 != 2016687156 && v14 != 2019963956)
  {
    v16 = 2019963440;
    goto LABEL_7;
  }
  v15 = 16 - sub_1B67C37F4(v14);
LABEL_9:
  v17 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
  v18 = a2[100];
  v19 = a2[101];
  if (CVIsCompressedPixelFormatAvailable(PixelFormatType))
  {
    v77 = v12;
    v78 = a4;
    v20 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v21 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &pixelTransferSessionOut);
    if (v21)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v21;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate for PSNR calculation failed with error: %d\n", buf, 8u);
      }
      goto LABEL_45;
    }
    Width = CVPixelBufferGetWidth(v8);
    Height = CVPixelBufferGetHeight(v8);
    *(_QWORD *)buf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, (const void *)*MEMORY[0x1E0CA8FF0], Mutable);
    v28 = a3;
    DescriptionWithPixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
    Value = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E0CA9120]);
    if (sub_1B67C37F4(PixelFormatType) != 8 || !CFEqual(Value, (CFTypeRef)*MEMORY[0x1E0CA9130]))
    {
      a3 = v28;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v90 = 0;
        v32 = MEMORY[0x1E0C81028];
        v33 = "Bit depth of source pixel buffer is not 8 or source pixel buffer is not video range for PSNR calculation";
        v74 = 2;
        goto LABEL_74;
      }
      goto LABEL_34;
    }
    v31 = CVPixelBufferCreate(v20, Width, Height, 0x34323076u, *(CFDictionaryRef *)buf, &pixelBufferOut);
    a3 = v28;
    if (v31)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v90 = 67109120;
        v91 = v31;
        v32 = MEMORY[0x1E0C81028];
        v33 = "CVPixelBufferCreate for PSNR calculation failed with error: %d\n";
LABEL_71:
        v74 = 8;
LABEL_74:
        _os_log_error_impl(&dword_1B676B000, v32, OS_LOG_TYPE_ERROR, v33, v90, v74);
        goto LABEL_34;
      }
      goto LABEL_34;
    }
    v73 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v8, pixelBufferOut);
    if (v73)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v90 = 67109120;
        v91 = v73;
        v32 = MEMORY[0x1E0C81028];
        v33 = "Pixel transfer from compressed to linear format for PSNR calculation failed with error: %d\n";
        goto LABEL_71;
      }
LABEL_34:
      sub_1B67705C8((const void **)&Mutable);
      sub_1B67705C8((const void **)buf);
LABEL_45:
      v36 = 0;
      goto LABEL_46;
    }
    CVPixelBufferGetPixelFormatType(pixelBufferOut);
    sub_1B67C28B8((uint64_t)&v93, pixelBufferOut, 0);
    sub_1B67705C8((const void **)&Mutable);
    sub_1B67705C8((const void **)buf);
    a3 = v28;
    a4 = v78;
    v12 = v77;
  }
  else
  {
    sub_1B67C28B8((uint64_t)&v93, v8, 0);
  }
  v22 = v80 - (v85 + v83);
  v23 = (v79 - (v82 + v81));
  v24 = v17 + 2 * v18 + 2 * v12 * v19;
  v25 = v98;
  if (a4)
  {
    v26 = *((_QWORD *)&v100 + 1);
    if ((_QWORD)v98 || !sub_1B67C3B94((uint64_t)&v93))
      v27 = v99;
    else
      v27 = 0;
    if ((int)v23 < 1)
      goto LABEL_45;
    v44 = 0;
    v36 = 0;
    v45 = v27 + 2 * (int)v107 + 2 * v26 * SDWORD1(v107);
    do
    {
      if (v22 >= 1)
      {
        v46 = (unsigned __int16 *)v24;
        v47 = (unsigned __int16 *)v45;
        v48 = (v80 - (v85 + v83));
        do
        {
          v50 = *v46++;
          v49 = v50;
          v51 = *v47++;
          v36 += ((v49 - v51) * (v49 - v51));
          --v48;
        }
        while (v48);
      }
      ++v44;
      v45 += 2 * v26;
      v24 += 2 * v12;
    }
    while (v44 != v23);
  }
  else
  {
    v34 = *((_QWORD *)&v99 + 1);
    if (!(_QWORD)v98)
    {
      if (sub_1B67C3B94((uint64_t)&v93))
        v25 = 0;
      else
        v25 = v98;
    }
    if ((int)v23 < 1)
    {
      v86 = a3;
      v36 = 0;
      goto LABEL_53;
    }
    v35 = 0;
    v36 = 0;
    v37 = v25 + 2 * (int)v107 + 2 * v34 * SDWORD1(v107);
    do
    {
      if (v22 >= 1)
      {
        v38 = (unsigned __int16 *)v24;
        v39 = (unsigned __int16 *)v37;
        v40 = (v80 - (v85 + v83));
        do
        {
          v42 = *v38++;
          v41 = v42;
          v43 = *v39++;
          v36 += ((v41 >> v15) - (v43 >> v15)) * ((v41 >> v15) - (v43 >> v15));
          --v40;
        }
        while (v40);
      }
      ++v35;
      v37 += 2 * v34;
      v24 += 2 * v12;
    }
    while (v35 != v23);
  }
  if ((a4 & 1) != 0)
  {
LABEL_46:
    v52 = 0;
    v53 = 0;
    goto LABEL_47;
  }
  v86 = a3;
LABEL_53:
  if (v22 >= 0)
    v55 = v22;
  else
    v55 = v22 + 1;
  v56 = v100;
  v57 = *((_QWORD *)a2 + 15);
  v84 = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a2 + 40))(a2, 1);
  v58 = a2[100];
  v59 = a2[101];
  if ((_QWORD)v98 || !sub_1B67C3B94((uint64_t)&v93))
    v60 = *((_QWORD *)&v98 + 1);
  else
    v60 = 0;
  if ((int)v23 < 1)
  {
    v52 = 0;
    v53 = 0;
    a3 = v86;
  }
  else
  {
    v61 = 0;
    v53 = 0;
    v62 = v55;
    v52 = 0;
    v63 = 2 * v56 * SDWORD1(v107) + 2 * (int)v107 + v60 + 2;
    v64 = 2 * v56;
    a3 = v86;
    v65 = 2 * v57 * v59 + 2 * v58 + v84 + 2;
    do
    {
      if (v22 >= 2)
      {
        v66 = (unsigned __int16 *)v65;
        v67 = (unsigned __int16 *)v63;
        v68 = (v62 >> 1);
        do
        {
          v69 = (*(v66 - 1) >> v15) - (*(v67 - 1) >> v15);
          v70 = *v66;
          v66 += 2;
          v71 = v70 >> v15;
          v72 = *v67;
          v67 += 2;
          v52 += (v69 * v69);
          v53 += (v71 - (v72 >> v15)) * (v71 - (v72 >> v15));
          --v68;
        }
        while (v68);
      }
      ++v61;
      v63 += v64;
      v65 += 2 * v57;
    }
    while (v61 != v23);
  }
LABEL_47:
  if (pixelBufferOut)
    CVPixelBufferRelease(pixelBufferOut);
  if (pixelTransferSessionOut)
    CFRelease(pixelTransferSessionOut);
  *a3 = (double)v36;
  a3[1] = (double)v52;
  a3[2] = (double)v53;
  return sub_1B67C3D28((uint64_t)&v93);
}

void sub_1B67BAE34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  const void *v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  va_list va1;
  va_list va2;

  va_start(va2, a10);
  va_start(va1, a10);
  va_start(va, a10);
  v11 = va_arg(va1, const void *);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v17 = va_arg(va2, const void *);
  sub_1B67705C8((const void **)va);
  sub_1B67705C8((const void **)va1);
  sub_1B67C3D28((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t *sub_1B67BAEA4(int *a1, int *a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t *v21;
  uint64_t v22;
  unsigned __int16 *v23;
  unsigned __int16 *v24;
  uint64_t v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t *result;
  int v48;
  char *v49;
  uint64_t *v50;
  uint64_t v51;
  unsigned __int16 *v52;
  unsigned __int16 *v53;
  uint64_t v54;
  uint64_t v55;
  unsigned __int16 *v56;
  unsigned __int16 *v57;
  uint64_t v58;
  int v59;
  int v60;
  int v61;
  int v62;
  uint64_t v63;
  _OWORD *v64;
  uint64_t i;
  _OWORD v66[4];
  uint64_t v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  v67 = 0;
  memset(v66, 0, sizeof(v66));
  v6 = (a2[69] - (a2[100] + a2[102]));
  v7 = a2[70] - (a2[101] + a2[103]);
  v8 = *((_QWORD *)a2 + 14);
  v9 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
  v10 = a2[100];
  v11 = a2[101];
  v12 = *((_QWORD *)a1 + 14);
  v13 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v14 = 0;
  v15 = v13 + 2 * a1[100];
  v16 = 2 * a1[101];
  v17 = v9 + 2 * v10;
  do
  {
    v18 = v7 * (int)v14 / 3;
    v19 = v14 + 1;
    v20 = v7 * ((int)v14 + 1) / 3;
    if (v18 < v20)
    {
      v21 = (uint64_t *)v66 + 3 * v14;
      v22 = v18;
      v23 = (unsigned __int16 *)(v15 + v12 * (v16 + 2 * v18));
      v24 = (unsigned __int16 *)(v17 + v8 * (2 * v11 + 2 * v18));
      do
      {
        if ((int)v6 >= 1)
        {
          v25 = *v21;
          v26 = v24;
          v27 = v23;
          v28 = v6;
          do
          {
            v30 = *v26++;
            v29 = v30;
            v31 = *v27++;
            v25 += ((v29 - v31) * (v29 - v31));
            --v28;
          }
          while (v28);
          *v21 = v25;
        }
        ++v22;
        v23 += v12;
        v24 += v8;
      }
      while (v22 != v20);
    }
    v14 = v19;
  }
  while (v19 != 3);
  if ((int)v6 >= 0)
    v32 = v6;
  else
    v32 = v6 + 1;
  v33 = (v32 >> 1);
  v34 = *((_QWORD *)a1 + 15);
  v35 = *((_QWORD *)a2 + 15);
  v36 = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a2 + 40))(a2, 1);
  v37 = a2[100];
  v38 = a2[101];
  v39 = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v40 = 0;
  v41 = v39 + 2 * a1[100] + 2;
  v42 = 2 * a1[101];
  v43 = v36 + 2 * v37 + 2;
  v44 = 2 * v38;
  do
  {
    v45 = v7 * (int)v40 / 3;
    v46 = v40 + 1;
    result = (uint64_t *)((unint64_t)(1431655766 * v7 * ((int)v40 + 1)) >> 32);
    v48 = v7 * ((int)v40 + 1) / 3;
    if (v45 < v48)
    {
      v49 = (char *)v66 + 24 * v40;
      result = (uint64_t *)(v49 + 8);
      v50 = (uint64_t *)(v49 + 16);
      v51 = v45;
      v52 = (unsigned __int16 *)(v41 + v34 * (v42 + 2 * v45));
      v53 = (unsigned __int16 *)(v43 + v35 * (v44 + 2 * v45));
      do
      {
        if ((int)v6 >= 2)
        {
          v54 = *result;
          v55 = *v50;
          v56 = v53;
          v57 = v52;
          v58 = v33;
          do
          {
            v59 = *(v56 - 1) - *(v57 - 1);
            v61 = *v56;
            v56 += 2;
            v60 = v61;
            v62 = *v57;
            v57 += 2;
            v54 += (v59 * v59);
            v55 += ((v60 - v62) * (v60 - v62));
            --v58;
          }
          while (v58);
          *result = v54;
          *v50 = v55;
        }
        ++v51;
        v52 += v34;
        v53 += v35;
      }
      while (v51 != v48);
    }
    v40 = v46;
  }
  while (v46 != 3);
  v63 = 0;
  v64 = v66;
  do
  {
    for (i = 0; i != 24; i += 8)
      *(double *)(a3 + i) = (double)(unint64_t)(3 * *(_QWORD *)((char *)v64 + i));
    ++v63;
    a3 += 24;
    v64 = (_OWORD *)((char *)v64 + 24);
  }
  while (v63 != 3);
  return result;
}

int *sub_1B67BB1F8(int *result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  int v10;
  uint64_t v11;
  int *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unint64_t v19;
  _DWORD *v20;

  v10 = (int)result;
  if (a5)
  {
    v11 = (a3 + (_DWORD)result - *(_DWORD *)(a6 + 276) / 2);
    if ((int)v11 >= 1)
    {
      v12 = (int *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a6 + 16))(a6, (*(_DWORD *)(a6 + 276) / 2 - 1), (a2 - 1), 1);
      v14 = *v12;
      result = v12 + 1;
      v13 = v14;
      do
      {
        *result++ = v13;
        --v11;
      }
      while (v11);
    }
  }
  if (a4)
  {
    v15 = *(_DWORD *)(a6 + 280);
    v16 = (a3 + a2 - v15);
    if ((int)v16 >= 1)
    {
      v17 = *(_QWORD *)(a6 + 120);
      result = (int *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a6 + 16))(a6, (v10 - 1), (v15 - 1), 1);
      v18 = *result;
      v19 = (2 * v17) & 0xFFFFFFFFFFFFFFFCLL;
      v20 = (int *)((char *)result + v19);
      do
      {
        *v20 = v18;
        v20 = (_DWORD *)((char *)v20 + v19);
        --v16;
      }
      while (v16);
    }
  }
  return result;
}

_DWORD *sub_1B67BB2DC(int a1, int a2, int a3, int a4, int a5, int a6, int *a7)
{
  uint64_t v14;
  uint64_t v15;
  _DWORD *result;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int16 v23;
  _WORD *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  _DWORD *v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  __int16 v42;
  _WORD *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  char *v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  _DWORD *v54;
  uint64_t v55;
  int v56;
  int v57;
  int v58;
  int v59;
  char *v60;
  char *v61;
  BOOL v62;
  int v63;
  char *v64;
  char *v65;
  uint64_t v66;
  int v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  _DWORD *v76;
  uint64_t v77;
  _DWORD *v78;
  uint64_t v79;
  uint64_t v80;
  int v81;

  v14 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a7 + 32))(a7, 0);
  v15 = *((_QWORD *)a7 + 14);
  result = (_DWORD *)(*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a7 + 32))(a7, 1);
  v79 = *((_QWORD *)a7 + 15);
  v17 = v79 >> 1;
  if (a1 <= 2)
  {
    if (a2 <= 3)
      v18 = 3;
    else
      v18 = a2;
    v19 = a7[70];
    LODWORD(v20) = a2 + a6 + 4;
    if ((int)v20 >= v19)
      v20 = v19;
    else
      v20 = v20;
    if ((int)v18 - 3 < (int)v20)
    {
      v21 = v18 - 3;
      v22 = v14 + 2 * v15 * v21 - 2;
      do
      {
        v23 = *(_WORD *)(v14 + 2 * v15 * v21);
        v24 = (_WORD *)v22;
        v25 = (3 - a1);
        do
        {
          *v24-- = v23;
          --v25;
        }
        while (v25);
        ++v21;
        v22 += 2 * v15;
      }
      while (v21 != v20);
    }
    if (a4 <= 1)
      v26 = 1;
    else
      v26 = a4;
    v27 = a4 + a6 + 2;
    if (v27 >= v19)
      v28 = v19;
    else
      v28 = a4 + a6 + 2;
    if ((int)v26 <= v28)
    {
      v29 = v26 - 1;
      v30 = (uint64_t)&result[v17 * v29 - 1];
      do
      {
        if (a3 <= 0)
        {
          v31 = result[v17 * v29];
          v32 = (_DWORD *)v30;
          v33 = (1 - a3) & ~((1 - a3) >> 31);
          do
          {
            *v32-- = v31;
            --v33;
          }
          while (v33);
          v19 = a7[70];
        }
        ++v29;
        if (v27 >= v19)
          v34 = v19;
        else
          v34 = a4 + a6 + 2;
        v30 += 4 * v17;
      }
      while (v29 < v34);
    }
  }
  v35 = a1 + a5 + 4;
  v36 = a7[69];
  if (v35 > (int)v36)
  {
    if (a2 <= 3)
      v37 = 3;
    else
      v37 = a2;
    v38 = a7[70];
    LODWORD(v39) = a2 + a6 + 4;
    if ((int)v39 >= v38)
      v39 = v38;
    else
      v39 = v39;
    if ((int)v37 - 3 < (int)v39)
    {
      v40 = v37 - 3;
      v41 = 2 * v15 * v40 + 2 * (v36 - 1) + v14 + 2;
      do
      {
        if (v35 != (_DWORD)v36)
        {
          v42 = *(_WORD *)(v14 + 2 * (v36 - 1 + v15 * v40));
          v43 = (_WORD *)v41;
          v44 = v35 - (int)v36;
          do
          {
            *v43++ = v42;
            --v44;
          }
          while (v44);
        }
        ++v40;
        v41 += 2 * v15;
      }
      while (v40 != v39);
    }
    if (a4 <= 1)
      v45 = 1;
    else
      v45 = a4;
    v46 = a4 + a6 + 2;
    if (v46 >= v38)
      v47 = v38;
    else
      v47 = a4 + a6 + 2;
    if ((int)v45 <= v47)
    {
      v48 = (int)v36 - 2;
      v49 = (char *)result + 2 * v48;
      v50 = a3 + (a5 >> 1) - ((int)v36 >> 1) + 2;
      v51 = v45 - 1;
      v52 = (uint64_t)&result[v17 * v51 + 1] + 2 * v48;
      do
      {
        if (v50 >= 1)
        {
          v53 = *(_DWORD *)&v49[4 * v17 * v51];
          v54 = (_DWORD *)v52;
          v55 = v50 & ~(v50 >> 31);
          do
          {
            *v54++ = v53;
            --v55;
          }
          while (v55);
          v38 = a7[70];
        }
        ++v51;
        if (v46 >= v38)
          v56 = v38;
        else
          v56 = a4 + a6 + 2;
        v52 += 4 * v17;
      }
      while (v51 < v56);
    }
  }
  v78 = result;
  v81 = a5;
  v57 = a6;
  v80 = v14 + 2 * a1;
  v58 = a2;
  if (a2 <= 2)
  {
    v59 = a2 - 3;
    v60 = (char *)(v80 - 6);
    do
    {
      v61 = &v60[-2 * v15];
      result = memcpy(v61, v60, 2 * (v81 + 7));
      v60 = v61;
      v62 = __CFADD__(v59++, 1);
    }
    while (!v62);
    if (a4 <= 0)
    {
      v63 = a4 - 1;
      v64 = (char *)&v78[a3 - 1];
      do
      {
        v65 = &v64[-2 * v79];
        result = memcpy(v65, v64, 2 * (int)((v81 & 0xFFFFFFFE) + 6));
        v64 = v65;
        v62 = __CFADD__(v63++, 1);
      }
      while (!v62);
    }
  }
  v66 = a7[70];
  if (a2 + v57 + 4 > (int)v66)
  {
    v67 = a4;
    v68 = v57 + v58 - v66 + 4;
    v69 = 2 * v15 * (v66 - 1);
    v70 = v80 - 6;
    v71 = 2 * v15;
    v72 = v15 * (2 * (v66 - 1) + 2);
    do
    {
      result = memcpy((void *)(v70 + v72), (const void *)(v70 + v69), 2 * (v81 + 7));
      v70 += v71;
      --v68;
    }
    while (v68);
    v73 = a7[70];
    if ((int)v73 < v67 + v57 + 2)
    {
      v74 = v57 + v67 - v73 + 2;
      v75 = 2 * v79 * (v73 - 1);
      v76 = &v78[a3 - 1];
      v77 = v79 * (2 * (v73 - 1) + 2);
      do
      {
        result = memcpy((char *)v76 + v77, (char *)v76 + v75, 2 * (int)((v81 & 0xFFFFFFFE) + 6));
        v76 = (_DWORD *)((char *)v76 + 2 * v79);
        --v74;
      }
      while (v74);
    }
  }
  return result;
}

uint64_t sub_1B67BB734(uint64_t a1, FILE *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a2)
    return 4294954394;
  v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  v5 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  v6 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v7 = *(int *)(a1 + 404);
  if ((int)v7 < (int)v5)
  {
    v8 = v6 + *(int *)(a1 + 400);
    do
      fwrite((const void *)(v8 + *(_QWORD *)(a1 + 112) * v7++), 1uLL, v4, a2);
    while (v7 < v5);
  }
  v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v10 = *(int *)(a1 + 404);
  if ((int)v10 < (int)v5)
  {
    v11 = v9 + *(int *)(a1 + 400);
    do
      fwrite((const void *)(v11 + *(_QWORD *)(a1 + 120) * v10++), 1uLL, v4 & 0x7FFFFFFFFFFFFFFFLL, a2);
    while (v10 < (int)v5);
  }
  return 0;
}

uint64_t sub_1B67BB840(uint64_t a1, FILE *a2)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;
  char *v26;
  uint64_t v27;
  char v28;
  uint64_t v30;
  uint64_t v31;

  if (!a2)
    return 4294954394;
  v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  v5 = *(_DWORD *)(a1 + 280);
  v6 = *(_DWORD *)(a1 + 412);
  v7 = v5 - (*(_DWORD *)(a1 + 404) + v6);
  v8 = v5 - v6;
  v9 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v10 = *(int *)(a1 + 404);
  if ((int)v10 < v8)
  {
    v11 = v9 + *(int *)(a1 + 400);
    do
      fwrite((const void *)(v11 + *(_QWORD *)(a1 + 112) * v10++), 1uLL, v4, a2);
    while (v10 < v8);
  }
  if (v4 >= 0)
    v12 = v4;
  else
    v12 = v4 + 1;
  if (v7 >= 0)
    v13 = v7;
  else
    v13 = v7 + 1;
  v14 = v13 >> 1;
  v15 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v30 = *(int *)(a1 + 400);
  v31 = v15;
  v16 = *(int *)(a1 + 404);
  v17 = *(_QWORD *)(a1 + 120);
  v18 = v14 * (uint64_t)(v12 >> 1);
  v19 = (char *)operator new[](2 * (int)v18, MEMORY[0x1E0DE4E10]);
  if (!v19)
    return 4294954392;
  v20 = v19;
  if ((v7 + 1) >= 3)
  {
    v21 = (uint64_t)v12 >> 1;
    v22 = v14;
    v23 = &v19[v18];
    v24 = v17 * v16 + 2 * v21 + v30 + v31 - 1;
    v25 = v19;
    do
    {
      if ((v4 + 1) >= 3)
      {
        v26 = (char *)v24;
        v27 = (uint64_t)v12 >> 1;
        do
        {
          v25[v27 - 1] = *(v26 - 1);
          v28 = *v26;
          v26 -= 2;
          v23[--v27] = v28;
        }
        while (v27);
      }
      v25 += v21;
      v23 += v21;
      v24 += v17;
      --v22;
    }
    while (v22);
  }
  fwrite(v19, 1uLL, 2 * (int)v18, a2);
  MEMORY[0x1BCC9811C](v20, 0x1000C8077774924);
  return 0;
}

uint64_t sub_1B67BBA28(uint64_t *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  uint64_t v4;
  char *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t i;
  char v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  char v27;
  char v28;
  char v29;
  uint64_t v30;
  char v31;
  BOOL v32;
  uint64_t v33;
  void *__p[3];
  CC_MD5_CTX c;
  char v37;
  CC_MD5_CTX v38;
  char v39;
  CC_MD5_CTX v40;
  char v41;
  uint64_t v42;

  v2 = a2;
  v42 = *MEMORY[0x1E0C80C00];
  memset(__p, 0, sizeof(__p));
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  v4 = *a1;
  if (*((_BYTE *)a1 + 136))
  {
    v5 = (char *)(*(uint64_t (**)(uint64_t *, _QWORD))(v4 + 56))(a1, 0);
    v6 = a1 + 22;
    v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, 1);
    v8 = a1 + 21;
  }
  else
  {
    v5 = (char *)(*(uint64_t (**)(uint64_t *, _QWORD))(v4 + 40))(a1, 0);
    v6 = a1 + 15;
    v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, 1);
    v8 = a1 + 14;
  }
  v9 = 0;
  v10 = *v6;
  v11 = *v8;
  do
  {
    *((_BYTE *)&c + v9 + 92) = 1;
    *((_BYTE *)&c + v9 + 92) = CC_MD5_Init((CC_MD5_CTX *)((char *)&c + v9)) != 0;
    v9 += 96;
  }
  while (v9 != 288);
  if (*((_DWORD *)a1 + 70))
  {
    for (i = 0; i < v14; ++i)
    {
      v13 = CC_MD5_Update(&c, v5, *((_DWORD *)a1 + 69));
      v37 &= v13;
      v5 += v11;
      v14 = *((_DWORD *)a1 + 70);
    }
    v15 = v14;
    if (!v7)
      goto LABEL_25;
LABEL_12:
    v16 = *((_DWORD *)a1 + 69);
    if (v16 >= 0)
      v17 = *((_DWORD *)a1 + 69);
    else
      v17 = v16 + 1;
    v18 = (v17 >> 1) * (uint64_t)v14;
    if ((_DWORD)v18)
    {
      sub_1B6773C90((unint64_t *)__p, 2 * (int)v18);
      v19 = (char *)__p[0];
    }
    else
    {
      v19 = 0;
    }
    v20 = &v19[v18];
    if (v14)
    {
      v21 = (uint64_t)v17 >> 1;
      v22 = v7 + 2 * v21 - 1;
      v23 = v19;
      v24 = &v19[v18];
      do
      {
        if ((v16 + 1) >= 3)
        {
          v25 = (char *)v22;
          v26 = (uint64_t)v17 >> 1;
          do
          {
            v23[v26 - 1] = *(v25 - 1);
            v27 = *v25;
            v25 -= 2;
            v24[--v26] = v27;
          }
          while (v26);
        }
        v23 += v21;
        v24 += v21;
        v22 += v10;
        --v15;
      }
      while (v15);
    }
    v28 = CC_MD5_Update(&v38, v19, v18);
    v39 &= v28;
    v29 = CC_MD5_Update(&v40, v20, v18);
    v41 &= v29;
    goto LABEL_25;
  }
  v14 = 0;
  v15 = 0;
  if (v7)
    goto LABEL_12;
LABEL_25:
  v30 = 0;
  while (1)
  {
    v31 = CC_MD5_Final(v2, (CC_MD5_CTX *)((char *)&c + v30));
    v32 = (v31 & *((_BYTE *)&c + v30 + 92)) == 0;
    *((_BYTE *)&c + v30 + 92) &= v31;
    if (v32)
      break;
    v30 += 96;
    v2 += 16;
    if (v30 == 288)
    {
      v33 = 0;
      goto LABEL_30;
    }
  }
  v33 = 4294954385;
LABEL_30:
  if (__p[0])
    operator delete(__p[0]);
  return v33;
}

void sub_1B67BBCE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B67BBD04(uint64_t a1, int *a2, uint64_t a3, int a4)
{
  __CVBuffer *v8;
  OSType PixelFormatType;
  int v10;
  int v11;
  uint64_t v12;
  __CVBuffer *v13;
  signed int v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  const __CFAllocator *v19;
  OSStatus v20;
  _BOOL4 v21;
  uint64x2_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int8 *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const __CFDictionary *DescriptionWithPixelFormatType;
  const void *Value;
  CVReturn v33;
  NSObject *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  unsigned __int8 *v38;
  unsigned __int8 *v39;
  unsigned __int8 *v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  unsigned __int8 *v46;
  unsigned __int8 *v47;
  unsigned __int8 *v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unsigned __int8 *v61;
  unsigned __int8 *v62;
  uint32x2_t v63;
  unsigned __int8 *v64;
  unsigned __int8 *v65;
  uint64_t v66;
  uint32x2_t v67;
  uint32x2_t v68;
  int32x2_t v69;
  OSStatus v71;
  uint32_t v72;
  size_t Height;
  size_t Width;
  int v75;
  int v76;
  uint64_t v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  uint64_t v83;
  uint64x2_t v84;
  CFMutableDictionaryRef Mutable;
  VTPixelTransferSessionRef pixelTransferSessionOut;
  CVPixelBufferRef pixelBufferOut;
  uint8_t buf[4];
  CVReturn v89;
  CFMutableDictionaryRef theDict;
  uint64_t (**v91)();
  int v92;
  int v93;
  uint64_t v94;
  __int16 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  char v100;
  uint64_t v101;
  __int16 v102;
  char v103;
  char v104;
  __int128 v105;
  __int128 v106;
  uint64_t v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  uint64_t v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  uint64_t v118;
  __int128 v119;
  int v120;
  uint64_t (***v121)();
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  _BYTE v126[21];
  __int128 v127;
  __int128 v128;
  uint64_t v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  uint64_t v133;
  uint64_t v134;
  __int128 v135;
  __int128 v136;
  uint64_t v137;
  uint64_t v138;
  int v139;
  uint64_t v140;
  char v141;
  uint64_t v142;

  v142 = *MEMORY[0x1E0C80C00];
  v92 = 0;
  v93 = 0;
  v100 = 1;
  v108 = 0u;
  v109 = 0u;
  v119 = 0u;
  v101 = 0;
  v102 = 0;
  v112 = 0u;
  v113 = 0u;
  v116 = 0u;
  v117 = 0u;
  v121 = &v91;
  memset(v126, 0, sizeof(v126));
  v125 = 0u;
  v124 = 0u;
  v123 = 0u;
  v122 = 0u;
  v128 = 0u;
  v127 = 0u;
  v129 = 850045863;
  v130 = 0u;
  v131 = 0u;
  v132 = 0u;
  v133 = 0;
  v134 = 1018212795;
  v135 = 0u;
  v136 = 0u;
  v137 = 0;
  v118 = 0;
  v95 = 0;
  v120 = 0;
  v94 = 0;
  v103 = 0;
  v104 = 0;
  v105 = 0u;
  v99 = 0u;
  v106 = 0u;
  v107 = 0;
  v110 = 0u;
  v111 = 0;
  v114 = 0u;
  v115 = 0u;
  v96 = 0u;
  v97 = 0u;
  v98 = 0u;
  v91 = &off_1E6A15040;
  v138 = 0;
  v139 = 0;
  v140 = 0;
  v141 = 0;
  pixelTransferSessionOut = 0;
  pixelBufferOut = 0;
  v8 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  PixelFormatType = CVPixelBufferGetPixelFormatType(v8);
  v10 = a2[69];
  v81 = a2[102];
  v82 = a2[100];
  v11 = a2[70];
  v79 = a2[103];
  v80 = a2[101];
  v12 = *((_QWORD *)a2 + 14);
  v13 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  v14 = CVPixelBufferGetPixelFormatType(v13);
  v15 = 0;
  v78 = v11;
  if (v14 <= 2016687155)
  {
    if (v14 != 1278226736)
    {
      v16 = 2016686640;
LABEL_7:
      if (v14 != v16)
        goto LABEL_9;
    }
  }
  else if (v14 != 2016687156 && v14 != 2019963956)
  {
    v16 = 2019963440;
    goto LABEL_7;
  }
  v15 = 8 - sub_1B67C37F4(v14);
LABEL_9:
  v77 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
  v17 = a2[100];
  v18 = a2[101];
  if (CVIsCompressedPixelFormatAvailable(PixelFormatType))
  {
    v75 = v10;
    v76 = a4;
    v19 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v20 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &pixelTransferSessionOut);
    if (v20)
    {
      v21 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      v22 = 0uLL;
      if (v21)
      {
        LODWORD(theDict) = 67109120;
        HIDWORD(theDict) = v20;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate for PSNR calculation failed with error: %d\n", (uint8_t *)&theDict, 8u);
        v22 = 0uLL;
      }
      v23 = 0;
      goto LABEL_63;
    }
    Width = CVPixelBufferGetWidth(v8);
    Height = CVPixelBufferGetHeight(v8);
    theDict = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E0CA8FF0], Mutable);
    v30 = a3;
    DescriptionWithPixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
    Value = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E0CA9120]);
    if (sub_1B67C37F4(PixelFormatType) != 8 || !CFEqual(Value, (CFTypeRef)*MEMORY[0x1E0CA9130]))
    {
      a3 = v30;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        v34 = MEMORY[0x1E0C81028];
        v35 = "Bit depth of source pixel buffer is not 8 or source pixel buffer is not video range for PSNR calculation";
        v72 = 2;
        goto LABEL_74;
      }
      goto LABEL_35;
    }
    v33 = CVPixelBufferCreate(v19, Width, Height, 0x34323076u, theDict, &pixelBufferOut);
    a3 = v30;
    if (v33)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        v89 = v33;
        v34 = MEMORY[0x1E0C81028];
        v35 = "CVPixelBufferCreate for PSNR calculation failed with error: %d\n";
LABEL_71:
        v72 = 8;
LABEL_74:
        _os_log_error_impl(&dword_1B676B000, v34, OS_LOG_TYPE_ERROR, v35, buf, v72);
        goto LABEL_35;
      }
      goto LABEL_35;
    }
    v71 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v8, pixelBufferOut);
    if (v71)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        v89 = v71;
        v34 = MEMORY[0x1E0C81028];
        v35 = "Pixel transfer from compressed to linear format for PSNR calculation failed with error: %d\n";
        goto LABEL_71;
      }
LABEL_35:
      sub_1B67705C8((const void **)&Mutable);
      sub_1B67705C8((const void **)&theDict);
LABEL_46:
      v23 = 0;
      v22 = 0uLL;
      goto LABEL_63;
    }
    CVPixelBufferGetPixelFormatType(pixelBufferOut);
    sub_1B67C28B8((uint64_t)&v91, pixelBufferOut, 0);
    sub_1B67705C8((const void **)&Mutable);
    sub_1B67705C8((const void **)&theDict);
    a3 = v30;
    v10 = v75;
    a4 = v76;
  }
  else
  {
    sub_1B67C28B8((uint64_t)&v91, v8, 0);
  }
  v24 = (v10 - (v82 + v81));
  v25 = (v78 - (v80 + v79));
  v26 = (unsigned __int8 *)(v77 + v17 + v12 * v18);
  v27 = v96;
  if (a4)
  {
    v28 = *((_QWORD *)&v98 + 1);
    if ((_QWORD)v96 || !sub_1B67C3B94((uint64_t)&v91))
      v29 = v97;
    else
      v29 = 0;
    if ((int)v25 < 1)
      goto LABEL_46;
    v45 = 0;
    v23 = 0;
    v46 = (unsigned __int8 *)(v29 + (int)v105 + v28 * SDWORD1(v105));
    do
    {
      if ((int)v24 >= 1)
      {
        v47 = v26;
        v48 = v46;
        v49 = v24;
        do
        {
          v51 = *v47++;
          v50 = v51;
          v52 = *v48++;
          v23 += ((v50 - v52) * (v50 - v52));
          --v49;
        }
        while (v49);
      }
      ++v45;
      v46 += v28;
      v26 += v12;
    }
    while (v45 != v25);
    goto LABEL_44;
  }
  v36 = *((_QWORD *)&v97 + 1);
  if (!(_QWORD)v96)
  {
    if (sub_1B67C3B94((uint64_t)&v91))
      v27 = 0;
    else
      v27 = v96;
  }
  if ((int)v25 >= 1)
  {
    v37 = 0;
    v23 = 0;
    v38 = (unsigned __int8 *)(v27 + (int)v105 + v36 * SDWORD1(v105));
    do
    {
      if ((int)v24 >= 1)
      {
        v39 = v26;
        v40 = v38;
        v41 = v24;
        do
        {
          v43 = *v39++;
          v42 = v43;
          v44 = *v40++;
          v23 += ((v42 >> v15) - (v44 >> v15)) * ((v42 >> v15) - (v44 >> v15));
          --v41;
        }
        while (v41);
      }
      ++v37;
      v38 += v36;
      v26 += v12;
    }
    while (v37 != v25);
LABEL_44:
    v22 = 0uLL;
    if ((a4 & 1) != 0)
      goto LABEL_63;
    goto LABEL_48;
  }
  v23 = 0;
LABEL_48:
  v83 = a3;
  if ((int)v24 >= 0)
    v53 = v24;
  else
    v53 = v24 + 1;
  v54 = v98;
  v55 = *((_QWORD *)a2 + 15);
  v56 = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a2 + 40))(a2, 1);
  v57 = a2[100];
  v58 = a2[101];
  if ((_QWORD)v96 || !sub_1B67C3B94((uint64_t)&v91))
    v59 = *((_QWORD *)&v96 + 1);
  else
    v59 = 0;
  if ((int)v25 < 1)
  {
    v22 = 0uLL;
    a3 = v83;
  }
  else
  {
    v60 = 0;
    v61 = (unsigned __int8 *)(v56 + v57 + v55 * v58);
    v62 = (unsigned __int8 *)(v59 + (int)v105 + v54 * SDWORD1(v105));
    v22 = 0uLL;
    v63 = (uint32x2_t)vneg_s32(vdup_n_s32(v15));
    a3 = v83;
    do
    {
      if ((int)v24 >= 2)
      {
        v64 = v61;
        v65 = v62;
        v66 = (v53 >> 1);
        do
        {
          v67.i32[0] = *v64;
          v67.i32[1] = v64[1];
          v68.i32[0] = *v65;
          v68.i32[1] = v65[1];
          v69 = vsub_s32((int32x2_t)vshl_u32(v67, v63), (int32x2_t)vshl_u32(v68, v63));
          v22 = vaddw_u32(v22, (uint32x2_t)vmul_s32(v69, v69));
          v65 += 2;
          v64 += 2;
          --v66;
        }
        while (v66);
      }
      ++v60;
      v62 += v54;
      v61 += v55;
    }
    while (v60 != v25);
  }
LABEL_63:
  v84 = v22;
  if (pixelBufferOut)
    CVPixelBufferRelease(pixelBufferOut);
  if (pixelTransferSessionOut)
    CFRelease(pixelTransferSessionOut);
  *(double *)a3 = (double)v23;
  *(float64x2_t *)(a3 + 8) = vcvtq_f64_u64(v84);
  return sub_1B67C3D28((uint64_t)&v91);
}

void sub_1B67BC4F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  const void *v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  va_list va1;
  va_list va2;

  va_start(va2, a10);
  va_start(va1, a10);
  va_start(va, a10);
  v11 = va_arg(va1, const void *);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v17 = va_arg(va2, const void *);
  sub_1B67705C8((const void **)va);
  sub_1B67705C8((const void **)va1);
  sub_1B67C3D28((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_1B67BC560(int *a1, int *a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  uint64_t v24;
  unsigned __int8 *v25;
  unsigned __int8 *v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t result;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  int v44;
  uint64x2_t *v45;
  uint64_t v46;
  unsigned __int8 *v47;
  uint64x2_t v48;
  unsigned __int8 *v49;
  unsigned __int8 *v50;
  uint64_t v51;
  int32x2_t v52;
  int32x2_t v53;
  int32x2_t v54;
  uint64_t v55;
  _OWORD *v56;
  uint64_t i;
  _OWORD v58[4];
  uint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v59 = 0;
  memset(v58, 0, sizeof(v58));
  v6 = (a2[69] - (a2[100] + a2[102]));
  v7 = a2[70] - (a2[101] + a2[103]);
  v8 = *((_QWORD *)a2 + 14);
  v9 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
  v10 = a2[100];
  v11 = a2[101];
  v12 = *((_QWORD *)a1 + 14);
  v13 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v14 = 0;
  v15 = v13 + a1[100];
  v16 = a1[101];
  do
  {
    v17 = v7 * (int)v14 / 3;
    v18 = v14 + 1;
    v19 = v7 * ((int)v14 + 1) / 3;
    if (v17 < v19)
    {
      v20 = (uint64_t *)v58 + 3 * v14;
      v21 = v17;
      v22 = (unsigned __int8 *)(v15 + v12 * (v16 + v17));
      v23 = (unsigned __int8 *)(v9 + v10 + v8 * (v11 + v17));
      do
      {
        if ((int)v6 >= 1)
        {
          v24 = *v20;
          v25 = v23;
          v26 = v22;
          v27 = v6;
          do
          {
            v29 = *v25++;
            v28 = v29;
            v30 = *v26++;
            v24 += ((v28 - v30) * (v28 - v30));
            --v27;
          }
          while (v27);
          *v20 = v24;
        }
        ++v21;
        v22 += v12;
        v23 += v8;
      }
      while (v21 != v19);
    }
    v14 = v18;
  }
  while (v18 != 3);
  if ((int)v6 >= 0)
    v31 = v6;
  else
    v31 = v6 + 1;
  v32 = (v31 >> 1);
  v33 = *((_QWORD *)a1 + 15);
  v34 = *((_QWORD *)a2 + 15);
  v35 = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a2 + 40))(a2, 1);
  v36 = a2[100];
  v37 = a2[101];
  result = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v39 = 0;
  v40 = result + a1[100];
  v41 = a1[101];
  do
  {
    v42 = v7 * (int)v39 / 3;
    v43 = v39 + 1;
    v44 = v7 * ((int)v39 + 1) / 3;
    if (v42 < v44)
    {
      v45 = (uint64x2_t *)((char *)v58 + 24 * v39 + 8);
      v46 = v42;
      result = v40 + v33 * (v41 + v42);
      v47 = (unsigned __int8 *)(v35 + v36 + v34 * (v37 + v42));
      do
      {
        if ((int)v6 >= 2)
        {
          v48 = *v45;
          v49 = v47;
          v50 = (unsigned __int8 *)result;
          v51 = v32;
          do
          {
            v52.i32[0] = *v49;
            v52.i32[1] = v49[1];
            v53.i32[0] = *v50;
            v53.i32[1] = v50[1];
            v54 = vsub_s32(v52, v53);
            v48 = vaddw_u32(v48, (uint32x2_t)vmul_s32(v54, v54));
            v50 += 2;
            v49 += 2;
            --v51;
          }
          while (v51);
          *v45 = v48;
        }
        ++v46;
        result += v33;
        v47 += v34;
      }
      while (v46 != v44);
    }
    v39 = v43;
  }
  while (v43 != 3);
  v55 = 0;
  v56 = v58;
  do
  {
    for (i = 0; i != 24; i += 8)
      *(double *)(a3 + i) = (double)(unint64_t)(3 * *(_QWORD *)((char *)v56 + i));
    ++v55;
    a3 += 24;
    v56 = (_OWORD *)((char *)v56 + 24);
  }
  while (v55 != 3);
  return result;
}

__int16 *sub_1B67BC88C(__int16 *result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  int v10;
  uint64_t v11;
  __int16 *v12;
  __int16 v13;
  __int16 v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  __int16 v18;
  _WORD *v19;

  v10 = (int)result;
  if (a5)
  {
    v11 = (a3 + (_DWORD)result - *(_DWORD *)(a6 + 276) / 2);
    if ((int)v11 >= 1)
    {
      v12 = (__int16 *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a6 + 16))(a6, (*(_DWORD *)(a6 + 276) / 2 - 1), (a2 - 1), 1);
      v14 = *v12;
      result = v12 + 1;
      v13 = v14;
      do
      {
        *result++ = v13;
        --v11;
      }
      while (v11);
    }
  }
  if (a4)
  {
    v15 = *(_DWORD *)(a6 + 280);
    v16 = (a3 + a2 - v15);
    if ((int)v16 >= 1)
    {
      v17 = *(_QWORD *)(a6 + 120);
      result = (__int16 *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a6 + 16))(a6, (v10 - 1), (v15 - 1), 1);
      v18 = *result;
      v19 = (__int16 *)((char *)result + (v17 & 0xFFFFFFFFFFFFFFFELL));
      do
      {
        *v19 = v18;
        v19 = (_WORD *)((char *)v19 + (v17 & 0xFFFFFFFFFFFFFFFELL));
        --v16;
      }
      while (v16);
    }
  }
  return result;
}

uint64_t sub_1B67BC96C(int a1, int a2, int a3, int a4, int a5, int a6, _QWORD *a7)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  size_t v23;
  uint64_t v24;
  unsigned __int8 *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  __int16 v32;
  _WORD *v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  size_t v43;
  char *v44;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  __int16 v54;
  _WORD *v55;
  uint64_t v56;
  int v57;
  char *v58;
  char *v59;
  BOOL v60;
  int v61;
  char *v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  int v80;

  v12 = (*(uint64_t (**)(_QWORD *, _QWORD))(*a7 + 32))(a7, 0);
  v13 = a7[14];
  result = (*(uint64_t (**)(_QWORD *, uint64_t))(*a7 + 32))(a7, 1);
  v15 = result;
  v16 = a7[15];
  v17 = v16;
  v80 = a6;
  v77 = result;
  if (a1 <= 2)
  {
    v78 = v12;
    if (a2 <= 3)
      v18 = 3;
    else
      v18 = a2;
    v19 = a2 + a6 + 4;
    LODWORD(v20) = *((_DWORD *)a7 + 70);
    if (v19 >= (int)v20)
      v21 = *((_DWORD *)a7 + 70);
    else
      v21 = a2 + a6 + 4;
    if ((int)v18 - 3 < v21)
    {
      v22 = a1;
      v23 = (3 - a1);
      v24 = v18 - 3;
      v75 = v22;
      v25 = (unsigned __int8 *)(v78 + v13 * (v18 - 3));
      v26 = v22 - 3;
      do
      {
        result = (uint64_t)memset(&v25[v26], *v25, v23);
        LODWORD(v20) = *((_DWORD *)a7 + 70);
        ++v24;
        if (v19 >= (int)v20)
          v27 = *((_DWORD *)a7 + 70);
        else
          v27 = v19;
        v25 += v13;
      }
      while (v24 < v27);
      v17 = a7[15];
      a6 = v80;
      a1 = v75;
      v15 = v77;
    }
    if (a4 <= 1)
      v28 = 1;
    else
      v28 = a4;
    v29 = a4 + a6 + 2;
    if (v29 >= (int)v20)
      v20 = v20;
    else
      v20 = v29;
    if ((int)v28 <= (int)v20)
    {
      v30 = v28 - 1;
      v31 = v15 + 2 * (v17 >> 1) * v30 - 2;
      v12 = v78;
      do
      {
        if (a3 <= 0)
        {
          v32 = *(_WORD *)(v15 + 2 * (v17 >> 1) * v30);
          v33 = (_WORD *)v31;
          v34 = (1 - a3) & ~((1 - a3) >> 31);
          do
          {
            *v33-- = v32;
            --v34;
          }
          while (v34);
        }
        ++v30;
        v31 += 2 * (v17 >> 1);
      }
      while (v30 != v20);
    }
    else
    {
      v12 = v78;
    }
  }
  v35 = a1 + a5 + 4;
  v36 = *((_DWORD *)a7 + 69);
  v37 = v35 - v36;
  if (v35 > v36)
  {
    if (a2 <= 3)
      v38 = 3;
    else
      v38 = a2;
    v39 = a2 + a6 + 4;
    LODWORD(v40) = *((_DWORD *)a7 + 70);
    if (v39 >= (int)v40)
      v41 = *((_DWORD *)a7 + 70);
    else
      v41 = a2 + a6 + 4;
    if ((int)v38 - 3 < v41)
    {
      v76 = a1;
      v42 = v38 - 3;
      v43 = v37;
      v79 = v12;
      v44 = (char *)(v36 + v13 * (v38 - 3) + v12);
      do
      {
        result = (uint64_t)memset(v44, *(v44 - 1), v43);
        ++v42;
        LODWORD(v40) = *((_DWORD *)a7 + 70);
        if (v39 >= (int)v40)
          v45 = *((_DWORD *)a7 + 70);
        else
          v45 = v39;
        v44 += v13;
      }
      while (v42 < v45);
      v36 = *((_DWORD *)a7 + 69);
      v17 = a7[15];
      a6 = v80;
      a1 = v76;
      v12 = v79;
    }
    if (a4 <= 1)
      v46 = 1;
    else
      v46 = a4;
    v47 = a4 + a6 + 2;
    if (v47 >= (int)v40)
      v40 = v40;
    else
      v40 = v47;
    if ((int)v46 <= (int)v40)
    {
      v48 = v36 - 2;
      v49 = v15 + v48;
      v50 = v17 >> 1;
      v51 = a3 + (a5 >> 1) - (v36 >> 1) + 2;
      v52 = v46 - 1;
      v53 = v48 + 2 * v50 * v52 + v15 + 2;
      do
      {
        if (v51 >= 1)
        {
          v54 = *(_WORD *)(v49 + 2 * v50 * v52);
          v55 = (_WORD *)v53;
          result = v51 & ~(v51 >> 31);
          do
          {
            *v55++ = v54;
            --result;
          }
          while (result);
        }
        ++v52;
        v53 += 2 * v50;
      }
      while (v52 != v40);
    }
  }
  v56 = v12 + a1;
  if (a2 <= 2)
  {
    v57 = a2 - 3;
    v58 = (char *)(v56 - 3);
    do
    {
      v59 = &v58[-v13];
      result = (uint64_t)memcpy(&v58[-v13], v58, a5 + 7);
      v58 = v59;
      v60 = __CFADD__(v57++, 1);
    }
    while (!v60);
    if (a4 <= 0)
    {
      v61 = a4 - 1;
      v62 = (char *)(v77 + 2 * a3 - 2);
      do
      {
        v63 = &v62[-v16];
        result = (uint64_t)memcpy(&v62[-v16], v62, (int)((a5 & 0xFFFFFFFE) + 6));
        v62 = v63;
        v60 = __CFADD__(v61++, 1);
      }
      while (!v60);
    }
  }
  v64 = *((int *)a7 + 70);
  if (a2 + v80 + 4 > (int)v64)
  {
    v65 = v13 * (v64 - 1);
    v66 = v80 + a2 - v64 + 4;
    v67 = v56 - 3;
    v68 = v13 * v64;
    do
    {
      result = (uint64_t)memcpy((void *)(v67 + v68), (const void *)(v67 + v65), a5 + 7);
      v67 += v13;
      --v66;
    }
    while (v66);
    v69 = *((int *)a7 + 70);
    if ((int)v69 < a4 + v80 + 2)
    {
      v70 = v16 * (v69 - 1);
      v71 = 2 * a3 - 2;
      v72 = v80 + a4 - v69 + 2;
      v73 = v16 * v69;
      v74 = v77 + v71;
      do
      {
        result = (uint64_t)memcpy((void *)(v74 + v73), (const void *)(v74 + v70), (int)((a5 & 0xFFFFFFFE) + 6));
        v74 += v16;
        --v72;
      }
      while (v72);
    }
  }
  return result;
}

uint64_t sub_1B67BCDB4(uint64_t a1, FILE *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  size_t v14;
  uint64_t v15;

  if (!a2)
    return 4294954394;
  v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  v5 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  v6 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v7 = *(int *)(a1 + 404);
  if ((int)v7 < (int)v5)
  {
    v8 = v6 + 2 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v8 + 2 * *(_QWORD *)(a1 + 112) * v7++), 1uLL, 2 * v4, a2);
    while (v7 < v5);
  }
  v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v10 = *(_DWORD *)(a1 + 404) / 2;
  if ((int)v5 >= 0)
    v11 = v5;
  else
    v11 = v5 + 1;
  if (v10 < v11 >> 1)
  {
    v12 = v9 + 2 * *(int *)(a1 + 400);
    v13 = v11 >> 1;
    v14 = 2 * (v4 & 0x3FFFFFFFFFFFFFFFLL);
    v15 = v10;
    do
      fwrite((const void *)(v12 + 2 * *(_QWORD *)(a1 + 120) * v15++), 1uLL, v14, a2);
    while (v13 != (_DWORD)v15);
  }
  return 0;
}

uint64_t sub_1B67BCEE0(uint64_t a1, FILE *a2)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  size_t v20;
  size_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  __int16 *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v34;
  uint64_t v35;

  if (!a2)
    return 4294954394;
  v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  v5 = *(_DWORD *)(a1 + 280);
  v6 = *(_DWORD *)(a1 + 412);
  v7 = v5 - (*(_DWORD *)(a1 + 404) + v6);
  v8 = v5 - v6;
  v9 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v10 = *(int *)(a1 + 404);
  if ((int)v10 < v8)
  {
    v11 = v9 + 2 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v11 + 2 * *(_QWORD *)(a1 + 112) * v10++), 1uLL, 2 * v4, a2);
    while (v10 < v8);
  }
  if (v4 >= 0)
    v12 = v4;
  else
    v12 = v4 + 1;
  v13 = v12 >> 1;
  if (v7 >= 0)
    v14 = v7;
  else
    v14 = v7 + 1;
  v15 = v14 >> 1;
  v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v34 = *(int *)(a1 + 400);
  v35 = v16;
  v17 = *(_DWORD *)(a1 + 404);
  v18 = *(_QWORD *)(a1 + 120);
  v19 = 2 * v15 * v13;
  v20 = 2 * v19;
  if (v15 * v13 < 0)
    v21 = -1;
  else
    v21 = 2 * v19;
  v22 = (char *)operator new[](v21, MEMORY[0x1E0DE4E10]);
  if (!v22)
    return 4294954392;
  v23 = v22;
  if ((v7 + 1) >= 3)
  {
    v24 = v15;
    v25 = &v22[2 * v15 * v13];
    if (v17 >= 0)
      v26 = v17;
    else
      v26 = v17 + 1;
    v27 = 2 * v13;
    v28 = 2 * v18 * ((uint64_t)v26 >> 1) + 4 * v13 + 2 * v34 + v35 - 2;
    v29 = v22;
    do
    {
      if ((v4 + 1) >= 3)
      {
        v30 = (__int16 *)v28;
        v31 = v13 - 1;
        do
        {
          *(_WORD *)&v29[2 * v31] = *(v30 - 1);
          v32 = *v30;
          v30 -= 2;
          *(_WORD *)&v25[2 * v31--] = v32;
        }
        while (v31 != -1);
      }
      v25 += v27;
      v29 += v27;
      v28 += 2 * v18;
      --v24;
    }
    while (v24);
  }
  fwrite(v22, 1uLL, v20, a2);
  MEMORY[0x1BCC9811C](v23, 0x1000C80BDFB0063);
  return 0;
}

uint64_t sub_1B67BD0E8(uint64_t *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  uint64_t v4;
  char *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char v14;
  unint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  CC_LONG v22;
  void *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  __int16 *v30;
  uint64_t v31;
  __int16 v32;
  char v33;
  char v34;
  uint64_t v35;
  char v36;
  BOOL v37;
  uint64_t v38;
  void *data[3];
  CC_MD5_CTX c;
  char v42;
  CC_MD5_CTX v43;
  char v44;
  CC_MD5_CTX v45;
  char v46;
  uint64_t v47;

  v2 = a2;
  v47 = *MEMORY[0x1E0C80C00];
  memset(data, 0, sizeof(data));
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  v4 = *a1;
  if (*((_BYTE *)a1 + 136))
  {
    v5 = (char *)(*(uint64_t (**)(uint64_t *, _QWORD))(v4 + 56))(a1, 0);
    v6 = a1 + 22;
    v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, 1);
    v8 = a1 + 21;
  }
  else
  {
    v5 = (char *)(*(uint64_t (**)(uint64_t *, _QWORD))(v4 + 40))(a1, 0);
    v6 = a1 + 15;
    v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, 1);
    v8 = a1 + 14;
  }
  v9 = 0;
  v10 = *v6;
  v11 = *v8;
  do
  {
    *((_BYTE *)&c + v9 + 92) = 1;
    *((_BYTE *)&c + v9 + 92) = CC_MD5_Init((CC_MD5_CTX *)((char *)&c + v9)) != 0;
    v9 += 96;
  }
  while (v9 != 288);
  if (*((_DWORD *)a1 + 70))
  {
    v12 = 0;
    v13 = 2 * v11;
    do
    {
      v14 = CC_MD5_Update(&c, v5, 2 * *((_DWORD *)a1 + 69));
      v42 &= v14;
      ++v12;
      v15 = *((int *)a1 + 70);
      v5 += v13;
    }
    while (v12 < v15);
    if (v7)
    {
LABEL_10:
      v16 = *((_DWORD *)a1 + 69);
      if (v16 >= 0)
        v17 = *((_DWORD *)a1 + 69);
      else
        v17 = v16 + 1;
      v18 = v17 >> 1;
      if ((v15 & 0x80000000) == 0)
        v19 = v15;
      else
        v19 = v15 + 1;
      v20 = v19 >> 1;
      v21 = v18 * (v19 >> 1);
      v22 = 2 * v21;
      sub_1B67B8800((char **)data, 2 * v21);
      v23 = data[0];
      v24 = (char *)data[0] + 2 * v21;
      if ((v15 + 1) >= 3)
      {
        v25 = v20;
        v26 = 2 * v18;
        v27 = v7 + 4 * v18 - 2;
        v28 = (char *)data[0];
        v29 = v24;
        do
        {
          if ((v16 + 1) >= 3)
          {
            v30 = (__int16 *)v27;
            v31 = v18 - 1;
            do
            {
              *(_WORD *)&v28[2 * v31] = *(v30 - 1);
              v32 = *v30;
              v30 -= 2;
              *(_WORD *)&v29[2 * v31--] = v32;
            }
            while (v31 != -1);
          }
          v29 += v26;
          v28 += v26;
          v27 += 2 * v10;
          --v25;
        }
        while (v25);
      }
      v33 = CC_MD5_Update(&v43, v23, v22);
      v44 &= v33;
      v34 = CC_MD5_Update(&v45, v24, v22);
      v46 &= v34;
      goto LABEL_25;
    }
  }
  else
  {
    LODWORD(v15) = 0;
    if (v7)
      goto LABEL_10;
  }
  v23 = 0;
LABEL_25:
  v35 = 0;
  while (1)
  {
    v36 = CC_MD5_Final(v2, (CC_MD5_CTX *)((char *)&c + v35));
    v37 = (v36 & *((_BYTE *)&c + v35 + 92)) == 0;
    *((_BYTE *)&c + v35 + 92) &= v36;
    if (v37)
      break;
    v35 += 96;
    v2 += 16;
    if (v35 == 288)
    {
      v38 = 0;
      if (!v23)
        return v38;
      goto LABEL_31;
    }
  }
  v38 = 4294954385;
  if (!v23)
    return v38;
LABEL_31:
  operator delete(v23);
  return v38;
}

void sub_1B67BD3BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B67BD3F0(uint64_t a1, int *a2, double *a3, int a4)
{
  __CVBuffer *v8;
  OSType PixelFormatType;
  int v10;
  int v11;
  uint64_t v12;
  __CVBuffer *v13;
  signed int v14;
  char v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  const __CFAllocator *v19;
  OSStatus v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  double *v27;
  const __CFDictionary *DescriptionWithPixelFormatType;
  const void *Value;
  CVReturn v30;
  NSObject *v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unsigned __int16 *v37;
  unsigned __int16 *v38;
  uint64_t v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  unsigned __int16 *v45;
  unsigned __int16 *v46;
  uint64_t v47;
  int v48;
  int v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  int v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  int v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unsigned __int16 *v68;
  unsigned __int16 *v69;
  uint64_t v70;
  int v71;
  unsigned int v72;
  unsigned int v73;
  unsigned int v74;
  OSStatus v75;
  uint32_t v76;
  size_t Height;
  size_t Width;
  uint64_t v79;
  int v80;
  uint64_t v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  double *v89;
  CFMutableDictionaryRef Mutable;
  VTPixelTransferSessionRef pixelTransferSessionOut;
  CVPixelBufferRef pixelBufferOut;
  uint8_t v93[4];
  CVReturn v94;
  uint8_t buf[8];
  uint64_t (**v96)();
  int v97;
  int v98;
  uint64_t v99;
  __int16 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  char v105;
  uint64_t v106;
  __int16 v107;
  char v108;
  char v109;
  __int128 v110;
  __int128 v111;
  uint64_t v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  uint64_t v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  uint64_t v123;
  __int128 v124;
  int v125;
  uint64_t (***v126)();
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  _BYTE v131[21];
  __int128 v132;
  __int128 v133;
  uint64_t v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  uint64_t v138;
  uint64_t v139;
  __int128 v140;
  __int128 v141;
  uint64_t v142;
  uint64_t v143;
  int v144;
  uint64_t v145;
  char v146;
  uint64_t v147;

  v147 = *MEMORY[0x1E0C80C00];
  v97 = 0;
  v98 = 0;
  v105 = 1;
  v113 = 0u;
  v114 = 0u;
  v124 = 0u;
  v106 = 0;
  v107 = 0;
  v117 = 0u;
  v118 = 0u;
  v121 = 0u;
  v122 = 0u;
  v126 = &v96;
  memset(v131, 0, sizeof(v131));
  v130 = 0u;
  v129 = 0u;
  v128 = 0u;
  v127 = 0u;
  v133 = 0u;
  v132 = 0u;
  v134 = 850045863;
  v135 = 0u;
  v136 = 0u;
  v137 = 0u;
  v138 = 0;
  v139 = 1018212795;
  v140 = 0u;
  v141 = 0u;
  v142 = 0;
  v123 = 0;
  v100 = 0;
  v125 = 0;
  v99 = 0;
  v108 = 0;
  v109 = 0;
  v110 = 0u;
  v104 = 0u;
  v111 = 0u;
  v112 = 0;
  v115 = 0u;
  v116 = 0;
  v119 = 0u;
  v120 = 0u;
  v101 = 0u;
  v102 = 0u;
  v103 = 0u;
  v96 = &off_1E6A15040;
  v143 = 0;
  v144 = 0;
  v145 = 0;
  v146 = 0;
  pixelTransferSessionOut = 0;
  pixelBufferOut = 0;
  v8 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  PixelFormatType = CVPixelBufferGetPixelFormatType(v8);
  v10 = a2[69];
  v86 = a2[102];
  v88 = a2[100];
  v11 = a2[70];
  v83 = a2[103];
  v84 = a2[101];
  v12 = *((_QWORD *)a2 + 14);
  v13 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  v14 = CVPixelBufferGetPixelFormatType(v13);
  v15 = 0;
  v82 = v11;
  if (v14 <= 2016687155)
  {
    if (v14 != 1278226736)
    {
      v16 = 2016686640;
LABEL_7:
      if (v14 != v16)
        goto LABEL_9;
    }
  }
  else if (v14 != 2016687156 && v14 != 2019963956)
  {
    v16 = 2019963440;
    goto LABEL_7;
  }
  v15 = 16 - sub_1B67C37F4(v14);
LABEL_9:
  v81 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
  v17 = a2[100];
  v18 = a2[101];
  if (CVIsCompressedPixelFormatAvailable(PixelFormatType))
  {
    v79 = v12;
    v80 = a4;
    v19 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v20 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &pixelTransferSessionOut);
    if (v20)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v20;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate for PSNR calculation failed with error: %d\n", buf, 8u);
      }
      goto LABEL_45;
    }
    Width = CVPixelBufferGetWidth(v8);
    Height = CVPixelBufferGetHeight(v8);
    *(_QWORD *)buf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, (const void *)*MEMORY[0x1E0CA8FF0], Mutable);
    v27 = a3;
    DescriptionWithPixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
    Value = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E0CA9120]);
    if (sub_1B67C37F4(PixelFormatType) != 8 || !CFEqual(Value, (CFTypeRef)*MEMORY[0x1E0CA9130]))
    {
      a3 = v27;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v93 = 0;
        v31 = MEMORY[0x1E0C81028];
        v32 = "Bit depth of source pixel buffer is not 8 or source pixel buffer is not video range for PSNR calculation";
        v76 = 2;
        goto LABEL_83;
      }
      goto LABEL_34;
    }
    v30 = CVPixelBufferCreate(v19, Width, Height, 0x34323076u, *(CFDictionaryRef *)buf, &pixelBufferOut);
    a3 = v27;
    if (v30)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v93 = 67109120;
        v94 = v30;
        v31 = MEMORY[0x1E0C81028];
        v32 = "CVPixelBufferCreate for PSNR calculation failed with error: %d\n";
LABEL_80:
        v76 = 8;
LABEL_83:
        _os_log_error_impl(&dword_1B676B000, v31, OS_LOG_TYPE_ERROR, v32, v93, v76);
        goto LABEL_34;
      }
      goto LABEL_34;
    }
    v75 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v8, pixelBufferOut);
    if (v75)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v93 = 67109120;
        v94 = v75;
        v31 = MEMORY[0x1E0C81028];
        v32 = "Pixel transfer from compressed to linear format for PSNR calculation failed with error: %d\n";
        goto LABEL_80;
      }
LABEL_34:
      sub_1B67705C8((const void **)&Mutable);
      sub_1B67705C8((const void **)buf);
LABEL_45:
      v35 = 0;
      goto LABEL_46;
    }
    CVPixelBufferGetPixelFormatType(pixelBufferOut);
    sub_1B67C28B8((uint64_t)&v96, pixelBufferOut, 0);
    sub_1B67705C8((const void **)&Mutable);
    sub_1B67705C8((const void **)buf);
    a3 = v27;
    a4 = v80;
    v12 = v79;
  }
  else
  {
    sub_1B67C28B8((uint64_t)&v96, v8, 0);
  }
  v21 = (v10 - (v88 + v86));
  v22 = (v82 - (v84 + v83));
  v23 = v81 + 2 * v17 + 2 * v12 * v18;
  v24 = v101;
  if (a4)
  {
    v25 = *((_QWORD *)&v103 + 1);
    if ((_QWORD)v101 || !sub_1B67C3B94((uint64_t)&v96))
      v26 = v102;
    else
      v26 = 0;
    if ((int)v22 < 1)
      goto LABEL_45;
    v43 = 0;
    v35 = 0;
    v44 = v26 + 2 * (int)v110 + 2 * v25 * SDWORD1(v110);
    do
    {
      if ((int)v21 >= 1)
      {
        v45 = (unsigned __int16 *)v23;
        v46 = (unsigned __int16 *)v44;
        v47 = v21;
        do
        {
          v49 = *v45++;
          v48 = v49;
          v50 = *v46++;
          v35 += ((v48 - v50) * (v48 - v50));
          --v47;
        }
        while (v47);
      }
      ++v43;
      v44 += 2 * v25;
      v23 += 2 * v12;
    }
    while (v43 != v22);
  }
  else
  {
    v33 = *((_QWORD *)&v102 + 1);
    if (!(_QWORD)v101)
    {
      if (sub_1B67C3B94((uint64_t)&v96))
        v24 = 0;
      else
        v24 = v101;
    }
    if ((int)v22 < 1)
    {
      v89 = a3;
      v35 = 0;
      goto LABEL_53;
    }
    v34 = 0;
    v35 = 0;
    v36 = v24 + 2 * (int)v110 + 2 * v33 * SDWORD1(v110);
    do
    {
      if ((int)v21 >= 1)
      {
        v37 = (unsigned __int16 *)v23;
        v38 = (unsigned __int16 *)v36;
        v39 = v21;
        do
        {
          v41 = *v37++;
          v40 = v41;
          v42 = *v38++;
          v35 += ((v40 >> v15) - (v42 >> v15)) * ((v40 >> v15) - (v42 >> v15));
          --v39;
        }
        while (v39);
      }
      ++v34;
      v36 += 2 * v33;
      v23 += 2 * v12;
    }
    while (v34 != v22);
  }
  if ((a4 & 1) != 0)
  {
LABEL_46:
    v51 = 0;
    v52 = 0;
    goto LABEL_47;
  }
  v89 = a3;
LABEL_53:
  if ((int)v21 >= 0)
    v54 = v21;
  else
    v54 = v21 + 1;
  if ((int)v22 >= 0)
    v55 = v82 - (v84 + v83);
  else
    v55 = v22 + 1;
  v85 = v55;
  v87 = v54;
  v56 = v103;
  v57 = *((_QWORD *)a2 + 15);
  v58 = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a2 + 40))(a2, 1);
  v59 = a2[100];
  v60 = a2[101];
  if (v60 >= 0)
    v61 = a2[101];
  else
    v61 = v60 + 1;
  if ((_QWORD)v101 || !sub_1B67C3B94((uint64_t)&v96))
    v62 = *((_QWORD *)&v101 + 1);
  else
    v62 = 0;
  if ((SDWORD1(v110) & 0x80000000) == 0)
    v63 = DWORD1(v110);
  else
    v63 = DWORD1(v110) + 1;
  if ((int)v22 < 2)
  {
    v51 = 0;
    v52 = 0;
    a3 = v89;
  }
  else
  {
    v64 = 0;
    v52 = 0;
    v51 = 0;
    v65 = 2 * v56 * ((uint64_t)v63 >> 1) + 2 * (int)v110 + v62 + 2;
    v66 = 2 * v56;
    v67 = 2 * v57 * ((uint64_t)v61 >> 1) + 2 * v59 + v58 + 2;
    a3 = v89;
    do
    {
      if ((int)v21 >= 2)
      {
        v68 = (unsigned __int16 *)v67;
        v69 = (unsigned __int16 *)v65;
        v70 = (v87 >> 1);
        do
        {
          v71 = (*(v68 - 1) >> v15) - (*(v69 - 1) >> v15);
          v72 = *v68;
          v68 += 2;
          v73 = v72 >> v15;
          v74 = *v69;
          v69 += 2;
          v51 += (v71 * v71);
          v52 += (v73 - (v74 >> v15)) * (v73 - (v74 >> v15));
          --v70;
        }
        while (v70);
      }
      ++v64;
      v65 += v66;
      v67 += 2 * v57;
    }
    while (v64 != v85 >> 1);
  }
LABEL_47:
  if (pixelBufferOut)
    CVPixelBufferRelease(pixelBufferOut);
  if (pixelTransferSessionOut)
    CFRelease(pixelTransferSessionOut);
  *a3 = (double)v35;
  a3[1] = (double)v51;
  a3[2] = (double)v52;
  return sub_1B67C3D28((uint64_t)&v96);
}

void sub_1B67BDC38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  const void *v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  va_list va1;
  va_list va2;

  va_start(va2, a10);
  va_start(va1, a10);
  va_start(va, a10);
  v11 = va_arg(va1, const void *);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v17 = va_arg(va2, const void *);
  sub_1B67705C8((const void **)va);
  sub_1B67705C8((const void **)va1);
  sub_1B67C3D28((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t *sub_1B67BDCA8(int *a1, int *a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t *v21;
  uint64_t v22;
  unsigned __int16 *v23;
  unsigned __int16 *v24;
  uint64_t v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t *result;
  int v50;
  char *v51;
  uint64_t *v52;
  uint64_t v53;
  unsigned __int16 *v54;
  unsigned __int16 *v55;
  uint64_t v56;
  uint64_t v57;
  unsigned __int16 *v58;
  unsigned __int16 *v59;
  uint64_t v60;
  int v61;
  int v62;
  int v63;
  int v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t i;
  _OWORD v68[4];
  uint64_t v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v69 = 0;
  memset(v68, 0, sizeof(v68));
  v6 = (a2[69] - (a2[100] + a2[102]));
  v7 = a2[70] - (a2[101] + a2[103]);
  v8 = *((_QWORD *)a2 + 14);
  v9 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
  v10 = a2[100];
  v11 = a2[101];
  v12 = *((_QWORD *)a1 + 14);
  v13 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v14 = 0;
  v15 = v13 + 2 * a1[100];
  v16 = 2 * a1[101];
  v17 = v9 + 2 * v10;
  do
  {
    v18 = v7 * (int)v14 / 3;
    v19 = v14 + 1;
    v20 = v7 * ((int)v14 + 1) / 3;
    if (v18 < v20)
    {
      v21 = (uint64_t *)v68 + 3 * v14;
      v22 = v18;
      v23 = (unsigned __int16 *)(v15 + v12 * (v16 + 2 * v18));
      v24 = (unsigned __int16 *)(v17 + v8 * (2 * v11 + 2 * v18));
      do
      {
        if ((int)v6 >= 1)
        {
          v25 = *v21;
          v26 = v24;
          v27 = v23;
          v28 = v6;
          do
          {
            v30 = *v26++;
            v29 = v30;
            v31 = *v27++;
            v25 += ((v29 - v31) * (v29 - v31));
            --v28;
          }
          while (v28);
          *v21 = v25;
        }
        ++v22;
        v23 += v12;
        v24 += v8;
      }
      while (v22 != v20);
    }
    v14 = v19;
  }
  while (v19 != 3);
  if ((int)v6 >= 0)
    v32 = v6;
  else
    v32 = v6 + 1;
  v33 = (v32 >> 1);
  if (v7 >= 0)
    v34 = v7;
  else
    v34 = v7 + 1;
  v35 = v34 >> 1;
  v36 = *((_QWORD *)a1 + 15);
  v37 = *((_QWORD *)a2 + 15);
  v38 = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a2 + 40))(a2, 1);
  v39 = a2[100];
  v40 = a2[101] / 2;
  v41 = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v42 = 0;
  v43 = v41 + 2 * a1[100] + 2;
  v44 = 2 * (a1[101] / 2);
  v45 = v38 + 2 * v39 + 2;
  v46 = 2 * v40;
  do
  {
    v47 = v35 * (int)v42 / 3;
    v48 = v42 + 1;
    result = (uint64_t *)((unint64_t)(1431655766 * v35 * ((int)v42 + 1)) >> 32);
    v50 = v35 * ((int)v42 + 1) / 3;
    if (v47 < v50)
    {
      v51 = (char *)v68 + 24 * v42;
      result = (uint64_t *)(v51 + 8);
      v52 = (uint64_t *)(v51 + 16);
      v53 = v47;
      v54 = (unsigned __int16 *)(v43 + v36 * (v44 + 2 * v47));
      v55 = (unsigned __int16 *)(v45 + v37 * (v46 + 2 * v47));
      do
      {
        if ((int)v6 >= 2)
        {
          v56 = *result;
          v57 = *v52;
          v58 = v55;
          v59 = v54;
          v60 = v33;
          do
          {
            v61 = *(v58 - 1) - *(v59 - 1);
            v63 = *v58;
            v58 += 2;
            v62 = v63;
            v64 = *v59;
            v59 += 2;
            v56 += (v61 * v61);
            v57 += ((v62 - v64) * (v62 - v64));
            --v60;
          }
          while (v60);
          *result = v56;
          *v52 = v57;
        }
        ++v53;
        v54 += v36;
        v55 += v37;
      }
      while (v53 != v50);
    }
    v42 = v48;
  }
  while (v48 != 3);
  v65 = 0;
  v66 = v68;
  do
  {
    for (i = 0; i != 24; i += 8)
      *(double *)(a3 + i) = (double)(unint64_t)(3 * *(_QWORD *)((char *)v66 + i));
    ++v65;
    a3 += 24;
    v66 = (_OWORD *)((char *)v66 + 24);
  }
  while (v65 != 3);
  return result;
}

int *sub_1B67BE020(int *result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  int v10;
  uint64_t v11;
  int *v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unint64_t v18;
  _DWORD *v19;

  v10 = (int)result;
  if (a5)
  {
    v11 = (a3 + (_DWORD)result - *(_DWORD *)(a6 + 276) / 2);
    if ((int)v11 >= 1)
    {
      v12 = (int *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a6 + 16))(a6, (*(_DWORD *)(a6 + 276) / 2 - 1), (a2 - 1), 1);
      v14 = *v12;
      result = v12 + 1;
      v13 = v14;
      do
      {
        *result++ = v13;
        --v11;
      }
      while (v11);
    }
  }
  if (a4)
  {
    v15 = (a3 + a2 - *(_DWORD *)(a6 + 280) / 2);
    if ((int)v15 >= 1)
    {
      v16 = *(_QWORD *)(a6 + 120);
      result = (int *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a6 + 16))(a6, (v10 - 1), (*(_DWORD *)(a6 + 280) / 2 - 1), 1);
      v17 = *result;
      v18 = (2 * v16) & 0xFFFFFFFFFFFFFFFCLL;
      v19 = (int *)((char *)result + v18);
      do
      {
        *v19 = v17;
        v19 = (_DWORD *)((char *)v19 + v18);
        --v15;
      }
      while (v15);
    }
  }
  return result;
}

_DWORD *sub_1B67BE110(int a1, int a2, int a3, int a4, int a5, int a6, int *a7)
{
  uint64_t v14;
  uint64_t v15;
  _DWORD *result;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int16 v23;
  _WORD *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  _DWORD *v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  __int16 v42;
  _WORD *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  char *v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  _DWORD *v54;
  uint64_t v55;
  int v56;
  int v57;
  int v58;
  char *v59;
  char *v60;
  BOOL v61;
  int v62;
  char *v63;
  char *v64;
  uint64_t v65;
  int v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  uint64_t v74;
  _DWORD *v75;
  uint64_t v76;
  _DWORD *v77;
  uint64_t v78;
  uint64_t v79;
  int v80;

  v14 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a7 + 32))(a7, 0);
  v15 = *((_QWORD *)a7 + 14);
  result = (_DWORD *)(*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a7 + 32))(a7, 1);
  v78 = *((_QWORD *)a7 + 15);
  v17 = v78 >> 1;
  if (a1 <= 2)
  {
    if (a2 <= 3)
      v18 = 3;
    else
      v18 = a2;
    v19 = a7[70];
    LODWORD(v20) = a2 + a6 + 4;
    if ((int)v20 >= v19)
      v20 = v19;
    else
      v20 = v20;
    if ((int)v18 - 3 < (int)v20)
    {
      v21 = v18 - 3;
      v22 = v14 + 2 * v15 * v21 - 2;
      do
      {
        v23 = *(_WORD *)(v14 + 2 * v15 * v21);
        v24 = (_WORD *)v22;
        v25 = (3 - a1);
        do
        {
          *v24-- = v23;
          --v25;
        }
        while (v25);
        ++v21;
        v22 += 2 * v15;
      }
      while (v21 != v20);
    }
    if (a4 <= 1)
      v26 = 1;
    else
      v26 = a4;
    v27 = a4 + (a6 >> 1) + 2;
    v28 = v19 >> 1;
    if (v27 < v19 >> 1)
      v28 = a4 + (a6 >> 1) + 2;
    if ((int)v26 <= v28)
    {
      v29 = v26 - 1;
      v30 = (uint64_t)&result[v17 * v29 - 1];
      do
      {
        if (a3 <= 0)
        {
          v31 = result[v17 * v29];
          v32 = (_DWORD *)v30;
          v33 = (1 - a3) & ~((1 - a3) >> 31);
          do
          {
            *v32-- = v31;
            --v33;
          }
          while (v33);
          v19 = a7[70];
        }
        ++v29;
        v34 = v19 >> 1;
        if (v27 < v19 >> 1)
          v34 = a4 + (a6 >> 1) + 2;
        v30 += 4 * v17;
      }
      while (v29 < v34);
    }
  }
  v35 = a1 + a5 + 4;
  v36 = a7[69];
  if (v35 > (int)v36)
  {
    if (a2 <= 3)
      v37 = 3;
    else
      v37 = a2;
    v38 = a7[70];
    LODWORD(v39) = a2 + a6 + 4;
    if ((int)v39 >= v38)
      v39 = v38;
    else
      v39 = v39;
    if ((int)v37 - 3 < (int)v39)
    {
      v40 = v37 - 3;
      v41 = 2 * v15 * v40 + 2 * (v36 - 1) + v14 + 2;
      do
      {
        if (v35 != (_DWORD)v36)
        {
          v42 = *(_WORD *)(v14 + 2 * (v36 - 1 + v15 * v40));
          v43 = (_WORD *)v41;
          v44 = v35 - (int)v36;
          do
          {
            *v43++ = v42;
            --v44;
          }
          while (v44);
        }
        ++v40;
        v41 += 2 * v15;
      }
      while (v40 != v39);
    }
    if (a4 <= 1)
      v45 = 1;
    else
      v45 = a4;
    v46 = a4 + (a6 >> 1) + 2;
    v47 = v38 >> 1;
    if (v46 < v38 >> 1)
      v47 = a4 + (a6 >> 1) + 2;
    if ((int)v45 <= v47)
    {
      v48 = (int)v36 - 2;
      v49 = (char *)result + 2 * v48;
      v50 = a3 + (a5 >> 1) - ((int)v36 >> 1) + 2;
      v51 = v45 - 1;
      v52 = (uint64_t)&result[v17 * v51 + 1] + 2 * v48;
      do
      {
        if (v50 >= 1)
        {
          v53 = *(_DWORD *)&v49[4 * v17 * v51];
          v54 = (_DWORD *)v52;
          v55 = v50 & ~(v50 >> 31);
          do
          {
            *v54++ = v53;
            --v55;
          }
          while (v55);
          v38 = a7[70];
        }
        ++v51;
        v56 = v38 >> 1;
        if (v46 < v38 >> 1)
          v56 = a4 + (a6 >> 1) + 2;
        v52 += 4 * v17;
      }
      while (v51 < v56);
    }
  }
  v77 = result;
  v80 = a5;
  v79 = v14 + 2 * a1;
  v57 = a2;
  if (a2 <= 2)
  {
    v58 = a2 - 3;
    v59 = (char *)(v79 - 6);
    do
    {
      v60 = &v59[-2 * v15];
      result = memcpy(v60, v59, 2 * (v80 + 7));
      v59 = v60;
      v61 = __CFADD__(v58++, 1);
    }
    while (!v61);
    if (a4 <= 0)
    {
      v62 = a4 - 1;
      v63 = (char *)&v77[a3 - 1];
      do
      {
        v64 = &v63[-2 * v78];
        result = memcpy(v64, v63, 2 * (int)((v80 & 0xFFFFFFFE) + 6));
        v63 = v64;
        v61 = __CFADD__(v62++, 1);
      }
      while (!v61);
    }
  }
  v65 = a7[70];
  if (v57 + a6 + 4 > (int)v65)
  {
    v66 = a4;
    v67 = v65 - v57 - 4;
    v68 = 2 * v15 * (v65 - 1);
    v69 = v79 - 6;
    v70 = 2 * v15;
    v71 = v15 * (2 * (v65 - 1) + 2);
    do
    {
      result = memcpy((void *)(v69 + v71), (const void *)(v69 + v68), 2 * (v80 + 7));
      ++v67;
      v69 += v70;
    }
    while (a6 != v67);
    v72 = a7[70] >> 1;
    if (v72 < v66 + (a6 >> 1) + 2)
    {
      v73 = (a6 >> 1) + v66 - v72 + 2;
      v74 = 2 * v78 * (v72 - 1);
      v75 = &v77[a3 - 1];
      v76 = 2 * v78 * v72;
      do
      {
        result = memcpy((char *)v75 + v76, (char *)v75 + v74, 2 * (int)((v80 & 0xFFFFFFFE) + 6));
        v75 = (_DWORD *)((char *)v75 + 2 * v78);
        --v73;
      }
      while (v73);
    }
  }
  return result;
}

uint64_t sub_1B67BE580(uint64_t a1, FILE *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  size_t v14;
  uint64_t v15;

  if (!a2)
    return 4294954394;
  v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  v5 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  v6 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v7 = *(int *)(a1 + 404);
  if ((int)v7 < (int)v5)
  {
    v8 = v6 + *(int *)(a1 + 400);
    do
      fwrite((const void *)(v8 + *(_QWORD *)(a1 + 112) * v7++), 1uLL, v4, a2);
    while (v7 < v5);
  }
  v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v10 = *(_DWORD *)(a1 + 404) / 2;
  if ((int)v5 >= 0)
    v11 = v5;
  else
    v11 = v5 + 1;
  if (v10 < v11 >> 1)
  {
    v12 = v9 + *(int *)(a1 + 400);
    v13 = v11 >> 1;
    v14 = v4 & 0x7FFFFFFFFFFFFFFFLL;
    v15 = v10;
    do
      fwrite((const void *)(v12 + *(_QWORD *)(a1 + 120) * v15++), 1uLL, v14, a2);
    while (v13 != (_DWORD)v15);
  }
  return 0;
}

uint64_t sub_1B67BE6A4(uint64_t a1, FILE *a2)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  int v24;
  uint64_t v25;
  char *v26;
  char *v27;
  uint64_t v28;
  char v29;
  uint64_t v31;
  uint64_t v32;

  if (!a2)
    return 4294954394;
  v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  v5 = *(_DWORD *)(a1 + 280);
  v6 = *(_DWORD *)(a1 + 412);
  v7 = v5 - (*(_DWORD *)(a1 + 404) + v6);
  v8 = v5 - v6;
  v9 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v10 = *(int *)(a1 + 404);
  if ((int)v10 < v8)
  {
    v11 = v9 + *(int *)(a1 + 400);
    do
      fwrite((const void *)(v11 + *(_QWORD *)(a1 + 112) * v10++), 1uLL, v4, a2);
    while (v10 < v8);
  }
  if (v4 >= 0)
    v12 = v4;
  else
    v12 = v4 + 1;
  if (v7 >= 0)
    v13 = v7;
  else
    v13 = v7 + 1;
  v14 = v13 >> 1;
  v15 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v31 = *(int *)(a1 + 400);
  v32 = v15;
  v16 = *(_DWORD *)(a1 + 404);
  v17 = *(_QWORD *)(a1 + 120);
  v18 = v14 * (uint64_t)(v12 >> 1);
  v19 = (char *)operator new[](2 * (int)v18, MEMORY[0x1E0DE4E10]);
  if (!v19)
    return 4294954392;
  v20 = v19;
  if ((v7 + 1) >= 3)
  {
    v21 = (uint64_t)v12 >> 1;
    v22 = v14;
    v23 = &v19[v18];
    if (v16 >= 0)
      v24 = v16;
    else
      v24 = v16 + 1;
    v25 = v17 * ((uint64_t)v24 >> 1) + 2 * v21 + v31 + v32 - 1;
    v26 = v19;
    do
    {
      if ((v4 + 1) >= 3)
      {
        v27 = (char *)v25;
        v28 = (uint64_t)v12 >> 1;
        do
        {
          v26[v28 - 1] = *(v27 - 1);
          v29 = *v27;
          v27 -= 2;
          v23[--v28] = v29;
        }
        while (v28);
      }
      v26 += v21;
      v23 += v21;
      v25 += v17;
      --v22;
    }
    while (v22);
  }
  fwrite(v19, 1uLL, 2 * (int)v18, a2);
  MEMORY[0x1BCC9811C](v20, 0x1000C8077774924);
  return 0;
}

uint64_t sub_1B67BE898(uint64_t *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  uint64_t v4;
  char *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  unint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  uint64_t v28;
  char v29;
  char v30;
  char v31;
  uint64_t v32;
  char v33;
  BOOL v34;
  uint64_t v35;
  void *__p[3];
  CC_MD5_CTX c;
  char v39;
  CC_MD5_CTX v40;
  char v41;
  CC_MD5_CTX v42;
  char v43;
  uint64_t v44;

  v2 = a2;
  v44 = *MEMORY[0x1E0C80C00];
  memset(__p, 0, sizeof(__p));
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  v4 = *a1;
  if (*((_BYTE *)a1 + 136))
  {
    v5 = (char *)(*(uint64_t (**)(uint64_t *, _QWORD))(v4 + 56))(a1, 0);
    v6 = a1 + 22;
    v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, 1);
    v8 = a1 + 21;
  }
  else
  {
    v5 = (char *)(*(uint64_t (**)(uint64_t *, _QWORD))(v4 + 40))(a1, 0);
    v6 = a1 + 15;
    v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, 1);
    v8 = a1 + 14;
  }
  v9 = 0;
  v10 = *v6;
  v11 = *v8;
  do
  {
    *((_BYTE *)&c + v9 + 92) = 1;
    *((_BYTE *)&c + v9 + 92) = CC_MD5_Init((CC_MD5_CTX *)((char *)&c + v9)) != 0;
    v9 += 96;
  }
  while (v9 != 288);
  if (*((_DWORD *)a1 + 70))
  {
    v12 = 0;
    do
    {
      v13 = CC_MD5_Update(&c, v5, *((_DWORD *)a1 + 69));
      v39 &= v13;
      ++v12;
      v5 += v11;
      v14 = *((int *)a1 + 70);
    }
    while (v12 < v14);
    if (!v7)
      goto LABEL_28;
LABEL_12:
    v15 = *((_DWORD *)a1 + 69);
    if (v15 >= 0)
      v16 = *((_DWORD *)a1 + 69);
    else
      v16 = v15 + 1;
    if ((v14 & 0x80000000) == 0)
      v17 = v14;
    else
      v17 = v14 + 1;
    v18 = v17 >> 1;
    v19 = (v16 >> 1) * (uint64_t)(v17 >> 1);
    if ((_DWORD)v19)
    {
      sub_1B6773C90((unint64_t *)__p, 2 * (int)v19);
      v20 = (char *)__p[0];
    }
    else
    {
      v20 = 0;
    }
    v21 = &v20[v19];
    if ((v14 + 1) >= 3)
    {
      v22 = (uint64_t)v16 >> 1;
      v23 = v18;
      v24 = v7 + 2 * v22 - 1;
      v25 = v20;
      v26 = &v20[v19];
      do
      {
        if ((v15 + 1) >= 3)
        {
          v27 = (char *)v24;
          v28 = (uint64_t)v16 >> 1;
          do
          {
            v25[v28 - 1] = *(v27 - 1);
            v29 = *v27;
            v27 -= 2;
            v26[--v28] = v29;
          }
          while (v28);
        }
        v25 += v22;
        v26 += v22;
        v24 += v10;
        --v23;
      }
      while (v23);
    }
    v30 = CC_MD5_Update(&v40, v20, v19);
    v41 &= v30;
    v31 = CC_MD5_Update(&v42, v21, v19);
    v43 &= v31;
    goto LABEL_28;
  }
  LODWORD(v14) = 0;
  if (v7)
    goto LABEL_12;
LABEL_28:
  v32 = 0;
  while (1)
  {
    v33 = CC_MD5_Final(v2, (CC_MD5_CTX *)((char *)&c + v32));
    v34 = (v33 & *((_BYTE *)&c + v32 + 92)) == 0;
    *((_BYTE *)&c + v32 + 92) &= v33;
    if (v34)
      break;
    v32 += 96;
    v2 += 16;
    if (v32 == 288)
    {
      v35 = 0;
      goto LABEL_33;
    }
  }
  v35 = 4294954385;
LABEL_33:
  if (__p[0])
    operator delete(__p[0]);
  return v35;
}

void sub_1B67BEB60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B67BEB84(uint64_t a1, int *a2, uint64_t a3, int a4)
{
  __CVBuffer *v8;
  OSType PixelFormatType;
  int v10;
  int v11;
  uint64_t v12;
  __CVBuffer *v13;
  signed int v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  const __CFAllocator *v18;
  OSStatus v19;
  _BOOL4 v20;
  uint64x2_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int8 *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const __CFDictionary *DescriptionWithPixelFormatType;
  const void *Value;
  CVReturn v32;
  NSObject *v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int8 *v37;
  unsigned __int8 *v38;
  unsigned __int8 *v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  unsigned __int8 *v45;
  unsigned __int8 *v46;
  unsigned __int8 *v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint32x2_t v66;
  unsigned __int8 *v67;
  unsigned __int8 *v68;
  uint64_t v69;
  uint32x2_t v70;
  uint32x2_t v71;
  int32x2_t v72;
  OSStatus v74;
  uint32_t v75;
  size_t Height;
  size_t Width;
  int v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  uint64_t v87;
  uint64x2_t v88;
  CFMutableDictionaryRef Mutable;
  VTPixelTransferSessionRef pixelTransferSessionOut;
  CVPixelBufferRef pixelBufferOut;
  uint8_t buf[4];
  CVReturn v93;
  CFMutableDictionaryRef theDict;
  uint64_t (**v95)();
  int v96;
  int v97;
  uint64_t v98;
  __int16 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  char v104;
  uint64_t v105;
  __int16 v106;
  char v107;
  char v108;
  __int128 v109;
  __int128 v110;
  uint64_t v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  uint64_t v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  uint64_t v122;
  __int128 v123;
  int v124;
  uint64_t (***v125)();
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  _BYTE v130[21];
  __int128 v131;
  __int128 v132;
  uint64_t v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  uint64_t v137;
  uint64_t v138;
  __int128 v139;
  __int128 v140;
  uint64_t v141;
  uint64_t v142;
  int v143;
  uint64_t v144;
  char v145;
  uint64_t v146;

  v146 = *MEMORY[0x1E0C80C00];
  v96 = 0;
  v97 = 0;
  v104 = 1;
  v112 = 0u;
  v113 = 0u;
  v123 = 0u;
  v105 = 0;
  v106 = 0;
  v116 = 0u;
  v117 = 0u;
  v120 = 0u;
  v121 = 0u;
  v125 = &v95;
  memset(v130, 0, sizeof(v130));
  v129 = 0u;
  v128 = 0u;
  v127 = 0u;
  v126 = 0u;
  v132 = 0u;
  v131 = 0u;
  v133 = 850045863;
  v134 = 0u;
  v135 = 0u;
  v136 = 0u;
  v137 = 0;
  v138 = 1018212795;
  v139 = 0u;
  v140 = 0u;
  v141 = 0;
  v122 = 0;
  v99 = 0;
  v124 = 0;
  v98 = 0;
  v107 = 0;
  v108 = 0;
  v109 = 0u;
  v103 = 0u;
  v110 = 0u;
  v111 = 0;
  v114 = 0u;
  v115 = 0;
  v118 = 0u;
  v119 = 0u;
  v100 = 0u;
  v101 = 0u;
  v102 = 0u;
  v95 = &off_1E6A15040;
  v142 = 0;
  v143 = 0;
  v144 = 0;
  v145 = 0;
  pixelTransferSessionOut = 0;
  pixelBufferOut = 0;
  v8 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  PixelFormatType = CVPixelBufferGetPixelFormatType(v8);
  v10 = a2[69];
  v83 = a2[102];
  v84 = a2[100];
  v86 = a2[70];
  v82 = a2[101];
  v11 = a2[103];
  v12 = *((_QWORD *)a2 + 14);
  v13 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  v14 = CVPixelBufferGetPixelFormatType(v13);
  v15 = 0;
  if (v14 <= 2016687155)
  {
    if (v14 != 1278226736)
    {
      v16 = 2016686640;
LABEL_7:
      if (v14 != v16)
        goto LABEL_9;
    }
  }
  else if (v14 != 2016687156 && v14 != 2019963956)
  {
    v16 = 2019963440;
    goto LABEL_7;
  }
  v15 = 8 - sub_1B67C37F4(v14);
LABEL_9:
  v81 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
  v17 = a2[100];
  v80 = a2[101];
  if (CVIsCompressedPixelFormatAvailable(PixelFormatType))
  {
    v78 = v10;
    v79 = a4;
    v18 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v19 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &pixelTransferSessionOut);
    if (v19)
    {
      v20 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
      v21 = 0uLL;
      if (v20)
      {
        LODWORD(theDict) = 67109120;
        HIDWORD(theDict) = v19;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate for PSNR calculation failed with error: %d\n", (uint8_t *)&theDict, 8u);
        v21 = 0uLL;
      }
      v22 = 0;
      goto LABEL_72;
    }
    Width = CVPixelBufferGetWidth(v8);
    Height = CVPixelBufferGetHeight(v8);
    theDict = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E0CA8FF0], Mutable);
    v29 = a3;
    DescriptionWithPixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
    Value = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E0CA9120]);
    if (sub_1B67C37F4(PixelFormatType) != 8 || !CFEqual(Value, (CFTypeRef)*MEMORY[0x1E0CA9130]))
    {
      a3 = v29;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        v33 = MEMORY[0x1E0C81028];
        v34 = "Bit depth of source pixel buffer is not 8 or source pixel buffer is not video range for PSNR calculation";
        v75 = 2;
        goto LABEL_83;
      }
      goto LABEL_35;
    }
    v32 = CVPixelBufferCreate(v18, Width, Height, 0x34323076u, theDict, &pixelBufferOut);
    a3 = v29;
    if (v32)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        v93 = v32;
        v33 = MEMORY[0x1E0C81028];
        v34 = "CVPixelBufferCreate for PSNR calculation failed with error: %d\n";
LABEL_80:
        v75 = 8;
LABEL_83:
        _os_log_error_impl(&dword_1B676B000, v33, OS_LOG_TYPE_ERROR, v34, buf, v75);
        goto LABEL_35;
      }
      goto LABEL_35;
    }
    v74 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v8, pixelBufferOut);
    if (v74)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        v93 = v74;
        v33 = MEMORY[0x1E0C81028];
        v34 = "Pixel transfer from compressed to linear format for PSNR calculation failed with error: %d\n";
        goto LABEL_80;
      }
LABEL_35:
      sub_1B67705C8((const void **)&Mutable);
      sub_1B67705C8((const void **)&theDict);
LABEL_46:
      v22 = 0;
      v21 = 0uLL;
      goto LABEL_72;
    }
    CVPixelBufferGetPixelFormatType(pixelBufferOut);
    sub_1B67C28B8((uint64_t)&v95, pixelBufferOut, 0);
    sub_1B67705C8((const void **)&Mutable);
    sub_1B67705C8((const void **)&theDict);
    a3 = v29;
    v10 = v78;
    a4 = v79;
  }
  else
  {
    sub_1B67C28B8((uint64_t)&v95, v8, 0);
  }
  v23 = (v10 - (v84 + v83));
  v24 = (v86 - (v82 + v11));
  v25 = (unsigned __int8 *)(v81 + v17 + v12 * v80);
  v26 = v100;
  if (a4)
  {
    v27 = *((_QWORD *)&v102 + 1);
    if ((_QWORD)v100 || !sub_1B67C3B94((uint64_t)&v95))
      v28 = v101;
    else
      v28 = 0;
    if ((int)v24 < 1)
      goto LABEL_46;
    v44 = 0;
    v22 = 0;
    v45 = (unsigned __int8 *)(v28 + (int)v109 + v27 * SDWORD1(v109));
    do
    {
      if ((int)v23 >= 1)
      {
        v46 = v25;
        v47 = v45;
        v48 = v23;
        do
        {
          v50 = *v46++;
          v49 = v50;
          v51 = *v47++;
          v22 += ((v49 - v51) * (v49 - v51));
          --v48;
        }
        while (v48);
      }
      ++v44;
      v45 += v27;
      v25 += v12;
    }
    while (v44 != v24);
    goto LABEL_44;
  }
  v35 = *((_QWORD *)&v101 + 1);
  if (!(_QWORD)v100)
  {
    if (sub_1B67C3B94((uint64_t)&v95))
      v26 = 0;
    else
      v26 = v100;
  }
  if ((int)v24 >= 1)
  {
    v36 = 0;
    v22 = 0;
    v37 = (unsigned __int8 *)(v26 + (int)v109 + v35 * SDWORD1(v109));
    do
    {
      if ((int)v23 >= 1)
      {
        v38 = v25;
        v39 = v37;
        v40 = v23;
        do
        {
          v42 = *v38++;
          v41 = v42;
          v43 = *v39++;
          v22 += ((v41 >> v15) - (v43 >> v15)) * ((v41 >> v15) - (v43 >> v15));
          --v40;
        }
        while (v40);
      }
      ++v36;
      v37 += v35;
      v25 += v12;
    }
    while (v36 != v24);
LABEL_44:
    v21 = 0uLL;
    if ((a4 & 1) != 0)
      goto LABEL_72;
    goto LABEL_48;
  }
  v22 = 0;
LABEL_48:
  v87 = a3;
  if ((int)v23 >= 0)
    v52 = v23;
  else
    v52 = v23 + 1;
  v85 = v52;
  if ((int)v24 >= 0)
    v53 = v24;
  else
    v53 = v24 + 1;
  v54 = v102;
  v55 = *((_QWORD *)a2 + 15);
  v56 = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a2 + 40))(a2, 1);
  v57 = a2[100];
  v58 = a2[101];
  if (v58 >= 0)
    v59 = a2[101];
  else
    v59 = v58 + 1;
  if ((_QWORD)v100 || !sub_1B67C3B94((uint64_t)&v95))
    v60 = *((_QWORD *)&v100 + 1);
  else
    v60 = 0;
  if ((SDWORD1(v109) & 0x80000000) == 0)
    v61 = DWORD1(v109);
  else
    v61 = DWORD1(v109) + 1;
  v21 = 0uLL;
  if ((int)v24 < 2)
  {
    a3 = v87;
  }
  else
  {
    v62 = 0;
    v63 = (v53 >> 1);
    v64 = v56 + v57 + v55 * ((uint64_t)v59 >> 1);
    v65 = v60 + (int)v109 + v54 * ((uint64_t)v61 >> 1);
    v66 = (uint32x2_t)vneg_s32(vdup_n_s32(v15));
    a3 = v87;
    do
    {
      if ((int)v23 >= 2)
      {
        v67 = (unsigned __int8 *)v64;
        v68 = (unsigned __int8 *)v65;
        v69 = (v85 >> 1);
        do
        {
          v70.i32[0] = *v67;
          v70.i32[1] = v67[1];
          v71.i32[0] = *v68;
          v71.i32[1] = v68[1];
          v72 = vsub_s32((int32x2_t)vshl_u32(v70, v66), (int32x2_t)vshl_u32(v71, v66));
          v21 = vaddw_u32(v21, (uint32x2_t)vmul_s32(v72, v72));
          v68 += 2;
          v67 += 2;
          --v69;
        }
        while (v69);
      }
      ++v62;
      v65 += v54;
      v64 += v55;
    }
    while (v62 != v63);
  }
LABEL_72:
  v88 = v21;
  if (pixelBufferOut)
    CVPixelBufferRelease(pixelBufferOut);
  if (pixelTransferSessionOut)
    CFRelease(pixelTransferSessionOut);
  *(double *)a3 = (double)v22;
  *(float64x2_t *)(a3 + 8) = vcvtq_f64_u64(v88);
  return sub_1B67C3D28((uint64_t)&v95);
}

void sub_1B67BF39C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, const void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25,char a26)
{
  sub_1B67705C8(&a20);
  sub_1B67705C8(&a25);
  sub_1B67C3D28((uint64_t)&a26);
  _Unwind_Resume(a1);
}

uint64_t sub_1B67BF40C(int *a1, int *a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  uint64_t v24;
  unsigned __int8 *v25;
  unsigned __int8 *v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t result;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int v46;
  uint64x2_t *v47;
  uint64_t v48;
  unsigned __int8 *v49;
  uint64x2_t v50;
  unsigned __int8 *v51;
  unsigned __int8 *v52;
  uint64_t v53;
  int32x2_t v54;
  int32x2_t v55;
  int32x2_t v56;
  uint64_t v57;
  _OWORD *v58;
  uint64_t i;
  _OWORD v60[4];
  uint64_t v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v61 = 0;
  memset(v60, 0, sizeof(v60));
  v6 = (a2[69] - (a2[100] + a2[102]));
  v7 = a2[70] - (a2[101] + a2[103]);
  v8 = *((_QWORD *)a2 + 14);
  v9 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
  v10 = a2[100];
  v11 = a2[101];
  v12 = *((_QWORD *)a1 + 14);
  v13 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v14 = 0;
  v15 = v13 + a1[100];
  v16 = a1[101];
  do
  {
    v17 = v7 * (int)v14 / 3;
    v18 = v14 + 1;
    v19 = v7 * ((int)v14 + 1) / 3;
    if (v17 < v19)
    {
      v20 = (uint64_t *)v60 + 3 * v14;
      v21 = v17;
      v22 = (unsigned __int8 *)(v15 + v12 * (v16 + v17));
      v23 = (unsigned __int8 *)(v9 + v10 + v8 * (v11 + v17));
      do
      {
        if ((int)v6 >= 1)
        {
          v24 = *v20;
          v25 = v23;
          v26 = v22;
          v27 = v6;
          do
          {
            v29 = *v25++;
            v28 = v29;
            v30 = *v26++;
            v24 += ((v28 - v30) * (v28 - v30));
            --v27;
          }
          while (v27);
          *v20 = v24;
        }
        ++v21;
        v22 += v12;
        v23 += v8;
      }
      while (v21 != v19);
    }
    v14 = v18;
  }
  while (v18 != 3);
  if ((int)v6 >= 0)
    v31 = v6;
  else
    v31 = v6 + 1;
  v32 = (v31 >> 1);
  if (v7 >= 0)
    v33 = v7;
  else
    v33 = v7 + 1;
  v34 = v33 >> 1;
  v35 = *((_QWORD *)a1 + 15);
  v36 = *((_QWORD *)a2 + 15);
  v37 = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a2 + 40))(a2, 1);
  v38 = a2[100];
  v39 = (uint64_t)(a2[101] + (a2[101] < 0)) >> 1;
  result = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
  v41 = 0;
  v42 = (uint64_t)(a1[101] + (a1[101] < 0)) >> 1;
  v43 = result + a1[100];
  do
  {
    v44 = v34 * (int)v41 / 3;
    v45 = v41 + 1;
    v46 = v34 * ((int)v41 + 1) / 3;
    if (v44 < v46)
    {
      v47 = (uint64x2_t *)((char *)v60 + 24 * v41 + 8);
      v48 = v44;
      result = v43 + v35 * (v42 + v44);
      v49 = (unsigned __int8 *)(v37 + v38 + v36 * (v39 + v44));
      do
      {
        if ((int)v6 >= 2)
        {
          v50 = *v47;
          v51 = v49;
          v52 = (unsigned __int8 *)result;
          v53 = v32;
          do
          {
            v54.i32[0] = *v51;
            v54.i32[1] = v51[1];
            v55.i32[0] = *v52;
            v55.i32[1] = v52[1];
            v56 = vsub_s32(v54, v55);
            v50 = vaddw_u32(v50, (uint32x2_t)vmul_s32(v56, v56));
            v52 += 2;
            v51 += 2;
            --v53;
          }
          while (v53);
          *v47 = v50;
        }
        ++v48;
        result += v35;
        v49 += v36;
      }
      while (v48 != v46);
    }
    v41 = v45;
  }
  while (v45 != 3);
  v57 = 0;
  v58 = v60;
  do
  {
    for (i = 0; i != 24; i += 8)
      *(double *)(a3 + i) = (double)(unint64_t)(3 * *(_QWORD *)((char *)v58 + i));
    ++v57;
    a3 += 24;
    v58 = (_OWORD *)((char *)v58 + 24);
  }
  while (v57 != 3);
  return result;
}

__int16 *sub_1B67BF75C(__int16 *result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  int v10;
  uint64_t v11;
  __int16 *v12;
  __int16 v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;
  __int16 v17;
  _WORD *v18;

  v10 = (int)result;
  if (a5)
  {
    v11 = (a3 + (_DWORD)result - *(_DWORD *)(a6 + 276) / 2);
    if ((int)v11 >= 1)
    {
      v12 = (__int16 *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a6 + 16))(a6, (*(_DWORD *)(a6 + 276) / 2 - 1), (a2 - 1), 1);
      v14 = *v12;
      result = v12 + 1;
      v13 = v14;
      do
      {
        *result++ = v13;
        --v11;
      }
      while (v11);
    }
  }
  if (a4)
  {
    v15 = (a3 + a2 - *(_DWORD *)(a6 + 280) / 2);
    if ((int)v15 >= 1)
    {
      v16 = *(_QWORD *)(a6 + 120);
      result = (__int16 *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a6 + 16))(a6, (v10 - 1), (*(_DWORD *)(a6 + 280) / 2 - 1), 1);
      v17 = *result;
      v18 = (__int16 *)((char *)result + (v16 & 0xFFFFFFFFFFFFFFFELL));
      do
      {
        *v18 = v17;
        v18 = (_WORD *)((char *)v18 + (v16 & 0xFFFFFFFFFFFFFFFELL));
        --v15;
      }
      while (v15);
    }
  }
  return result;
}

uint64_t sub_1B67BF848(int a1, int a2, int a3, int a4, int a5, int a6, int *a7)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  size_t v23;
  uint64_t v24;
  unsigned __int8 *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int16 v34;
  _WORD *v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  int v41;
  int v42;
  int v43;
  uint64_t v44;
  size_t v45;
  char *v46;
  int v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  __int16 v56;
  _WORD *v57;
  uint64_t v58;
  int v59;
  char *v60;
  char *v61;
  BOOL v62;
  int v63;
  char *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  int v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int v82;

  v12 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a7 + 32))(a7, 0);
  v13 = *((_QWORD *)a7 + 14);
  result = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a7 + 32))(a7, 1);
  v15 = result;
  v16 = *((_QWORD *)a7 + 15);
  v17 = v16;
  v82 = a2;
  v79 = result;
  if (a1 <= 2)
  {
    v80 = v12;
    if (a2 <= 3)
      v18 = 3;
    else
      v18 = a2;
    v19 = a2 + a6 + 4;
    v20 = a7[70];
    if (v19 >= v20)
      v21 = a7[70];
    else
      v21 = a2 + a6 + 4;
    if ((int)v18 - 3 < v21)
    {
      v22 = a1;
      v23 = (3 - a1);
      v24 = v18 - 3;
      v77 = v22;
      v25 = (unsigned __int8 *)(v80 + v13 * (v18 - 3));
      v26 = v22 - 3;
      do
      {
        result = (uint64_t)memset(&v25[v26], *v25, v23);
        v20 = a7[70];
        ++v24;
        if (v19 >= v20)
          v27 = a7[70];
        else
          v27 = v19;
        v25 += v13;
      }
      while (v24 < v27);
      v17 = *((_QWORD *)a7 + 15);
      a1 = v77;
      v15 = v79;
    }
    if (a4 <= 1)
      v28 = 1;
    else
      v28 = a4;
    v29 = a4 + (a6 >> 1) + 2;
    if (v29 >= v20 >> 1)
      v30 = (v20 >> 1);
    else
      v30 = v29;
    if ((int)v28 <= (int)v30)
    {
      v31 = v17 >> 1;
      v32 = v28 - 1;
      if (v30 > v28)
        v28 = v30;
      v33 = v15 + 2 * v31 * v32 - 2;
      a2 = v82;
      v12 = v80;
      do
      {
        if (a3 <= 0)
        {
          v34 = *(_WORD *)(v15 + 2 * v31 * v32);
          v35 = (_WORD *)v33;
          v36 = (1 - a3) & ~((1 - a3) >> 31);
          do
          {
            *v35-- = v34;
            --v36;
          }
          while (v36);
        }
        ++v32;
        v33 += 2 * v31;
      }
      while (v32 != v28);
    }
    else
    {
      a2 = v82;
      v12 = v80;
    }
  }
  v37 = a1 + a5 + 4;
  v38 = a7[69];
  v39 = v37 - v38;
  if (v37 > v38)
  {
    if (a2 <= 3)
      v40 = 3;
    else
      v40 = a2;
    v41 = a2 + a6 + 4;
    v42 = a7[70];
    if (v41 >= v42)
      v43 = a7[70];
    else
      v43 = a2 + a6 + 4;
    if ((int)v40 - 3 < v43)
    {
      v78 = a1;
      v44 = v40 - 3;
      v45 = v39;
      v81 = v12;
      v46 = (char *)(v38 + v13 * (v40 - 3) + v12);
      do
      {
        result = (uint64_t)memset(v46, *(v46 - 1), v45);
        ++v44;
        v42 = a7[70];
        if (v41 >= v42)
          v47 = a7[70];
        else
          v47 = v41;
        v46 += v13;
      }
      while (v44 < v47);
      v38 = a7[69];
      v17 = *((_QWORD *)a7 + 15);
      a2 = v82;
      a1 = v78;
      v12 = v81;
    }
    if (a4 <= 1)
      v48 = 1;
    else
      v48 = a4;
    v49 = a4 + (a6 >> 1) + 2;
    if (v49 >= v42 >> 1)
      v50 = (v42 >> 1);
    else
      v50 = v49;
    if ((int)v48 <= (int)v50)
    {
      v51 = v38 - 2;
      v52 = v17 >> 1;
      v53 = a3 + (a5 >> 1) - (v38 >> 1) + 2;
      v54 = v48 - 1;
      if (v50 > v48)
        v48 = v50;
      v55 = v51 + 2 * v52 * v54 + v15 + 2;
      do
      {
        if (v53 >= 1)
        {
          v56 = *(_WORD *)(v15 + v51 + 2 * v52 * v54);
          v57 = (_WORD *)v55;
          result = v53 & ~(v53 >> 31);
          do
          {
            *v57++ = v56;
            --result;
          }
          while (result);
        }
        ++v54;
        v55 += 2 * v52;
      }
      while (v54 != v48);
    }
  }
  v58 = v12 + a1;
  if (a2 <= 2)
  {
    v59 = v82 - 3;
    v60 = (char *)(v58 - 3);
    do
    {
      v61 = &v60[-v13];
      result = (uint64_t)memcpy(&v60[-v13], v60, a5 + 7);
      v60 = v61;
      v62 = __CFADD__(v59++, 1);
    }
    while (!v62);
    if (a4 <= 0)
    {
      v63 = a4 - 1;
      v64 = (char *)(v79 + 2 * a3 - 2);
      do
      {
        v65 = &v64[-v16];
        result = (uint64_t)memcpy(&v64[-v16], v64, (int)((a5 & 0xFFFFFFFE) + 6));
        v64 = v65;
        v62 = __CFADD__(v63++, 1);
      }
      while (!v62);
    }
  }
  v66 = a7[70];
  if (v82 + a6 + 4 > (int)v66)
  {
    v67 = v13 * (v66 - 1);
    v68 = v66 - v82 - 4;
    v69 = v58 - 3;
    v70 = v13 * v66;
    do
    {
      result = (uint64_t)memcpy((void *)(v69 + v70), (const void *)(v69 + v67), a5 + 7);
      ++v68;
      v69 += v13;
    }
    while (a6 != v68);
    v71 = a7[70] >> 1;
    if (v71 < a4 + (a6 >> 1) + 2)
    {
      v72 = v16 * (v71 - 1);
      v73 = 2 * a3 - 2;
      v74 = (a6 >> 1) + a4 - v71 + 2;
      v75 = v79 + v73;
      v76 = v16 * v71;
      do
      {
        result = (uint64_t)memcpy((void *)(v75 + v76), (const void *)(v75 + v72), (int)((a5 & 0xFFFFFFFE) + 6));
        v75 += v16;
        --v74;
      }
      while (v74);
    }
  }
  return result;
}

uint64_t sub_1B67BFCC0(uint64_t a1, FILE *a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  size_t v12;

  if (!a2)
    return 4294954394;
  v4 = *(_DWORD *)(a1 + 276);
  v5 = *(_DWORD *)(a1 + 400);
  v6 = *(_DWORD *)(a1 + 408);
  v7 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  v8 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  result = 0;
  v10 = *(int *)(a1 + 404);
  if ((int)v10 < (int)v7)
  {
    v11 = v8 + 2 * *(int *)(a1 + 400);
    v12 = 2 * (v4 - (v5 + v6));
    do
      fwrite((const void *)(v11 + 2 * *(_QWORD *)(a1 + 112) * v10++), 1uLL, v12, a2);
    while (v10 < v7);
    return 0;
  }
  return result;
}

uint64_t sub_1B67BFD80(uint64_t a1, FILE *a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  size_t v12;

  if (!a2)
    return 4294954394;
  v4 = *(_DWORD *)(a1 + 276);
  v5 = *(_DWORD *)(a1 + 400);
  v6 = *(_DWORD *)(a1 + 408);
  v7 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  v8 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  result = 0;
  v10 = *(int *)(a1 + 404);
  if ((int)v10 < (int)v7)
  {
    v11 = v8 + 2 * *(int *)(a1 + 400);
    v12 = 2 * (v4 - (v5 + v6));
    do
      fwrite((const void *)(v11 + 2 * *(_QWORD *)(a1 + 112) * v10++), 1uLL, v12, a2);
    while (v10 < v7);
    return 0;
  }
  return result;
}

uint64_t sub_1B67BFE40(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  char *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  signed int v17;
  void *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  __int16 *v24;
  uint64_t v25;
  __int16 v26;
  char v27;
  char v28;
  int v29;
  int v30;
  void *data[3];
  CC_MD5_CTX c;
  unsigned __int8 v34;
  CC_MD5_CTX v35;
  char v36;
  CC_MD5_CTX v37;
  char v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  memset(data, 0, sizeof(data));
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  v4 = *a1;
  if (*((_BYTE *)a1 + 136))
  {
    v5 = (char *)(*(uint64_t (**)(uint64_t *, _QWORD))(v4 + 56))(a1, 0);
    v6 = a1 + 22;
    v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, 1);
    v8 = a1 + 21;
  }
  else
  {
    v5 = (char *)(*(uint64_t (**)(uint64_t *, _QWORD))(v4 + 40))(a1, 0);
    v6 = a1 + 15;
    v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, 1);
    v8 = a1 + 14;
  }
  v9 = 0;
  v10 = *v6;
  v11 = *v8;
  do
  {
    *((_BYTE *)&c + v9 + 92) = 1;
    *((_BYTE *)&c + v9 + 92) = CC_MD5_Init((CC_MD5_CTX *)((char *)&c + v9)) != 0;
    v9 += 96;
  }
  while (v9 != 288);
  if (*((_DWORD *)a1 + 70))
  {
    v12 = 0;
    do
    {
      v13 = CC_MD5_Update(&c, v5, 2 * *((_DWORD *)a1 + 69));
      v34 &= v13;
      ++v12;
      v14 = *((_DWORD *)a1 + 70);
      v5 += 2 * v11;
    }
    while (v12 < v14);
    v15 = v14;
    if (v7)
      goto LABEL_10;
LABEL_18:
    v18 = 0;
    goto LABEL_19;
  }
  v14 = 0;
  v15 = 0;
  if (!v7)
    goto LABEL_18;
LABEL_10:
  v16 = *((int *)a1 + 69);
  v17 = 2 * v16 * v14;
  sub_1B67B8800((char **)data, v17);
  v18 = data[0];
  v19 = (char *)data[0] + 2 * (int)v16 * v14;
  if (v14)
  {
    v20 = 2 * v16;
    v21 = v7 + 4 * v16 - 2;
    v22 = (char *)data[0];
    v23 = (char *)data[0] + 2 * (int)v16 * v14;
    do
    {
      if ((_DWORD)v16)
      {
        v24 = (__int16 *)v21;
        v25 = v16 - 1;
        do
        {
          *(_WORD *)&v22[2 * v25] = *(v24 - 1);
          v26 = *v24;
          v24 -= 2;
          *(_WORD *)&v23[2 * v25--] = v26;
        }
        while (v25 != -1);
      }
      v23 += v20;
      v22 += v20;
      v21 += 2 * v10;
      --v15;
    }
    while (v15);
  }
  v27 = CC_MD5_Update(&v35, v18, v17);
  v36 &= v27;
  v28 = CC_MD5_Update(&v37, v19, v17);
  v38 &= v28;
LABEL_19:
  v29 = CC_MD5_Final((unsigned __int8 *)a2, &c);
  v30 = v34;
  if (v18)
    operator delete(v18);
  if ((v29 & v30) != 0)
    return 0;
  else
    return 4294954385;
}

void sub_1B67C00C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void *v11;

  if (v11)
    operator delete(v11);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B67C00F4(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  __CVBuffer *v8;
  OSType PixelFormatType;
  int v10;
  int v11;
  uint64_t v12;
  __CVBuffer *v13;
  signed int v14;
  char v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFAllocator *v20;
  OSStatus v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  size_t Height;
  const __CFDictionary *DescriptionWithPixelFormatType;
  const void *Value;
  CVReturn v31;
  NSObject *v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unsigned __int16 *v38;
  unsigned __int16 *v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  unsigned __int16 *v46;
  unsigned __int16 *v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  OSStatus v53;
  uint32_t v54;
  int v55;
  size_t width;
  uint64_t v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  CFMutableDictionaryRef Mutable;
  VTPixelTransferSessionRef pixelTransferSessionOut;
  CVPixelBufferRef pixelBufferOut;
  uint8_t v67[4];
  CVReturn v68;
  uint8_t buf[8];
  uint64_t (**v70)();
  int v71;
  int v72;
  uint64_t v73;
  __int16 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  char v79;
  uint64_t v80;
  __int16 v81;
  char v82;
  char v83;
  __int128 v84;
  __int128 v85;
  uint64_t v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  uint64_t v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  uint64_t v97;
  __int128 v98;
  int v99;
  uint64_t (***v100)();
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  _BYTE v105[21];
  __int128 v106;
  __int128 v107;
  uint64_t v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  uint64_t v112;
  uint64_t v113;
  __int128 v114;
  __int128 v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  uint64_t v119;
  char v120;
  uint64_t v121;

  v121 = *MEMORY[0x1E0C80C00];
  v71 = 0;
  v72 = 0;
  v79 = 1;
  v87 = 0u;
  v88 = 0u;
  v98 = 0u;
  v80 = 0;
  v81 = 0;
  v91 = 0u;
  v92 = 0u;
  v95 = 0u;
  v96 = 0u;
  v100 = &v70;
  memset(v105, 0, sizeof(v105));
  v104 = 0u;
  v103 = 0u;
  v102 = 0u;
  v101 = 0u;
  v107 = 0u;
  v106 = 0u;
  v108 = 850045863;
  v109 = 0u;
  v110 = 0u;
  v111 = 0u;
  v112 = 0;
  v113 = 1018212795;
  v114 = 0u;
  v115 = 0u;
  v116 = 0;
  v97 = 0;
  v74 = 0;
  v99 = 0;
  v73 = 0;
  v82 = 0;
  v83 = 0;
  v84 = 0u;
  v78 = 0u;
  v85 = 0u;
  v86 = 0;
  v89 = 0u;
  v90 = 0;
  v93 = 0u;
  v94 = 0u;
  v75 = 0u;
  v76 = 0u;
  v77 = 0u;
  v70 = &off_1E6A15040;
  v117 = 0;
  v118 = 0;
  v119 = 0;
  v120 = 0;
  pixelTransferSessionOut = 0;
  pixelBufferOut = 0;
  v8 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  PixelFormatType = CVPixelBufferGetPixelFormatType(v8);
  v10 = *(_DWORD *)(a2 + 276);
  v62 = *(_DWORD *)(a2 + 408);
  v63 = *(_DWORD *)(a2 + 400);
  v11 = *(_DWORD *)(a2 + 280);
  v60 = *(_DWORD *)(a2 + 412);
  v61 = *(_DWORD *)(a2 + 404);
  v12 = *(_QWORD *)(a2 + 112);
  v13 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  v14 = CVPixelBufferGetPixelFormatType(v13);
  v15 = 0;
  v58 = v11;
  v59 = v10;
  if (v14 <= 2016687155)
  {
    if (v14 != 1278226736)
    {
      v16 = 2016686640;
LABEL_7:
      if (v14 != v16)
        goto LABEL_9;
    }
  }
  else if (v14 != 2016687156 && v14 != 2019963956)
  {
    v16 = 2019963440;
    goto LABEL_7;
  }
  v15 = 16 - sub_1B67C37F4(v14);
LABEL_9:
  v17 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
  v18 = *(int *)(a2 + 400);
  v19 = *(int *)(a2 + 404);
  if (CVIsCompressedPixelFormatAvailable(PixelFormatType))
  {
    v57 = v12;
    v20 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v21 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &pixelTransferSessionOut);
    if (v21)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v21;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate for PSNR calculation failed with error: %d\n", buf, 8u);
      }
      goto LABEL_44;
    }
    width = CVPixelBufferGetWidth(v8);
    Height = CVPixelBufferGetHeight(v8);
    *(_QWORD *)buf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, (const void *)*MEMORY[0x1E0CA8FF0], Mutable);
    v55 = a4;
    DescriptionWithPixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
    Value = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E0CA9120]);
    if (sub_1B67C37F4(PixelFormatType) != 8 || !CFEqual(Value, (CFTypeRef)*MEMORY[0x1E0CA9130]))
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v67 = 0;
        v32 = MEMORY[0x1E0C81028];
        v33 = "Bit depth of source pixel buffer is not 8 or source pixel buffer is not video range for PSNR calculation";
        v54 = 2;
        goto LABEL_56;
      }
      goto LABEL_34;
    }
    v31 = CVPixelBufferCreate(v20, width, Height, 0x34323076u, *(CFDictionaryRef *)buf, &pixelBufferOut);
    if (v31)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v67 = 67109120;
        v68 = v31;
        v32 = MEMORY[0x1E0C81028];
        v33 = "CVPixelBufferCreate for PSNR calculation failed with error: %d\n";
LABEL_53:
        v54 = 8;
LABEL_56:
        _os_log_error_impl(&dword_1B676B000, v32, OS_LOG_TYPE_ERROR, v33, v67, v54);
        goto LABEL_34;
      }
      goto LABEL_34;
    }
    v53 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v8, pixelBufferOut);
    if (v53)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v67 = 67109120;
        v68 = v53;
        v32 = MEMORY[0x1E0C81028];
        v33 = "Pixel transfer from compressed to linear format for PSNR calculation failed with error: %d\n";
        goto LABEL_53;
      }
LABEL_34:
      sub_1B67705C8((const void **)&Mutable);
      sub_1B67705C8((const void **)buf);
LABEL_44:
      v36 = 0;
      goto LABEL_45;
    }
    CVPixelBufferGetPixelFormatType(pixelBufferOut);
    sub_1B67C28B8((uint64_t)&v70, pixelBufferOut, 0);
    sub_1B67705C8((const void **)&Mutable);
    sub_1B67705C8((const void **)buf);
    a4 = v55;
    v12 = v57;
  }
  else
  {
    sub_1B67C28B8((uint64_t)&v70, v8, 0);
  }
  v22 = v59 - (v63 + v62);
  v23 = (v58 - (v61 + v60));
  v24 = v17 + 2 * v18 + 2 * v12 * v19;
  v25 = v75;
  if (a4)
  {
    v26 = *((_QWORD *)&v77 + 1);
    if ((_QWORD)v75 || !sub_1B67C3B94((uint64_t)&v70))
      v27 = v76;
    else
      v27 = 0;
    if ((int)v23 < 1)
      goto LABEL_44;
    v44 = 0;
    v36 = 0;
    v45 = v27 + 2 * (int)v84 + 2 * v26 * SDWORD1(v84);
    do
    {
      if (v22 >= 1)
      {
        v46 = (unsigned __int16 *)v24;
        v47 = (unsigned __int16 *)v45;
        v48 = (v59 - (v63 + v62));
        do
        {
          v50 = *v46++;
          v49 = v50;
          v51 = *v47++;
          v36 += ((v49 - v51) * (v49 - v51));
          --v48;
        }
        while (v48);
      }
      ++v44;
      v45 += 2 * v26;
      v24 += 2 * v12;
    }
    while (v44 != v23);
  }
  else
  {
    v34 = *((_QWORD *)&v76 + 1);
    if (!(_QWORD)v75)
    {
      if (sub_1B67C3B94((uint64_t)&v70))
        v25 = 0;
      else
        v25 = v75;
    }
    if ((int)v23 < 1)
      goto LABEL_44;
    v35 = 0;
    v36 = 0;
    v37 = v25 + 2 * (int)v84 + 2 * v34 * SDWORD1(v84);
    do
    {
      if (v22 >= 1)
      {
        v38 = (unsigned __int16 *)v24;
        v39 = (unsigned __int16 *)v37;
        v40 = (v59 - (v63 + v62));
        do
        {
          v42 = *v38++;
          v41 = v42;
          v43 = *v39++;
          v36 += ((v41 >> v15) - (v43 >> v15)) * ((v41 >> v15) - (v43 >> v15));
          --v40;
        }
        while (v40);
      }
      ++v35;
      v37 += 2 * v34;
      v24 += 2 * v12;
    }
    while (v35 != v23);
  }
LABEL_45:
  if (pixelBufferOut)
    CVPixelBufferRelease(pixelBufferOut);
  if (pixelTransferSessionOut)
    CFRelease(pixelTransferSessionOut);
  *(double *)a3 = (double)v36;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  return sub_1B67C3D28((uint64_t)&v70);
}

void sub_1B67C07C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  const void *v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  va_list va1;
  va_list va2;

  va_start(va2, a8);
  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, const void *);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v15 = va_arg(va2, const void *);
  sub_1B67705C8((const void **)va);
  sub_1B67705C8((const void **)va1);
  sub_1B67C3D28((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t *sub_1B67C082C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t *result;
  int v21;
  uint64_t v22;
  unsigned __int16 *v23;
  unsigned __int16 *v24;
  uint64_t v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  _OWORD *v33;
  uint64_t i;
  _OWORD v35[4];
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v36 = 0;
  memset(v35, 0, sizeof(v35));
  v6 = (*(_DWORD *)(a2 + 276) - (*(_DWORD *)(a2 + 400) + *(_DWORD *)(a2 + 408)));
  v7 = *(_DWORD *)(a2 + 280) - (*(_DWORD *)(a2 + 404) + *(_DWORD *)(a2 + 412));
  v8 = *(_QWORD *)(a2 + 112);
  v9 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
  v10 = *(int *)(a2 + 400);
  v11 = *(int *)(a2 + 404);
  v12 = *(_QWORD *)(a1 + 112);
  v13 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v14 = 0;
  v15 = v13 + 2 * *(int *)(a1 + 400);
  v16 = 2 * *(int *)(a1 + 404);
  v17 = v9 + 2 * v10;
  do
  {
    v18 = v7 * (int)v14 / 3;
    v19 = v14 + 1;
    result = (uint64_t *)((unint64_t)(1431655766 * v7 * ((int)v14 + 1)) >> 32);
    v21 = v7 * ((int)v14 + 1) / 3;
    if (v18 < v21)
    {
      result = (uint64_t *)v35 + 3 * v14;
      v22 = v18;
      v23 = (unsigned __int16 *)(v15 + v12 * (v16 + 2 * v18));
      v24 = (unsigned __int16 *)(v17 + v8 * (2 * v11 + 2 * v18));
      do
      {
        if ((int)v6 >= 1)
        {
          v25 = *result;
          v26 = v24;
          v27 = v23;
          v28 = v6;
          do
          {
            v30 = *v26++;
            v29 = v30;
            v31 = *v27++;
            v25 += ((v29 - v31) * (v29 - v31));
            --v28;
          }
          while (v28);
          *result = v25;
        }
        ++v22;
        v23 += v12;
        v24 += v8;
      }
      while (v22 != v21);
    }
    v14 = v19;
  }
  while (v19 != 3);
  v32 = 0;
  v33 = v35;
  do
  {
    for (i = 0; i != 24; i += 8)
      *(double *)(a3 + i) = (double)(unint64_t)(3 * *(_QWORD *)((char *)v33 + i));
    ++v32;
    a3 += 24;
    v33 = (_OWORD *)((char *)v33 + 24);
  }
  while (v32 != 3);
  return result;
}

uint64_t sub_1B67C0A30(int a1, int a2, uint64_t a3, uint64_t a4, int a5, int a6, int *a7)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  __int16 v20;
  _WORD *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  __int16 v30;
  _WORD *v31;
  uint64_t v32;
  int v33;
  char *v34;
  char *v35;
  uint64_t v37;
  size_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;

  v12 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a7 + 32))(a7, 0);
  v13 = *((_QWORD *)a7 + 14);
  result = (*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a7 + 32))(a7, 1);
  if (a1 <= 2)
  {
    v15 = a2 <= 3 ? 3 : a2;
    LODWORD(v16) = a7[70];
    v17 = a2 + a6 + 4;
    v16 = v17 >= (int)v16 ? v16 : v17;
    if ((int)v15 - 3 < (int)v16)
    {
      v18 = v15 - 3;
      v19 = v12 + 2 * v13 * v18 - 2;
      do
      {
        v20 = *(_WORD *)(v12 + 2 * v13 * v18);
        v21 = (_WORD *)v19;
        v22 = (3 - a1);
        do
        {
          *v21-- = v20;
          --v22;
        }
        while (v22);
        ++v18;
        v19 += 2 * v13;
      }
      while (v18 != v16);
    }
  }
  v23 = a1 + a5 + 4;
  v24 = a7[69];
  if (v23 > (int)v24)
  {
    v25 = a2 <= 3 ? 3 : a2;
    LODWORD(v26) = a7[70];
    v27 = a2 + a6 + 4;
    v26 = v27 >= (int)v26 ? v26 : v27;
    if ((int)v25 - 3 < (int)v26)
    {
      v28 = v25 - 3;
      v29 = 2 * v13 * v28 + 2 * (v24 - 1) + v12 + 2;
      do
      {
        if (v23 != (_DWORD)v24)
        {
          v30 = *(_WORD *)(v12 + 2 * (v24 - 1 + v13 * v28));
          v31 = (_WORD *)v29;
          result = v23 - (int)v24;
          do
          {
            *v31++ = v30;
            --result;
          }
          while (result);
        }
        ++v28;
        v29 += 2 * v13;
      }
      while (v28 != v26);
    }
  }
  v32 = v12 + 2 * a1;
  if (a2 <= 2)
  {
    v33 = a2 - 3;
    v34 = (char *)(v32 - 6);
    do
    {
      v35 = &v34[-2 * v13];
      result = (uint64_t)memcpy(v35, v34, 2 * (a5 + 7));
      v34 = v35;
    }
    while (!__CFADD__(v33++, 1));
  }
  v37 = a7[70];
  if (a2 + a6 + 4 > (int)v37)
  {
    v38 = 2 * (a5 + 7);
    v39 = a6 + a2 - v37 + 4;
    v40 = 2 * v13 * (v37 - 1);
    v41 = v32 - 6;
    v42 = v13 * (2 * (v37 - 1) + 2);
    do
    {
      result = (uint64_t)memcpy((void *)(v41 + v42), (const void *)(v41 + v40), v38);
      v41 += 2 * v13;
      --v39;
    }
    while (v39);
  }
  return result;
}

uint64_t sub_1B67C0C60(uint64_t a1, FILE *a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  size_t v12;

  if (!a2)
    return 4294954394;
  v4 = *(_DWORD *)(a1 + 276);
  v5 = *(_DWORD *)(a1 + 400);
  v6 = *(_DWORD *)(a1 + 408);
  v7 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  v8 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  result = 0;
  v10 = *(int *)(a1 + 404);
  if ((int)v10 < (int)v7)
  {
    v11 = v8 + *(int *)(a1 + 400);
    v12 = v4 - (v5 + v6);
    do
      fwrite((const void *)(v11 + *(_QWORD *)(a1 + 112) * v10++), 1uLL, v12, a2);
    while (v10 < v7);
    return 0;
  }
  return result;
}

uint64_t sub_1B67C0D1C(uint64_t a1, FILE *a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  size_t v12;

  if (!a2)
    return 4294954394;
  v4 = *(_DWORD *)(a1 + 276);
  v5 = *(_DWORD *)(a1 + 400);
  v6 = *(_DWORD *)(a1 + 408);
  v7 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  v8 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  result = 0;
  v10 = *(int *)(a1 + 404);
  if ((int)v10 < (int)v7)
  {
    v11 = v8 + *(int *)(a1 + 400);
    v12 = v4 - (v5 + v6);
    do
      fwrite((const void *)(v11 + *(_QWORD *)(a1 + 112) * v10++), 1uLL, v12, a2);
    while (v10 < v7);
    return 0;
  }
  return result;
}

uint64_t sub_1B67C0DD8(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  char *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t i;
  char v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char v25;
  char v26;
  char v27;
  int v28;
  int v29;
  void *__p[3];
  CC_MD5_CTX c;
  unsigned __int8 v33;
  CC_MD5_CTX v34;
  char v35;
  CC_MD5_CTX v36;
  char v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  memset(__p, 0, sizeof(__p));
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  v4 = *a1;
  if (*((_BYTE *)a1 + 136))
  {
    v5 = (char *)(*(uint64_t (**)(uint64_t *, _QWORD))(v4 + 56))(a1, 0);
    v6 = a1 + 22;
    v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, 1);
    v8 = a1 + 21;
  }
  else
  {
    v5 = (char *)(*(uint64_t (**)(uint64_t *, _QWORD))(v4 + 40))(a1, 0);
    v6 = a1 + 15;
    v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, 1);
    v8 = a1 + 14;
  }
  v9 = 0;
  v10 = *v6;
  v11 = *v8;
  do
  {
    *((_BYTE *)&c + v9 + 92) = 1;
    *((_BYTE *)&c + v9 + 92) = CC_MD5_Init((CC_MD5_CTX *)((char *)&c + v9)) != 0;
    v9 += 96;
  }
  while (v9 != 288);
  if (*((_DWORD *)a1 + 70))
  {
    for (i = 0; i < v14; ++i)
    {
      v13 = CC_MD5_Update(&c, v5, *((_DWORD *)a1 + 69));
      v33 &= v13;
      v5 += v11;
      v14 = *((_DWORD *)a1 + 70);
    }
    v15 = v14;
    if (!v7)
      goto LABEL_22;
  }
  else
  {
    v14 = 0;
    v15 = 0;
    if (!v7)
      goto LABEL_22;
  }
  v16 = *((int *)a1 + 69);
  v17 = (int)v16 * (uint64_t)v14;
  if ((_DWORD)v17)
  {
    sub_1B6773C90((unint64_t *)__p, 2 * (int)v17);
    v18 = (char *)__p[0];
  }
  else
  {
    v18 = 0;
  }
  v19 = &v18[v17];
  if (v14)
  {
    v20 = v7 + 2 * v16 - 1;
    v21 = v18;
    v22 = &v18[v17];
    do
    {
      if ((_DWORD)v16)
      {
        v23 = (char *)v20;
        v24 = v16;
        do
        {
          v21[v24 - 1] = *(v23 - 1);
          v25 = *v23;
          v23 -= 2;
          v22[--v24] = v25;
        }
        while (v24);
      }
      v21 += v16;
      v22 += v16;
      v20 += v10;
      --v15;
    }
    while (v15);
  }
  v26 = CC_MD5_Update(&v34, v18, v16 * v14);
  v35 &= v26;
  v27 = CC_MD5_Update(&v36, v19, v16 * v14);
  v37 &= v27;
LABEL_22:
  v28 = CC_MD5_Final((unsigned __int8 *)a2, &c);
  v29 = v33;
  if (__p[0])
    operator delete(__p[0]);
  if ((v28 & v29) != 0)
    return 0;
  else
    return 4294954385;
}

void sub_1B67C1050(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B67C1074(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  __CVBuffer *v8;
  OSType PixelFormatType;
  int v10;
  int v11;
  uint64_t v12;
  __CVBuffer *v13;
  signed int v14;
  char v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFAllocator *v20;
  OSStatus v21;
  int v22;
  uint64_t v23;
  unsigned __int8 *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFDictionary *DescriptionWithPixelFormatType;
  const void *Value;
  CVReturn v31;
  NSObject *v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unsigned __int8 *v37;
  unsigned __int8 *v38;
  unsigned __int8 *v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  unsigned __int8 *v45;
  unsigned __int8 *v46;
  unsigned __int8 *v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  OSStatus v53;
  uint32_t v54;
  size_t Height;
  size_t Width;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  CFMutableDictionaryRef Mutable;
  VTPixelTransferSessionRef pixelTransferSessionOut;
  CVPixelBufferRef pixelBufferOut;
  uint8_t v67[4];
  CVReturn v68;
  uint8_t buf[8];
  uint64_t (**v70)();
  int v71;
  int v72;
  uint64_t v73;
  __int16 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  char v79;
  uint64_t v80;
  __int16 v81;
  char v82;
  char v83;
  __int128 v84;
  __int128 v85;
  uint64_t v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  uint64_t v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  uint64_t v97;
  __int128 v98;
  int v99;
  uint64_t (***v100)();
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  _BYTE v105[21];
  __int128 v106;
  __int128 v107;
  uint64_t v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  uint64_t v112;
  uint64_t v113;
  __int128 v114;
  __int128 v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  uint64_t v119;
  char v120;
  uint64_t v121;

  v121 = *MEMORY[0x1E0C80C00];
  v71 = 0;
  v72 = 0;
  v79 = 1;
  v87 = 0u;
  v88 = 0u;
  v98 = 0u;
  v80 = 0;
  v81 = 0;
  v91 = 0u;
  v92 = 0u;
  v95 = 0u;
  v96 = 0u;
  v100 = &v70;
  memset(v105, 0, sizeof(v105));
  v104 = 0u;
  v103 = 0u;
  v102 = 0u;
  v101 = 0u;
  v107 = 0u;
  v106 = 0u;
  v108 = 850045863;
  v109 = 0u;
  v110 = 0u;
  v111 = 0u;
  v112 = 0;
  v113 = 1018212795;
  v114 = 0u;
  v115 = 0u;
  v116 = 0;
  v97 = 0;
  v74 = 0;
  v99 = 0;
  v73 = 0;
  v82 = 0;
  v83 = 0;
  v84 = 0u;
  v78 = 0u;
  v85 = 0u;
  v86 = 0;
  v89 = 0u;
  v90 = 0;
  v93 = 0u;
  v94 = 0u;
  v75 = 0u;
  v76 = 0u;
  v77 = 0u;
  v70 = &off_1E6A15040;
  v117 = 0;
  v118 = 0;
  v119 = 0;
  v120 = 0;
  pixelTransferSessionOut = 0;
  pixelBufferOut = 0;
  v8 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  PixelFormatType = CVPixelBufferGetPixelFormatType(v8);
  v10 = *(_DWORD *)(a2 + 276);
  v62 = *(_DWORD *)(a2 + 408);
  v63 = *(_DWORD *)(a2 + 400);
  v11 = *(_DWORD *)(a2 + 280);
  v60 = *(_DWORD *)(a2 + 412);
  v61 = *(_DWORD *)(a2 + 404);
  v12 = *(_QWORD *)(a2 + 112);
  v13 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  v14 = CVPixelBufferGetPixelFormatType(v13);
  v15 = 0;
  v58 = v11;
  v59 = v10;
  if (v14 <= 2016687155)
  {
    if (v14 != 1278226736)
    {
      v16 = 2016686640;
LABEL_7:
      if (v14 != v16)
        goto LABEL_9;
    }
  }
  else if (v14 != 2016687156 && v14 != 2019963956)
  {
    v16 = 2019963440;
    goto LABEL_7;
  }
  v15 = 8 - sub_1B67C37F4(v14);
LABEL_9:
  v17 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
  v18 = *(int *)(a2 + 400);
  v19 = *(int *)(a2 + 404);
  if (CVIsCompressedPixelFormatAvailable(PixelFormatType))
  {
    v57 = a4;
    v20 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v21 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &pixelTransferSessionOut);
    if (v21)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v21;
        _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate for PSNR calculation failed with error: %d\n", buf, 8u);
      }
      goto LABEL_44;
    }
    Width = CVPixelBufferGetWidth(v8);
    Height = CVPixelBufferGetHeight(v8);
    *(_QWORD *)buf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, (const void *)*MEMORY[0x1E0CA8FF0], Mutable);
    v28 = a3;
    DescriptionWithPixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
    Value = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E0CA9120]);
    if (sub_1B67C37F4(PixelFormatType) != 8 || !CFEqual(Value, (CFTypeRef)*MEMORY[0x1E0CA9130]))
    {
      a3 = v28;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v67 = 0;
        v32 = MEMORY[0x1E0C81028];
        v33 = "Bit depth of source pixel buffer is not 8 or source pixel buffer is not video range for PSNR calculation";
        v54 = 2;
        goto LABEL_56;
      }
      goto LABEL_34;
    }
    v31 = CVPixelBufferCreate(v20, Width, Height, 0x34323076u, *(CFDictionaryRef *)buf, &pixelBufferOut);
    a3 = v28;
    if (v31)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v67 = 67109120;
        v68 = v31;
        v32 = MEMORY[0x1E0C81028];
        v33 = "CVPixelBufferCreate for PSNR calculation failed with error: %d\n";
LABEL_53:
        v54 = 8;
LABEL_56:
        _os_log_error_impl(&dword_1B676B000, v32, OS_LOG_TYPE_ERROR, v33, v67, v54);
        goto LABEL_34;
      }
      goto LABEL_34;
    }
    v53 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v8, pixelBufferOut);
    if (v53)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v67 = 67109120;
        v68 = v53;
        v32 = MEMORY[0x1E0C81028];
        v33 = "Pixel transfer from compressed to linear format for PSNR calculation failed with error: %d\n";
        goto LABEL_53;
      }
LABEL_34:
      sub_1B67705C8((const void **)&Mutable);
      sub_1B67705C8((const void **)buf);
LABEL_44:
      v36 = 0;
      goto LABEL_45;
    }
    CVPixelBufferGetPixelFormatType(pixelBufferOut);
    sub_1B67C28B8((uint64_t)&v70, pixelBufferOut, 0);
    sub_1B67705C8((const void **)&Mutable);
    sub_1B67705C8((const void **)buf);
    a3 = v28;
    a4 = v57;
  }
  else
  {
    sub_1B67C28B8((uint64_t)&v70, v8, 0);
  }
  v22 = v59 - (v63 + v62);
  v23 = (v58 - (v61 + v60));
  v24 = (unsigned __int8 *)(v17 + v18 + v12 * v19);
  v25 = v75;
  if (a4)
  {
    v26 = *((_QWORD *)&v77 + 1);
    if ((_QWORD)v75 || !sub_1B67C3B94((uint64_t)&v70))
      v27 = v76;
    else
      v27 = 0;
    if ((int)v23 < 1)
      goto LABEL_44;
    v44 = 0;
    v36 = 0;
    v45 = (unsigned __int8 *)(v27 + (int)v84 + v26 * SDWORD1(v84));
    do
    {
      if (v22 >= 1)
      {
        v46 = v24;
        v47 = v45;
        v48 = (v59 - (v63 + v62));
        do
        {
          v50 = *v46++;
          v49 = v50;
          v51 = *v47++;
          v36 += ((v49 - v51) * (v49 - v51));
          --v48;
        }
        while (v48);
      }
      ++v44;
      v45 += v26;
      v24 += v12;
    }
    while (v44 != v23);
  }
  else
  {
    v34 = *((_QWORD *)&v76 + 1);
    if (!(_QWORD)v75)
    {
      if (sub_1B67C3B94((uint64_t)&v70))
        v25 = 0;
      else
        v25 = v75;
    }
    if ((int)v23 < 1)
      goto LABEL_44;
    v35 = 0;
    v36 = 0;
    v37 = (unsigned __int8 *)(v25 + (int)v84 + v34 * SDWORD1(v84));
    do
    {
      if (v22 >= 1)
      {
        v38 = v24;
        v39 = v37;
        v40 = (v59 - (v63 + v62));
        do
        {
          v42 = *v38++;
          v41 = v42;
          v43 = *v39++;
          v36 += ((v41 >> v15) - (v43 >> v15)) * ((v41 >> v15) - (v43 >> v15));
          --v40;
        }
        while (v40);
      }
      ++v35;
      v37 += v34;
      v24 += v12;
    }
    while (v35 != v23);
  }
LABEL_45:
  if (pixelBufferOut)
    CVPixelBufferRelease(pixelBufferOut);
  if (pixelTransferSessionOut)
    CFRelease(pixelTransferSessionOut);
  *(double *)a3 = (double)v36;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  return sub_1B67C3D28((uint64_t)&v70);
}

void sub_1B67C172C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  const void *v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  va_list va1;
  va_list va2;

  va_start(va2, a8);
  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, const void *);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v15 = va_arg(va2, const void *);
  sub_1B67705C8((const void **)va);
  sub_1B67705C8((const void **)va1);
  sub_1B67C3D28((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_1B67C1794(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 *v22;
  uint64_t v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  _OWORD *v31;
  uint64_t i;
  _OWORD v33[4];
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v34 = 0;
  memset(v33, 0, sizeof(v33));
  v6 = (*(_DWORD *)(a2 + 276) - (*(_DWORD *)(a2 + 400) + *(_DWORD *)(a2 + 408)));
  v7 = *(_DWORD *)(a2 + 280) - (*(_DWORD *)(a2 + 404) + *(_DWORD *)(a2 + 412));
  v8 = *(_QWORD *)(a2 + 112);
  v9 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
  v10 = *(int *)(a2 + 400);
  v11 = *(int *)(a2 + 404);
  v12 = *(_QWORD *)(a1 + 112);
  result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
  v14 = 0;
  v15 = result + *(int *)(a1 + 400);
  v16 = *(int *)(a1 + 404);
  do
  {
    v17 = v7 * (int)v14 / 3;
    v18 = v14 + 1;
    v19 = v7 * ((int)v14 + 1) / 3;
    if (v17 < v19)
    {
      v20 = (uint64_t *)v33 + 3 * v14;
      v21 = v17;
      result = v15 + v12 * (v16 + v17);
      v22 = (unsigned __int8 *)(v9 + v10 + v8 * (v11 + v17));
      do
      {
        if ((int)v6 >= 1)
        {
          v23 = *v20;
          v24 = v22;
          v25 = (unsigned __int8 *)result;
          v26 = v6;
          do
          {
            v28 = *v24++;
            v27 = v28;
            v29 = *v25++;
            v23 += ((v27 - v29) * (v27 - v29));
            --v26;
          }
          while (v26);
          *v20 = v23;
        }
        ++v21;
        result += v12;
        v22 += v8;
      }
      while (v21 != v19);
    }
    v14 = v18;
  }
  while (v18 != 3);
  v30 = 0;
  v31 = v33;
  do
  {
    for (i = 0; i != 24; i += 8)
      *(double *)(a3 + i) = (double)(unint64_t)(3 * *(_QWORD *)((char *)v31 + i));
    ++v30;
    a3 += 24;
    v31 = (_OWORD *)((char *)v31 + 24);
  }
  while (v30 != 3);
  return result;
}

void *sub_1B67C1988(int a1, int a2, uint64_t a3, uint64_t a4, int a5, int a6, int *a7)
{
  uint64_t v10;
  uint64_t v11;
  void *result;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  unsigned __int8 *v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  size_t v25;
  char *v26;
  int v27;
  uint64_t v28;
  int v29;
  char *v30;
  char *v31;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;

  v10 = (*(uint64_t (**)(int *, _QWORD))(*(_QWORD *)a7 + 32))(a7, 0);
  v11 = *((_QWORD *)a7 + 14);
  result = (void *)(*(uint64_t (**)(int *, uint64_t))(*(_QWORD *)a7 + 32))(a7, 1);
  if (a1 <= 2)
  {
    if (a2 <= 3)
      v13 = 3;
    else
      v13 = a2;
    v14 = a2 + a6 + 4;
    v15 = a7[70];
    if (v14 < v15)
      v15 = a2 + a6 + 4;
    if ((int)v13 - 3 < v15)
    {
      v16 = v13 - 3;
      v17 = (unsigned __int8 *)(v10 + v11 * (v13 - 3));
      do
      {
        result = memset(&v17[a1 - 3], *v17, (3 - a1));
        v18 = a7[70];
        ++v16;
        if (v14 < v18)
          v18 = a2 + a6 + 4;
        v17 += v11;
      }
      while (v16 < v18);
    }
  }
  v19 = a1 + a5 + 4;
  v20 = a7[69];
  if (v19 > (int)v20)
  {
    if (a2 <= 3)
      v21 = 3;
    else
      v21 = a2;
    v22 = a2 + a6 + 4;
    v23 = a7[70];
    if (v22 < v23)
      v23 = a2 + a6 + 4;
    if ((int)v21 - 3 < v23)
    {
      v24 = v21 - 3;
      v25 = v19 - (int)v20;
      v26 = (char *)(v20 + v11 * (v21 - 3) + v10);
      do
      {
        result = memset(v26, *(v26 - 1), v25);
        ++v24;
        v27 = a7[70];
        if (v22 < v27)
          v27 = a2 + a6 + 4;
        v26 += v11;
      }
      while (v24 < v27);
    }
  }
  v28 = v10 + a1;
  if (a2 <= 2)
  {
    v29 = a2 - 3;
    v30 = (char *)(v28 - 3);
    do
    {
      v31 = &v30[-v11];
      result = memcpy(&v30[-v11], v30, a5 + 7);
      v30 = v31;
    }
    while (!__CFADD__(v29++, 1));
  }
  v33 = a7[70];
  if (a2 + a6 + 4 > (int)v33)
  {
    v34 = v11 * (v33 - 1);
    v35 = a6 + a2 - v33 + 4;
    v36 = v28 - 3;
    v37 = v11 * v33;
    do
    {
      result = memcpy((void *)(v36 + v37), (const void *)(v36 + v34), a5 + 7);
      v36 += v11;
      --v35;
    }
    while (v35);
  }
  return result;
}

void sub_1B67C1BA4(_DWORD *a1, double *a2, double *a3)
{
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;

  v5 = (double)(unint64_t)(65025 * (a1[69] - (a1[100] + a1[102])) * (uint64_t)(a1[70] - (a1[101] + a1[103])));
  v6 = 999.0;
  v7 = 999.0;
  if (*a2 > 0.0)
    v7 = log10(v5 / *a2) * 10.0;
  *a3 = v7;
  v8 = a2[1];
  v9 = 999.0;
  if (v8 > 0.0)
    v9 = log10(v5 * 0.25 / v8) * 10.0;
  a3[1] = v9;
  v10 = a2[2];
  v11 = 999.0;
  if (v10 > 0.0)
    v11 = log10(v5 * 0.25 / v10) * 10.0;
  a3[2] = v11;
  v12 = *a2 + a2[1] + a2[2];
  if (v12 > 0.0)
    v6 = log10(v5 * 1.5 / v12) * 10.0;
  a3[3] = v6;
}

void sub_1B67C1CBC(_DWORD *a1, double *a2, double *a3)
{
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;

  v5 = (double)(unint64_t)(261121 * (a1[69] - (a1[100] + a1[102])) * (uint64_t)(a1[70] - (a1[101] + a1[103])));
  v6 = 999.0;
  v7 = 999.0;
  if (*a2 > 0.0)
    v7 = log10(v5 / *a2) * 10.0;
  *a3 = v7;
  v8 = a2[1];
  v9 = 999.0;
  if (v8 > 0.0)
    v9 = log10(v5 * 0.25 / v8) * 10.0;
  a3[1] = v9;
  v10 = a2[2];
  v11 = 999.0;
  if (v10 > 0.0)
    v11 = log10(v5 * 0.25 / v10) * 10.0;
  a3[2] = v11;
  v12 = *a2 + a2[1] + a2[2];
  if (v12 > 0.0)
    v6 = log10(v5 * 1.5 / v12) * 10.0;
  a3[3] = v6;
}

void sub_1B67C1DD8(_DWORD *a1, double *a2, double *a3)
{
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;

  v5 = (double)(unint64_t)(1046529 * (a1[69] - (a1[100] + a1[102])) * (uint64_t)(a1[70] - (a1[101] + a1[103])));
  v6 = 999.0;
  v7 = 999.0;
  if (*a2 > 0.0)
    v7 = log10(v5 / *a2) * 10.0;
  *a3 = v7;
  v8 = a2[1];
  v9 = 999.0;
  if (v8 > 0.0)
    v9 = log10(v5 * 0.25 / v8) * 10.0;
  a3[1] = v9;
  v10 = a2[2];
  v11 = 999.0;
  if (v10 > 0.0)
    v11 = log10(v5 * 0.25 / v10) * 10.0;
  a3[2] = v11;
  v12 = *a2 + a2[1] + a2[2];
  if (v12 > 0.0)
    v6 = log10(v5 * 1.5 / v12) * 10.0;
  a3[3] = v6;
}

uint64_t sub_1B67C1EF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v12;
  int v13;
  __CVBuffer *v14;
  __CVBuffer *v15;
  uint64_t v16;
  uint64_t v17;
  void *BaseAddressOfPlane;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  char v34;
  uint64_t v35;
  _QWORD *v36;
  uint8_t v38[16];

  v5 = 1;
  if (a3 && *(_BYTE *)(a1 + 136))
  {
    v6 = *(_DWORD *)(a1 + 276);
    v8 = *(_DWORD *)(a1 + 240);
    v7 = *(_DWORD *)(a1 + 244);
    v9 = *(_DWORD *)(a1 + 280);
    if (v8 != v6 || v7 != v9)
    {
      v12 = v6 - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
      v13 = v9 - (*(_DWORD *)(a1 + 404) + *(_DWORD *)(a1 + 412));
      v14 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1);
      v15 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1);
      v16 = sub_1B68520B8((_DWORD *)a3, v8, v7, v12, v13, v14, v15);
      if ((_DWORD)v16)
      {
LABEL_34:
        *(_QWORD *)(a1 + 248) = 0;
        return v16;
      }
      v16 = CVPixelBufferLockBaseAddress(v14, 1uLL);
      if ((_DWORD)v16)
      {
LABEL_11:
        CVBufferPropagateAttachments(v14, v15);
        goto LABEL_34;
      }
      v17 = CVPixelBufferLockBaseAddress(v15, 0);
      if ((_DWORD)v17)
      {
        v16 = v17;
        CVPixelBufferUnlockBaseAddress(v14, 1uLL);
        goto LABEL_11;
      }
      *(_QWORD *)a3 = CVPixelBufferGetBaseAddressOfPlane(v14, 0);
      *(_QWORD *)(a3 + 8) = CVPixelBufferGetBaseAddressOfPlane(v14, 1uLL);
      *(_QWORD *)(a3 + 16) = CVPixelBufferGetBaseAddressOfPlane(v15, 0);
      BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(v15, 1uLL);
      *(_QWORD *)(a3 + 24) = BaseAddressOfPlane;
      if (*(_QWORD *)a3 && *(_QWORD *)(a3 + 8) && *(_QWORD *)(a3 + 16) && BaseAddressOfPlane)
      {
        *(_QWORD *)(a3 + 32) = CVPixelBufferGetBytesPerRowOfPlane(v14, 0);
        *(_QWORD *)(a3 + 40) = CVPixelBufferGetBytesPerRowOfPlane(v14, 1uLL);
        *(_QWORD *)(a3 + 48) = CVPixelBufferGetBytesPerRowOfPlane(v15, 0);
        *(_QWORD *)(a3 + 56) = CVPixelBufferGetBytesPerRowOfPlane(v15, 1uLL);
        v24 = *(int *)(a3 + 4252);
        v25 = *(int *)(a3 + 4248) & 0xFFFFFFFFFFFFFFFELL;
        v26 = v25 + *(_QWORD *)(a3 + 32) * v24;
        if ((int)v24 >= -1)
          v27 = v24 + 1;
        else
          v27 = v24 + 2;
        v28 = *(_QWORD *)(a3 + 8) + v25 + *(_QWORD *)(a3 + 40) * ((uint64_t)v27 >> 1);
        *(_QWORD *)a3 += v26;
        *(_QWORD *)(a3 + 8) = v28;
        v16 = sub_1B68730BC((uint64_t *)a3, v19, v20, v21, v22, v23);
      }
      else
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v38 = 0;
          _os_log_error_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "NULL plane!\n", v38, 2u);
        }
        v16 = 4294954394;
      }
      CVPixelBufferUnlockBaseAddress(v14, 1uLL);
      CVPixelBufferUnlockBaseAddress(v15, 0);
      CVBufferPropagateAttachments(v14, v15);
      if ((_DWORD)v16)
        goto LABEL_34;
      v29 = *(unsigned __int8 *)(a1 + 285);
      if (*(_BYTE *)(a1 + 285))
      {
        v30 = (_QWORD *)(a1 + 112);
        do
        {
          *(v30 - 3) = v30[10];
          *v30 = v30[13];
          ++v30;
          --v29;
        }
        while (v29);
      }
      v5 = 0;
      *(_QWORD *)(a1 + 248) = *(_QWORD *)(a1 + 276);
    }
  }
  v31 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 432))(a1, a2);
  v16 = v31;
  if ((v5 & 1) == 0 && !(_DWORD)v31)
  {
    if (!*(_BYTE *)(a1 + 136))
      return 0;
    v32 = 0;
    v33 = 1;
    do
    {
      v34 = v33;
      v35 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, v32);
      v33 = 0;
      v36 = (_QWORD *)(a1 + 8 * v32);
      v36[11] = v35;
      v36[14] = v36[21];
      v32 = 1;
    }
    while ((v34 & 1) != 0);
    v16 = 0;
    goto LABEL_34;
  }
  return v16;
}

uint64_t sub_1B67C2218(void **memptr, unint64_t a2)
{
  void *v4;
  uint64_t result;
  uint64_t v6;

  if ((unint64_t)memptr[1] >= a2)
    return 0;
  if (a2 > 0x3200000)
    return 4294954392;
  v4 = *memptr;
  if (v4)
  {
    free(v4);
    *memptr = 0;
    memptr[1] = 0;
  }
  if (malloc_type_posix_memalign(memptr, 0x10uLL, 2 * a2, 0x1000040BDFB0063uLL) || !*memptr)
    return 4294954392;
  v6 = 0;
  do
    *((_WORD *)*memptr + v6++) = 0;
  while (a2 != v6);
  result = 0;
  memptr[1] = (void *)a2;
  return result;
}

uint64_t sub_1B67C22BC(void **memptr, unint64_t a2)
{
  void *v4;
  uint64_t result;
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;

  if ((unint64_t)memptr[1] >= a2)
    return 0;
  if (a2 > 0x640000)
    return 4294954392;
  v4 = *memptr;
  if (v4)
  {
    free(v4);
    *memptr = 0;
    memptr[1] = 0;
  }
  if (malloc_type_posix_memalign(memptr, 0x10uLL, 16 * a2, 0x10000402CEA329FuLL) || !*memptr)
    return 4294954392;
  v6 = 0;
  v7 = a2;
  do
  {
    v8 = (char *)*memptr + v6;
    *v8 = 0;
    v8[1] = 0;
    v6 += 16;
    --v7;
  }
  while (v7);
  result = 0;
  memptr[1] = (void *)a2;
  return result;
}

uint64_t sub_1B67C2364(void **memptr, size_t size, size_t alignment)
{
  unsigned int v4;
  void *v6;
  uint64_t result;
  uint64_t v8;

  if ((unint64_t)memptr[1] >= size)
    return 0;
  if (size > 0x6400000)
    return 4294954392;
  v4 = alignment;
  v6 = *memptr;
  if (v6)
  {
    free(v6);
    *memptr = 0;
    memptr[1] = 0;
  }
  if (malloc_type_posix_memalign(memptr, v4, size, 0x100004077774924uLL) || !*memptr)
    return 4294954392;
  v8 = 0;
  do
    *((_BYTE *)*memptr + v8++) = 0;
  while (size != v8);
  result = 0;
  memptr[1] = (void *)size;
  return result;
}

uint64_t sub_1B67C2414(void **memptr, unint64_t a2)
{
  void *v4;
  uint64_t result;
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;

  if ((unint64_t)memptr[1] >= a2)
    return 0;
  if (a2 > 0x640000)
    return 4294954392;
  v4 = *memptr;
  if (v4)
  {
    free(v4);
    *memptr = 0;
    memptr[1] = 0;
  }
  if (malloc_type_posix_memalign(memptr, 0x10uLL, 16 * a2, 0x1000040451B5BE8uLL) || !*memptr)
    return 4294954392;
  v6 = 0;
  v7 = a2;
  do
  {
    v8 = (char *)*memptr + v6;
    *v8 = 0;
    v8[1] = 0;
    v6 += 16;
    --v7;
  }
  while (v7);
  result = 0;
  memptr[1] = (void *)a2;
  return result;
}

uint64_t sub_1B67C24BC(_QWORD *a1)
{
  void *v2;
  void *v3;
  id v4;
  uint64_t v5;

  if (!a1)
    return 4294967246;
  NSClassFromString(CFSTR("VCPRealTimeAnalysisService"));
  objc_msgSend((id)objc_opt_class(), "analysisService");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = v2;
  if (v2)
  {
    v4 = v2;
    v5 = 0;
  }
  else
  {
    v5 = 4294967188;
  }
  *a1 = v3;

  return v5;
}

void sub_1B67C2528(void *a1, uint64_t a2, unsigned int a3, uint64_t a4, void *a5)
{
  id v9;
  void *v10;
  void *v11;
  _QWORD v12[4];
  id v13;

  v9 = a5;
  v10 = v9;
  if (a1 && a2 && v9)
  {
    v11 = (void *)MEMORY[0x1BCC98608]();
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = sub_1B67C2614;
    v12[3] = &unk_1E6A16DE0;
    v13 = v10;
    objc_msgSend(a1, "requestAnalysis:ofPixelBuffer:withProperties:withCompletionHandler:", a3, a2, a4, v12);

    objc_autoreleasePoolPop(v11);
  }

}

void sub_1B67C25F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B67C2614(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;

  v6 = a2;
  v5 = a3;
  (*(void (**)(_QWORD, uint64_t, id))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), objc_msgSend(v5, "code"), v6);

}

void sub_1B67C2670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B67C268C(uint64_t a1)
{
  sub_1B67C3D28(a1);
  JUMPOUT(0x1BCC9814CLL);
}

uint64_t sub_1B67C26B0(uint64_t a1, int a2, int a3, int a4)
{
  if (*(_QWORD *)(a1 + 88) || !sub_1B67C3B94(a1))
    return *(_QWORD *)(a1 + 8 * a4 + 88)
         + ((*(_QWORD *)(a1 + 8 * a4 + 112) * a3 + (a2 << a4)) << *(_BYTE *)(a1 + 286));
  else
    return 0;
}

uint64_t sub_1B67C2724(uint64_t a1, int a2, int a3, int a4)
{
  if (*(_QWORD *)(a1 + 88) || !sub_1B67C3B94(a1))
    return *(_QWORD *)(a1 + 8 * a4 + 88)
         + ((*(_QWORD *)(a1 + 8 * a4 + 112) * a3 + (a2 << a4)) << *(_BYTE *)(a1 + 286));
  else
    return 0;
}

uint64_t sub_1B67C2798(uint64_t a1, int a2)
{
  if (*(_QWORD *)(a1 + 88) || !sub_1B67C3B94(a1))
    return *(_QWORD *)(a1 + 8 * a2 + 88);
  else
    return 0;
}

uint64_t sub_1B67C27DC(uint64_t a1, int a2)
{
  if (*(_QWORD *)(a1 + 88) || !sub_1B67C3B94(a1))
    return *(_QWORD *)(a1 + 8 * a2 + 88);
  else
    return 0;
}

uint64_t sub_1B67C2820(uint64_t a1, int a2)
{
  if (*(_BYTE *)(a1 + 136) && !*(_QWORD *)(a1 + 144) && sub_1B67C3B94(a1))
    return 0;
  else
    return *(_QWORD *)(a1 + 8 * a2 + 144);
}

uint64_t sub_1B67C286C(uint64_t a1, int a2)
{
  if (*(_BYTE *)(a1 + 136) && !*(_QWORD *)(a1 + 144) && sub_1B67C3B94(a1))
    return 0;
  else
    return *(_QWORD *)(a1 + 8 * a2 + 144);
}

uint64_t sub_1B67C28B8(uint64_t a1, CVPixelBufferRef pixelBuffer, __CVBuffer *a3)
{
  signed int PixelFormatType;
  char v7;
  unsigned __int8 PlaneCount;
  int v9;
  int v10;
  unsigned int v11;
  size_t v12;
  char v13;
  uint64_t result;
  OSType v15;
  size_t v16;
  char v17;
  _QWORD *v18;
  size_t BytesPerRowOfPlane;

  PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
  if (!sub_1B67C34C0(PixelFormatType))
    return 4294954394;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  *(_QWORD *)(a1 + 1232) = CVPixelBufferRetain(pixelBuffer);
  v7 = 1;
  *(_DWORD *)(a1 + 1240) = 1;
  *(_DWORD *)(a1 + 276) = CVPixelBufferGetWidth(pixelBuffer);
  *(_DWORD *)(a1 + 280) = CVPixelBufferGetHeight(pixelBuffer);
  PlaneCount = CVPixelBufferGetPlaneCount(pixelBuffer);
  *(_BYTE *)(a1 + 285) = PlaneCount;
  if (PixelFormatType <= 875836517)
  {
    if (PixelFormatType > 645428787)
    {
      if (PixelFormatType == 645428788)
        goto LABEL_24;
      if (PixelFormatType != 875704934 && PixelFormatType != 875704950)
        goto LABEL_25;
    }
    else if (PixelFormatType != 641230386 && PixelFormatType != 641234482)
    {
      v10 = 645424692;
      goto LABEL_23;
    }
    v7 = 2;
    goto LABEL_25;
  }
  if (PixelFormatType <= 1278226735)
  {
    if (PixelFormatType != 875836518 && PixelFormatType != 875836534)
    {
      v9 = 1278226488;
      goto LABEL_14;
    }
    goto LABEL_24;
  }
  if (PixelFormatType > 2016687155)
  {
    if (PixelFormatType != 2016687156)
    {
      v10 = 2019963956;
LABEL_23:
      if (PixelFormatType != v10)
        goto LABEL_25;
    }
LABEL_24:
    v7 = 3;
    goto LABEL_25;
  }
  if (PixelFormatType == 1278226736)
    goto LABEL_15;
  v9 = 1751411059;
LABEL_14:
  if (PixelFormatType == v9)
  {
LABEL_15:
    *(_BYTE *)(a1 + 287) = 0;
    if (!PlaneCount)
    {
      *(_BYTE *)(a1 + 285) = 1;
LABEL_28:
      v11 = sub_1B67C37F4(PixelFormatType);
      v12 = 0;
      v13 = v11 > 8;
      do
      {
        *(_QWORD *)(a1 + 112 + 8 * v12) = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, v12) >> v13;
        ++v12;
      }
      while (v12 < *(unsigned __int8 *)(a1 + 285));
      if (!a3)
        return 0;
      goto LABEL_35;
    }
    goto LABEL_32;
  }
LABEL_25:
  *(_BYTE *)(a1 + 287) = v7;
  if (PlaneCount)
  {
    if (PixelFormatType == 1982882104)
    {
      if (PlaneCount <= 3u)
        goto LABEL_28;
      return 4294954386;
    }
LABEL_32:
    if (PlaneCount <= 2u)
      goto LABEL_28;
    return 4294954386;
  }
  v13 = sub_1B67C37F4(PixelFormatType) > 8;
  if (!a3)
    return 0;
LABEL_35:
  v15 = CVPixelBufferGetPixelFormatType(a3);
  if (!sub_1B67C34C0(v15))
    return 4294954394;
  result = CVPixelBufferLockBaseAddress(a3, 0);
  if ((_DWORD)result)
    return result;
  *(_QWORD *)(a1 + 1248) = CVPixelBufferRetain(a3);
  if (CVPixelBufferGetWidth(a3) != *(_DWORD *)(a1 + 276) || CVPixelBufferGetHeight(a3) != *(_DWORD *)(a1 + 280))
    return 4294954394;
  if (!*(_BYTE *)(a1 + 285))
    return 0;
  v16 = 0;
  v17 = v13;
  do
  {
    v18 = (_QWORD *)(a1 + 8 * v16);
    v18[24] = CVPixelBufferGetBaseAddressOfPlane(a3, v16);
    BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a3, v16);
    result = 0;
    v18[27] = BytesPerRowOfPlane >> v17;
    v18[21] = v18[14];
    ++v16;
  }
  while (v16 < *(unsigned __int8 *)(a1 + 285));
  return result;
}

double sub_1B67C2BB8(uint64_t a1)
{
  __CVBuffer *v2;
  __CVBuffer *v3;
  double result;

  v2 = *(__CVBuffer **)(a1 + 1232);
  if (v2)
  {
    if (*(_BYTE *)(a1 + 1256))
    {
      CVPixelBufferUnlockBaseAddress(v2, *(unsigned int *)(a1 + 1240));
      *(_BYTE *)(a1 + 1256) = 0;
      v2 = *(__CVBuffer **)(a1 + 1232);
    }
    CVPixelBufferRelease(v2);
    *(_QWORD *)(a1 + 1232) = 0;
  }
  v3 = *(__CVBuffer **)(a1 + 1248);
  if (v3)
  {
    CVPixelBufferUnlockBaseAddress(v3, 0);
    CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 1248));
    *(_QWORD *)(a1 + 1248) = 0;
  }
  result = 0.0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  return result;
}

uint64_t sub_1B67C2C34(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t (*v4)(uint64_t, uint64_t, uint64_t);
  uint64_t v5;
  uint64_t v6;

  if (!*(_BYTE *)(a1 + 136))
  {
    v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 8 * a4 + 1264);
    v5 = a3;
    goto LABEL_5;
  }
  v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 8 * a4 + 1264);
  v5 = a3;
  if (*(_QWORD *)(a1 + 88) == *(_QWORD *)(a1 + 144))
  {
LABEL_5:
    v6 = *(_QWORD *)(a1 + 1232);
    return v4(a2, v5, v6);
  }
  v6 = *(_QWORD *)(a1 + 1248);
  return v4(a2, v5, v6);
}

uint64_t sub_1B67C2C7C(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1232);
}

uint64_t sub_1B67C2C84(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1232);
}

uint64_t sub_1B67C2C8C(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1248);
}

uint64_t sub_1B67C2C94(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  void *v5;
  unint64_t (*v6)(int, unint64_t, CVPixelBufferRef);

  result = sub_1B67B6CC4(a1, a2);
  if (!(_DWORD)result)
  {
    v5 = sub_1B67C2EA4;
    v6 = sub_1B67C32B0;
    if (*(_BYTE *)(a2 + 2000) == 8)
    {
      v5 = sub_1B67C2CF4;
      v6 = sub_1B67C30A0;
    }
    *(_QWORD *)(a1 + 1264) = v5;
    *(_QWORD *)(a1 + 1272) = v6;
  }
  return result;
}

uint64_t sub_1B67C2CF4(int a1, unint64_t a2, CVPixelBufferRef pixelBuffer)
{
  size_t Width;
  unint64_t v7;
  char *BaseAddressOfPlane;
  uint64_t result;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  unint64_t v17;
  char *v18;
  char *v19;
  size_t __len[2];
  __int128 v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  Width = CVPixelBufferGetWidth(pixelBuffer);
  CVPixelBufferGetHeight(pixelBuffer);
  *(_OWORD *)__len = 0u;
  v21 = 0u;
  CVPixelBufferGetExtendedPixels(pixelBuffer, __len, &__len[1], (size_t *)&v21, (size_t *)&v21 + 1);
  v7 = a1 & ~(a1 >> 31);
  BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 0);
  result = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
  v10 = result;
  v11 = a2 - v7;
  if (a2 > v7)
  {
    v12 = &BaseAddressOfPlane[result * v7];
    do
    {
      memset(&v12[-__len[0]], *v12, __len[0]);
      result = (uint64_t)memset(&v12[Width], v12[Width - 1], __len[1]);
      v12 += v10;
      --v11;
    }
    while (v11);
  }
  v13 = __len[0];
  if (a1 < 1 && (_QWORD)v21)
  {
    v14 = 0;
    v15 = &BaseAddressOfPlane[-__len[0]];
    v16 = &BaseAddressOfPlane[-v10 - __len[0]];
    do
    {
      result = (uint64_t)memcpy(v16, v15, __len[0] + Width + __len[1]);
      ++v14;
      v16 -= v10;
    }
    while ((unint64_t)v21 > v14);
    v13 = __len[0];
  }
  if (*((_QWORD *)&v21 + 1))
  {
    v17 = 0;
    v18 = &BaseAddressOfPlane[v10 * (a2 - 1) - v13];
    v19 = &BaseAddressOfPlane[v10 * a2 - v13];
    do
    {
      result = (uint64_t)memcpy(v19, v18, __len[0] + Width + __len[1]);
      ++v17;
      v19 += v10;
    }
    while (*((_QWORD *)&v21 + 1) > v17);
  }
  return result;
}

unint64_t sub_1B67C2EA4(int a1, unint64_t a2, CVPixelBufferRef pixelBuffer)
{
  size_t Width;
  unint64_t v7;
  char *BaseAddressOfPlane;
  unint64_t result;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  unint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  Width = CVPixelBufferGetWidth(pixelBuffer);
  CVPixelBufferGetHeight(pixelBuffer);
  v29 = 0u;
  v30 = 0u;
  CVPixelBufferGetExtendedPixels(pixelBuffer, (size_t *)&v29, (size_t *)&v29 + 1, (size_t *)&v30, (size_t *)&v30 + 1);
  v7 = a1 & ~(a1 >> 31);
  BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 0);
  result = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
  v10 = result >> 1;
  v11 = v29;
  v12 = 2 * (result >> 1);
  if (v7 < a2)
  {
    v13 = &BaseAddressOfPlane[2 * v10 * v7];
    v14 = &v13[2 * Width - 2];
    v15 = *((_QWORD *)&v29 + 1);
    do
    {
      if (v11)
      {
        v16 = *(_WORD *)v13;
        v17 = -v11;
        do
          *(_WORD *)&v13[2 * v17] = v16;
        while (!__CFADD__(v17++, 1));
      }
      if (v15)
      {
        v19 = *(_WORD *)v14;
        v20 = 2 * Width;
        v21 = v15;
        do
        {
          *(_WORD *)&v13[v20] = v19;
          v20 += 2;
          --v21;
        }
        while (v21);
      }
      ++v7;
      v13 += v12;
      v14 += 2 * v10;
    }
    while (v7 != a2);
  }
  if (a1 < 1 && (_QWORD)v30)
  {
    v22 = 0;
    v23 = &BaseAddressOfPlane[-2 * v11];
    v24 = &BaseAddressOfPlane[-2 * v11 + -2 * v10];
    do
    {
      result = (unint64_t)memcpy(v24, v23, 2 * (v29 + Width + *((_QWORD *)&v29 + 1)));
      ++v22;
      v24 -= 2 * v10;
    }
    while ((unint64_t)v30 > v22);
    v11 = v29;
  }
  if (*((_QWORD *)&v30 + 1))
  {
    v25 = 0;
    v26 = &BaseAddressOfPlane[-2 * v11];
    v27 = &v26[2 * v10 * (a2 - 1)];
    v28 = &v26[2 * a2 * v10];
    do
    {
      result = (unint64_t)memcpy(v28, v27, 2 * (v29 + Width + *((_QWORD *)&v29 + 1)));
      ++v25;
      v28 += v12;
    }
    while (*((_QWORD *)&v30 + 1) > v25);
  }
  return result;
}

unint64_t sub_1B67C30A0(int a1, unint64_t a2, CVPixelBufferRef pixelBuffer)
{
  size_t Width;
  size_t v7;
  unint64_t v8;
  char *BaseAddressOfPlane;
  unint64_t result;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  __int16 v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  unint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  uint64x2_t v30;
  uint64x2_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  Width = CVPixelBufferGetWidth(pixelBuffer);
  CVPixelBufferGetHeight(pixelBuffer);
  v30 = 0u;
  v31 = 0u;
  CVPixelBufferGetExtendedPixels(pixelBuffer, (size_t *)&v30, &v30.u64[1], (size_t *)&v31, &v31.u64[1]);
  v30 = vshrq_n_u64(v30, 1uLL);
  v31 = vshrq_n_u64(v31, 1uLL);
  v7 = Width >> 1;
  v8 = a1 & ~(a1 >> 31);
  BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 1uLL);
  result = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 1uLL);
  v11 = result >> 1;
  v12 = v30.i64[0];
  v13 = 2 * (result >> 1);
  if (v8 < a2)
  {
    v14 = &BaseAddressOfPlane[2 * v11 * v8];
    v15 = &v14[2 * v7 - 2];
    v16 = v30.i64[1];
    do
    {
      if (v12)
      {
        v17 = *(_WORD *)v14;
        v18 = -v12;
        do
          *(_WORD *)&v14[2 * v18] = v17;
        while (!__CFADD__(v18++, 1));
      }
      if (v16)
      {
        v20 = *(_WORD *)v15;
        v21 = 2 * v7;
        v22 = v16;
        do
        {
          *(_WORD *)&v14[v21] = v20;
          v21 += 2;
          --v22;
        }
        while (v22);
      }
      ++v8;
      v14 += v13;
      v15 += 2 * v11;
    }
    while (v8 != a2);
  }
  if (a1 < 1 && v31.i64[0])
  {
    v23 = 0;
    v24 = &BaseAddressOfPlane[-2 * v12];
    v25 = &BaseAddressOfPlane[-2 * v12 + -2 * v11];
    do
    {
      result = (unint64_t)memcpy(v25, v24, 2 * (v30.i64[0] + v7 + v30.i64[1]));
      ++v23;
      v25 -= 2 * v11;
    }
    while (v31.i64[0] > v23);
    v12 = v30.i64[0];
  }
  if (v31.i64[1])
  {
    v26 = 0;
    v27 = &BaseAddressOfPlane[-2 * v12];
    v28 = &v27[2 * v11 * (a2 - 1)];
    v29 = &v27[2 * a2 * v11];
    do
    {
      result = (unint64_t)memcpy(v29, v28, 2 * (v30.i64[0] + v7 + v30.i64[1]));
      ++v26;
      v29 += v13;
    }
    while (v31.i64[1] > v26);
  }
  return result;
}

unint64_t sub_1B67C32B0(int a1, unint64_t a2, CVPixelBufferRef pixelBuffer)
{
  size_t Width;
  size_t v7;
  unint64_t v8;
  char *BaseAddressOfPlane;
  unint64_t result;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  unint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  uint64x2_t v30;
  uint64x2_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  Width = CVPixelBufferGetWidth(pixelBuffer);
  CVPixelBufferGetHeight(pixelBuffer);
  v30 = 0u;
  v31 = 0u;
  CVPixelBufferGetExtendedPixels(pixelBuffer, (size_t *)&v30, &v30.u64[1], (size_t *)&v31, &v31.u64[1]);
  v30 = vshrq_n_u64(v30, 1uLL);
  v31 = vshrq_n_u64(v31, 1uLL);
  v7 = Width >> 1;
  v8 = a1 & ~(a1 >> 31);
  BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 1uLL);
  result = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 1uLL);
  v11 = result >> 2;
  v12 = v30.i64[0];
  v13 = 4 * (result >> 2);
  if (v8 < a2)
  {
    v14 = &BaseAddressOfPlane[4 * v11 * v8];
    v15 = &v14[4 * v7 - 4];
    v16 = v30.i64[1];
    do
    {
      if (v12)
      {
        v17 = *(_DWORD *)v14;
        v18 = -v12;
        do
          *(_DWORD *)&v14[4 * v18] = v17;
        while (!__CFADD__(v18++, 1));
      }
      if (v16)
      {
        v20 = *(_DWORD *)v15;
        v21 = 4 * v7;
        v22 = v16;
        do
        {
          *(_DWORD *)&v14[v21] = v20;
          v21 += 4;
          --v22;
        }
        while (v22);
      }
      ++v8;
      v14 += v13;
      v15 += 4 * v11;
    }
    while (v8 != a2);
  }
  if (a1 < 1 && v31.i64[0])
  {
    v23 = 0;
    v24 = &BaseAddressOfPlane[-4 * v12];
    v25 = &BaseAddressOfPlane[-4 * v12 + -4 * v11];
    do
    {
      result = (unint64_t)memcpy(v25, v24, 4 * (v30.i64[0] + v7 + v30.i64[1]));
      ++v23;
      v25 -= 4 * v11;
    }
    while (v31.i64[0] > v23);
    v12 = v30.i64[0];
  }
  if (v31.i64[1])
  {
    v26 = 0;
    v27 = &BaseAddressOfPlane[-4 * v12];
    v28 = &v27[4 * v11 * (a2 - 1)];
    v29 = &v27[4 * a2 * v11];
    do
    {
      result = (unint64_t)memcpy(v29, v28, 4 * (v30.i64[0] + v7 + v30.i64[1]));
      ++v26;
      v29 += v13;
    }
    while (v31.i64[1] > v26);
  }
  return result;
}

uint64_t sub_1B67C34C0(int a1)
{
  uint64_t result;
  int v3;
  unsigned __int16 v4;

  result = 1;
  if (a1 <= 875704949)
  {
    if (a1 <= 758674991)
    {
      if (a1 <= 645424687)
      {
        if (a1 > 641234479)
        {
          if (a1 == 641234480)
            return result;
          v4 = 30260;
        }
        else
        {
          if (a1 == 641230384)
            return result;
          v4 = 26164;
        }
        v3 = v4 | 0x26380000;
        goto LABEL_56;
      }
      if (a1 <= 645428783)
      {
        if (a1 == 645424688)
          return result;
        v3 = 645424692;
        goto LABEL_56;
      }
      if (a1 == 645428784 || a1 == 645428788)
        return result;
      v3 = 758670896;
    }
    else if (a1 > 796419631)
    {
      if (a1 <= 875704421)
      {
        if (a1 == 796419632)
          return result;
        v3 = 796423728;
        goto LABEL_56;
      }
      if (a1 == 875704422 || a1 == 875704438)
        return result;
      v3 = 875704934;
    }
    else
    {
      if (a1 <= 762869295)
      {
        if (a1 == 758674992)
          return result;
        v3 = 762865200;
        goto LABEL_56;
      }
      if (a1 == 762869296 || a1 == 792225328)
        return result;
      v3 = 792229424;
    }
    goto LABEL_56;
  }
  if (a1 > 1751411058)
  {
    if (a1 > 2019963955)
    {
      if (a1 <= 2084075055)
      {
        if (a1 == 2019963956)
          return result;
        v3 = 2084070960;
        goto LABEL_56;
      }
      if (a1 == 2084075056 || a1 == 2088265264)
        return result;
      v3 = 2088269360;
    }
    else
    {
      if (a1 <= 2016686639)
      {
        if (a1 == 1751411059)
          return result;
        v3 = 1982882104;
        goto LABEL_56;
      }
      if (a1 == 2016686640 || a1 == 2016687156)
        return result;
      v3 = 2019963440;
    }
LABEL_56:
    if (a1 != v3)
      return 0;
    return result;
  }
  if (a1 > 1496395841)
  {
    if (a1 <= 1563981359)
    {
      if (a1 == 1496395842)
        return result;
      v3 = 1563977268;
      goto LABEL_56;
    }
    if (a1 == 1563981360 || a1 == 1563981364)
      return result;
    v3 = 1568171568;
    goto LABEL_56;
  }
  if (a1 <= 875836533)
  {
    if (a1 == 875704950)
      return result;
    v3 = 875836518;
    goto LABEL_56;
  }
  if (a1 != 875836534 && a1 != 1278226488)
  {
    v3 = 1278226736;
    goto LABEL_56;
  }
  return result;
}

uint64_t sub_1B67C37F4(int a1)
{
  uint64_t result;
  int v3;
  unsigned __int16 v4;
  int v5;

  result = 8;
  if (a1 <= 1278226487)
  {
    if (a1 <= 758674991)
    {
      if (a1 <= 642527535)
      {
        if (a1 <= 641234479)
        {
          if (a1 == 641230384)
            return result;
          v5 = 641230388;
        }
        else
        {
          if (a1 == 641234480 || a1 == 641234484)
            return result;
          v5 = 642527288;
        }
      }
      else
      {
        if (a1 <= 645428783)
        {
          if (a1 == 642527536 || a1 == 645424688)
            return 10;
          v3 = 645424692;
          goto LABEL_64;
        }
        if (a1 == 645428784 || a1 == 645428788)
          return 10;
        v5 = 758670896;
      }
      goto LABEL_60;
    }
    if (a1 > 796419631)
    {
      if (a1 > 875704437)
      {
        if (a1 == 875704438 || a1 == 875836518)
          return result;
        v5 = 875836534;
      }
      else
      {
        if (a1 == 796419632 || a1 == 796423728)
          return 10;
        v5 = 875704422;
      }
      goto LABEL_60;
    }
    if (a1 <= 762869295)
    {
      if (a1 != 758674992)
      {
        v3 = 762865200;
        goto LABEL_64;
      }
      return result;
    }
    if (a1 == 762869296)
      return 10;
    if (a1 != 792225328)
    {
      v5 = 792229424;
      goto LABEL_60;
    }
  }
  else
  {
    if (a1 <= 1882469427)
    {
      if (a1 <= 1563977267)
      {
        if (a1 <= 1534617135)
        {
          if (a1 != 1278226488)
          {
            v3 = 1278226736;
            goto LABEL_64;
          }
          return result;
        }
        if (a1 == 1534617136 || a1 == 1534621232)
          return 10;
        v4 = 26160;
      }
      else
      {
        if (a1 > 1568171567)
        {
          if (a1 == 1568171568 || a1 == 1751411059)
            return 10;
          v3 = 1882468912;
          goto LABEL_64;
        }
        if (a1 == 1563977268 || a1 == 1563981360)
          return result;
        v4 = 30260;
      }
      v5 = v4 | 0x5D380000;
LABEL_60:
      if (a1 != v5)
        return 0;
      return result;
    }
    if (a1 <= 2019963439)
    {
      if (a1 <= 1982882103)
      {
        if (a1 == 1882469428 || a1 == 1885745712)
          return 10;
        v3 = 1885746228;
LABEL_64:
        if (a1 == v3)
          return 10;
        return 0;
      }
      if (a1 != 1982882104)
      {
        if (a1 != 2016686640)
        {
          v3 = 2016687156;
          goto LABEL_64;
        }
        return 10;
      }
      return result;
    }
    if (a1 <= 2084075055)
    {
      if (a1 == 2019963440 || a1 == 2019963956)
        return 10;
      v5 = 2084070960;
      goto LABEL_60;
    }
    if (a1 != 2084075056)
    {
      if (a1 != 2088269360)
      {
        v3 = 2088265264;
        goto LABEL_64;
      }
      return 10;
    }
  }
  return result;
}

uint64_t sub_1B67C3B94(uint64_t a1)
{
  uint64_t PlaneCount;
  size_t i;
  void *BaseAddressOfPlane;
  size_t v5;
  uint64_t result;
  OSType PixelFormatType;

  if (!*(_BYTE *)(a1 + 1256))
  {
    result = CVPixelBufferLockBaseAddress(*(CVPixelBufferRef *)(a1 + 1232), *(unsigned int *)(a1 + 1240));
    if ((_DWORD)result)
      return result;
    *(_BYTE *)(a1 + 1256) = 1;
  }
  PlaneCount = CVPixelBufferGetPlaneCount(*(CVPixelBufferRef *)(a1 + 1232));
  if (PlaneCount)
    goto LABEL_3;
  PixelFormatType = CVPixelBufferGetPixelFormatType(*(CVPixelBufferRef *)(a1 + 1232));
  if (!sub_1B67C3C48(PixelFormatType))
  {
    PlaneCount = 1;
LABEL_3:
    for (i = 0; i != PlaneCount; ++i)
    {
      BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(*(CVPixelBufferRef *)(a1 + 1232), i);
      v5 = a1 + 8 * i;
      if (!*(_QWORD *)(v5 + 88))
        *(_QWORD *)(v5 + 88) = BaseAddressOfPlane;
      if (*(_BYTE *)(a1 + 136))
        *(_QWORD *)(a1 + 8 * i + 144) = BaseAddressOfPlane;
    }
  }
  return 0;
}

uint64_t sub_1B67C3C48(int a1)
{
  uint64_t result;
  int v3;

  result = 1;
  if (a1 > 1278226735)
  {
    if (a1 <= 1751411058)
    {
      if (a1 == 1278226736)
        return 0;
      v3 = 1496395842;
    }
    else
    {
      if (a1 == 2019963956 || a1 == 2016687156)
        return 3;
      v3 = 1751411059;
    }
LABEL_15:
    if (a1 != v3)
      return result;
    return 0;
  }
  if (a1 > 875836517)
  {
    if (a1 != 875836518 && a1 != 875836534)
    {
      v3 = 1278226488;
      goto LABEL_15;
    }
    return 3;
  }
  if (a1 == 645424692 || a1 == 645428788)
    return 3;
  return result;
}

uint64_t sub_1B67C3D28(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  *(_QWORD *)a1 = &off_1E6A15040;
  sub_1B67C2BB8(a1);
  *(_QWORD *)a1 = off_1E6A15948;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 1168));
  std::mutex::~mutex((std::mutex *)(a1 + 1104));
  *(_DWORD *)(a1 + 1032) = 0;
  *(_OWORD *)(a1 + 1016) = 0u;
  *(_OWORD *)(a1 + 1000) = 0u;
  *(_OWORD *)(a1 + 984) = 0u;
  *(_OWORD *)(a1 + 968) = 0u;
  v2 = *(void **)(a1 + 952);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(a1 + 952) = 0;
    *(_QWORD *)(a1 + 960) = 0;
  }
  v3 = *(void **)(a1 + 664);
  if (v3)
  {
    free(v3);
    *(_QWORD *)(a1 + 664) = 0;
    *(_QWORD *)(a1 + 672) = 0;
  }
  v4 = *(void **)(a1 + 640);
  if (v4)
  {
    free(v4);
    *(_QWORD *)(a1 + 640) = 0;
    *(_QWORD *)(a1 + 648) = 0;
  }
  v5 = *(void **)(a1 + 624);
  if (v5)
  {
    free(v5);
    *(_QWORD *)(a1 + 624) = 0;
    *(_QWORD *)(a1 + 632) = 0;
  }
  v6 = *(void **)(a1 + 592);
  if (v6)
  {
    free(v6);
    *(_QWORD *)(a1 + 592) = 0;
    *(_QWORD *)(a1 + 600) = 0;
  }
  v7 = *(void **)(a1 + 576);
  if (v7)
  {
    free(v7);
    *(_QWORD *)(a1 + 576) = 0;
    *(_QWORD *)(a1 + 584) = 0;
  }
  v8 = *(void **)(a1 + 560);
  if (v8)
  {
    free(v8);
    *(_QWORD *)(a1 + 560) = 0;
    *(_QWORD *)(a1 + 568) = 0;
  }
  v9 = *(void **)(a1 + 520);
  if (v9)
  {
    free(v9);
    *(_QWORD *)(a1 + 520) = 0;
    *(_QWORD *)(a1 + 528) = 0;
  }
  v10 = *(void **)(a1 + 496);
  if (v10)
  {
    free(v10);
    *(_QWORD *)(a1 + 496) = 0;
    *(_QWORD *)(a1 + 504) = 0;
  }
  return a1;
}

void sub_1B67C3E4C(_QWORD *a1)
{
  sub_1B67C5264(a1);
  JUMPOUT(0x1BCC9814CLL);
}

uint64_t sub_1B67C3E70(uint64_t a1, uint64_t a2, __CVBuffer *a3)
{
  uint64_t v5;
  char *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  __int128 v17;
  __int128 v18;
  char *v19;

  v19 = 0;
  v5 = sub_1B67C4554(*(_QWORD *)(a1 + 48), &v19, a3, 1, *(unsigned __int8 *)(a1 + 28), a1);
  if (!(_DWORD)v5)
  {
    v7 = v19;
    if (*(_BYTE *)(a1 + 28))
      *((int32x2_t *)v19 + 30) = vsub_s32(*(int32x2_t *)(v19 + 276), vadd_s32(*(int32x2_t *)(v19 + 400), *(int32x2_t *)(v19 + 408)));
    v8 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)&v17 = *(_QWORD *)(a1 + 48);
    *((_QWORD *)&v17 + 1) = v8;
    if (v8)
    {
      v9 = (unint64_t *)(v8 + 8);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    sub_1B67C4924(&v18, (uint64_t)v7, &v17);
    sub_1B67C49BC(a2, &v18);
    v11 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
    if (*((_QWORD *)&v18 + 1))
    {
      v12 = (unint64_t *)(*((_QWORD *)&v18 + 1) + 8);
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    v14 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
    if (*((_QWORD *)&v17 + 1))
    {
      v15 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }
  return v5;
}

void sub_1B67C3F98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1B6772C88((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1B67C3FAC(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t result;
  char *v7;
  int v8;
  char v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  void *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  uint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  __int128 v51;
  char *v52;
  __int128 v53;

  v52 = 0;
  result = sub_1B67C4554(*(_QWORD *)(a1 + 48), &v52, 0, *(_DWORD *)(a1 + 24) != 0, *(unsigned __int8 *)(a1 + 28), a1);
  if ((_DWORD)result)
    return result;
  v7 = v52;
  *((_DWORD *)v52 + 170) = a2;
  v7[1228] = *(_BYTE *)(a1 + 64);
  v8 = *(_DWORD *)(a1 + 24);
  v9 = *((_DWORD *)v7 + 274);
  v10 = ~(-1 << v9);
  v11 = (*((_DWORD *)v7 + 69) + v10) >> v9;
  *((_DWORD *)v7 + 164) = v11;
  v12 = (*((_DWORD *)v7 + 70) + v10) >> v9;
  *((_DWORD *)v7 + 165) = v12;
  v13 = ((v11 << v9) + 7) >> 3;
  v14 = ((v12 << v9) + 7) >> 3;
  *((_QWORD *)v7 + 59) = v13;
  *((_QWORD *)v7 + 60) = v14;
  v15 = ((_DWORD)v13 + 7) & 0x3FFFFFF8;
  *((_QWORD *)v7 + 61) = v15;
  v16 = v14 + 3;
  *((_QWORD *)v7 + 64) = 0;
  if (v8 == 3)
  {
    result = sub_1B67C2218((void **)v7 + 65, (((_DWORD)v14 + 7) & 0x3FFFFFF8 | 2u) * (unint64_t)v15);
    if ((_DWORD)result)
      return result;
    *((_QWORD *)v7 + 64) = *((_QWORD *)v7 + 65) + 2 * *((_QWORD *)v7 + 61);
  }
  else if (v8 == 2)
  {
    v17 = v16 * (unint64_t)v15;
    v18 = v17 + 8;
    if (*((_QWORD *)v7 + 63) < v17 + 8)
    {
      if (v17 > 0x31FFFF8)
        return 4294954392;
      v19 = v7 + 496;
      v20 = (void *)*((_QWORD *)v7 + 62);
      if (v20)
      {
        free(v20);
        *v19 = 0;
        *((_QWORD *)v7 + 63) = 0;
      }
      if (malloc_type_posix_memalign((void **)v7 + 62, 0x10uLL, 2 * v18, 0x1000040BDFB0063uLL) || !*v19)
        return 4294954392;
      v21 = 0;
      do
        *(_WORD *)(*v19 + 2 * v21++) = 0;
      while (v18 != v21);
      *((_QWORD *)v7 + 63) = v18;
    }
  }
  v22 = *((_QWORD *)v7 + 60);
  v23 = 2 * *((_QWORD *)v7 + 59);
  *((_QWORD *)v7 + 67) = v23;
  v22 *= 2;
  *((_QWORD *)v7 + 68) = v22;
  v24 = v23 + 3;
  *((_QWORD *)v7 + 69) = v24;
  v25 = v22 + 3;
  if (v8 == 3)
  {
    result = sub_1B67C22BC((void **)v7 + 72, v25 * v24);
    if ((_DWORD)result)
      return result;
    v26 = *((_QWORD *)v7 + 69) * v25;
    if (*((_QWORD *)v7 + 75) >= v26)
      goto LABEL_38;
    if (v26 <= 0x1900000)
    {
      v27 = v7 + 592;
      v28 = (void *)*((_QWORD *)v7 + 74);
      if (v28)
      {
        free(v28);
        *v27 = 0;
        *((_QWORD *)v7 + 75) = 0;
      }
      if (!malloc_type_posix_memalign((void **)v7 + 74, 0x10uLL, 4 * v26, 0x100004052888210uLL) && *v27)
      {
        v29 = 0;
        do
          *(_DWORD *)(*v27 + 4 * v29++) = 0;
        while (v26 != v29);
        *((_QWORD *)v7 + 75) = v26;
        goto LABEL_38;
      }
    }
    return 4294954392;
  }
  if (v8 == 2)
  {
    v30 = v25 * v24;
    if (*((_QWORD *)v7 + 71) < (unint64_t)(v25 * v24))
    {
      if (v30 > 0x855555)
        return 4294954392;
      v31 = v7 + 560;
      v32 = (void *)*((_QWORD *)v7 + 70);
      if (v32)
      {
        free(v32);
        *v31 = 0;
        *((_QWORD *)v7 + 71) = 0;
      }
      if (malloc_type_posix_memalign((void **)v7 + 70, 0x10uLL, 12 * v30, 0x1000040E45D73ADuLL) || !*v31)
        return 4294954392;
      v33 = 0;
      v34 = v30;
      do
      {
        v35 = *v31 + v33;
        *(_DWORD *)(v35 + 8) = 0;
        *(_QWORD *)v35 = 0;
        v33 += 12;
        --v34;
      }
      while (v34);
      *((_QWORD *)v7 + 71) = v30;
    }
  }
LABEL_38:
  v36 = *((_QWORD *)v7 + 60);
  v37 = 2 * *((_QWORD *)v7 + 59) + 16;
  *((_QWORD *)v7 + 76) = v37;
  *((_QWORD *)v7 + 77) = 2 * v36;
  if (v8 < 2
    || (result = sub_1B67C2364((void **)v7 + 78, v37 * v16 + 31, 0x10uLL), !(_DWORD)result)
    && (result = sub_1B67C2364((void **)v7 + 80, (*((_QWORD *)v7 + 59) + 8) * *((_QWORD *)v7 + 77) + 31, 0x10uLL),
        !(_DWORD)result)
    && (result = sub_1B67C2414((void **)v7 + 83, (*((_DWORD *)v7 + 165) * *((_DWORD *)v7 + 164))),
        !(_DWORD)result))
  {
    v38 = (void *)*((_QWORD *)v7 + 78);
    if (v38)
      bzero(v38, *((_QWORD *)v7 + 76) * *((_QWORD *)v7 + 60));
    v39 = (void *)*((_QWORD *)v7 + 80);
    if (v39)
      bzero(v39, *((_QWORD *)v7 + 77) * *((_QWORD *)v7 + 59));
    v40 = (void *)*((_QWORD *)v7 + 64);
    if (v40)
      bzero(v40, 2 * *((_QWORD *)v7 + 60) * *((_QWORD *)v7 + 61));
    v41 = (void *)*((_QWORD *)v7 + 72);
    if (v41)
      bzero(v41, 16 * *((_QWORD *)v7 + 68) * *((_QWORD *)v7 + 69));
    *(_QWORD *)&v53 = v7 + 1104;
    BYTE8(v53) = 1;
    std::mutex::lock((std::mutex *)(v7 + 1104));
    atomic_store(0x80000000, (unsigned int *)v7 + 275);
    sub_1B678B174((uint64_t)&v53);
    std::condition_variable::notify_all((std::condition_variable *)(v7 + 1168));
    if (BYTE8(v53))
      std::mutex::unlock((std::mutex *)v53);
    v42 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)&v51 = *(_QWORD *)(a1 + 48);
    *((_QWORD *)&v51 + 1) = v42;
    if (v42)
    {
      v43 = (unint64_t *)(v42 + 8);
      do
        v44 = __ldxr(v43);
      while (__stxr(v44 + 1, v43));
    }
    sub_1B67C4924(&v53, (uint64_t)v7, &v51);
    sub_1B67C49BC(a3, &v53);
    v45 = (std::__shared_weak_count *)*((_QWORD *)&v53 + 1);
    if (*((_QWORD *)&v53 + 1))
    {
      v46 = (unint64_t *)(*((_QWORD *)&v53 + 1) + 8);
      do
        v47 = __ldaxr(v46);
      while (__stlxr(v47 - 1, v46));
      if (!v47)
      {
        ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
        std::__shared_weak_count::__release_weak(v45);
      }
    }
    v48 = (std::__shared_weak_count *)*((_QWORD *)&v51 + 1);
    if (*((_QWORD *)&v51 + 1))
    {
      v49 = (unint64_t *)(*((_QWORD *)&v51 + 1) + 8);
      do
        v50 = __ldaxr(v49);
      while (__stlxr(v50 - 1, v49));
      if (!v50)
      {
        ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
        std::__shared_weak_count::__release_weak(v48);
      }
    }
    return 0;
  }
  return result;
}

void sub_1B67C446C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, std::mutex *a13, char a14)
{
  sub_1B6772C88((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_1B67C4498(uint64_t a1, CVPixelBufferRef *pixelBufferOut)
{
  CVPixelBufferPoolRef *v4;
  uint64_t PixelBuffer;

  v4 = *(CVPixelBufferPoolRef **)(a1 + 48);
  if (*pixelBufferOut)
    CVPixelBufferRelease(*pixelBufferOut);
  PixelBuffer = CVPixelBufferPoolCreatePixelBuffer(0, *v4, pixelBufferOut);
  if ((_DWORD)PixelBuffer)
    CVPixelBufferRelease(*pixelBufferOut);
  else
    sub_1B67C4504(a1, *pixelBufferOut);
  return PixelBuffer;
}

void sub_1B67C4504(uint64_t a1, CVBufferRef buffer)
{
  const __CFDictionary *v4;
  const __CFDictionary *v5;

  v4 = *(const __CFDictionary **)(a1 + 32);
  if (v4)
    CVBufferSetAttachments(buffer, v4, kCVAttachmentMode_ShouldPropagate);
  v5 = *(const __CFDictionary **)(a1 + 40);
  if (v5)
    CVBufferSetAttachments(buffer, v5, kCVAttachmentMode_ShouldNotPropagate);
}

uint64_t sub_1B67C4554(uint64_t a1, char **a2, __CVBuffer *a3, char a4, int a5, uint64_t a6)
{
  std::mutex *v11;
  CFDictionaryRef PixelBufferAttributes;
  unint64_t v14;
  __CVBuffer *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  char *v19;
  _QWORD v21[6];
  _QWORD *v22;
  CVPixelBufferRef texture;
  CVPixelBufferRef pixelBufferOut;
  _QWORD **v25;
  _QWORD *v26;

  texture = 0;
  pixelBufferOut = 0;
  v11 = (std::mutex *)(a1 + 56);
  *a2 = 0;
  if (!a3)
  {
    if ((a4 & 1) == 0)
      goto LABEL_15;
LABEL_9:
    v16 = CVPixelBufferPoolCreatePixelBuffer(0, *(CVPixelBufferPoolRef *)a1, &pixelBufferOut);
    if ((_DWORD)v16)
    {
LABEL_13:
      v17 = 0;
      goto LABEL_22;
    }
    sub_1B67C4504(a6, pixelBufferOut);
    goto LABEL_11;
  }
  PixelBufferAttributes = CVPixelBufferPoolGetPixelBufferAttributes(*(CVPixelBufferPoolRef *)a1);
  if (!CVPixelBufferIsCompatibleWithAttributes())
  {
    v21[0] = MEMORY[0x1E0C809B0];
    v21[1] = 0x40000000;
    v21[2] = sub_1B67C50BC;
    v21[3] = &unk_1E6A16E08;
    v21[4] = a3;
    v21[5] = PixelBufferAttributes;
    v22 = v21;
    v14 = atomic_load((unint64_t *)(a1 + 168));
    if (v14 != -1)
    {
      v26 = &v22;
      v25 = &v26;
      std::__call_once((std::once_flag::_State_type *)(a1 + 168), &v25, (void (__cdecl *)(void *))sub_1B67C5204);
    }
  }
  v15 = CVPixelBufferRetain(a3);
  pixelBufferOut = v15;
  if ((a4 & 1) == 0)
    goto LABEL_15;
  if (!v15)
    goto LABEL_9;
LABEL_11:
  if (a5)
  {
    v16 = CVPixelBufferPoolCreatePixelBuffer(0, *(CVPixelBufferPoolRef *)a1, &texture);
    if ((_DWORD)v16)
      goto LABEL_13;
    sub_1B67C4504(a6, texture);
  }
LABEL_15:
  std::mutex::lock(v11);
  if (*(_QWORD *)(a1 + 48))
  {
    v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + ((*(_QWORD *)(a1 + 40) >> 6) & 0x3FFFFFFFFFFFFF8))
                    + 8 * (*(_QWORD *)(a1 + 40) & 0x1FFLL));
    *a2 = (char *)v18;
    *(_QWORD *)(v18 + 656) = 0;
    *(_WORD *)(v18 + 45) = 0;
    *(_DWORD *)(v18 + 680) = 0;
    *(_QWORD *)(v18 + 36) = 0;
    *(_BYTE *)(v18 + 300) = 0;
    *(_BYTE *)(v18 + 349) = 0;
    *(_OWORD *)(v18 + 400) = 0u;
    *(_OWORD *)(v18 + 240) = 0u;
    *(_QWORD *)(v18 + 472) = 0;
    *(_OWORD *)(v18 + 480) = 0u;
    *(_QWORD *)(v18 + 536) = 0;
    *(_OWORD *)(v18 + 544) = 0u;
    *(_OWORD *)(v18 + 608) = 0u;
    *(int64x2_t *)(a1 + 40) = vaddq_s64(*(int64x2_t *)(a1 + 40), (int64x2_t)xmmword_1B6917580);
    sub_1B67C5218(a1 + 8);
    v19 = *a2;
  }
  else
  {
    v19 = (char *)operator new(0x500uLL, MEMORY[0x1E0DE4E10]);
    if (!v19)
    {
      *a2 = 0;
      v16 = 4294954392;
      goto LABEL_27;
    }
    *((_DWORD *)v19 + 3) = 0;
    *((_DWORD *)v19 + 8) = 0;
    v19[272] = 1;
    *((_OWORD *)v19 + 31) = 0u;
    *(_OWORD *)(v19 + 520) = 0u;
    *(_OWORD *)(v19 + 664) = 0u;
    *((_WORD *)v19 + 142) = 0;
    *(_QWORD *)(v19 + 276) = 0;
    *((_OWORD *)v19 + 35) = 0u;
    *((_OWORD *)v19 + 36) = 0u;
    *((_OWORD *)v19 + 39) = 0u;
    *((_OWORD *)v19 + 40) = 0u;
    *((_QWORD *)v19 + 118) = v19;
    *(_QWORD *)(v19 + 1029) = 0;
    *(_OWORD *)(v19 + 1016) = 0u;
    *(_OWORD *)(v19 + 1000) = 0u;
    *(_OWORD *)(v19 + 984) = 0u;
    *(_OWORD *)(v19 + 968) = 0u;
    *(_OWORD *)(v19 + 952) = 0u;
    *((_OWORD *)v19 + 66) = 0u;
    *((_OWORD *)v19 + 65) = 0u;
    *((_QWORD *)v19 + 138) = 850045863;
    *(_OWORD *)(v19 + 1112) = 0u;
    *(_OWORD *)(v19 + 1128) = 0u;
    *(_OWORD *)(v19 + 1144) = 0u;
    *((_QWORD *)v19 + 145) = 0;
    *((_QWORD *)v19 + 146) = 1018212795;
    *(_OWORD *)(v19 + 1176) = 0u;
    *(_OWORD *)(v19 + 1192) = 0u;
    *((_QWORD *)v19 + 151) = 0;
    *((_QWORD *)v19 + 82) = 0;
    *(_WORD *)(v19 + 45) = 0;
    *((_DWORD *)v19 + 170) = 0;
    *(_QWORD *)(v19 + 36) = 0;
    v19[300] = 0;
    v19[349] = 0;
    *((_OWORD *)v19 + 25) = 0u;
    *((_OWORD *)v19 + 15) = 0u;
    *((_QWORD *)v19 + 61) = 0;
    *(_OWORD *)(v19 + 472) = 0u;
    *((_QWORD *)v19 + 69) = 0;
    *(_OWORD *)(v19 + 536) = 0u;
    *((_OWORD *)v19 + 37) = 0u;
    *((_OWORD *)v19 + 38) = 0u;
    *(_OWORD *)(v19 + 88) = 0u;
    *(_OWORD *)(v19 + 104) = 0u;
    *(_OWORD *)(v19 + 120) = 0u;
    *(_QWORD *)v19 = &off_1E6A15040;
    *((_QWORD *)v19 + 154) = 0;
    *((_DWORD *)v19 + 310) = 0;
    *((_QWORD *)v19 + 156) = 0;
    v19[1256] = 0;
    *a2 = v19;
  }
  if (!pixelBufferOut)
  {
LABEL_25:
    (*(void (**)(char *, _QWORD))(*(_QWORD *)v19 + 112))(v19, *(_QWORD *)(a6 + 8));
    v16 = 0;
    (*a2)[136] = a5;
LABEL_27:
    v17 = 1;
    goto LABEL_28;
  }
  v16 = (*(uint64_t (**)(char *, CVPixelBufferRef, CVPixelBufferRef))(*(_QWORD *)v19 + 64))(v19, pixelBufferOut, texture);
  if (!(_DWORD)v16)
  {
    v19 = *a2;
    goto LABEL_25;
  }
  v17 = 1;
LABEL_22:
  if (*a2)
  {
    sub_1B67C4A94((_QWORD *)(a1 + 8), a2);
    *a2 = 0;
  }
LABEL_28:
  CVPixelBufferRelease(pixelBufferOut);
  CVPixelBufferRelease(texture);
  if (v17)
    std::mutex::unlock(v11);
  return v16;
}

void sub_1B67C48E4(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1B67C4924(_QWORD *a1, uint64_t a2, __int128 *a3)
{
  uint64_t v6;
  __int128 v7;

  *a1 = a2;
  v6 = operator new();
  v7 = *a3;
  *(_QWORD *)a3 = 0;
  *((_QWORD *)a3 + 1) = 0;
  *(_QWORD *)v6 = &off_1E6A15BC8;
  *(_QWORD *)(v6 + 8) = 0;
  *(_QWORD *)(v6 + 16) = 0;
  *(_QWORD *)(v6 + 24) = a2;
  *(_OWORD *)(v6 + 32) = v7;
  a1[1] = v6;
  return a1;
}

void sub_1B67C4990(void *a1)
{
  uint64_t v1;
  uint64_t *v2;

  __cxa_begin_catch(a1);
  sub_1B67C4A20(*v2, v1);
  __cxa_rethrow();
}

void sub_1B67C49A8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t sub_1B67C49BC(uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

void sub_1B67C4A20(uint64_t a1, uint64_t a2)
{
  std::mutex *v4;
  uint64_t v5;

  v5 = a2;
  v4 = (std::mutex *)(a1 + 56);
  std::mutex::lock((std::mutex *)(a1 + 56));
  (*(void (**)(uint64_t))(*(_QWORD *)a2 + 72))(a2);
  sub_1B67C4A94((_QWORD *)(a1 + 8), &v5);
  std::mutex::unlock(v4);
}

void sub_1B67C4A80(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B67C4A94(_QWORD *a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;
  char *v26;
  uint64_t v27;
  void *v28;
  void *v29;
  unint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  __int128 v35;
  void *v36;
  __int128 v37;
  uint64_t v38;
  __int128 v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  char *v43;
  uint64_t v44;
  char *v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  unint64_t v52;
  uint64_t v53;
  char *v54;
  uint64_t v55;
  uint64_t *v56;
  char *v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  int64_t v73;
  uint64_t v74;
  unint64_t v75;
  char *v76;
  uint64_t v77;
  uint64_t i;
  _QWORD *v79;
  char *v80;
  _BYTE *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  char *v87;
  uint64_t v88;
  char *v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  uint64_t *v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  unint64_t v97;
  char *v98;
  uint64_t v99;
  char *v100;
  uint64_t *v101;
  uint64_t v102;
  uint64_t v103;
  char *v104;
  uint64_t v105;
  char *v106;
  __int128 v107;
  __int128 v108;
  uint64_t v109;
  __int128 v110;
  uint64_t v111;
  __int128 v112;

  v4 = (char *)a1[2];
  v5 = (char *)a1[1];
  v6 = v4 - v5;
  if (v4 == v5)
    v7 = 0;
  else
    v7 = ((v4 - v5) << 6) - 1;
  v9 = a1[4];
  v8 = a1[5];
  v10 = v8 + v9;
  if (v7 == v8 + v9)
  {
    if (v9 >= 0x200)
    {
      a1[4] = v9 - 512;
      v13 = *(_QWORD *)v5;
      v11 = v5 + 8;
      v12 = v13;
      a1[1] = v11;
      if ((char *)a1[3] == v4)
      {
        v14 = (uint64_t)&v11[-*a1];
        if ((unint64_t)v11 <= *a1)
        {
          if (v4 == (char *)*a1)
            v42 = 1;
          else
            v42 = (uint64_t)&v4[-*a1] >> 2;
          v43 = (char *)sub_1B677AA34(v42);
          v45 = &v43[8 * (v42 >> 2)];
          v46 = (uint64_t *)a1[1];
          v4 = v45;
          v47 = a1[2] - (_QWORD)v46;
          if (v47)
          {
            v4 = &v45[v47 & 0xFFFFFFFFFFFFFFF8];
            v48 = 8 * (v47 >> 3);
            v49 = &v43[8 * (v42 >> 2)];
            do
            {
              v50 = *v46++;
              *(_QWORD *)v49 = v50;
              v49 += 8;
              v48 -= 8;
            }
            while (v48);
          }
          v51 = (char *)*a1;
          *a1 = v43;
          a1[1] = v45;
          a1[2] = v4;
          a1[3] = &v43[8 * v44];
          if (v51)
          {
            operator delete(v51);
            v4 = (char *)a1[2];
          }
        }
        else
        {
          v15 = v14 >> 3;
          v16 = v14 >> 3 < -1;
          v17 = (v14 >> 3) + 2;
          if (v16)
            v18 = v17;
          else
            v18 = v15 + 1;
          v19 = -(v18 >> 1);
          v20 = v18 >> 1;
          v21 = &v11[-8 * v20];
          v22 = v4 - v11;
          if (v4 == v11)
          {
            v23 = v4;
          }
          else
          {
            memmove(&v11[-8 * v20], v11, v4 - v11);
            v23 = (char *)a1[1];
          }
          v4 = &v21[v22];
          a1[1] = &v23[8 * v19];
          a1[2] = &v21[v22];
        }
      }
      *(_QWORD *)v4 = v12;
LABEL_82:
      a1[2] += 8;
LABEL_83:
      v5 = (char *)a1[1];
      v8 = a1[5];
      v10 = a1[4] + v8;
      goto LABEL_84;
    }
    v24 = v6 >> 3;
    v25 = (char *)a1[3];
    v26 = (char *)*a1;
    v27 = (uint64_t)&v25[-*a1];
    if (v6 >> 3 < (unint64_t)(v27 >> 3))
    {
      v28 = operator new(0x1000uLL);
      v29 = v28;
      if (v25 == v4)
      {
        if (v26 == v5)
        {
          if (v4 == v5)
            v52 = 1;
          else
            v52 = v27 >> 2;
          v53 = 2 * v52;
          v54 = (char *)sub_1B677AA34(v52);
          v5 = &v54[(v53 + 6) & 0xFFFFFFFFFFFFFFF8];
          v56 = (uint64_t *)a1[1];
          v57 = v5;
          v58 = a1[2] - (_QWORD)v56;
          if (v58)
          {
            v57 = &v5[v58 & 0xFFFFFFFFFFFFFFF8];
            v59 = 8 * (v58 >> 3);
            v60 = v5;
            do
            {
              v61 = *v56++;
              *(_QWORD *)v60 = v61;
              v60 += 8;
              v59 -= 8;
            }
            while (v59);
          }
          v62 = (char *)*a1;
          *a1 = v54;
          a1[1] = v5;
          a1[2] = v57;
          a1[3] = &v54[8 * v55];
          if (v62)
          {
            operator delete(v62);
            v5 = (char *)a1[1];
          }
        }
        *((_QWORD *)v5 - 1) = v29;
        v63 = (char *)a1[1];
        v64 = (char *)a1[2];
        a1[1] = v63 - 8;
        v65 = *((_QWORD *)v63 - 1);
        a1[1] = v63;
        if (v64 == (char *)a1[3])
        {
          v66 = (uint64_t)&v63[-*a1];
          if ((unint64_t)v63 <= *a1)
          {
            if (v64 == (char *)*a1)
              v97 = 1;
            else
              v97 = (uint64_t)&v64[-*a1] >> 2;
            v98 = (char *)sub_1B677AA34(v97);
            v100 = &v98[8 * (v97 >> 2)];
            v101 = (uint64_t *)a1[1];
            v64 = v100;
            v102 = a1[2] - (_QWORD)v101;
            if (v102)
            {
              v64 = &v100[v102 & 0xFFFFFFFFFFFFFFF8];
              v103 = 8 * (v102 >> 3);
              v104 = &v98[8 * (v97 >> 2)];
              do
              {
                v105 = *v101++;
                *(_QWORD *)v104 = v105;
                v104 += 8;
                v103 -= 8;
              }
              while (v103);
            }
            v106 = (char *)*a1;
            *a1 = v98;
            a1[1] = v100;
            a1[2] = v64;
            a1[3] = &v98[8 * v99];
            if (v106)
            {
              operator delete(v106);
              v64 = (char *)a1[2];
            }
          }
          else
          {
            v67 = v66 >> 3;
            v16 = v66 >> 3 < -1;
            v68 = (v66 >> 3) + 2;
            if (v16)
              v69 = v68;
            else
              v69 = v67 + 1;
            v70 = -(v69 >> 1);
            v71 = v69 >> 1;
            v72 = &v63[-8 * v71];
            v73 = v64 - v63;
            if (v64 != v63)
            {
              memmove(&v63[-8 * v71], v63, v64 - v63);
              v63 = (char *)a1[1];
            }
            v64 = &v72[v73];
            a1[1] = &v63[8 * v70];
            a1[2] = &v72[v73];
          }
        }
        *(_QWORD *)v64 = v65;
      }
      else
      {
        *(_QWORD *)v4 = v28;
      }
      goto LABEL_82;
    }
    if (v25 == v26)
      v30 = 1;
    else
      v30 = v27 >> 2;
    v31 = (char *)sub_1B677AA34(v30);
    v33 = v32;
    v34 = &v31[8 * v24];
    *(_QWORD *)&v35 = v31;
    *((_QWORD *)&v35 + 1) = v34;
    v110 = v35;
    v36 = operator new(0x1000uLL);
    *(_QWORD *)&v37 = v34;
    *((_QWORD *)&v37 + 1) = &v31[8 * v33];
    if (v24 == v33)
    {
      v38 = 8 * v24;
      *(_QWORD *)&v39 = v110;
      if (v6 >= 1)
      {
        v40 = v38 >> 3;
        if (v40 >= -1)
          v41 = v40 + 1;
        else
          v41 = v40 + 2;
        v34 -= 8 * (v41 >> 1);
        *(_QWORD *)&v37 = v34;
        *((_QWORD *)&v39 + 1) = v34;
        goto LABEL_56;
      }
      v74 = v38 >> 2;
      if (v4 == v5)
        v75 = 1;
      else
        v75 = v74;
      v76 = (char *)sub_1B677AA34(v75);
      v34 = &v76[8 * (v75 >> 2)];
      *(_QWORD *)&v39 = v76;
      *((_QWORD *)&v39 + 1) = v34;
      *(_QWORD *)&v37 = v34;
      *((_QWORD *)&v37 + 1) = &v76[8 * v77];
      if (!v31)
        goto LABEL_56;
      v107 = v37;
      v110 = v39;
      operator delete(v31);
      v37 = v107;
    }
    v39 = v110;
LABEL_56:
    *(_QWORD *)v34 = v36;
    *(_QWORD *)&v37 = v37 + 8;
    for (i = a1[2]; i != a1[1]; i -= 8)
    {
      v79 = (_QWORD *)*((_QWORD *)&v39 + 1);
      if (*((_QWORD *)&v39 + 1) == (_QWORD)v39)
      {
        v81 = (_BYTE *)v37;
        if ((unint64_t)v37 >= *((_QWORD *)&v37 + 1))
        {
          if (*((_QWORD *)&v37 + 1) == *((_QWORD *)&v39 + 1))
            v86 = 1;
          else
            v86 = (uint64_t)(*((_QWORD *)&v37 + 1) - *((_QWORD *)&v39 + 1)) >> 2;
          v87 = (char *)sub_1B677AA34(v86);
          v80 = &v87[(2 * v86 + 6) & 0xFFFFFFFFFFFFFFF8];
          v89 = v80;
          v90 = v81 - (_BYTE *)v79;
          if (v81 != (_BYTE *)v79)
          {
            v89 = &v80[v90 & 0xFFFFFFFFFFFFFFF8];
            v91 = 8 * (v90 >> 3);
            v92 = v80;
            v93 = v79;
            do
            {
              v94 = *v93++;
              *(_QWORD *)v92 = v94;
              v92 += 8;
              v91 -= 8;
            }
            while (v91);
          }
          *(_QWORD *)&v39 = v87;
          *((_QWORD *)&v39 + 1) = v80;
          *(_QWORD *)&v37 = v89;
          *((_QWORD *)&v37 + 1) = &v87[8 * v88];
          if (v79)
          {
            v108 = v37;
            v112 = v39;
            operator delete(v79);
            v37 = v108;
            v39 = v112;
          }
        }
        else
        {
          v82 = (uint64_t)(*((_QWORD *)&v37 + 1) - v37) >> 3;
          if (v82 >= -1)
            v83 = v82 + 1;
          else
            v83 = v82 + 2;
          v84 = v83 >> 1;
          v85 = v37 + 8 * (v83 >> 1);
          v80 = (char *)(v85 - (v37 - *((_QWORD *)&v39 + 1)));
          if ((_QWORD)v37 == *((_QWORD *)&v39 + 1))
          {
            v81 = (_BYTE *)*((_QWORD *)&v39 + 1);
          }
          else
          {
            v109 = *((_QWORD *)&v37 + 1);
            v111 = v39;
            memmove((void *)(v85 - (v37 - *((_QWORD *)&v39 + 1))), *((const void **)&v39 + 1), v37 - *((_QWORD *)&v39 + 1));
            *((_QWORD *)&v37 + 1) = v109;
            *(_QWORD *)&v39 = v111;
          }
          *((_QWORD *)&v39 + 1) = v80;
          *(_QWORD *)&v37 = &v81[8 * v84];
        }
      }
      else
      {
        v80 = (char *)*((_QWORD *)&v39 + 1);
      }
      v95 = *(_QWORD *)(i - 8);
      *((_QWORD *)v80 - 1) = v95;
      *((_QWORD *)&v39 + 1) -= 8;
    }
    v96 = (char *)*a1;
    *(_OWORD *)a1 = v39;
    *((_OWORD *)a1 + 1) = v37;
    if (v96)
      operator delete(v96);
    goto LABEL_83;
  }
LABEL_84:
  *(_QWORD *)(*(_QWORD *)&v5[(v10 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v10 & 0x1FF)) = *a2;
  a1[5] = v8 + 1;
}

void sub_1B67C4FE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int128 a11)
{
  void *v11;

  operator delete(v11);
  if ((_QWORD)a11)
    operator delete((void *)a11);
  _Unwind_Resume(a1);
}

void sub_1B67C5014(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6A15BC8;
  sub_1B6772C88((uint64_t)&a1[1].__shared_owners_);
  std::__shared_weak_count::~__shared_weak_count(a1);
}

void sub_1B67C5044(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6A15BC8;
  sub_1B6772C88((uint64_t)&a1[1].__shared_owners_);
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC9814CLL);
}

uint64_t sub_1B67C5088(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 32;
  sub_1B67C4A20(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 24));
  return sub_1B6772C88(v1);
}

void sub_1B67C50BC(uint64_t a1)
{
  const void *Attributes;
  const __CFAllocator *v3;
  __CFString *Mutable;
  const void *v5;
  __CFString *v6;
  int v7;
  __CFString *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  Attributes = (const void *)CVPixelBufferGetAttributes();
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  sub_1B685548C(Mutable, Attributes);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v7 = 138412290;
    v8 = Mutable;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "External attributes: %@\n", (uint8_t *)&v7, 0xCu);
  }
  CFRelease(Mutable);
  v5 = *(const void **)(a1 + 40);
  v6 = CFStringCreateMutable(v3, 0);
  sub_1B685548C(v6, v5);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v7 = 138412290;
    v8 = v6;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Expected attributes: %@\n", (uint8_t *)&v7, 0xCu);
  }
  CFRelease(v6);
}

_QWORD *sub_1B67C5204(_QWORD ***a1)
{
  return (*(_QWORD *(**)(_QWORD *__return_ptr))(***a1 + 16))(**a1);
}

void sub_1B67C5218(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 32) >= 0x400uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(_QWORD *)(a1 + 8) += 8;
    *(_QWORD *)(a1 + 32) -= 512;
  }
}

_QWORD *sub_1B67C5264(_QWORD *a1)
{
  const void *v2;
  const void *v3;

  *a1 = &off_1E6A15618;
  v2 = (const void *)a1[4];
  if (v2)
    CFRelease(v2);
  v3 = (const void *)a1[5];
  if (v3)
    CFRelease(v3);
  sub_1B6772C88((uint64_t)(a1 + 6));
  *a1 = off_1E6A14BB0;
  sub_1B6772C88((uint64_t)(a1 + 1));
  return a1;
}

uint64_t sub_1B67C52D0(int a1, int a2, int a3, int a4)
{
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  BOOL v13;
  int v14;
  int v15;
  int v16;
  BOOL v17;
  __CFDictionary *v18;
  CFMutableArrayRef Mutable;
  __CFArray *v20;
  const char *v21;
  const char *v22;
  const void *v23;
  const void *v24;
  _DWORD *v25;
  const __CFDictionary *DescriptionWithPixelFormatType;
  const __CFArray *Value;
  const __CFArray *v28;
  CFTypeID v29;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v31;
  CFTypeID v32;
  const __CFNumber *v33;
  const __CFNumber *v34;
  CFTypeID v35;
  CFNumberRef v36;
  CFNumberRef v37;
  int v39;
  int *v40;
  CFNumberRef v41;
  CFNumberRef v42;
  int v43;
  __CFString *v44;
  uint64_t v45;
  __CFDictionary *v47;
  _DWORD valuePtr[2];
  __int16 v49;
  __CFString *v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v47 = 0;
  if (sub_1B67EE3C8())
  {
    if (a4 == 1752589105 || a4 == 1718908520)
    {
      v8 = 64;
      v9 = 160;
    }
    else
    {
      v8 = 96;
      v9 = 192;
    }
    v12 = 16 - (a1 & 0xF);
    if ((a1 & 0xF) == 0)
      v12 = 0;
    v13 = __OFSUB__(v9, a1);
    v14 = v9 - a1;
    if ((v14 < 0) ^ v13 | (v14 == 0))
      v10 = v12;
    else
      v10 = v14;
    v15 = 16 - (a2 & 0xF);
    if ((a2 & 0xF) == 0)
      v15 = 0;
    v13 = __OFSUB__(v8, a2);
    v16 = v8 - a2;
    if ((v16 < 0) ^ v13 | (v16 == 0))
      v11 = v15;
    else
      v11 = v16;
  }
  else
  {
    v10 = 0;
    v11 = 0;
  }
  sub_1B67C5780(a1, a2, 0, v10, 0, v11, 0, &v47);
  v17 = 0;
  if (a1 >= 1 && a2 >= 1)
    v17 = (a1 < 0xC1 || a2 <= 0x60) && (v11 | v10) != 0;
  v18 = v47;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
    goto LABEL_71;
  v20 = Mutable;
  if (a4 != 1684632424 && a4 != 1752589105 && a4 != 1718908520)
  {
    v21 = "f024v024";
    v22 = "0v8&0f8&0v8-0v8/0v8|0f8-0f8/0f8|";
    if (v17)
      goto LABEL_62;
    goto LABEL_49;
  }
  if ((a3 & 0xFFFFFFFD) == 1)
  {
    v21 = "f024v0248a0v800L";
    v22 = "0v8&0f8&80v&0v8-0v8/0v8|0f8-0f8/0f8|";
    if (v17)
      goto LABEL_62;
LABEL_49:
    if (*(_DWORD *)v22)
    {
      v23 = (const void *)*MEMORY[0x1E0CA91B0];
      v24 = (const void *)*MEMORY[0x1E0CA9158];
      v25 = v22 + 4;
      do
      {
        DescriptionWithPixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
        if (DescriptionWithPixelFormatType)
        {
          Value = (const __CFArray *)CFDictionaryGetValue(DescriptionWithPixelFormatType, v23);
          if (Value)
          {
            v28 = Value;
            v29 = CFGetTypeID(Value);
            if (v29 == CFArrayGetTypeID())
            {
              ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v28, 0);
              if (ValueAtIndex)
              {
                v31 = ValueAtIndex;
                v32 = CFGetTypeID(ValueAtIndex);
                if (v32 == CFDictionaryGetTypeID())
                {
                  valuePtr[0] = 0;
                  v33 = (const __CFNumber *)CFDictionaryGetValue(v31, v24);
                  if (v33)
                  {
                    v34 = v33;
                    v35 = CFGetTypeID(v33);
                    if (v35 == CFNumberGetTypeID())
                    {
                      CFNumberGetValue(v34, kCFNumberSInt32Type, valuePtr);
                      if ((valuePtr[0] - 5) >= 0xFFFFFFFE)
                      {
                        valuePtr[0] = *(v25 - 1);
                        v36 = CFNumberCreate(0, kCFNumberSInt32Type, valuePtr);
                        if (!v36)
                          goto LABEL_70;
                        v37 = v36;
                        CFArrayAppendValue(v20, v36);
                        CFRelease(v37);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      while (*v25++);
    }
    goto LABEL_62;
  }
  if (a3 <= 99)
  {
    if (a3 == 2)
    {
      v21 = "024x02fxf024v024010Lsidh";
      v22 = "0vx&0fx&";
      if (v17)
        goto LABEL_62;
      goto LABEL_49;
    }
    if (a3 == 20)
    {
      v21 = "800L";
LABEL_40:
      v22 = (const char *)&dword_1B6920400;
      if (v17)
        goto LABEL_62;
      goto LABEL_49;
    }
  }
  else
  {
    switch(a3)
    {
      case 100:
        v21 = "f444v444";
        v22 = "4v8&4f8&";
        if (v17)
          goto LABEL_62;
        goto LABEL_49;
      case 116:
        v21 = "f444v444444x44fx";
        v22 = "4fx&4vx&";
        if (v17)
          goto LABEL_62;
        goto LABEL_49;
      case 132:
        v21 = "010Lsidh";
        goto LABEL_40;
    }
  }
  v21 = "024x02fxf024v024f444v444800L444x44fx010Lsidh8a0v";
  v22 = "0v8&0f8&4fx&4vx&0v8-0v8/0v8|0vx-0vx|0vx/0f8-0f8/0f8|0fx&0fx/0fx|";
  if (!v17)
    goto LABEL_49;
LABEL_62:
  v39 = *(_DWORD *)v21;
  if (!*(_DWORD *)v21)
  {
LABEL_66:
    CFDictionarySetValue(v18, (const void *)*MEMORY[0x1E0CA9040], v20);
    CFRelease(v20);
    v44 = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    sub_1B685548C(v44, v18);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      valuePtr[0] = 67109378;
      valuePtr[1] = a3;
      v49 = 2114;
      v50 = v44;
      _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Buffer attributes for profile %d %{public}@", (uint8_t *)valuePtr, 0x12u);
    }
    CFRelease(v44);
    v45 = VTEncoderSessionSetPixelBufferAttributes();
    if (v18)
      goto LABEL_72;
    return v45;
  }
  v40 = (int *)(v21 + 4);
  while (1)
  {
    valuePtr[0] = v39;
    v41 = CFNumberCreate(0, kCFNumberSInt32Type, valuePtr);
    if (!v41)
      break;
    v42 = v41;
    CFArrayAppendValue(v20, v41);
    CFRelease(v42);
    v43 = *v40++;
    v39 = v43;
    if (!v43)
      goto LABEL_66;
  }
LABEL_70:
  CFRelease(v20);
LABEL_71:
  v45 = 4294954392;
  if (v18)
LABEL_72:
    CFRelease(v18);
  return v45;
}

void sub_1B67C5780(int a1, int a2, int a3, int a4, int a5, int a6, int a7, __CFDictionary **a8)
{
  __CFDictionary *Mutable;
  __CFDictionary *v17;
  CFMutableDictionaryRef v18;
  CFMutableDictionaryRef v19;
  CFNumberRef v20;
  CFNumberRef v21;
  CFArrayRef v22;
  CFArrayRef v23;
  int valuePtr;
  void *values[2];

  values[1] = *(void **)MEMORY[0x1E0C80C00];
  *a8 = 0;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v17 = Mutable;
  if (!Mutable)
    goto LABEL_17;
  sub_1B67C5A00(Mutable, (const void *)*MEMORY[0x1E0CA90E0], a1);
  sub_1B67C5A00(v17, (const void *)*MEMORY[0x1E0CA8FD8], a2);
  if (a7)
    sub_1B67C5A00(v17, (const void *)*MEMORY[0x1E0CA9040], a7);
  sub_1B67C5A60(v17, (const void *)*MEMORY[0x1E0CA8F68]);
  sub_1B67C5A60(v17, (const void *)*MEMORY[0x1E0CA9048]);
  if (a4 | a3 | a5 | a6)
  {
    sub_1B67C5A00(v17, (const void *)*MEMORY[0x1E0CA8FB0], a3);
    sub_1B67C5A00(v17, (const void *)*MEMORY[0x1E0CA8FC0], a5);
    sub_1B67C5A00(v17, (const void *)*MEMORY[0x1E0CA8FB8], a4);
  }
  else
  {
    if ((a1 & 0xF) != 0)
      sub_1B67C5A00(v17, (const void *)*MEMORY[0x1E0CA8FB8], 16 - (a1 & 0xF));
    if ((a2 & 0xF) == 0)
      goto LABEL_11;
    a6 = 16 - (a2 & 0xF);
  }
  sub_1B67C5A00(v17, (const void *)*MEMORY[0x1E0CA8FA0], a6);
LABEL_11:
  v18 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v18)
  {
    v19 = v18;
    CFDictionaryAddValue(v17, (const void *)*MEMORY[0x1E0CA8FF0], v18);
    CFRelease(v19);
  }
  valuePtr = 0;
  v20 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  if (v20)
  {
    v21 = v20;
    values[0] = v20;
    v22 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x1E0C9B378]);
    if (v22)
    {
      v23 = v22;
      CFDictionaryAddValue(v17, (const void *)*MEMORY[0x1E0CA8F80], v22);
      CFRelease(v23);
    }
    CFRelease(v21);
  }
LABEL_17:
  *a8 = v17;
}

void sub_1B67C5A00(__CFDictionary *a1, const void *a2, int a3)
{
  CFNumberRef v5;
  int valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(a1, a2, v5);
  CFRelease(v5);
}

void sub_1B67C5A60(__CFDictionary *a1, const void *a2)
{
  CFNumberRef v4;
  uint64_t valuePtr;

  valuePtr = 64;
  v4 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  CFDictionaryAddValue(a1, a2, v4);
  CFRelease(v4);
}

uint64_t sub_1B67C5AC4(unsigned __int8 *a1, int *a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t result;

  v2 = a1[2000];
  if (v2 != a1[2002])
    return 4294954386;
  if ((v2 - 9) >= 2)
  {
    if (v2 != 8)
      return 4294954386;
    v5 = a1[173];
    if (a1[173])
    {
      if (v5 == 3)
      {
        v6 = a1[1903];
        v7 = 875836518;
      }
      else
      {
        if (v5 != 1)
          return 4294954386;
        v6 = a1[1903];
        v7 = 875704422;
      }
      if (v6)
        v4 = v7;
      else
        v4 = v7 | 0x10;
      goto LABEL_24;
    }
    v4 = 1278226488;
  }
  else
  {
    v3 = a1[173];
    if (a1[173])
    {
      if (v3 == 3)
      {
        if (a1[1903])
          v4 = 2019963956;
        else
          v4 = 2016687156;
        goto LABEL_24;
      }
      if (v3 == 1)
      {
        if (a1[1903])
          v4 = 2019963440;
        else
          v4 = 2016686640;
        goto LABEL_24;
      }
      return 4294954386;
    }
    v4 = 1278226736;
  }
LABEL_24:
  result = 0;
  *a2 = v4;
  return result;
}

uint64_t sub_1B67C5BB0(uint64_t a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
  *(_QWORD *)(a1 + 40) = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = *(void ***)(a1 + 16);
      v2 = (void **)(*(_QWORD *)(a1 + 8) + 8);
      *(_QWORD *)(a1 + 8) = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 256;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    v6 = 512;
LABEL_7:
    *(_QWORD *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    v9 = *(_QWORD *)(a1 + 8);
    v8 = *(_QWORD *)(a1 + 16);
    if (v8 != v9)
      *(_QWORD *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t sub_1B67C5C74(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;
  uint64_t v4;

  v2 = a1 + 8;
  for (i = *(_QWORD *)(a1 + 48); i; i = *(_QWORD *)(a1 + 48))
  {
    v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + ((*(_QWORD *)(a1 + 40) >> 6) & 0x3FFFFFFFFFFFFF8))
                   + 8 * (*(_QWORD *)(a1 + 40) & 0x1FFLL));
    ++*(_QWORD *)(a1 + 40);
    *(_QWORD *)(a1 + 48) = i - 1;
    sub_1B67C5218(v2);
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  CVPixelBufferPoolRelease(*(CVPixelBufferPoolRef *)a1);
  std::mutex::~mutex((std::mutex *)(a1 + 56));
  sub_1B67C5BB0(v2);
  return a1;
}

uint64_t sub_1B67C5D10(uint64_t *a1, int a2, int a3, void *a4, uint64_t *a5, int a6)
{
  int v6;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  const __CFDictionary *v17;
  const __CFArray *v18;
  const __CFDictionary *v19;
  uint64_t v20;
  __CVPixelBufferPool *v21;
  char *v22;
  void *v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  uint64_t v27;
  CFStringRef StringForIntegerCodePoint;
  CFStringRef v29;
  CFStringRef v30;
  const void *v31;
  __CFDictionary *v32;
  CFNumberRef v33;
  CFNumberRef v34;
  CFNumberRef v35;
  __CFDictionary *v36;
  uint64_t v37;
  uint64_t v39;
  void *value;
  __CFDictionary *Mutable;
  __CFDictionary *theDict;
  int v43;
  CFDictionaryRef resolvedDictionaryOut;
  __CFDictionary *v45;
  CVPixelBufferPoolRef poolOut;
  void *values[3];

  v6 = a6;
  values[2] = *(void **)MEMORY[0x1E0C80C00];
  v45 = 0;
  poolOut = 0;
  resolvedDictionaryOut = 0;
  v11 = *a1;
  if (a2)
    v12 = *(unsigned __int8 *)(v11 + 2013) + 7;
  else
    v12 = 0;
  v13 = *(_DWORD *)(v11 + 2032);
  v14 = *(_DWORD *)(v11 + 2040);
  v16 = *(_DWORD *)(v11 + 176);
  v15 = *(_DWORD *)(v11 + 180);
  if (!a6)
  {
    v43 = 0;
    v20 = sub_1B67C5AC4((unsigned __int8 *)v11, &v43);
    if ((_DWORD)v20)
      goto LABEL_47;
    v6 = v43;
  }
  sub_1B67C5780(v16 - v13, v15 - v14, v12, v13 + v12, v12, v14 + v12, v6, &v45);
  v17 = v45;
  if (a4
    && (values[0] = v45, values[1] = a4, (v18 = CFArrayCreate(0, (const void **)values, 2, 0)) != 0)
    && (CVPixelBufferCreateResolvedAttributesDictionary(0, v18, &resolvedDictionaryOut),
        CFRelease(v18),
        resolvedDictionaryOut))
  {
    v19 = v17;
    v17 = resolvedDictionaryOut;
  }
  else
  {
    v19 = 0;
    resolvedDictionaryOut = v17;
    v45 = 0;
  }
  v20 = CVPixelBufferPoolCreate(0, 0, v17, &poolOut);
  if ((_DWORD)v20)
  {
LABEL_45:
    if (!v19)
      goto LABEL_47;
    goto LABEL_46;
  }
  v21 = poolOut;
  v22 = (char *)operator new(0xB0uLL, MEMORY[0x1E0DE4E10]);
  if (!v22)
  {
LABEL_44:
    v20 = 4294954392;
    goto LABEL_45;
  }
  v23 = v22;
  *(_OWORD *)(v22 + 8) = 0u;
  *(_OWORD *)(v22 + 40) = 0u;
  *(_OWORD *)(v22 + 24) = 0u;
  *((_QWORD *)v22 + 7) = 850045863;
  *((_OWORD *)v22 + 4) = 0u;
  *((_OWORD *)v22 + 5) = 0u;
  *((_OWORD *)v22 + 6) = 0u;
  *((_DWORD *)v22 + 38) = 0;
  *((_QWORD *)v22 + 14) = 0;
  *((_QWORD *)v22 + 15) = sub_1B68527F8;
  *((_QWORD *)v22 + 16) = sub_1B6871CD4;
  *((_QWORD *)v22 + 17) = sub_1B6852840;
  *((_QWORD *)v22 + 18) = sub_1B6871D78;
  *((_QWORD *)v22 + 20) = sub_1B6871E1C;
  *((_QWORD *)v22 + 21) = 0;
  *(_QWORD *)v22 = v21;
  CVPixelBufferPoolRetain(v21);
  v24 = operator new(0x48uLL, MEMORY[0x1E0DE4E10]);
  if (!v24)
  {
    *a5 = 0;
LABEL_43:
    v37 = sub_1B67C5C74((uint64_t)v23);
    MEMORY[0x1BCC9814C](v37, 0x10A0C40507A846CLL);
    goto LABEL_44;
  }
  v25 = v24;
  v24[1] = 0;
  v24[2] = 0;
  *(_QWORD *)((char *)v24 + 21) = 0;
  *v24 = &off_1E6A15618;
  v24[6] = v23;
  values[0] = v23;
  v26 = (_QWORD *)operator new();
  *v26 = &off_1E6A15D70;
  v26[1] = 0;
  v26[2] = 0;
  v26[3] = v23;
  v25[7] = v26;
  *((_BYTE *)v25 + 64) = 0;
  v25[4] = 0;
  v25[5] = 0;
  *a5 = (uint64_t)v25;
  v27 = *a1;
  theDict = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!theDict)
    goto LABEL_43;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    goto LABEL_43;
  StringForIntegerCodePoint = CVColorPrimariesGetStringForIntegerCodePoint(*(unsigned __int8 *)(v27 + 1904));
  v29 = CVTransferFunctionGetStringForIntegerCodePoint(*(unsigned __int8 *)(v27 + 1905));
  v30 = CVYCbCrMatrixGetStringForIntegerCodePoint(*(unsigned __int8 *)(v27 + 1906));
  v31 = (const void *)sub_1B67C62B0(*(unsigned __int8 *)(v27 + 1907));
  value = (void *)sub_1B67C62B0(*(unsigned __int8 *)(v27 + 1908));
  if (StringForIntegerCodePoint)
    CFDictionaryAddValue(theDict, (const void *)*MEMORY[0x1E0CA8D68], StringForIntegerCodePoint);
  if (v29)
    CFDictionaryAddValue(theDict, (const void *)*MEMORY[0x1E0CA8E98], v29);
  if (v30)
    CFDictionaryAddValue(theDict, (const void *)*MEMORY[0x1E0CA8EE8], v30);
  if (v31)
    CFDictionaryAddValue(theDict, (const void *)*MEMORY[0x1E0CA8CE8], v31);
  if (value)
    CFDictionaryAddValue(theDict, (const void *)*MEMORY[0x1E0CA8CE0], value);
  if (*(_WORD *)(v27 + 1896))
  {
    if (*(_WORD *)(v27 + 1898))
    {
      v32 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v32)
      {
        LODWORD(values[0]) = *(unsigned __int16 *)(v27 + 1896);
        v33 = CFNumberCreate(0, kCFNumberSInt32Type, values);
        if (v33)
        {
          CFDictionaryAddValue(v32, (const void *)*MEMORY[0x1E0CA8E60], v33);
          CFRelease(v33);
        }
        LODWORD(values[0]) = *(unsigned __int16 *)(v27 + 1898);
        v34 = CFNumberCreate(0, kCFNumberSInt32Type, values);
        if (v34)
        {
          CFDictionaryAddValue(v32, (const void *)*MEMORY[0x1E0CA8E70], v34);
          CFRelease(v34);
        }
        CFDictionaryAddValue(theDict, (const void *)*MEMORY[0x1E0CA8E68], v32);
        CFRelease(v32);
      }
    }
  }
  if (*(unsigned __int8 *)(v27 + 2000) >= 9u)
  {
    LODWORD(values[0]) = *(unsigned __int8 *)(v27 + 2000);
    v35 = CFNumberCreate(0, kCFNumberSInt32Type, values);
    if (v35)
    {
      CFDictionaryAddValue(Mutable, CFSTR("VPImageBufferLSBAligned"), v35);
      CFRelease(v35);
    }
  }
  if (!CFDictionaryGetCount(theDict))
  {
    CFRelease(theDict);
    theDict = 0;
  }
  if (CFDictionaryGetCount(Mutable))
  {
    v36 = Mutable;
  }
  else
  {
    CFRelease(Mutable);
    v36 = 0;
  }
  v25[4] = theDict;
  v25[5] = v36;
  v39 = *a5;
  *(_DWORD *)(v39 + 24) = a3;
  sub_1B67B665C((_QWORD *)(v39 + 8), *a1, a1[1]);
  v20 = 0;
  if (v19)
LABEL_46:
    CFRelease(v19);
LABEL_47:
  if (resolvedDictionaryOut)
    CFRelease(resolvedDictionaryOut);
  CVPixelBufferPoolRelease(poolOut);
  return v20;
}

void sub_1B67C6254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  _QWORD *v8;
  uint64_t v9;
  va_list va;

  va_start(va, a8);
  sub_1B67C6328((uint64_t *)va);
  *v8 = off_1E6A14BB0;
  sub_1B6772C88(v9);
  MEMORY[0x1BCC98134](v8, MEMORY[0x1E0DE4E10]);
  _Unwind_Resume(a1);
}

uint64_t sub_1B67C62B0(int a1)
{
  uint64_t *v1;
  uint64_t result;

  switch(a1)
  {
    case 0:
      v1 = (uint64_t *)MEMORY[0x1E0CA8D10];
      goto LABEL_9;
    case 1:
      v1 = (uint64_t *)MEMORY[0x1E0CA8D00];
      goto LABEL_9;
    case 2:
      v1 = (uint64_t *)MEMORY[0x1E0CA8D20];
      goto LABEL_9;
    case 3:
      v1 = (uint64_t *)MEMORY[0x1E0CA8D18];
      goto LABEL_9;
    case 4:
      v1 = (uint64_t *)MEMORY[0x1E0CA8CF8];
      goto LABEL_9;
    case 5:
      v1 = (uint64_t *)MEMORY[0x1E0CA8CF0];
LABEL_9:
      result = *v1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t sub_1B67C6328(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_1B67C5C74(result);
    JUMPOUT(0x1BCC9814CLL);
  }
  return result;
}

void sub_1B67C6368(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCC9814CLL);
}

uint64_t sub_1B67C638C(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
  {
    sub_1B67C5C74(result);
    JUMPOUT(0x1BCC9814CLL);
  }
  return result;
}

uint64_t sub_1B67C63C4(uint64_t a1)
{
  _OWORD *v2;

  *(_OWORD *)(a1 + 177) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 194) = 0u;
  *(_OWORD *)(a1 + 210) = 0u;
  *(_OWORD *)(a1 + 226) = 0u;
  *(_OWORD *)(a1 + 242) = 0u;
  *(_OWORD *)(a1 + 254) = 0u;
  *(_DWORD *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 276) = 0;
  *(_DWORD *)(a1 + 492) = 0;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 1024) = 0u;
  *(_OWORD *)(a1 + 1360) = 0u;
  *(_OWORD *)(a1 + 1376) = 0u;
  *(_QWORD *)(a1 + 1392) = 0;
  *(_DWORD *)(a1 + 1840) = 8;
  *(_BYTE *)(a1 + 1844) = 0;
  v2 = (_OWORD *)(a1 + 3464);
  *(_QWORD *)(a1 + 3528) = 0;
  *(_QWORD *)(a1 + 3512) = 0;
  *(_QWORD *)(a1 + 3520) = 0;
  bzero((void *)(a1 + 3544), 0x210uLL);
  *(_OWORD *)(a1 + 4184) = 0u;
  *(_OWORD *)(a1 + 4168) = 0u;
  *v2 = 0u;
  v2[1] = 0u;
  *(_QWORD *)(a1 + 3496) = 0;
  *(_BYTE *)(a1 + 627) = 1;
  *(_WORD *)a1 = 1;
  *(_BYTE *)(a1 + 2) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) = 258;
  *(_BYTE *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_QWORD *)(a1 + 542) = 0;
  *(_BYTE *)(a1 + 550) = 1;
  *(_DWORD *)(a1 + 552) = 0;
  *(_BYTE *)(a1 + 556) = 0;
  *(_WORD *)(a1 + 576) = 0;
  *(_QWORD *)(a1 + 1416) = 0;
  return a1;
}

uint64_t sub_1B67C64E8(uint64_t result, __int16 *a2, int a3, int a4, int a5, int a6)
{
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 *v13;
  uint64_t v14;
  __int16 *v15;
  unsigned int v16;
  unsigned __int8 *v17;
  uint64_t v18;
  uint64_t v19;
  __int16 *v20;
  unsigned int v21;

  v10 = result;
  v11 = *(_QWORD **)(result + 1360);
  v12 = v11[69];
  if (a4 && (a4 & 7) == 0 && a5 >= 4)
  {
    v13 = (unsigned __int8 *)(v11[78] + v11[76] * ((uint64_t)a4 >> 3) + (a3 >> 2));
    v14 = a5 >> 2;
    v15 = &a2[-6 * v12];
    do
    {
      result = sub_1B67C732C(a2, v15, v10 + 4080);
      v16 = *v13;
      if (v16 <= result)
        LOBYTE(v16) = result;
      *v13++ = v16;
      v15 += 6;
      --v14;
    }
    while (v14);
  }
  if (a3 && (a3 & 7) == 0 && a6 >= 4)
  {
    v17 = (unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(v10 + 1360) + 640)
                            + *(_QWORD *)(*(_QWORD *)(v10 + 1360) + 616) * ((uint64_t)a3 >> 3)
                            + (a4 >> 2));
    v18 = a6 >> 2;
    v19 = v10 + 4080;
    v20 = a2 - 6;
    do
    {
      result = sub_1B67C732C(a2, v20, v19);
      v21 = *v17;
      if (v21 <= result)
        LOBYTE(v21) = result;
      *v17++ = v21;
      v20 += 6 * v12;
      --v18;
    }
    while (v18);
  }
  return result;
}

uint64_t sub_1B67C661C(uint64_t result, __int16 *a2, int a3, int a4, int a5, int a6)
{
  _QWORD *v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  __int16 *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  unsigned int v17;
  int v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  __int16 *v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  unsigned int v29;
  int v30;

  v6 = *(_QWORD **)(result + 1360);
  v7 = v6[69];
  if (a4 && (a4 & 7) == 0 && a5 >= 4)
  {
    v8 = (_BYTE *)(v6[78] + v6[76] * ((uint64_t)a4 >> 3) + (a3 >> 2));
    v9 = a5 >> 2;
    v10 = result + 4080;
    v11 = &a2[-6 * v7];
    do
    {
      v12 = *((char *)a2 + 8);
      if (v12 == -1)
        v13 = 0;
      else
        v13 = *(unsigned __int8 *)(v10 + v12);
      v14 = *((char *)v11 + 8);
      if (v14 == -1)
        v15 = 0;
      else
        v15 = *(unsigned __int8 *)(v10 + v14);
      if (v13 != v15)
        goto LABEL_15;
      v16 = *a2 - *v11;
      if (v16 < 0)
        v16 = *v11 - *a2;
      if (v16 <= 3)
      {
        v18 = a2[1] - v11[1];
        if (v18 < 0)
          v18 = v11[1] - a2[1];
        v17 = v18 > 3;
      }
      else
      {
LABEL_15:
        v17 = 1;
      }
      if (*v8 > v17)
        LOBYTE(v17) = *v8;
      *v8++ = v17;
      v11 += 6;
      --v9;
    }
    while (v9);
  }
  if (a3 && (a3 & 7) == 0 && a6 >= 4)
  {
    v19 = (_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 1360) + 640)
                  + *(_QWORD *)(*(_QWORD *)(result + 1360) + 616) * ((uint64_t)a3 >> 3)
                  + (a4 >> 2));
    v20 = a6 >> 2;
    v21 = result + 4080;
    v22 = a2 - 2;
    v23 = 12 * v7;
    do
    {
      v24 = *((char *)a2 + 8);
      if (v24 == -1)
        v25 = 0;
      else
        v25 = *(unsigned __int8 *)(v21 + v24);
      v26 = *(char *)v22;
      if (v26 == -1)
        v27 = 0;
      else
        v27 = *(unsigned __int8 *)(v21 + v26);
      if (v25 != v27)
        goto LABEL_36;
      v28 = *a2 - *(v22 - 4);
      if (v28 < 0)
        v28 = *(v22 - 4) - *a2;
      if (v28 <= 3)
      {
        v30 = a2[1] - *(v22 - 3);
        if (v30 < 0)
          v30 = *(v22 - 3) - a2[1];
        v29 = v30 > 3;
      }
      else
      {
LABEL_36:
        v29 = 1;
      }
      if (*v19 > v29)
        LOBYTE(v29) = *v19;
      *v19++ = v29;
      v22 = (__int16 *)((char *)v22 + v23);
      --v20;
    }
    while (v20);
  }
  return result;
}

uint64_t sub_1B67C67C8(uint64_t result, __int16 *a2, int a3, int a4, int a5, int a6)
{
  _QWORD *v6;
  uint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  __int16 *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  unsigned int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  unsigned __int8 *v26;
  uint64_t v27;
  uint64_t v28;
  __int16 *v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  int v38;
  unsigned int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;

  v6 = *(_QWORD **)(result + 1360);
  v7 = v6[69];
  if (a4 && (a4 & 7) == 0 && a5 >= 4)
  {
    v8 = (unsigned __int8 *)(v6[78] + v6[76] * ((uint64_t)a4 >> 3) + (a3 >> 2));
    v9 = a5 >> 2;
    v10 = result + 4080;
    v11 = &a2[-6 * v7 + 2];
    do
    {
      v12 = *((char *)a2 + 8);
      if (v12 == -1)
        v13 = 0;
      else
        v13 = *(unsigned __int8 *)(v10 + v12);
      v14 = *((char *)a2 + 9);
      if (v14 == -1)
        v15 = 0;
      else
        v15 = *(unsigned __int8 *)(v10 + v14 + 16);
      v16 = *((char *)v11 + 4);
      if (v16 == -1)
        v17 = 0;
      else
        v17 = *(unsigned __int8 *)(v10 + v16);
      v18 = *((char *)v11 + 5);
      if (v18 == -1)
        v19 = 0;
      else
        v19 = *(unsigned __int8 *)(v10 + v18 + 16);
      v20 = 1;
      if (v13 == v17 && v15 == v19)
      {
        v21 = *(v11 - 2) - *a2;
        if (v21 < 0)
          v21 = *a2 - *(v11 - 2);
        if (v21 <= 3)
        {
          v22 = *(v11 - 1) - a2[1];
          if (v22 < 0)
            v22 = a2[1] - *(v11 - 1);
          if (v22 <= 3)
          {
            v23 = *v11 - a2[2];
            if (v23 < 0)
              v23 = a2[2] - *v11;
            if (v23 <= 3)
            {
              v24 = v11[1] - a2[3];
              if (v24 < 0)
                v24 = a2[3] - v11[1];
              v20 = v24 > 3;
            }
          }
        }
      }
      v25 = *v8;
      if (v25 <= v20)
        LOBYTE(v25) = v20;
      *v8++ = v25;
      v11 += 6;
      --v9;
    }
    while (v9);
  }
  if (a3 && (a3 & 7) == 0 && a6 >= 4)
  {
    v26 = (unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(result + 1360) + 640)
                            + *(_QWORD *)(*(_QWORD *)(result + 1360) + 616) * ((uint64_t)a3 >> 3)
                            + (a4 >> 2));
    v27 = a6 >> 2;
    v28 = result + 4080;
    v29 = a2 - 3;
    v30 = 12 * v7;
    do
    {
      v31 = *((char *)a2 + 8);
      if (v31 == -1)
        v32 = 0;
      else
        v32 = *(unsigned __int8 *)(v28 + v31);
      v33 = *((char *)a2 + 9);
      if (v33 == -1)
        v34 = 0;
      else
        v34 = *(unsigned __int8 *)(v28 + v33 + 16);
      v35 = *((char *)v29 + 2);
      if (v35 == -1)
        v36 = 0;
      else
        v36 = *(unsigned __int8 *)(v28 + v35);
      v37 = *((char *)v29 + 3);
      if (v37 == -1)
        v38 = 0;
      else
        v38 = *(unsigned __int8 *)(v28 + v37 + 16);
      v39 = 1;
      if (v32 == v36 && v34 == v38)
      {
        v40 = *(v29 - 3) - *a2;
        if (v40 < 0)
          v40 = *a2 - *(v29 - 3);
        if (v40 <= 3)
        {
          v41 = *(v29 - 2) - a2[1];
          if (v41 < 0)
            v41 = a2[1] - *(v29 - 2);
          if (v41 <= 3)
          {
            v42 = *(v29 - 1) - a2[2];
            if (v42 < 0)
              v42 = a2[2] - *(v29 - 1);
            if (v42 <= 3)
            {
              v43 = *v29 - a2[3];
              if (v43 < 0)
                v43 = a2[3] - *v29;
              v39 = v43 > 3;
            }
          }
        }
      }
      v44 = *v26;
      if (v44 <= v39)
        LOBYTE(v44) = v39;
      *v26++ = v44;
      v29 = (__int16 *)((char *)v29 + v30);
      --v27;
    }
    while (v27);
  }
  return result;
}

uint64_t sub_1B67C6A50(uint64_t a1, unsigned int *a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t result;
  uint64_t v24;
  unsigned int v25;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31[2];

  v31[1] = *MEMORY[0x1E0C80C00];
  v16 = *((char *)a2 + 9);
  if (v16 == -1)
  {
    v24 = *(_QWORD *)(a1 + 16 * *((char *)a2 + 8) + 3544);
    v25 = *a2;
    return sub_1B67C71E4(a1, v24, v25, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  v17 = *((char *)a2 + 8);
  if (v17 == -1)
  {
    v24 = *(_QWORD *)(a1 + 16 * v16 + 3800);
    v25 = a2[1];
    return sub_1B67C71E4(a1, v24, v25, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  v18 = *(_QWORD *)(a1 + 3544 + 16 * v17);
  v19 = *(_QWORD *)(a1 + 3544 + 16 * v16 + 256);
  v20 = *a2;
  v21 = a2[1];
  if (v18 == v19 && (_DWORD)v20 == (_DWORD)v21)
    return sub_1B67C71E4(a1, v18, v20, a3, a4, a5, a6, a7, a8, a9, a10);
  v30 = 0;
  v31[0] = 0;
  v28 = 0;
  v29 = 0;
  v27 = v20;
  sub_1B67C7020((_DWORD *)v18, v20, a3, a4, a5, a6, &v30, &v28);
  sub_1B67C7020((_DWORD *)v19, v21, a3, a4, a5, a6, v31, &v29);
  result = sub_1B67DD8DC(a1 + 2104, a5, a6, v27, *(_QWORD *)(v18 + 112), v30, v21, *(_QWORD *)(v19 + 112), v31[0], a7, a8);
  if (*(_BYTE *)(*(_QWORD *)(a1 + 1368) + 173))
    return sub_1B67DDA3C(a1 + 2104, ((int)a5 >> 1), ((int)a6 >> 1), v27, *(_QWORD *)(v18 + 120), v28, v21, *(_QWORD *)(v19 + 120), v29, a9, a10);
  return result;
}

uint64_t sub_1B67C6C64(uint64_t a1, unsigned int *a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v15;
  uint64_t v16;
  __int16 *v17;
  __int16 *v18;
  uint64_t v19;
  uint64_t v20;
  __int16 *v21;
  __int16 *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t result;
  uint64_t v28;
  unsigned int v29;
  __int16 *v30;
  __int16 *v31;
  __int16 *v32;
  __int16 *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37[3];

  v37[1] = *MEMORY[0x1E0C80C00];
  v15 = *((char *)a2 + 8);
  v16 = a1 + 6 * v15;
  v17 = (__int16 *)(v16 + 640);
  v18 = (__int16 *)(v16 + 736);
  v19 = *((char *)a2 + 9);
  if (v19 == -1)
  {
    if ((_DWORD)v15 == -1)
      v21 = 0;
    else
      v21 = v17;
    if ((_DWORD)v15 == -1)
      v22 = 0;
    else
      v22 = v18;
    v28 = *(_QWORD *)(a1 + 16 * v15 + 3544);
    v29 = *a2;
    return sub_1B67C6EC8(a1, v28, v29, (unsigned int *)(a1 + 632), v21, v22, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  v20 = a1 + 6 * *((char *)a2 + 9);
  v21 = (__int16 *)(v20 + 832);
  v22 = (__int16 *)(v20 + 928);
  if ((_DWORD)v15 == -1)
  {
    v28 = *(_QWORD *)(a1 + 16 * v19 + 3800);
    v29 = a2[1];
    return sub_1B67C6EC8(a1, v28, v29, (unsigned int *)(a1 + 632), v21, v22, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  v23 = *(_QWORD *)(a1 + 3544 + 16 * v15);
  v24 = *(_QWORD *)(a1 + 3544 + 16 * v19 + 256);
  v26 = *a2;
  v25 = a2[1];
  v36 = 0;
  v37[0] = 0;
  v32 = (__int16 *)(v20 + 928);
  v33 = (__int16 *)(v20 + 832);
  v34 = 0;
  v35 = 0;
  v30 = v17;
  v31 = v18;
  sub_1B67C7020((_DWORD *)v23, v26, a3, a4, a5, a6, &v36, &v34);
  sub_1B67C7020((_DWORD *)v24, v25, a3, a4, a5, a6, v37, &v35);
  result = sub_1B67DDDC4(a1 + 2104, a5, a6, *(unsigned int *)(a1 + 632), *v31, *v30, v26, *(_QWORD *)(v23 + 112), v36, *v32, *v33, v25, *(_QWORD *)(v24 + 112), v37[0]);
  if (*(_BYTE *)(*(_QWORD *)(a1 + 1368) + 173))
    return sub_1B67DDF7C(a1 + 2104, ((int)a5 >> 1), ((int)a6 >> 1), *(unsigned int *)(a1 + 636), (uint64_t)(v31 + 1), (uint64_t)(v30 + 1), v26, *(_QWORD *)(v23 + 120), v34, (uint64_t)(v32 + 1), (uint64_t)(v33 + 1), v25, *(_QWORD *)(v24 + 120), v35);
  return result;
}

uint64_t sub_1B67C6EC8(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int *a4, __int16 *a5, __int16 *a6, int a7, int a8, int a9, int a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v19;
  uint64_t result;
  uint64_t v21;
  uint64_t v22;

  v21 = 0;
  v22 = 0;
  v19 = a3;
  sub_1B67C7020((_DWORD *)a2, a3, a7, a8, a9, a10, &v22, &v21);
  result = sub_1B67DDB9C(a1 + 2104, a9, a10, *a4, *a6, *a5, v19, *(_QWORD *)(a2 + 112), v22, a11, a12);
  if (*(_BYTE *)(*(_QWORD *)(a1 + 1368) + 173))
    return sub_1B67DDCB8(a1 + 2104, (a9 >> 1), (a10 >> 1), a4[1], (uint64_t)(a6 + 1), (uint64_t)(a5 + 1), v19, *(_QWORD *)(a2 + 120), v21, a13, a14);
  return result;
}

uint64_t sub_1B67C7020(_DWORD *a1, int a2, int a3, int a4, uint64_t a5, uint64_t a6, _QWORD *a7, _QWORD *a8)
{
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  unsigned int v27;
  uint64_t v28;
  signed int v29;
  signed int v30;
  signed int v31;
  signed int v32;
  std::unique_lock<std::mutex> v34;

  v15 = -3 - a5;
  v16 = a1[69] + 2;
  v17 = a3 + ((__int16)a2 >> 2);
  if (v17 < v16)
    v16 = a3 + ((__int16)a2 >> 2);
  if (v17 <= v15)
    v18 = v15;
  else
    v18 = v16;
  v19 = -3 - a6;
  v20 = a1[70] + 2;
  v21 = a4 + (a2 >> 18);
  if (v21 < v20)
    v20 = a4 + (a2 >> 18);
  if (v21 <= v19)
    v22 = v19;
  else
    v22 = v20;
  *a7 = (*(uint64_t (**)(_DWORD *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 16))(a1, v18, v22, 0);
  v23 = ((__int16)a2 >> 3) + (a3 >> 1);
  if (v23 >= (int)a1[69] >> 1)
    v24 = (int)a1[69] >> 1;
  else
    v24 = ((__int16)a2 >> 3) + (a3 >> 1);
  if (v23 <= ~((int)a5 >> 1))
    v25 = ~((int)a5 >> 1);
  else
    v25 = v24;
  v26 = (a4 >> 1) + (a2 >> 19);
  if (v26 >= (int)a1[70] >> 1)
    v27 = (int)a1[70] >> 1;
  else
    v27 = (a4 >> 1) + (a2 >> 19);
  if (v26 <= ~((int)a6 >> 1))
    v28 = ~((int)a6 >> 1);
  else
    v28 = v27;
  *a8 = (*(uint64_t (**)(_DWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 16))(a1, v25, v28, 1);
  v29 = a6 + v22 + 4;
  v30 = atomic_load(a1 + 275);
  if (v30 < v29)
  {
    v34.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 276);
    v34.__owns_ = 1;
    std::mutex::lock((std::mutex *)(a1 + 276));
    v31 = atomic_load(a1 + 275);
    if (v31 < v29)
    {
      do
      {
        std::condition_variable::wait((std::condition_variable *)(a1 + 292), &v34);
        v32 = atomic_load(a1 + 275);
      }
      while (v32 < v29);
    }
    if (v34.__owns_)
      std::mutex::unlock(v34.__m_);
  }
  return (*((uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _DWORD *))a1 + 136))(v18, v22, v25, v28, a5, a6, a1);
}

uint64_t sub_1B67C71E4(uint64_t a1, uint64_t a2, unsigned int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v13;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;

  v13 = a6;
  v20 = 0;
  v21 = 0;
  v17 = a3;
  sub_1B67C7020((_DWORD *)a2, a3, a4, a5, a6, a7, &v21, &v20);
  v18 = byte_1B6920C45[(v13 >> 2) - 1];
  result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t))(a1
                                                                                          + 2104
                                                                                          + (((unint64_t)((a3 & 3) != 0) << 6) | ((unint64_t)((*(_QWORD *)&a3 & 0x30000) != 0) << 7))
                                                                                          + 8 * v18))(a7, v17, *(_QWORD *)(a2 + 112), v21, a8, a9);
  if (*(_BYTE *)(*(_QWORD *)(a1 + 1368) + 173))
    return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t))(a1
                                                                                         + 2104
                                                                                         + (((unint64_t)((a3 & 7) != 0) << 6) | ((unint64_t)((*(_QWORD *)&a3 & 0x70000) != 0) << 7))
                                                                                         + 8 * v18
                                                                                         + 256))(((int)a7 >> 1), v17, *(_QWORD *)(a2 + 120), v20, a10, a11);
  return result;
}

BOOL sub_1B67C732C(__int16 *a1, __int16 *a2, uint64_t a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  __int16 *v14;
  uint64_t v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v28;

  v3 = *((char *)a1 + 8);
  if (v3 == -1)
    v4 = 0;
  else
    v4 = *(unsigned __int8 *)(a3 + v3);
  v5 = *((char *)a1 + 9);
  if (v5 == -1)
    v6 = 0;
  else
    v6 = *(unsigned __int8 *)(a3 + v5 + 16);
  v7 = *((char *)a2 + 8);
  if (v7 == -1)
    v8 = 0;
  else
    v8 = *(unsigned __int8 *)(a3 + v7);
  v9 = *((char *)a2 + 9);
  if (v9 == -1)
    v10 = 0;
  else
    v10 = *(unsigned __int8 *)(a3 + v9 + 16);
  if (v4 != v8 || v6 != v10)
  {
    v15 = 1;
    if (v4 != v10 || v6 != v8)
      return v15;
    if (v4 != v6)
    {
      v24 = a2[2] - *a1;
      if (v24 < 0)
        v24 = *a1 - a2[2];
      if (v24 > 3)
        return 1;
      v25 = a2[3] - a1[1];
      if (v25 < 0)
        v25 = a1[1] - a2[3];
      if (v25 > 3)
        return 1;
      v16 = *a2;
      goto LABEL_55;
    }
LABEL_29:
    v16 = *a2;
    v17 = *a1;
    v18 = v16 - v17;
    if (v16 - v17 < 0)
      v18 = v17 - v16;
    if (v18 <= 3)
    {
      v19 = a2[1] - a1[1];
      if (v19 < 0)
        v19 = a1[1] - a2[1];
      if (v19 <= 3)
      {
        v20 = a2[2] - a1[2];
        if (v20 < 0)
          v20 = a1[2] - a2[2];
        if (v20 <= 3)
        {
          v21 = a2[3] - a1[3];
          if (v21 < 0)
            v21 = a1[3] - a2[3];
          if (v21 < 4)
            return 0;
        }
      }
    }
    v22 = a2[2] - v17;
    if (v22 < 0)
      v22 = -v22;
    if (v22 > 3)
      return 1;
    v23 = a2[3] - a1[1];
    if (v23 < 0)
      v23 = a1[1] - a2[3];
    if (v23 > 3)
      return 1;
LABEL_55:
    v26 = v16 - a1[2];
    if (v26 < 0)
      v26 = -v26;
    if (v26 <= 3)
    {
      v14 = a2 + 1;
      goto LABEL_61;
    }
    return 1;
  }
  if (v4 == v6)
    goto LABEL_29;
  v11 = *a2 - *a1;
  if (v11 < 0)
    v11 = *a1 - *a2;
  if (v11 > 3)
    return 1;
  v12 = a2[1] - a1[1];
  if (v12 < 0)
    v12 = a1[1] - a2[1];
  if (v12 > 3)
    return 1;
  v13 = a2[2] - a1[2];
  if (v13 < 0)
    v13 = a1[2] - a2[2];
  if (v13 > 3)
    return 1;
  v14 = a2 + 3;
LABEL_61:
  v28 = *v14 - a1[3];
  if (v28 < 0)
    v28 = -v28;
  return v28 > 3;
}

_QWORD *sub_1B67C7524(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  void *v5;
  void **v6;
  unint64_t v7;
  uint64_t v8;
  std::condition_variable *v9;
  std::mutex *v10;
  uint64_t i;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  v2 = (std::__shared_weak_count *)a1[524];
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = (void *)a1[521];
  if (v5)
  {
    v6 = (void **)(a1 + 521);
    if (a1[522])
    {
      v7 = 0;
      v8 = 64;
      do
      {
        v9 = (std::condition_variable *)(a1[521] + v8);
        v10 = (std::mutex *)&v9[-2].__cv_.__opaque[24];
        std::condition_variable::~condition_variable(v9);
        std::mutex::~mutex(v10);
        ++v7;
        v8 += 120;
      }
      while (v7 < a1[522]);
      v5 = *v6;
    }
    free(v5);
    *v6 = 0;
    a1[522] = 0;
  }
  sub_1B6772C88((uint64_t)(a1 + 507));
  for (i = 505; i != 441; i -= 2)
    sub_1B6772C88((uint64_t)&a1[i]);
  v12 = (void *)a1[436];
  if (v12)
  {
    free(v12);
    a1[436] = 0;
    a1[437] = 0;
  }
  v13 = (void *)a1[433];
  if (v13)
  {
    a1[434] = v13;
    operator delete(v13);
  }
  sub_1B6772C88((uint64_t)(a1 + 173));
  sub_1B6772C88((uint64_t)(a1 + 171));
  v14 = (void *)a1[128];
  if (v14)
  {
    free(v14);
    a1[128] = 0;
    a1[129] = 0;
  }
  v15 = (void *)a1[73];
  if (v15)
  {
    free(v15);
    a1[73] = 0;
    a1[74] = 0;
  }
  v16 = (void *)a1[70];
  if (v16)
  {
    free(v16);
    a1[70] = 0;
    a1[71] = 0;
  }
  return a1;
}

void sub_1B67C7674(_QWORD *a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)a1[1];
  *a1 = 0;
  a1[1] = 0;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

uint64_t sub_1B67C76D0(uint64_t a1, int a2, unsigned __int8 *a3)
{
  uint64_t v5;
  _QWORD *v6;
  unsigned int v7;
  uint64_t i;
  uint64_t j;
  uint64_t result;
  _OWORD v11[16];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  memset(v11, 0, sizeof(v11));
  if ((a2 & 0x80000000) == 0)
  {
    v5 = (a2 + 1);
    v6 = v11;
    do
    {
      v7 = *a3++;
      v6 = sub_1B67B665C(v6, *(_QWORD *)(a1 + 16 * v7), *(_QWORD *)(a1 + 16 * v7 + 8)) + 2;
      --v5;
    }
    while (v5);
  }
  for (i = 0; i != 16; ++i)
    sub_1B67B665C((_QWORD *)(a1 + i * 16), *(_QWORD *)&v11[i], *((_QWORD *)&v11[i] + 1));
  for (j = 15; j != -1; --j)
    result = sub_1B6772C88((uint64_t)&v11[j]);
  return result;
}

int32x2_t sub_1B67C77B8(uint64_t a1, unsigned int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  __int32 v10;
  int v11;
  int v12;
  unsigned int v13;
  signed int v14;
  int32x2_t v15;
  int32x2_t v16;
  int32x2_t v17;
  int32x2_t result;
  _QWORD v19[3];

  v19[2] = *MEMORY[0x1E0C80C00];
  if (a4 && *(_BYTE *)(a4 + 10) != 1)
  {
    v19[0] = a1 + 3544;
    v19[1] = a1 + 3800;
    v5 = a4 + 8;
    v6 = a2;
    if (!*(_BYTE *)(a1 + 627))
      v6 = *(unsigned __int8 *)(a1 + 538);
    LODWORD(v7) = 1 - v6;
    if (*(unsigned __int8 *)(v5 + v6) == 255)
      v7 = v7;
    else
      v7 = v6;
    v8 = v19[a2] + 16 * a3;
    v9 = *(_DWORD *)(*(_QWORD *)v8 + 36);
    if (((v9 >> 1) & 1) == *(_BYTE *)(*(_QWORD *)(a1 + 4056) + (v7 << 7) + 8 * *(char *)(v5 + v7) + 692))
    {
      v10 = *(_DWORD *)(a4 + 4 * v7);
      *(_DWORD *)a5 = v10;
      if ((v9 & 2) == 0)
      {
        v11 = *(_DWORD *)(*(_QWORD *)(a1 + 4056) + 680)
            - *(_DWORD *)(*(_QWORD *)(a1 + 4056) + (v7 << 7) + 8 * *(char *)(v5 + v7) + 688);
        v12 = *(_DWORD *)(a1 + 608) - *(_DWORD *)(*(_QWORD *)v8 + 680);
        if (v11 >= 127)
          v11 = 127;
        if (v11 <= -128)
          v11 = -128;
        if (v11)
        {
          if (v11 >= 0)
            v13 = v11;
          else
            v13 = -v11;
          v11 = (__int16)((__int16)((v13 >> 1) + 0x4000) / (__int16)v11);
        }
        if (v12 >= 127)
          v12 = 127;
        if (v12 <= -128)
          v12 = -128;
        v14 = (v11 * v12 + 32) >> 6;
        if (v14 >= 4095)
          v14 = 4095;
        if (v14 <= -4096)
          v14 = -4096;
        v15.i32[0] = v10 << 16;
        v15.i32[1] = v10;
        v16 = vmul_s32(vdup_n_s32(v14), vshr_n_s32(v15, 0x10uLL));
        v17 = (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32(vabs_s32(v16), (int32x2_t)0x7F0000007FLL), 8uLL);
        result = vmax_s32(vmin_s32((int32x2_t)vbsl_s8((int8x8_t)vcltz_s32(v16), (int8x8_t)vneg_s32(v17), (int8x8_t)v17), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
        *(_WORD *)(a5 + 2) = result.i16[2];
        *(_WORD *)a5 = result.i16[0];
      }
    }
  }
  return result;
}

void sub_1B67C7980(uint64_t a1, int a2, int a3, int a4, int a5, unsigned int a6, int a7, uint64_t a8)
{
  int v8;
  unsigned int v9;
  int v15;
  uint64_t v16;
  signed int v17;
  uint64_t v19;
  signed int v20;
  signed int v21;
  char v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  int v28;
  int v29;
  std::unique_lock<std::mutex> __lk;

  v8 = a7;
  v9 = a6;
  v15 = a5 + a3;
  v16 = *(_QWORD *)(a1 + 4056);
  v17 = atomic_load((unsigned int *)(v16 + 1100));
  if (v17 < a5 + a3)
  {
    v19 = a8;
    __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v16 + 1104);
    __lk.__owns_ = 1;
    std::mutex::lock((std::mutex *)(v16 + 1104));
    v20 = atomic_load((unsigned int *)(v16 + 1100));
    if (v20 < v15)
    {
      do
      {
        std::condition_variable::wait((std::condition_variable *)(v16 + 1168), &__lk);
        v21 = atomic_load((unsigned int *)(v16 + 1100));
      }
      while (v21 < v15);
    }
    if (__lk.__owns_)
      std::mutex::unlock(__lk.__m_);
    a8 = v19;
    v8 = a7;
    v9 = a6;
  }
  v22 = *(_BYTE *)(*(_QWORD *)(a1 + 1368) + 2009);
  v23 = a3 >> v22;
  v24 = v15 >> v22;
  v25 = *(_QWORD *)(a1 + 4056);
  if (v23 == v24 && a4 + a2 < *(_DWORD *)(v25 + 276) && v15 < *(_DWORD *)(v25 + 280))
  {
    v26 = a8;
    sub_1B67C77B8(a1, v9, v8, *(_QWORD *)(v25 + 576)+ 16 * (*(_QWORD *)(v25 + 552) * (int)((v15 >> 2) & 0xFFFFFFFC) + (int)(((a4 + a2) >> 2) & 0xFFFFFFFC)), a8);
    if ((v27 & 1) != 0)
      return;
    v25 = *(_QWORD *)(a1 + 4056);
    a8 = v26;
  }
  v28 = a2 + (a4 >> 1);
  if (v28 < *(_DWORD *)(v25 + 276))
  {
    v29 = a3 + (a5 >> 1);
    if (v29 < *(_DWORD *)(v25 + 280))
      sub_1B67C77B8(a1, v9, v8, *(_QWORD *)(v25 + 576)+ 16 * (*(_QWORD *)(v25 + 552) * (int)((v29 >> 2) & 0xFFFFFFFC) + (int)((v28 >> 2) & 0xFFFFFFFC)), a8);
  }
}

void sub_1B67C7B4C(uint64_t a1, int a2, int a3, unsigned int a4, int a5, int a6, int a7, __int32 *a8, _QWORD *a9, uint64_t a10)
{
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  char v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  __int32 v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;
  signed int v46;
  int32x2_t v47;
  int32x2_t v48;
  int32x2_t v49;
  int32x2_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  int v64;
  int v66;
  int v67;
  int v68;
  unsigned int v69;
  signed int v70;
  __int16 *v71;
  int32x2_t v72;
  int32x2_t v73;
  int32x2_t v74;
  int32x2_t v75;
  char v76;
  uint64_t v77;
  uint64_t v78;

  v13 = a4;
  v14 = a1 + 3544 + ((unint64_t)a4 << 8);
  v15 = a4 == 0;
  v16 = a1 + 3544 + (v15 << 8);
  v17 = 1 - a4;
  v18 = v14 + 16 * a5;
  v19 = *(_DWORD *)(*(_QWORD *)v18 + 36);
  if (*a9 && *(unsigned __int8 *)(*a9 + 10) > 1u)
  {
    LOBYTE(v20) = 1;
  }
  else
  {
    v20 = a9[1];
    if (v20)
      LOBYTE(v20) = *(unsigned __int8 *)(v20 + 10) > 1u;
  }
  v21 = 0;
  v22 = *(_DWORD *)(*(_QWORD *)v18 + 680);
  *((_BYTE *)a8 + 48) = 0;
  v23 = 1;
  do
  {
    v24 = v23;
    v25 = a9[v21];
    if (v25 && *(unsigned __int8 *)(v25 + 10) >= 2u)
    {
      v26 = *(char *)(v25 + v13 + 8);
      if (v26 != -1 && v22 == *(_DWORD *)(*(_QWORD *)(v14 + 16 * v26) + 680))
      {
        LOBYTE(v28) = 0;
        v34 = 1;
        *((_BYTE *)a8 + 48) = 1;
        v35 = *(_DWORD *)(v25 + 4 * v13);
LABEL_25:
        *a8 = v35;
        goto LABEL_50;
      }
      v27 = *(char *)(v25 + v17 + 8);
      if (v27 != -1 && v22 == *(_DWORD *)(*(_QWORD *)(v16 + 16 * v27) + 680))
      {
        LOBYTE(v28) = 0;
        v34 = 1;
        *((_BYTE *)a8 + 48) = 1;
        v35 = *(_DWORD *)(v25 + 4 * v17);
        goto LABEL_25;
      }
    }
    v23 = 0;
    v21 = 1;
  }
  while ((v24 & 1) != 0);
  v28 = 0;
  v29 = 1;
  while (1)
  {
    v30 = v29;
    v31 = a9[v28];
    if (v31)
    {
      if (*(unsigned __int8 *)(v31 + 10) >= 2u)
      {
        v32 = *(char *)(v31 + v13 + 8);
        if (v32 != -1 && ((v19 >> 1) & 1) == (*(_BYTE *)(*(_QWORD *)(v14 + 16 * v32) + 36) & 2) >> 1)
        {
          v36 = v13;
          v37 = v13;
          goto LABEL_28;
        }
        v33 = *(char *)(v31 + v17 + 8);
        if (v33 != -1 && ((v19 ^ *(unsigned __int8 *)(*(_QWORD *)(v16 + 16 * v33) + 36)) & 2) == 0)
          break;
      }
    }
    v29 = 0;
    v28 = 1;
    if ((v30 & 1) == 0)
    {
      v34 = 0;
      goto LABEL_50;
    }
  }
  v36 = v17;
  v37 = v15;
LABEL_28:
  v34 = 1;
  *((_BYTE *)a8 + 48) = 1;
  v38 = *(_DWORD *)(v31 + 4 * v36);
  *a8 = v38;
  if ((v19 & 2) != 0)
  {
    LOBYTE(v28) = 0;
  }
  else
  {
    v39 = *(_DWORD *)(*(_QWORD *)(a1 + (v37 << 8) + 16 * *(char *)(a9[v28] + v36 + 8) + 3544) + 680);
    v40 = *(_DWORD *)(a1 + 608);
    v41 = v40 - v39;
    v42 = v40 - *(_DWORD *)(*(_QWORD *)v18 + 680);
    if (v41 >= 127)
      v43 = 127;
    else
      v43 = v41;
    if (v43 <= -128)
      v43 = -128;
    if (v43)
    {
      if (v43 >= 0)
        v44 = v43;
      else
        v44 = -v43;
      v45 = (__int16)((__int16)((v44 >> 1) + 0x4000) / (__int16)v43);
    }
    else
    {
      v45 = 0;
    }
    LOBYTE(v28) = 0;
    if (v42 >= 127)
      v42 = 127;
    if (v42 <= -128)
      v42 = -128;
    v46 = (v45 * v42 + 32) >> 6;
    if (v46 >= 4095)
      v46 = 4095;
    if (v46 <= -4096)
      v46 = -4096;
    v47.i32[0] = v38 << 16;
    v47.i32[1] = v38;
    v48 = vmul_s32(vdup_n_s32(v46), vshr_n_s32(v47, 0x10uLL));
    v49 = (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32(vabs_s32(v48), (int32x2_t)0x7F0000007FLL), 8uLL);
    v50 = vmax_s32(vmin_s32((int32x2_t)vbsl_s8((int8x8_t)vcltz_s32(v48), (int8x8_t)vneg_s32(v49), (int8x8_t)v49), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
    *((_WORD *)a8 + 1) = v50.i16[2];
    *(_WORD *)a8 = v50.i16[0];
    v34 = 1;
  }
LABEL_50:
  v51 = 0;
  while (1)
  {
    v52 = *(_QWORD *)(a10 + v51);
    if (v52 && *(unsigned __int8 *)(v52 + 10) >= 2u)
    {
      v53 = *(char *)(v52 + v13 + 8);
      if (v53 != -1 && v22 == *(_DWORD *)(*(_QWORD *)(v14 + 16 * v53) + 680))
      {
        v55 = v13;
        if ((v28 & 1) != 0)
          goto LABEL_64;
        v56 = *a8;
        v57 = *(_DWORD *)(v52 + 4 * v13);
        v55 = v13;
        goto LABEL_63;
      }
      v54 = *(char *)(v52 + v17 + 8);
      if (v54 != -1 && v22 == *(_DWORD *)(*(_QWORD *)(v16 + 16 * v54) + 680))
        break;
    }
    v51 += 8;
    if (v51 == 24)
      goto LABEL_65;
  }
  v55 = v17;
  if ((v28 & 1) != 0)
    goto LABEL_64;
  v56 = *a8;
  v57 = *(_DWORD *)(v52 + 4 * v17);
  v55 = v17;
LABEL_63:
  if (v56 == v57)
    goto LABEL_65;
LABEL_64:
  *((_BYTE *)a8 + 48) = v34 + 1;
  a8[v34++] = *(_DWORD *)(v52 + 4 * v55);
LABEL_65:
  if ((v20 & 1) == 0)
  {
    v58 = 0;
    while (1)
    {
      v59 = *(_QWORD *)(a10 + 8 * v58);
      if (v59 && *(unsigned __int8 *)(v59 + 10) >= 2u)
      {
        v60 = *(char *)(v59 + v13 + 8);
        if (v60 != -1 && ((v19 >> 1) & 1) == (*(_BYTE *)(*(_QWORD *)(v14 + 16 * v60) + 36) & 2) >> 1)
        {
          v15 = v13;
          goto LABEL_77;
        }
        v61 = *(char *)(v59 + v17 + 8);
        if (v61 != -1 && ((v19 ^ *(unsigned __int8 *)(*(_QWORD *)(v16 + 16 * v61) + 36)) & 2) == 0)
          break;
      }
      if (++v58 == 3)
        goto LABEL_104;
    }
    v13 = v17;
LABEL_77:
    v62 = v19 & 2;
    a8[v34] = *(_DWORD *)(v59 + 4 * v13);
    v63 = *(_DWORD *)(*(_QWORD *)(a1 + (v15 << 8) + 16 * *(char *)(*(_QWORD *)(a10 + 8 * v58) + v13 + 8) + 3544)
                    + 680);
    v64 = *(_DWORD *)(*(_QWORD *)v18 + 680);
    if (v63 != v64 && v62 == 0)
    {
      v66 = *(_DWORD *)(a1 + 608);
      v67 = v66 - v64;
      if (v66 - v63 >= 127)
        v68 = 127;
      else
        v68 = v66 - v63;
      if (v68 <= -128)
        v68 = -128;
      if (v68)
      {
        if (v68 >= 0)
          v69 = v68;
        else
          v69 = -v68;
        v68 = (__int16)((__int16)((v69 >> 1) + 0x4000) / (__int16)v68);
      }
      if (v67 >= 127)
        v67 = 127;
      if (v67 <= -128)
        v67 = -128;
      v70 = (v68 * v67 + 32) >> 6;
      if (v70 >= 4095)
        v70 = 4095;
      if (v70 <= -4096)
        v70 = -4096;
      v71 = (__int16 *)&a8[*((unsigned __int8 *)a8 + 48)];
      v72.i32[0] = *v71;
      v72.i32[1] = v71[1];
      v73 = vmul_s32(vdup_n_s32(v70), v72);
      v74 = (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32(vabs_s32(v73), (int32x2_t)0x7F0000007FLL), 8uLL);
      v75 = vmax_s32(vmin_s32((int32x2_t)vbsl_s8((int8x8_t)vcltz_s32(v73), (int8x8_t)vneg_s32(v74), (int8x8_t)v74), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
      *v71 = v75.i16[0];
      v71[1] = v75.i16[2];
    }
    LOBYTE(v34) = *((_BYTE *)a8 + 48);
    if (!(_BYTE)v34 || *a8 != a8[1])
    {
      LOBYTE(v34) = v34 + 1;
      *((_BYTE *)a8 + 48) = v34;
    }
  }
LABEL_104:
  if (*(_BYTE *)(a1 + 498))
  {
    if (v34 > 1u)
      return;
    sub_1B67C7980(a1, a2, a3, a6, a7, a4, a5, (uint64_t)&a8[v34]);
    LOBYTE(v34) = *((_BYTE *)a8 + 48) + v76;
    *((_BYTE *)a8 + 48) = v34;
  }
  if (v34 <= 1u)
  {
    v77 = v34;
    do
    {
      v78 = v77;
      *((_BYTE *)a8 + 48) = v77 + 1;
      a8[v77] = 0;
      v77 = 1;
    }
    while (!v78);
  }
}

void sub_1B67C8110(_BYTE *a1, int a2, int a3, int a4, int a5, uint64_t a6, uint64_t *a7, uint64_t *a8)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  char v19;
  uint64_t v20;
  unsigned __int8 v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  char v29;
  uint64_t v30;
  int v31;
  int v32;
  char v33;
  char v34;
  char v35;
  uint64_t v36;
  unsigned __int8 v37;
  __int16 v38;
  uint64_t v39;
  char v40;
  char v41;
  uint64_t v42;
  unsigned __int8 v43;
  int v44;
  uint64_t v45;
  unsigned __int8 v46;
  int v47;
  unsigned __int8 v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  int v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  char v60;
  char v61;
  char v62;
  int v63;
  int v64;

  *(_BYTE *)(a6 + 60) = 0;
  v14 = a7[1];
  if (v14 && *(unsigned __int8 *)(v14 + 10) >= 2u && (a4 >= a5 || ((a5 - 1) & a2) <= 0))
  {
    v38 = *(_WORD *)(v14 + 8);
    *(_QWORD *)(a6 + 4) = *(_QWORD *)v14;
    *(_WORD *)a6 = v38;
    *(_BYTE *)(a6 + 60) = 1;
  }
  else
  {
    a7[1] = 0;
  }
  v15 = a8[1];
  if (v15 && *(unsigned __int8 *)(v15 + 10) >= 2u && (a4 <= a5 || ((a4 - 1) & a3) <= 0))
  {
    v39 = a7[1];
    if (!v39
      || *(unsigned __int8 *)(v39 + 10) < 2u
      || *(unsigned __int8 *)(v39 + 8) != *(unsigned __int8 *)(v15 + 8)
      || *(_DWORD *)v39 != *(_DWORD *)v15
      || *(unsigned __int8 *)(v39 + 9) != *(unsigned __int8 *)(v15 + 9)
      || *(_DWORD *)(v39 + 4) != *(_DWORD *)(v15 + 4))
    {
      v40 = *(_BYTE *)(v15 + 8);
      v41 = *(_BYTE *)(v15 + 9);
      v42 = a6 + 12 * *(unsigned __int8 *)(a6 + 60);
      *(_QWORD *)(v42 + 4) = *(_QWORD *)v15;
      *(_BYTE *)v42 = v40;
      v43 = *(_BYTE *)(a6 + 60);
      *(_BYTE *)(a6 + 12 * v43++ + 1) = v41;
      *(_BYTE *)(a6 + 60) = v43;
      if (v43 == 5)
        return;
    }
  }
  else
  {
    a8[1] = 0;
  }
  v16 = *a8;
  if (!*a8)
    goto LABEL_93;
  if (*(unsigned __int8 *)(v16 + 10) < 2u)
    goto LABEL_93;
  v17 = a8[1];
  if (v17)
  {
    if (*(unsigned __int8 *)(v17 + 10) >= 2u
      && *(unsigned __int8 *)(v17 + 8) == *(unsigned __int8 *)(v16 + 8)
      && *(_DWORD *)v17 == *(_DWORD *)v16
      && *(unsigned __int8 *)(v17 + 9) == *(unsigned __int8 *)(v16 + 9)
      && *(_DWORD *)(v17 + 4) == *(_DWORD *)(v16 + 4))
    {
      goto LABEL_93;
    }
  }
  v18 = *(_BYTE *)(v16 + 8);
  v19 = *(_BYTE *)(v16 + 9);
  v20 = a6 + 12 * *(unsigned __int8 *)(a6 + 60);
  *(_QWORD *)(v20 + 4) = *(_QWORD *)v16;
  *(_BYTE *)v20 = v18;
  v21 = *(_BYTE *)(a6 + 60);
  *(_BYTE *)(a6 + 12 * v21++ + 1) = v19;
  *(_BYTE *)(a6 + 60) = v21;
  if (v21 != 5)
  {
LABEL_93:
    v22 = *a7;
    if (!*a7
      || *(unsigned __int8 *)(v22 + 10) < 2u
      || (v23 = a7[1]) != 0
      && *(unsigned __int8 *)(v23 + 10) >= 2u
      && *(unsigned __int8 *)(v23 + 8) == *(unsigned __int8 *)(v22 + 8)
      && *(_DWORD *)v23 == *(_DWORD *)v22
      && *(unsigned __int8 *)(v23 + 9) == *(unsigned __int8 *)(v22 + 9)
      && *(_DWORD *)(v23 + 4) == *(_DWORD *)(v22 + 4))
    {
      v24 = *(_BYTE *)(a6 + 60);
    }
    else
    {
      v34 = *(_BYTE *)(v22 + 8);
      v35 = *(_BYTE *)(v22 + 9);
      v36 = a6 + 12 * *(unsigned __int8 *)(a6 + 60);
      *(_QWORD *)(v36 + 4) = *(_QWORD *)v22;
      *(_BYTE *)v36 = v34;
      v37 = *(_BYTE *)(a6 + 60);
      *(_BYTE *)(a6 + 12 * v37 + 1) = v35;
      v24 = v37 + 1;
      *(_BYTE *)(a6 + 60) = v24;
      if (v24 == 5)
        return;
    }
    if (v24 > 3u)
      goto LABEL_94;
    v25 = a8[2];
    if (!v25)
      goto LABEL_94;
    if (*(unsigned __int8 *)(v25 + 10) < 2u)
      goto LABEL_94;
    v26 = a7[1];
    if (v26)
    {
      if (*(unsigned __int8 *)(v26 + 10) >= 2u
        && *(unsigned __int8 *)(v26 + 8) == *(unsigned __int8 *)(v25 + 8)
        && *(_DWORD *)v26 == *(_DWORD *)v25
        && *(unsigned __int8 *)(v26 + 9) == *(unsigned __int8 *)(v25 + 9)
        && *(_DWORD *)(v26 + 4) == *(_DWORD *)(v25 + 4))
      {
        goto LABEL_94;
      }
    }
    v27 = a8[1];
    if (v27)
    {
      if (*(unsigned __int8 *)(v27 + 10) >= 2u
        && *(unsigned __int8 *)(v27 + 8) == *(unsigned __int8 *)(v25 + 8)
        && *(_DWORD *)v27 == *(_DWORD *)v25
        && *(unsigned __int8 *)(v27 + 9) == *(unsigned __int8 *)(v25 + 9)
        && *(_DWORD *)(v27 + 4) == *(_DWORD *)(v25 + 4))
      {
        goto LABEL_94;
      }
    }
    v28 = *(_BYTE *)(v25 + 8);
    v29 = *(_BYTE *)(v25 + 9);
    v30 = a6 + 12 * v24;
    *(_QWORD *)(v30 + 4) = *(_QWORD *)v25;
    *(_BYTE *)v30 = v28;
    LOBYTE(v30) = *(_BYTE *)(a6 + 60);
    *(_BYTE *)(a6 + 12 * v30 + 1) = v29;
    LOBYTE(v30) = v30 + 1;
    *(_BYTE *)(a6 + 60) = v30;
    if (v30 != 5)
    {
LABEL_94:
      if (!a1[498])
        goto LABEL_95;
      sub_1B67C7980((uint64_t)a1, a2, a3, a4, a5, 0, 0, (uint64_t)&v64);
      if (!v31)
        goto LABEL_95;
      if (a1[10])
      {
        v32 = 0;
        v33 = -1;
      }
      else
      {
        sub_1B67C7980((uint64_t)a1, a2, a3, a4, a5, 1u, 0, (uint64_t)&v63);
        v32 = v44 ? v63 : 0;
        v33 = v44 - 1;
      }
      v45 = a6 + 12 * *(unsigned __int8 *)(a6 + 60);
      *(_DWORD *)(v45 + 4) = v64;
      *(_DWORD *)(v45 + 8) = v32;
      *(_BYTE *)v45 = 0;
      v46 = *(_BYTE *)(a6 + 60);
      *(_BYTE *)(a6 + 12 * v46 + 1) = v33;
      *(_BYTE *)(a6 + 60) = v46 + 1;
      if ((v46 + 1) != 5)
      {
LABEL_95:
        if (a1[10])
        {
          LOBYTE(v47) = a1[500];
          v48 = *(_BYTE *)(a6 + 60);
        }
        else
        {
          LODWORD(v49) = *(unsigned __int8 *)(a6 + 60);
          v50 = ((v49 - 1) * v49);
          if ((int)v50 <= 0)
          {
            LOBYTE(v47) = a1[500];
          }
          else
          {
            v51 = &byte_1B692041C;
            v52 = &byte_1B6920410;
            do
            {
              if (v49 > 4u)
                break;
              v53 = *(char *)(a6 + 12 * *v52);
              if (v53 != -1)
              {
                v54 = *(char *)(a6 + 12 * *v51 + 1);
                if (v54 != -1)
                {
                  v55 = *(_DWORD *)(a6 + 12 * *v52 + 4);
                  v56 = *(_DWORD *)(a6 + 12 * *v51 + 8);
                  if (v55 != v56
                    || *(_DWORD *)(*(_QWORD *)&a1[16 * v53 + 3544] + 680) != *(_DWORD *)(*(_QWORD *)&a1[16 * v54 + 3800]
                                                                                         + 680))
                  {
                    v49 = a6 + 12 * v49;
                    *(_DWORD *)(v49 + 4) = v55;
                    *(_BYTE *)v49 = v53;
                    LOBYTE(v49) = *(_BYTE *)(a6 + 60);
                    v57 = a6 + 12 * v49;
                    *(_DWORD *)(v57 + 8) = v56;
                    *(_BYTE *)(v57 + 1) = v54;
                    LOBYTE(v49) = v49 + 1;
                    *(_BYTE *)(a6 + 60) = v49;
                    if (v49 == 5)
                      return;
                  }
                }
              }
              ++v51;
              ++v52;
              --v50;
            }
            while (v50);
            LOBYTE(v47) = a1[500];
            v48 = v49;
            if (a1[10])
              goto LABEL_82;
          }
          if ((char)a1[501] < (char)v47)
            LOBYTE(v47) = a1[501];
          v48 = v49;
        }
LABEL_82:
        if (v48 <= 4u)
        {
          v58 = 0;
          v47 = (char)v47;
          do
          {
            v59 = a6 + 12 * v48;
            *(_DWORD *)(v59 + 4) = 0;
            *(_DWORD *)(v59 + 8) = 0;
            if (v58 >= v47)
              v60 = 0;
            else
              v60 = v58;
            *(_BYTE *)v59 = v60;
            v61 = *(_BYTE *)(a6 + 60);
            if (a1[10])
              v62 = -1;
            else
              v62 = *(_BYTE *)(a6 + 12 * *(unsigned __int8 *)(a6 + 60));
            *(_BYTE *)(a6 + 12 * *(unsigned __int8 *)(a6 + 60) + 1) = v62;
            ++v58;
            v48 = v61 + 1;
            *(_BYTE *)(a6 + 60) = v48;
          }
          while (v48 < 5u);
        }
      }
    }
  }
}

uint64_t sub_1B67C8710(uint64_t result)
{
  uint64_t v1;
  int v2;
  char *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  char v12;
  int v13;
  int v14;
  int v15;
  int v16;

  v1 = *(_QWORD *)(result + 1368);
  v2 = *(unsigned __int8 *)(v1 + 2001);
  v3 = *(char **)(result + 1384);
  v4 = v3[9] + *(char *)(result + 543) + 26;
  if (v4 >= 51)
    v5 = 51;
  else
    v5 = v3[9] + *(char *)(result + 543) + 26;
  if (v4 <= -v2)
    v6 = -v2;
  else
    v6 = v5;
  *(_BYTE *)(result + 621) = v6;
  v7 = *(char *)(result + 544);
  v8 = v6 + v3[14] + v7;
  v9 = *(unsigned __int8 *)(v1 + 2003);
  if (v8 >= 57)
    v10 = 57;
  else
    v10 = v6 + v3[14] + v7;
  if (v8 <= -v9)
    v11 = -v9;
  else
    v11 = v10;
  if (v11 >= 30)
    LOBYTE(v11) = byte_1B692B6F0[v11 - 30];
  *(_BYTE *)(result + 622) = v11;
  v12 = *(_BYTE *)(result + 545);
  v13 = v6 + v3[15] + v12;
  v14 = *(unsigned __int8 *)(v1 + 2003);
  if (v13 >= 57)
    v15 = 57;
  else
    v15 = v13;
  if (v13 <= -v14)
    v16 = -v14;
  else
    v16 = v15;
  if (v16 >= 30)
    LOBYTE(v16) = byte_1B692B6F0[v16 - 30];
  *(_BYTE *)(result + 623) = v16;
  *(_BYTE *)(result + 624) = 0;
  *(_BYTE *)(result + 625) = v3[14] + v7;
  *(_BYTE *)(result + 626) = v3[15] + v12;
  return result;
}

char *sub_1B67C87EC(uint64_t a1, int a2, int a3, int a4, int a5, uint64_t a6)
{
  unsigned int v6;
  char *result;
  uint64_t v11;
  char *v12;
  char *v13;
  uint64_t v14;

  v6 = a6;
  result = (char *)(*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 1360) + 16))(*(_QWORD *)(a1 + 1360), (a2 >> a6), (a3 >> a6), a6);
  v11 = (a5 >> v6);
  if ((int)v11 >= 1)
  {
    v12 = result;
    v13 = (char *)(a1 + 4392);
    v14 = *(_QWORD *)(*(_QWORD *)(a1 + 1360) + 8 * v6 + 112);
    do
    {
      result = (char *)memcpy(v13, v12, a4);
      v12 += v14;
      v13 += a4;
      --v11;
    }
    while (v11);
  }
  return result;
}

char *sub_1B67C8888(uint64_t a1, int a2, int a3, int a4, int a5, uint64_t a6)
{
  unsigned int v6;
  char *result;
  uint64_t v11;
  char *v12;
  char *v13;
  size_t v14;
  uint64_t v15;

  v6 = a6;
  result = (char *)(*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 1360) + 16))(*(_QWORD *)(a1 + 1360), (a2 >> a6), (a3 >> a6), a6);
  v11 = (a5 >> v6);
  if ((int)v11 >= 1)
  {
    v12 = result;
    v13 = (char *)(a1 + 4392);
    v14 = 2 * a4;
    v15 = 2 * *(_QWORD *)(*(_QWORD *)(a1 + 1360) + 8 * v6 + 112);
    do
    {
      result = (char *)memcpy(v13, v12, v14);
      v12 += v15;
      v13 += v14;
      --v11;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1B67C8928(uint64_t a1, int a2, int a3, int a4, int a5, uint64_t a6)
{
  unsigned int v6;
  uint64_t result;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;

  v6 = a6;
  result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 1360) + 16))(*(_QWORD *)(a1 + 1360), (a2 >> a6), (a3 >> a6), a6);
  if (a5 >= 1)
  {
    v13 = 0;
    v14 = *(_QWORD *)(*(_QWORD *)(a1 + 1360) + 8 * v6 + 112);
    v15 = (_QWORD *)(a1 + 4392);
    v16 = 8u >> v6;
    v17 = v14 * v16;
    v18 = (int)v16 * (uint64_t)a4;
    if (v16 <= 1)
      v16 = 1;
    else
      v16 = v16;
    do
    {
      if (a4 >= 1)
      {
        v19 = 0;
        v20 = (_QWORD *)result;
        v21 = v15;
        do
        {
          v22 = *(_QWORD *)(a1 + 1360);
          v24 = *(_QWORD *)(v22 + 488);
          v23 = *(_QWORD *)(v22 + 496);
          v25 = v24 * ((uint64_t)(v13 + a3) >> 3) + (((int)v19 + a2) >> 3);
          if (*(_BYTE *)(*(_QWORD *)(a1 + 1384) + 19) && (*(_WORD *)(v23 + 2 * v25) & 0x100) != 0
            || *(_BYTE *)(*(_QWORD *)(a1 + 1368) + 255) && (*(_WORD *)(v23 + 2 * v25) & 0xC) != 0)
          {
            v26 = v20;
            v27 = v21;
            v28 = v16;
            do
            {
              *v26 = *v27;
              v27 = (_QWORD *)((char *)v27 + a4);
              v26 = (_QWORD *)((char *)v26 + v14);
              --v28;
            }
            while (v28);
          }
          v19 += 8;
          ++v21;
          ++v20;
        }
        while (v19 < a4);
      }
      result += v17;
      v15 = (_QWORD *)((char *)v15 + v18);
      v13 += 8;
    }
    while (v13 < a5);
  }
  return result;
}

uint64_t sub_1B67C8A6C(uint64_t a1, int a2, int a3, int a4, int a5, uint64_t a6)
{
  unsigned int v6;
  uint64_t result;
  int v13;
  uint64_t v14;
  _OWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _OWORD *v22;
  _OWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _OWORD *v28;
  _OWORD *v29;
  uint64_t v30;

  v6 = a6;
  result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 1360) + 16))(*(_QWORD *)(a1 + 1360), (a2 >> a6), (a3 >> a6), a6);
  if (a5 >= 1)
  {
    v13 = 0;
    v14 = *(_QWORD *)(*(_QWORD *)(a1 + 1360) + 8 * v6 + 112);
    v15 = (_OWORD *)(a1 + 4392);
    v16 = 8u >> v6;
    if (v16 <= 1)
      v17 = 1;
    else
      v17 = v16;
    v18 = 2 * (int)v16 * a4;
    v19 = 2 * v14 * v16;
    v20 = 2 * v14;
    do
    {
      if (a4 >= 1)
      {
        v21 = 0;
        v22 = (_OWORD *)result;
        v23 = v15;
        do
        {
          v24 = *(_QWORD *)(a1 + 1360);
          v26 = *(_QWORD *)(v24 + 488);
          v25 = *(_QWORD *)(v24 + 496);
          v27 = v26 * ((uint64_t)(v13 + a3) >> 3) + (((int)v21 + a2) >> 3);
          if (*(_BYTE *)(*(_QWORD *)(a1 + 1384) + 19) && (*(_WORD *)(v25 + 2 * v27) & 0x100) != 0
            || *(_BYTE *)(*(_QWORD *)(a1 + 1368) + 255) && (*(_WORD *)(v25 + 2 * v27) & 0xC) != 0)
          {
            v28 = v22;
            v29 = v23;
            v30 = v17;
            do
            {
              *v28 = *v29;
              v29 = (_OWORD *)((char *)v29 + 2 * a4);
              v28 = (_OWORD *)((char *)v28 + v20);
              --v30;
            }
            while (v30);
          }
          v21 += 8;
          ++v23;
          ++v22;
        }
        while (v21 < a4);
      }
      v13 += 8;
      v15 = (_OWORD *)((char *)v15 + v18);
      result += v19;
    }
    while (v13 < a5);
  }
  return result;
}

uint64_t sub_1B67C8BC0(_QWORD *a1, int a2, int a3)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  signed int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;

  v4 = *(_DWORD *)(a1[171] + 2016);
  v5 = a2 + v4 * a3;
  v6 = a1[173];
  if (*(_BYTE *)(v6 + 20))
  {
    v7 = v6 + 1624;
    v8 = sub_1B67C8E9C(v6 + 1624, a2, a3);
    v9 = a1[434];
    v10 = a1[433];
    if (v9 != v10)
    {
      v11 = v8;
      while (1)
      {
        v12 = v9 - 16;
        v13 = *(_DWORD *)(v9 - 12);
        if ((int)v13 <= v5)
        {
          v14 = sub_1B67C8E9C(v7, v13 % v4, v13 / v4);
          if ((int)v11 >= v14 && v11 <= *(_DWORD *)(v9 - 8) + v14)
            break;
        }
        v9 -= 16;
        if (v12 == v10)
          return v10;
      }
      v9 -= 16;
    }
  }
  else
  {
    v15 = a1[434];
    v9 = a1[433];
    while (v15 != v9)
    {
      v16 = v15 - 16;
      v17 = *(_DWORD *)(v15 - 12);
      v15 -= 16;
      if (v17 <= v5)
        return v16;
    }
  }
  return v9;
}

uint64_t sub_1B67C8CAC(void **memptr, unint64_t a2)
{
  void *v4;
  uint64_t result;

  if ((unint64_t)memptr[1] >= a2)
    return 0;
  if (a2 > 0x3200000)
    return 4294954392;
  v4 = *memptr;
  if (v4)
  {
    free(v4);
    *memptr = 0;
    memptr[1] = 0;
  }
  if (malloc_type_posix_memalign(memptr, 0x10uLL, 2 * a2, 0x1000040BDFB0063uLL) || !*memptr)
    return 4294954392;
  bzero(*memptr, 2 * a2);
  result = 0;
  memptr[1] = (void *)a2;
  return result;
}

uint64_t sub_1B67C8D4C(void **memptr, unint64_t a2)
{
  void *v4;
  uint64_t result;
  uint64_t v6;
  unint64_t v7;
  char *v8;

  if ((unint64_t)memptr[1] >= a2)
    return 0;
  if (a2 > 0x855555)
    return 4294954392;
  v4 = *memptr;
  if (v4)
  {
    free(v4);
    *memptr = 0;
    memptr[1] = 0;
  }
  if (malloc_type_posix_memalign(memptr, 0x10uLL, 12 * a2, 0x10000403E1C8BA9uLL) || !*memptr)
    return 4294954392;
  v6 = 0;
  v7 = a2;
  do
  {
    v8 = (char *)*memptr + v6;
    *((_DWORD *)v8 + 2) = 0;
    *(_QWORD *)v8 = 0;
    v6 += 12;
    --v7;
  }
  while (v7);
  result = 0;
  memptr[1] = (void *)a2;
  return result;
}

uint64_t sub_1B67C8E04(int a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  _DWORD *v10;
  unsigned int v11;
  int v12;
  uint64_t v13;

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = a4 + 8;
  while (v5 < a1)
  {
    v8 = 0;
    v9 = *(unsigned __int16 *)(a3 + 2 * v4);
    v10 = (_DWORD *)(v7 + 12 * v5);
    do
    {
      *(v10 - 2) = v4;
      *(v10 - 1) = v6;
      *v10 = v6 + v9 + 1;
      v11 = v8;
      v12 = v8 + 1;
      if (v8 >= v9)
        break;
      v13 = v5 + 1 + v8;
      v10 += 3;
      ++v8;
    }
    while (v13 < a1);
    if (v11 < v9)
      break;
    v5 += v12;
    ++v4;
    v6 += v9 + 1;
    if (v4 == a2)
      return 0;
  }
  return 4294954387;
}

uint64_t sub_1B67C8E9C(uint64_t a1, int a2, int a3)
{
  int v3;
  int v4;

  if (!*(_BYTE *)(a1 + 72))
    return 0;
  v3 = *(_DWORD *)(a1 + 64);
  if (v3 <= a2 || *(_DWORD *)(a1 + 68) <= a3)
    return 0;
  v4 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 12 * a3);
  return (v4
                      + v4 * *(_DWORD *)(*(_QWORD *)(a1 + 32) + 12 * (v3 - 1))
                      + *(_DWORD *)(*(_QWORD *)(a1 + 32) + 12 * a2));
}

uint64_t sub_1B67C8EF8(void **a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t (*v5)(_QWORD *, void *);
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  unsigned int *v9;
  BOOL v10;
  uint64_t v11;

  result = sub_1B67C2364(a1, a2[4] + 4, 0x10uLL);
  if (!(_DWORD)result)
  {
    v5 = (uint64_t (*)(_QWORD *, void *))a2[5];
    v6 = a2[6];
    v7 = (_QWORD *)((char *)a2 + (v6 >> 1));
    if ((v6 & 1) != 0)
      v5 = *(uint64_t (**)(_QWORD *, void *))(*v7 + v5);
    v8 = v5(v7, *a1);
    v9 = (unsigned int *)*a1;
    if (v8)
      v10 = v9 == 0;
    else
      v10 = 1;
    if (v10)
    {
      return 4294954387;
    }
    else
    {
      v11 = v8;
      result = 0;
      a1[2] = v9;
      a1[3] = v9;
      a1[4] = (char *)v9 + v11;
      a1[5] = (void *)bswap32(*v9);
      *((_BYTE *)a1 + 48) = 0;
    }
  }
  return result;
}

uint64_t sub_1B67C8F84(void **a1, int a2)
{
  uint64_t result;
  char *v5;

  result = sub_1B67C2364(a1, (a2 + 4), 0x10uLL);
  if (!(_DWORD)result)
  {
    result = 4294954387;
    if (a2)
    {
      v5 = (char *)*a1;
      if (*a1)
      {
        result = 0;
        a1[2] = v5;
        a1[3] = v5;
        a1[4] = &v5[a2];
        *((_DWORD *)a1 + 11) = 0;
        *((_BYTE *)a1 + 48) = 0;
      }
    }
    *((_DWORD *)a1 + 10) = 0;
  }
  return result;
}

uint64_t sub_1B67C8FE0(uint64_t result, int a2, int a3)
{
  unsigned int v3;
  unint64_t v4;
  int v5;
  unint64_t v6;
  unint64_t v7;

  v3 = (a2 << (-(char)a3 - *(_DWORD *)(result + 44))) | *(_DWORD *)(result + 40);
  *(_DWORD *)(result + 40) = v3;
  **(_DWORD **)(result + 24) = bswap32(v3);
  v4 = *(int *)(result + 44) + (uint64_t)a3;
  v5 = *(_DWORD *)(result + 40) << (v4 & 0xF8);
  v6 = *(_QWORD *)(result + 32);
  v7 = *(_QWORD *)(result + 24) + (v4 >> 3);
  *(_QWORD *)(result + 24) = v7;
  *(_DWORD *)(result + 40) = v5;
  *(_DWORD *)(result + 44) = v4 & 7;
  if (v7 >= v6)
  {
    *(_BYTE *)(result + 48) = 1;
    *(_QWORD *)(result + 24) = v6;
  }
  return result;
}

uint64_t sub_1B67C9044(uint64_t a1, unsigned int a2, int a3)
{
  unsigned __int16 v3;
  uint64_t v4;

  v3 = a2;
  v4 = a1;
  if (a3 > 25)
  {
    sub_1B67C8FE0(a1, HIWORD(a2), a3 - 16);
    a2 = v3;
    a1 = v4;
    a3 = 16;
  }
  return sub_1B67C8FE0(a1, a2, a3);
}

uint64_t sub_1B67C9094(uint64_t a1, int a2)
{
  unsigned int v2;
  unint64_t v3;
  char v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int v7;

  v2 = *(_DWORD *)(a1 + 40);
  v3 = *(int *)(a1 + 44) + (uint64_t)a2;
  v4 = v3 & 7;
  *(_DWORD *)(a1 + 44) = v3 & 7;
  v5 = *(_QWORD *)(a1 + 32);
  v6 = (unsigned int *)(*(_QWORD *)(a1 + 24) + (v3 >> 3));
  *(_QWORD *)(a1 + 24) = v6;
  if ((unint64_t)v6 >= v5)
  {
    if ((unint64_t)v6 > v5)
      *(_QWORD *)(a1 + 24) = v5;
    v7 = v2;
  }
  else
  {
    v7 = bswap32(*v6);
  }
  *(_DWORD *)(a1 + 40) = v7 << v4;
  return v2 >> -(char)a2;
}

uint64_t sub_1B67C90EC(uint64_t a1, int a2)
{
  int v4;

  if (a2 <= 25)
    return sub_1B67C9094(a1, a2);
  v4 = sub_1B67C9094(a1, a2 - 16);
  return sub_1B67C9094(a1, 16) + (v4 << 16);
}

uint64_t sub_1B67C9140(uint64_t a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  unint64_t v4;
  unint64_t v5;
  unsigned int *v6;
  int v7;

  v1 = *(_DWORD *)(a1 + 40);
  if (!v1)
    return 0;
  v2 = __clz(v1);
  v3 = v1 << (v2 + 1) >> -(char)v2;
  if (!v2)
    v3 = 0;
  v4 = *(int *)(a1 + 44) + (unint64_t)((2 * v2) | 1);
  v5 = *(_QWORD *)(a1 + 32);
  v6 = (unsigned int *)(*(_QWORD *)(a1 + 24) + (v4 >> 3));
  v7 = v4 & 7;
  *(_DWORD *)(a1 + 44) = v7;
  *(_QWORD *)(a1 + 24) = v6;
  if ((unint64_t)v6 >= v5)
  {
    if ((unint64_t)v6 > v5)
      *(_QWORD *)(a1 + 24) = v5;
  }
  else
  {
    v1 = bswap32(*v6);
  }
  *(_DWORD *)(a1 + 40) = v1 << v7;
  return v3 + ~(-1 << v2);
}

uint64_t sub_1B67C91C8(uint64_t a1)
{
  unsigned int v3;

  if (*(_DWORD *)(a1 + 40) >> 19)
    return sub_1B67C9140(a1);
  v3 = -1;
  do
    ++v3;
  while (!sub_1B67C9094(a1, 1) && v3 < 0x20);
  return sub_1B67C90EC(a1, v3) + ~(-1 << v3);
}

uint64_t sub_1B67C9248(uint64_t a1, int a2)
{
  unsigned int v3;
  uint64_t result;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;

  v3 = a2 + 1;
  if (a2 == -1)
  {
    sub_1B67C8FE0(a1, 0, 16);
    sub_1B67C8FE0(a1, 0, 16);
    sub_1B67C8FE0(a1, 1, 1);
    sub_1B67C8FE0(a1, 0, 16);
    return sub_1B67C8FE0(a1, 0, 16);
  }
  else
  {
    v5 = __clz(v3);
    v6 = v5 ^ 0x1F;
    v7 = (v5 ^ 0x1F) >> 1;
    if ((v5 ^ 0x1F) >= 2)
      sub_1B67C8FE0(a1, 0, v6 >> 1);
    if (v6 != v7)
      sub_1B67C8FE0(a1, 0, v6 - (v6 >> 1));
    result = sub_1B67C8FE0(a1, 1, 1);
    v8 = v3 - (0x80000000 >> v5);
    if (v6 >= 2)
      result = sub_1B67C8FE0(a1, v8 >> (v6 - (v6 >> 1)), v6 >> 1);
    if (v6 != v7)
      return sub_1B67C8FE0(a1, v8, v6 - (v6 >> 1));
  }
  return result;
}

uint64_t sub_1B67C9368(uint64_t a1, int a2)
{
  int v2;
  unsigned int v3;
  unsigned int v4;

  if (a2 <= 0)
    v2 = -2 * a2;
  else
    v2 = 2 * a2 - 1;
  v3 = v2 + 1;
  v4 = __clz(v3);
  return sub_1B67C8FE0(a1, (v3 - (0x80000000 >> v4)) | (0x80000000 >> v4), 63 - 2 * v4);
}

uint64_t sub_1B67C939C(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  _BYTE *v4;

  result = sub_1B67C8FE0(a1, 1, 1);
  v3 = *(int *)(a1 + 44);
  if ((_DWORD)v3)
  {
    v4 = *(_BYTE **)(a1 + 24);
    if ((unint64_t)v4 < *(_QWORD *)(a1 + 32))
    {
      *v4 &= byte_1B693261C[v3];
      v4 = *(_BYTE **)(a1 + 24);
    }
    *(_QWORD *)(a1 + 24) = v4 + 1;
  }
  *(_QWORD *)(a1 + 40) = 0;
  return result;
}

uint64_t sub_1B67C9400(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t result;

  *(_BYTE *)(a1 + 24) = sub_1B67C9094(a2, 8);
  *(_BYTE *)(a1 + 25) = *(_BYTE *)(a1 + 25) & 0xFC | sub_1B67C9094(a2, 2) & 3;
  *(_BYTE *)(a1 + 25) = *(_BYTE *)(a1 + 25) & 0xFB | (4 * (sub_1B67C9094(a2, 1) != 0));
  *(_BYTE *)(a1 + 25) = *(_BYTE *)(a1 + 25) & 7 | (8 * sub_1B67C9094(a2, 5));
  v4 = sub_1B67C9094(a2, 16);
  *(_DWORD *)(a1 + 28) = sub_1B67C9094(a2, 16) + (v4 << 16);
  v5 = sub_1B67C9094(a2, 16);
  v6 = sub_1B67C9094(a2, 16) + (v5 << 16);
  *(_QWORD *)(a1 + 32) = sub_1B67C9094(a2, 16) | (unint64_t)(v6 << 16);
  *(_BYTE *)(a1 + 40) = sub_1B67C9094(a2, 8);
  v7 = sub_1B67C9094(a2, 4);
  *(_WORD *)(a1 + 42) = sub_1B67C9094(a2, 12);
  v8 = sub_1B67C9094(a2, 6);
  *(_BYTE *)(a1 + 44) = sub_1B67C9094(a2, 2);
  v9 = sub_1B67C9094(a2, 6);
  *(_BYTE *)(a1 + 45) = sub_1B67C9094(a2, 2);
  v10 = sub_1B67C9094(a2, 5);
  *(_BYTE *)(a1 + 46) = sub_1B67C9094(a2, 3);
  v11 = sub_1B67C9094(a2, 5);
  *(_BYTE *)(a1 + 47) = sub_1B67C9094(a2, 3);
  *(_WORD *)(a1 + 48) = sub_1B67C9094(a2, 16);
  *(_BYTE *)(a1 + 50) = *(_BYTE *)(a1 + 50) & 0xFC | sub_1B67C9094(a2, 2) & 3;
  *(_BYTE *)(a1 + 50) = (4 * (sub_1B67C9094(a2, 3) & 7)) | *(_BYTE *)(a1 + 50) & 0xE3;
  *(_BYTE *)(a1 + 50) = *(_BYTE *)(a1 + 50) & 0xDF | (32 * (sub_1B67C9094(a2, 1) != 0));
  *(_BYTE *)(a1 + 50) = *(_BYTE *)(a1 + 50) & 0x3F | (sub_1B67C9094(a2, 2) << 6);
  *(_BYTE *)(a1 + 51) = sub_1B67C9094(a2, 8);
  result = 4294954394;
  if (*(_BYTE *)(a1 + 24) == 1 && v7 == 15 && v8 == 63 && v9 == 63 && v10 == 31 && v11 == 31)
  {
    if (*(unsigned __int8 *)(a1 + 50) >= 0x40u)
    {
      if ((((*(_BYTE *)(a1 + 50) >> 6) - 1) & 0xFFFFFFFD) != 0)
        return 4294954394;
      else
        return 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1B67C96A0(uint64_t a1)
{
  uint64_t i;

  sub_1B6772C88(a1 + 1568);
  sub_1B6772C88(a1 + 1552);
  sub_1B6772C88(a1 + 1536);
  for (i = 1520; i != 496; i -= 16)
    sub_1B6772C88(a1 + i);
  do
  {
    sub_1B6772C88(a1 + i);
    i -= 16;
  }
  while (i != 240);
  do
  {
    sub_1B6772C88(a1 + i);
    i -= 16;
  }
  while (i != -16);
  return a1;
}

uint64_t sub_1B67C9718(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  void *v10;
  unsigned int *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int *v15;
  int v16;
  unint64_t v17;
  unsigned int v18;
  unint64_t v19;
  char v20;
  unsigned int *v21;
  unsigned int v22;
  unint64_t v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int v26;
  unint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  unint64_t v38;
  uint64_t v39;
  unsigned int *v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v48;
  uint64_t v49;
  unsigned int *v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v56;
  int v57;
  void *v58[2];
  unsigned int *v59;
  unsigned int *v60;
  char *v61;
  unsigned int v62;
  int v63;
  char v64;
  _OWORD v65[2];
  uint64_t v66;
  _OWORD v67[2];
  uint64_t v68;
  uint64_t v69;

  v9 = 0;
  v69 = *MEMORY[0x1E0C80C00];
  do
  {
    v10 = *(void **)(a4 + v9);
    if (v10)
      bzero(v10, *(_QWORD *)(a5 + v9));
    v9 += 8;
  }
  while (v9 != 40);
  v11 = *(unsigned int **)a1;
  if (!*(_QWORD *)a1)
    return 4294954394;
  v12 = *(_QWORD *)(a1 + 16);
  if (!v12)
    return 4294954394;
  v58[0] = 0;
  v58[1] = 0;
  v59 = v11;
  v60 = v11;
  v61 = (char *)v11 + v12;
  v62 = bswap32(*v11);
  v63 = 0;
  v64 = 0;
  v13 = sub_1B67C9400(a1, (uint64_t)v58);
  if (!(_DWORD)v13)
  {
    v68 = 0;
    memset(v67, 0, sizeof(v67));
    v66 = 0;
    memset(v65, 0, sizeof(v65));
    v14 = *(unsigned __int8 *)(a1 + 51);
    v15 = v60;
    v50 = v59;
    if (*(_BYTE *)(a1 + 51))
    {
      v16 = 0;
      v17 = (unint64_t)v61;
      v18 = v62;
      v57 = v63;
      v48 = a2;
      v49 = a1;
      v51 = a5;
      v53 = a4;
      do
      {
        v19 = v57 + 1;
        v20 = v19 & 7;
        v63 = v19 & 7;
        v21 = (unsigned int *)((char *)v15 + (v19 >> 3));
        v60 = v21;
        if ((unint64_t)v21 >= v17)
        {
          if ((unint64_t)v21 > v17)
            v21 = (unsigned int *)v17;
        }
        else
        {
          v18 = bswap32(*v21);
        }
        v22 = v18 << v20;
        v23 = (v19 & 7) + 1;
        v62 = v18 << v20;
        v63 = v23 & 7;
        v24 = (unsigned int *)((char *)v21 + (v23 >> 3));
        v60 = v24;
        if ((unint64_t)v24 >= v17)
        {
          if ((unint64_t)v24 > v17)
            v24 = (unsigned int *)v17;
          v25 = v18 << v20;
        }
        else
        {
          v25 = bswap32(*v24);
        }
        v26 = v25 << (v23 & 7);
        v62 = v26;
        if ((v22 & 0x80000000) != 0)
          goto LABEL_62;
        v27 = (v23 & 7) + 6;
        v57 = v27 & 7;
        v63 = v57;
        v28 = (unsigned int *)((char *)v24 + (v27 >> 3));
        v60 = v28;
        if ((unint64_t)v28 >= v17)
        {
          if ((unint64_t)v28 > v17)
            v28 = (unsigned int *)v17;
          v29 = v25 << (v23 & 7);
        }
        else
        {
          v29 = bswap32(*v28);
        }
        v30 = v29 << v57;
        v62 = v30;
        v63 = v57;
        v15 = (unsigned int *)((char *)v28 + 2);
        v60 = v15;
        if ((unint64_t)v15 >= v17)
        {
          if ((unint64_t)v15 > v17)
          {
            v60 = (unsigned int *)v17;
            v15 = (unsigned int *)v17;
          }
          v31 = v30;
        }
        else
        {
          v31 = bswap32(*v15);
        }
        v32 = v26 >> 26;
        v18 = v31 << v57;
        v62 = v31 << v57;
        v33 = v32 - 32;
        if (v32 - 32 > 8 || ((0x187u >> v33) & 1) == 0)
        {
LABEL_62:
          v13 = 4294954394;
          goto LABEL_63;
        }
        v52 = v16;
        v34 = qword_1B6920600[v33];
        v35 = *(_QWORD *)(a2 + 8 * v34);
        v36 = *(_QWORD *)(a4 + 8 * v34);
        if (v35)
          v37 = v36 == 0;
        else
          v37 = 1;
        if (v37)
          v56 = 0;
        else
          v56 = *(_QWORD *)(v51 + 8 * v34) >> 3;
        if (v30 >= 0x10000)
        {
          v38 = 0;
          v39 = HIWORD(v30);
          v54 = *(_QWORD *)(a4 + 8 * v34);
          while (1)
          {
            v40 = (unsigned int *)((char *)v15 + 2);
            if ((unint64_t)v15 + 2 >= v17)
            {
              if ((unint64_t)v15 + 2 > v17)
                v40 = (unsigned int *)v17;
              v41 = v18;
            }
            else
            {
              v41 = bswap32(*v40);
            }
            v42 = HIWORD(v18);
            if (v35 && v56 > v38 && v36)
            {
              v43 = *((_QWORD *)v67 + v34);
              v44 = v43 + v42;
              if (v44 > *(_QWORD *)(a3 + 8 * v34))
              {
                v13 = 4294940770;
                goto LABEL_63;
              }
              v45 = *((_QWORD *)v65 + v34);
              *(_QWORD *)(v36 + 8 * v45) = v42;
              v46 = v39;
              memcpy((void *)(v35 + v43), v40, HIWORD(v18));
              v39 = v46;
              a4 = v53;
              v36 = v54;
              *((_QWORD *)v67 + v34) = v44;
              *((_QWORD *)v65 + v34) = v45 + 1;
            }
            v15 = (unsigned int *)((char *)v40 + v42);
            if ((unint64_t)v15 >= v17)
            {
              v18 = v41 << v57;
              if ((unint64_t)v15 > v17)
                v15 = (unsigned int *)v17;
            }
            else
            {
              v18 = bswap32(*v15);
            }
            if (v39 == ++v38)
            {
              v62 = v18;
              v63 = v57;
              v60 = v15;
              a2 = v48;
              a1 = v49;
              v14 = *(unsigned __int8 *)(v49 + 51);
              break;
            }
          }
        }
        v16 = v52 + 1;
      }
      while (v52 + 1 < v14);
    }
    if ((unint64_t)((char *)v15 - (char *)v50) <= *(_QWORD *)(a1 + 16))
      v13 = 0;
    else
      v13 = 4294940770;
  }
LABEL_63:
  if (v58[0])
    free(v58[0]);
  return v13;
}

uint64_t sub_1B67C9AC0(_BYTE *a1, uint64_t a2)
{
  int v4;

  a1[24] = sub_1B67C9094(a2, 8);
  a1[25] = sub_1B67C9094(a2, 8);
  a1[26] = sub_1B67C9094(a2, 8);
  a1[27] = sub_1B67C9094(a2, 8);
  v4 = sub_1B67C9094(a2, 6);
  a1[28] = sub_1B67C9094(a2, 2);
  if (sub_1B67C9094(a2, 3) == 7 && v4 == 63 && a1[24] == 1)
    return 0;
  else
    return 4294954394;
}

void sub_1B67C9B70(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;

  v3 = *a1;
  v2 = a1[1];
  if (v2 != *a1)
  {
    v4 = a1[1];
    do
    {
      v6 = *(void **)(v4 - 24);
      v4 -= 24;
      v5 = v6;
      if (v6)
      {
        *(_QWORD *)(v2 - 16) = v5;
        operator delete(v5);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

_QWORD *sub_1B67C9BC4(_QWORD *a1, size_t a2)
{
  char *v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1B67C9E7C(a1, a2);
    v4 = (char *)a1[1];
    v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1B67C9C18(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1B67C9C34(_QWORD *result, const void *a2, uint64_t a3, size_t __sz)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (__sz)
  {
    v6 = result;
    result = sub_1B67C9E7C(result, __sz);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B67C9C90(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1B67C9CAC(uint64_t *a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  __int128 v13;
  int64x2_t v14;
  char *v15;
  char *v17;
  int64x2_t v18;
  char *v19;
  _QWORD *v20;

  v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL)
    sub_1B6773BAC();
  if (0x5555555555555556 * ((a1[2] - *a1) >> 3) > v3)
    v3 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555)
    v6 = 0xAAAAAAAAAAAAAAALL;
  else
    v6 = v3;
  v20 = a1 + 2;
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL)
      sub_1B6773BF4();
    v7 = (char *)operator new(24 * v6);
  }
  else
  {
    v7 = 0;
  }
  v8 = &v7[24 * v2];
  v17 = v7;
  v18.i64[0] = (uint64_t)v8;
  v18.i64[1] = (uint64_t)v8;
  v19 = &v7[24 * v6];
  *((_QWORD *)v8 + 1) = 0;
  *((_QWORD *)v8 + 2) = 0;
  *(_QWORD *)v8 = 0;
  sub_1B67C9C34(v8, *(const void **)a2, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  v9 = v18.i64[0];
  v10 = v18.i64[1] + 24;
  v18.i64[1] += 24;
  v12 = (_QWORD *)*a1;
  v11 = (_QWORD *)a1[1];
  if (v11 == (_QWORD *)*a1)
  {
    v14 = vdupq_n_s64((unint64_t)v11);
  }
  else
  {
    do
    {
      *(_QWORD *)(v9 - 24) = 0;
      *(_QWORD *)(v9 - 16) = 0;
      v9 -= 24;
      *(_QWORD *)(v9 + 16) = 0;
      v13 = *(_OWORD *)(v11 - 3);
      v11 -= 3;
      *(_OWORD *)v9 = v13;
      *(_QWORD *)(v9 + 16) = v11[2];
      *v11 = 0;
      v11[1] = 0;
      v11[2] = 0;
    }
    while (v11 != v12);
    v14 = *(int64x2_t *)a1;
    v10 = v18.i64[1];
  }
  *a1 = v9;
  a1[1] = v10;
  v18 = v14;
  v15 = (char *)a1[2];
  a1[2] = (uint64_t)v19;
  v19 = v15;
  v17 = (char *)v14.i64[0];
  sub_1B67C9E1C((uint64_t)&v17);
  return v10;
}

void sub_1B67C9E08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1B67C9E1C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1B67C9E1C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    v4 = *(void **)(v2 - 24);
    *(_QWORD *)(a1 + 16) = v2 - 24;
    if (v4)
    {
      *(_QWORD *)(v2 - 16) = v4;
      operator delete(v4);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

char *sub_1B67C9E7C(_QWORD *a1, size_t __sz)
{
  char *result;

  if ((__sz & 0x8000000000000000) != 0)
    sub_1B6773BAC();
  result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

uint64_t *sub_1B67C9EB8(uint64_t *result, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t *a5, int *a6, int a7, int a8)
{
  uint64_t *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;

  if ((int)a3 >= 17 && (int)a4 >= 17 && a7 >= 17 && a8 >= 17)
  {
    v13 = result;
    v14 = (a7 << 16) / (int)a3;
    v15 = *result;
    v16 = *a2;
    v17 = *a5;
    v18 = a4 >> 1;
    v19 = a3 >> 1;
    v20 = *a6;
    v21 = a7 >> 1;
    v22 = a8 >> 1;
    if (v14 <= 0x20000)
    {
      sub_1B67CA248(0, a4, v15, v16, a3, a4, v17, v20, a7, a8, (uint64_t (*)(uint64_t, uint16x8_t *, _QWORD, _DWORD *, _BYTE *, _BYTE *, uint64_t))BilinearFilterH_vperm2_neon64);
      return (uint64_t *)sub_1B67CA248(1, v18, v13[1], a2[1], v19, v18, a5[1], a6[1], v21, v22, (uint64_t (*)(uint64_t, uint16x8_t *, _QWORD, _DWORD *, _BYTE *, _BYTE *, uint64_t))BilinearFilterH_chroma_vperm2_neon64);
    }
    else
    {
      sub_1B67CA00C(0, a4, v15, v16, a3, a4, v17, v20, a7, (uint64_t (*)(uint64_t, uint16x8_t *, _QWORD, _QWORD, unint64_t, uint64_t))BilinearFilterH_swift_neon);
      return (uint64_t *)sub_1B67CA00C(1, v18, v13[1], a2[1], v19, v18, a5[1], a6[1], v21, (uint64_t (*)(uint64_t, uint16x8_t *, _QWORD, _QWORD, unint64_t, uint64_t))BilinearFilterH_swift_chroma_neon);
    }
  }
  return result;
}

uint64_t sub_1B67CA00C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, int a9, uint64_t (*a10)(uint64_t, uint16x8_t *, _QWORD, _QWORD, unint64_t, uint64_t))
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint16x8_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  unsigned __int16 v24;
  uint64_t v25;
  unint64_t v26;
  int v27;
  uint64_t v28;
  uint64x2_t v29;
  int64x2_t v30;
  int64x2_t v31;
  __int16 v32;
  int32x2_t v33;
  unsigned int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  int v40;
  int v41;
  uint64_t result;
  _BYTE v43[4];
  int v44;
  uint64_t v45;
  int v46;
  uint64_t (*v47)(uint64_t, uint16x8_t *, _QWORD, _QWORD, unint64_t, uint64_t);
  int v48;
  unsigned int v49;
  uint64_t v50;
  int v51;
  unsigned int v52;
  uint64_t v53;

  v51 = a8;
  v50 = a7;
  v10 = a3;
  v11 = a2;
  v47 = a10;
  v53 = *MEMORY[0x1E0C80C00];
  v48 = a1;
  v46 = a9 << a1;
  v12 = MEMORY[0x1E0C80A78](a1, a2, a3, a4, a5, a6);
  v14 = (uint16x8_t *)((unint64_t)&v43[-v13 + 15] & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12, v15, v16, v17, v18, v19);
  v24 = 0;
  v25 = 0;
  v26 = (unint64_t)&v43[-((v23 + 47) & 0x1FFFFFFF0) + 15] & 0xFFFFFFFFFFFFFFF0;
  v49 = v27;
  v28 = (v23 + 1) & 0x1FFFFFFFELL;
  v29 = (uint64x2_t)vdupq_n_s64(v23 - 1);
  v30 = (int64x2_t)xmmword_1B6917590;
  v31 = vdupq_n_s64(2uLL);
  v52 = (a9 << 16) / v27;
  v32 = 2 * v52;
  do
  {
    v33 = vmovn_s64((int64x2_t)vcgeq_u64(v29, (uint64x2_t)v30));
    if ((v33.i8[0] & 1) != 0)
      *(_BYTE *)(v26 + v25) = v24 >> 12;
    if ((v33.i8[4] & 1) != 0)
      *(_BYTE *)(v26 + v25 + 1) = (unsigned __int16)(v52 + v24) >> 12;
    v25 += 2;
    v30 = vaddq_s64(v30, v31);
    v24 += v32;
  }
  while (v28 != v25);
  v34 = 0;
  v35 = v22 - 1;
  v36 = (2 * a9);
  v45 = (int)v36 - 2;
  v44 = (2 * a9) | 1;
  v37 = v20;
  v38 = (v22 << 16) / v21;
  do
  {
    if (v35 >= (int)(HIWORD(v34) + 1))
      v39 = HIWORD(v34) + 1;
    else
      v39 = v35;
    BilinearFilterV_swift_neon(v14, (uint8x16_t *)(v50 + HIWORD(v34) * (uint64_t)v51), (uint8x16_t *)(v50 + v39 * (uint64_t)v51), v46, (unsigned __int16)v34 >> 12);
    v40 = a9;
    v41 = a9;
    if (v48)
    {
      v14->i16[v36] = v14->i16[v45];
      v40 = v44;
      v41 = 2 * a9;
    }
    v34 += v38;
    v14->i16[v40] = v14->i16[v41 - 1];
    result = v47(v10, v14, v49, v52, v26, 16);
    v10 += v37;
    --v11;
  }
  while (v11);
  return result;
}

uint64_t sub_1B67CA248(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, int a9, int a10, uint64_t (*a11)(uint64_t, uint16x8_t *, _QWORD, _DWORD *, _BYTE *, _BYTE *, uint64_t))
{
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint16x8_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  _DWORD *v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  _BYTE *v42;
  int v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  unsigned int v49;
  _DWORD *v50;
  unsigned int v51;
  char v52;
  _BYTE *v53;
  int v54;
  int v55;
  unsigned int v56;
  unsigned int v57;
  _BYTE *v58;
  unsigned int v59;
  unsigned int v60;
  int v61;
  unsigned int v62;
  uint64_t v63;
  int v64;
  int v65;
  int v66;
  uint64_t result;
  _BYTE v68[12];
  int v69;
  uint64_t v70;
  _DWORD *v71;
  int v72;
  int v73;
  uint64_t v74;
  int v75;
  int v76;
  unsigned int v77;
  _BYTE *v78;
  uint64_t v79;

  v75 = a8;
  v74 = a7;
  v11 = a4;
  v12 = a3;
  v13 = a2;
  v79 = *MEMORY[0x1E0C80C00];
  v72 = a9 << a1;
  v14 = MEMORY[0x1E0C80A78](a1, a2, a3, a4, a5, a6);
  v16 = (uint16x8_t *)&v68[-v15];
  v22 = MEMORY[0x1E0C80A78](v14, v17, v18, v19, v20, v21);
  v78 = &v68[-v23];
  v29 = MEMORY[0x1E0C80A78](v22, v24, v25, v26, v27, v28);
  v35 = MEMORY[0x1E0C80A78](v29, v31, &v68[-v30], v32, v33, v34);
  v42 = &v68[-v41];
  v76 = v43;
  v77 = v37;
  v44 = v37;
  v45 = (v43 << 16) / (int)v37;
  v73 = v35;
  v71 = v36;
  v46 = 0;
  if (v35)
  {
    v47 = 0;
    v48 = 0;
    v49 = 0;
    v50 = v36;
    do
    {
      v51 = HIWORD(v48);
      v52 = (unsigned __int16)v48 >> 12;
      v53 = &v78[v46];
      v53[1] = v52;
      *v53 = v52;
      if ((v47 & 3) == 0)
      {
        *v50++ = 4 * v51;
        v49 = HIWORD(v48);
      }
      v48 += v45;
      v54 = 67372036 * (v51 - v49);
      v55 = v46 & 0x7FFFFFF8 | v47 & 3;
      *(_DWORD *)&v42[4 * v55] = v54 + v39;
      *(_DWORD *)&v42[4 * (v55 | 4)] = v54 + 117835012;
      ++v47;
      v46 += 2;
    }
    while (v44 != v47);
  }
  else
  {
    v56 = 0;
    v57 = 0;
    v50 = v36;
    v58 = v78;
    do
    {
      v59 = HIWORD(v56);
      v58[v46] = (unsigned __int16)v56 >> 12;
      if ((v46 & 3) == 0)
      {
        *v50++ = 2 * v59;
        v57 = HIWORD(v56);
      }
      v56 += v45;
      *(_DWORD *)&v42[4 * v46++] = v39 + 33686018 * (v59 - v57);
    }
    while (v37 != v46);
  }
  v60 = v77 + 4;
  if (v40 > (int)(v77 + 4))
    v60 = v40;
  v61 = (a10 << 16) / v38;
  bzero(v50, ((v60 + ~v77) & 0xFFFFFFFC) + 4);
  v62 = 0;
  v63 = (2 * v76);
  v70 = (int)v63 - 2;
  v69 = (2 * v76) | 1;
  do
  {
    if (a10 - 1 >= (HIWORD(v62) + 1))
      v64 = HIWORD(v62) + 1;
    else
      v64 = a10 - 1;
    BilinearFilterV_swift_neon(v16, (uint8x16_t *)(v74 + HIWORD(v62) * v75), (uint8x16_t *)(v74 + (v64 * v75)), v72, (unsigned __int16)v62 >> 12);
    v65 = v76;
    v66 = v76;
    if (v73)
    {
      v16->i16[v63] = v16->i16[v70];
      v66 = v69;
      v65 = v63;
    }
    v62 += v61;
    v16->i16[v66] = v16->i16[v65 - 1];
    result = a11(v12, v16, v77, v71, v78, v42, 16);
    v12 += v11;
    --v13;
  }
  while (v13);
  return result;
}

uint64_t sub_1B67CA56C(uint64_t a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = (pthread_mutex_t *)(a1 + 104);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 104));
  while (1)
  {
    if (!*(_DWORD *)(a1 + 172))
      pthread_cond_wait((pthread_cond_t *)(a1 + 8), v2);
    if (*(_DWORD *)(a1 + 168))
      break;
    if (((*(_DWORD *)(a1 + 228) << 16) / *(_DWORD *)(a1 + 196)) <= 0x20000)
    {
      sub_1B67CAB4C(0, a1 + 176, (void (*)(uint64_t, uint16x8_t *, _QWORD, char *, uint64_t, uint64_t, _QWORD))BilinearFilterH_vperm2_neon64, v3, v4, v5);
      sub_1B67CAB4C(1u, a1 + 256, (void (*)(uint64_t, uint16x8_t *, _QWORD, char *, uint64_t, uint64_t, _QWORD))BilinearFilterH_chroma_vperm2_neon64, v9, v10, v11);
    }
    else
    {
      sub_1B67CA72C(0, a1 + 176, (uint64_t (*)(uint64_t, uint16x8_t *, _QWORD, uint64_t, unint64_t, _QWORD))BilinearFilterH_swift_neon, v3, v4, v5);
      sub_1B67CA72C(1, a1 + 256, (uint64_t (*)(uint64_t, uint16x8_t *, _QWORD, uint64_t, unint64_t, _QWORD))BilinearFilterH_swift_chroma_neon, v6, v7, v8);
    }
    *(_DWORD *)(a1 + 172) = 0;
    pthread_cond_signal((pthread_cond_t *)(a1 + 56));
  }
  pthread_mutex_unlock(v2);
  return 0;
}

void sub_1B67CA678(char *a1)
{
  uint64_t v2;
  char v3;
  char v4;
  pthread_t *v5;
  char *v6;
  char *v7;

  if (a1)
  {
    v2 = 0;
    v3 = 1;
    do
    {
      v4 = v3;
      v5 = (pthread_t *)&a1[336 * v2];
      if (*v5)
      {
        v6 = &a1[336 * v2];
        pthread_mutex_lock((pthread_mutex_t *)(v6 + 104));
        *((_DWORD *)v6 + 42) = 1;
        pthread_cond_signal((pthread_cond_t *)(v6 + 8));
        pthread_mutex_unlock((pthread_mutex_t *)(v6 + 104));
        pthread_join(*v5, 0);
      }
      v7 = &a1[336 * v2];
      pthread_mutex_destroy((pthread_mutex_t *)(v7 + 104));
      pthread_cond_destroy((pthread_cond_t *)(v7 + 56));
      pthread_cond_destroy((pthread_cond_t *)(v7 + 8));
      v3 = 0;
      v2 = 1;
    }
    while ((v4 & 1) != 0);
  }
  free(a1);
}

uint64_t sub_1B67CA72C(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint16x8_t *, _QWORD, uint64_t, unint64_t, _QWORD), uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  _BYTE *v28;
  int v29;
  int v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  uint16x8_t *v36;
  int v37;
  uint8x16_t *v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __int128 *v45;
  int v46;
  _BYTE *v47;
  int v48;
  int v49;
  uint8x16_t *v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  int v57;
  __int128 *v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  uint64_t v64;
  _BYTE v65[4];
  int v66;
  int v67;
  unsigned int v68;
  unint64_t v69;
  uint64_t (*v70)(uint64_t, uint16x8_t *, _QWORD, uint64_t, unint64_t, _QWORD);
  unsigned int v71;
  int v72;
  _BYTE *v73;
  uint64_t v74;
  uint64_t v75;

  v70 = a3;
  v7 = a1;
  v75 = *MEMORY[0x1E0C80C00];
  v8 = MEMORY[0x1E0C80A78](a1, *(unsigned int *)(a2 + 52), a3, a4, ((*(_DWORD *)(a2 + 52) << a1) + 16), a6);
  MEMORY[0x1E0C80A78](v8, v9, *(int *)(a2 + 20), v10, v11, v12);
  v14 = (unint64_t)&v65[-((v13 + 47) & 0xFFFFFFFFFFFFFFF0) + 15] & 0xFFFFFFFFFFFFFFF0;
  result = MEMORY[0x1E0C80A78](*(unsigned int *)(a2 + 76), v16, v13, (4 * v15 + 15) & 0x7FFFFFFF0, v15, v17);
  v28 = &v65[-v27];
  v29 = *(_DWORD *)(a2 + 56);
  v30 = *(_DWORD *)(a2 + 24);
  if (v20 < 1)
  {
    v33 = v24;
  }
  else
  {
    v31 = 0;
    v32 = 0;
    do
    {
      *(_BYTE *)(v14 + v31) = (unsigned __int16)v32 >> 12;
      v32 += (v19 << 16) / v20;
      ++v31;
    }
    while (v31 < *(int *)(a2 + 20));
    v33 = *(_DWORD *)(a2 + 64);
  }
  if (v33 < *(_DWORD *)(a2 + 68))
  {
    v66 = -v23;
    v34 = v25 + (int)(((result + v24) & -v23) * v26 + 16 * ((result + v24) & (v23 - 1)));
    v67 = (v29 << 16) / v30;
    v68 = (v19 << 16) / v20;
    v35 = v67 * v24;
    v36 = (uint16x8_t *)((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
    v71 = 16 * v23;
    v72 = v23 - 1;
    v37 = -1;
    v73 = v28;
    v74 = v21;
    v69 = v14;
    while (1)
    {
      v38 = (uint8x16_t *)&v28[v21 * (unint64_t)(HIWORD(v35) & 3)];
      v39 = HIWORD(v35) + 1;
      if ((int)HIWORD(v35) <= v37)
        goto LABEL_14;
      v40 = *(_DWORD *)(a2 + 76);
      v41 = v40 + HIWORD(v35);
      v42 = *(unsigned int *)(a2 + 48);
      v43 = *(_QWORD *)(a2 + 32);
      v44 = *(_QWORD *)(a2 + 40);
      if (v44)
        break;
      v45 = (__int128 *)(v43 + (int)((v41 & v66) * v42 + 16 * (v41 & v72)));
      if (((v40 + v39) & v72) == 0)
      {
        DetileRow_neon(v38, v45, *(_DWORD *)(a2 + 52) << v7, v71);
        goto LABEL_11;
      }
      v47 = v73;
      v46 = v74;
      Detile2Rows_neon(v38, &v73[v74 * (unint64_t)((BYTE2(v35) + 1) & 3)], v45, *(_DWORD *)(a2 + 52) << v7, v71);
      v28 = v47;
      LODWORD(v21) = v46;
      v37 = HIWORD(v35) + 1;
LABEL_14:
      v48 = *(_DWORD *)(a2 + 56);
      if (v48 <= v39)
        v49 = v48 - 1;
      else
        v49 = HIWORD(v35) + 1;
      v50 = (uint8x16_t *)&v28[v21 * (unint64_t)(v49 & 3)];
      if (v49 <= v37)
        goto LABEL_28;
      v51 = *(_DWORD *)(a2 + 76);
      v52 = (v49 + v51);
      v53 = *(unsigned int *)(a2 + 48);
      v54 = *(_QWORD *)(a2 + 32);
      v55 = *(_QWORD *)(a2 + 40);
      if (v55)
      {
        off_1EF1391B8(v50, v54, v52, (*(_DWORD *)(a2 + 52) << v7), v53, v55, v7 != 0);
      }
      else
      {
        v57 = v49 + 1;
        v58 = (__int128 *)(v54 + (int)((v52 & v66) * v53 + 16 * (v52 & v72)));
        if (((v57 + v51) & v72) != 0)
        {
          Detile2Rows_neon(v50, &v73[v74 * (unint64_t)(v57 & 3)], v58, *(_DWORD *)(a2 + 52) << v7, v71);
          v59 = *(_DWORD *)(a2 + 56);
          if (v59 <= v39)
            v60 = v59 - 1;
          else
            v60 = HIWORD(v35) + 1;
          v37 = v60 + 1;
          goto LABEL_28;
        }
        DetileRow_neon(v50, v58, *(_DWORD *)(a2 + 52) << v7, v71);
      }
      v56 = *(_DWORD *)(a2 + 56);
      if (v56 <= v39)
        v37 = v56 - 1;
      else
        v37 = HIWORD(v35) + 1;
LABEL_28:
      v61 = v33 + *(_DWORD *)(a2 + 76);
      if ((v61 & v72) == 0)
        v34 = *(_QWORD *)a2 + *(int *)(a2 + 16) * (uint64_t)(v61 & v66);
      BilinearFilterV_swift_neon(v36, v38, v50, *(_DWORD *)(a2 + 52) << v7, (unsigned __int16)v35 >> 12);
      v62 = *(_DWORD *)(a2 + 52);
      if (v7)
      {
        v63 = 2 * v62;
        v36->i16[2 * v62] = v36->i16[2 * v62 - 2];
        v62 = (2 * v62) | 1;
      }
      else
      {
        v63 = *(_DWORD *)(a2 + 52);
      }
      v64 = v68;
      v35 += v67;
      v36->i16[v62] = v36->i16[v63 - 1];
      result = v70(v34, v36, *(unsigned int *)(a2 + 20), v64, v69, v71);
      v34 += 16;
      ++v33;
      v28 = v73;
      LODWORD(v21) = v74;
      if (v33 >= *(_DWORD *)(a2 + 68))
        return result;
    }
    off_1EF1391B8(v38, v43, v41, (*(_DWORD *)(a2 + 52) << v7), v42, v44, v7 != 0);
LABEL_11:
    v37 = HIWORD(v35);
    v28 = v73;
    LODWORD(v21) = v74;
    goto LABEL_14;
  }
  return result;
}

void sub_1B67CAB4C(unsigned int a1, uint64_t a2, void (*a3)(uint64_t, uint16x8_t *, _QWORD, char *, uint64_t, uint64_t, _QWORD), uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v9;
  uint16x8_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t *v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  unsigned int v53;
  _DWORD *v54;
  unsigned int v55;
  char v56;
  _BYTE *v57;
  int v58;
  unsigned int v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  int v64;
  int v65;
  uint64_t v66;
  unsigned int v67;
  int v68;
  unsigned int v69;
  char *v70;
  uint8x16_t *v71;
  int v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  __int128 *v78;
  unsigned int v79;
  char *v80;
  int v81;
  int v82;
  uint8x16_t *v83;
  int v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  __int128 *v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  int v100;
  int v101;
  uint64_t v102;
  uint64_t v103;
  void (*v104)(uint64_t, uint16x8_t *, _QWORD, char *, uint64_t, uint64_t, _QWORD);
  char *v105;
  unsigned int v106;
  int v107;
  char *v108;
  uint64_t v109;
  uint64_t v110;

  v104 = a3;
  v110 = *MEMORY[0x1E0C80C00];
  v8 = MEMORY[0x1E0C80A78](((*(_DWORD *)(a2 + 52) << a1) + 16), a2, a3, a4, a5, a6);
  v10 = (uint16x8_t *)((char *)&v99 - v9);
  v16 = MEMORY[0x1E0C80A78](v8, v11, v12, v13, v14, v15);
  v22 = MEMORY[0x1E0C80A78](v16, v18, v19, v20, v21, (char *)&v99 - v17);
  v105 = (char *)&v99 - v23;
  v29 = MEMORY[0x1E0C80A78](v22, v24, v25, v26, v27, v28);
  v30 = *((_DWORD *)&qword_1EF137CC8 + a1);
  v32 = *v31;
  v33 = *((_DWORD *)v31 + 16);
  v34 = v33;
  v35 = *((_DWORD *)v31 + 19);
  v106 = *((_DWORD *)v31 + 4);
  v109 = v29;
  MEMORY[0x1E0C80A78](v29, v31, v36, v37, v38, v39);
  v108 = (char *)&v99 - v44;
  v47 = *(_DWORD *)(v46 + 56);
  v48 = *(_DWORD *)(v46 + 24);
  v49 = (v45 << 16) / (int)v42;
  v102 = v41;
  v103 = v40;
  if (a1)
  {
    if ((int)v42 >= 1)
    {
      v50 = 0;
      v51 = 0;
      v52 = 0;
      v53 = 0;
      v54 = v105;
      do
      {
        v55 = HIWORD(v52);
        v56 = (unsigned __int16)v52 >> 12;
        v57 = (_BYTE *)(v40 + v50);
        v57[1] = v56;
        *v57 = v56;
        if ((v51 & 3) == 0)
        {
          *v54++ = 4 * v55;
          v53 = HIWORD(v52);
        }
        v52 += v49;
        v58 = 67372036 * (v55 - v53);
        v59 = v50 & 0x7FFFFFF8 | v51 & 3;
        *(_DWORD *)(v41 + 4 * v59) = v58 + 50462976;
        *(_DWORD *)(v41 + 4 * (v59 | 4)) = v58 + 117835012;
        ++v51;
        v50 += 2;
      }
      while (v42 != v51);
      goto LABEL_16;
    }
  }
  else if ((int)v42 >= 1)
  {
    v60 = 0;
    v61 = 0;
    v62 = 0;
    v54 = v105;
    do
    {
      v63 = HIWORD(v61);
      *(_BYTE *)(v40 + v60) = (unsigned __int16)v61 >> 12;
      if ((v60 & 3) == 0)
      {
        *v54++ = 2 * v63;
        v62 = HIWORD(v61);
      }
      v61 += v49;
      *(_DWORD *)(v41 + 4 * v60++) = 33686018 * (v63 - v62) + 50462976;
    }
    while (v42 != v60);
    goto LABEL_16;
  }
  if ((int)v42 <= -16)
    goto LABEL_19;
  LODWORD(v42) = 0;
  v54 = v105;
LABEL_16:
  v64 = v42 + 4;
  if (v43 > (int)v42 + 4)
    v64 = v43;
  bzero(v54, ((v64 + ~(_DWORD)v42) & 0xFFFFFFFC) + 4);
  v34 = *(_DWORD *)(a2 + 64);
LABEL_19:
  if (v34 < *(_DWORD *)(a2 + 68))
  {
    v100 = -v30;
    v107 = v30 - 1;
    v65 = (v47 << 16) / v48;
    v66 = v32 + (int)(((v35 + v33) & -v30) * v106 + 16 * ((v35 + v33) & (v30 - 1)));
    v101 = v65;
    v67 = v65 * v33;
    v106 = 16 * v30;
    v68 = -1;
    while (1)
    {
      v70 = v108;
      v69 = v109;
      v71 = (uint8x16_t *)&v108[v109 * (unint64_t)(HIWORD(v67) & 3)];
      v72 = HIWORD(v67) + 1;
      if ((int)HIWORD(v67) <= v68)
        goto LABEL_27;
      v73 = *(_DWORD *)(a2 + 76);
      v74 = v73 + HIWORD(v67);
      v75 = *(unsigned int *)(a2 + 48);
      v76 = *(_QWORD *)(a2 + 32);
      v77 = *(_QWORD *)(a2 + 40);
      if (v77)
        break;
      v78 = (__int128 *)(v76 + (int)((v74 & v100) * v75 + 16 * (v74 & v107)));
      if (((v73 + v72) & v107) == 0)
      {
        DetileRow_neon(v71, v78, *(_DWORD *)(a2 + 52) << a1, v106);
        goto LABEL_24;
      }
      v80 = v108;
      v79 = v109;
      Detile2Rows_neon(v71, &v108[v109 * (unint64_t)((BYTE2(v67) + 1) & 3)], v78, *(_DWORD *)(a2 + 52) << a1, v106);
      v70 = v80;
      v69 = v79;
      v68 = HIWORD(v67) + 1;
LABEL_27:
      v81 = *(_DWORD *)(a2 + 56);
      if (v81 <= v72)
        v82 = v81 - 1;
      else
        v82 = HIWORD(v67) + 1;
      v83 = (uint8x16_t *)&v70[v69 * (unint64_t)(v82 & 3)];
      if (v82 <= v68)
        goto LABEL_41;
      v84 = *(_DWORD *)(a2 + 76);
      v85 = (v82 + v84);
      v86 = *(unsigned int *)(a2 + 48);
      v87 = *(_QWORD *)(a2 + 32);
      v88 = *(_QWORD *)(a2 + 40);
      if (v88)
      {
        off_1EF1391B8(v83, v87, v85, (*(_DWORD *)(a2 + 52) << a1), v86, v88, a1 != 0);
      }
      else
      {
        v90 = v82 + 1;
        v91 = (__int128 *)(v87 + (int)((v85 & v100) * v86 + 16 * (v85 & v107)));
        if (((v90 + v84) & v107) != 0)
        {
          Detile2Rows_neon(v83, &v108[v109 * (unint64_t)(v90 & 3)], v91, *(_DWORD *)(a2 + 52) << a1, v106);
          v92 = *(_DWORD *)(a2 + 56);
          if (v92 <= v72)
            v93 = v92 - 1;
          else
            v93 = HIWORD(v67) + 1;
          v68 = v93 + 1;
          goto LABEL_41;
        }
        DetileRow_neon(v83, v91, *(_DWORD *)(a2 + 52) << a1, v106);
      }
      v89 = *(_DWORD *)(a2 + 56);
      if (v89 <= v72)
        v68 = v89 - 1;
      else
        v68 = HIWORD(v67) + 1;
LABEL_41:
      v94 = v34 + *(_DWORD *)(a2 + 76);
      if ((v94 & v107) == 0)
        v66 = *(_QWORD *)a2 + *(int *)(a2 + 16) * (uint64_t)(v94 & v100);
      BilinearFilterV_swift_neon(v10, v71, v83, *(_DWORD *)(a2 + 52) << a1, (unsigned __int16)v67 >> 12);
      v95 = *(_DWORD *)(a2 + 52);
      if (a1)
      {
        v96 = 2 * v95;
        v10->i16[2 * v95] = v10->i16[2 * v95 - 2];
        v95 = (2 * v95) | 1;
      }
      else
      {
        v96 = *(_DWORD *)(a2 + 52);
      }
      v98 = v102;
      v97 = v103;
      v67 += v101;
      v10->i16[v95] = v10->i16[v96 - 1];
      v104(v66, v10, *(unsigned int *)(a2 + 20), v105, v97, v98, v106);
      v66 += 16;
      if (++v34 >= *(_DWORD *)(a2 + 68))
        return;
    }
    off_1EF1391B8(&v108[v109 * (unint64_t)(HIWORD(v67) & 3)], v76, v74, (*(_DWORD *)(a2 + 52) << a1), v75, v77, a1 != 0);
LABEL_24:
    v68 = HIWORD(v67);
    v70 = v108;
    v69 = v109;
    goto LABEL_27;
  }
}

void sub_1B67CB0C0(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, int a9, uint64_t a10, uint64_t a11)
{
  char *v13;
  uint64_t v14;
  char v15;
  char v16;
  uint64_t v17;
  signed int v18;
  char v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  char v29;
  char v30;
  char *v31;
  pthread_mutex_t *v38;
  char v39;
  _QWORD v40[2];

  v40[1] = *MEMORY[0x1E0C80C00];
  v13 = (char *)malloc_type_calloc(1uLL, 0x2A0uLL, 0x10700409586CEC2uLL);
  if (v13)
  {
    v14 = 0;
    v15 = 1;
    while (1)
    {
      v16 = v15;
      if (pthread_cond_init((pthread_cond_t *)&v13[336 * v14 + 8], 0)
        || pthread_cond_init((pthread_cond_t *)&v13[336 * v14 + 56], 0)
        || pthread_mutex_init((pthread_mutex_t *)&v13[336 * v14 + 104], 0)
        || pthread_create((pthread_t *)&v13[336 * v14], 0, (void *(__cdecl *)(void *))sub_1B67CA56C, &v13[336 * v14]))
      {
        break;
      }
      v15 = 0;
      v14 = 1;
      if ((v16 & 1) == 0)
      {
        v17 = 0;
        v40[0] = 0;
        v19 = 1;
        do
        {
          v39 = v19;
          v38 = (pthread_mutex_t *)&v13[336 * v17 + 104];
          pthread_mutex_lock(v38);
          v20 = 0;
          *(_DWORD *)&v13[336 * v17 + 172] = 1;
          v21 = 1;
          do
          {
            v22 = (uint64_t)&v13[336 * v17 + 80 * v20];
            *(_QWORD *)(v22 + 176) = *(_QWORD *)(a1 + 8 * v20);
            *(_QWORD *)(v22 + 184) = 0;
            *(_DWORD *)(v22 + 192) = *(_DWORD *)(a2 + 4 * v20);
            *(_DWORD *)(v22 + 196) = a3 >> v20;
            v23 = a4 >> v20;
            *(_DWORD *)(v22 + 200) = a4 >> v20;
            v24 = v21 & 1;
            if ((v21 & 1) != 0)
              v25 = a6;
            else
              v25 = 0;
            *(_QWORD *)(v22 + 208) = *(_QWORD *)(a5 + 8 * v20);
            *(_QWORD *)(v22 + 216) = v25;
            *(_DWORD *)(v22 + 224) = *(_DWORD *)(a7 + 4 * v20);
            *(_DWORD *)(v22 + 228) = a8 >> v20;
            *(_DWORD *)(v22 + 232) = a9 >> v20;
            *(_DWORD *)(v22 + 236) = v20;
            v26 = *((_DWORD *)v40 + v20);
            v18 = (a4 + 63) & 0xFFFFFFC0;
            v27 = v26 + (v18 >> v20 >> 1);
            *((_DWORD *)v40 + v20) = v27;
            if (v27 < v23)
              v23 = v26 + (v18 >> v20 >> 1);
            *(_DWORD *)(v22 + 240) = v26;
            *(_DWORD *)(v22 + 244) = v23;
            *(_DWORD *)(v22 + 248) = *(_DWORD *)(a10 + 4 * v20);
            *(_DWORD *)(v22 + 252) = *(_DWORD *)(a11 + 4 * v20);
            v20 = 1;
            v21 = 0;
          }
          while (v24);
          pthread_cond_signal((pthread_cond_t *)&v13[336 * v17 + 8]);
          pthread_mutex_unlock(v38);
          v19 = 0;
          v17 = 1;
        }
        while ((v39 & 1) != 0);
        v28 = 0;
        v29 = 1;
        do
        {
          v30 = v29;
          v31 = &v13[336 * v28];
          pthread_mutex_lock((pthread_mutex_t *)(v31 + 104));
          if (*((_DWORD *)v31 + 43))
            pthread_cond_wait((pthread_cond_t *)&v13[336 * v28 + 56], (pthread_mutex_t *)(v31 + 104));
          pthread_mutex_unlock((pthread_mutex_t *)(v31 + 104));
          v29 = 0;
          v28 = 1;
        }
        while ((v30 & 1) != 0);
        break;
      }
    }
  }
  sub_1B67CA678(v13);
}

uint64_t sub_1B67CB374(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E6A14EA8;
  return sub_1B682B3E0(a1);
}

void sub_1B67CB384(_QWORD *a1)
{
  *a1 = &off_1E6A14EA8;
  sub_1B682B3E0((uint64_t)a1);
  JUMPOUT(0x1BCC9814CLL);
}

uint64_t sub_1B67CB3B4(uint64_t a1)
{
  return *(_QWORD *)(a1 + 240);
}

__CVPixelBufferPool *sub_1B67CB3BC(uint64_t a1)
{
  __CVPixelBufferPool *result;

  result = *(__CVPixelBufferPool **)(a1 + 240);
  if (result)
    return CVPixelBufferPoolGetPixelBufferAttributes(result);
  return result;
}

uint64_t sub_1B67CB3CC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 154);
}

uint64_t sub_1B67CB3D4()
{
  return 0;
}

uint64_t sub_1B67CB3DC(uint64_t a1, uint64_t a2, CMSampleBufferRef sbuf)
{
  const __CFArray *SampleAttachmentsArray;
  const __CFDictionary *ValueAtIndex;
  const __CFData *Value;
  const __CFData *v8;
  const UInt8 *BytePtr;
  int Length;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  int v16;

  SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(sbuf, 0);
  if (!SampleAttachmentsArray)
    return 4294954394;
  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
  if (!ValueAtIndex)
    return 4294954394;
  Value = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, CFSTR("MBStatistics"));
  if (!Value)
    return 4294954394;
  v8 = Value;
  BytePtr = CFDataGetBytePtr(Value);
  Length = CFDataGetLength(v8);
  result = 4294954394;
  if (BytePtr && Length >= 1)
  {
    v12 = 432 * *(int *)(a1 + 108);
    v13 = Length == v12 ? 0 : 4294954394;
    if (Length == v12)
    {
      if (*(_QWORD *)(a2 + 400) && (v14 = *(_QWORD *)(a2 + 392), *(_QWORD *)(v14 + 8)))
        v15 = *(_QWORD **)v14;
      else
        v15 = 0;
      v16 = 0;
      do
      {
        (*(void (**)(const UInt8 *, _QWORD *))(a1 + 2560))(BytePtr, v15);
        BytePtr += 432;
        ++v16;
      }
      while (v16 < *(_DWORD *)(a1 + 108));
      sub_1B682B5C8(a1, a2, v15);
      return v13;
    }
  }
  return result;
}

uint64_t sub_1B67CB4E0(uint64_t a1, int *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t *v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t result;
  _QWORD v53[2];
  uint64_t v54;
  uint64_t v55;
  _QWORD v56[3];

  v2 = 0;
  v56[2] = *MEMORY[0x1E0C80C00];
  v3 = *(unsigned int *)(a1 + 240);
  v4 = (v3 >> 16) & 0xFFF;
  v5 = (_DWORD)v3 << 19;
  v6 = (int)((_DWORD)v3 << 19) >> 18;
  v7 = (int)((_DWORD)v3 << 19) >> 17;
  v8 = *(_QWORD *)a2;
  v9 = *(_QWORD *)a2 * 4 * v4 + v6;
  v10 = *(_QWORD *)a2 * ((4 * (_DWORD)v4) | 2u) + v6;
  v56[0] = v9;
  v56[1] = v10;
  v11 = 16 * v8 * v4 + v7;
  do
  {
    v53[v2++] = v11;
    v11 += 4 * v8;
  }
  while (v2 != 4);
  v12 = v8 * v4 + (v5 >> 19);
  *(_BYTE *)(*((_QWORD *)a2 + 1) + v12) = *(_BYTE *)(a1 + 80) & 0x3F;
  *(_BYTE *)(*((_QWORD *)a2 + 16) + v12) = *(_BYTE *)(a1 + 83) & 0x3F;
  *(_BYTE *)(*((_QWORD *)a2 + 3) + v12) = (*(_DWORD *)(a1 + 80) & 0x400000) != 0;
  *(_WORD *)(*((_QWORD *)a2 + 4) + 2 * v12) = *(_WORD *)(a1 + 102);
  *(_WORD *)(*((_QWORD *)a2 + 18) + 2 * v12) = *(_WORD *)(a1 + 106);
  *(_BYTE *)(*((_QWORD *)a2 + 13) + v9) = *(_BYTE *)(a1 + 92) & 0xF;
  v13 = v9 | 1;
  *(_BYTE *)(*((_QWORD *)a2 + 13) + v13) = *(_BYTE *)(a1 + 92) >> 4;
  *(_BYTE *)(*((_QWORD *)a2 + 13) + v10) = *(_BYTE *)(a1 + 93) & 0xF;
  v14 = v10 | 1;
  *(_BYTE *)(*((_QWORD *)a2 + 13) + v14) = (unsigned __int16)*(_DWORD *)(a1 + 92) >> 12;
  v15 = v53[0];
  v16 = v53[1];
  *(_BYTE *)(*((_QWORD *)a2 + 14) + v53[0]) = *(_BYTE *)(a1 + 84) & 0xF;
  *(_BYTE *)(v15 + *((_QWORD *)a2 + 14) + 1) = *(_BYTE *)(a1 + 84) >> 4;
  *(_BYTE *)(v15 + *((_QWORD *)a2 + 14) + 2) = *(_BYTE *)(a1 + 85) & 0xF;
  *(_BYTE *)(v15 + *((_QWORD *)a2 + 14) + 3) = (unsigned __int16)*(_DWORD *)(a1 + 84) >> 12;
  *(_BYTE *)(*((_QWORD *)a2 + 14) + v16) = *(_BYTE *)(a1 + 86) & 0xF;
  *(_BYTE *)(v16 + *((_QWORD *)a2 + 14) + 1) = (*(_DWORD *)(a1 + 84) >> 20) & 0xF;
  *(_BYTE *)(v16 + *((_QWORD *)a2 + 14) + 2) = *(_BYTE *)(a1 + 87) & 0xF;
  *(_BYTE *)(v16 + *((_QWORD *)a2 + 14) + 3) = *(_DWORD *)(a1 + 84) >> 28;
  v17 = v54;
  v18 = v55;
  *(_BYTE *)(*((_QWORD *)a2 + 14) + v54) = *(_BYTE *)(a1 + 88) & 0xF;
  *(_BYTE *)(v17 + *((_QWORD *)a2 + 14) + 1) = *(_BYTE *)(a1 + 88) >> 4;
  *(_BYTE *)(v17 + *((_QWORD *)a2 + 14) + 2) = *(_BYTE *)(a1 + 89) & 0xF;
  *(_BYTE *)(v17 + *((_QWORD *)a2 + 14) + 3) = (unsigned __int16)*(_DWORD *)(a1 + 88) >> 12;
  *(_BYTE *)(*((_QWORD *)a2 + 14) + v18) = *(_BYTE *)(a1 + 90) & 0xF;
  *(_BYTE *)(v18 + *((_QWORD *)a2 + 14) + 1) = (*(_DWORD *)(a1 + 88) >> 20) & 0xF;
  *(_BYTE *)(v18 + *((_QWORD *)a2 + 14) + 2) = *(_BYTE *)(a1 + 91) & 0xF;
  *(_BYTE *)(v18 + *((_QWORD *)a2 + 14) + 3) = *(_DWORD *)(a1 + 88) >> 28;
  *(_BYTE *)(*((_QWORD *)a2 + 12) + v12) = *(_BYTE *)(a1 + 94) & 3;
  *(_BYTE *)(*((_QWORD *)a2 + 15) + v12) = (*(_DWORD *)(a1 + 92) >> 20) & 3;
  *(_BYTE *)(*((_QWORD *)a2 + 40) + v9) = *(_BYTE *)(a1 + 96) & 0x1F;
  *(_BYTE *)(*((_QWORD *)a2 + 40) + v13) = (*(_DWORD *)(a1 + 96) >> 5) & 0x1F;
  *(_BYTE *)(*((_QWORD *)a2 + 40) + v10) = (*(_DWORD *)(a1 + 96) >> 10) & 0x1F;
  *(_BYTE *)(*((_QWORD *)a2 + 40) + v14) = (*(_DWORD *)(a1 + 96) >> 15) & 0x1F;
  if (a2[272] >= 1)
  {
    v19 = 0;
    v20 = a1 + 108;
    do
    {
      v21 = 0;
      v22 = 0;
      v23 = (uint64_t *)&a2[2 * v19];
      v24 = v23 + 20;
      v25 = v23 + 22;
      do
      {
        v26 = 0;
        v27 = v53[v21];
        v28 = v22;
        v29 = v20 + 4 * v22;
        v30 = 4 * v27;
        do
        {
          *(_WORD *)(*v24 + v30) = (__int16)(32 * *(_WORD *)(v29 + 4 * v26)) >> 5;
          *(_WORD *)(*v24 + v30 + 2) = (__int16)(*(_DWORD *)(v29 + 4 * v26) >> 6) >> 6;
          *(_BYTE *)(*v25 + v27 + v26) = (32 * *(_DWORD *)(v29 + 4 * v26)) >> 29;
          ++v26;
          v30 += 4;
        }
        while (v26 != 4);
        v22 = v28 + 4;
        ++v21;
      }
      while (v21 != 4);
      ++v19;
      v20 += 64;
    }
    while (v19 < a2[272]);
  }
  v31 = 0;
  v32 = 0;
  v33 = 4 * v12;
  *(_WORD *)(*((_QWORD *)a2 + 24) + v33) = (__int16)(32 * *(_WORD *)a1) >> 5;
  *(_WORD *)(*((_QWORD *)a2 + 24) + 4 * v12 + 2) = (__int16)(*(_DWORD *)a1 >> 6) >> 6;
  *(_WORD *)(*((_QWORD *)a2 + 28) + 2 * v12) = *(_DWORD *)(a1 + 4);
  *(_WORD *)(*((_QWORD *)a2 + 25) + v33) = (__int16)(32 * *(_WORD *)(a1 + 32)) >> 5;
  *(_WORD *)(*((_QWORD *)a2 + 25) + 4 * v12 + 2) = (__int16)(*(_DWORD *)(a1 + 32) >> 6) >> 6;
  *(_WORD *)(*((_QWORD *)a2 + 29) + 2 * v12) = *(_DWORD *)(a1 + 36);
  v34 = 1;
  do
  {
    v35 = 0;
    v36 = 0;
    v37 = v34;
    v38 = v56[v31];
    while (1)
    {
      v39 = a1 + 4 * v32 + 4 * v35;
      v40 = v38 + v36;
      v41 = 4 * v40;
      *(_WORD *)(*((_QWORD *)a2 + 32) + v41) = (__int16)(32 * *(_WORD *)(v39 + 8)) >> 5;
      *(_WORD *)(*((_QWORD *)a2 + 32) + 4 * v40 + 2) = (__int16)(*(_DWORD *)(v39 + 8) >> 6) >> 6;
      *(_WORD *)(*((_QWORD *)a2 + 33) + v41) = (__int16)(32 * *(_WORD *)(v39 + 40)) >> 5;
      *(_WORD *)(*((_QWORD *)a2 + 33) + 4 * v40 + 2) = (__int16)(*(_DWORD *)(v39 + 40) >> 6) >> 6;
      v42 = (uint64_t)(v32 + (int)v35) >> 1;
      v43 = *(_DWORD *)(a1 + 4 * ((v32 + (int)v35) >> 1) + 24);
      if ((_DWORD)v35 == 1)
        break;
      *(_WORD *)(*((_QWORD *)a2 + 36) + 2 * v40) = v43;
      *(_WORD *)(*((_QWORD *)a2 + 37) + 2 * v40) = *(_DWORD *)(a1 + 4 * v42 + 56);
      ++v35;
      v36 = 1;
    }
    v34 = 0;
    *(_WORD *)(*((_QWORD *)a2 + 36) + 2 * v40) = HIWORD(v43);
    *(_WORD *)(*((_QWORD *)a2 + 37) + 2 * v40) = *(_WORD *)(a1 + 4 * v42 + 58);
    v32 += 2;
    v31 = 1;
  }
  while ((v37 & 1) != 0);
  v44 = 0;
  v45 = *((_QWORD *)a2 + 42);
  *(_WORD *)(v45 + 2 * v12) = 0;
  v46 = *((_QWORD *)a2 + 45);
  *(_DWORD *)(v46 + 4 * v12) = 0;
  v47 = *((_QWORD *)a2 + 43);
  *(_WORD *)(v47 + 2 * v12) = 0;
  v48 = *((_QWORD *)a2 + 46);
  *(_DWORD *)(v48 + 4 * v12) = 0;
  v49 = *((_QWORD *)a2 + 44);
  *(_WORD *)(v49 + 2 * v12) = 0;
  v50 = *((_QWORD *)a2 + 47);
  *(_DWORD *)(v50 + 4 * v12) = 0;
  v51 = a1 + 248;
  do
  {
    *(_WORD *)(v45 + 2 * v12) += *(_WORD *)(v51 + v44);
    *(_DWORD *)(v46 + 4 * v12) += *(_DWORD *)(v51 + v44 + 48) & 0x3FFFFFF;
    *(_WORD *)(v47 + 2 * v12) += *(_WORD *)(v51 + v44 + 16);
    *(_DWORD *)(v48 + 4 * v12) += *(_DWORD *)(v51 + v44 + 64) & 0x3FFFFFF;
    *(_WORD *)(v49 + 2 * v12) += *(_WORD *)(v51 + v44 + 32);
    result = *(unsigned int *)(v50 + 4 * v12);
    *(_DWORD *)(v50 + 4 * v12) = result + (*(_DWORD *)(v51 + v44 + 80) & 0x3FFFFFF);
    v44 += 4;
  }
  while (v44 != 16);
  return result;
}

double sub_1B67CBA6C(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  uint64_t v20;
  uint64_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int16x8_t v24;
  uint64_t v25;
  uint64_t v26;
  int16x8_t v27;
  int16x8_t v28;
  uint64_t v29;
  int16x8_t v30;
  uint64_t v31;
  int32x4_t v32;
  int32x4_t v33;
  double result;
  int32x4_t v35;
  int32x4_t v36;
  _QWORD v37[5];

  v2 = 0;
  v37[4] = *MEMORY[0x1E0C80C00];
  v3 = *(unsigned int *)(a1 + 240);
  v4 = (v3 >> 16) & 0xFFF;
  v5 = (_DWORD)v3 << 19;
  v6 = *a2;
  v7 = 16 * *a2 * v4 + ((int)((_DWORD)v3 << 19) >> 17);
  v8 = 4 * *a2;
  do
  {
    v37[v2++] = v7;
    v7 += v8;
  }
  while (v2 != 4);
  v9 = 0;
  v10 = v5 >> 19;
  v11 = v5 >> 18;
  v12 = v6 * v4 + v10;
  v13 = v6 * 4 * v4 + v11;
  *(_BYTE *)(a2[1] + v12) = *(_BYTE *)(a1 + 80) & 0x3F;
  *(_BYTE *)(a2[3] + v12) = (*(_DWORD *)(a1 + 80) & 0x400000) != 0;
  *(_WORD *)(a2[4] + 2 * v12) = *(_WORD *)(a1 + 102);
  v14 = v6 * ((4 * (_DWORD)v4) | 2u) + v11;
  *(_BYTE *)(a2[16] + v12) = *(_BYTE *)(a1 + 83) & 0x3F;
  *(_WORD *)(a2[18] + 2 * v12) = *(_WORD *)(a1 + 106);
  v15 = *(int8x16_t *)(a1 + 84);
  v16.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v16.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  v17 = vandq_s8(v15, v16);
  v18 = (int8x16_t)vshrq_n_u8((uint8x16_t)v15, 4uLL);
  v19 = vzip1q_s8(v17, v18);
  v20 = v37[1];
  *(_DWORD *)(a2[14] + v37[0]) = v19.i32[0];
  *(_DWORD *)(a2[14] + v20) = v19.i32[1];
  v21 = v37[3];
  *(_DWORD *)(a2[14] + v37[2]) = v19.i32[2];
  v22 = vzip2q_s8(v17, v18);
  *(_DWORD *)(a2[14] + v21) = v19.i32[3];
  *(_WORD *)(a2[13] + v13) = v22.i16[0];
  *(_WORD *)(a2[13] + v14) = v22.i16[1];
  v17.i64[0] = 0x303030303030303;
  v17.i64[1] = 0x303030303030303;
  v23 = vandq_s8(v22, v17);
  *(_BYTE *)(a2[12] + v12) = v23.i8[4];
  *(_BYTE *)(a2[15] + v12) = v23.i8[5];
  *(_BYTE *)(a2[40] + v13) = *(_BYTE *)(a1 + 96) & 0x1F;
  *(_BYTE *)(a2[40] + (v13 | 1)) = (*(_DWORD *)(a1 + 96) >> 5) & 0x1F;
  *(_BYTE *)(a2[40] + v14) = (*(_DWORD *)(a1 + 96) >> 10) & 0x1F;
  *(_BYTE *)(a2[40] + (v14 | 1)) = (*(_DWORD *)(a1 + 96) >> 15) & 0x1F;
  do
  {
    v24 = *(int16x8_t *)(a1 + 16 * v9 + 108);
    v25 = v37[v9];
    *(int16x8_t *)(a2[20] + 4 * v25) = vtrn1q_s16(vshrq_n_s16(vshlq_n_s16(v24, 5uLL), 5uLL), (int16x8_t)vshrq_n_s32(vshlq_n_s32((int32x4_t)v24, 0xAuLL), 0x16uLL));
    *(_DWORD *)(a2[22] + v25) = vqtbl1q_s8(vshrq_n_s8(vshlq_n_s8((int8x16_t)v24, 5uLL), 5uLL), (int8x16_t)xmmword_1B69175A0).u32[0];
    ++v9;
  }
  while (v9 != 4);
  v26 = 4 * v12;
  *(_WORD *)(a2[24] + v26) = (__int16)(32 * *(_WORD *)a1) >> 5;
  *(_WORD *)(a2[24] + 4 * v12 + 2) = (__int16)(*(_DWORD *)a1 >> 6) >> 6;
  *(_WORD *)(a2[28] + 2 * v12) = *(_DWORD *)(a1 + 4);
  *(_WORD *)(a2[25] + v26) = (__int16)(32 * *(_WORD *)(a1 + 32)) >> 5;
  *(_WORD *)(a2[25] + 4 * v12 + 2) = (__int16)(*(_DWORD *)(a1 + 32) >> 6) >> 6;
  *(_WORD *)(a2[29] + 2 * v12) = *(_DWORD *)(a1 + 36);
  v27 = vtrn1q_s16(vshrq_n_s16(vshlq_n_s16(*(int16x8_t *)(a1 + 8), 5uLL), 5uLL), (int16x8_t)vshrq_n_s32(vshlq_n_s32(*(int32x4_t *)(a1 + 8), 0xAuLL), 0x16uLL));
  v28 = *(int16x8_t *)(a1 + 40);
  v29 = 4 * v13;
  *(_QWORD *)(a2[32] + v29) = v27.i64[0];
  v30 = vtrn1q_s16(vshrq_n_s16(vshlq_n_s16(v28, 5uLL), 5uLL), (int16x8_t)vshrq_n_s32(vshlq_n_s32((int32x4_t)v28, 0xAuLL), 0x16uLL));
  *(_QWORD *)(a2[32] + 4 * v14) = v27.i64[1];
  *(_QWORD *)(a2[33] + v29) = v30.i64[0];
  *(_QWORD *)(a2[33] + 4 * v14) = v30.i64[1];
  v27.i64[0] = *(_QWORD *)(a1 + 24);
  v30.i64[0] = *(_QWORD *)(a1 + 56);
  v31 = 2 * v13;
  *(_DWORD *)(a2[36] + v31) = v27.i32[0];
  *(_DWORD *)(a2[36] + 2 * v14) = v27.i32[1];
  *(_DWORD *)(a2[37] + v31) = v30.i32[0];
  *(_DWORD *)(a2[37] + 2 * v14) = v30.i32[1];
  v32 = vpaddq_s32((int32x4_t)vpaddlq_u16((uint16x8_t)vuzp1q_s16(*(int16x8_t *)(a1 + 248), *(int16x8_t *)(a1 + 264))), vpaddlq_s16(vuzp1q_s16(*(int16x8_t *)(a1 + 280), vuzp2q_s16(*(int16x8_t *)(a1 + 248), *(int16x8_t *)(a1 + 264)))));
  *(_WORD *)(a2[42] + 2 * v12) = v32.i16[0];
  *(_WORD *)(a2[43] + 2 * v12) = v32.i16[2];
  *(_WORD *)(a2[44] + 2 * v12) = v32.i16[4];
  v33 = vpaddq_s32(*(int32x4_t *)(a1 + 296), *(int32x4_t *)(a1 + 296));
  *(_QWORD *)&result = vpaddq_s32(v33, v33).u64[0];
  v35 = vpaddq_s32(*(int32x4_t *)(a1 + 312), *(int32x4_t *)(a1 + 312));
  v36 = vpaddq_s32(*(int32x4_t *)(a1 + 328), *(int32x4_t *)(a1 + 328));
  *(_DWORD *)(a2[45] + 4 * v12) = LODWORD(result);
  *(_DWORD *)(a2[46] + 4 * v12) = vpaddq_s32(v35, v35).u32[0];
  *(_DWORD *)(a2[47] + 4 * v12) = vpaddq_s32(v36, v36).u32[0];
  return result;
}

uint64_t sub_1B67CBDF8(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int32x4_t v5;
  int32x4_t v6;
  int32x4_t v7;
  int32x2_t v8;

  v4 = sub_1B682B2F4(a1, a2);
  *(_QWORD *)v4 = &off_1E6A14EA8;
  *(_DWORD *)(v4 + 148) = 1;
  if (*(_DWORD *)(a2 + 508) == 2)
    *(_DWORD *)(a1 + 148) = *(_DWORD *)(a2 + 504);
  v5.i64[0] = *(_QWORD *)(a1 + 72);
  v6 = vzip1q_s32(v5, v5);
  v6.i32[2] = v5.i32[0];
  v7 = vshlq_s32(vaddq_s32(v6, (int32x4_t)xmmword_1B69175B0), (int32x4_t)xmmword_1B69175C0);
  v8 = vshl_s32(vadd_s32(vdup_lane_s32(*(int32x2_t *)v5.i8, 1), (int32x2_t)0x1F0000000FLL), (int32x2_t)0xFFFFFFFBFFFFFFFCLL);
  *(int32x2_t *)(a1 + 140) = v8;
  v8.i32[0] = v7.i32[2];
  *(int32x2_t *)(a1 + 112) = v8;
  *(int32x4_t *)(a1 + 124) = v7;
  *(_DWORD *)(a1 + 120) = v8.i32[1] * v7.i32[2];
  if (*(_BYTE *)(*(_QWORD *)(a1 + 88) + 581))
  {
    *(_QWORD *)(a1 + 2560) = sub_1B67CB4E0;
    if (qword_1EDBB4CB8 != -1)
      dispatch_once_f(&qword_1EDBB4CB8, 0, (dispatch_function_t)sub_1B67ED9E8);
    if (dword_1EDBB4CB0 >= 2)
      *(_QWORD *)(a1 + 2560) = sub_1B67CBA6C;
  }
  return a1;
}

uint64_t sub_1B67CBF08(uint64_t a1, uint64_t a2)
{
  unint64_t i;
  unint64_t v5;
  unsigned __int8 *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  uint64_t result;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  const void *v15;
  unsigned __int8 *v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  unsigned __int8 *v24;

  for (i = 0; i != 4; ++i)
  {
    v5 = 0;
    if (i)
      v6 = byte_1B692C014;
    else
      v6 = (unsigned __int8 *)&unk_1B692C004;
    if (i)
      v7 = 64;
    else
      v7 = 16;
    if (i == 3)
      v8 = 3;
    else
      v8 = 1;
    v24 = v6;
    v23 = *v6 + 1;
    do
    {
      if (sub_1B67C9094(a2, 1))
      {
        if (i <= 1)
        {
          v10 = 8;
        }
        else
        {
          v9 = sub_1B67C9140(a2);
          v10 = (-((v9 + 1) & 1) ^ ((v9 + 1) >> 1)) + ((v9 + 1) & 1) + 8;
          *(_BYTE *)(a1 + 390 * i + 65 * v5) = (-((v9 + 1) & 1) ^ ((v9 + 1) >> 1)) + ((v9 + 1) & 1) + 8;
        }
        v16 = v24;
        v17 = v7;
        do
        {
          result = sub_1B67C9140(a2);
          v18 = (result + 1) & 1;
          v19 = v10 + v18 + (-v18 ^ ((result + 1) >> 1)) + 256;
          v20 = (v10 + v18 + (-(char)v18 ^ ((result + 1) >> 1)));
          v21 = -v19;
          if (v21 >= 0)
            v10 = -v21;
          else
            v10 = v20;
          v22 = *v16++;
          *(_BYTE *)(v22 + 65 * v5 + a1 + 390 * i + 1) = v10;
          --v17;
        }
        while (v17);
        if (i < 2)
          *(_BYTE *)(a1 + 390 * i + 65 * v5) = *(_BYTE *)(a1 + 390 * i + 65 * v5 + v23);
      }
      else
      {
        result = sub_1B67C9140(a2);
        v12 = (result * v8);
        if (v5 < v12)
          return result;
        v13 = (char *)&unk_1B6920659 + ((v5 > 2) | ((unint64_t)(v5 > 2) << 6));
        if (!i)
          v13 = (char *)&unk_1B6920648;
        v14 = a1 + 390 * i + 65 * ((int)v5 - (int)v12);
        if ((_DWORD)result)
          v15 = (const void *)v14;
        else
          v15 = v13;
        result = (uint64_t)memcpy((void *)(a1 + 390 * i + 65 * v5), v15, v7 | 1);
      }
      v5 += v8;
    }
    while (v5 < 6);
  }
  return result;
}

uint64_t sub_1B67CC0F0(uint64_t result, uint64_t a2, unsigned int a3, int a4)
{
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  uint64_t v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  char v12;
  BOOL v13;
  BOOL v14;
  char v15;

  v4 = *(_QWORD *)(a2 + 24);
  v5 = *(_QWORD *)(a2 + 32);
  if (*(_DWORD *)(a2 + 44))
    v6 = v4 >= v5;
  else
    v6 = 1;
  if (!v6)
    *(_QWORD *)(a2 + 24) = ++v4;
  v7 = 0;
  *(_QWORD *)(a2 + 40) = 0;
  *(_OWORD *)result = xmmword_1B69175D0;
  *(_QWORD *)(result + 200) = a2;
  *(_QWORD *)(result + 208) = v4;
  *(_QWORD *)(result + 16) = -1;
  *(_QWORD *)(result + 24) = v4;
  *(_QWORD *)(result + 32) = v5;
  if (a4 >= 51)
    v8 = 51;
  else
    v8 = a4;
  v9 = v8 & ~(v8 >> 31);
  do
  {
    v10 = byte_1B6920428[157 * a3 + v7];
    v11 = 8 * (v10 & 0xF) + ((int)((5 * (v10 >> 4) - 45) * v9) >> 4) - 16;
    if (v11 >= 126)
      v11 = 126;
    if (v11 <= 1)
      v11 = 1;
    v12 = 63 - v11;
    v13 = v11 > 0x3F;
    v14 = v11 > 0x3F;
    v15 = v11 + 64;
    if (!v13)
      v15 = v12;
    *(_BYTE *)(result + 40 + v7++) = v14 | (2 * v15);
  }
  while (v7 != 157);
  return result;
}

_QWORD *sub_1B67CC1BC(_QWORD *result)
{
  unint64_t v1;
  uint64_t v2;
  _DWORD *v3;
  uint64_t v4;
  _BYTE *v5;
  __int16 v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  unint64_t v11;
  char *v12;

  v1 = *result >> 8;
  v2 = result[2];
  v3 = (_DWORD *)result[3];
  v4 = v2 + 2;
  if (((v1 >> (v2 + 2)) & 1) != 0)
  {
    v1 &= ~(-1 << v4);
    v5 = (char *)v3 - 1;
    do
    {
      if ((unint64_t)v5 < result[26])
        break;
      v6 = (*v5--)++ + 1;
    }
    while ((v6 & 0x100) != 0);
  }
  v7 = v2 < 30;
  v8 = v2 - 30;
  if (!v7)
  {
    *v3++ = bswap32(v1 >> v8);
    LODWORD(v1) = v1 & ~(-1 << v8);
    v4 = v8;
  }
  v9 = result[25];
  v10 = (char *)v3 + (*(int *)(v9 + 44) >> 3) - result[26];
  v11 = *(_QWORD *)(v9 + 32);
  v12 = &v10[*(_QWORD *)(v9 + 24)];
  *(_QWORD *)(v9 + 24) = v12;
  if ((unint64_t)v12 >= v11)
  {
    *(_BYTE *)(v9 + 48) = 1;
    *(_QWORD *)(v9 + 24) = v11;
  }
  *(_DWORD *)(v9 + 40) = 0;
  if (v4)
    return (_QWORD *)sub_1B67C9044(v9, v1, v4);
  return result;
}

unint64_t *sub_1B67CC270(unint64_t *result, int a2, _BYTE *a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  unint64_t v16;
  char v17;
  unint64_t v18;
  unsigned int *v19;
  unsigned int v20;

  v3 = *a3;
  v4 = byte_1B6920D90[(result[1] & 0xC0) + (v3 >> 1)];
  v5 = result[2];
  v6 = result[1] - v4;
  v7 = v3 & 1 ^ a2;
  if (v7)
    v8 = result[1] - v4;
  else
    v8 = 0;
  v9 = v8 + *result;
  if (v7)
    v6 = byte_1B6920D90[(result[1] & 0xC0) + (v3 >> 1)];
  *a3 = byte_1B6920D90[(v7 | (2 * v3)) + 256];
  v10 = __clz(v6) - 55;
  v11 = v6 << v10;
  v12 = v9 << v10;
  v13 = v5 + v10;
  result[1] = v11;
  v14 = v13 - 32;
  if (v13 >= 32)
  {
    v15 = (_DWORD *)result[3];
    if ((unint64_t)v15 < result[4])
    {
      v16 = result[26];
      v17 = v13 - 22;
      v18 = v12 >> v17;
      result[3] = (unint64_t)(v15 + 1);
      *v15 = bswap32(v12 >> v17);
      v12 &= ~(-1 << v17);
      if ((v18 & 0x100000000) != 0)
      {
        v19 = v15 - 1;
        do
        {
          if ((unint64_t)v19 < v16)
            break;
          v20 = *v19;
          *v19 = bswap32(bswap32(*v19) + 1);
          --v19;
        }
        while (v20 == -1);
      }
      v13 = v14;
    }
  }
  *result = v12;
  result[2] = v13;
  return result;
}

unint64_t *sub_1B67CC34C(unint64_t *result, int a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  unint64_t v7;
  char v8;
  unint64_t v9;
  unsigned int *v10;
  unsigned int v11;

  v2 = 2 * *result;
  if (a2)
    v2 += result[1];
  v3 = result[2];
  v4 = v3 + 1;
  v5 = v3 - 31;
  if (v3 >= 31)
  {
    v6 = (_DWORD *)result[3];
    if ((unint64_t)v6 < result[4])
    {
      v7 = result[26];
      v8 = v3 - 21;
      v9 = v2 >> v8;
      result[3] = (unint64_t)(v6 + 1);
      *v6 = bswap32(v2 >> v8);
      v2 &= ~(-1 << v8);
      if ((v9 & 0x100000000) != 0)
      {
        v10 = v6 - 1;
        do
        {
          if ((unint64_t)v10 < v7)
            break;
          v11 = *v10;
          *v10 = bswap32(bswap32(*v10) + 1);
          --v10;
        }
        while (v11 == -1);
      }
      v4 = v5;
    }
  }
  *result = v2;
  result[2] = v4;
  return result;
}

unint64_t *sub_1B67CC3E0(unint64_t *result, int a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  unint64_t v11;
  char v12;
  unint64_t v13;
  unsigned int *v14;
  unsigned int v15;

  v2 = result[1] - 2;
  v3 = 1 - ((int)v2 >> 8);
  v4 = 2;
  if (!a2)
  {
    v4 = result[1] - 2;
    v2 = 0;
  }
  v5 = v2 + *result;
  if (a2)
    v6 = 7;
  else
    v6 = v3;
  v7 = v5 << v6;
  v8 = result[2] + v6;
  result[1] = v4 << v6;
  v9 = v8 - 32;
  if (v8 >= 32)
  {
    v10 = (_DWORD *)result[3];
    if ((unint64_t)v10 < result[4])
    {
      v11 = result[26];
      v12 = v8 - 22;
      v13 = v7 >> v12;
      result[3] = (unint64_t)(v10 + 1);
      *v10 = bswap32(v7 >> v12);
      v7 &= ~(-1 << v12);
      if ((v13 & 0x100000000) != 0)
      {
        v14 = v10 - 1;
        do
        {
          if ((unint64_t)v14 < v11)
            break;
          v15 = *v14;
          *v14 = bswap32(bswap32(*v14) + 1);
          --v14;
        }
        while (v15 == -1);
      }
      v8 = v9;
    }
  }
  *result = v7;
  result[2] = v8;
  return result;
}

unint64_t *sub_1B67CC498(unint64_t *result, int a2, int a3)
{
  unint64_t v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  unint64_t v10;
  char v11;
  unint64_t v12;
  unsigned int *v13;
  unsigned int v14;

  if (a3)
  {
    v3 = *result;
    v4 = result[2] + a3;
    if (a3 >= 1)
    {
      v5 = a2 << -(char)a3;
      v6 = a3 + 1;
      do
      {
        if (v5 >= 0)
          v7 = 0;
        else
          v7 = result[1];
        v3 = v7 + 2 * v3;
        v5 *= 2;
        --v6;
      }
      while (v6 > 1);
    }
    v8 = v4 - 32;
    if (v4 >= 32)
    {
      v9 = (_DWORD *)result[3];
      if ((unint64_t)v9 < result[4])
      {
        v10 = result[26];
        v11 = v4 - 22;
        v12 = v3 >> v11;
        result[3] = (unint64_t)(v9 + 1);
        *v9 = bswap32(v3 >> v11);
        v3 &= ~(-1 << v11);
        if ((v12 & 0x100000000) != 0)
        {
          v13 = v9 - 1;
          do
          {
            if ((unint64_t)v13 < v10)
              break;
            v14 = *v13;
            *v13 = bswap32(bswap32(*v13) + 1);
            --v13;
          }
          while (v14 == -1);
        }
        v4 = v8;
      }
    }
    *result = v3;
    result[2] = v4;
  }
  return result;
}

unint64_t *sub_1B67CC554(unint64_t *a1, int a2, int a3)
{
  unint64_t *result;

  do
  {
    result = sub_1B67CC34C(a1, 1);
    --a2;
  }
  while (a2);
  if (a3)
    return sub_1B67CC34C(a1, 0);
  return result;
}

unint64_t *sub_1B67CC5B0(unint64_t *a1, unsigned int a2, int a3)
{
  int v4;
  int i;
  int v6;
  int v7;
  unsigned int v8;
  unint64_t *result;
  unsigned int v10;

  v4 = 1 << a3;
  for (i = a3; a2 >= 1 << i; v4 = 1 << i)
  {
    ++i;
    a2 -= v4;
  }
  v6 = 2 * i - a3;
  v7 = -2 << i;
  v8 = a2 | v7;
  if (v6 + 1 < 23)
    return sub_1B67CC498(a1, a2 | v7, v6 + 1);
  do
  {
    result = sub_1B67CC34C(a1, (v8 >> v6) & 1);
    v10 = v6-- + 1;
  }
  while (v10 > 1);
  return result;
}

void sub_1B67CC654(_QWORD *a1)
{
  uint64_t v2;

  v2 = 0x1FFFFFFFFFFFFFE0;
  do
  {
    sub_1B67C7674(&a1[v2 + 35]);
    sub_1B67C7674(&a1[v2 + 67]);
    sub_1B67C7674(&a1[v2 + 99]);
    sub_1B67C7674(&a1[v2 + 131]);
    sub_1B67C7674(&a1[v2 + 163]);
    v2 += 2;
  }
  while (v2 * 8);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t sub_1B67CC6B8(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, char a6)
{
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  uint64_t *v17;
  unsigned __int8 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  _QWORD *v23;
  char v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  __int128 v28;
  std::__shared_weak_count *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  _DWORD *v40;
  uint64_t *v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  _QWORD *v46;
  BOOL v47;
  int v48;
  unint64_t *v49;
  unint64_t v50;
  int v51;
  _DWORD *v52;
  uint64_t v53;
  int v54;
  NSObject *v55;
  int v56;
  uint64_t v57;
  uint64_t *v58;
  uint64_t v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  char v63;
  uint64_t v64;
  _BYTE *v65;
  int v66;
  __int128 v67;
  unint64_t *v68;
  unint64_t v69;
  std::__shared_weak_count *v70;
  unint64_t *v71;
  unint64_t v72;
  std::__shared_weak_count *v73;
  unint64_t *v74;
  unint64_t v75;
  int v77;
  unsigned int v78;
  uint64_t v80;
  __int128 v83;
  uint8_t buf[16];
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v80 = (*(_DWORD *)(a4 + 4) + *(_DWORD *)a4);
    if ((int)v80 >= 1)
    {
      v9 = 0;
      v10 = 0;
      v11 = 0;
      v77 = (-1 << a6) & a5;
      v78 = 0;
      v12 = ~(-1 << a6);
      while (1)
      {
        v13 = *(unsigned __int16 *)(a4 + 2 * v9 + 24);
        v83 = 0uLL;
        v14 = 1 << v9;
        if (((1 << v9) & *(unsigned __int16 *)(a4 + 218)) != 0)
        {
          v15 = *(_DWORD *)(a4 + 4 * v9 + 152) << a6;
          v16 = v77 + v13;
          v13 = (v77 + v13 - v15);
          v17 = (uint64_t *)sub_1B67CCE18(a2, v16 - v15);
        }
        else
        {
          v18 = atomic_load((unsigned __int8 *)&qword_1EF138F80);
          if ((v18 & 1) == 0 && __cxa_guard_acquire(&qword_1EF138F80))
          {
            __cxa_atexit((void (*)(void *))sub_1B67CD160, &qword_1EF138F70, &dword_1B676B000);
            __cxa_guard_release(&qword_1EF138F80);
          }
          v19 = 16;
          while (1)
          {
            v20 = *(_QWORD *)(a2 + v19);
            if (v20)
            {
              if ((*(_DWORD *)(v20 + 680) & v12) == (_DWORD)v13)
                break;
            }
            v19 += 16;
            if (v19 == 288)
            {
              v17 = &qword_1EF138F70;
              goto LABEL_13;
            }
          }
          v17 = (uint64_t *)(a2 + v19);
        }
LABEL_13:
        sub_1B67B665C(&v83, *v17, v17[1]);
        v21 = v83;
        v22 = *(unsigned __int16 *)(a4 + 216);
        if ((_QWORD)v83)
          break;
        if ((v14 & v22) == 0)
          goto LABEL_21;
        sub_1B67CCED4(buf, a2, v13);
        v28 = *(_OWORD *)buf;
        memset(buf, 0, sizeof(buf));
        v29 = (std::__shared_weak_count *)*((_QWORD *)&v83 + 1);
        v83 = v28;
        if (v29)
        {
          p_shared_owners = (unint64_t *)&v29->__shared_owners_;
          do
            v31 = __ldaxr(p_shared_owners);
          while (__stlxr(v31 - 1, p_shared_owners));
          if (!v31)
          {
            ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
            std::__shared_weak_count::__release_weak(v29);
          }
        }
        v32 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v33 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v34 = __ldaxr(v33);
          while (__stlxr(v34 - 1, v33));
          if (!v34)
          {
            ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
            std::__shared_weak_count::__release_weak(v32);
          }
        }
        v21 = v83;
        v22 = *(unsigned __int16 *)(a4 + 216);
        if ((_QWORD)v83)
          break;
        if ((v14 & v22) == 0)
          goto LABEL_21;
        sub_1B68903EC((unsigned int *)a4);
        if (dword_1EF137CD0 >= 1)
        {
          fprintf((FILE *)*MEMORY[0x1E0C80C10], "Unavailable long-term reference - POC %d!\n", v13);
          v35 = MEMORY[0x1E0C81028];
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&buf[4] = v13;
            _os_log_impl(&dword_1B676B000, v35, OS_LOG_TYPE_DEFAULT, "Unavailable long-term reference - POC %d!\n", buf, 8u);
          }
        }
        v24 = 0;
        v78 = -12909;
LABEL_22:
        v25 = (std::__shared_weak_count *)*((_QWORD *)&v83 + 1);
        if (*((_QWORD *)&v83 + 1))
        {
          v26 = (unint64_t *)(*((_QWORD *)&v83 + 1) + 8);
          do
            v27 = __ldaxr(v26);
          while (__stlxr(v27 - 1, v26));
          if (!v27)
          {
            ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
            std::__shared_weak_count::__release_weak(v25);
          }
        }
        if ((v24 & 1) == 0)
          return v78;
        if (++v9 == v80)
          goto LABEL_51;
      }
      if ((v14 & v22) != 0)
        v23 = &a1[4 * v11 + 134];
      else
        v23 = &a1[4 * v10 + 262];
      if ((v14 & v22) != 0)
        ++v11;
      else
        ++v10;
      sub_1B67B665C(v23, v21, *((uint64_t *)&v83 + 1));
      *(_DWORD *)(v83 + 36) |= 2u;
LABEL_21:
      v24 = 1;
      goto LABEL_22;
    }
    v78 = 0;
    v11 = 0;
    v10 = 0;
LABEL_51:
    a1[3] = v11;
    a1[5] = v10;
  }
  else
  {
    v11 = 0;
    v78 = 0;
    a1[5] = 0;
    a1[3] = 0;
  }
  v36 = a3;
  if (a3)
  {
    if (*(_BYTE *)(a3 + 160))
    {
      v37 = 0;
      v38 = 0;
      v39 = 0;
      v40 = a1;
      while (1)
      {
        v41 = (uint64_t *)sub_1B67CCE18(a2, *(__int16 *)(a3 + 4 * v37) + a5);
        v42 = *v41;
        v43 = (std::__shared_weak_count *)v41[1];
        if (v43)
        {
          v44 = (unint64_t *)&v43->__shared_owners_;
          do
            v45 = __ldxr(v44);
          while (__stxr(v45 + 1, v44));
        }
        if (v42)
        {
          if (*(_DWORD *)(v42 + 36) == 1)
          {
            if (*(_BYTE *)(a3 + 4 * v37 + 2))
              v46 = &a1[4 * v39 + 6];
            else
              v46 = &a1[4 * v38 + 198];
            v39 += *(unsigned __int8 *)(a3 + 4 * v37 + 2);
            if (!*(_BYTE *)(a3 + 4 * v37 + 2))
              ++v38;
            sub_1B67B665C(v46, v42, (uint64_t)v43);
          }
          v47 = 1;
          if (!v43)
            goto LABEL_75;
        }
        else
        {
          v47 = *(_BYTE *)(a3 + 4 * v37 + 2) == 0;
          v48 = v78;
          if (*(_BYTE *)(a3 + 4 * v37 + 2))
            v48 = -17694;
          v78 = v48;
          if (!v43)
            goto LABEL_75;
        }
        v49 = (unint64_t *)&v43->__shared_owners_;
        do
          v50 = __ldaxr(v49);
        while (__stlxr(v50 - 1, v49));
        if (!v50)
        {
          ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
          std::__shared_weak_count::__release_weak(v43);
        }
LABEL_75:
        if (!v47)
          return v78;
        if (++v37 >= (unint64_t)*(unsigned __int8 *)(a3 + 160))
          goto LABEL_80;
      }
    }
    v39 = 0;
    v38 = 0;
    v40 = a1;
LABEL_80:
    v40[1] = v39;
    if (*(_BYTE *)(a3 + 161))
    {
      v53 = 0;
      v54 = 0;
      v55 = MEMORY[0x1E0C81028];
      while (1)
      {
        v56 = *(__int16 *)(v36 + 4 * v53 + 64);
        v57 = (v56 + a5);
        v58 = (uint64_t *)sub_1B67CCE18(a2, v56 + a5);
        v59 = *v58;
        v60 = (std::__shared_weak_count *)v58[1];
        *(_QWORD *)&v83 = *v58;
        *((_QWORD *)&v83 + 1) = v60;
        if (v60)
        {
          v61 = (unint64_t *)&v60->__shared_owners_;
          do
            v62 = __ldxr(v61);
          while (__stxr(v62 + 1, v61));
        }
        if (v59)
          break;
        v64 = a3 + 4 * v53;
        v66 = *(unsigned __int8 *)(v64 + 66);
        v65 = (_BYTE *)(v64 + 66);
        if (v66)
        {
          sub_1B67CCED4(buf, a2, v57);
          v67 = *(_OWORD *)buf;
          memset(buf, 0, sizeof(buf));
          v83 = v67;
          if (v60)
          {
            v68 = (unint64_t *)&v60->__shared_owners_;
            do
              v69 = __ldaxr(v68);
            while (__stlxr(v69 - 1, v68));
            if (!v69)
            {
              ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
              std::__shared_weak_count::__release_weak(v60);
            }
          }
          v70 = *(std::__shared_weak_count **)&buf[8];
          if (*(_QWORD *)&buf[8])
          {
            v71 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
            do
              v72 = __ldaxr(v71);
            while (__stlxr(v72 - 1, v71));
            if (!v72)
            {
              ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
              std::__shared_weak_count::__release_weak(v70);
            }
          }
          v59 = v83;
          if ((_QWORD)v83)
            break;
          if (*v65)
          {
            sub_1B688FD74((__int16 *)a3);
            if (dword_1EF137CD0 >= 1)
            {
              fprintf((FILE *)*MEMORY[0x1E0C80C10], "Unavailable short-term reference - POC %d!\n", v57);
              if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 67109120;
                *(_DWORD *)&buf[4] = v57;
                _os_log_impl(&dword_1B676B000, v55, OS_LOG_TYPE_DEFAULT, "Unavailable short-term reference - POC %d!\n", buf, 8u);
              }
            }
            v63 = 0;
            v78 = -12909;
            goto LABEL_107;
          }
        }
LABEL_106:
        v63 = 1;
LABEL_107:
        v36 = a3;
LABEL_108:
        v73 = (std::__shared_weak_count *)*((_QWORD *)&v83 + 1);
        if (*((_QWORD *)&v83 + 1))
        {
          v74 = (unint64_t *)(*((_QWORD *)&v83 + 1) + 8);
          do
            v75 = __ldaxr(v74);
          while (__stlxr(v75 - 1, v74));
          if (!v75)
          {
            ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
            std::__shared_weak_count::__release_weak(v73);
          }
        }
        if ((v63 & 1) == 0)
          return v78;
        if (++v53 >= (unint64_t)*(unsigned __int8 *)(v36 + 161))
        {
          v40 = a1;
          v39 = a1[1];
          goto LABEL_118;
        }
      }
      if (*(_DWORD *)(v59 + 36) == 1)
      {
        v36 = a3;
        if (*(_BYTE *)(a3 + 4 * v53 + 66))
        {
          sub_1B67B665C(&a1[4 * v54 + 70], v59, *((uint64_t *)&v83 + 1));
          v63 = 1;
          ++v54;
        }
        else
        {
          sub_1B67B665C(&a1[4 * v38 + 198], v59, *((uint64_t *)&v83 + 1));
          v63 = 1;
          ++v38;
        }
        goto LABEL_108;
      }
      goto LABEL_106;
    }
    v54 = 0;
LABEL_118:
    v40[2] = v54;
    v40[4] = v38;
    v51 = v54 + v39;
    v52 = v40;
    v11 = v40[3];
  }
  else
  {
    v51 = 0;
    v52 = a1;
    a1[4] = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  *v52 = v51 + v11;
  return v78;
}

void sub_1B67CCE00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  sub_1B6772C88((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_1B67CCE18(uint64_t a1, int a2)
{
  unsigned __int8 v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  int v7;
  int v8;
  int v9;
  uint64_t v10;

  v2 = atomic_load((unsigned __int8 *)&qword_1EF138F68);
  if ((v2 & 1) == 0)
  {
    v10 = a1;
    v9 = a2;
    v7 = __cxa_guard_acquire(&qword_1EF138F68);
    a2 = v9;
    v8 = v7;
    a1 = v10;
    if (v8)
    {
      __cxa_atexit((void (*)(void *))sub_1B67CD160, &unk_1EF138F58, &dword_1B676B000);
      __cxa_guard_release(&qword_1EF138F68);
      a2 = v9;
      a1 = v10;
    }
  }
  v3 = 16;
  v4 = &unk_1EF138F58;
  while (1)
  {
    v5 = *(_QWORD *)(a1 + v3);
    if (v5)
    {
      if (*(_DWORD *)(v5 + 680) == a2)
        break;
    }
    v3 += 16;
    if (v3 == 288)
      return v4;
  }
  return (void *)(a1 + v3);
}

double sub_1B67CCED4(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  double result;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  void *v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  void *v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  std::mutex *v30;
  char v31;

  v29 = 0uLL;
  if (*(_QWORD *)a2)
  {
    if ((*(unsigned int (**)(_QWORD, uint64_t, __int128 *))a2)(*(_QWORD *)(a2 + 8), a3, &v29))
    {
      *a1 = 0;
      a1[1] = 0;
      v5 = (std::__shared_weak_count *)*((_QWORD *)&v29 + 1);
      if (*((_QWORD *)&v29 + 1))
      {
        v6 = (unint64_t *)(*((_QWORD *)&v29 + 1) + 8);
        do
          v7 = __ldaxr(v6);
        while (__stlxr(v7 - 1, v6));
        if (!v7)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
    }
    else
    {
      v8 = v29;
      v9 = *(unsigned __int8 *)(v29 + 284);
      if (v9 == 8)
      {
        v10 = (void *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)v29 + 32))(v29, 0);
        memset(v10, 128, *(_QWORD *)(v8 + 112) * *(int *)(v8 + 280));
      }
      else
      {
        v11 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)v29 + 32))(v29, 0);
        v12 = *(_DWORD *)(v8 + 280);
        if (v12 >= 1)
        {
          v13 = 0;
          v14 = 1 << (v9 - 1);
          v15 = *(_QWORD *)(v8 + 112);
          v16 = 2 * v15;
          v17 = *(unsigned int *)(v8 + 276);
          v18 = 4 * v15;
          do
          {
            if ((int)v17 >= 1)
            {
              v19 = 0;
              do
              {
                *(_WORD *)(v11 + v16 + v19) = v14;
                *(_WORD *)(v11 + v19) = v14;
                v19 += 2;
              }
              while (2 * v17 != v19);
            }
            v13 += 2;
            v11 += v18;
          }
          while (v13 < v12);
        }
      }
      if (*(unsigned __int8 *)(v8 + 285) >= 2u)
      {
        v20 = *(unsigned __int8 *)(v8 + 284);
        if (v20 == 8)
        {
          v21 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 32))(v8, 1);
          memset(v21, 128, *(_QWORD *)(v8 + 120) * *(int *)(v8 + 280) / 2);
        }
        else
        {
          v22 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 32))(v8, 1);
          v23 = *(_DWORD *)(v8 + 280);
          if (v23 >= 1)
          {
            v24 = 0;
            v25 = *(unsigned int *)(v8 + 276);
            v26 = 2 * *(_QWORD *)(v8 + 120);
            do
            {
              if ((int)v25 >= 1)
              {
                v27 = 0;
                do
                {
                  *(_WORD *)(v22 + v27) = 1 << (v20 - 1);
                  v27 += 2;
                }
                while (2 * v25 != v27);
              }
              v24 += 2;
              v22 += v26;
            }
            while (v24 < v23);
          }
        }
      }
      v28 = v29;
      *(_DWORD *)(v29 + 36) |= 1u;
      v30 = (std::mutex *)(v28 + 1104);
      v31 = 1;
      std::mutex::lock((std::mutex *)(v28 + 1104));
      atomic_store(0x7FFFFFFFu, (unsigned int *)(v28 + 1100));
      sub_1B678B174((uint64_t)&v30);
      std::condition_variable::notify_all((std::condition_variable *)(v28 + 1168));
      if (v31)
        std::mutex::unlock(v30);
      result = *(double *)&v29;
      *(_OWORD *)a1 = v29;
    }
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
  return result;
}

void sub_1B67CD134(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, char a12)
{
  if (a12)
    std::mutex::unlock(a11);
  sub_1B6772C88((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1B67CD164(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  v4 = 288;
  v5 = 16;
  *(_OWORD *)(a1 + 16) = 0u;
  do
  {
    sub_1B67B665C((_QWORD *)(a1 + v5), *(_QWORD *)(a2 + v5), *(_QWORD *)(a2 + v5 + 8));
    *(_DWORD *)(a1 + v4) = *(_DWORD *)(a2 + v4);
    v4 += 4;
    v5 += 16;
  }
  while (v4 != 356);
  *(_DWORD *)(a1 + 356) = *(_DWORD *)(a2 + 356);
  *(_QWORD *)(a1 + 360) = *(_QWORD *)(a2 + 360);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  return a1;
}

unsigned __int16 *sub_1B67CD200(unsigned __int16 *result, unsigned __int16 *a2, unint64_t a3, unsigned __int16 *a4, uint64_t a5)
{
  char *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned __int16 *v10;
  uint64_t v11;
  unsigned __int16 *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int16 *v17;
  char *v19;
  unint64_t v20;
  unsigned __int16 *v21;
  unint64_t v22;
  unsigned __int16 *v23;
  unsigned __int16 *v24;
  unsigned __int16 *v25;
  unsigned int v26;
  unsigned int v27;
  _BOOL4 v28;
  _BOOL4 v29;
  uint64_t v30;
  uint64_t v31;

  if (a3 >= 2)
  {
    v6 = (char *)result;
    if (a3 == 2)
    {
      v7 = *(a2 - 1);
      v8 = *result;
      if (v7 < v8)
      {
        *result = v7;
        *(a2 - 1) = v8;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      v19 = (char *)a4;
      v20 = a3 >> 1;
      v21 = &result[a3 >> 1];
      v22 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        sub_1B67CD404(result, v21, v22, a4);
        v23 = (unsigned __int16 *)&v19[2 * v20];
        result = sub_1B67CD404((unsigned __int16 *)&v6[2 * (a3 >> 1)], a2, a3 - (a3 >> 1), v23);
        v24 = (unsigned __int16 *)&v19[2 * a3];
        v25 = v23;
        while (v25 != v24)
        {
          v26 = *v25;
          v27 = *(unsigned __int16 *)v19;
          v28 = v26 < v27;
          v29 = v26 >= v27;
          if (v26 >= v27)
            LOWORD(v26) = *(_WORD *)v19;
          v19 += 2 * v29;
          v25 += v28;
          *(_WORD *)v6 = v26;
          v6 += 2;
          if (v19 == (char *)v23)
          {
            if (v25 != v24)
            {
              v30 = 0;
              do
              {
                *(_WORD *)&v6[v30 * 2] = v25[v30];
                ++v30;
              }
              while (&v25[v30] != v24);
            }
            return result;
          }
        }
        if (v19 != (char *)v23)
        {
          v31 = 0;
          do
          {
            *(_WORD *)&v6[v31] = *(_WORD *)&v19[v31];
            v31 += 2;
          }
          while (&v19[v31] != (char *)v23);
        }
      }
      else
      {
        sub_1B67CD200(result, v21, v22, a4, a5);
        sub_1B67CD200(&v6[2 * (a3 >> 1)], a2, a3 - (a3 >> 1), v19, a5);
        return (unsigned __int16 *)sub_1B67CD5CC(v6, &v6[2 * (a3 >> 1)], (char *)a2, a3 >> 1, a3 - (a3 >> 1), v19, a5);
      }
    }
    else if (result != a2)
    {
      v10 = result + 1;
      if (result + 1 != a2)
      {
        v11 = 2;
        v12 = result;
        do
        {
          v13 = v12[1];
          v14 = *v12;
          v12 = v10;
          if (v13 < v14)
          {
            v15 = v11;
            while (1)
            {
              *(unsigned __int16 *)((char *)result + v15) = v14;
              v16 = v15 - 2;
              if (v15 == 2)
                break;
              v14 = *(unsigned __int16 *)((char *)result + v15 - 4);
              v15 -= 2;
              if (v13 >= v14)
              {
                v17 = (unsigned __int16 *)((char *)result + v16);
                goto LABEL_15;
              }
            }
            v17 = result;
LABEL_15:
            *v17 = v13;
          }
          v10 = v12 + 1;
          v11 += 2;
        }
        while (v12 + 1 != a2);
      }
    }
  }
  return result;
}

unsigned __int16 *sub_1B67CD404(unsigned __int16 *result, unsigned __int16 *a2, unint64_t a3, unsigned __int16 *a4)
{
  unsigned __int16 *v4;
  unsigned __int16 *v6;
  unsigned __int16 v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned __int16 *v15;
  unsigned __int16 v16;
  unsigned int v17;
  unsigned int v18;
  unsigned __int16 *v19;
  uint64_t v20;
  unsigned int v21;
  unsigned __int16 *v22;
  unsigned __int16 *v23;
  unsigned int v24;
  unsigned int v25;
  _BOOL4 v26;
  _BOOL4 v27;
  uint64_t v28;
  uint64_t v29;

  if (a3)
  {
    v4 = a4;
    v6 = result;
    if (a3 == 1)
    {
LABEL_9:
      *v4 = *v6;
      return result;
    }
    if (a3 == 2)
    {
      v9 = *(a2 - 1);
      v8 = *(a2 - 1);
      v10 = *result;
      v11 = v9 >= v10;
      if (v9 >= v10)
        v8 = *result;
      *a4 = v8;
      v4 = a4 + 1;
      if (v11)
        v6 = a2 - 1;
      goto LABEL_9;
    }
    if ((uint64_t)a3 > 8)
    {
      v22 = &result[a3 >> 1];
      sub_1B67CD200(result, v22, a3 >> 1, a4, a3 >> 1);
      result = (unsigned __int16 *)sub_1B67CD200(&v6[a3 >> 1], a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
      v23 = &v6[a3 >> 1];
      while (v23 != a2)
      {
        v24 = *v23;
        v25 = *v6;
        v26 = v24 >= v25;
        v27 = v24 < v25;
        if (v24 >= v25)
          LOWORD(v24) = *v6;
        v23 += v27;
        v6 += v26;
        *v4++ = v24;
        if (v6 == v22)
        {
          if (v23 != a2)
          {
            v28 = 0;
            do
            {
              v4[v28] = v23[v28];
              ++v28;
            }
            while (&v23[v28] != a2);
          }
          return result;
        }
      }
      if (v6 != v22)
      {
        v29 = 0;
        do
        {
          v4[v29] = v6[v29];
          ++v29;
        }
        while (&v6[v29] != v22);
      }
    }
    else if (result != a2)
    {
      v12 = result + 1;
      *a4 = *result;
      if (result + 1 != a2)
      {
        v13 = 0;
        v14 = a4;
        v15 = a4;
        do
        {
          v17 = *v15++;
          v16 = v17;
          v18 = *v12;
          if (v18 >= v17)
          {
            *v15 = v18;
          }
          else
          {
            v14[1] = v16;
            v19 = a4;
            if (v14 != a4)
            {
              v20 = v13;
              while (1)
              {
                v19 = (unsigned __int16 *)((char *)a4 + v20);
                v21 = *(unsigned __int16 *)((char *)a4 + v20 - 2);
                if (*v12 >= v21)
                  break;
                *v19 = v21;
                v20 -= 2;
                if (!v20)
                {
                  v19 = a4;
                  break;
                }
              }
            }
            *v19 = *v12;
          }
          ++v12;
          v13 += 2;
          v14 = v15;
        }
        while (v12 != a2);
      }
    }
  }
  return result;
}

char *sub_1B67CD5CC(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  uint64_t v8;
  char *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  char *v15;
  unsigned __int16 *v16;
  unint64_t v17;
  unint64_t v18;
  unsigned __int16 *v19;
  unsigned __int16 *v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unsigned __int16 *v27;
  unsigned __int16 *v28;
  unsigned int v29;
  unsigned __int16 *v30;
  uint64_t v31;
  uint64_t v32;
  unsigned __int16 v33;
  uint64_t v34;
  uint64_t v35;
  int64_t v37;
  char *v38;
  unsigned __int16 v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned __int16 *v44;
  unsigned __int16 v45;
  unsigned __int16 v46;
  unsigned __int16 *v47;
  unsigned __int16 *v48;
  unsigned __int16 *v49;
  BOOL v50;
  char v51;
  uint64_t v52;
  char *v53;
  char *v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  char *v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  uint64_t v64;
  char *v65;
  unsigned int v66;
  unsigned int v67;
  _BOOL4 v68;
  _BOOL4 v69;
  uint64_t v70;
  unsigned __int16 v71;
  unsigned __int16 v72;
  uint64_t v73;
  uint64_t v74;
  char *v75;
  char *v76;

  if (a5)
  {
    v8 = a5;
    v11 = result;
    while (v8 > a7 && a4 > a7)
    {
      if (!a4)
        return result;
      v12 = *(unsigned __int16 *)a2;
      while (1)
      {
        v13 = *(unsigned __int16 *)v11;
        if (v12 < v13)
          break;
        v11 += 2;
        if (!--a4)
          return result;
      }
      if (a4 >= v8)
      {
        if (a4 == 1)
        {
          *(_WORD *)v11 = v12;
          *(_WORD *)a2 = v13;
          return result;
        }
        if (a4 >= 0)
          v24 = a4;
        else
          v24 = a4 + 1;
        v16 = (unsigned __int16 *)&v11[v24 & 0xFFFFFFFFFFFFFFFELL];
        v15 = a3;
        if (a3 != a2)
        {
          v25 = (a3 - a2) >> 1;
          v15 = a2;
          do
          {
            v26 = v25 >> 1;
            v27 = (unsigned __int16 *)&v15[2 * (v25 >> 1)];
            v29 = *v27;
            v28 = v27 + 1;
            v25 += ~(v25 >> 1);
            if (v29 < *v16)
              v15 = (char *)v28;
            else
              v25 = v26;
          }
          while (v25);
        }
        v23 = v24 >> 1;
        v22 = (v15 - a2) >> 1;
      }
      else
      {
        if (v8 >= 0)
          v14 = v8;
        else
          v14 = v8 + 1;
        v15 = &a2[v14 & 0xFFFFFFFFFFFFFFFELL];
        v16 = (unsigned __int16 *)a2;
        if (a2 != v11)
        {
          v17 = (a2 - v11) >> 1;
          v16 = (unsigned __int16 *)v11;
          do
          {
            v18 = v17 >> 1;
            v19 = &v16[v17 >> 1];
            v21 = *v19;
            v20 = v19 + 1;
            v17 += ~(v17 >> 1);
            if (*(unsigned __int16 *)v15 < v21)
              v17 = v18;
            else
              v16 = v20;
          }
          while (v17);
        }
        v22 = v14 >> 1;
        v23 = ((char *)v16 - v11) >> 1;
      }
      v30 = (unsigned __int16 *)v15;
      if (v16 != (unsigned __int16 *)a2)
      {
        v30 = v16;
        if (a2 != v15)
        {
          if (v16 + 1 == (unsigned __int16 *)a2)
          {
            v71 = *v16;
            v37 = v15 - a2;
            v73 = v22;
            v75 = a6;
            v38 = a3;
            memmove(v16, a2, v15 - a2);
            v22 = v73;
            a6 = v75;
            a3 = v38;
            v30 = (unsigned __int16 *)((char *)v16 + v37);
            *v30 = v71;
          }
          else if (a2 + 2 == v15)
          {
            v39 = *((_WORD *)v15 - 1);
            v30 = v16 + 1;
            if (v15 - 2 != (char *)v16)
            {
              v74 = v22;
              v76 = a6;
              v40 = a3;
              v72 = *((_WORD *)v15 - 1);
              memmove(v16 + 1, v16, v15 - 2 - (char *)v16);
              v39 = v72;
              v22 = v74;
              a6 = v76;
              a3 = v40;
            }
            *v16 = v39;
          }
          else
          {
            v31 = (a2 - (char *)v16) >> 1;
            if (v31 == (v15 - a2) >> 1)
            {
              v32 = 0;
              do
              {
                v33 = v16[v32];
                v16[v32] = *(_WORD *)&a2[v32 * 2];
                v34 = (uint64_t)&v16[v32 + 1];
                *(_WORD *)&a2[v32 * 2] = v33;
                v35 = (uint64_t)&a2[v32 * 2 + 2];
                ++v32;
              }
              while ((char *)v34 != a2 && v35 != (_QWORD)v15);
              v30 = (unsigned __int16 *)a2;
            }
            else
            {
              v41 = (v15 - a2) >> 1;
              v42 = (a2 - (char *)v16) >> 1;
              do
              {
                v43 = v42;
                v42 = v41;
                v41 = v43 % v41;
              }
              while (v41);
              if (v42)
              {
                v44 = &v16[v42];
                do
                {
                  v46 = *--v44;
                  v45 = v46;
                  v47 = &v44[v31];
                  v48 = v44;
                  do
                  {
                    v49 = v48;
                    v48 = v47;
                    *v49 = *v47;
                    v50 = __OFSUB__(v31, (v15 - (char *)v47) >> 1);
                    v52 = v31 - ((v15 - (char *)v47) >> 1);
                    v51 = (v52 < 0) ^ v50;
                    v47 = &v16[v52];
                    if (v51)
                      v47 = &v48[v31];
                  }
                  while (v47 != v44);
                  *v48 = v45;
                }
                while (v44 != v16);
              }
              v30 = &v16[(v15 - a2) >> 1];
            }
          }
        }
      }
      a4 -= v23;
      v8 -= v22;
      if (v23 + v22 >= a4 + v8)
      {
        v56 = a4;
        v57 = v22;
        v54 = a6;
        result = (char *)sub_1B67CD5CC(v30, v15, a3, v56, v8, a6, a7);
        v15 = (char *)v16;
        v8 = v57;
        a4 = v23;
        a3 = (char *)v30;
      }
      else
      {
        v53 = v11;
        v54 = a6;
        v55 = a3;
        result = (char *)sub_1B67CD5CC(v53, v16, v30, v23, v22, a6, a7);
        a3 = v55;
        v11 = (char *)v30;
      }
      a2 = v15;
      a6 = v54;
      if (!v8)
        return result;
    }
    if (a4 <= v8)
    {
      if (v11 != a2)
      {
        v64 = 0;
        do
        {
          *(_WORD *)&a6[v64] = *(_WORD *)&v11[v64];
          v64 += 2;
        }
        while (&v11[v64] != a2);
        v65 = &a6[v64];
        if (v65 != a6)
        {
          while (a2 != a3)
          {
            v66 = *(unsigned __int16 *)a2;
            v67 = *(unsigned __int16 *)a6;
            v68 = v66 < v67;
            v69 = v66 >= v67;
            if (v66 >= v67)
              LOWORD(v66) = *(_WORD *)a6;
            a6 += 2 * v69;
            a2 += 2 * v68;
            *(_WORD *)v11 = v66;
            v11 += 2;
            if (a6 == v65)
              return result;
          }
          return (char *)memmove(v11, a6, v65 - a6);
        }
      }
    }
    else if (a2 != a3)
    {
      v58 = 0;
      do
      {
        *(_WORD *)&a6[v58] = *(_WORD *)&a2[v58];
        v58 += 2;
      }
      while (&a2[v58] != a3);
      v59 = &a6[v58];
      if (v59 != a6)
      {
        v60 = a3 - 2;
        while (a2 != v11)
        {
          v61 = *((unsigned __int16 *)v59 - 1);
          v62 = *((unsigned __int16 *)a2 - 1);
          v63 = v61 >= v62;
          if (v61 <= v62)
            LOWORD(v61) = *((_WORD *)a2 - 1);
          if (v63)
            v59 -= 2;
          else
            a2 -= 2;
          *(_WORD *)v60 = v61;
          v60 -= 2;
          if (v59 == a6)
            return result;
        }
        v70 = 0;
        do
        {
          *(_WORD *)&v60[v70] = *(_WORD *)&v59[v70 - 2];
          v70 -= 2;
        }
        while (&v59[v70] != a6);
      }
    }
  }
  return result;
}

void *sub_1B67CDA40(uint64_t a1, unsigned __int8 a2)
{
  unsigned __int8 v2;
  uint64_t v3;
  uint64_t *v4;
  int v5;
  int v6;
  uint64_t v7;
  int v9;
  int v10;
  unsigned __int8 v11;
  uint64_t v12;

  v2 = atomic_load((unsigned __int8 *)&qword_1EF138FB0);
  if ((v2 & 1) == 0)
  {
    v12 = a1;
    v11 = a2;
    v9 = __cxa_guard_acquire(&qword_1EF138FB0);
    a2 = v11;
    v10 = v9;
    a1 = v12;
    if (v10)
    {
      __cxa_atexit((void (*)(void *))sub_1B67CD160, &unk_1EF138FA0, &dword_1B676B000);
      __cxa_guard_release(&qword_1EF138FB0);
      a2 = v11;
      a1 = v12;
    }
  }
  v3 = 0;
  v4 = (uint64_t *)(a1 + 16);
  v5 = -1;
  v6 = -1;
  do
  {
    v7 = *v4;
    if (*v4 && *(_DWORD *)(v7 + 680) > v6 && *(_DWORD *)(v7 + 40) == a2)
    {
      v6 = *(_DWORD *)(v7 + 680);
      v5 = v3;
    }
    ++v3;
    v4 += 2;
  }
  while (v3 != 17);
  if (v5 == -1)
    return &unk_1EF138FA0;
  else
    return (void *)(a1 + 16 * v5 + 16);
}

void *sub_1B67CDB24(uint64_t a1, int a2)
{
  unsigned __int8 v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v7;
  int v8;
  int v9;
  uint64_t v10;

  v2 = atomic_load((unsigned __int8 *)&qword_1EF138FE0);
  if ((v2 & 1) == 0)
  {
    v10 = a1;
    v9 = a2;
    v7 = __cxa_guard_acquire(&qword_1EF138FE0);
    a2 = v9;
    v8 = v7;
    a1 = v10;
    if (v8)
    {
      __cxa_atexit((void (*)(void *))sub_1B67CD160, &unk_1EF138FD0, &dword_1B676B000);
      __cxa_guard_release(&qword_1EF138FE0);
      a1 = v10;
      a2 = v9;
    }
  }
  v3 = a1 + 16 * a2;
  v5 = *(_QWORD *)(v3 + 16);
  v4 = v3 + 16;
  if (v5)
    return (void *)v4;
  else
    return &unk_1EF138FD0;
}

uint64_t sub_1B67CDBC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 356);
  v3 = 16;
  while (*(_QWORD *)(a1 + v3))
  {
    v3 += 16;
    if (v3 == 288)
      return 4294954387;
  }
  sub_1B67B665C((_QWORD *)(a1 + v3), a2, a3);
  return 0;
}

void sub_1B67CDC08(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  for (i = 16; i != 288; i += 16)
  {
    v3 = *(_QWORD *)(a1 + i);
    if (v3 && !*(_DWORD *)(v3 + 36))
    {
      if (*(_BYTE *)(v3 + 45))
        sub_1B67C7674((_QWORD *)(a1 + i));
    }
  }
}

uint64_t sub_1B67CDC54(uint64_t result, unsigned int *a2)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  unsigned int *v9;
  uint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  unsigned int *v13;

  if (a2)
  {
    for (i = 16; i != 288; i += 16)
    {
      v3 = *(_QWORD *)(result + i);
      if (v3)
        *(_DWORD *)(v3 + 36) = 0;
    }
    v4 = a2[1];
    if ((int)v4 >= 1)
    {
      v5 = a2 + 6;
      do
      {
        if (*(_QWORD *)v5)
          *(_DWORD *)(*(_QWORD *)v5 + 36) |= 1u;
        v5 += 4;
        --v4;
      }
      while (v4);
    }
    v6 = a2[2];
    if ((int)v6 >= 1)
    {
      v7 = a2 + 70;
      do
      {
        if (*(_QWORD *)v7)
          *(_DWORD *)(*(_QWORD *)v7 + 36) |= 1u;
        v7 += 4;
        --v6;
      }
      while (v6);
    }
    v8 = a2[4];
    if ((int)v8 >= 1)
    {
      v9 = a2 + 198;
      do
      {
        if (*(_QWORD *)v9)
          *(_DWORD *)(*(_QWORD *)v9 + 36) |= 1u;
        v9 += 4;
        --v8;
      }
      while (v8);
    }
    v10 = a2[3];
    if ((int)v10 >= 1)
    {
      v11 = a2 + 134;
      do
      {
        if (*(_QWORD *)v11)
          *(_DWORD *)(*(_QWORD *)v11 + 36) |= 2u;
        v11 += 4;
        --v10;
      }
      while (v10);
    }
    v12 = a2[5];
    if ((int)v12 >= 1)
    {
      v13 = a2 + 262;
      do
      {
        if (*(_QWORD *)v13)
          *(_DWORD *)(*(_QWORD *)v13 + 36) |= 2u;
        v13 += 4;
        --v12;
      }
      while (v12);
    }
  }
  return result;
}

uint64_t sub_1B67CDD68(uint64_t a1)
{
  int v1;
  uint64_t i;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int *v7;
  const std::nothrow_t *v8;
  unint64_t v9;
  int *v10;
  BOOL v11;
  int *v12;
  uint64_t (*v14)(int *, int *);

  v1 = 0;
  for (i = 16; i != 288; i += 16)
  {
    v3 = *(_QWORD *)(a1 + i);
    if (v3)
    {
      v4 = a1 + 4 * v1++;
      *(_DWORD *)(v4 + 288) = *(_DWORD *)(v3 + 680);
    }
  }
  v5 = a1 + 288;
  v6 = v1;
  v7 = (int *)(a1 + 288 + 4 * v1);
  v14 = (uint64_t (*)(int *, int *))sub_1B67CDE64;
  if (v1 < 129)
  {
LABEL_9:
    v12 = 0;
    v9 = 0;
  }
  else
  {
    v8 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
    v9 = v1;
    while (1)
    {
      v10 = (int *)operator new(4 * v9, v8);
      if (v10)
        break;
      v11 = v9 > 1;
      v9 >>= 1;
      if (!v11)
        goto LABEL_9;
    }
    v12 = v10;
  }
  sub_1B67CDE78(v5, v7, &v14, v6, v12, v9);
  if (v12)
    operator delete(v12);
  return v5;
}

void sub_1B67CDE4C(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

BOOL sub_1B67CDE64(_DWORD *a1, _DWORD *a2)
{
  return *a1 > *a2;
}

uint64_t sub_1B67CDE78(uint64_t result, int *a2, uint64_t (**a3)(int *, int *), unint64_t a4, int *a5, uint64_t a6)
{
  int *v8;
  int *v9;
  int v10;
  int *v12;
  uint64_t v13;
  int *v14;
  int *v15;
  uint64_t v16;
  int *v17;
  char *v19;
  unint64_t v20;
  int *v21;
  unint64_t v22;
  int *v23;
  char *v24;
  int *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  int v29;

  if (a4 >= 2)
  {
    v8 = (int *)result;
    if (a4 == 2)
    {
      v9 = a2 - 1;
      result = (*a3)(a2 - 1, (int *)result);
      if ((_DWORD)result)
      {
        v10 = *v8;
        *v8 = *v9;
        *v9 = v10;
      }
    }
    else if ((uint64_t)a4 > 128)
    {
      v19 = (char *)a5;
      v20 = a4 >> 1;
      v21 = (int *)(result + 4 * (a4 >> 1));
      v22 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        sub_1B67CE0DC((int *)result, v21, a3, v22, a5);
        v23 = (int *)&v19[4 * v20];
        result = (uint64_t)sub_1B67CE0DC(&v8[a4 >> 1], a2, a3, a4 - (a4 >> 1), v23);
        v24 = &v19[4 * a4];
        v25 = v23;
        while (v25 != (int *)v24)
        {
          result = (*a3)(v25, (int *)v19);
          if ((_DWORD)result)
            v26 = (char *)v25;
          else
            v26 = v19;
          v19 += 4 * (result ^ 1);
          v25 += result;
          *v8++ = *(_DWORD *)v26;
          if (v19 == (char *)v23)
          {
            if (v25 != (int *)v24)
            {
              v27 = 0;
              do
              {
                v8[v27] = v25[v27];
                ++v27;
              }
              while (&v25[v27] != (int *)v24);
            }
            return result;
          }
        }
        if (v19 != (char *)v23)
        {
          v28 = 0;
          do
          {
            v8[v28] = *(_DWORD *)&v19[v28 * 4];
            ++v28;
          }
          while (&v19[v28 * 4] != (char *)v23);
        }
      }
      else
      {
        sub_1B67CDE78(result, v21, a3, v22, a5, a6);
        sub_1B67CDE78(&v8[a4 >> 1], a2, a3, a4 - (a4 >> 1), v19, a6);
        return sub_1B67CE2E4((uint64_t)v8, &v8[a4 >> 1], a2, (uint64_t (**)(_QWORD, _QWORD))a3, a4 >> 1, a4 - (a4 >> 1), v19, a6);
      }
    }
    else if ((int *)result != a2)
    {
      v12 = (int *)(result + 4);
      if ((int *)(result + 4) != a2)
      {
        v13 = 0;
        v14 = (int *)result;
        do
        {
          v15 = v14;
          v14 = v12;
          result = (*a3)(v12, v15);
          if ((_DWORD)result)
          {
            v29 = *v14;
            v16 = v13;
            while (1)
            {
              *(int *)((char *)v8 + v16 + 4) = *(int *)((char *)v8 + v16);
              if (!v16)
                break;
              v16 -= 4;
              result = (*a3)(&v29, (int *)((char *)v8 + v16));
              if ((result & 1) == 0)
              {
                v17 = (int *)((char *)v8 + v16 + 4);
                goto LABEL_15;
              }
            }
            v17 = v8;
LABEL_15:
            *v17 = v29;
          }
          v12 = v14 + 1;
          v13 += 4;
        }
        while (v14 + 1 != a2);
      }
    }
  }
  return result;
}

int *sub_1B67CE0DC(int *result, int *a2, uint64_t (**a3)(int *, int *), unint64_t a4, int *a5)
{
  int *v5;
  int *v7;
  int *v10;
  int *v11;
  int *v12;
  uint64_t v13;
  int *v14;
  int *v15;
  int *v16;
  uint64_t v17;
  int v18;
  int *v19;
  int *v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;

  if (a4)
  {
    v5 = a5;
    v7 = result;
    if (a4 == 1)
    {
LABEL_9:
      *v5 = *v7;
      return result;
    }
    if (a4 == 2)
    {
      v10 = a2 - 1;
      result = (int *)(*a3)(a2 - 1, result);
      if ((_DWORD)result)
        v11 = v10;
      else
        v11 = v7;
      *v5++ = *v11;
      if (!(_DWORD)result)
        v7 = v10;
      goto LABEL_9;
    }
    if ((uint64_t)a4 > 8)
    {
      v19 = &result[a4 >> 1];
      sub_1B67CDE78(result, v19, a3, a4 >> 1, a5, a4 >> 1);
      result = (int *)sub_1B67CDE78(&v7[a4 >> 1], a2, a3, a4 - (a4 >> 1), &v5[a4 >> 1], a4 - (a4 >> 1));
      v20 = &v7[a4 >> 1];
      while (v20 != a2)
      {
        result = (int *)(*a3)(v20, v7);
        if ((_DWORD)result)
          v21 = v20;
        else
          v21 = v7;
        v20 += result;
        v7 += result ^ 1;
        *v5++ = *v21;
        if (v7 == v19)
        {
          if (v20 != a2)
          {
            v22 = 0;
            do
            {
              v5[v22] = v20[v22];
              ++v22;
            }
            while (&v20[v22] != a2);
          }
          return result;
        }
      }
      if (v7 != v19)
      {
        v23 = 0;
        do
        {
          v5[v23] = v7[v23];
          ++v23;
        }
        while (&v7[v23] != v19);
      }
    }
    else if (result != a2)
    {
      v12 = result + 1;
      *a5 = *result;
      if (result + 1 != a2)
      {
        v13 = 0;
        v14 = a5;
        do
        {
          v15 = v14++;
          result = (int *)(*a3)(v12, v15);
          v16 = v14;
          if ((_DWORD)result)
          {
            v15[1] = *v15;
            v16 = v5;
            if (v15 != v5)
            {
              v17 = v13;
              while (1)
              {
                v16 = (int *)((char *)v5 + v17);
                result = (int *)(*a3)(v12, (int *)((char *)v5 + v17 - 4));
                if (!(_DWORD)result)
                  break;
                *(int *)((char *)v5 + v17) = *(int *)((char *)v5 + v17 - 4);
                v17 -= 4;
                if (!v17)
                {
                  v16 = v5;
                  break;
                }
              }
            }
          }
          v18 = *v12++;
          *v16 = v18;
          v13 += 4;
        }
        while (v12 != a2);
      }
    }
  }
  return result;
}

uint64_t sub_1B67CE2E4(uint64_t result, _DWORD *a2, _DWORD *a3, uint64_t (**a4)(_QWORD, _QWORD), uint64_t a5, uint64_t a6, char *a7, uint64_t a8)
{
  uint64_t v10;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  char *v19;
  unint64_t v20;
  _DWORD *v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t (*v25)(_DWORD *, _DWORD *);
  unint64_t v26;
  _DWORD *v27;
  int v28;
  _DWORD *v29;
  _DWORD *v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  int v37;
  int64_t v38;
  const void *v39;
  size_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _DWORD *v49;
  int v50;
  int v51;
  _DWORD *v52;
  _DWORD *v53;
  _DWORD *v54;
  BOOL v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  _DWORD *v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  _DWORD *v63;
  char *v64;
  uint64_t v65;
  char *v66;
  char *v67;
  int v68;
  uint64_t v69;
  char *v70;
  char *v71;
  _DWORD *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;

  if (!a6)
    return result;
  v10 = a6;
  v15 = (_DWORD *)result;
  while (v10 > a8 && a5 > a8)
  {
    if (!a5)
      return result;
    while (1)
    {
      result = (*a4)(a2, v15);
      if ((result & 1) != 0)
        break;
      ++v15;
      if (!--a5)
        return result;
    }
    v78 = v10;
    if (a5 >= v10)
    {
      if (a5 == 1)
      {
        v68 = *v15;
        *v15 = *a2;
        *a2 = v68;
        return result;
      }
      if (a5 >= 0)
        v23 = a5;
      else
        v23 = a5 + 1;
      v24 = v23 >> 1;
      v21 = &v15[v23 >> 1];
      if (a3 == a2)
      {
        v18 = a3;
        v29 = a3;
      }
      else
      {
        v74 = v23 >> 1;
        v76 = a8;
        v70 = a7;
        v25 = (uint64_t (*)(_DWORD *, _DWORD *))*a4;
        v26 = a3 - a2;
        v18 = a2;
        do
        {
          v27 = &v18[v26 >> 1];
          v28 = v25(v27, v21);
          if (v28)
            v26 += ~(v26 >> 1);
          else
            v26 >>= 1;
          if (v28)
            v18 = v27 + 1;
        }
        while (v26);
        v29 = a2;
        a7 = v70;
        v24 = v74;
        a8 = v76;
      }
      v17 = v18 - v29;
    }
    else
    {
      if (v10 >= 0)
        v16 = v10;
      else
        v16 = v10 + 1;
      v17 = v16 >> 1;
      v18 = &a2[v16 >> 1];
      if (a2 == v15)
      {
        v21 = a2;
        v22 = a2;
      }
      else
      {
        v73 = v16 >> 1;
        v72 = a3;
        v19 = a7;
        v20 = a2 - v15;
        v21 = v15;
        do
        {
          if ((*a4)(v18, &v21[v20 >> 1]))
          {
            v20 >>= 1;
          }
          else
          {
            v21 += (v20 >> 1) + 1;
            v20 += ~(v20 >> 1);
          }
        }
        while (v20);
        v22 = v15;
        a7 = v19;
        a3 = v72;
        v17 = v73;
      }
      v24 = v21 - v22;
    }
    v30 = v18;
    if (v21 != a2)
    {
      v30 = v21;
      if (a2 != v18)
      {
        if (v21 + 1 == a2)
        {
          v77 = a8;
          v71 = a7;
          v37 = *v21;
          v38 = (char *)v18 - (char *)a2;
          v39 = a2;
          v40 = (char *)v18 - (char *)a2;
          v41 = v17;
          v42 = v24;
          memmove(v21, v39, v40);
          v24 = v42;
          v17 = v41;
          v30 = (_DWORD *)((char *)v21 + v38);
          *v30 = v37;
        }
        else
        {
          if (a2 + 1 != v18)
          {
            v31 = a2 - v21;
            if (v31 == v18 - a2)
            {
              v32 = 0;
              do
              {
                v33 = v21[v32];
                v21[v32] = a2[v32];
                v34 = (uint64_t)&v21[v32 + 1];
                a2[v32] = v33;
                v35 = (uint64_t)&a2[++v32];
              }
              while ((_DWORD *)v34 != a2 && v35 != (_QWORD)v18);
              v30 = a2;
            }
            else
            {
              v46 = v18 - a2;
              v47 = a2 - v21;
              do
              {
                v48 = v47;
                v47 = v46;
                v46 = v48 % v46;
              }
              while (v46);
              if (v47)
              {
                v49 = &v21[v47];
                do
                {
                  v51 = *--v49;
                  v50 = v51;
                  v52 = &v49[v31];
                  v53 = v49;
                  do
                  {
                    v54 = v53;
                    v53 = v52;
                    *v54 = *v52;
                    v55 = __OFSUB__(v31, v18 - v52);
                    v57 = v31 - (v18 - v52);
                    v56 = (v57 < 0) ^ v55;
                    v52 = &v21[v57];
                    if (v56)
                      v52 = &v53[v31];
                  }
                  while (v52 != v49);
                  *v53 = v50;
                }
                while (v49 != v21);
              }
              v30 = &v21[v18 - a2];
            }
            goto LABEL_64;
          }
          v77 = a8;
          v71 = a7;
          v43 = *(v18 - 1);
          v30 = v21 + 1;
          if (v18 - 1 != v21)
          {
            v44 = v17;
            v45 = v24;
            memmove(v21 + 1, v21, (char *)(v18 - 1) - (char *)v21);
            v24 = v45;
            v17 = v44;
          }
          *v21 = v43;
        }
        a7 = v71;
        a8 = v77;
      }
    }
LABEL_64:
    a5 -= v24;
    v58 = v78 - v17;
    if (v24 + v17 >= a5 + v78 - v17)
    {
      v59 = a3;
      v75 = v24;
      v60 = v17;
      result = sub_1B67CE2E4(v30, v18, v59, a4, a5, v78 - v17, a7, a8);
      v18 = v21;
      v10 = v60;
      a5 = v75;
      a3 = v30;
    }
    else
    {
      result = sub_1B67CE2E4(v15, v21, v30, a4, v24, v17, a7, a8);
      v15 = v30;
      v10 = v58;
    }
    a2 = v18;
    if (!v10)
      return result;
  }
  if (a5 <= v10)
  {
    if (v15 != a2)
    {
      v65 = 0;
      do
      {
        *(_DWORD *)&a7[v65 * 4] = v15[v65];
        ++v65;
      }
      while (&v15[v65] != a2);
      v66 = &a7[v65 * 4];
      if (&a7[v65 * 4] != a7)
      {
        while (a2 != a3)
        {
          result = (*a4)(a2, a7);
          if ((_DWORD)result)
            v67 = (char *)a2;
          else
            v67 = a7;
          a7 += 4 * (result ^ 1);
          a2 += result;
          *v15++ = *(_DWORD *)v67;
          if (a7 == v66)
            return result;
        }
        return (uint64_t)memmove(v15, a7, v66 - a7);
      }
    }
  }
  else if (a2 != a3)
  {
    v61 = 0;
    do
    {
      *(_DWORD *)&a7[v61 * 4] = a2[v61];
      ++v61;
    }
    while (&a2[v61] != a3);
    v62 = &a7[v61 * 4];
    if (&a7[v61 * 4] != a7)
    {
      v63 = a3 - 1;
      while (a2 != v15)
      {
        result = (*a4)(v62 - 4, a2 - 1);
        if ((_DWORD)result)
          v64 = (char *)a2;
        else
          v64 = v62;
        if ((_DWORD)result)
          --a2;
        else
          v62 -= 4;
        *v63-- = *((_DWORD *)v64 - 1);
        if (v62 == a7)
          return result;
      }
      v69 = 0;
      do
      {
        v63[v69] = *(_DWORD *)&v62[v69 * 4 - 4];
        --v69;
      }
      while (&v62[v69 * 4] != a7);
    }
  }
  return result;
}

void sub_1B67CE7F4(uint64_t a1, int a2)
{
  int v3;
  uint64_t v5;
  NSObject *v6;
  _DWORD *v7;
  BOOL v8;
  int v9;
  int v10;
  int v11;
  const char *v12;
  const char *v13;
  int v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = dword_1EF137CD0;
  if (dword_1EF137CD0 >= 3 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    v16 = a2;
    _os_log_impl(&dword_1B676B000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "<<<<<< [Poc %d]: SW DPB >>>>>>\n", buf, 8u);
    v3 = dword_1EF137CD0;
  }
  v5 = 16;
  v6 = MEMORY[0x1E0C81028];
  do
  {
    v7 = *(_DWORD **)(a1 + v5);
    if (v7)
      v8 = v3 < 3;
    else
      v8 = 1;
    if (!v8 && os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v9 = v7[170];
      v10 = v7[171];
      v11 = v7[9];
      v12 = "N/A";
      if (v11 == 1)
        v12 = "short_term";
      if (v11 == 2)
        v13 = "long_term";
      else
        v13 = v12;
      v14 = v7[3];
      *(_DWORD *)buf = 67109890;
      v16 = v9;
      v17 = 1024;
      v18 = v10;
      v19 = 2080;
      v20 = v13;
      v21 = 1024;
      v22 = v14;
      _os_log_impl(&dword_1B676B000, v6, OS_LOG_TYPE_DEFAULT, "poc: %d\tframe_num_driver: %d\treference_type: %s temporalID %d\n", buf, 0x1Eu);
      v3 = dword_1EF137CD0;
    }
    v5 += 16;
  }
  while (v5 != 288);
}

uint64_t sub_1B67CE9A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL *v6;
  int v7;
  __int16 v8;
  unsigned __int8 *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t result;

  *(_WORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 6) = 33685509;
  *(_BYTE *)(a1 + 10) = 2;
  *(_DWORD *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 44) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  v6 = (BOOL *)(a1 + 80);
  *(_QWORD *)(a1 + 11) = 0;
  *(_QWORD *)(a1 + 17) = 0;
  *(_QWORD *)(a1 + 28) = 0;
  *(_BYTE *)(a1 + 36) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  if (sub_1B67C9094(a2, 1))
  {
    v7 = sub_1B67C9094(a2, 8);
    if (v7 == 255)
    {
      *(_WORD *)a1 = sub_1B67C9094(a2, 16);
      v8 = sub_1B67C9094(a2, 16);
    }
    else
    {
      if (v7 > 16)
        goto LABEL_7;
      v9 = (unsigned __int8 *)&unk_1B69206DB + 2 * v7;
      *(_WORD *)a1 = *v9;
      v8 = v9[1];
    }
    *(_WORD *)(a1 + 2) = v8;
  }
LABEL_7:
  v10 = sub_1B67C9094(a2, 1);
  *(_BYTE *)(a1 + 4) = v10 != 0;
  if (v10)
    *(_BYTE *)(a1 + 5) = sub_1B67C9094(a2, 1) != 0;
  if (sub_1B67C9094(a2, 1))
  {
    *(_BYTE *)(a1 + 6) = sub_1B67C9094(a2, 3);
    *(_BYTE *)(a1 + 7) = sub_1B67C9094(a2, 1) != 0;
    if (sub_1B67C9094(a2, 1))
    {
      *(_BYTE *)(a1 + 8) = sub_1B67C9094(a2, 8);
      *(_BYTE *)(a1 + 9) = sub_1B67C9094(a2, 8);
      *(_BYTE *)(a1 + 10) = sub_1B67C9094(a2, 8);
    }
  }
  if (sub_1B67C9094(a2, 1))
  {
    *(_BYTE *)(a1 + 11) = sub_1B67C9140(a2);
    *(_BYTE *)(a1 + 12) = sub_1B67C9140(a2);
  }
  *(_BYTE *)(a1 + 13) = sub_1B67C9094(a2, 1) != 0;
  *(_BYTE *)(a1 + 14) = sub_1B67C9094(a2, 1) != 0;
  *(_BYTE *)(a1 + 15) = sub_1B67C9094(a2, 1) != 0;
  if (sub_1B67C9094(a2, 1))
  {
    *(_WORD *)(a1 + 16) = sub_1B67C9140(a2);
    *(_WORD *)(a1 + 18) = sub_1B67C9140(a2);
    *(_WORD *)(a1 + 20) = sub_1B67C9140(a2);
    *(_WORD *)(a1 + 22) = sub_1B67C9140(a2);
  }
  v11 = sub_1B67C9094(a2, 1);
  *(_BYTE *)(a1 + 24) = v11 != 0;
  if (v11)
  {
    v12 = sub_1B67C9094(a2, 16);
    *(_DWORD *)(a1 + 28) = sub_1B67C9094(a2, 16) + (v12 << 16);
    v13 = sub_1B67C9094(a2, 16);
    *(_DWORD *)(a1 + 32) = sub_1B67C9094(a2, 16) + (v13 << 16);
    v14 = sub_1B67C9094(a2, 1);
    *(_BYTE *)(a1 + 36) = v14 != 0;
    if (v14)
      *(_DWORD *)(a1 + 40) = sub_1B67C91C8(a2);
    v15 = sub_1B67C9094(a2, 1);
    *(_BYTE *)(a1 + 44) = v15 != 0;
    if (v15)
      sub_1B6803730(a1 + 48, a2, 1, *(unsigned __int8 *)(a3 + 1) + 1);
  }
  result = sub_1B67C9094(a2, 1);
  *v6 = (_DWORD)result != 0;
  if ((_DWORD)result)
  {
    *(_BYTE *)(a1 + 81) = sub_1B67C9094(a2, 1) != 0;
    *(_BYTE *)(a1 + 82) = sub_1B67C9094(a2, 1) != 0;
    *(_BYTE *)(a1 + 83) = sub_1B67C9094(a2, 1) != 0;
    *(_DWORD *)(a1 + 84) = sub_1B67C9140(a2);
    *(_DWORD *)(a1 + 88) = sub_1B67C9140(a2);
    *(_DWORD *)(a1 + 92) = sub_1B67C9140(a2);
    *(_DWORD *)(a1 + 96) = sub_1B67C9140(a2);
    result = sub_1B67C9140(a2);
    *(_DWORD *)(a1 + 100) = result;
  }
  return result;
}

uint64_t sub_1B67CED40(uint64_t a1, uint64_t a2, char a3)
{
  int v3;
  __int16 *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t result;
  _WORD *v16;

  v3 = 1 << (a3 - 1);
  v4 = (__int16 *)(a2 + 4);
  v5 = a1 + 16;
  v6 = -8;
  do
  {
    v7 = *(v4 - 2);
    v8 = v4[1];
    v9 = v8 + v7;
    v10 = v7 - v8;
    v11 = *(v4 - 1);
    v12 = *v4;
    v13 = v12 + v11;
    v14 = v11 - v12;
    result = ((v3 + ((v13 + v9) << 6)) >> a3);
    v16 = (_WORD *)(v5 + v6);
    *(v16 - 4) = result;
    v16[4] = (v3 + ((v9 - v13) << 6)) >> a3;
    *v16 = (v3 + 83 * v10 + 36 * v14) >> a3;
    v16[8] = (v3 + 36 * v10 - 83 * v14) >> a3;
    v4 += 4;
    v6 += 2;
  }
  while (v6);
  return result;
}

int32x4_t sub_1B67CEDD8(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v3;
  int v4;
  _WORD *v5;
  int16x4_t v6;
  int16x4_t v7;
  int32x4_t v8;
  int32x4_t result;

  v3 = 0;
  v4 = 1 << (a3 - 1);
  v5 = (_WORD *)(a1 + 64);
  do
  {
    v6 = *(int16x4_t *)(a2 + v3);
    v7 = vrev64_s16(*(int16x4_t *)(a2 + v3 + 8));
    v8 = vaddl_s16(v7, v6);
    result = vsubl_s16(v6, v7);
    *(v5 - 32) = (v4 + ((v8.i32[2] + v8.i32[1] + v8.i32[3] + v8.i32[0]) << 6)) >> a3;
    *v5 = (v4 + ((v8.i32[3] + v8.i32[0] - (v8.i32[2] + v8.i32[1])) << 6)) >> a3;
    *(v5 - 16) = (v4 + 83 * (v8.i32[0] - v8.i32[3]) + 36 * (v8.i32[1] - v8.i32[2])) >> a3;
    v5[16] = (v4 + 36 * (v8.i32[0] - v8.i32[3]) - 83 * (v8.i32[1] - v8.i32[2])) >> a3;
    *(v5 - 24) = (v4 + 89 * result.i32[0] + 75 * result.i32[1] + 50 * result.i32[2] + 18 * result.i32[3]) >> a3;
    v5[8] = (v4 + 50 * result.i32[0] - 89 * result.i32[1] + 18 * result.i32[2] + 75 * result.i32[3]) >> a3;
    *(v5 - 8) = (v4 + 75 * result.i32[0] - 18 * result.i32[1] - 89 * result.i32[2] - 50 * result.i32[3]) >> a3;
    v5[24] = (v4 + 18 * result.i32[0] - 50 * result.i32[1] + 75 * result.i32[2] - 89 * result.i32[3]) >> a3;
    v3 += 16;
    ++v5;
  }
  while (v3 != 128);
  return result;
}

uint64_t sub_1B67CEF1C(uint64_t result, uint64_t a2, char a3)
{
  uint64_t v3;
  int v4;
  _WORD *v5;
  _WORD *v6;
  int16x8_t v7;
  int8x16_t v8;
  int16x8_t v9;
  int32x4_t v10;
  int8x16_t v11;
  int32x4_t v12;
  int32x4_t v13;
  int32x4_t v14;
  _WORD *v15;
  unint64_t v16;
  int *v17;
  _WORD *v18;
  int v19;
  int32x4_t v20;
  int32x4_t v21;
  unint64_t v22;
  uint64_t *v23;
  _WORD *v24;
  int8x8_t v25;
  int16x8_t v26;

  v3 = 0;
  v4 = 1 << (a3 - 1);
  v5 = (_WORD *)(result + 64);
  v6 = (_WORD *)(result + 32);
  do
  {
    v7 = *(int16x8_t *)(a2 + 32 * v3);
    v8 = (int8x16_t)vrev64q_s16(*(int16x8_t *)(a2 - 14 + 32 * v3 + 30));
    v9 = (int16x8_t)vextq_s8(v8, v8, 8uLL);
    v10 = vaddl_s16(*(int16x4_t *)v9.i8, *(int16x4_t *)v7.i8);
    v11 = (int8x16_t)vrev64q_s32(vaddl_high_s16(v9, v7));
    v12 = (int32x4_t)vextq_s8(v11, v11, 8uLL);
    v13 = vaddq_s32(v12, v10);
    v14 = vsubq_s32(v10, v12);
    v15 = (_WORD *)(result + 2 * v3);
    *v15 = (v4 + ((v13.i32[2] + v13.i32[1] + v13.i32[3] + v13.i32[0]) << 6)) >> a3;
    v15[128] = (v4 + ((v13.i32[3] + v13.i32[0] - (v13.i32[2] + v13.i32[1])) << 6)) >> a3;
    v15[64] = (v4 + 83 * (v13.i32[0] - v13.i32[3]) + 36 * (v13.i32[1] - v13.i32[2])) >> a3;
    v15[192] = (v4 + 36 * (v13.i32[0] - v13.i32[3]) - 83 * (v13.i32[1] - v13.i32[2])) >> a3;
    v16 = -2;
    v17 = &dword_1B692071D;
    v18 = v5;
    do
    {
      v19 = *v17;
      v17 += 16;
      v12.i32[0] = v19;
      v12 = vmulq_s32(v14, vmovl_s16((int16x4_t)*(_OWORD *)&vmovl_s8(*(int8x8_t *)v12.i8)));
      *v18 = (vaddvq_s32(v12) + v4) >> a3;
      v18 += 64;
      v16 += 4;
    }
    while (v16 < 0xC);
    v20 = vsubl_high_s16(v7, v9);
    v21 = vsubl_s16(*(int16x4_t *)v7.i8, *(int16x4_t *)v9.i8);
    v22 = -1;
    v23 = &qword_1B692070D;
    v24 = v6;
    do
    {
      v25 = (int8x8_t)*v23;
      v23 += 4;
      v26 = vmovl_s8(v25);
      *v24 = (vaddvq_s32(vmlaq_s32(vmulq_s32(v20, vmovl_high_s16(v26)), v21, vmovl_s16(*(int16x4_t *)v26.i8))) + v4) >> a3;
      v24 += 32;
      v22 += 2;
    }
    while (v22 < 0xE);
    ++v3;
    ++v5;
    ++v6;
  }
  while (v3 != 16);
  return result;
}

_WORD *sub_1B67CF090(_WORD *result, int16x8_t *a2, char a3)
{
  uint64_t v3;
  int v4;
  int16x8_t *v5;
  _WORD *v6;
  _WORD *v7;
  _WORD *v8;
  uint64_t v9;
  int16x8_t *v10;
  int16x8_t *v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int8x16_t v15;
  int16x8_t v16;
  int32x4_t *v17;
  int32x4_t *v18;
  uint64_t v19;
  uint64_t i;
  int32x4_t v21;
  int8x16_t v22;
  int32x4_t v23;
  int8x16_t v24;
  int32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  _WORD *v28;
  unint64_t v29;
  int *v30;
  _WORD *v31;
  int32x4_t v32;
  int32x4_t v33;
  unint64_t v34;
  uint64_t *v35;
  _WORD *v36;
  int8x8_t v37;
  int16x8_t v38;
  int32x4_t v39;
  int32x4_t v40;
  unint64_t v41;
  __int128 *v42;
  _WORD *v43;
  int32x4_t v44;
  int32x4_t v45;
  int8x16_t v46;
  int16x8_t v47;
  int16x8_t v48;
  int32x4_t v49;
  int32x4_t v50;
  int32x4_t v51;
  int32x4_t v52;
  int32x4_t v53;
  int32x4_t v54;
  int32x4_t v55;
  int32x4_t v56;
  _OWORD v57[4];
  uint64_t v58;

  v3 = 0;
  v58 = *MEMORY[0x1E0C80C00];
  memset(v57, 0, sizeof(v57));
  v4 = 1 << (a3 - 1);
  v5 = a2 + 3;
  v55 = 0u;
  v56 = 0u;
  v6 = result + 128;
  v7 = result + 64;
  v8 = result + 32;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  do
  {
    v9 = 0;
    v10 = a2;
    v11 = v5;
    do
    {
      v12 = *v10++;
      v13 = v12;
      v14 = *v11--;
      v15 = (int8x16_t)vrev64q_s16(v14);
      v16 = (int16x8_t)vextq_s8(v15, v15, 8uLL);
      v17 = (int32x4_t *)&v57[v9];
      *v17 = vaddl_s16(*(int16x4_t *)v16.i8, *(int16x4_t *)v13.i8);
      v17[1] = vaddl_high_s16(v16, v13);
      v18 = (int32x4_t *)((char *)&v53 + v9 * 16);
      *v18 = vsubl_s16(*(int16x4_t *)v13.i8, *(int16x4_t *)v16.i8);
      v18[1] = vsubl_high_s16(v13, v16);
      v9 += 2;
    }
    while (v9 != 4);
    v19 = 0;
    for (i = 3; i != 1; --i)
    {
      v21 = (int32x4_t)v57[v19];
      v22 = (int8x16_t)vrev64q_s32((int32x4_t)v57[i]);
      v23 = (int32x4_t)vextq_s8(v22, v22, 8uLL);
      *(int32x4_t *)((char *)&v51 + v19 * 16) = vaddq_s32(v23, v21);
      *(int32x4_t *)((char *)&v49 + v19 * 16) = vsubq_s32(v21, v23);
      ++v19;
    }
    v24 = (int8x16_t)vrev64q_s32(v52);
    v25 = (int32x4_t)vextq_s8(v24, v24, 8uLL);
    v26 = vaddq_s32(v25, v51);
    v27 = vsubq_s32(v51, v25);
    v28 = &result[v3];
    *v28 = (v4 + ((v26.i32[2] + v26.i32[1] + v26.i32[3] + v26.i32[0]) << 6)) >> a3;
    v28[512] = (v4 + ((v26.i32[3] + v26.i32[0] - (v26.i32[2] + v26.i32[1])) << 6)) >> a3;
    v28[256] = (v4 + 83 * (v26.i32[0] - v26.i32[3]) + 36 * (v26.i32[1] - v26.i32[2])) >> a3;
    v28[768] = (v4 + 36 * (v26.i32[0] - v26.i32[3]) - 83 * (v26.i32[1] - v26.i32[2])) >> a3;
    v29 = -4;
    v30 = &dword_1B692087D;
    v31 = v6;
    do
    {
      v25.i32[0] = *v30;
      v25 = vmulq_s32(v27, vmovl_s16((int16x4_t)*(_OWORD *)&vmovl_s8(*(int8x8_t *)v25.i8)));
      *v31 = (vaddvq_s32(v25) + v4) >> a3;
      v29 += 8;
      v31 += 256;
      v30 += 64;
    }
    while (v29 < 0x18);
    v33 = v49;
    v32 = v50;
    v34 = -2;
    v35 = &qword_1B692083D;
    v36 = v7;
    do
    {
      v37 = (int8x8_t)*v35;
      v35 += 16;
      v38 = vmovl_s8(v37);
      *v36 = (vaddvq_s32(vmlaq_s32(vmulq_s32(v32, vmovl_high_s16(v38)), v33, vmovl_s16(*(int16x4_t *)v38.i8))) + v4) >> a3;
      v34 += 4;
      v36 += 128;
    }
    while (v34 < 0x1C);
    v40 = v55;
    v39 = v56;
    v41 = -1;
    v42 = &xmmword_1B692081D;
    v43 = v8;
    v45 = v53;
    v44 = v54;
    do
    {
      v46 = (int8x16_t)*v42;
      v42 += 4;
      v47 = vmovl_s8(*(int8x8_t *)v46.i8);
      v48 = vmovl_high_s8(v46);
      *v43 = (vaddvq_s32(vaddq_s32(vmlaq_s32(vmulq_s32(v40, vmovl_s16(*(int16x4_t *)v48.i8)), v45, vmovl_s16(*(int16x4_t *)v47.i8)), vmlaq_s32(vmulq_s32(v39, vmovl_high_s16(v48)), v44, vmovl_high_s16(v47))))+ v4) >> a3;
      v43 += 64;
      v41 += 2;
    }
    while (v41 < 0x1E);
    ++v3;
    v5 += 4;
    a2 += 4;
    ++v6;
    ++v7;
    ++v8;
  }
  while (v3 != 32);
  return result;
}

uint64_t sub_1B67CF370(uint64_t a1, int a2)
{
  uint64_t v2;

  *(_DWORD *)a1 = a2;
  *(_BYTE *)(a1 + 4) = 20 - a2;
  switch(a2)
  {
    case 10:
      *(_QWORD *)(a1 + 48) = sub_1B67CF4F4;
      *(_QWORD *)(a1 + 56) = sub_1B67CF5AC;
      *(_QWORD *)(a1 + 64) = sub_1B67CF664;
      *(_QWORD *)(a1 + 72) = sub_1B67CF71C;
      *(_QWORD *)(a1 + 80) = sub_1B67CF7D4;
      *(_QWORD *)(a1 + 88) = sub_1B67CF88C;
      *(_QWORD *)(a1 + 96) = sub_1B67CF8FC;
      *(_QWORD *)(a1 + 104) = sub_1B67CF96C;
      *(_QWORD *)(a1 + 208) = sub_1B67CF9DC;
      *(_QWORD *)(a1 + 216) = sub_1B67CFA24;
      *(_QWORD *)(a1 + 224) = sub_1B67CFA6C;
      *(_QWORD *)(a1 + 232) = sub_1B67CFAB4;
      *(_QWORD *)(a1 + 240) = sub_1B67CFAFC;
      *(_QWORD *)(a1 + 248) = sub_1B67CFB68;
      *(_QWORD *)(a1 + 256) = sub_1B67CFBD4;
LABEL_6:
      sub_1B688320C((_QWORD *)a1, a2);
      return 0;
    case 9:
      v2 = 0;
      *(_QWORD *)(a1 + 48) = sub_1B67CFD48;
      *(_QWORD *)(a1 + 56) = sub_1B67CFE00;
      *(_QWORD *)(a1 + 64) = sub_1B67CFEB8;
      *(_QWORD *)(a1 + 72) = sub_1B67CFF70;
      *(_QWORD *)(a1 + 80) = sub_1B67D0028;
      *(_QWORD *)(a1 + 88) = sub_1B67D00E0;
      *(_QWORD *)(a1 + 96) = sub_1B67D0150;
      *(_QWORD *)(a1 + 104) = sub_1B67D01C0;
      *(_QWORD *)(a1 + 208) = sub_1B67CF9DC;
      *(_QWORD *)(a1 + 216) = sub_1B67CFA24;
      *(_QWORD *)(a1 + 224) = sub_1B67CFA6C;
      *(_QWORD *)(a1 + 232) = sub_1B67CFAB4;
      *(_QWORD *)(a1 + 240) = sub_1B67CFAFC;
      *(_QWORD *)(a1 + 248) = sub_1B67CFB68;
      *(_QWORD *)(a1 + 256) = sub_1B67CFBD4;
      return v2;
    case 8:
      goto LABEL_6;
  }
  return 4294954386;
}

uint64_t sub_1B67CF4F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  _QWORD v10[6];

  v6 = 0;
  v10[5] = *MEMORY[0x1E0C80C00];
  v7 = a5;
  do
  {
    for (i = 0; i != 8; i += 2)
      *(_WORD *)(v7 + i) = *(_WORD *)(a1 + i) - *(_WORD *)(a3 + i);
    ++v6;
    v7 += 8;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 4);
  sub_1B67CFC40((uint64_t)v10, a5, 3);
  return sub_1B67CFC40(a5, (uint64_t)v10, 8);
}

uint64_t sub_1B67CF5AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  _QWORD v10[6];

  v6 = 0;
  v10[5] = *MEMORY[0x1E0C80C00];
  v7 = a5;
  do
  {
    for (i = 0; i != 8; i += 2)
      *(_WORD *)(v7 + i) = *(_WORD *)(a1 + i) - *(_WORD *)(a3 + i);
    ++v6;
    v7 += 8;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 4);
  sub_1B67CED40((uint64_t)v10, a5, 3);
  return sub_1B67CED40(a5, (uint64_t)v10, 8);
}

double sub_1B67CF664(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  double result;
  _QWORD v10[18];

  v6 = 0;
  v10[17] = *MEMORY[0x1E0C80C00];
  v7 = a5;
  do
  {
    for (i = 0; i != 16; i += 2)
      *(_WORD *)(v7 + i) = *(_WORD *)(a1 + i) - *(_WORD *)(a3 + i);
    ++v6;
    v7 += 16;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 8);
  sub_1B67CEDD8((uint64_t)v10, a5, 4);
  *(_QWORD *)&result = sub_1B67CEDD8(a5, (uint64_t)v10, 9).u64[0];
  return result;
}

uint64_t sub_1B67CF71C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  _QWORD v10[66];

  v6 = 0;
  v10[65] = *MEMORY[0x1E0C80C00];
  v7 = a5;
  do
  {
    for (i = 0; i != 32; i += 2)
      *(_WORD *)(v7 + i) = *(_WORD *)(a1 + i) - *(_WORD *)(a3 + i);
    ++v6;
    v7 += 32;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 16);
  sub_1B67CEF1C((uint64_t)v10, a5, 5);
  return sub_1B67CEF1C(a5, (uint64_t)v10, 10);
}

_WORD *sub_1B67CF7D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int16x8_t *a5)
{
  uint64_t v6;
  int16x8_t *v7;
  uint64_t i;
  int16x8_t v10[128];
  uint64_t v11;

  v6 = 0;
  v11 = *MEMORY[0x1E0C80C00];
  v7 = a5;
  do
  {
    for (i = 0; i != 32; ++i)
      v7->i16[i] = *(_WORD *)(a1 + i * 2) - *(_WORD *)(a3 + i * 2);
    ++v6;
    v7 += 4;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 32);
  sub_1B67CF090(v10, a5, 6);
  return sub_1B67CF090(a5, v10, 11);
}

uint64_t sub_1B67CF88C(uint64_t a1)
{
  _QWORD v3[6];

  v3[5] = *MEMORY[0x1E0C80C00];
  sub_1B67CED40((uint64_t)v3, a1, 3);
  return sub_1B67CED40(a1, (uint64_t)v3, 8);
}

double sub_1B67CF8FC(uint64_t a1)
{
  double result;
  _QWORD v3[18];

  v3[17] = *MEMORY[0x1E0C80C00];
  sub_1B67CEDD8((uint64_t)v3, a1, 4);
  *(_QWORD *)&result = sub_1B67CEDD8(a1, (uint64_t)v3, 9).u64[0];
  return result;
}

uint64_t sub_1B67CF96C(uint64_t a1)
{
  _QWORD v3[66];

  v3[65] = *MEMORY[0x1E0C80C00];
  sub_1B67CEF1C((uint64_t)v3, a1, 5);
  return sub_1B67CEF1C(a1, (uint64_t)v3, 10);
}

uint64_t sub_1B67CF9DC(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t i;

  v5 = 0;
  do
  {
    for (i = 0; i != 8; i += 2)
      *(_WORD *)(a5 + i) = *(_WORD *)(result + i) - *(_WORD *)(a3 + i);
    ++v5;
    a5 += 8;
    a3 += 2 * a4;
    result += 2 * a2;
  }
  while (v5 != 4);
  return result;
}

uint64_t sub_1B67CFA24(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t i;

  v5 = 0;
  do
  {
    for (i = 0; i != 16; i += 2)
      *(_WORD *)(a5 + i) = *(_WORD *)(result + i) - *(_WORD *)(a3 + i);
    ++v5;
    a5 += 16;
    a3 += 2 * a4;
    result += 2 * a2;
  }
  while (v5 != 8);
  return result;
}

uint64_t sub_1B67CFA6C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t i;

  v5 = 0;
  do
  {
    for (i = 0; i != 32; i += 2)
      *(_WORD *)(a5 + i) = *(_WORD *)(result + i) - *(_WORD *)(a3 + i);
    ++v5;
    a5 += 32;
    a3 += 2 * a4;
    result += 2 * a2;
  }
  while (v5 != 16);
  return result;
}

uint64_t sub_1B67CFAB4(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t i;

  v5 = 0;
  do
  {
    for (i = 0; i != 64; i += 2)
      *(_WORD *)(a5 + i) = *(_WORD *)(result + i) - *(_WORD *)(a3 + i);
    ++v5;
    a5 += 64;
    a3 += 2 * a4;
    result += 2 * a2;
  }
  while (v5 != 32);
  return result;
}

uint64_t sub_1B67CFAFC(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  __int16 *v7;
  __int16 *v8;
  uint64_t v9;
  __int16 *v10;
  __int16 *v11;
  __int16 v12;
  __int16 v13;
  __int16 v14;

  v6 = 0;
  v7 = (__int16 *)(result + 2);
  v8 = (__int16 *)(a3 + 2);
  do
  {
    v9 = 0;
    v10 = v8;
    v11 = v7;
    do
    {
      *(_WORD *)(a5 + v9) = *(v11 - 1) - *(v10 - 1);
      v13 = *v11;
      v11 += 2;
      v12 = v13;
      v14 = *v10;
      v10 += 2;
      *(_WORD *)(a6 + v9) = v12 - v14;
      v9 += 2;
    }
    while (v9 != 8);
    ++v6;
    a6 += 8;
    a5 += 8;
    v7 += a2;
    v8 += a4;
  }
  while (v6 != 4);
  return result;
}

uint64_t sub_1B67CFB68(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  __int16 *v7;
  __int16 *v8;
  uint64_t v9;
  __int16 *v10;
  __int16 *v11;
  __int16 v12;
  __int16 v13;
  __int16 v14;

  v6 = 0;
  v7 = (__int16 *)(result + 2);
  v8 = (__int16 *)(a3 + 2);
  do
  {
    v9 = 0;
    v10 = v8;
    v11 = v7;
    do
    {
      *(_WORD *)(a5 + v9) = *(v11 - 1) - *(v10 - 1);
      v13 = *v11;
      v11 += 2;
      v12 = v13;
      v14 = *v10;
      v10 += 2;
      *(_WORD *)(a6 + v9) = v12 - v14;
      v9 += 2;
    }
    while (v9 != 16);
    ++v6;
    a6 += 16;
    a5 += 16;
    v7 += a2;
    v8 += a4;
  }
  while (v6 != 8);
  return result;
}

uint64_t sub_1B67CFBD4(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  __int16 *v7;
  __int16 *v8;
  uint64_t v9;
  __int16 *v10;
  __int16 *v11;
  __int16 v12;
  __int16 v13;
  __int16 v14;

  v6 = 0;
  v7 = (__int16 *)(result + 2);
  v8 = (__int16 *)(a3 + 2);
  do
  {
    v9 = 0;
    v10 = v8;
    v11 = v7;
    do
    {
      *(_WORD *)(a5 + v9) = *(v11 - 1) - *(v10 - 1);
      v13 = *v11;
      v11 += 2;
      v12 = v13;
      v14 = *v10;
      v10 += 2;
      *(_WORD *)(a6 + v9) = v12 - v14;
      v9 += 2;
    }
    while (v9 != 32);
    ++v6;
    a6 += 32;
    a5 += 32;
    v7 += a2;
    v8 += a4;
  }
  while (v6 != 16);
  return result;
}

uint64_t sub_1B67CFC40(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v3;
  int v4;
  __int16 *v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  _WORD *v15;
  int v16;
  int v17;
  uint64_t result;

  v3 = 0;
  v4 = 1 << (a3 - 1);
  v5 = (__int16 *)(a2 + 4);
  v6 = a1 + 8;
  do
  {
    v7 = *(v5 - 2);
    v8 = v5[1];
    v9 = v8 + v7;
    v10 = *(v5 - 1);
    v11 = v10 + v8;
    v12 = v7 - v10;
    v13 = 74 * *v5;
    v14 = (v13 + v4 + 29 * v9 + 55 * v11) >> a3;
    if (v14 >= 0x7FFF)
      v14 = 0x7FFF;
    if (v14 <= -32768)
      LOWORD(v14) = 0x8000;
    v15 = (_WORD *)(v6 + v3);
    *(_WORD *)(v6 + v3 - 8) = v14;
    v16 = (v4 + 74 * (*(v5 - 1) + *(v5 - 2) - v5[1])) >> a3;
    if (v16 >= 0x7FFF)
      v16 = 0x7FFF;
    if (v16 <= -32768)
      LOWORD(v16) = 0x8000;
    *v15 = v16;
    v17 = (v4 + 55 * v9 + 29 * v12 - v13) >> a3;
    if (v17 >= 0x7FFF)
      v17 = 0x7FFF;
    if (v17 <= -32768)
      LOWORD(v17) = 0x8000;
    v15[4] = v17;
    LODWORD(result) = (v13 + v4 + 55 * v12 - 29 * v11) >> a3;
    if ((int)result >= 0x7FFF)
      LODWORD(result) = 0x7FFF;
    if ((int)result <= -32768)
      result = 4294934528;
    else
      result = result;
    v15[8] = result;
    v3 += 2;
    v5 += 4;
  }
  while (v3 != 8);
  return result;
}

uint64_t sub_1B67CFD48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  _QWORD v10[6];

  v6 = 0;
  v10[5] = *MEMORY[0x1E0C80C00];
  v7 = a5;
  do
  {
    for (i = 0; i != 8; i += 2)
      *(_WORD *)(v7 + i) = *(_WORD *)(a1 + i) - *(_WORD *)(a3 + i);
    ++v6;
    v7 += 8;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 4);
  sub_1B67CFC40((uint64_t)v10, a5, 2);
  return sub_1B67CFC40(a5, (uint64_t)v10, 8);
}

uint64_t sub_1B67CFE00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  _QWORD v10[6];

  v6 = 0;
  v10[5] = *MEMORY[0x1E0C80C00];
  v7 = a5;
  do
  {
    for (i = 0; i != 8; i += 2)
      *(_WORD *)(v7 + i) = *(_WORD *)(a1 + i) - *(_WORD *)(a3 + i);
    ++v6;
    v7 += 8;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 4);
  sub_1B67CED40((uint64_t)v10, a5, 2);
  return sub_1B67CED40(a5, (uint64_t)v10, 8);
}

double sub_1B67CFEB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  double result;
  _QWORD v10[18];

  v6 = 0;
  v10[17] = *MEMORY[0x1E0C80C00];
  v7 = a5;
  do
  {
    for (i = 0; i != 16; i += 2)
      *(_WORD *)(v7 + i) = *(_WORD *)(a1 + i) - *(_WORD *)(a3 + i);
    ++v6;
    v7 += 16;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 8);
  sub_1B67CEDD8((uint64_t)v10, a5, 3);
  *(_QWORD *)&result = sub_1B67CEDD8(a5, (uint64_t)v10, 9).u64[0];
  return result;
}

uint64_t sub_1B67CFF70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  _QWORD v10[66];

  v6 = 0;
  v10[65] = *MEMORY[0x1E0C80C00];
  v7 = a5;
  do
  {
    for (i = 0; i != 32; i += 2)
      *(_WORD *)(v7 + i) = *(_WORD *)(a1 + i) - *(_WORD *)(a3 + i);
    ++v6;
    v7 += 32;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 16);
  sub_1B67CEF1C((uint64_t)v10, a5, 4);
  return sub_1B67CEF1C(a5, (uint64_t)v10, 10);
}

_WORD *sub_1B67D0028(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int16x8_t *a5)
{
  uint64_t v6;
  int16x8_t *v7;
  uint64_t i;
  int16x8_t v10[128];
  uint64_t v11;

  v6 = 0;
  v11 = *MEMORY[0x1E0C80C00];
  v7 = a5;
  do
  {
    for (i = 0; i != 32; ++i)
      v7->i16[i] = *(_WORD *)(a1 + i * 2) - *(_WORD *)(a3 + i * 2);
    ++v6;
    v7 += 4;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 32);
  sub_1B67CF090(v10, a5, 5);
  return sub_1B67CF090(a5, v10, 11);
}

uint64_t sub_1B67D00E0(uint64_t a1)
{
  _QWORD v3[6];

  v3[5] = *MEMORY[0x1E0C80C00];
  sub_1B67CED40((uint64_t)v3, a1, 2);
  return sub_1B67CED40(a1, (uint64_t)v3, 8);
}

double sub_1B67D0150(uint64_t a1)
{
  double result;
  _QWORD v3[18];

  v3[17] = *MEMORY[0x1E0C80C00];
  sub_1B67CEDD8((uint64_t)v3, a1, 3);
  *(_QWORD *)&result = sub_1B67CEDD8(a1, (uint64_t)v3, 9).u64[0];
  return result;
}

uint64_t sub_1B67D01C0(uint64_t a1)
{
  _QWORD v3[66];

  v3[65] = *MEMORY[0x1E0C80C00];
  sub_1B67CEF1C((uint64_t)v3, a1, 4);
  return sub_1B67CEF1C(a1, (uint64_t)v3, 10);
}

uint64_t sub_1B67D0230(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, char a9)
{
  uint64_t (*v12)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  if (a9)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a7 + 192))(a2, a3, a4, a5, a6);
    return (*(uint64_t (**)(uint64_t))(a1 + 136))(a6);
  }
  else
  {
    if (a8 == 1)
      v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 48);
    else
      v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a7 + 40);
    return v12(a2, a3, a4, a5, a6);
  }
}

uint64_t sub_1B67D02B8(_QWORD *a1, int a2, int a3, int a4)
{
  uint64_t result;
  void *v6;
  void *v7;
  unsigned __int16 *(*v8)(unsigned __int16 *, uint64_t);
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  switch(a2)
  {
    case 8:
      result = 0;
      v9 = sub_1B67D0D14;
      if (a4)
        v9 = sub_1B67D0990;
      v10 = sub_1B67D1174;
      if (a4)
        v10 = sub_1B67D0EE0;
      *a1 = v9;
      a1[1] = v10;
      a1[50] = sub_1B67D1388;
      a1[51] = sub_1B67D1420;
      a1[2] = sub_1B67F778C;
      a1[3] = sub_1B67F7824;
      v11 = sub_1B67F79CC;
      if (a3)
        v11 = sub_1B67F790C;
      a1[4] = v11;
      a1[5] = sub_1B67F7B64;
      a1[6] = sub_1B67F7C10;
      a1[7] = sub_1B67F7D6C;
      a1[8] = sub_1B67F8180;
      a1[9] = sub_1B67F859C;
      a1[10] = sub_1B67F8D78;
      a1[11] = sub_1B67F8DC0;
      a1[12] = sub_1B67F8E98;
      a1[13] = sub_1B67F9000;
      a1[14] = sub_1B67F9020;
      a1[15] = sub_1B67F9048;
      a1[16] = sub_1B67F9094;
      a1[17] = sub_1B67F9110;
      a1[18] = sub_1B67F9200;
      a1[19] = sub_1B67F92C8;
      a1[20] = sub_1B67F93BC;
      a1[21] = sub_1B67F9424;
      a1[22] = sub_1B67F94E0;
      a1[23] = sub_1B67F9674;
      a1[24] = sub_1B67F96D0;
      a1[25] = sub_1B67F9758;
      a1[26] = sub_1B67F99EC;
      a1[27] = sub_1B67F9AA0;
      a1[28] = sub_1B67F9E34;
      a1[29] = sub_1B67FA2A4;
      a1[30] = sub_1B67FA978;
      a1[31] = sub_1B67FAA30;
      a1[32] = sub_1B67FAC34;
      a1[33] = sub_1B67FAED0;
      a1[34] = sub_1B67FB37C;
      a1[35] = sub_1B67FB39C;
      a1[36] = sub_1B67FB3B8;
      a1[37] = sub_1B67FB3D8;
      a1[38] = sub_1B67FB400;
      a1[39] = sub_1B67FB430;
      a1[40] = sub_1B67FB490;
      a1[41] = sub_1B67FB55C;
      a1[42] = sub_1B67FB648;
      a1[43] = sub_1B67FB68C;
      a1[44] = sub_1B67FB6D4;
      a1[45] = sub_1B67FB740;
      a1[46] = sub_1B67FB7E0;
      a1[47] = sub_1B67FB890;
      a1[48] = sub_1B67FBBBC;
      a1[49] = sub_1B67FBF9C;
      break;
    case 10:
      result = 0;
      v12 = sub_1B67D1828;
      if (a4)
        v12 = sub_1B67D150C;
      v13 = sub_1B67D1CD0;
      if (a4)
        v13 = sub_1B67D1A40;
      *a1 = v12;
      a1[1] = v13;
      a1[50] = sub_1B67D469C;
      a1[51] = sub_1B67D4734;
      a1[2] = sub_1B67FC620;
      a1[3] = sub_1B67FC6A8;
      v14 = sub_1B67FC820;
      a1[20] = sub_1B67FC8E4;
      a1[21] = sub_1B67FC95C;
      a1[22] = sub_1B67FCA38;
      a1[23] = sub_1B67FCB9C;
      if (a3)
        v14 = sub_1B67FC76C;
      a1[4] = v14;
      a1[5] = sub_1B67FCC98;
      a1[6] = sub_1B67FCD30;
      a1[7] = sub_1B67FCDC8;
      a1[8] = sub_1B67FCE68;
      a1[9] = sub_1B67D2260;
      a1[24] = sub_1B67FCBFC;
      a1[25] = sub_1B67FCF68;
      a1[26] = sub_1B67FD0F4;
      a1[27] = sub_1B67FD36C;
      a1[28] = sub_1B67FD690;
      a1[29] = sub_1B67FDA64;
      a1[10] = sub_1B67FDE68;
      a1[11] = sub_1B67FDED0;
      a1[12] = sub_1B67FDFA4;
      a1[13] = sub_1B67FE054;
      a1[14] = sub_1B67FE080;
      a1[15] = sub_1B67FE0BC;
      a1[16] = sub_1B67FE118;
      a1[17] = sub_1B67FE1B0;
      a1[18] = sub_1B67FE230;
      a1[19] = sub_1B67FE260;
      a1[42] = sub_1B67FE298;
      a1[43] = sub_1B67FE2D4;
      a1[44] = sub_1B67FE320;
      a1[45] = sub_1B67FE37C;
      a1[30] = sub_1B67FE408;
      a1[31] = sub_1B67FE4B8;
      a1[32] = sub_1B67FE558;
      a1[33] = sub_1B67FE658;
      a1[46] = sub_1B67FE760;
      a1[47] = sub_1B67FE968;
      a1[48] = sub_1B67FEC6C;
      a1[49] = sub_1B67FEFB8;
      a1[34] = sub_1B67FF32C;
      a1[35] = sub_1B67FF354;
      a1[36] = sub_1B67FF384;
      a1[37] = sub_1B67FF3B0;
      a1[38] = sub_1B67FF3EC;
      a1[39] = sub_1B67FF42C;
      a1[40] = sub_1B67FF46C;
      a1[41] = sub_1B67FF49C;
      break;
    case 9:
      result = 0;
      v6 = sub_1B67D4B3C;
      if (a4)
        v6 = sub_1B67D4820;
      v7 = sub_1B67D4FE4;
      if (a4)
        v7 = sub_1B67D4D54;
      *a1 = v6;
      a1[1] = v7;
      a1[2] = sub_1B67D1EE4;
      a1[3] = sub_1B67D1F78;
      v8 = sub_1B67D200C;
      if (a3)
        v8 = sub_1B67D51F8;
      a1[4] = v8;
      a1[5] = sub_1B67D20A0;
      a1[6] = sub_1B67D2110;
      a1[7] = sub_1B67D2180;
      a1[8] = sub_1B67D21F0;
      a1[9] = sub_1B67D2260;
      a1[10] = sub_1B67D5330;
      a1[11] = sub_1B67D5390;
      a1[12] = sub_1B67D53F0;
      a1[13] = sub_1B67D5450;
      a1[14] = sub_1B67D547C;
      a1[15] = sub_1B67D54B8;
      a1[16] = sub_1B67D5524;
      a1[17] = sub_1B67D5590;
      a1[18] = sub_1B67D5600;
      a1[19] = sub_1B67D5638;
      a1[20] = sub_1B67D22D0;
      a1[21] = sub_1B67D2378;
      a1[22] = sub_1B67D2428;
      a1[23] = sub_1B67D24F4;
      a1[24] = sub_1B67D2570;
      a1[25] = sub_1B67D25EC;
      a1[26] = sub_1B67D2880;
      a1[27] = sub_1B67D2B24;
      a1[28] = sub_1B67D2DF8;
      a1[29] = sub_1B67D3124;
      a1[30] = sub_1B67D346C;
      a1[31] = sub_1B67D3514;
      a1[32] = sub_1B67D35BC;
      a1[33] = sub_1B67D3664;
      a1[34] = sub_1B67D370C;
      a1[35] = sub_1B67D3730;
      a1[36] = sub_1B67D3754;
      a1[37] = sub_1B67D3780;
      a1[38] = sub_1B67D37BC;
      a1[39] = sub_1B67D37E8;
      a1[40] = sub_1B67D3818;
      a1[41] = sub_1B67D3854;
      a1[42] = sub_1B67D3890;
      a1[43] = sub_1B67D38F4;
      a1[44] = sub_1B67D3968;
      a1[45] = sub_1B67D3A1C;
      a1[46] = sub_1B67D3AE4;
      a1[47] = sub_1B67D3D94;
      a1[48] = sub_1B67D4070;
      a1[49] = sub_1B67D4378;
      a1[50] = sub_1B67D5670;
      a1[51] = sub_1B67D5708;
      break;
    default:
      return 4294954386;
  }
  return result;
}

void *sub_1B67D0990(void *result, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int8 *v25;
  _BYTE *v26;
  uint64_t v27;
  uint64_t v28;
  _BYTE *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned __int8 *v33;
  _BYTE *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE *v40;
  unsigned __int8 *v41;
  unsigned __int8 *v42;
  _BYTE *v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  _BYTE *v47;
  unsigned __int8 *v48;
  unsigned __int8 *v49;
  _BYTE *v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  int v54;
  int v55;
  char v56;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v63;

  if (!a2)
    return memset((void *)(a5 - 1), 128, (4 << (char)result) | 1);
  v6 = 1 << (char)result;
  v7 = (1 << (char)result) + 4;
  if (1 << (char)result >= 8)
    v8 = 8;
  else
    v8 = v6;
  v9 = __clz(__rbit32(a2));
  if (v9 < 9)
    v10 = ((2 << (char)result) + (char)~byte_1B6920BFD[9 * (int)result - 18 + v9]) * a3 - 1;
  else
    v10 = byte_1B6920BFD[9 * (int)result - 27 + v9] - a3;
  v11 = v7 >> 3;
  v12 = *(unsigned __int8 *)(a4 + v10);
  v63 = (1 << (char)result);
  v55 = v8;
  v56 = (char)result;
  v54 = v7 >> 3;
  if (v6 >= 4)
  {
    v13 = 0;
    v14 = (int)v8;
    v15 = 2 << (char)result;
    if (v11 <= 1)
      v16 = 1;
    else
      v16 = v11;
    if (v6 >= 8)
      v17 = 8;
    else
      v17 = 1 << (char)result;
    v18 = (_BYTE *)(a5 + v15 - 1);
    v19 = -(uint64_t)v17;
    v20 = a4 + a3 * (v15 - 1) - 1;
    v53 = v17;
    v21 = -(a3 * v17);
    v22 = -a3;
    v59 = 2 << (char)result;
    v60 = v8 + 1;
    do
    {
      v23 = v13 + 1;
      if (((a2 >> v13) & 1) != 0)
      {
        v24 = v60;
        v25 = (unsigned __int8 *)v20;
        v26 = v18;
        do
        {
          v12 = *v25;
          *v26-- = v12;
          v25 += v22;
          --v24;
        }
        while (v24 > 1);
      }
      else
      {
        result = memset((void *)(a5 + v59 - v23 * v14), v12, v14);
      }
      v18 += v19;
      v20 += v21;
      v13 = v23;
    }
    while (v23 != v16);
    v27 = 0;
    v28 = 8;
    if (v63 < 8)
      v28 = v63;
    v29 = (_BYTE *)(a5 + v63 - 1);
    v30 = a4 + a3 * (v63 - 1) - 1;
    v61 = v28 + 1;
    do
    {
      v31 = v27 + 1;
      if (((a2 >> v27) & 0x10) != 0)
      {
        v32 = v61;
        v33 = (unsigned __int8 *)v30;
        v34 = v29;
        do
        {
          v12 = *v33;
          *v34-- = v12;
          v33 -= a3;
          --v32;
        }
        while (v32 > 1);
      }
      else
      {
        result = memset((void *)(a5 + v63 - v31 * v14), v12, v14);
      }
      v29 -= v53;
      v30 += v21;
      v27 = v31;
    }
    while (v31 != v16);
  }
  if ((a2 & 0x100) != 0)
    v12 = *(unsigned __int8 *)(a4 + ~a3);
  *(_BYTE *)(a5 - 1) = v12;
  if ((int)v63 >= 4)
  {
    v35 = 0;
    v36 = 2 << v56;
    if (v55 <= 1)
      v37 = 1;
    else
      v37 = v55;
    v38 = v36;
    if (v54 <= 1)
      v39 = 1;
    else
      v39 = v54;
    v40 = (_BYTE *)(a5 + v36);
    v41 = (unsigned __int8 *)(a4 - a3);
    do
    {
      if (((a2 >> v35) & 0x200) != 0)
      {
        v42 = v41;
        v43 = v40;
        v44 = v37;
        do
        {
          v45 = *v42++;
          v12 = v45;
          *v43++ = v45;
          --v44;
        }
        while (v44);
      }
      else
      {
        result = memset((void *)(a5 + v35 * v55 + v38), v12, v55);
      }
      ++v35;
      v40 += v55;
      v41 += v55;
    }
    while (v35 != v39);
    v46 = 0;
    v47 = (_BYTE *)(a5 + v38 + v63);
    v48 = (unsigned __int8 *)(a4 + v63 - a3);
    do
    {
      if (((a2 >> v46) & 0x2000) != 0)
      {
        v49 = v48;
        v50 = v47;
        v51 = v37;
        do
        {
          v52 = *v49++;
          v12 = v52;
          *v50++ = v52;
          --v51;
        }
        while (v51);
      }
      else
      {
        result = memset((void *)(a5 + v63 + v46 * v55 + v38), v12, v55);
      }
      ++v46;
      v47 += v55;
      v48 += v55;
    }
    while (v46 != v39);
  }
  return result;
}

void *sub_1B67D0D14(int a1, int a2, uint64_t a3, uint64_t a4, char *__b)
{
  int v10;
  uint64_t v11;
  char *v12;
  char *v13;
  size_t v14;
  char *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE *v19;
  _BYTE *v20;
  unsigned __int8 *v21;
  int v22;

  if (a2)
  {
    v10 = 1 << a1;
    if ((a2 & 0xF) != 0)
    {
      if (v10 < 2 << a1)
      {
        v11 = (2 << a1) - (uint64_t)v10;
        v12 = &__b[v10];
        v13 = (char *)(a4 + a3 * v10 - 1);
        do
        {
          *v12++ = *v13;
          v13 += a3;
          --v11;
        }
        while (v11);
      }
    }
    else
    {
      v17 = v10 - a3;
      if ((a2 & 0x1E00) != 0)
        v17 = -a3;
      if ((a2 & 0x100) != 0)
        v17 = ~a3;
      if ((a2 & 0xF0) != 0)
        v17 = (v10 - 1) * a3 - 1;
      memset(&__b[v10], *(unsigned __int8 *)(a4 + v17), v10);
    }
    if ((a2 & 0xF0) != 0)
    {
      if (a1 != 31)
      {
        if (v10 <= 1)
          v18 = 1;
        else
          v18 = v10;
        v19 = (_BYTE *)(a4 - 1);
        v20 = __b;
        do
        {
          *v20++ = *v19;
          v19 += a3;
          --v18;
        }
        while (v18);
      }
    }
    else
    {
      memset(__b, __b[v10], v10);
    }
    v21 = (unsigned __int8 *)(a4 + ~a3);
    if ((a2 & 0x100) == 0)
      v21 = (unsigned __int8 *)__b;
    v22 = *v21;
    *(__b - 1) = v22;
    if ((a2 & 0x1E00) != 0)
      memcpy(&__b[2 << a1], (const void *)(a4 - a3), v10);
    else
      memset(&__b[2 << a1], v22, v10);
    if ((a2 & 0x1E000) != 0)
      return memcpy(&__b[3 << a1], (const void *)(a4 + v10 - a3), v10);
    v14 = v10;
    v15 = &__b[3 << a1];
    v16 = *(v15 - 1);
  }
  else
  {
    v14 = (4 << a1) | 1;
    v15 = __b - 1;
    v16 = 128;
  }
  return memset(v15, v16, v14);
}

void *sub_1B67D0EE0(void *result, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int16 *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned __int16 *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t i;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t j;

  if (!a2)
    return memset((void *)(a5 - 2), 128, (8 * ((unint64_t)(4 << (char)result) >> 2)) | 2);
  v5 = (1 << (char)result);
  v6 = __clz(__rbit32(a2));
  if (v6 < 9)
    v7 = ((2 << (char)result) + (char)~byte_1B6920BFD[9 * (int)result + 18 + v6]) * a3 - 1;
  else
    v7 = byte_1B6920BFD[9 * (int)result + 9 + v6] - a3;
  LODWORD(v8) = (int)v5 >> 2;
  v9 = *(unsigned __int16 *)(a4 + 2 * v7);
  if ((int)v5 >= 4)
  {
    v10 = 0;
    v11 = 2 << (char)result;
    v12 = a5 + 2 * v11;
    if ((int)v8 <= 1)
      v13 = 1;
    else
      v13 = v8;
    v14 = a4 + 2 * a3 * (v11 - 1) - 2;
    do
    {
      v15 = v10 + 1;
      if (((a2 >> v10) & 1) != 0)
      {
        v16 = -2;
        v17 = (unsigned __int16 *)v14;
        do
        {
          v9 = *v17;
          *(_WORD *)(v12 + v16) = v9;
          v16 -= 2;
          v17 -= a3;
        }
        while (v16 != -10);
      }
      else
      {
        *(int16x4_t *)(a5 + 2 * (v11 - 4 * v15)) = vdup_n_s16(v9);
      }
      v12 -= 8;
      v14 -= 8 * a3;
      v10 = v15;
    }
    while (v15 != v13);
    v18 = 0;
    v19 = a5 + 2 * v5;
    v20 = a4 + 2 * a3 * (v5 - 1) - 2;
    do
    {
      v21 = v18 + 1;
      if (((a2 >> v18) & 0x10) != 0)
      {
        v22 = -2;
        v23 = (unsigned __int16 *)v20;
        do
        {
          v9 = *v23;
          *(_WORD *)(v19 + v22) = v9;
          v22 -= 2;
          v23 -= a3;
        }
        while (v22 != -10);
      }
      else
      {
        *(int16x4_t *)(a5 + 2 * (v5 - 4 * v21)) = vdup_n_s16(v9);
      }
      v19 -= 8;
      v20 -= 8 * a3;
      v18 = v21;
    }
    while (v21 != v13);
  }
  if ((a2 & 0x100) != 0)
    v9 = *(unsigned __int16 *)(a4 + 2 * ~a3);
  *(_WORD *)(a5 - 2) = v9;
  if ((int)v5 >= 4)
  {
    v24 = 0;
    v25 = 2 << (char)result;
    if ((int)v8 <= 1)
      v8 = 1;
    else
      v8 = v8;
    v26 = a5 + 2 * v25;
    v27 = a4 - 2 * a3;
    do
    {
      if (((a2 >> v24) & 0x200) != 0)
      {
        for (i = 0; i != 8; i += 2)
        {
          v9 = *(unsigned __int16 *)(v27 + i);
          *(_WORD *)(v26 + i) = v9;
        }
      }
      else
      {
        *(int16x4_t *)(a5 + 2 * (4 * v24 + v25)) = vdup_n_s16(v9);
      }
      ++v24;
      v26 += 8;
      v27 += 8;
    }
    while (v24 != v8);
    v29 = 0;
    v30 = a5 + 2 * (v25 + (unint64_t)v5);
    v31 = a4 - 2 * a3 + 2 * v5;
    do
    {
      if (((a2 >> v29) & 0x2000) != 0)
      {
        for (j = 0; j != 8; j += 2)
        {
          v9 = *(unsigned __int16 *)(v31 + j);
          *(_WORD *)(v30 + j) = v9;
        }
      }
      else
      {
        *(int16x4_t *)(a5 + 2 * (v5 + 4 * v29 + (2 << (char)result))) = vdup_n_s16(v9);
      }
      ++v29;
      v30 += 8;
      v31 += 8;
    }
    while (v29 != v8);
  }
  return result;
}

void *sub_1B67D1174(void *result, int a2, uint64_t a3, uint64_t a4, _WORD *a5)
{
  char v6;
  int v10;
  uint64_t v11;
  _WORD *v12;
  _WORD *v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  _WORD *v17;
  uint64_t v18;
  _WORD *v19;
  _WORD *v20;
  uint64_t v21;
  __int16 v22;
  _WORD *v23;
  __int16 *v24;
  __int16 v25;
  uint64_t v26;
  _WORD *v27;
  uint64_t v28;
  _WORD *v29;
  __int16 v30;

  v6 = (char)result;
  if (!a2)
    return memset(a5 - 1, 128, (8 * ((unint64_t)(4 << (char)result) >> 2)) | 2);
  v10 = 1 << (char)result;
  if ((a2 & 0xF) != 0)
  {
    if (v10 < 2 << (char)result)
    {
      v11 = (2 << (char)result) - (uint64_t)v10;
      v12 = &a5[v10];
      v13 = (_WORD *)(a4 + 2 * a3 * v10 - 2);
      do
      {
        *v12++ = *v13;
        v13 += a3;
        --v11;
      }
      while (v11);
    }
  }
  else
  {
    v14 = v10 - a3;
    if ((a2 & 0x1E00) != 0)
      v14 = -a3;
    if ((a2 & 0x100) != 0)
      v14 = ~a3;
    if ((a2 & 0xF0) != 0)
      v14 = (v10 - 1) * a3 - 1;
    v15 = *(_WORD *)(a4 + 2 * v14);
    v16 = v10;
    v17 = &a5[v10];
    do
    {
      *v17++ = v15;
      --v16;
    }
    while (v16);
  }
  if ((a2 & 0xF0) != 0)
  {
    if ((_DWORD)result != 31)
    {
      if (v10 <= 1)
        v18 = 1;
      else
        v18 = v10;
      v19 = (_WORD *)(a4 - 2);
      v20 = a5;
      do
      {
        *v20++ = *v19;
        v19 += a3;
        --v18;
      }
      while (v18);
    }
  }
  else
  {
    v21 = v10;
    v22 = a5[v10];
    v23 = a5;
    do
    {
      *v23++ = v22;
      --v21;
    }
    while (v21);
  }
  v24 = (__int16 *)(a4 + 2 * ~a3);
  if ((a2 & 0x100) == 0)
    v24 = a5;
  v25 = *v24;
  *(a5 - 1) = v25;
  if ((a2 & 0x1E00) != 0)
  {
    result = memcpy(&a5[2 << (char)result], (const void *)(a4 - 2 * a3), 2 * v10);
  }
  else
  {
    v26 = v10;
    v27 = &a5[2 << (char)result];
    do
    {
      *v27++ = v25;
      --v26;
    }
    while (v26);
  }
  if ((a2 & 0x1E000) != 0)
    return memcpy(&a5[3 << v6], (const void *)(a4 + 2 * v10 - 2 * a3), 2 * v10);
  v28 = v10;
  v29 = &a5[3 << v6];
  v30 = *(v29 - 1);
  do
  {
    *v29++ = v30;
    --v28;
  }
  while (v28);
  return result;
}

uint64_t sub_1B67D1388(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  int v10;
  char v11;
  uint64_t v12;
  uint64_t i;

  if (a2 >= 1)
  {
    v9 = result;
    v10 = 0;
    v11 = 8 - a3;
    v12 = a2;
    do
    {
      for (i = 0; i != v12; ++i)
      {
        result = sub_1B67C9094(v9, a3);
        *(_BYTE *)(a5 + i) = (_DWORD)result << v11;
      }
      a5 += a4;
      ++v10;
    }
    while (v10 != a2);
  }
  return result;
}

uint64_t sub_1B67D1420(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v9;
  int v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;

  if (a2 >= 1)
  {
    v5 = a5;
    v9 = result;
    v10 = 0;
    v11 = a5 + 1;
    v12 = 8 - a3;
    v17 = a2;
    v13 = 2 * a2;
    do
    {
      v14 = 0;
      do
      {
        *(_BYTE *)(v5 + v14) = sub_1B67C9094(v9, a3) << v12;
        v14 += 2;
      }
      while (v13 != v14);
      v5 += a4;
      ++v10;
    }
    while (v10 != a2);
    v15 = 0;
    do
    {
      v16 = 0;
      do
      {
        result = sub_1B67C9094(v9, a3);
        *(_BYTE *)(v11 + v16) = (_DWORD)result << v12;
        v16 += 2;
      }
      while (2 * v17 != v16);
      v11 += a4;
      ++v15;
    }
    while (v15 != a2);
  }
  return result;
}

void sub_1B67D150C(int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int16 *v20;
  __int16 *v21;
  uint64_t v22;
  uint64_t v23;
  __int16 *v24;
  __int16 *v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int16 *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __int16 *v38;
  __int16 *v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  __int16 *v47;
  __int16 *v48;
  _WORD *v49;
  __int16 *v50;
  _WORD *v51;
  uint64_t v52;
  __int16 v53;
  uint64_t v54;
  uint64_t v55;
  _WORD *v56;
  uint64_t v57;
  __int16 *v58;
  __int16 *v59;
  _WORD *v60;
  uint64_t v61;
  __int16 v62;
  uint64_t v63;

  if (a2)
  {
    v5 = (1 << a1);
    if ((int)v5 >= 8)
      v6 = 8;
    else
      v6 = v5;
    v7 = __clz(__rbit32(a2));
    if (v7 < 9)
      v8 = ((2 << a1) + (char)~byte_1B6920BFD[9 * a1 - 18 + v7]) * a3 - 1;
    else
      v8 = byte_1B6920BFD[9 * a1 - 27 + v7] - a3;
    LODWORD(v9) = ((int)v5 + 4) >> 3;
    v10 = *(_WORD *)(a4 + 2 * v8);
    if ((int)v5 >= 4)
    {
      v11 = 0;
      v12 = 2 << a1;
      if ((int)v9 <= 1)
        v13 = 1;
      else
        v13 = v9;
      if ((int)v5 >= 8)
        v14 = 8;
      else
        v14 = 1 << a1;
      v15 = v14;
      v16 = a5 + 2 * v12;
      v17 = -2 * v14;
      v18 = a4 + 2 * a3 * (v12 - 1);
      v19 = a3 * v14;
      v20 = (__int16 *)(v16 - 2);
      v21 = (__int16 *)(v18 - 2);
      v22 = -(uint64_t)v14;
      do
      {
        if (((a2 >> v11) & 1) != 0)
        {
          v23 = v6 + 1;
          v24 = v21;
          v25 = v20;
          do
          {
            v10 = *v24;
            *v25-- = *v24;
            v24 -= a3;
            --v23;
          }
          while (v23 > 1);
        }
        else
        {
          v26 = v22;
          do
          {
            *(_WORD *)(v16 + 2 * v26) = v10;
            v27 = __CFADD__(v26++, 1);
          }
          while (!v27);
        }
        ++v11;
        v20 = (__int16 *)((char *)v20 + v17);
        v21 -= v19;
        v16 += v17;
      }
      while (v11 != v13);
      v28 = 0;
      v29 = a5 + 2 * v5;
      v30 = -2 * v15;
      if ((1 << a1) >= 8uLL)
        v31 = 8;
      else
        v31 = (1 << a1);
      v32 = (__int16 *)(v29 - 2);
      v33 = a4 + 2 * a3 * (v5 - 1) - 2;
      v34 = -2 * v19;
      v35 = v31 + 1;
      v36 = -v15;
      do
      {
        if (((a2 >> v28) & 0x10) != 0)
        {
          v37 = v35;
          v38 = (__int16 *)v33;
          v39 = v32;
          do
          {
            v10 = *v38;
            *v39-- = *v38;
            v38 -= a3;
            --v37;
          }
          while (v37 > 1);
        }
        else
        {
          v40 = v36;
          do
          {
            *(_WORD *)(v29 + 2 * v40) = v10;
            v27 = __CFADD__(v40++, 1);
          }
          while (!v27);
        }
        ++v28;
        v32 = (__int16 *)((char *)v32 + v30);
        v33 += v34;
        v29 += v30;
      }
      while (v28 != v13);
    }
    if ((a2 & 0x100) != 0)
      v10 = *(_WORD *)(a4 + 2 * ~a3);
    *(_WORD *)(a5 - 2) = v10;
    if ((int)v5 >= 4)
    {
      v41 = 0;
      v42 = 2 << a1;
      v43 = (int)v6;
      if ((int)v6 <= 1)
        v44 = 1;
      else
        v44 = v6;
      v45 = v42;
      if ((int)v9 <= 1)
        v9 = 1;
      else
        v9 = v9;
      v46 = 2 * (int)v6;
      v47 = (__int16 *)(a4 - 2 * a3);
      v48 = v47;
      v49 = (_WORD *)(a5 + 2 * v42);
      do
      {
        if (((a2 >> v41) & 0x200) != 0)
        {
          v50 = v48;
          v51 = v49;
          v52 = v44;
          do
          {
            v53 = *v50++;
            v10 = v53;
            *v51++ = v53;
            --v52;
          }
          while (v52);
        }
        else
        {
          v54 = 0;
          do
            v49[v54++] = v10;
          while (v43 != v54);
        }
        ++v41;
        v49 = (_WORD *)((char *)v49 + v46);
        v48 = (__int16 *)((char *)v48 + v46);
      }
      while (v41 != v9);
      v55 = 0;
      v56 = (_WORD *)(a5 + 2 * (v45 + v5));
      v57 = 2 * v43;
      v58 = &v47[v5];
      do
      {
        if (((a2 >> v55) & 0x2000) != 0)
        {
          v59 = v58;
          v60 = v56;
          v61 = v44;
          do
          {
            v62 = *v59++;
            v10 = v62;
            *v60++ = v62;
            --v61;
          }
          while (v61);
        }
        else
        {
          v63 = 0;
          do
            v56[v63++] = v10;
          while (v43 != v63);
        }
        ++v55;
        v56 = (_WORD *)((char *)v56 + v57);
        v58 = (__int16 *)((char *)v58 + v57);
      }
      while (v55 != v9);
    }
  }
  else
  {
    memset_pattern16((void *)(a5 - 2), &unk_1B69180E0, (8 * ((unint64_t)(4 << a1) >> 2)) | 2);
  }
}

void sub_1B67D1828(int a1, int a2, uint64_t a3, uint64_t a4, _WORD *a5)
{
  char v6;
  int v10;
  uint64_t v11;
  _WORD *v12;
  _WORD *v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  _WORD *v17;
  uint64_t v18;
  _WORD *v19;
  _WORD *v20;
  uint64_t v21;
  __int16 v22;
  _WORD *v23;
  __int16 *v24;
  __int16 v25;
  uint64_t v26;
  _WORD *v27;
  uint64_t v28;
  _WORD *v29;
  __int16 v30;

  v6 = a1;
  if (a2)
  {
    v10 = 1 << a1;
    if ((a2 & 0xF) != 0)
    {
      if (v10 < 2 << a1)
      {
        v11 = (2 << a1) - (uint64_t)v10;
        v12 = &a5[v10];
        v13 = (_WORD *)(a4 + 2 * a3 * v10 - 2);
        do
        {
          *v12++ = *v13;
          v13 += a3;
          --v11;
        }
        while (v11);
      }
    }
    else
    {
      v14 = v10 - a3;
      if ((a2 & 0x1E00) != 0)
        v14 = -a3;
      if ((a2 & 0x100) != 0)
        v14 = ~a3;
      if ((a2 & 0xF0) != 0)
        v14 = (v10 - 1) * a3 - 1;
      v15 = *(_WORD *)(a4 + 2 * v14);
      v16 = v10;
      v17 = &a5[v10];
      do
      {
        *v17++ = v15;
        --v16;
      }
      while (v16);
    }
    if ((a2 & 0xF0) != 0)
    {
      if (a1 != 31)
      {
        if (v10 <= 1)
          v18 = 1;
        else
          v18 = v10;
        v19 = (_WORD *)(a4 - 2);
        v20 = a5;
        do
        {
          *v20++ = *v19;
          v19 += a3;
          --v18;
        }
        while (v18);
      }
    }
    else
    {
      v21 = v10;
      v22 = a5[v10];
      v23 = a5;
      do
      {
        *v23++ = v22;
        --v21;
      }
      while (v21);
    }
    v24 = (__int16 *)(a4 + 2 * ~a3);
    if ((a2 & 0x100) == 0)
      v24 = a5;
    v25 = *v24;
    *(a5 - 1) = v25;
    if ((a2 & 0x1E00) != 0)
    {
      memcpy(&a5[2 << a1], (const void *)(a4 - 2 * a3), 2 * v10);
    }
    else
    {
      v26 = v10;
      v27 = &a5[2 << a1];
      do
      {
        *v27++ = v25;
        --v26;
      }
      while (v26);
    }
    if ((a2 & 0x1E000) != 0)
    {
      memcpy(&a5[3 << v6], (const void *)(a4 + 2 * v10 - 2 * a3), 2 * v10);
    }
    else
    {
      v28 = v10;
      v29 = &a5[3 << v6];
      v30 = *(v29 - 1);
      do
      {
        *v29++ = v30;
        --v28;
      }
      while (v28);
    }
  }
  else
  {
    memset_pattern16(a5 - 1, &unk_1B69180E0, (8 * ((unint64_t)(4 << a1) >> 2)) | 2);
  }
}

void sub_1B67D1A40(int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t i;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t j;

  if (a2)
  {
    v5 = (1 << a1);
    v6 = __clz(__rbit32(a2));
    if (v6 < 9)
      v7 = ((2 << a1) + (char)~byte_1B6920BFD[9 * a1 + 18 + v6]) * a3 - 1;
    else
      v7 = byte_1B6920BFD[9 * a1 + 9 + v6] - a3;
    LODWORD(v8) = (int)v5 >> 2;
    v9 = *(_DWORD *)(a4 + 4 * v7);
    if ((int)v5 >= 4)
    {
      v10 = 0;
      v11 = 2 << a1;
      v12 = a5 + 4 * v11;
      if ((int)v8 <= 1)
        v13 = 1;
      else
        v13 = v8;
      v14 = a4 + 4 * a3 * (v11 - 1) - 4;
      do
      {
        v15 = v10 + 1;
        if (((a2 >> v10) & 1) != 0)
        {
          v16 = -4;
          v17 = (unsigned int *)v14;
          do
          {
            v9 = *v17;
            *(_DWORD *)(v12 + v16) = *v17;
            v16 -= 4;
            v17 -= a3;
          }
          while (v16 != -20);
        }
        else
        {
          *(int32x4_t *)(a5 + 4 * (v11 - 4 * v15)) = vdupq_n_s32(v9);
        }
        v12 -= 16;
        v14 -= 16 * a3;
        v10 = v15;
      }
      while (v15 != v13);
      v18 = 0;
      v19 = a5 + 4 * v5;
      v20 = a4 + 4 * a3 * (v5 - 1) - 4;
      do
      {
        v21 = v18 + 1;
        if (((a2 >> v18) & 0x10) != 0)
        {
          v22 = -4;
          v23 = (unsigned int *)v20;
          do
          {
            v9 = *v23;
            *(_DWORD *)(v19 + v22) = *v23;
            v22 -= 4;
            v23 -= a3;
          }
          while (v22 != -20);
        }
        else
        {
          *(int32x4_t *)(a5 + 4 * (v5 - 4 * v21)) = vdupq_n_s32(v9);
        }
        v19 -= 16;
        v20 -= 16 * a3;
        v18 = v21;
      }
      while (v21 != v13);
    }
    if ((a2 & 0x100) != 0)
      v9 = *(_DWORD *)(a4 + 4 * ~a3);
    *(_DWORD *)(a5 - 4) = v9;
    if ((int)v5 >= 4)
    {
      v24 = 0;
      v25 = 2 << a1;
      if ((int)v8 <= 1)
        v8 = 1;
      else
        v8 = v8;
      v26 = a5 + 4 * v25;
      v27 = a4 - 4 * a3;
      do
      {
        if (((a2 >> v24) & 0x200) != 0)
        {
          for (i = 0; i != 16; i += 4)
          {
            v9 = *(_DWORD *)(v27 + i);
            *(_DWORD *)(v26 + i) = v9;
          }
        }
        else
        {
          *(int32x4_t *)(a5 + 4 * (v25 + 4 * v24)) = vdupq_n_s32(v9);
        }
        ++v24;
        v26 += 16;
        v27 += 16;
      }
      while (v24 != v8);
      v29 = 0;
      v30 = a5 + 4 * (v25 + (unint64_t)v5);
      v31 = a4 - 4 * a3 + 4 * v5;
      do
      {
        if (((a2 >> v29) & 0x2000) != 0)
        {
          for (j = 0; j != 16; j += 4)
          {
            v9 = *(_DWORD *)(v31 + j);
            *(_DWORD *)(v30 + j) = v9;
          }
        }
        else
        {
          *(int32x4_t *)(a5 + 4 * (v5 + 4 * v29 + (2 << a1))) = vdupq_n_s32(v9);
        }
        ++v29;
        v30 += 16;
        v31 += 16;
      }
      while (v29 != v8);
    }
  }
  else
  {
    memset_pattern16((void *)(a5 - 4), &unk_1B69180E0, (16 * ((unint64_t)(4 << a1) >> 2)) | 4);
  }
}

void sub_1B67D1CD0(int a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  char v6;
  int v10;
  uint64_t v11;
  _DWORD *v12;
  _DWORD *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  _DWORD *v17;
  uint64_t v18;
  _DWORD *v19;
  _DWORD *v20;
  uint64_t v21;
  int v22;
  _DWORD *v23;
  int *v24;
  int v25;
  uint64_t v26;
  _DWORD *v27;
  uint64_t v28;
  _DWORD *v29;
  int v30;

  v6 = a1;
  if (a2)
  {
    v10 = 1 << a1;
    if ((a2 & 0xF) != 0)
    {
      if (v10 < 2 << a1)
      {
        v11 = (2 << a1) - (uint64_t)v10;
        v12 = &a5[v10];
        v13 = (_DWORD *)(a4 + 4 * a3 * v10 - 4);
        do
        {
          *v12++ = *v13;
          v13 += a3;
          --v11;
        }
        while (v11);
      }
    }
    else
    {
      v14 = v10 - a3;
      if ((a2 & 0x1E00) != 0)
        v14 = -a3;
      if ((a2 & 0x100) != 0)
        v14 = ~a3;
      if ((a2 & 0xF0) != 0)
        v14 = (v10 - 1) * a3 - 1;
      v15 = *(_DWORD *)(a4 + 4 * v14);
      v16 = v10;
      v17 = &a5[v10];
      do
      {
        *v17++ = v15;
        --v16;
      }
      while (v16);
    }
    if ((a2 & 0xF0) != 0)
    {
      if (a1 != 31)
      {
        if (v10 <= 1)
          v18 = 1;
        else
          v18 = v10;
        v19 = (_DWORD *)(a4 - 4);
        v20 = a5;
        do
        {
          *v20++ = *v19;
          v19 += a3;
          --v18;
        }
        while (v18);
      }
    }
    else
    {
      v21 = v10;
      v22 = a5[v10];
      v23 = a5;
      do
      {
        *v23++ = v22;
        --v21;
      }
      while (v21);
    }
    v24 = (int *)(a4 + 4 * ~a3);
    if ((a2 & 0x100) == 0)
      v24 = a5;
    v25 = *v24;
    *(a5 - 1) = v25;
    if ((a2 & 0x1E00) != 0)
    {
      memcpy(&a5[2 << a1], (const void *)(a4 - 4 * a3), 4 * v10);
    }
    else
    {
      v26 = v10;
      v27 = &a5[2 << a1];
      do
      {
        *v27++ = v25;
        --v26;
      }
      while (v26);
    }
    if ((a2 & 0x1E000) != 0)
    {
      memcpy(&a5[3 << v6], (const void *)(a4 + 4 * v10 - 4 * a3), 4 * v10);
    }
    else
    {
      v28 = v10;
      v29 = &a5[3 << v6];
      v30 = *(v29 - 1);
      do
      {
        *v29++ = v30;
        --v28;
      }
      while (v28);
    }
  }
  else
  {
    memset_pattern16(a5 - 1, &unk_1B69180E0, (16 * ((unint64_t)(4 << a1) >> 2)) | 4);
  }
}

unsigned __int16 *sub_1B67D1EE4(unsigned __int16 *result, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned __int16 *v4;
  int v5;
  int v6;
  _WORD *v7;
  int v8;

  v2 = 0;
  v3 = *(result - 1);
  v4 = result + 16;
  *(_WORD *)(a2 - 2) = (*result + 2 * v3 + result[16] + 2) >> 2;
  *(_WORD *)(a2 + 62) = result[31];
  *(_WORD *)(a2 + 30) = result[15];
  v5 = v3;
  do
  {
    v6 = result[v2];
    v7 = (_WORD *)(a2 + v2 * 2);
    *v7 = (v3 + 2 * v6 + v4[v2 - 15] + 2) >> 2;
    v8 = v4[v2];
    v7[16] = (v5 + 2 * v8 + v4[++v2] + 2) >> 2;
    v3 = v6;
    v5 = v8;
  }
  while (v2 != 15);
  return result;
}

unsigned __int16 *sub_1B67D1F78(unsigned __int16 *result, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned __int16 *v4;
  int v5;
  int v6;
  _WORD *v7;
  int v8;

  v2 = 0;
  v3 = *(result - 1);
  v4 = result + 32;
  *(_WORD *)(a2 - 2) = (*result + 2 * v3 + result[32] + 2) >> 2;
  *(_WORD *)(a2 + 126) = result[63];
  *(_WORD *)(a2 + 62) = result[31];
  v5 = v3;
  do
  {
    v6 = result[v2];
    v7 = (_WORD *)(a2 + v2 * 2);
    *v7 = (v3 + 2 * v6 + v4[v2 - 31] + 2) >> 2;
    v8 = v4[v2];
    v7[32] = (v5 + 2 * v8 + v4[++v2] + 2) >> 2;
    v3 = v6;
    v5 = v8;
  }
  while (v2 != 31);
  return result;
}

unsigned __int16 *sub_1B67D200C(unsigned __int16 *result, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned __int16 *v4;
  int v5;
  int v6;
  _WORD *v7;
  int v8;

  v2 = 0;
  v3 = *(result - 1);
  v4 = result + 64;
  *(_WORD *)(a2 - 2) = (*result + 2 * v3 + result[64] + 2) >> 2;
  *(_WORD *)(a2 + 254) = result[127];
  *(_WORD *)(a2 + 126) = result[63];
  v5 = v3;
  do
  {
    v6 = result[v2];
    v7 = (_WORD *)(a2 + v2 * 2);
    *v7 = (v3 + 2 * v6 + v4[v2 - 63] + 2) >> 2;
    v8 = v4[v2];
    v7[64] = (v5 + 2 * v8 + v4[++v2] + 2) >> 2;
    v3 = v6;
    v5 = v8;
  }
  while (v2 != 63);
  return result;
}

uint64_t sub_1B67D20A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t result;

  v4 = 0;
  do
  {
    v5 = 0;
    v6 = v4 + 1;
    v7 = 3;
    do
    {
      result = *(unsigned __int16 *)(a2 + 16 + 2 * v5);
      *(_WORD *)(a4 + 2 * v5) = (((_DWORD)v5 + 1) * *(unsigned __int16 *)(a2 + 24)
                               + v7 * *(unsigned __int16 *)(a2 + 2 * v4)
                               + (3 - (_DWORD)v4) * (_DWORD)result
                               + v6 * *(unsigned __int16 *)(a2 + 8)
                               + 4) >> 3;
      --v7;
      ++v5;
    }
    while (v5 != 4);
    a4 += 2 * a3;
    ++v4;
  }
  while (v6 != 4);
  return result;
}

uint64_t sub_1B67D2110(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t result;

  v4 = 0;
  do
  {
    v5 = 0;
    v6 = v4 + 1;
    v7 = 7;
    do
    {
      result = *(unsigned __int16 *)(a2 + 32 + 2 * v5);
      *(_WORD *)(a4 + 2 * v5) = (((_DWORD)v5 + 1) * *(unsigned __int16 *)(a2 + 48)
                               + v7 * *(unsigned __int16 *)(a2 + 2 * v4)
                               + (7 - (_DWORD)v4) * (_DWORD)result
                               + v6 * *(unsigned __int16 *)(a2 + 16)
                               + 8) >> 4;
      --v7;
      ++v5;
    }
    while (v5 != 8);
    a4 += 2 * a3;
    ++v4;
  }
  while (v6 != 8);
  return result;
}

uint64_t sub_1B67D2180(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t result;

  v4 = 0;
  do
  {
    v5 = 0;
    v6 = v4 + 1;
    v7 = 15;
    do
    {
      result = *(unsigned __int16 *)(a2 + 64 + 2 * v5);
      *(_WORD *)(a4 + 2 * v5) = (((_DWORD)v5 + 1) * *(unsigned __int16 *)(a2 + 96)
                               + v7 * *(unsigned __int16 *)(a2 + 2 * v4)
                               + (15 - (_DWORD)v4) * (_DWORD)result
                               + v6 * *(unsigned __int16 *)(a2 + 32)
                               + 16) >> 5;
      --v7;
      ++v5;
    }
    while (v5 != 16);
    a4 += 2 * a3;
    ++v4;
  }
  while (v6 != 16);
  return result;
}

uint64_t sub_1B67D21F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t result;

  v4 = 0;
  do
  {
    v5 = 0;
    v6 = v4 + 1;
    v7 = 31;
    do
    {
      result = *(unsigned __int16 *)(a2 + 128 + 2 * v5);
      *(_WORD *)(a4 + 2 * v5) = (((_DWORD)v5 + 1) * *(unsigned __int16 *)(a2 + 192)
                               + v7 * *(unsigned __int16 *)(a2 + 2 * v4)
                               + (31 - (_DWORD)v4) * (_DWORD)result
                               + v6 * *(unsigned __int16 *)(a2 + 64)
                               + 32) >> 6;
      --v7;
      ++v5;
    }
    while (v5 != 32);
    a4 += 2 * a3;
    ++v4;
  }
  while (v6 != 32);
  return result;
}

uint64_t sub_1B67D2260(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t result;

  v4 = 0;
  do
  {
    v5 = 0;
    v6 = v4 + 1;
    v7 = 63;
    do
    {
      result = *(unsigned __int16 *)(a2 + 256 + 2 * v5);
      *(_WORD *)(a4 + 2 * v5) = (((_DWORD)v5 + 1) * *(unsigned __int16 *)(a2 + 384)
                               + v7 * *(unsigned __int16 *)(a2 + 2 * v4)
                               + (63 - (_DWORD)v4) * (_DWORD)result
                               + v6 * *(unsigned __int16 *)(a2 + 128)
                               + 64) >> 7;
      --v7;
      ++v5;
    }
    while (v5 != 64);
    a4 += 2 * a3;
    ++v4;
  }
  while (v6 != 64);
  return result;
}

void sub_1B67D22D0(uint64_t a1, uint16x4_t *a2, uint64_t a3, _WORD *a4)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  char *v7;
  _WORD *v8;

  v4 = 0;
  v5 = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(a2[2], *a2), (int32x4_t)xmmword_1B69175E0)) >> 3;
  *a4 = (2 * v5 + a2->u16[0] + (unsigned __int16)*(_QWORD *)&a2[2] + 2) >> 2;
  v6 = 3 * v5 + 2;
  v7 = (char *)&a2[2] + 2;
  v8 = &a4[a3 + 2];
  do
  {
    a4[v4 + 1] = (v6 + *(unsigned __int16 *)&v7[v4 * 2]) >> 2;
    *(v8 - 2) = (v6 + *(unsigned __int16 *)&v7[v4 * 2 - 16]) >> 2;
    *(v8 - 1) = v5;
    *v8 = v5;
    v8[1] = v5;
    ++v4;
    v8 += a3;
  }
  while (v4 != 3);
}

void sub_1B67D2378(uint64_t a1, uint16x4_t *a2, uint64_t a3, _WORD *a4)
{
  unsigned int v4;
  int v5;
  _WORD *v6;
  uint64_t i;
  unsigned __int16 *v8;
  uint64_t j;

  v4 = vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)vaddl_u16(a2[4], *a2), (int32x4_t)vaddl_high_u16(*(uint16x8_t *)a2[4].i8, *(uint16x8_t *)a2->i8)), (int32x4_t)xmmword_1B69175F0)) >> 4;
  *a4 = (2 * v4 + (unsigned __int16)*(_OWORD *)a2->i8 + (unsigned __int16)*(_OWORD *)a2[4].i8 + 2) >> 2;
  v5 = 3 * v4 + 2;
  v6 = &a4[a3];
  for (i = 1; i != 8; ++i)
  {
    v8 = (unsigned __int16 *)a2 + i;
    a4[i] = (v5 + v8[16]) >> 2;
    a4[i * a3] = (v5 + *v8) >> 2;
    for (j = 1; j != 8; ++j)
      v6[j] = v4;
    v6 += a3;
  }
}

void sub_1B67D2428(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _WORD *a4)
{
  uint64_t v4;
  int32x4_t v5;
  int32x4_t v6;
  uint16x8_t v7;
  uint16x8_t v8;
  unsigned int v9;
  int v10;
  _WORD *v11;
  uint64_t i;
  unsigned __int16 *v13;
  uint64_t j;

  v4 = 0;
  v5 = (int32x4_t)xmmword_1B6917600;
  v6 = 0uLL;
  do
  {
    v7 = *(uint16x8_t *)&a2[v4 + 32];
    v8 = *(uint16x8_t *)&a2[v4];
    v6 = (int32x4_t)vaddw_high_u16(vaddw_high_u16((uint32x4_t)v6, v7), v8);
    v5 = (int32x4_t)vaddw_u16(vaddw_u16((uint32x4_t)v5, *(uint16x4_t *)v7.i8), *(uint16x4_t *)v8.i8);
    v4 += 8;
  }
  while (v4 != 16);
  v9 = vaddvq_s32(vaddq_s32(v5, v6)) >> 5;
  *a4 = (*a2 + 2 * v9 + a2[32] + 2) >> 2;
  v10 = 3 * v9 + 2;
  v11 = &a4[a3];
  for (i = 1; i != 16; ++i)
  {
    v13 = &a2[i];
    a4[i] = (v10 + v13[32]) >> 2;
    a4[i * a3] = (v10 + *v13) >> 2;
    for (j = 1; j != 16; ++j)
      v11[j] = v9;
    v11 += a3;
  }
}

void sub_1B67D24F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  int32x4_t v5;
  int32x4_t v6;
  uint16x8_t v7;
  uint16x8_t v8;
  uint64_t v9;
  int16x8_t v10;
  uint64_t i;

  v4 = 0;
  v5 = (int32x4_t)xmmword_1B6917610;
  v6 = 0uLL;
  do
  {
    v7 = *(uint16x8_t *)(a2 + v4 + 128);
    v8 = *(uint16x8_t *)(a2 + v4);
    v6 = (int32x4_t)vaddw_high_u16(vaddw_high_u16((uint32x4_t)v6, v7), v8);
    v5 = (int32x4_t)vaddw_u16(vaddw_u16((uint32x4_t)v5, *(uint16x4_t *)v7.i8), *(uint16x4_t *)v8.i8);
    v4 += 16;
  }
  while (v4 != 64);
  v9 = 0;
  v10 = vdupq_n_s16(vaddvq_s32(vaddq_s32(v5, v6)) >> 6);
  do
  {
    for (i = 0; i != 64; i += 16)
      *(int16x8_t *)(a4 + i) = v10;
    ++v9;
    a4 += 2 * a3;
  }
  while (v9 != 32);
}

void sub_1B67D2570(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  int32x4_t v5;
  int32x4_t v6;
  uint16x8_t v7;
  uint16x8_t v8;
  uint64_t v9;
  int16x8_t v10;
  uint64_t i;

  v4 = 0;
  v5 = (int32x4_t)xmmword_1B6917620;
  v6 = 0uLL;
  do
  {
    v7 = *(uint16x8_t *)(a2 + v4 + 256);
    v8 = *(uint16x8_t *)(a2 + v4);
    v6 = (int32x4_t)vaddw_high_u16(vaddw_high_u16((uint32x4_t)v6, v7), v8);
    v5 = (int32x4_t)vaddw_u16(vaddw_u16((uint32x4_t)v5, *(uint16x4_t *)v7.i8), *(uint16x4_t *)v8.i8);
    v4 += 16;
  }
  while (v4 != 128);
  v9 = 0;
  v10 = vdupq_n_s16(vaddvq_s32(vaddq_s32(v5, v6)) >> 7);
  do
  {
    for (i = 0; i != 128; i += 16)
      *(int16x8_t *)(a4 + i) = v10;
    ++v9;
    a4 += 2 * a3;
  }
  while (v9 != 64);
}

int16x4_t *sub_1B67D25EC(int16x4_t *result, uint64_t a2, uint64_t a3, int16x4_t *a4)
{
  int v4;
  int v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  uint64_t v11;
  uint64_t j;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t i;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  _WORD *v27;
  uint64_t v28;
  int16x4_t *v29;
  _WORD v30[4];
  __int128 v31;
  __int16 v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v4 = byte_1B6921758[(int)result];
  v5 = v4;
  v6 = (int)result - 11;
  if ((int)result < 18)
  {
    if (v6 >= 0xF)
    {
      v31 = *(_OWORD *)(a2 - 2);
      v32 = *(_WORD *)(a2 + 14);
    }
    else
    {
      if ((v4 & 0x40000) != 0)
      {
        v14 = word_1B6921880[(int)result - 11];
        v15 = (uint64_t)byte_1B6921758[(int)result] >> 3;
        v16 = (v4 >> 3) * v14 + 128;
        do
        {
          v17 = (v16 >> 8) + 7;
          if (v16 < 0x100)
            v17 = -1;
          *((_WORD *)&v31 + v15) = *(_WORD *)(a2 + 2 * v17);
          v16 += v14;
          v10 = __CFADD__(v15++, 1);
        }
        while (!v10);
      }
      *(_QWORD *)&v31 = *(_QWORD *)(a2 - 2);
      WORD4(v31) = *(_WORD *)(a2 + 6);
    }
    v23 = 0;
    v24 = 2 * a3;
    do
    {
      v25 = v5 >> 5;
      if ((v5 & 0x1F) != 0)
      {
        v26 = 0;
        result = a4;
        v27 = &v30[v25];
        do
        {
          result->i16[0] = ((v5 & 0x1F) * (unsigned __int16)v27[v26 + 6]
                          + (32 - (v5 & 0x1F)) * (unsigned __int16)v27[v26 + 5]
                          + 16) >> 5;
          ++v26;
          result = (int16x4_t *)((char *)result + v24);
        }
        while (v26 != 4);
      }
      else
      {
        v28 = 0;
        v29 = a4;
        do
        {
          result = (int16x4_t *)*(unsigned __int16 *)((char *)&v31 + 2 * v25 + v28 + 2);
          v29->i16[0] = (__int16)result;
          v28 += 2;
          v29 = (int16x4_t *)((char *)v29 + v24);
        }
        while (v28 != 8);
      }
      ++v23;
      v5 += v4;
      a4 = (int16x4_t *)((char *)a4 + 2);
    }
    while (v23 != 4);
  }
  else
  {
    if (v6 >= 0xF)
    {
      v18 = 0;
      for (i = 0; i != 9; ++i)
      {
        v20 = i + 7;
        if (!v18)
          v20 = -1;
        *(_WORD *)((char *)&v31 + v18) = *(_WORD *)(a2 + 2 * v20);
        v18 += 2;
      }
    }
    else
    {
      if ((v4 & 0x40000) != 0)
      {
        v7 = word_1B6921880[(_DWORD)result - 11];
        v8 = (uint64_t)byte_1B6921758[(int)result] >> 3;
        v9 = (v4 >> 3) * v7 + 128;
        do
        {
          *((_WORD *)&v31 + v8) = *(_WORD *)(a2 + 2 * ((v9 >> 8) - 1));
          v9 += v7;
          v10 = __CFADD__(v8++, 1);
        }
        while (!v10);
      }
      v11 = 0;
      for (j = 0; j != 5; ++j)
      {
        v13 = j + 7;
        if (!v11)
          v13 = -1;
        *(_WORD *)((char *)&v31 + v11) = *(_WORD *)(a2 + 2 * v13);
        v11 += 2;
      }
    }
    v21 = 4;
    do
    {
      v22 = (uint64_t)v5 >> 5;
      if ((v5 & 0x1F) != 0)
        *a4 = vrshrn_n_s32((int32x4_t)vmlal_u16(vmull_u16((uint16x4_t)vdup_n_s16(32 - (v5 & 0x1Fu)), *(uint16x4_t *)((char *)&v31 + 2 * v22 + 2)), (uint16x4_t)vdup_n_s16(v5 & 0x1F), *(uint16x4_t *)((char *)&v31 + 2 * v22 + 4)), 5uLL);
      else
        *a4 = *(int16x4_t *)((char *)&v31 + 2 * v22 + 2);
      v5 += v4;
      a4 = (int16x4_t *)((char *)a4 + 2 * a3);
      --v21;
    }
    while (v21);
  }
  return result;
}

int16x8_t *sub_1B67D2880(int16x8_t *result, uint64_t a2, uint64_t a3, int16x8_t *a4)
{
  int v4;
  int v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  uint64_t v11;
  uint64_t j;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t i;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  char *v24;
  uint16x8_t v25;
  uint16x8_t v26;
  uint32x4_t v27;
  uint32x4_t v28;
  uint16x8_t v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  _WORD *v35;
  uint64_t v36;
  int16x8_t *v37;
  _WORD v38[8];
  __int128 v39;
  __int128 v40;
  __int16 v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v4 = byte_1B6921758[(int)result];
  v5 = v4;
  v6 = (int)result - 11;
  if ((int)result < 18)
  {
    if (v6 >= 0xF)
    {
      v30 = *(_OWORD *)(a2 + 14);
      v39 = *(_OWORD *)(a2 - 2);
      v40 = v30;
      v41 = *(_WORD *)(a2 + 30);
    }
    else
    {
      if ((v4 & 0x20000) != 0)
      {
        v14 = word_1B6921880[(int)result - 11];
        v15 = (uint64_t)byte_1B6921758[(int)result] >> 2;
        v16 = (v4 >> 2) * v14 + 128;
        do
        {
          v17 = (v16 >> 8) + 15;
          if (v16 < 0x100)
            v17 = -1;
          *((_WORD *)&v39 + v15) = *(_WORD *)(a2 + 2 * v17);
          v16 += v14;
          v10 = __CFADD__(v15++, 1);
        }
        while (!v10);
      }
      v39 = *(_OWORD *)(a2 - 2);
      LOWORD(v40) = *(_WORD *)(a2 + 14);
    }
    v31 = 0;
    v32 = 2 * a3;
    do
    {
      v33 = v5 >> 5;
      if ((v5 & 0x1F) != 0)
      {
        v34 = 0;
        result = a4;
        v35 = &v38[v33];
        do
        {
          result->i16[0] = ((v5 & 0x1F) * (unsigned __int16)v35[v34 + 10]
                          + (32 - (v5 & 0x1F)) * (unsigned __int16)v35[v34 + 9]
                          + 16) >> 5;
          ++v34;
          result = (int16x8_t *)((char *)result + v32);
        }
        while (v34 != 8);
      }
      else
      {
        v36 = 0;
        v37 = a4;
        do
        {
          result = (int16x8_t *)*(unsigned __int16 *)((char *)&v39 + 2 * v33 + v36 + 2);
          v37->i16[0] = (__int16)result;
          v36 += 2;
          v37 = (int16x8_t *)((char *)v37 + v32);
        }
        while (v36 != 16);
      }
      ++v31;
      v5 += v4;
      a4 = (int16x8_t *)((char *)a4 + 2);
    }
    while (v31 != 8);
  }
  else
  {
    if (v6 >= 0xF)
    {
      v18 = 0;
      for (i = 0; i != 17; ++i)
      {
        v20 = i + 15;
        if (!v18)
          v20 = -1;
        *(_WORD *)((char *)&v39 + v18) = *(_WORD *)(a2 + 2 * v20);
        v18 += 2;
      }
    }
    else
    {
      if ((v4 & 0x20000) != 0)
      {
        v7 = word_1B6921880[(_DWORD)result - 11];
        v8 = (uint64_t)byte_1B6921758[(int)result] >> 2;
        v9 = (v4 >> 2) * v7 + 128;
        do
        {
          *((_WORD *)&v39 + v8) = *(_WORD *)(a2 + 2 * ((v9 >> 8) - 1));
          v9 += v7;
          v10 = __CFADD__(v8++, 1);
        }
        while (!v10);
      }
      v11 = 0;
      for (j = 0; j != 9; ++j)
      {
        v13 = j + 15;
        if (!v11)
          v13 = -1;
        *(_WORD *)((char *)&v39 + v11) = *(_WORD *)(a2 + 2 * v13);
        v11 += 2;
      }
    }
    v21 = 8;
    do
    {
      v22 = (uint64_t)v5 >> 5;
      v23 = v5 & 0x1F;
      if ((v5 & 0x1F) != 0)
      {
        v24 = (char *)&v39 + 2 * v22;
        v25 = *(uint16x8_t *)(v24 + 2);
        v26 = (uint16x8_t)vdupq_n_s16(32 - v23);
        v27 = vmull_u16(*(uint16x4_t *)v26.i8, *(uint16x4_t *)v25.i8);
        v28 = vmull_high_u16(v26, v25);
        v29 = (uint16x8_t)vdupq_n_s16(v23);
        *a4 = vrshrn_high_n_s32(vrshrn_n_s32((int32x4_t)vmlal_u16(v27, *(uint16x4_t *)v29.i8, *(uint16x4_t *)(v24 + 4)), 5uLL), (int32x4_t)vmlal_high_u16(v28, v29, *(uint16x8_t *)(v24 + 4)), 5uLL);
      }
      else
      {
        *a4 = *(int16x8_t *)((char *)&v39 + 2 * v22 + 2);
      }
      v5 += v4;
      a4 = (int16x8_t *)((char *)a4 + 2 * a3);
      --v21;
    }
    while (v21);
  }
  return result;
}

unint64_t sub_1B67D2B24(unint64_t result, uint64_t a2, uint64_t a3, _WORD *a4)
{
  int v4;
  int v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  uint64_t v11;
  uint64_t j;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  __int128 v18;
  uint64_t v19;
  uint64_t i;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _WORD *v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  _WORD *v28;
  uint16x8_t v29;
  uint16x8_t v30;
  __int128 *v31;
  __int128 v32;
  __int128 v33;
  _OWORD *v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  _WORD *v41;
  uint64_t v42;
  _WORD *v43;
  _WORD v44[16];
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int16 v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v4 = byte_1B6921758[(int)result];
  v5 = v4;
  v6 = (int)result - 11;
  if ((int)result < 18)
  {
    if (v6 >= 0xF)
    {
      v35 = *(_OWORD *)(a2 + 14);
      v36 = *(_OWORD *)(a2 + 46);
      v47 = *(_OWORD *)(a2 + 30);
      v48 = v36;
      v49 = *(_WORD *)(a2 + 62);
      v45 = *(_OWORD *)(a2 - 2);
      v46 = v35;
    }
    else
    {
      if ((v4 & 0x10000) != 0)
      {
        v14 = word_1B6921880[(int)result - 11];
        v15 = (uint64_t)byte_1B6921758[(int)result] >> 1;
        v16 = (v4 >> 1) * v14 + 128;
        do
        {
          v17 = (v16 >> 8) + 31;
          if (v16 < 0x100)
            v17 = -1;
          *((_WORD *)&v45 + v15) = *(_WORD *)(a2 + 2 * v17);
          v16 += v14;
          v10 = __CFADD__(v15++, 1);
        }
        while (!v10);
      }
      v18 = *(_OWORD *)(a2 + 14);
      v45 = *(_OWORD *)(a2 - 2);
      v46 = v18;
      LOWORD(v47) = *(_WORD *)(a2 + 30);
    }
    v37 = 0;
    v38 = 2 * a3;
    do
    {
      v39 = v5 >> 5;
      if ((v5 & 0x1F) != 0)
      {
        v40 = 0;
        result = (unint64_t)a4;
        v41 = &v44[v39];
        do
        {
          *(_WORD *)result = ((v5 & 0x1F) * (unsigned __int16)v41[v40 + 18]
                            + (32 - (v5 & 0x1F)) * (unsigned __int16)v41[v40 + 17]
                            + 16) >> 5;
          ++v40;
          result += v38;
        }
        while (v40 != 16);
      }
      else
      {
        v42 = 0;
        v43 = a4;
        do
        {
          result = *(unsigned __int16 *)((char *)&v45 + 2 * v39 + v42 + 2);
          *v43 = result;
          v42 += 2;
          v43 = (_WORD *)((char *)v43 + v38);
        }
        while (v42 != 32);
      }
      ++v37;
      v5 += v4;
      ++a4;
    }
    while (v37 != 16);
  }
  else
  {
    if (v6 >= 0xF)
    {
      v19 = 0;
      for (i = 0; i != 33; ++i)
      {
        v21 = i + 31;
        if (!v19)
          v21 = -1;
        *(_WORD *)((char *)&v45 + v19) = *(_WORD *)(a2 + 2 * v21);
        v19 += 2;
      }
    }
    else
    {
      if ((v4 & 0x10000) != 0)
      {
        v7 = word_1B6921880[(result - 11)];
        v8 = (uint64_t)byte_1B6921758[(int)result] >> 1;
        v9 = (v4 >> 1) * v7 + 128;
        do
        {
          *((_WORD *)&v45 + v8) = *(_WORD *)(a2 + 2 * ((v9 >> 8) - 1));
          v9 += v7;
          v10 = __CFADD__(v8++, 1);
        }
        while (!v10);
      }
      v11 = 0;
      for (j = 0; j != 17; ++j)
      {
        v13 = j + 31;
        if (!v11)
          v13 = -1;
        *(_WORD *)((char *)&v45 + v11) = *(_WORD *)(a2 + 2 * v13);
        v11 += 2;
      }
    }
    v22 = 0;
    v23 = 2 * a3;
    v24 = a4;
    do
    {
      v25 = (uint64_t)v5 >> 5;
      v26 = v5 & 0x1F;
      if ((v5 & 0x1F) != 0)
      {
        v27 = 0;
        result = 32 - v26;
        v28 = &v44[v25];
        do
        {
          v29 = (uint16x8_t)vdupq_n_s16(result);
          v30 = (uint16x8_t)vdupq_n_s16(v26);
          *(int16x8_t *)&v24[v27] = vrshrn_high_n_s32(vrshrn_n_s32((int32x4_t)vmlal_u16(vmull_u16(*(uint16x4_t *)v29.i8, *(uint16x4_t *)&v28[v27 + 17]), *(uint16x4_t *)v30.i8, *(uint16x4_t *)&v28[v27 + 18]), 5uLL), (int32x4_t)vmlal_high_u16(vmull_high_u16(v29, *(uint16x8_t *)&v28[v27 + 17]), v30, *(uint16x8_t *)&v28[v27 + 18]), 5uLL);
          v27 += 8;
        }
        while (v27 != 16);
      }
      else
      {
        v31 = (__int128 *)((char *)&v45 + 2 * v25 + 2);
        v32 = *v31;
        v33 = v31[1];
        v34 = (_OWORD *)((char *)a4 + v23 * v22);
        *v34 = v32;
        v34[1] = v33;
      }
      ++v22;
      v5 += v4;
      v24 = (_WORD *)((char *)v24 + v23);
    }
    while (v22 != 16);
  }
  return result;
}

unint64_t sub_1B67D2DF8(unint64_t result, uint64_t a2, uint64_t a3, _WORD *a4)
{
  int v4;
  uint64_t v5;
  int v6;
  unint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  _WORD *v11;
  int v12;
  uint64_t v13;
  uint64_t j;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  _WORD *v19;
  int v20;
  int v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t i;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _WORD *v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  _WORD *v33;
  uint16x8_t v34;
  uint16x8_t v35;
  _OWORD *v36;
  _OWORD *v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  _WORD *v48;
  uint64_t v49;
  _WORD *v50;
  _WORD v51[32];
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int16 v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v4 = byte_1B6921758[(int)result];
  v5 = byte_1B6921758[(int)result];
  v6 = v4;
  v7 = (int)result - 11;
  if ((int)result < 18)
  {
    if (v7 >= 0xF)
    {
      v40 = *(_OWORD *)(a2 + 78);
      v41 = *(_OWORD *)(a2 + 110);
      v58 = *(_OWORD *)(a2 + 94);
      v59 = v41;
      v60 = *(_WORD *)(a2 + 126);
      v42 = *(_OWORD *)(a2 + 14);
      v43 = *(_OWORD *)(a2 + 46);
      v54 = *(_OWORD *)(a2 + 30);
      v55 = v43;
      v56 = *(_OWORD *)(a2 + 62);
      v57 = v40;
      v52 = *(_OWORD *)(a2 - 2);
      v53 = v42;
    }
    else
    {
      v16 = word_1B6921880[(int)result - 11];
      if (v4 < 0)
        v17 = -1;
      else
        v17 = byte_1B6921758[(int)result];
      v18 = v17 - v5 + 1;
      v19 = &v51[v5 + 32];
      v20 = v4 * v16 + 128;
      do
      {
        v21 = (v20 >> 8) + 63;
        if (v20 < 0x100)
          v21 = -1;
        *v19++ = *(_WORD *)(a2 + 2 * v21);
        v20 += v16;
        --v18;
      }
      while (v18);
      v22 = *(_OWORD *)(a2 + 14);
      v23 = *(_OWORD *)(a2 + 46);
      v54 = *(_OWORD *)(a2 + 30);
      v55 = v23;
      LOWORD(v56) = *(_WORD *)(a2 + 62);
      v52 = *(_OWORD *)(a2 - 2);
      v53 = v22;
    }
    v44 = 0;
    v45 = 2 * a3;
    do
    {
      v46 = v6 >> 5;
      if ((v6 & 0x1F) != 0)
      {
        v47 = 0;
        result = (unint64_t)a4;
        v48 = &v51[v46];
        do
        {
          *(_WORD *)result = ((v6 & 0x1F) * (unsigned __int16)v48[v47 + 34]
                            + (32 - (v6 & 0x1F)) * (unsigned __int16)v48[v47 + 33]
                            + 16) >> 5;
          ++v47;
          result += v45;
        }
        while (v47 != 32);
      }
      else
      {
        v49 = 0;
        v50 = a4;
        do
        {
          result = *(unsigned __int16 *)((char *)&v52 + 2 * v46 + v49 + 2);
          *v50 = result;
          v49 += 2;
          v50 = (_WORD *)((char *)v50 + v45);
        }
        while (v49 != 64);
      }
      ++v44;
      v6 += v4;
      ++a4;
    }
    while (v44 != 32);
  }
  else
  {
    if (v7 >= 0xF)
    {
      v24 = 0;
      for (i = 0; i != 65; ++i)
      {
        v26 = i + 63;
        if (!v24)
          v26 = -1;
        *(_WORD *)((char *)&v52 + v24) = *(_WORD *)(a2 + 2 * v26);
        v24 += 2;
      }
    }
    else
    {
      v8 = word_1B6921880[(result - 11)];
      if ((int)v5 < 0)
        v9 = -1;
      else
        v9 = byte_1B6921758[(int)result];
      v10 = v9 - v5 + 1;
      v11 = &v51[v5 + 32];
      v12 = v4 * v8 + 128;
      do
      {
        *v11++ = *(_WORD *)(a2 + 2 * ((v12 >> 8) - 1));
        v12 += v8;
        --v10;
      }
      while (v10);
      v13 = 0;
      for (j = 0; j != 33; ++j)
      {
        v15 = j + 63;
        if (!v13)
          v15 = -1;
        *(_WORD *)((char *)&v52 + v13) = *(_WORD *)(a2 + 2 * v15);
        v13 += 2;
      }
    }
    v27 = 0;
    v28 = 2 * a3;
    v29 = a4;
    do
    {
      v30 = (uint64_t)v6 >> 5;
      v31 = v6 & 0x1F;
      if ((v6 & 0x1F) != 0)
      {
        v32 = 0;
        result = 32 - v31;
        v33 = &v51[v30];
        do
        {
          v34 = (uint16x8_t)vdupq_n_s16(result);
          v35 = (uint16x8_t)vdupq_n_s16(v31);
          *(int16x8_t *)&v29[v32] = vrshrn_high_n_s32(vrshrn_n_s32((int32x4_t)vmlal_u16(vmull_u16(*(uint16x4_t *)v34.i8, *(uint16x4_t *)&v33[v32 + 33]), *(uint16x4_t *)v35.i8, *(uint16x4_t *)&v33[v32 + 34]), 5uLL), (int32x4_t)vmlal_high_u16(vmull_high_u16(v34, *(uint16x8_t *)&v33[v32 + 33]), v35, *(uint16x8_t *)&v33[v32 + 34]), 5uLL);
          v32 += 8;
        }
        while (v32 != 32);
      }
      else
      {
        v36 = (_OWORD *)((char *)a4 + v28 * v27);
        v37 = (__int128 *)((char *)&v52 + 2 * v30 + 2);
        v38 = v37[1];
        *v36 = *v37;
        v36[1] = v38;
        v39 = v37[3];
        v36[2] = v37[2];
        v36[3] = v39;
      }
      ++v27;
      v6 += v4;
      v29 = (_WORD *)((char *)v29 + v28);
    }
    while (v27 != 32);
  }
  return result;
}

_BYTE *sub_1B67D3124(int a1, uint64_t a2, uint64_t a3, _WORD *a4)
{
  _WORD *v4;
  int v7;
  uint64_t v8;
  _BYTE *result;
  int v10;
  unint64_t v11;
  int v12;
  int v13;
  __int16 v14;
  unint64_t v15;
  _WORD *v16;
  int v17;
  BOOL v18;
  uint64_t v19;
  uint64_t j;
  uint64_t v21;
  int v22;
  int v23;
  __int16 v24;
  unint64_t v25;
  _WORD *v26;
  int v27;
  int v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  uint64_t i;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _WORD *v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t v41;
  _WORD *v42;
  uint16x8_t v43;
  uint16x8_t v44;
  _OWORD *v45;
  __int128 v46;
  _OWORD *v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  _WORD *v55;
  _WORD *v56;
  uint64_t v57;
  _WORD *v58;
  _WORD v59[64];
  _BYTE v60[258];
  uint64_t v61;

  v4 = a4;
  v61 = *MEMORY[0x1E0C80C00];
  v7 = byte_1B6921758[a1];
  v8 = a1;
  result = v60;
  v10 = v7;
  v11 = v8 - 11;
  if (a1 < 18)
  {
    if (v11 >= 0xF)
    {
      result = memcpy(v60, (const void *)(a2 - 2), sizeof(v60));
    }
    else
    {
      v22 = 2 * v7;
      v23 = word_1B6921880[v8 - 11];
      if ((v7 & 0x40000000) != 0)
        v24 = -1;
      else
        v24 = 2 * v7;
      v25 = v22 - (unint64_t)(unsigned __int16)(v24 + 1);
      v26 = &v59[v22 + 64];
      v27 = v23 * v22 + 128;
      do
      {
        v28 = (v27 >> 8) + 127;
        if (v27 < 0x100)
          v28 = -1;
        *v26++ = *(_WORD *)(a2 + 2 * v28);
        v27 += v23;
        v18 = __CFADD__(v25++, 1);
      }
      while (!v18);
      v29 = *(_OWORD *)(a2 + 78);
      v30 = *(_OWORD *)(a2 + 110);
      *(_OWORD *)&v60[96] = *(_OWORD *)(a2 + 94);
      *(_OWORD *)&v60[112] = v30;
      *(_WORD *)&v60[128] = *(_WORD *)(a2 + 126);
      v31 = *(_OWORD *)(a2 + 14);
      v32 = *(_OWORD *)(a2 + 46);
      *(_OWORD *)&v60[32] = *(_OWORD *)(a2 + 30);
      *(_OWORD *)&v60[48] = v32;
      *(_OWORD *)&v60[64] = *(_OWORD *)(a2 + 62);
      *(_OWORD *)&v60[80] = v29;
      *(_OWORD *)v60 = *(_OWORD *)(a2 - 2);
      *(_OWORD *)&v60[16] = v31;
    }
    v51 = 0;
    v52 = 2 * a3;
    do
    {
      v53 = v10 >> 5;
      if ((v10 & 0x1F) != 0)
      {
        v54 = 0;
        v55 = v4;
        v56 = &v59[v53];
        do
        {
          result = (_BYTE *)(((v10 & 0x1F) * (unsigned __int16)v56[v54 + 66]
                            + (32 - (v10 & 0x1F)) * (unsigned __int16)v56[v54 + 65]
                            + 16) >> 5);
          *v55 = (_WORD)result;
          ++v54;
          v55 = (_WORD *)((char *)v55 + v52);
        }
        while (v54 != 64);
      }
      else
      {
        v57 = 0;
        v58 = v4;
        do
        {
          *v58 = *(_WORD *)&v60[2 * v53 + 2 + v57];
          v57 += 2;
          v58 = (_WORD *)((char *)v58 + v52);
        }
        while (v57 != 128);
      }
      ++v51;
      v10 += v7;
      ++v4;
    }
    while (v51 != 64);
  }
  else
  {
    if (v11 >= 0xF)
    {
      v33 = 0;
      for (i = 0; i != 129; ++i)
      {
        v35 = i + 127;
        if (!v33)
          v35 = -1;
        *(_WORD *)&v60[v33] = *(_WORD *)(a2 + 2 * v35);
        v33 += 2;
      }
    }
    else
    {
      v12 = 2 * v7;
      v13 = word_1B6921880[a1 - 11];
      if ((v7 & 0x40000000) != 0)
        v14 = -1;
      else
        v14 = 2 * v7;
      v15 = v12 - (unint64_t)(unsigned __int16)(v14 + 1);
      v16 = &v59[v12 + 64];
      v17 = v13 * v12 + 128;
      do
      {
        *v16++ = *(_WORD *)(a2 + 2 * ((v17 >> 8) - 1));
        v17 += v13;
        v18 = __CFADD__(v15++, 1);
      }
      while (!v18);
      v19 = 0;
      for (j = 0; j != 65; ++j)
      {
        v21 = j + 127;
        if (!v19)
          v21 = -1;
        *(_WORD *)&v60[v19] = *(_WORD *)(a2 + 2 * v21);
        v19 += 2;
      }
    }
    v36 = 0;
    v37 = 2 * a3;
    v38 = a4;
    do
    {
      v39 = (uint64_t)v10 >> 5;
      v40 = v10 & 0x1F;
      if ((v10 & 0x1F) != 0)
      {
        v41 = 0;
        v42 = &v59[v39];
        do
        {
          result = &v42[v41];
          v43 = (uint16x8_t)vdupq_n_s16(32 - v40);
          v44 = (uint16x8_t)vdupq_n_s16(v40);
          *(int16x8_t *)&v38[v41] = vrshrn_high_n_s32(vrshrn_n_s32((int32x4_t)vmlal_u16(vmull_u16(*(uint16x4_t *)v43.i8, *(uint16x4_t *)&v42[v41 + 65]), *(uint16x4_t *)v44.i8, *(uint16x4_t *)&v42[v41 + 66]), 5uLL), (int32x4_t)vmlal_high_u16(vmull_high_u16(v43, *(uint16x8_t *)&v42[v41 + 65]), v44, *(uint16x8_t *)&v42[v41 + 66]), 5uLL);
          v41 += 8;
        }
        while (v41 != 64);
      }
      else
      {
        v45 = &v60[2 * v39 + 2];
        v46 = v45[5];
        v47 = (_OWORD *)((char *)a4 + v37 * v36);
        v47[4] = v45[4];
        v47[5] = v46;
        v48 = v45[7];
        v47[6] = v45[6];
        v47[7] = v48;
        v49 = v45[1];
        *v47 = *v45;
        v47[1] = v49;
        v50 = v45[3];
        v47[2] = v45[2];
        v47[3] = v50;
      }
      ++v36;
      v10 += v7;
      v38 = (_WORD *)((char *)v38 + v37);
    }
    while (v36 != 64);
  }
  return result;
}

uint64_t sub_1B67D346C(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  int v8;
  int v9;
  int v10;
  _WORD *v11;
  uint64_t result;

  v4 = 0;
  v5 = a2 + 16;
  do
  {
    v6 = 0;
    v7 = &a2[2 * v4];
    v8 = 3;
    v9 = 3 - v4++;
    v10 = 1;
    do
    {
      v11 = (_WORD *)(a4 + v6 * 2);
      *v11 = (v10 * a2[24] + v8 * *v7 + v9 * v5[v6] + v4 * a2[8] + 4) >> 3;
      result = v5[v6 + 1];
      v11[1] = (v10 * a2[25] + v8 * v7[1] + v9 * (_DWORD)result + v4 * a2[9] + 4) >> 3;
      --v8;
      v6 += 2;
      ++v10;
    }
    while (v6 != 8);
    a4 += 2 * a3;
  }
  while (v4 != 4);
  return result;
}

uint64_t sub_1B67D3514(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  int v8;
  int v9;
  int v10;
  _WORD *v11;
  uint64_t result;

  v4 = 0;
  v5 = a2 + 32;
  do
  {
    v6 = 0;
    v7 = &a2[2 * v4];
    v8 = 7;
    v9 = 7 - v4++;
    v10 = 1;
    do
    {
      v11 = (_WORD *)(a4 + v6 * 2);
      *v11 = (v10 * a2[48] + v8 * *v7 + v9 * v5[v6] + v4 * a2[16] + 8) >> 4;
      result = v5[v6 + 1];
      v11[1] = (v10 * a2[49] + v8 * v7[1] + v9 * (_DWORD)result + v4 * a2[17] + 8) >> 4;
      --v8;
      v6 += 2;
      ++v10;
    }
    while (v6 != 16);
    a4 += 2 * a3;
  }
  while (v4 != 8);
  return result;
}

uint64_t sub_1B67D35BC(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  int v8;
  int v9;
  int v10;
  _WORD *v11;
  uint64_t result;

  v4 = 0;
  v5 = a2 + 64;
  do
  {
    v6 = 0;
    v7 = &a2[2 * v4];
    v8 = 15;
    v9 = 15 - v4++;
    v10 = 1;
    do
    {
      v11 = (_WORD *)(a4 + v6 * 2);
      *v11 = (v10 * a2[96] + v8 * *v7 + v9 * v5[v6] + v4 * a2[32] + 16) >> 5;
      result = v5[v6 + 1];
      v11[1] = (v10 * a2[97] + v8 * v7[1] + v9 * (_DWORD)result + v4 * a2[33] + 16) >> 5;
      --v8;
      v6 += 2;
      ++v10;
    }
    while (v6 != 32);
    a4 += 2 * a3;
  }
  while (v4 != 16);
  return result;
}

uint64_t sub_1B67D3664(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  int v8;
  int v9;
  int v10;
  _WORD *v11;
  uint64_t result;

  v4 = 0;
  v5 = a2 + 128;
  do
  {
    v6 = 0;
    v7 = &a2[2 * v4];
    v8 = 31;
    v9 = 31 - v4++;
    v10 = 1;
    do
    {
      v11 = (_WORD *)(a4 + v6 * 2);
      *v11 = (v10 * a2[192] + v8 * *v7 + v9 * v5[v6] + v4 * a2[64] + 32) >> 6;
      result = v5[v6 + 1];
      v11[1] = (v10 * a2[193] + v8 * v7[1] + v9 * (_DWORD)result + v4 * a2[65] + 32) >> 6;
      --v8;
      v6 += 2;
      ++v10;
    }
    while (v6 != 64);
    a4 += 2 * a3;
  }
  while (v4 != 32);
  return result;
}

__n128 sub_1B67D370C(uint64_t a1, __n128 *a2, uint64_t a3, __n128 *a4)
{
  __n128 *v4;
  int v5;
  __n128 result;

  v4 = a2 + 2;
  v5 = 4;
  do
  {
    result = *v4;
    *a4 = *v4;
    a4 = (__n128 *)((char *)a4 + 2 * a3);
    --v5;
  }
  while (v5);
  return result;
}

__n128 sub_1B67D3730(uint64_t a1, __n128 *a2, uint64_t a3, __n128 *a4)
{
  __n128 *v4;
  int v5;
  __n128 result;
  __n128 v7;

  v4 = a2 + 4;
  v5 = 8;
  do
  {
    result = *v4;
    v7 = a2[5];
    *a4 = *v4;
    a4[1] = v7;
    a4 = (__n128 *)((char *)a4 + 2 * a3);
    --v5;
  }
  while (v5);
  return result;
}

__n128 sub_1B67D3754(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  __n128 result;
  __int128 v6;
  __int128 v7;

  v4 = 16;
  do
  {
    result = *(__n128 *)(a2 + 128);
    v6 = *(_OWORD *)(a2 + 144);
    v7 = *(_OWORD *)(a2 + 176);
    *(_OWORD *)(a4 + 32) = *(_OWORD *)(a2 + 160);
    *(_OWORD *)(a4 + 48) = v7;
    *(__n128 *)a4 = result;
    *(_OWORD *)(a4 + 16) = v6;
    a4 += 2 * a3;
    --v4;
  }
  while (v4);
  return result;
}

__n128 sub_1B67D3780(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __n128 result;
  __int128 v9;
  __int128 v10;

  v4 = 32;
  do
  {
    v5 = *(_OWORD *)(a2 + 256);
    v6 = *(_OWORD *)(a2 + 272);
    v7 = *(_OWORD *)(a2 + 304);
    *(_OWORD *)(a4 + 32) = *(_OWORD *)(a2 + 288);
    *(_OWORD *)(a4 + 48) = v7;
    *(_OWORD *)a4 = v5;
    *(_OWORD *)(a4 + 16) = v6;
    result = *(__n128 *)(a2 + 320);
    v9 = *(_OWORD *)(a2 + 336);
    v10 = *(_OWORD *)(a2 + 368);
    *(_OWORD *)(a4 + 96) = *(_OWORD *)(a2 + 352);
    *(_OWORD *)(a4 + 112) = v10;
    *(__n128 *)(a4 + 64) = result;
    *(_OWORD *)(a4 + 80) = v9;
    a4 += 2 * a3;
    --v4;
  }
  while (v4);
  return result;
}

float32x4_t sub_1B67D37BC(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4)
{
  uint64_t i;
  const float *v5;
  float32x4_t result;

  for (i = 0; i != 16; i += 4)
  {
    v5 = (const float *)(a2 + i);
    result = vld1q_dup_f32(v5);
    *a4 = result;
    a4 = (float32x4_t *)((char *)a4 + ((2 * a3) & 0xFFFFFFFFFFFFFFFCLL));
  }
  return result;
}

float32x4_t sub_1B67D37E8(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4)
{
  uint64_t v4;
  float32x4_t *v5;
  const float *v6;
  float32x4_t result;

  v4 = 0;
  v5 = a4 + 1;
  do
  {
    v6 = (const float *)(a2 + v4);
    result = vld1q_dup_f32(v6);
    v5[-1] = result;
    *v5 = result;
    v4 += 4;
    v5 = (float32x4_t *)((char *)v5 + ((2 * a3) & 0xFFFFFFFFFFFFFFFCLL));
  }
  while (v4 != 32);
  return result;
}

void sub_1B67D3818(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t i;
  uint64_t v5;
  const float *v6;
  float32x4_t v7;

  for (i = 0; i != 16; ++i)
  {
    v5 = 0;
    v6 = (const float *)(a2 + 4 * i);
    v7 = vld1q_dup_f32(v6);
    do
    {
      *(float32x4_t *)(a4 + v5) = v7;
      v5 += 16;
    }
    while (v5 != 64);
    a4 += (2 * a3) & 0xFFFFFFFFFFFFFFFCLL;
  }
}

void sub_1B67D3854(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t i;
  uint64_t v5;
  const float *v6;
  float32x4_t v7;

  for (i = 0; i != 32; ++i)
  {
    v5 = 0;
    v6 = (const float *)(a2 + 4 * i);
    v7 = vld1q_dup_f32(v6);
    do
    {
      *(float32x4_t *)(a4 + v5) = v7;
      v5 += 16;
    }
    while (v5 != 128);
    a4 += (2 * a3) & 0xFFFFFFFFFFFFFFFCLL;
  }
}

int32x4_t sub_1B67D3890(uint64_t a1, const __int16 *a2, uint64_t a3, int32x4_t *a4)
{
  const __int16 *v4;
  int v5;
  int32x4_t result;
  int16x4x2_t v7;
  int16x4x2_t v8;

  v4 = a2 + 16;
  v7 = vld2_s16(v4);
  v8 = vld2_s16(a2);
  *a4 = vdupq_n_s32((vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16((uint16x4_t)v7.val[1], (uint16x4_t)v8.val[1]), (int32x4_t)xmmword_1B69175E0)) << 13) & 0xFFFF0000 | (unsigned __int16)(vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16((uint16x4_t)v7.val[0], (uint16x4_t)v8.val[0]), (int32x4_t)xmmword_1B69175E0)) >> 3));
  v5 = 3;
  do
  {
    result = *a4;
    a4 = (int32x4_t *)((char *)a4 + 2 * a3);
    *a4 = result;
    --v5;
  }
  while (v5);
  return result;
}

int16x8_t sub_1B67D38F4(uint64_t a1, const __int16 *a2, uint64_t a3, int16x8_t *a4)
{
  const __int16 *v4;
  int v5;
  int16x8_t result;
  int16x8_t v7;
  int16x8x2_t v8;
  int16x8x2_t v9;

  v4 = a2 + 32;
  v8 = vld2q_s16(v4);
  v9 = vld2q_s16(a2);
  v8.val[0] = (int16x8_t)vdupq_n_s32((vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v8.val[1].i8, *(uint16x4_t *)v9.val[1].i8), (int32x4_t)vaddl_high_u16((uint16x8_t)v8.val[1], (uint16x8_t)v9.val[1])), (int32x4_t)xmmword_1B69175F0)) << 12) & 0xFFFF0000 | (unsigned __int16)(vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v8.val[0].i8, *(uint16x4_t *)v9.val[0].i8), (int32x4_t)vaddl_high_u16((uint16x8_t)v8.val[0], (uint16x8_t)v9.val[0])), (int32x4_t)xmmword_1B69175F0)) >> 4));
  *a4 = v8.val[0];
  a4[1] = v8.val[0];
  v5 = 7;
  do
  {
    result = *a4;
    v7 = a4[1];
    a4 = (int16x8_t *)((char *)a4 + 2 * a3);
    *a4 = result;
    a4[1] = v7;
    --v5;
  }
  while (v5);
  return result;
}

__n128 sub_1B67D3968(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  int32x4_t v5;
  int32x4_t v6;
  int32x4_t v7;
  int32x4_t v8;
  const __int16 *v9;
  const __int16 *v10;
  uint64_t v11;
  int32x4_t v12;
  int v13;
  __n128 result;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  int16x8x2_t v18;
  int16x8x2_t v19;

  v4 = 0;
  v5 = (int32x4_t)xmmword_1B6917600;
  v6 = 0uLL;
  v7 = (int32x4_t)xmmword_1B6917600;
  v8 = 0uLL;
  do
  {
    v9 = (const __int16 *)(a2 + v4);
    v10 = (const __int16 *)(a2 + v4 + 128);
    v18 = vld2q_s16(v10);
    v19 = vld2q_s16(v9);
    v6 = (int32x4_t)vaddw_high_u16(vaddw_high_u16((uint32x4_t)v6, (uint16x8_t)v18.val[0]), (uint16x8_t)v19.val[0]);
    v5 = (int32x4_t)vaddw_u16(vaddw_u16((uint32x4_t)v5, *(uint16x4_t *)v18.val[0].i8), *(uint16x4_t *)v19.val[0].i8);
    v8 = (int32x4_t)vaddw_high_u16(vaddw_high_u16((uint32x4_t)v8, (uint16x8_t)v18.val[1]), (uint16x8_t)v19.val[1]);
    v7 = (int32x4_t)vaddw_u16(vaddw_u16((uint32x4_t)v7, *(uint16x4_t *)v18.val[1].i8), *(uint16x4_t *)v19.val[1].i8);
    v4 += 32;
  }
  while (v4 != 64);
  v11 = 0;
  v12 = vdupq_n_s32((vaddvq_s32(vaddq_s32(v7, v8)) << 11) & 0xFFFF0000 | (unsigned __int16)(vaddvq_s32(vaddq_s32(v5, v6)) >> 5));
  do
  {
    *(int32x4_t *)(a4 + v11) = v12;
    v11 += 16;
  }
  while (v11 != 64);
  v13 = 15;
  do
  {
    result = *(__n128 *)a4;
    v15 = *(_OWORD *)(a4 + 16);
    v16 = *(_OWORD *)(a4 + 32);
    v17 = *(_OWORD *)(a4 + 48);
    a4 += 2 * a3;
    *(_OWORD *)(a4 + 32) = v16;
    *(_OWORD *)(a4 + 48) = v17;
    *(__n128 *)a4 = result;
    *(_OWORD *)(a4 + 16) = v15;
    --v13;
  }
  while (v13);
  return result;
}

__n128 sub_1B67D3A1C(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  uint64_t v4;
  int32x4_t v5;
  int32x4_t v6;
  int32x4_t v7;
  int32x4_t v8;
  const __int16 *v9;
  const __int16 *v10;
  uint64_t v11;
  int32x4_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __n128 result;
  __int128 v20;
  __int128 v21;
  int16x8x2_t v22;
  int16x8x2_t v23;

  v4 = 0;
  v5 = (int32x4_t)xmmword_1B6917610;
  v6 = 0uLL;
  v7 = (int32x4_t)xmmword_1B6917610;
  v8 = 0uLL;
  do
  {
    v9 = (const __int16 *)(a2 + v4);
    v10 = (const __int16 *)(a2 + v4 + 256);
    v22 = vld2q_s16(v10);
    v23 = vld2q_s16(v9);
    v6 = (int32x4_t)vaddw_high_u16(vaddw_high_u16((uint32x4_t)v6, (uint16x8_t)v22.val[0]), (uint16x8_t)v23.val[0]);
    v5 = (int32x4_t)vaddw_u16(vaddw_u16((uint32x4_t)v5, *(uint16x4_t *)v22.val[0].i8), *(uint16x4_t *)v23.val[0].i8);
    v8 = (int32x4_t)vaddw_high_u16(vaddw_high_u16((uint32x4_t)v8, (uint16x8_t)v22.val[1]), (uint16x8_t)v23.val[1]);
    v7 = (int32x4_t)vaddw_u16(vaddw_u16((uint32x4_t)v7, *(uint16x4_t *)v22.val[1].i8), *(uint16x4_t *)v23.val[1].i8);
    v4 += 32;
  }
  while (v4 != 128);
  v11 = 0;
  v12 = vdupq_n_s32((vaddvq_s32(vaddq_s32(v7, v8)) << 10) & 0xFFFF0000 | (unsigned __int16)(vaddvq_s32(vaddq_s32(v5, v6)) >> 6));
  do
    a4[v11++] = (__int128)v12;
  while (v11 != 8);
  v13 = 2 * a3;
  v14 = 31;
  do
  {
    v15 = (uint64_t)a4 + v13;
    v16 = *a4;
    v17 = a4[1];
    v18 = a4[3];
    *(_OWORD *)(v15 + 32) = a4[2];
    *(_OWORD *)(v15 + 48) = v18;
    *(_OWORD *)v15 = v16;
    *(_OWORD *)(v15 + 16) = v17;
    result = (__n128)a4[4];
    v20 = a4[5];
    v21 = a4[7];
    *(_OWORD *)(v15 + 96) = a4[6];
    *(_OWORD *)(v15 + 112) = v21;
    *(__n128 *)(v15 + 64) = result;
    *(_OWORD *)(v15 + 80) = v20;
    a4 = (__int128 *)((char *)a4 + v13);
    --v14;
  }
  while (v14);
  return result;
}

uint64_t sub_1B67D3AE4(uint64_t result, uint64_t a2, uint64_t a3, int16x8_t *a4)
{
  int v4;
  unint64_t v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  _DWORD *v10;
  int v11;
  uint64_t v12;
  __int128 *v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  _DWORD *v19;
  int v20;
  signed int v21;
  uint64_t v22;
  __int128 *v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  int v27;
  int16x8_t *v28;
  int v29;
  unsigned int v30;
  uint16x8_t v31;
  uint16x8_t v32;
  uint32x4_t v33;
  uint32x4_t v34;
  uint16x8_t v35;
  uint16x8_t v36;
  uint64_t v37;
  uint64_t v38;
  __int32 *v39;
  uint64_t v40;
  __int8 *v41;
  uint64_t v42;
  __int32 *v43;
  int v44;
  _DWORD v45[4];
  __int128 v46;
  __int128 v47;
  int v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v4 = byte_1B6921758[(int)result];
  v5 = (int)result - 11;
  if ((int)result < 18)
  {
    if (v5 >= 0xF)
    {
      v25 = *(_OWORD *)(a2 + 12);
      v46 = *(_OWORD *)(a2 - 4);
      v47 = v25;
      v48 = *(_DWORD *)(a2 + 28);
    }
    else
    {
      v15 = v4 >> 3;
      v16 = word_1B6921880[(int)result - 11];
      if (v4 >> 3 < 0)
        v17 = -1;
      else
        v17 = v4 >> 3;
      v18 = v17 - (uint64_t)v15 + 1;
      v19 = &v45[v15 + 4];
      v20 = v16 * v15 + 128;
      do
      {
        v21 = ((v20 >> 7) & 0xFFFFFFFE) + 14;
        if (v20 < 0x100)
          v21 = -2;
        *v19++ = *(_DWORD *)(a2 + 2 * v21);
        v20 += v16;
        --v18;
      }
      while (v18);
      v46 = *(_OWORD *)(a2 - 4);
      LODWORD(v47) = *(_DWORD *)(a2 + 12);
    }
  }
  else if (v5 >= 0xF)
  {
    v22 = 14;
    v23 = &v46;
    do
    {
      if (v22 == 14)
        v24 = -2;
      else
        v24 = v22;
      *(_DWORD *)v23 = *(_DWORD *)(a2 + 2 * v24);
      v23 = (__int128 *)((char *)v23 + 4);
      v22 += 2;
    }
    while (v22 != 32);
  }
  else
  {
    v6 = v4 >> 3;
    v7 = word_1B6921880[(result - 11)];
    if (v4 >> 3 < 0)
      v8 = -1;
    else
      v8 = v4 >> 3;
    v9 = v8 - (uint64_t)v6 + 1;
    v10 = &v45[v6 + 4];
    v11 = v7 * v6 + 128;
    do
    {
      *v10++ = *(_DWORD *)(a2 + 2 * (int)(((v11 >> 7) & 0xFFFFFFFE) - 2));
      v11 += v7;
      --v9;
    }
    while (v9);
    v12 = 14;
    v13 = &v46;
    do
    {
      if (v12 == 14)
        v14 = -2;
      else
        v14 = v12;
      *(_DWORD *)v13 = *(_DWORD *)(a2 + 2 * v14);
      v13 = (__int128 *)((char *)v13 + 4);
      v12 += 2;
    }
    while (v12 != 24);
  }
  v26 = 4;
  v27 = v4;
  v28 = a4;
  do
  {
    v29 = v27 >> 5;
    v30 = v27 & 0x1F;
    if ((v27 & 0x1F) != 0)
    {
      v31 = (uint16x8_t)vdupq_n_s16(32 - v30);
      v32 = *(uint16x8_t *)((char *)&v46 + 4 * v29 + 4);
      v33 = vmull_u16(*(uint16x4_t *)v31.i8, *(uint16x4_t *)v32.i8);
      v34 = vmull_high_u16(v31, v32);
      v35 = (uint16x8_t)vdupq_n_s16(v30);
      v36 = *(uint16x8_t *)((char *)&v46 + 4 * v29 + 8);
      *v28 = vrshrn_high_n_s32(vrshrn_n_s32((int32x4_t)vmlal_u16(v33, *(uint16x4_t *)v35.i8, *(uint16x4_t *)v36.i8), 5uLL), (int32x4_t)vmlal_high_u16(v34, v35, v36), 5uLL);
    }
    else
    {
      *v28 = *(int16x8_t *)((char *)&v46 + 4 * v29 + 4);
    }
    v28 = (int16x8_t *)((char *)v28 + 2 * a3);
    v27 += v4;
    --v26;
  }
  while (v26);
  if ((int)result <= 17)
  {
    v37 = 0;
    v38 = 4 * (a3 >> 1);
    v39 = &a4->i32[(unint64_t)v38 / 4];
    v40 = v38 + 4;
    v41 = &a4->i8[4];
    do
    {
      v42 = 0;
      v43 = v39;
      do
      {
        v44 = *(_DWORD *)&v41[4 * v42];
        *(_DWORD *)&v41[4 * v42] = *v43;
        *v43 = v44;
        ++v42;
        v43 = (__int32 *)((char *)v43 + v38);
      }
      while (v37 + v42 != 3);
      ++v37;
      v39 = (__int32 *)((char *)v39 + v40);
      v41 += v40;
    }
    while (v37 != 3);
  }
  return result;
}

uint64_t sub_1B67D3D94(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  unint64_t v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  _DWORD *v10;
  int v11;
  uint64_t v12;
  __int128 *v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  _DWORD *v19;
  int v20;
  signed int v21;
  __int128 v22;
  uint64_t v23;
  __int128 *v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  unsigned int v33;
  uint64_t i;
  _WORD *v35;
  uint16x8_t v36;
  uint16x8_t v37;
  uint64_t v38;
  _OWORD *v39;
  __int128 v40;
  _OWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  _WORD v47[16];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  int v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = byte_1B6921758[(int)result];
  v5 = (int)result - 11;
  if ((int)result < 18)
  {
    if (v5 >= 0xF)
    {
      v26 = *(_OWORD *)(a2 + 12);
      v27 = *(_OWORD *)(a2 + 44);
      v50 = *(_OWORD *)(a2 + 28);
      v51 = v27;
      v52 = *(_DWORD *)(a2 + 60);
      v48 = *(_OWORD *)(a2 - 4);
      v49 = v26;
    }
    else
    {
      v15 = v4 >> 2;
      v16 = word_1B6921880[(int)result - 11];
      if (v4 >> 2 < 0)
        v17 = -1;
      else
        v17 = v4 >> 2;
      v18 = v17 - (uint64_t)v15 + 1;
      v19 = &v47[2 * v15 + 16];
      v20 = v16 * v15 + 128;
      do
      {
        v21 = ((v20 >> 7) & 0xFFFFFFFE) + 30;
        if (v20 < 0x100)
          v21 = -2;
        *v19++ = *(_DWORD *)(a2 + 2 * v21);
        v20 += v16;
        --v18;
      }
      while (v18);
      v22 = *(_OWORD *)(a2 + 12);
      v48 = *(_OWORD *)(a2 - 4);
      v49 = v22;
      LODWORD(v50) = *(_DWORD *)(a2 + 28);
    }
  }
  else if (v5 >= 0xF)
  {
    v23 = 30;
    v24 = &v48;
    do
    {
      if (v23 == 30)
        v25 = -2;
      else
        v25 = v23;
      *(_DWORD *)v24 = *(_DWORD *)(a2 + 2 * v25);
      v24 = (__int128 *)((char *)v24 + 4);
      v23 += 2;
    }
    while (v23 != 64);
  }
  else
  {
    v6 = v4 >> 2;
    v7 = word_1B6921880[(result - 11)];
    if (v4 >> 2 < 0)
      v8 = -1;
    else
      v8 = v4 >> 2;
    v9 = v8 - (uint64_t)v6 + 1;
    v10 = &v47[2 * v6 + 16];
    v11 = v7 * v6 + 128;
    do
    {
      *v10++ = *(_DWORD *)(a2 + 2 * (int)(((v11 >> 7) & 0xFFFFFFFE) - 2));
      v11 += v7;
      --v9;
    }
    while (v9);
    v12 = 30;
    v13 = &v48;
    do
    {
      if (v12 == 30)
        v14 = -2;
      else
        v14 = v12;
      *(_DWORD *)v13 = *(_DWORD *)(a2 + 2 * v14);
      v13 = (__int128 *)((char *)v13 + 4);
      v12 += 2;
    }
    while (v12 != 48);
  }
  v28 = 0;
  v29 = a4;
  do
  {
    v30 = v28 + 1;
    v31 = (v28 + 1) * v4;
    v32 = v31 >> 5;
    v33 = v31 & 0x1F;
    if (v33)
    {
      for (i = 0; i != 16; i += 8)
      {
        v36 = (uint16x8_t)vdupq_n_s16(32 - v33);
        v37 = (uint16x8_t)vdupq_n_s16(v33);
        v35 = &v47[2 * v32];
        *(int16x8_t *)(v29 + i * 2) = vrshrn_high_n_s32(vrshrn_n_s32((int32x4_t)vmlal_u16(vmull_u16(*(uint16x4_t *)v36.i8, *(uint16x4_t *)&v35[i + 18]), *(uint16x4_t *)v37.i8, *(uint16x4_t *)&v35[i + 20]), 5uLL), (int32x4_t)vmlal_high_u16(vmull_high_u16(v36, *(uint16x8_t *)&v35[i + 18]), v37, *(uint16x8_t *)&v35[i + 20]), 5uLL);
      }
    }
    else
    {
      v38 = v28 * a3;
      v39 = (__int128 *)((char *)&v48 + 4 * v32 + 4);
      v40 = v39[1];
      v41 = (_OWORD *)(a4 + 2 * v38);
      *v41 = *v39;
      v41[1] = v40;
    }
    v29 += 2 * a3;
    v28 = v30;
  }
  while (v30 != 8);
  if ((int)result <= 17)
  {
    v42 = 0;
    v43 = 4 * (a3 >> 1);
    do
    {
      v44 = 4 * (a3 >> 1);
      v45 = 1;
      do
      {
        v46 = *(_DWORD *)(a4 + 4 * v45);
        *(_DWORD *)(a4 + 4 * v45) = *(_DWORD *)(a4 + v44);
        *(_DWORD *)(a4 + v44) = v46;
        ++v45;
        v44 += v43;
      }
      while (v42 + v45 != 8);
      ++v42;
      a4 += v43 + 4;
    }
    while (v42 != 7);
  }
  return result;
}

uint64_t sub_1B67D4070(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  unint64_t v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  _DWORD *v10;
  int v11;
  uint64_t v12;
  __int128 *v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  _DWORD *v19;
  int v20;
  signed int v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  __int128 *v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  unsigned int v36;
  uint64_t i;
  _WORD *v38;
  uint16x8_t v39;
  uint16x8_t v40;
  _OWORD *v41;
  _OWORD *v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  _WORD v50[32];
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  int v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v4 = byte_1B6921758[(int)result];
  v5 = (int)result - 11;
  if ((int)result < 18)
  {
    if (v5 >= 0xF)
    {
      v27 = *(_OWORD *)(a2 + 76);
      v28 = *(_OWORD *)(a2 + 108);
      v57 = *(_OWORD *)(a2 + 92);
      v58 = v28;
      v59 = *(_DWORD *)(a2 + 124);
      v29 = *(_OWORD *)(a2 + 12);
      v30 = *(_OWORD *)(a2 + 44);
      v53 = *(_OWORD *)(a2 + 28);
      v54 = v30;
      v55 = *(_OWORD *)(a2 + 60);
      v56 = v27;
      v51 = *(_OWORD *)(a2 - 4);
      v52 = v29;
    }
    else
    {
      v15 = v4 >> 1;
      v16 = word_1B6921880[(int)result - 11];
      if (v4 >> 1 < 0)
        v17 = -1;
      else
        v17 = v4 >> 1;
      v18 = v17 - (uint64_t)v15 + 1;
      v19 = &v50[2 * v15 + 32];
      v20 = v16 * v15 + 128;
      do
      {
        v21 = ((v20 >> 7) & 0xFFFFFFFE) + 62;
        if (v20 < 0x100)
          v21 = -2;
        *v19++ = *(_DWORD *)(a2 + 2 * v21);
        v20 += v16;
        --v18;
      }
      while (v18);
      v22 = *(_OWORD *)(a2 + 12);
      v23 = *(_OWORD *)(a2 + 44);
      v53 = *(_OWORD *)(a2 + 28);
      v54 = v23;
      LODWORD(v55) = *(_DWORD *)(a2 + 60);
      v51 = *(_OWORD *)(a2 - 4);
      v52 = v22;
    }
  }
  else if (v5 >= 0xF)
  {
    v24 = 62;
    v25 = &v51;
    do
    {
      if (v24 == 62)
        v26 = -2;
      else
        v26 = v24;
      *(_DWORD *)v25 = *(_DWORD *)(a2 + 2 * v26);
      v25 = (__int128 *)((char *)v25 + 4);
      v24 += 2;
    }
    while (v24 != 128);
  }
  else
  {
    v6 = v4 >> 1;
    v7 = word_1B6921880[(result - 11)];
    if (v4 >> 1 < 0)
      v8 = -1;
    else
      v8 = v4 >> 1;
    v9 = v8 - (uint64_t)v6 + 1;
    v10 = &v50[2 * v6 + 32];
    v11 = v7 * v6 + 128;
    do
    {
      *v10++ = *(_DWORD *)(a2 + 2 * (int)(((v11 >> 7) & 0xFFFFFFFE) - 2));
      v11 += v7;
      --v9;
    }
    while (v9);
    v12 = 62;
    v13 = &v51;
    do
    {
      if (v12 == 62)
        v14 = -2;
      else
        v14 = v12;
      *(_DWORD *)v13 = *(_DWORD *)(a2 + 2 * v14);
      v13 = (__int128 *)((char *)v13 + 4);
      v12 += 2;
    }
    while (v12 != 96);
  }
  v31 = 0;
  v32 = a4;
  do
  {
    v33 = v31 + 1;
    v34 = (v31 + 1) * v4;
    v35 = v34 >> 5;
    v36 = v34 & 0x1F;
    if (v36)
    {
      for (i = 0; i != 32; i += 8)
      {
        v39 = (uint16x8_t)vdupq_n_s16(32 - v36);
        v40 = (uint16x8_t)vdupq_n_s16(v36);
        v38 = &v50[2 * v35];
        *(int16x8_t *)(v32 + i * 2) = vrshrn_high_n_s32(vrshrn_n_s32((int32x4_t)vmlal_u16(vmull_u16(*(uint16x4_t *)v39.i8, *(uint16x4_t *)&v38[i + 34]), *(uint16x4_t *)v40.i8, *(uint16x4_t *)&v38[i + 36]), 5uLL), (int32x4_t)vmlal_high_u16(vmull_high_u16(v39, *(uint16x8_t *)&v38[i + 34]), v40, *(uint16x8_t *)&v38[i + 36]), 5uLL);
      }
    }
    else
    {
      v41 = (_OWORD *)(a4 + 2 * v31 * a3);
      v42 = (__int128 *)((char *)&v51 + 4 * v35 + 4);
      v43 = v42[1];
      *v41 = *v42;
      v41[1] = v43;
      v44 = v42[3];
      v41[2] = v42[2];
      v41[3] = v44;
    }
    v32 += 2 * a3;
    v31 = v33;
  }
  while (v33 != 16);
  if ((int)result <= 17)
  {
    v45 = 0;
    v46 = 4 * (a3 >> 1);
    do
    {
      v47 = 4 * (a3 >> 1);
      v48 = 1;
      do
      {
        v49 = *(_DWORD *)(a4 + 4 * v48);
        *(_DWORD *)(a4 + 4 * v48) = *(_DWORD *)(a4 + v47);
        *(_DWORD *)(a4 + v47) = v49;
        ++v48;
        v47 += v46;
      }
      while (v45 + v48 != 16);
      ++v45;
      a4 += v46 + 4;
    }
    while (v45 != 15);
  }
  return result;
}

void *sub_1B67D4378(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  _DWORD *v13;
  int v14;
  uint64_t v15;
  _DWORD *v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  _DWORD *v21;
  int v22;
  signed int v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  _DWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  unsigned int v36;
  uint64_t v37;
  _WORD *v38;
  uint16x8_t v39;
  uint16x8_t v40;
  _OWORD *v41;
  __int128 v42;
  _OWORD *v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  _WORD v52[64];
  _OWORD v53[40];
  uint64_t v54;

  v6 = (int)result;
  v54 = *MEMORY[0x1E0C80C00];
  v7 = byte_1B6921758[(int)result];
  v8 = byte_1B6921758[(int)result];
  v9 = (int)result - 11;
  if ((int)result < 18)
  {
    if (v9 >= 0xF)
    {
      result = memcpy(v53, (const void *)(a2 - 4), 0x104uLL);
    }
    else
    {
      v18 = word_1B6921880[(int)result - 11];
      if ((int)v8 < 0)
        v19 = -1;
      else
        v19 = byte_1B6921758[(int)result];
      v20 = v19 - v8 + 1;
      v21 = &v52[2 * v8 + 64];
      v22 = v8 * v18 + 128;
      do
      {
        v23 = ((v22 >> 7) & 0xFFFFFFFE) + 126;
        if (v22 < 0x100)
          v23 = -2;
        *v21++ = *(_DWORD *)(a2 + 2 * v23);
        v22 += v18;
        --v20;
      }
      while (v20);
      v24 = *(_OWORD *)(a2 + 76);
      v25 = *(_OWORD *)(a2 + 108);
      v53[6] = *(_OWORD *)(a2 + 92);
      v53[7] = v25;
      LODWORD(v53[8]) = *(_DWORD *)(a2 + 124);
      v26 = *(_OWORD *)(a2 + 12);
      v27 = *(_OWORD *)(a2 + 44);
      v53[2] = *(_OWORD *)(a2 + 28);
      v53[3] = v27;
      v53[4] = *(_OWORD *)(a2 + 60);
      v53[5] = v24;
      v53[0] = *(_OWORD *)(a2 - 4);
      v53[1] = v26;
    }
  }
  else if (v9 >= 0xF)
  {
    v28 = 126;
    v29 = v53;
    do
    {
      if (v28 == 126)
        v30 = -2;
      else
        v30 = v28;
      *v29++ = *(_DWORD *)(a2 + 2 * v30);
      v28 += 2;
    }
    while (v28 != 256);
  }
  else
  {
    v10 = word_1B6921880[(_DWORD)result - 11];
    if ((int)v8 < 0)
      v11 = -1;
    else
      v11 = byte_1B6921758[(int)result];
    v12 = v11 - v8 + 1;
    v13 = &v52[2 * v8 + 64];
    v14 = v7 * v10 + 128;
    do
    {
      *v13++ = *(_DWORD *)(a2 + 2 * (int)(((v14 >> 7) & 0xFFFFFFFE) - 2));
      v14 += v10;
      --v12;
    }
    while (v12);
    v15 = 126;
    v16 = v53;
    do
    {
      if (v15 == 126)
        v17 = -2;
      else
        v17 = v15;
      *v16++ = *(_DWORD *)(a2 + 2 * v17);
      v15 += 2;
    }
    while (v15 != 192);
  }
  v31 = 0;
  v32 = a4;
  do
  {
    v33 = v31 + 1;
    v34 = (v31 + 1) * v7;
    v35 = v34 >> 5;
    v36 = v34 & 0x1F;
    if (v36)
    {
      v37 = 0;
      v38 = &v52[2 * v35];
      do
      {
        result = &v38[v37];
        v39 = (uint16x8_t)vdupq_n_s16(32 - v36);
        v40 = (uint16x8_t)vdupq_n_s16(v36);
        *(int16x8_t *)(v32 + v37 * 2) = vrshrn_high_n_s32(vrshrn_n_s32((int32x4_t)vmlal_u16(vmull_u16(*(uint16x4_t *)v39.i8, *(uint16x4_t *)&v38[v37 + 66]), *(uint16x4_t *)v40.i8, *(uint16x4_t *)&v38[v37 + 68]), 5uLL), (int32x4_t)vmlal_high_u16(vmull_high_u16(v39, *(uint16x8_t *)&v38[v37 + 66]), v40, *(uint16x8_t *)&v38[v37 + 68]), 5uLL);
        v37 += 8;
      }
      while (v37 != 64);
    }
    else
    {
      v41 = (_OWORD *)((char *)v53 + 4 * v35 + 4);
      v42 = v41[5];
      v43 = (_OWORD *)(a4 + 2 * v31 * a3);
      v43[4] = v41[4];
      v43[5] = v42;
      v44 = v41[7];
      v43[6] = v41[6];
      v43[7] = v44;
      v45 = v41[1];
      *v43 = *v41;
      v43[1] = v45;
      v46 = v41[3];
      v43[2] = v41[2];
      v43[3] = v46;
    }
    v32 += 2 * a3;
    v31 = v33;
  }
  while (v33 != 32);
  if (v6 <= 17)
  {
    v47 = 0;
    v48 = 4 * (a3 >> 1);
    do
    {
      v49 = 4 * (a3 >> 1);
      v50 = 1;
      do
      {
        v51 = *(_DWORD *)(a4 + 4 * v50);
        *(_DWORD *)(a4 + 4 * v50) = *(_DWORD *)(a4 + v49);
        *(_DWORD *)(a4 + v49) = v51;
        ++v50;
        v49 += v48;
      }
      while (v47 + v50 != 32);
      ++v47;
      a4 += v48 + 4;
    }
    while (v47 != 31);
  }
  return result;
}

uint64_t sub_1B67D469C(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  int v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (a2 >= 1)
  {
    v8 = result;
    v9 = 0;
    v10 = 10 - a3;
    v11 = 2 * a2;
    v12 = 2 * a4;
    do
    {
      v13 = 0;
      do
      {
        result = sub_1B67C9094(v8, a3);
        *(_WORD *)(a5 + v13) = (_DWORD)result << v10;
        v13 += 2;
      }
      while (v11 != v13);
      ++v9;
      a5 += v12;
    }
    while (v9 != a2);
  }
  return result;
}

uint64_t sub_1B67D4734(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v8;
  int v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;

  if (a2 >= 1)
  {
    v5 = a5;
    v8 = result;
    v9 = 0;
    v10 = a5 + 2;
    v17 = a2;
    v11 = 10 - a3;
    v12 = 4 * a2;
    v13 = 2 * a4;
    do
    {
      v14 = 0;
      do
      {
        *(_WORD *)(v5 + v14) = sub_1B67C9094(v8, a3) << v11;
        v14 += 4;
      }
      while (v12 != v14);
      ++v9;
      v5 += v13;
    }
    while (v9 != a2);
    v15 = 0;
    do
    {
      v16 = 0;
      do
      {
        result = sub_1B67C9094(v8, a3);
        *(_WORD *)(v10 + v16) = (_DWORD)result << v11;
        v16 += 4;
      }
      while (4 * v17 != v16);
      ++v15;
      v10 += v13;
    }
    while (v15 != a2);
  }
  return result;
}

void sub_1B67D4820(int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int16 *v20;
  __int16 *v21;
  uint64_t v22;
  uint64_t v23;
  __int16 *v24;
  __int16 *v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int16 *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __int16 *v38;
  __int16 *v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  __int16 *v47;
  __int16 *v48;
  _WORD *v49;
  __int16 *v50;
  _WORD *v51;
  uint64_t v52;
  __int16 v53;
  uint64_t v54;
  uint64_t v55;
  _WORD *v56;
  uint64_t v57;
  __int16 *v58;
  __int16 *v59;
  _WORD *v60;
  uint64_t v61;
  __int16 v62;
  uint64_t v63;

  if (a2)
  {
    v5 = (1 << a1);
    if ((int)v5 >= 8)
      v6 = 8;
    else
      v6 = v5;
    v7 = __clz(__rbit32(a2));
    if (v7 < 9)
      v8 = ((2 << a1) + (char)~byte_1B6920BFD[9 * a1 - 18 + v7]) * a3 - 1;
    else
      v8 = byte_1B6920BFD[9 * a1 - 27 + v7] - a3;
    LODWORD(v9) = ((int)v5 + 4) >> 3;
    v10 = *(_WORD *)(a4 + 2 * v8);
    if ((int)v5 >= 4)
    {
      v11 = 0;
      v12 = 2 << a1;
      if ((int)v9 <= 1)
        v13 = 1;
      else
        v13 = v9;
      if ((int)v5 >= 8)
        v14 = 8;
      else
        v14 = 1 << a1;
      v15 = v14;
      v16 = a5 + 2 * v12;
      v17 = -2 * v14;
      v18 = a4 + 2 * a3 * (v12 - 1);
      v19 = a3 * v14;
      v20 = (__int16 *)(v16 - 2);
      v21 = (__int16 *)(v18 - 2);
      v22 = -(uint64_t)v14;
      do
      {
        if (((a2 >> v11) & 1) != 0)
        {
          v23 = v6 + 1;
          v24 = v21;
          v25 = v20;
          do
          {
            v10 = *v24;
            *v25-- = *v24;
            v24 -= a3;
            --v23;
          }
          while (v23 > 1);
        }
        else
        {
          v26 = v22;
          do
          {
            *(_WORD *)(v16 + 2 * v26) = v10;
            v27 = __CFADD__(v26++, 1);
          }
          while (!v27);
        }
        ++v11;
        v20 = (__int16 *)((char *)v20 + v17);
        v21 -= v19;
        v16 += v17;
      }
      while (v11 != v13);
      v28 = 0;
      v29 = a5 + 2 * v5;
      v30 = -2 * v15;
      if ((1 << a1) >= 8uLL)
        v31 = 8;
      else
        v31 = (1 << a1);
      v32 = (__int16 *)(v29 - 2);
      v33 = a4 + 2 * a3 * (v5 - 1) - 2;
      v34 = -2 * v19;
      v35 = v31 + 1;
      v36 = -v15;
      do
      {
        if (((a2 >> v28) & 0x10) != 0)
        {
          v37 = v35;
          v38 = (__int16 *)v33;
          v39 = v32;
          do
          {
            v10 = *v38;
            *v39-- = *v38;
            v38 -= a3;
            --v37;
          }
          while (v37 > 1);
        }
        else
        {
          v40 = v36;
          do
          {
            *(_WORD *)(v29 + 2 * v40) = v10;
            v27 = __CFADD__(v40++, 1);
          }
          while (!v27);
        }
        ++v28;
        v32 = (__int16 *)((char *)v32 + v30);
        v33 += v34;
        v29 += v30;
      }
      while (v28 != v13);
    }
    if ((a2 & 0x100) != 0)
      v10 = *(_WORD *)(a4 + 2 * ~a3);
    *(_WORD *)(a5 - 2) = v10;
    if ((int)v5 >= 4)
    {
      v41 = 0;
      v42 = 2 << a1;
      v43 = (int)v6;
      if ((int)v6 <= 1)
        v44 = 1;
      else
        v44 = v6;
      v45 = v42;
      if ((int)v9 <= 1)
        v9 = 1;
      else
        v9 = v9;
      v46 = 2 * (int)v6;
      v47 = (__int16 *)(a4 - 2 * a3);
      v48 = v47;
      v49 = (_WORD *)(a5 + 2 * v42);
      do
      {
        if (((a2 >> v41) & 0x200) != 0)
        {
          v50 = v48;
          v51 = v49;
          v52 = v44;
          do
          {
            v53 = *v50++;
            v10 = v53;
            *v51++ = v53;
            --v52;
          }
          while (v52);
        }
        else
        {
          v54 = 0;
          do
            v49[v54++] = v10;
          while (v43 != v54);
        }
        ++v41;
        v49 = (_WORD *)((char *)v49 + v46);
        v48 = (__int16 *)((char *)v48 + v46);
      }
      while (v41 != v9);
      v55 = 0;
      v56 = (_WORD *)(a5 + 2 * (v45 + v5));
      v57 = 2 * v43;
      v58 = &v47[v5];
      do
      {
        if (((a2 >> v55) & 0x2000) != 0)
        {
          v59 = v58;
          v60 = v56;
          v61 = v44;
          do
          {
            v62 = *v59++;
            v10 = v62;
            *v60++ = v62;
            --v61;
          }
          while (v61);
        }
        else
        {
          v63 = 0;
          do
            v56[v63++] = v10;
          while (v43 != v63);
        }
        ++v55;
        v56 = (_WORD *)((char *)v56 + v57);
        v58 = (__int16 *)((char *)v58 + v57);
      }
      while (v55 != v9);
    }
  }
  else
  {
    memset_pattern16((void *)(a5 - 2), &unk_1B69180D0, (8 * ((unint64_t)(4 << a1) >> 2)) | 2);
  }
}

void sub_1B67D4B3C(int a1, int a2, uint64_t a3, uint64_t a4, _WORD *a5)
{
  char v6;
  int v10;
  uint64_t v11;
  _WORD *v12;
  _WORD *v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  _WORD *v17;
  uint64_t v18;
  _WORD *v19;
  _WORD *v20;
  uint64_t v21;
  __int16 v22;
  _WORD *v23;
  __int16 *v24;
  __int16 v25;
  uint64_t v26;
  _WORD *v27;
  uint64_t v28;
  _WORD *v29;
  __int16 v30;

  v6 = a1;
  if (a2)
  {
    v10 = 1 << a1;
    if ((a2 & 0xF) != 0)
    {
      if (v10 < 2 << a1)
      {
        v11 = (2 << a1) - (uint64_t)v10;
        v12 = &a5[v10];
        v13 = (_WORD *)(a4 + 2 * a3 * v10 - 2);
        do
        {
          *v12++ = *v13;
          v13 += a3;
          --v11;
        }
        while (v11);
      }
    }
    else
    {
      v14 = v10 - a3;
      if ((a2 & 0x1E00) != 0)
        v14 = -a3;
      if ((a2 & 0x100) != 0)
        v14 = ~a3;
      if ((a2 & 0xF0) != 0)
        v14 = (v10 - 1) * a3 - 1;
      v15 = *(_WORD *)(a4 + 2 * v14);
      v16 = v10;
      v17 = &a5[v10];
      do
      {
        *v17++ = v15;
        --v16;
      }
      while (v16);
    }
    if ((a2 & 0xF0) != 0)
    {
      if (a1 != 31)
      {
        if (v10 <= 1)
          v18 = 1;
        else
          v18 = v10;
        v19 = (_WORD *)(a4 - 2);
        v20 = a5;
        do
        {
          *v20++ = *v19;
          v19 += a3;
          --v18;
        }
        while (v18);
      }
    }
    else
    {
      v21 = v10;
      v22 = a5[v10];
      v23 = a5;
      do
      {
        *v23++ = v22;
        --v21;
      }
      while (v21);
    }
    v24 = (__int16 *)(a4 + 2 * ~a3);
    if ((a2 & 0x100) == 0)
      v24 = a5;
    v25 = *v24;
    *(a5 - 1) = v25;
    if ((a2 & 0x1E00) != 0)
    {
      memcpy(&a5[2 << a1], (const void *)(a4 - 2 * a3), 2 * v10);
    }
    else
    {
      v26 = v10;
      v27 = &a5[2 << a1];
      do
      {
        *v27++ = v25;
        --v26;
      }
      while (v26);
    }
    if ((a2 & 0x1E000) != 0)
    {
      memcpy(&a5[3 << v6], (const void *)(a4 + 2 * v10 - 2 * a3), 2 * v10);
    }
    else
    {
      v28 = v10;
      v29 = &a5[3 << v6];
      v30 = *(v29 - 1);
      do
      {
        *v29++ = v30;
        --v28;
      }
      while (v28);
    }
  }
  else
  {
    memset_pattern16(a5 - 1, &unk_1B69180D0, (8 * ((unint64_t)(4 << a1) >> 2)) | 2);
  }
}

void sub_1B67D4D54(int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t i;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t j;

  if (a2)
  {
    v5 = (1 << a1);
    v6 = __clz(__rbit32(a2));
    if (v6 < 9)
      v7 = ((2 << a1) + (char)~byte_1B6920BFD[9 * a1 + 18 + v6]) * a3 - 1;
    else
      v7 = byte_1B6920BFD[9 * a1 + 9 + v6] - a3;
    LODWORD(v8) = (int)v5 >> 2;
    v9 = *(_DWORD *)(a4 + 4 * v7);
    if ((int)v5 >= 4)
    {
      v10 = 0;
      v11 = 2 << a1;
      v12 = a5 + 4 * v11;
      if ((int)v8 <= 1)
        v13 = 1;
      else
        v13 = v8;
      v14 = a4 + 4 * a3 * (v11 - 1) - 4;
      do
      {
        v15 = v10 + 1;
        if (((a2 >> v10) & 1) != 0)
        {
          v16 = -4;
          v17 = (unsigned int *)v14;
          do
          {
            v9 = *v17;
            *(_DWORD *)(v12 + v16) = *v17;
            v16 -= 4;
            v17 -= a3;
          }
          while (v16 != -20);
        }
        else
        {
          *(int32x4_t *)(a5 + 4 * (v11 - 4 * v15)) = vdupq_n_s32(v9);
        }
        v12 -= 16;
        v14 -= 16 * a3;
        v10 = v15;
      }
      while (v15 != v13);
      v18 = 0;
      v19 = a5 + 4 * v5;
      v20 = a4 + 4 * a3 * (v5 - 1) - 4;
      do
      {
        v21 = v18 + 1;
        if (((a2 >> v18) & 0x10) != 0)
        {
          v22 = -4;
          v23 = (unsigned int *)v20;
          do
          {
            v9 = *v23;
            *(_DWORD *)(v19 + v22) = *v23;
            v22 -= 4;
            v23 -= a3;
          }
          while (v22 != -20);
        }
        else
        {
          *(int32x4_t *)(a5 + 4 * (v5 - 4 * v21)) = vdupq_n_s32(v9);
        }
        v19 -= 16;
        v20 -= 16 * a3;
        v18 = v21;
      }
      while (v21 != v13);
    }
    if ((a2 & 0x100) != 0)
      v9 = *(_DWORD *)(a4 + 4 * ~a3);
    *(_DWORD *)(a5 - 4) = v9;
    if ((int)v5 >= 4)
    {
      v24 = 0;
      v25 = 2 << a1;
      if ((int)v8 <= 1)
        v8 = 1;
      else
        v8 = v8;
      v26 = a5 + 4 * v25;
      v27 = a4 - 4 * a3;
      do
      {
        if (((a2 >> v24) & 0x200) != 0)
        {
          for (i = 0; i != 16; i += 4)
          {
            v9 = *(_DWORD *)(v27 + i);
            *(_DWORD *)(v26 + i) = v9;
          }
        }
        else
        {
          *(int32x4_t *)(a5 + 4 * (v25 + 4 * v24)) = vdupq_n_s32(v9);
        }
        ++v24;
        v26 += 16;
        v27 += 16;
      }
      while (v24 != v8);
      v29 = 0;
      v30 = a5 + 4 * (v25 + (unint64_t)v5);
      v31 = a4 - 4 * a3 + 4 * v5;
      do
      {
        if (((a2 >> v29) & 0x2000) != 0)
        {
          for (j = 0; j != 16; j += 4)
          {
            v9 = *(_DWORD *)(v31 + j);
            *(_DWORD *)(v30 + j) = v9;
          }
        }
        else
        {
          *(int32x4_t *)(a5 + 4 * (v5 + 4 * v29 + (2 << a1))) = vdupq_n_s32(v9);
        }
        ++v29;
        v30 += 16;
        v31 += 16;
      }
      while (v29 != v8);
    }
  }
  else
  {
    memset_pattern16((void *)(a5 - 4), &unk_1B69180D0, (16 * ((unint64_t)(4 << a1) >> 2)) | 4);
  }
}

void sub_1B67D4FE4(int a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  char v6;
  int v10;
  uint64_t v11;
  _DWORD *v12;
  _DWORD *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  _DWORD *v17;
  uint64_t v18;
  _DWORD *v19;
  _DWORD *v20;
  uint64_t v21;
  int v22;
  _DWORD *v23;
  int *v24;
  int v25;
  uint64_t v26;
  _DWORD *v27;
  uint64_t v28;
  _DWORD *v29;
  int v30;

  v6 = a1;
  if (a2)
  {
    v10 = 1 << a1;
    if ((a2 & 0xF) != 0)
    {
      if (v10 < 2 << a1)
      {
        v11 = (2 << a1) - (uint64_t)v10;
        v12 = &a5[v10];
        v13 = (_DWORD *)(a4 + 4 * a3 * v10 - 4);
        do
        {
          *v12++ = *v13;
          v13 += a3;
          --v11;
        }
        while (v11);
      }
    }
    else
    {
      v14 = v10 - a3;
      if ((a2 & 0x1E00) != 0)
        v14 = -a3;
      if ((a2 & 0x100) != 0)
        v14 = ~a3;
      if ((a2 & 0xF0) != 0)
        v14 = (v10 - 1) * a3 - 1;
      v15 = *(_DWORD *)(a4 + 4 * v14);
      v16 = v10;
      v17 = &a5[v10];
      do
      {
        *v17++ = v15;
        --v16;
      }
      while (v16);
    }
    if ((a2 & 0xF0) != 0)
    {
      if (a1 != 31)
      {
        if (v10 <= 1)
          v18 = 1;
        else
          v18 = v10;
        v19 = (_DWORD *)(a4 - 4);
        v20 = a5;
        do
        {
          *v20++ = *v19;
          v19 += a3;
          --v18;
        }
        while (v18);
      }
    }
    else
    {
      v21 = v10;
      v22 = a5[v10];
      v23 = a5;
      do
      {
        *v23++ = v22;
        --v21;
      }
      while (v21);
    }
    v24 = (int *)(a4 + 4 * ~a3);
    if ((a2 & 0x100) == 0)
      v24 = a5;
    v25 = *v24;
    *(a5 - 1) = v25;
    if ((a2 & 0x1E00) != 0)
    {
      memcpy(&a5[2 << a1], (const void *)(a4 - 4 * a3), 4 * v10);
    }
    else
    {
      v26 = v10;
      v27 = &a5[2 << a1];
      do
      {
        *v27++ = v25;
        --v26;
      }
      while (v26);
    }
    if ((a2 & 0x1E000) != 0)
    {
      memcpy(&a5[3 << v6], (const void *)(a4 + 4 * v10 - 4 * a3), 4 * v10);
    }
    else
    {
      v28 = v10;
      v29 = &a5[3 << v6];
      v30 = *(v29 - 1);
      do
      {
        *v29++ = v30;
        --v28;
      }
      while (v28);
    }
  }
  else
  {
    memset_pattern16(a5 - 1, &unk_1B69180D0, (16 * ((unint64_t)(4 << a1) >> 2)) | 4);
  }
}

unsigned __int16 *sub_1B67D51F8(unsigned __int16 *result, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  unsigned __int16 *v7;
  int v8;
  int v9;
  _WORD *v10;
  int v11;
  uint64_t v12;
  _WORD *v13;

  v2 = *(result - 1);
  v3 = result[127];
  v4 = v3 + v2 - 2 * result[95];
  if (v4 < 0)
    v4 = 2 * result[95] - (v3 + v2);
  if (v4 > 0xF)
    goto LABEL_7;
  v5 = result[63] + v2 - 2 * result[31];
  if (v5 < 0)
    v5 = 2 * result[31] - (result[63] + v2);
  if (v5 < 0x10)
  {
    v12 = 0;
    *(_WORD *)(a2 + 254) = v3;
    *(_WORD *)(a2 + 126) = result[63];
    *(_WORD *)(a2 - 2) = *(result - 1);
    do
    {
      v13 = (_WORD *)(a2 + 2 * v12);
      *v13 = *(result - 1) + (((result[63] - *(result - 1)) * ((_DWORD)v12 + 1) + 32) >> 6);
      v13[64] = *(result - 1) + (((result[127] - *(result - 1)) * ((_DWORD)v12++ + 1) + 32) >> 6);
    }
    while (v12 != 63);
  }
  else
  {
LABEL_7:
    v6 = 0;
    v7 = result + 64;
    *(_WORD *)(a2 - 2) = (*result + 2 * v2 + result[64] + 2) >> 2;
    *(_WORD *)(a2 + 254) = result[127];
    *(_WORD *)(a2 + 126) = result[63];
    v8 = v2;
    do
    {
      v9 = result[v6];
      v10 = (_WORD *)(a2 + v6 * 2);
      *v10 = (v2 + 2 * v9 + v7[v6 - 63] + 2) >> 2;
      v11 = v7[v6];
      v10[64] = (v8 + 2 * v11 + v7[++v6] + 2) >> 2;
      v2 = v9;
      v8 = v11;
    }
    while (v6 != 63);
  }
  return result;
}

void sub_1B67D5330(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;

  v4 = 0;
  v5 = a4 + 2;
  do
  {
    v6 = *(unsigned __int16 *)(a2 + 16) + ((__int16)(*(_WORD *)(a2 + v4) - *(_WORD *)(a2 - 2)) >> 1);
    if (v6 >= 511)
      v6 = 511;
    *(_WORD *)(v5 - 2) = v6 & ~(unsigned __int16)(v6 >> 31);
    v7 = *(_DWORD *)(a2 + 18);
    *(_WORD *)(v5 + 4) = *(_WORD *)(a2 + 22);
    *(_DWORD *)v5 = v7;
    v4 += 2;
    v5 += 2 * a3;
  }
  while (v4 != 8);
}

void sub_1B67D5390(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  int v6;
  uint64_t v7;

  v4 = 0;
  v5 = (_QWORD *)(a4 + 2);
  do
  {
    v6 = *(unsigned __int16 *)(a2 + 32) + ((__int16)(*(_WORD *)(a2 + v4) - *(_WORD *)(a2 - 2)) >> 1);
    if (v6 >= 511)
      v6 = 511;
    *((_WORD *)v5 - 1) = v6 & ~(unsigned __int16)(v6 >> 31);
    v7 = *(_QWORD *)(a2 + 34);
    *(_QWORD *)((char *)v5 + 6) = *(_QWORD *)(a2 + 40);
    *v5 = v7;
    v4 += 2;
    v5 = (_QWORD *)((char *)v5 + 2 * a3);
  }
  while (v4 != 16);
}

__n128 sub_1B67D53F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  __n128 result;

  v4 = 0;
  v5 = a4 + 2;
  do
  {
    v6 = *(unsigned __int16 *)(a2 + 64) + ((__int16)(*(_WORD *)(a2 + v4) - *(_WORD *)(a2 - 2)) >> 1);
    if (v6 >= 511)
      v6 = 511;
    *(_WORD *)(v5 - 2) = v6 & ~(unsigned __int16)(v6 >> 31);
    result = *(__n128 *)(a2 + 66);
    *(_OWORD *)(v5 + 14) = *(_OWORD *)(a2 + 80);
    *(__n128 *)v5 = result;
    v4 += 2;
    v5 += 2 * a3;
  }
  while (v4 != 32);
  return result;
}

__n128 sub_1B67D5450(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  __n128 result;
  __int128 v6;
  __int128 v7;

  v4 = 32;
  do
  {
    result = *(__n128 *)(a2 + 128);
    v6 = *(_OWORD *)(a2 + 144);
    v7 = *(_OWORD *)(a2 + 176);
    *(_OWORD *)(a4 + 32) = *(_OWORD *)(a2 + 160);
    *(_OWORD *)(a4 + 48) = v7;
    *(__n128 *)a4 = result;
    *(_OWORD *)(a4 + 16) = v6;
    a4 += 2 * a3;
    --v4;
  }
  while (v4);
  return result;
}

__n128 sub_1B67D547C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __n128 result;
  __int128 v9;
  __int128 v10;

  v4 = 64;
  do
  {
    v5 = *(_OWORD *)(a2 + 256);
    v6 = *(_OWORD *)(a2 + 272);
    v7 = *(_OWORD *)(a2 + 304);
    *(_OWORD *)(a4 + 32) = *(_OWORD *)(a2 + 288);
    *(_OWORD *)(a4 + 48) = v7;
    *(_OWORD *)a4 = v5;
    *(_OWORD *)(a4 + 16) = v6;
    result = *(__n128 *)(a2 + 320);
    v9 = *(_OWORD *)(a2 + 336);
    v10 = *(_OWORD *)(a2 + 368);
    *(_OWORD *)(a4 + 96) = *(_OWORD *)(a2 + 352);
    *(_OWORD *)(a4 + 112) = v10;
    *(__n128 *)(a4 + 64) = result;
    *(_OWORD *)(a4 + 80) = v9;
    a4 += 2 * a3;
    --v4;
  }
  while (v4);
  return result;
}

int16x4_t sub_1B67D54B8(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t i;
  int v5;
  uint64_t v6;
  int16x4_t *v7;
  const __int16 *v8;
  int16x4_t result;

  for (i = 0; i != 4; ++i)
  {
    v5 = *a2 + ((__int16)(a2[i + 8] - *(a2 - 1)) >> 1);
    if (v5 >= 511)
      v5 = 511;
    *(_WORD *)(a4 + i * 2) = v5 & ~(unsigned __int16)(v5 >> 31);
  }
  v6 = 1;
  v7 = (int16x4_t *)(a4 + 2 * a3);
  do
  {
    v8 = (const __int16 *)&a2[v6];
    result = vld1_dup_s16(v8);
    *v7 = result;
    ++v6;
    v7 = (int16x4_t *)((char *)v7 + 2 * a3);
  }
  while (v6 != 4);
  return result;
}

int16x8_t sub_1B67D5524(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t i;
  int v5;
  uint64_t v6;
  int16x8_t *v7;
  const __int16 *v8;
  int16x8_t result;

  for (i = 0; i != 8; ++i)
  {
    v5 = *a2 + ((__int16)(a2[i + 16] - *(a2 - 1)) >> 1);
    if (v5 >= 511)
      v5 = 511;
    *(_WORD *)(a4 + i * 2) = v5 & ~(unsigned __int16)(v5 >> 31);
  }
  v6 = 1;
  v7 = (int16x8_t *)(a4 + 2 * a3);
  do
  {
    v8 = (const __int16 *)&a2[v6];
    result = vld1q_dup_s16(v8);
    *v7 = result;
    ++v6;
    v7 = (int16x8_t *)((char *)v7 + 2 * a3);
  }
  while (v6 != 8);
  return result;
}

int16x8_t sub_1B67D5590(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t i;
  int v5;
  int16x8_t *v6;
  uint64_t j;
  const __int16 *v8;
  int16x8_t result;

  for (i = 0; i != 16; ++i)
  {
    v5 = *a2 + ((__int16)(a2[i + 32] - *(a2 - 1)) >> 1);
    if (v5 >= 511)
      v5 = 511;
    *(_WORD *)(a4 + i * 2) = v5 & ~(unsigned __int16)(v5 >> 31);
  }
  v6 = (int16x8_t *)(a4 + 2 * a3 + 16);
  for (j = 1; j != 16; ++j)
  {
    v8 = (const __int16 *)&a2[j];
    result = vld1q_dup_s16(v8);
    v6[-1] = result;
    *v6 = result;
    v6 = (int16x8_t *)((char *)v6 + 2 * a3);
  }
  return result;
}

void sub_1B67D5600(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t i;
  uint64_t v5;
  const __int16 *v6;
  int16x8_t v7;

  for (i = 0; i != 32; ++i)
  {
    v5 = 0;
    v6 = (const __int16 *)(a2 + 2 * i);
    v7 = vld1q_dup_s16(v6);
    do
    {
      *(int16x8_t *)(a4 + v5) = v7;
      v5 += 16;
    }
    while (v5 != 64);
    a4 += 2 * a3;
  }
}

void sub_1B67D5638(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t i;
  uint64_t v5;
  const __int16 *v6;
  int16x8_t v7;

  for (i = 0; i != 64; ++i)
  {
    v5 = 0;
    v6 = (const __int16 *)(a2 + 2 * i);
    v7 = vld1q_dup_s16(v6);
    do
    {
      *(int16x8_t *)(a4 + v5) = v7;
      v5 += 16;
    }
    while (v5 != 128);
    a4 += 2 * a3;
  }
}

uint64_t sub_1B67D5670(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  int v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (a2 >= 1)
  {
    v8 = result;
    v9 = 0;
    v10 = 9 - a3;
    v11 = 2 * a2;
    v12 = 2 * a4;
    do
    {
      v13 = 0;
      do
      {
        result = sub_1B67C9094(v8, a3);
        *(_WORD *)(a5 + v13) = (_DWORD)result << v10;
        v13 += 2;
      }
      while (v11 != v13);
      ++v9;
      a5 += v12;
    }
    while (v9 != a2);
  }
  return result;
}

uint64_t sub_1B67D5708(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v8;
  int v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;

  if (a2 >= 1)
  {
    v5 = a5;
    v8 = result;
    v9 = 0;
    v10 = a5 + 2;
    v17 = a2;
    v11 = 9 - a3;
    v12 = 4 * a2;
    v13 = 2 * a4;
    do
    {
      v14 = 0;
      do
      {
        *(_WORD *)(v5 + v14) = sub_1B67C9094(v8, a3) << v11;
        v14 += 4;
      }
      while (v12 != v14);
      ++v9;
      v5 += v13;
    }
    while (v9 != a2);
    v15 = 0;
    do
    {
      v16 = 0;
      do
      {
        result = sub_1B67C9094(v8, a3);
        *(_WORD *)(v10 + v16) = (_DWORD)result << v11;
        v16 += 4;
      }
      while (4 * v17 != v16);
      ++v15;
      v10 += v13;
    }
    while (v15 != a2);
  }
  return result;
}

uint64_t sub_1B67D57F4(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t (**v6)(uint64_t, uint64_t, uint64_t, uint64_t);

  if ((int)a2 > 9)
  {
    if ((_DWORD)a2 == 10)
    {
      v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 104);
      return (*v6)(a2, a4, a5, a6);
    }
    if ((_DWORD)a2 == 26)
    {
      v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 64);
      return (*v6)(a2, a4, a5, a6);
    }
LABEL_8:
    v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 184);
    return (*v6)(a2, a4, a5, a6);
  }
  if (!(_DWORD)a2)
  {
    v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 24);
    return (*v6)(a2, a4, a5, a6);
  }
  if ((_DWORD)a2 != 1)
    goto LABEL_8;
  v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 144);
  return (*v6)(a2, a4, a5, a6);
}

uint64_t sub_1B67D5868(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t (**v6)(uint64_t, uint64_t, uint64_t, uint64_t);

  if ((int)a2 > 9)
  {
    if ((_DWORD)a2 == 10)
    {
      v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 288);
      return (*v6)(a2, a4, a5, a6);
    }
    if ((_DWORD)a2 == 26)
    {
      v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 256);
      return (*v6)(a2, a4, a5, a6);
    }
LABEL_8:
    v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 352);
    return (*v6)(a2, a4, a5, a6);
  }
  if (!(_DWORD)a2)
  {
    v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 224);
    return (*v6)(a2, a4, a5, a6);
  }
  if ((_DWORD)a2 != 1)
    goto LABEL_8;
  v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 320);
  return (*v6)(a2, a4, a5, a6);
}

uint64_t *sub_1B67D58DC(uint64_t *result, int *a2, int a3, int a4)
{
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;

  if (a4 >= 1)
  {
    v4 = 0;
    v5 = *result;
    v6 = *a2;
    do
    {
      if (v6 >= 1)
      {
        v7 = 0;
        do
        {
          *(_DWORD *)(v5 + 4 * v7) = a3;
          v6 = *a2;
          ++v7;
        }
        while ((int)v7 < *a2);
      }
      ++v4;
      v5 += *((int *)result + 3);
    }
    while (v4 != a4);
    *result = v5;
  }
  v8 = a2[1];
  if (v8 > 2 * a4)
  {
    v9 = 0;
    v10 = *result;
    do
    {
      if (a4 >= 1)
      {
        v11 = 0;
        do
          *(_DWORD *)(v10 + 4 * v11++) = a3;
        while (a4 != (_DWORD)v11);
        v12 = (_DWORD *)(v10 + 4 * *a2 - 4 * a4);
        v13 = a4;
        do
        {
          *v12++ = a3;
          --v13;
        }
        while (v13);
        v8 = a2[1];
      }
      ++v9;
      v10 += *((int *)result + 3);
    }
    while (v9 < v8 - 2 * a4);
    *result = v10;
  }
  if (a4 >= 1)
  {
    v14 = 0;
    v15 = *result;
    v16 = *a2;
    do
    {
      if (v16 >= 1)
      {
        v17 = 0;
        do
        {
          *(_DWORD *)(v15 + 4 * v17) = a3;
          v16 = *a2;
          ++v17;
        }
        while ((int)v17 < *a2);
      }
      ++v14;
      v15 += *((int *)result + 3);
    }
    while (v14 != a4);
    *result = v15;
  }
  return result;
}

uint64_t sub_1B67D59F4(_QWORD *a1, int a2)
{
  uint64_t v2;
  uint64_t (*v3)(uint64_t, char, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v4)(uint64_t, char, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v5)(uint64_t, char, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v7)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v9)();
  uint64_t (*v10)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v11)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v12)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v13)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v14)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v15)(uint64_t, char, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v16)(uint64_t, char, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v17)(uint64_t, char, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v18)();
  uint64_t (*v19)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v20)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v21)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v22)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v23)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v24)(uint64_t, char, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v25)(uint64_t, char, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v26)(uint64_t, char, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v27)(uint64_t, uint64_t, uint64_t, __int128 *, uint64_t, _OWORD *);
  void *v28;
  void *v29;
  uint64_t (*v31)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v32)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v33)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v34)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v35)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v36)();
  uint64_t (*v37)(uint64_t, char, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v38)(uint64_t, char, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v39)(uint64_t, char, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v40)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v41)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v42)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v43)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v44)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v45)();
  uint64_t (*v46)(uint64_t, int, __int16 *, __int16 *, uint64_t, uint64_t, uint64_t);
  uint64_t (*v47)(uint64_t, int, __int16 *, __int16 *, uint64_t, uint64_t, uint64_t);
  uint64_t (*v48)(uint64_t, int, __int16 *, __int16 *, uint64_t, uint64_t, uint64_t);
  uint64_t (*v49)(uint64_t, char, __int16 *, __int16 *, uint64_t, __int16 *, __int16 *, uint64_t, uint64_t, uint64_t);
  uint64_t (*v50)(uint64_t, char, __int16 *, __int16 *, uint64_t, __int16 *, __int16 *, uint64_t, uint64_t, uint64_t);
  uint64_t (*v51)(uint64_t, char, __int16 *, __int16 *, uint64_t, __int16 *, __int16 *, uint64_t, uint64_t, uint64_t);
  uint64_t (*v52)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v53)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v54)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  void *v66;
  void *v67;
  void *v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  void *v79;
  void *v80;
  void *v81;
  void *v82;
  void *v83;
  void *v84;
  uint64_t (*v85)(uint64_t, char, uint64_t, uint64_t, uint64_t, int16x4_t *);
  uint64_t (*v86)(uint64_t, char, uint64_t, uint64_t, uint64_t, uint16x8_t *);
  void *v87;
  void *v88;
  void *v89;
  void *v90;
  void *v91;
  void *v92;
  void *v93;
  void *v94;
  void *v95;
  void *v96;
  void *v97;
  void *v98;
  uint64_t (*v99)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, int16x4_t *);
  void *v100;
  uint64_t (*v101)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, int16x8_t *);
  uint64_t (*v102)(uint64_t, unsigned int, uint64_t, uint64_t, uint64_t, int16x8_t *);
  uint64_t (*v103)(uint64_t, unsigned int, uint64_t, uint64_t, uint64_t, int16x8_t *);
  uint64_t (*v104)(uint64_t, unsigned int, uint64_t, uint64_t, uint64_t, int16x8_t *);
  void *v105;
  void *v106;
  void *v107;
  void *v108;
  void *v109;
  void *v110;
  void *v111;
  void *v112;
  void *v113;
  void *v114;
  void *v115;
  uint64_t (*v116)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, int16x8_t *);
  void *v117;
  void *v118;
  uint64_t (*v119)(uint64_t, unsigned int, uint64_t, uint64_t, uint64_t, int16x8_t *);
  void *v120;
  void *v121;
  void *v122;
  void *v123;
  void *v124;
  void *v125;
  void *v126;
  void *v127;
  void *v128;
  void *v129;
  void *v130;
  void *v131;
  void *v132;
  void *v133;
  void *v134;
  void *v135;
  void *v136;
  void *v137;
  void *v138;
  void *v139;

  if (a2 == 8)
  {
    v139 = sub_1B67E7880;
    v138 = sub_1B67E7614;
    v137 = sub_1B67E741C;
    v136 = sub_1B67E721C;
    v135 = sub_1B67E7080;
    v134 = sub_1B67E6E14;
    v133 = sub_1B67E6C58;
    v132 = sub_1B67E6B00;
    v131 = sub_1B67E69A0;
    v130 = sub_1B67E6894;
    v129 = sub_1B67E678C;
    v128 = sub_1B67E6698;
    v127 = sub_1B67E65A0;
    v121 = sub_1B67E6498;
    v120 = sub_1B67E63FC;
    v119 = sub_1B67E6348;
    v118 = sub_1B67E6070;
    v117 = sub_1B67E5D84;
    v116 = sub_1B67E5BAC;
    v115 = sub_1B67E58A4;
    v114 = sub_1B67E56F4;
    v113 = sub_1B67E5504;
    v112 = sub_1B67E5364;
    v111 = sub_1B67E5200;
    v110 = sub_1B67E4FCC;
    v109 = sub_1B67E4E90;
    v108 = sub_1B67E4D48;
    v107 = sub_1B67E4BF4;
    v106 = sub_1B67E4AD0;
    v105 = sub_1B67E4958;
    v104 = sub_1B67E4864;
    v103 = sub_1B67E4770;
    v102 = sub_1B67E4694;
    v101 = sub_1B67E41E0;
    v99 = sub_1B67E3B74;
    v97 = sub_1B67E3780;
    v95 = sub_1B67E36A4;
    v94 = sub_1B67E343C;
    v92 = sub_1B67E319C;
    v89 = sub_1B67E2BAC;
    v90 = sub_1B67E2D94;
    v87 = sub_1B67E2A6C;
    v88 = sub_1B67E2B0C;
    v85 = sub_1B67E27D0;
    v86 = sub_1B67E2960;
    v126 = sub_1B67E2670;
    v125 = sub_1B67E24E8;
    v124 = sub_1B67E2394;
    v123 = sub_1B67E22B4;
    v122 = sub_1B67E221C;
    v83 = sub_1B67E1BA0;
    v84 = sub_1B67E1E8C;
    v82 = sub_1B67E19C8;
    v80 = sub_1B67E216C;
    v81 = sub_1B67E16B8;
    v78 = sub_1B67E1150;
    v79 = sub_1B67E1300;
    v77 = sub_1B67E0FE4;
    v75 = sub_1B67E1504;
    v76 = sub_1B67E0DB0;
    v73 = sub_1B67E09C4;
    v74 = sub_1B67E0B24;
    v72 = sub_1B67E089C;
    v70 = sub_1B67E0C74;
    v71 = sub_1B67E0728;
    v68 = sub_1B67E0464;
    v69 = sub_1B67E0540;
    v67 = sub_1B67DFFAC;
    v65 = sub_1B67E0634;
    v66 = sub_1B67DF93C;
    v63 = sub_1B67DF1FC;
    v64 = sub_1B67DF468;
    v62 = sub_1B67DEF54;
    v60 = sub_1B67DF544;
    v61 = sub_1B67DEB60;
    v58 = sub_1B67DE838;
    v59 = sub_1B67DE8D8;
    v57 = sub_1B67DE72C;
    v55 = sub_1B67DE978;
    v56 = sub_1B67DE5A4;
    v100 = sub_1B67DE498;
    v98 = sub_1B67DE378;
    v96 = sub_1B67DE25C;
    v93 = sub_1B67DE1A0;
    v91 = sub_1B67DE130;
    v53 = sub_1B67DD814;
    v54 = sub_1B67DD878;
    v51 = sub_1B67DD6BC;
    v52 = sub_1B67DD7B0;
    v49 = sub_1B67DD4D4;
    v50 = sub_1B67DD5C8;
    v47 = sub_1B67DD364;
    v48 = sub_1B67DD41C;
    v45 = sub_1B67DD158;
    v46 = sub_1B67DD2AC;
    v43 = sub_1B67DCEE0;
    v44 = sub_1B67DD01C;
    v41 = sub_1B67DCDE8;
    v42 = sub_1B67DCE64;
    v39 = sub_1B67DCCF4;
    v40 = sub_1B67DCD6C;
    v37 = sub_1B67DCC04;
    v38 = sub_1B67DCC7C;
    v35 = sub_1B67DC964;
    v36 = sub_1B67DCAA8;
    v33 = sub_1B67DC7A0;
    v34 = sub_1B67DC820;
    v31 = sub_1B67DC6A0;
    v32 = sub_1B67DC720;
    v3 = sub_1B67DC624;
    v4 = sub_1B67DC5A8;
    v5 = sub_1B67DC52C;
    v6 = sub_1B67DC4E4;
    v7 = sub_1B67DC49C;
    v8 = sub_1B67DC454;
    v9 = sub_1B67DC2F0;
    v10 = sub_1B67DC1A4;
    v11 = sub_1B67DC058;
    v12 = sub_1B67DBFC8;
    v13 = sub_1B67DBF38;
    v14 = sub_1B67DBEA8;
    v15 = sub_1B67DBE1C;
    v16 = sub_1B67DBD90;
    v17 = sub_1B67DBD04;
    v18 = sub_1B67DBB98;
    v19 = sub_1B67DBA44;
    v20 = sub_1B67DB8F0;
    v21 = sub_1B67DB85C;
    v22 = sub_1B67DB7C8;
    v23 = sub_1B67DB734;
    v24 = sub_1B67DB6A4;
    v25 = sub_1B67DB614;
    v26 = sub_1B67DB584;
    v27 = sub_1B67DB558;
    v28 = sub_1B67DB52C;
    v29 = sub_1B67DB500;
LABEL_7:
    v2 = 0;
    a1[13] = v26;
    a1[14] = v25;
    a1[12] = v55;
    a1[15] = v24;
    a1[21] = v23;
    a1[22] = v22;
    a1[20] = v60;
    a1[23] = v21;
    a1[28] = v65;
    a1[29] = v20;
    a1[30] = v19;
    a1[31] = v18;
    a1[44] = v70;
    a1[45] = v17;
    a1[46] = v16;
    a1[47] = v15;
    a1[52] = v75;
    a1[53] = v14;
    a1[54] = v13;
    a1[55] = v12;
    a1[60] = v80;
    a1[61] = v11;
    a1[62] = v10;
    a1[63] = v9;
    a1[77] = v5;
    a1[78] = v4;
    a1[79] = v3;
    a1[85] = v31;
    a1[86] = v32;
    a1[87] = v33;
    a1[93] = v34;
    a1[94] = v35;
    a1[95] = v36;
    a1[109] = v37;
    a1[110] = v38;
    a1[111] = v39;
    a1[117] = v40;
    a1[118] = v41;
    a1[119] = v42;
    a1[125] = v43;
    a1[126] = v44;
    a1[127] = v45;
    a1[133] = v46;
    a1[134] = v47;
    a1[135] = v48;
    a1[141] = v49;
    a1[142] = v50;
    a1[143] = v51;
    a1[149] = v52;
    a1[150] = v53;
    a1[151] = v54;
    a1[8] = v56;
    a1[9] = v57;
    a1[10] = v58;
    a1[11] = v59;
    a1[16] = v61;
    a1[17] = v62;
    a1[18] = v63;
    a1[19] = v64;
    a1[24] = v66;
    a1[25] = v67;
    a1[26] = v68;
    a1[27] = v69;
    a1[40] = v71;
    a1[41] = v72;
    a1[42] = v73;
    a1[43] = v74;
    a1[48] = v76;
    a1[49] = v77;
    a1[50] = v78;
    a1[51] = v79;
    a1[56] = v81;
    a1[57] = v82;
    a1[58] = v83;
    a1[59] = v84;
    a1[72] = v85;
    a1[73] = v86;
    a1[74] = v87;
    a1[75] = v88;
    a1[76] = v89;
    a1[80] = v90;
    a1[81] = v92;
    a1[82] = v94;
    a1[83] = v95;
    a1[84] = v97;
    a1[88] = v99;
    a1[89] = v101;
    a1[90] = v102;
    a1[91] = v103;
    a1[92] = v104;
    a1[104] = v105;
    a1[105] = v106;
    a1[106] = v107;
    a1[107] = v108;
    a1[108] = v109;
    a1[112] = v110;
    a1[113] = v111;
    a1[114] = v112;
    a1[115] = v113;
    a1[116] = v114;
    a1[120] = v115;
    a1[121] = v116;
    a1[122] = v117;
    a1[123] = v118;
    a1[124] = v119;
    a1[144] = v120;
    a1[145] = v121;
    a1[6] = v28;
    a1[7] = v27;
    a1[38] = v28;
    a1[39] = v27;
    a1[69] = v8;
    a1[70] = v7;
    a1[71] = v6;
    a1[101] = v8;
    a1[102] = v7;
    a1[103] = v6;
    *a1 = v91;
    a1[1] = v93;
    a1[2] = v96;
    a1[3] = v98;
    a1[4] = v100;
    a1[5] = v29;
    a1[32] = v91;
    a1[33] = v93;
    a1[34] = v96;
    a1[35] = v98;
    a1[36] = v100;
    a1[37] = v29;
    a1[64] = v122;
    a1[65] = v123;
    a1[66] = v124;
    a1[67] = v125;
    a1[68] = v126;
    a1[96] = v122;
    a1[97] = v123;
    a1[98] = v124;
    a1[99] = v125;
    a1[100] = v126;
    a1[146] = v127;
    a1[147] = v128;
    a1[148] = v129;
    a1[128] = v130;
    a1[129] = v131;
    a1[130] = v132;
    a1[131] = v133;
    a1[132] = v134;
    a1[136] = v135;
    a1[137] = v136;
    a1[138] = v137;
    a1[139] = v138;
    a1[140] = v139;
    return v2;
  }
  if (a2 == 10)
  {
    v139 = sub_1B67E7748;
    v138 = sub_1B67E74DC;
    v137 = sub_1B67E72E4;
    v136 = sub_1B67E711C;
    v135 = sub_1B67E6FBC;
    v134 = sub_1B67E6D44;
    v133 = sub_1B67E6B88;
    v132 = sub_1B67E6A30;
    v131 = sub_1B67E68FC;
    v130 = sub_1B67E6818;
    v129 = sub_1B67E66F0;
    v128 = sub_1B67E65FC;
    v127 = sub_1B67E6504;
    v121 = sub_1B67E6434;
    v120 = sub_1B67E63A8;
    v119 = sub_1B67E62CC;
    v118 = sub_1B67E5FF4;
    v117 = sub_1B67E5D24;
    v116 = sub_1B67E59C8;
    v115 = sub_1B67E5754;
    v114 = sub_1B67E5678;
    v113 = sub_1B67E5488;
    v112 = sub_1B67E5304;
    v111 = sub_1B67E50D8;
    v110 = sub_1B67E4EF0;
    v109 = sub_1B67E4E14;
    v108 = sub_1B67E4CCC;
    v107 = sub_1B67E4B94;
    v106 = sub_1B67E4A24;
    v105 = sub_1B67E48DC;
    v104 = sub_1B67E47E8;
    v103 = sub_1B67E46F4;
    v102 = sub_1B67E4634;
    v101 = sub_1B67E3D8C;
    v99 = sub_1B67E3818;
    v97 = sub_1B67E3704;
    v95 = sub_1B67E3628;
    v94 = sub_1B67E33DC;
    v92 = sub_1B67E2FF0;
    v89 = sub_1B67E2B30;
    v90 = sub_1B67E2BD0;
    v87 = sub_1B67E2A0C;
    v88 = sub_1B67E2A90;
    v85 = sub_1B67E2730;
    v86 = sub_1B67E2884;
    v126 = sub_1B67E25F8;
    v125 = sub_1B67E2470;
    v124 = sub_1B67E2320;
    v123 = sub_1B67E2264;
    v122 = sub_1B67E21CC;
    v83 = sub_1B67E1B40;
    v84 = sub_1B67E1E10;
    v82 = sub_1B67E17DC;
    v80 = sub_1B67E20F0;
    v81 = sub_1B67E1564;
    v78 = sub_1B67E10F0;
    v79 = sub_1B67E1284;
    v77 = sub_1B67E0EBC;
    v75 = sub_1B67E1488;
    v76 = sub_1B67E0CD4;
    v73 = sub_1B67E0964;
    v74 = sub_1B67E0AA8;
    v72 = sub_1B67E07F0;
    v70 = sub_1B67E0BF8;
    v71 = sub_1B67E06AC;
    v68 = sub_1B67E0404;
    v69 = sub_1B67E04C4;
    v67 = sub_1B67DFB50;
    v65 = sub_1B67E05B8;
    v66 = sub_1B67DF5DC;
    v63 = sub_1B67DF19C;
    v64 = sub_1B67DF3EC;
    v62 = sub_1B67DEDA8;
    v60 = sub_1B67DF4C8;
    v61 = sub_1B67DE99C;
    v58 = sub_1B67DE7D8;
    v59 = sub_1B67DE85C;
    v57 = sub_1B67DE650;
    v55 = sub_1B67DE8FC;
    v56 = sub_1B67DE504;
    v100 = sub_1B67DE434;
    v98 = sub_1B67DE314;
    v96 = sub_1B67DE1FC;
    v93 = sub_1B67DE164;
    v91 = sub_1B67DE0F4;
    v53 = sub_1B67D8FD0;
    v54 = sub_1B67D9038;
    v51 = sub_1B67D8E74;
    v52 = sub_1B67D8F68;
    v49 = sub_1B67D8C8C;
    v50 = sub_1B67D8D80;
    v47 = sub_1B67D8B1C;
    v48 = sub_1B67D8BD4;
    v45 = sub_1B67D8908;
    v46 = sub_1B67D8A64;
    v43 = sub_1B67D8680;
    v44 = sub_1B67D87C4;
    v41 = sub_1B67D8578;
    v42 = sub_1B67D85FC;
    v39 = sub_1B67D8474;
    v40 = sub_1B67D84F4;
    v37 = sub_1B67D8374;
    v38 = sub_1B67D83F4;
    v35 = sub_1B67D80C4;
    v36 = sub_1B67D8210;
    v33 = sub_1B67D7EF0;
    v34 = sub_1B67D7F78;
    v31 = sub_1B67D7DE0;
    v32 = sub_1B67D7E68;
    v3 = sub_1B67D7D5C;
    v4 = sub_1B67D7CD8;
    v5 = sub_1B67D7C54;
    v6 = sub_1B67D7C08;
    v7 = sub_1B67D7BBC;
    v8 = sub_1B67D7B70;
    v9 = sub_1B67D7A04;
    v10 = sub_1B67D78B0;
    v11 = sub_1B67D775C;
    v12 = sub_1B67D76C8;
    v13 = sub_1B67D7634;
    v14 = sub_1B67D75A0;
    v15 = sub_1B67D7510;
    v16 = sub_1B67D7480;
    v17 = sub_1B67D73F0;
    v18 = sub_1B67D727C;
    v19 = sub_1B67D7120;
    v20 = sub_1B67D6FC4;
    v21 = sub_1B67D6F2C;
    v22 = sub_1B67D6E94;
    v23 = sub_1B67D6DFC;
    v24 = sub_1B67D6D68;
    v25 = sub_1B67D6CD4;
    v26 = sub_1B67D6C40;
    v27 = sub_1B67D6C04;
    v28 = sub_1B67D6BD0;
    v29 = sub_1B67D6B9C;
    goto LABEL_7;
  }
  if (a2 != 9)
    return 4294954386;
  v2 = 0;
  a1[13] = sub_1B67D90A0;
  a1[14] = sub_1B67D9134;
  a1[15] = sub_1B67D91C8;
  a1[21] = sub_1B67D925C;
  a1[22] = sub_1B67D92F4;
  a1[23] = sub_1B67D938C;
  a1[5] = sub_1B67D6B9C;
  a1[6] = sub_1B67D6BD0;
  a1[29] = sub_1B67D9424;
  a1[30] = sub_1B67D9580;
  a1[31] = sub_1B67D96DC;
  a1[7] = sub_1B67D6C04;
  a1[37] = sub_1B67D6B9C;
  a1[38] = sub_1B67D6BD0;
  a1[39] = sub_1B67D6C04;
  a1[45] = sub_1B67D9850;
  a1[46] = sub_1B67D98E0;
  a1[47] = sub_1B67D9970;
  a1[53] = sub_1B67D9A00;
  a1[54] = sub_1B67D9A94;
  a1[55] = sub_1B67D9B28;
  a1[61] = sub_1B67D9BBC;
  a1[62] = sub_1B67D9D10;
  a1[63] = sub_1B67D9E64;
  a1[69] = sub_1B67D9FD0;
  a1[70] = sub_1B67DA01C;
  a1[77] = sub_1B67DA0B4;
  a1[78] = sub_1B67DA138;
  a1[79] = sub_1B67DA1BC;
  a1[85] = sub_1B67DA240;
  a1[86] = sub_1B67DA2C8;
  a1[87] = sub_1B67DA350;
  a1[93] = sub_1B67DA3D8;
  a1[94] = sub_1B67DA524;
  a1[95] = sub_1B67DA670;
  a1[71] = sub_1B67DA068;
  a1[101] = sub_1B67D9FD0;
  a1[102] = sub_1B67DA01C;
  a1[103] = sub_1B67DA068;
  a1[109] = sub_1B67DA7D4;
  a1[110] = sub_1B67DA854;
  a1[111] = sub_1B67DA8D4;
  a1[117] = sub_1B67DA954;
  a1[118] = sub_1B67DA9D8;
  a1[119] = sub_1B67DAA5C;
  a1[125] = sub_1B67DAAE0;
  a1[126] = sub_1B67DAC24;
  a1[127] = sub_1B67DAD68;
  a1[133] = sub_1B67DAEC4;
  a1[134] = sub_1B67DAF7C;
  a1[135] = sub_1B67DB034;
  a1[141] = sub_1B67DB0EC;
  a1[142] = sub_1B67DB1E0;
  a1[143] = sub_1B67DB2D4;
  a1[149] = sub_1B67DB3C8;
  a1[150] = sub_1B67DB430;
  a1[151] = sub_1B67DB498;
  return v2;
}

uint64_t sub_1B67D6B9C(uint64_t result, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, uint64_t a6)
{
  __int128 v6;

  if ((int)result >= 1)
  {
    do
    {
      v6 = *a4;
      *(_QWORD *)(a6 + 16) = *((_QWORD *)a4 + 2);
      *(_OWORD *)a6 = v6;
      a6 += 2 * a5;
      a4 = (__int128 *)((char *)a4 + 2 * a3);
      result = (result - 1);
    }
    while ((_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D6BD0(uint64_t result, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, _OWORD *a6)
{
  __int128 v6;
  __int128 v7;

  if ((int)result >= 1)
  {
    do
    {
      v6 = *a4;
      v7 = a4[2];
      a6[1] = a4[1];
      a6[2] = v7;
      *a6 = v6;
      a6 = (_OWORD *)((char *)a6 + 2 * a5);
      a4 = (__int128 *)((char *)a4 + 2 * a3);
      result = (result - 1);
    }
    while ((_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D6C04(uint64_t result, uint64_t a2, uint64_t a3, _OWORD *a4, uint64_t a5, _OWORD *a6)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  if ((int)result >= 1)
  {
    do
    {
      v6 = a4[1];
      *a6 = *a4;
      a6[1] = v6;
      v7 = a4[2];
      v8 = a4[3];
      v9 = a4[5];
      a6[4] = a4[4];
      a6[5] = v9;
      a6[2] = v7;
      a6[3] = v8;
      a6 = (_OWORD *)((char *)a6 + 2 * a5);
      a4 = (_OWORD *)((char *)a4 + 2 * a3);
      result = (result - 1);
    }
    while ((_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D6C40(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = a4 - 6;
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = 0;
        do
        {
          v11 += byte_1B6920C55[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        v12 = (v11 + 32) >> 6;
        if (v12 >= 1023)
          v12 = 1023;
        *(_WORD *)(a6 + 2 * v8++) = v12 & ~(unsigned __int16)(v12 >> 31);
        v9 += 2;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D6CD4(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = a4 - 6;
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = 0;
        do
        {
          v11 += byte_1B6920C55[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        v12 = (v11 + 32) >> 6;
        if (v12 >= 1023)
          v12 = 1023;
        *(_WORD *)(a6 + 2 * v8++) = v12 & ~(unsigned __int16)(v12 >> 31);
        v9 += 2;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D6D68(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = a4 - 6;
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = 0;
        do
        {
          v11 += byte_1B6920C55[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        v12 = (v11 + 32) >> 6;
        if (v12 >= 1023)
          v12 = 1023;
        *(_WORD *)(a6 + 2 * v8++) = v12 & ~(unsigned __int16)(v12 >> 31);
        v9 += 2;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D6DFC(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 6 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -8;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        v15 = (v11 + 32) >> 6;
        if (v15 >= 1023)
          v15 = 1023;
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D6E94(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 6 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -8;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        v15 = (v11 + 32) >> 6;
        if (v15 >= 1023)
          v15 = 1023;
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D6F2C(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 6 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -8;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        v15 = (v11 + 32) >> 6;
        if (v15 >= 1023)
          v15 = 1023;
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D6FC4(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v15;
  __int16 *v16;
  uint64_t v17;
  __int16 *v18;
  int v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  int v24;
  _QWORD v25[214];

  v25[213] = *MEMORY[0x1E0C80C00];
  if ((int)result >= -6)
  {
    v6 = 0;
    v7 = a4 - 6 * a3 - 6;
    v8 = 2 * a3;
    v9 = v25;
    do
    {
      v10 = 0;
      v11 = v7;
      do
      {
        v12 = 0;
        v13 = 0;
        do
        {
          v13 += byte_1B6920C55[8 * (a2 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *((_WORD *)v9 + v10++) = v13 >> 2;
        v11 += 2;
      }
      while (v10 != 12);
      v9 += 3;
      v7 += v8;
    }
    while (v6++ != (_DWORD)result + 6);
    if ((int)result >= 1)
    {
      v15 = 0;
      v16 = (__int16 *)v25;
      do
      {
        v17 = 0;
        v18 = v16;
        do
        {
          v19 = 0;
          v20 = -8;
          v21 = v18;
          do
          {
            v22 = *v21;
            v21 += 12;
            v19 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          v24 = (v19 + 512) >> 10;
          if (v24 >= 1023)
            v24 = 1023;
          *(_WORD *)(a6 + 2 * v17++) = v24 & ~(unsigned __int16)(v24 >> 31);
          ++v18;
        }
        while (v17 != 12);
        ++v15;
        a6 += 2 * a5;
        v16 += 12;
      }
      while (v15 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D7120(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v15;
  __int16 *v16;
  uint64_t v17;
  __int16 *v18;
  int v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  int v24;
  _BYTE v25[3408];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if ((int)result >= -6)
  {
    v6 = 0;
    v7 = a4 - 6 * a3 - 6;
    v8 = 2 * a3;
    v9 = v25;
    do
    {
      v10 = 0;
      v11 = v7;
      do
      {
        v12 = 0;
        v13 = 0;
        do
        {
          v13 += byte_1B6920C55[8 * (a2 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *(_WORD *)&v9[2 * v10++] = v13 >> 2;
        v11 += 2;
      }
      while (v10 != 24);
      v9 += 48;
      v7 += v8;
    }
    while (v6++ != (_DWORD)result + 6);
    if ((int)result >= 1)
    {
      v15 = 0;
      v16 = (__int16 *)v25;
      do
      {
        v17 = 0;
        v18 = v16;
        do
        {
          v19 = 0;
          v20 = -8;
          v21 = v18;
          do
          {
            v22 = *v21;
            v21 += 24;
            v19 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          v24 = (v19 + 512) >> 10;
          if (v24 >= 1023)
            v24 = 1023;
          *(_WORD *)(a6 + 2 * v17++) = v24 & ~(unsigned __int16)(v24 >> 31);
          ++v18;
        }
        while (v17 != 24);
        ++v15;
        a6 += 2 * a5;
        v16 += 24;
      }
      while (v15 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D727C()
{
  uint64_t result;
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v15;
  __int16 *v16;
  uint64_t v17;
  __int16 *v18;
  int v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  int v24;
  _BYTE v25[6816];
  uint64_t v26;

  result = MEMORY[0x1E0C80A78]();
  v26 = *MEMORY[0x1E0C80C00];
  if ((int)result >= -6)
  {
    v6 = 0;
    v7 = v3 - 6 * v2 - 6;
    v8 = 2 * v2;
    v9 = v25;
    do
    {
      v10 = 0;
      v11 = v7;
      do
      {
        v12 = 0;
        v13 = 0;
        do
        {
          v13 += byte_1B6920C55[8 * (v1 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *(_WORD *)&v9[2 * v10++] = v13 >> 2;
        v11 += 2;
      }
      while (v10 != 48);
      v9 += 96;
      v7 += v8;
    }
    while (v6++ != (_DWORD)result + 6);
    if ((int)result >= 1)
    {
      v15 = 0;
      v16 = (__int16 *)v25;
      do
      {
        v17 = 0;
        v18 = v16;
        do
        {
          v19 = 0;
          v20 = -8;
          v21 = v18;
          do
          {
            v22 = *v21;
            v21 += 48;
            v19 += byte_1B6920C55[8 * ((v1 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          v24 = (v19 + 512) >> 10;
          if (v24 >= 1023)
            v24 = 1023;
          *(_WORD *)(v5 + 2 * v17++) = v24 & ~(unsigned __int16)(v24 >> 31);
          ++v18;
        }
        while (v17 != 48);
        ++v15;
        v5 += 2 * v4;
        v16 += 48;
      }
      while (v15 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D73F0(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;
  uint64_t v11;
  unsigned __int16 *v12;
  int v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = -4;
        v12 = v9;
        do
        {
          v13 = *v12;
          v12 += 2;
          v10 += byte_1B6920C6D[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        v15 = (v10 + 32) >> 6;
        if (v15 >= 1023)
          v15 = 1023;
        *(_WORD *)(a6 + 2 * v8++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v9;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D7480(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;
  uint64_t v11;
  unsigned __int16 *v12;
  int v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = -4;
        v12 = v9;
        do
        {
          v13 = *v12;
          v12 += 2;
          v10 += byte_1B6920C6D[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        v15 = (v10 + 32) >> 6;
        if (v15 >= 1023)
          v15 = 1023;
        *(_WORD *)(a6 + 2 * v8++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v9;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D7510(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;
  uint64_t v11;
  unsigned __int16 *v12;
  int v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = -4;
        v12 = v9;
        do
        {
          v13 = *v12;
          v12 += 2;
          v10 += byte_1B6920C6D[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        v15 = (v10 + 32) >> 6;
        if (v15 >= 1023)
          v15 = 1023;
        *(_WORD *)(a6 + 2 * v8++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v9;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D75A0(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 2 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -4;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        v15 = (v11 + 32) >> 6;
        if (v15 >= 1023)
          v15 = 1023;
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D7634(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 2 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -4;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        v15 = (v11 + 32) >> 6;
        if (v15 >= 1023)
          v15 = 1023;
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D76C8(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 2 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -4;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        v15 = (v11 + 32) >> 6;
        if (v15 >= 1023)
          v15 = 1023;
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D775C(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned __int16 *v14;
  int v15;
  BOOL v16;
  int v18;
  __int16 *v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  uint64_t v23;
  __int16 *v24;
  int v25;
  int v26;
  _QWORD v27[202];

  v27[201] = *MEMORY[0x1E0C80C00];
  if ((int)result >= -2)
  {
    v6 = 0;
    v7 = 2 * a3;
    v8 = a4 - 2 * a3 - 4;
    v9 = v27;
    do
    {
      v10 = 0;
      v11 = (unsigned __int16 *)v8;
      do
      {
        v12 = 0;
        v13 = -4;
        v14 = v11;
        do
        {
          v15 = *v14;
          v14 += 2;
          v12 += byte_1B6920C6D[4 * (a2 & 7) + v13] * v15;
          v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *((_WORD *)v9 + v10++) = v12 >> 2;
        ++v11;
      }
      while (v10 != 12);
      v9 += 3;
      v8 += v7;
    }
    while (v6++ != (_DWORD)result + 2);
    if ((int)result >= 1)
    {
      v18 = 0;
      v19 = (__int16 *)v27;
      do
      {
        v20 = 0;
        v21 = v19;
        do
        {
          v22 = 0;
          v23 = -4;
          v24 = v21;
          do
          {
            v25 = *v24;
            v24 += 12;
            v22 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v23] * v25;
            v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          v26 = (v22 + 512) >> 10;
          if (v26 >= 1023)
            v26 = 1023;
          *(_WORD *)(a6 + 2 * v20++) = v26 & ~(unsigned __int16)(v26 >> 31);
          ++v21;
        }
        while (v20 != 12);
        ++v18;
        a6 += 2 * a5;
        v19 += 12;
      }
      while (v18 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D78B0(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned __int16 *v14;
  int v15;
  BOOL v16;
  int v18;
  __int16 *v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  uint64_t v23;
  __int16 *v24;
  int v25;
  int v26;
  _BYTE v27[3216];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if ((int)result >= -2)
  {
    v6 = 0;
    v7 = 2 * a3;
    v8 = a4 - 2 * a3 - 4;
    v9 = v27;
    do
    {
      v10 = 0;
      v11 = (unsigned __int16 *)v8;
      do
      {
        v12 = 0;
        v13 = -4;
        v14 = v11;
        do
        {
          v15 = *v14;
          v14 += 2;
          v12 += byte_1B6920C6D[4 * (a2 & 7) + v13] * v15;
          v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *(_WORD *)&v9[2 * v10++] = v12 >> 2;
        ++v11;
      }
      while (v10 != 24);
      v9 += 48;
      v8 += v7;
    }
    while (v6++ != (_DWORD)result + 2);
    if ((int)result >= 1)
    {
      v18 = 0;
      v19 = (__int16 *)v27;
      do
      {
        v20 = 0;
        v21 = v19;
        do
        {
          v22 = 0;
          v23 = -4;
          v24 = v21;
          do
          {
            v25 = *v24;
            v24 += 24;
            v22 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v23] * v25;
            v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          v26 = (v22 + 512) >> 10;
          if (v26 >= 1023)
            v26 = 1023;
          *(_WORD *)(a6 + 2 * v20++) = v26 & ~(unsigned __int16)(v26 >> 31);
          ++v21;
        }
        while (v20 != 24);
        ++v18;
        a6 += 2 * a5;
        v19 += 24;
      }
      while (v18 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D7A04()
{
  uint64_t result;
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned __int16 *v14;
  int v15;
  BOOL v16;
  int v18;
  __int16 *v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  uint64_t v23;
  __int16 *v24;
  int v25;
  int v26;
  _BYTE v27[6432];
  uint64_t v28;

  result = MEMORY[0x1E0C80A78]();
  v28 = *MEMORY[0x1E0C80C00];
  if ((int)result >= -2)
  {
    v6 = 0;
    v7 = 2 * v2;
    v8 = v3 - 2 * v2 - 4;
    v9 = v27;
    do
    {
      v10 = 0;
      v11 = (unsigned __int16 *)v8;
      do
      {
        v12 = 0;
        v13 = -4;
        v14 = v11;
        do
        {
          v15 = *v14;
          v14 += 2;
          v12 += byte_1B6920C6D[4 * (v1 & 7) + v13] * v15;
          v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *(_WORD *)&v9[2 * v10++] = v12 >> 2;
        ++v11;
      }
      while (v10 != 48);
      v9 += 96;
      v8 += v7;
    }
    while (v6++ != (_DWORD)result + 2);
    if ((int)result >= 1)
    {
      v18 = 0;
      v19 = (__int16 *)v27;
      do
      {
        v20 = 0;
        v21 = v19;
        do
        {
          v22 = 0;
          v23 = -4;
          v24 = v21;
          do
          {
            v25 = *v24;
            v24 += 48;
            v22 += byte_1B6920C6D[4 * ((v1 >> 16) & 7) + v23] * v25;
            v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          v26 = (v22 + 512) >> 10;
          if (v26 >= 1023)
            v26 = 1023;
          *(_WORD *)(v5 + 2 * v20++) = v26 & ~(unsigned __int16)(v26 >> 31);
          ++v21;
        }
        while (v20 != 48);
        ++v18;
        v5 += 2 * v4;
        v19 += 48;
      }
      while (v18 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D7B70(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t i;

  if ((int)result >= 1)
  {
    v6 = 0;
    do
    {
      for (i = 0; i != 24; i += 2)
        *(_WORD *)(a6 + i) = 16 * *(_WORD *)(a4 + i) - 0x2000;
      ++v6;
      a6 += 2 * a5;
      a4 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D7BBC(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t i;

  if ((int)result >= 1)
  {
    v6 = 0;
    do
    {
      for (i = 0; i != 48; i += 2)
        *(_WORD *)(a6 + i) = 16 * *(_WORD *)(a4 + i) - 0x2000;
      ++v6;
      a6 += 2 * a5;
      a4 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D7C08(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t i;

  if ((int)result >= 1)
  {
    v6 = 0;
    do
    {
      for (i = 0; i != 96; i += 2)
        *(_WORD *)(a6 + i) = 16 * *(_WORD *)(a4 + i) - 0x2000;
      ++v6;
      a6 += 2 * a5;
      a4 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D7C54(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = a4 - 6;
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = 0;
        do
        {
          v11 += byte_1B6920C55[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        *(_WORD *)(a6 + 2 * v8++) = (v11 + 229376) >> 2;
        v9 += 2;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D7CD8(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = a4 - 6;
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = 0;
        do
        {
          v11 += byte_1B6920C55[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        *(_WORD *)(a6 + 2 * v8++) = (v11 + 229376) >> 2;
        v9 += 2;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D7D5C(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = a4 - 6;
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = 0;
        do
        {
          v11 += byte_1B6920C55[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        *(_WORD *)(a6 + 2 * v8++) = (v11 + 229376) >> 2;
        v9 += 2;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D7DE0(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 6 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -8;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 229376) >> 2;
        ++v10;
      }
      while (v9 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D7E68(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 6 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -8;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 229376) >> 2;
        ++v10;
      }
      while (v9 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D7EF0(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 6 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -8;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 229376) >> 2;
        ++v10;
      }
      while (v9 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D7F78(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v15;
  __int16 *v16;
  uint64_t v17;
  __int16 *v18;
  unsigned int v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  _QWORD v24[214];

  v24[213] = *MEMORY[0x1E0C80C00];
  if ((int)result >= -6)
  {
    v6 = 0;
    v7 = a4 - 6 * a3 - 6;
    v8 = 2 * a3;
    v9 = v24;
    do
    {
      v10 = 0;
      v11 = v7;
      do
      {
        v12 = 0;
        v13 = 0;
        do
        {
          v13 += byte_1B6920C55[8 * (a2 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *((_WORD *)v9 + v10++) = (v13 + 229376) >> 2;
        v11 += 2;
      }
      while (v10 != 12);
      v9 += 3;
      v7 += v8;
    }
    while (v6++ != (_DWORD)result + 6);
    if ((int)result >= 1)
    {
      v15 = 0;
      v16 = (__int16 *)v24;
      do
      {
        v17 = 0;
        v18 = v16;
        do
        {
          v19 = 0;
          v20 = -8;
          v21 = v18;
          do
          {
            v22 = *v21;
            v21 += 12;
            v19 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          *(_WORD *)(a6 + 2 * v17++) = v19 >> 6;
          ++v18;
        }
        while (v17 != 12);
        ++v15;
        a6 += 2 * a5;
        v16 += 12;
      }
      while (v15 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D80C4(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v15;
  __int16 *v16;
  uint64_t v17;
  __int16 *v18;
  unsigned int v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  _BYTE v24[3408];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if ((int)result >= -6)
  {
    v6 = 0;
    v7 = a4 - 6 * a3 - 6;
    v8 = 2 * a3;
    v9 = v24;
    do
    {
      v10 = 0;
      v11 = v7;
      do
      {
        v12 = 0;
        v13 = 0;
        do
        {
          v13 += byte_1B6920C55[8 * (a2 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *(_WORD *)&v9[2 * v10++] = (v13 + 229376) >> 2;
        v11 += 2;
      }
      while (v10 != 24);
      v9 += 48;
      v7 += v8;
    }
    while (v6++ != (_DWORD)result + 6);
    if ((int)result >= 1)
    {
      v15 = 0;
      v16 = (__int16 *)v24;
      do
      {
        v17 = 0;
        v18 = v16;
        do
        {
          v19 = 0;
          v20 = -8;
          v21 = v18;
          do
          {
            v22 = *v21;
            v21 += 24;
            v19 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          *(_WORD *)(a6 + 2 * v17++) = v19 >> 6;
          ++v18;
        }
        while (v17 != 24);
        ++v15;
        a6 += 2 * a5;
        v16 += 24;
      }
      while (v15 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D8210()
{
  uint64_t result;
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v15;
  __int16 *v16;
  uint64_t v17;
  __int16 *v18;
  unsigned int v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  _BYTE v24[6816];
  uint64_t v25;

  result = MEMORY[0x1E0C80A78]();
  v25 = *MEMORY[0x1E0C80C00];
  if ((int)result >= -6)
  {
    v6 = 0;
    v7 = v3 - 6 * v2 - 6;
    v8 = 2 * v2;
    v9 = v24;
    do
    {
      v10 = 0;
      v11 = v7;
      do
      {
        v12 = 0;
        v13 = 0;
        do
        {
          v13 += byte_1B6920C55[8 * (v1 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *(_WORD *)&v9[2 * v10++] = (v13 + 229376) >> 2;
        v11 += 2;
      }
      while (v10 != 48);
      v9 += 96;
      v7 += v8;
    }
    while (v6++ != (_DWORD)result + 6);
    if ((int)result >= 1)
    {
      v15 = 0;
      v16 = (__int16 *)v24;
      do
      {
        v17 = 0;
        v18 = v16;
        do
        {
          v19 = 0;
          v20 = -8;
          v21 = v18;
          do
          {
            v22 = *v21;
            v21 += 48;
            v19 += byte_1B6920C55[8 * ((v1 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          *(_WORD *)(v5 + 2 * v17++) = v19 >> 6;
          ++v18;
        }
        while (v17 != 48);
        ++v15;
        v5 += 2 * v4;
        v16 += 48;
      }
      while (v15 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D8374(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;
  uint64_t v11;
  unsigned __int16 *v12;
  int v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = -4;
        v12 = v9;
        do
        {
          v13 = *v12;
          v12 += 2;
          v10 += byte_1B6920C6D[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = (v10 + 229376) >> 2;
        ++v9;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D83F4(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;
  uint64_t v11;
  unsigned __int16 *v12;
  int v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = -4;
        v12 = v9;
        do
        {
          v13 = *v12;
          v12 += 2;
          v10 += byte_1B6920C6D[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = (v10 + 229376) >> 2;
        ++v9;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D8474(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;
  uint64_t v11;
  unsigned __int16 *v12;
  int v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = -4;
        v12 = v9;
        do
        {
          v13 = *v12;
          v12 += 2;
          v10 += byte_1B6920C6D[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = (v10 + 229376) >> 2;
        ++v9;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D84F4(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 2 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -4;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 229376) >> 2;
        ++v10;
      }
      while (v9 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D8578(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 2 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -4;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 229376) >> 2;
        ++v10;
      }
      while (v9 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D85FC(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 2 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -4;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 229376) >> 2;
        ++v10;
      }
      while (v9 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D8680(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unsigned __int16 *v11;
  int v12;
  uint64_t v13;
  unsigned __int16 *v14;
  int v15;
  BOOL v16;
  int v18;
  __int16 *v19;
  uint64_t v20;
  __int16 *v21;
  unsigned int v22;
  uint64_t v23;
  __int16 *v24;
  int v25;
  _QWORD v26[202];

  v26[201] = *MEMORY[0x1E0C80C00];
  if ((int)result >= -2)
  {
    v6 = 0;
    v7 = 2 * a3;
    v8 = a4 - 2 * a3 - 4;
    v9 = v26;
    do
    {
      v10 = 0;
      v11 = (unsigned __int16 *)v8;
      do
      {
        v12 = 0;
        v13 = -4;
        v14 = v11;
        do
        {
          v15 = *v14;
          v14 += 2;
          v12 += byte_1B6920C6D[4 * (a2 & 7) + v13] * v15;
          v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *((_WORD *)v9 + v10++) = (v12 + 229376) >> 2;
        ++v11;
      }
      while (v10 != 12);
      v9 += 3;
      v8 += v7;
    }
    while (v6++ != (_DWORD)result + 2);
    if ((int)result >= 1)
    {
      v18 = 0;
      v19 = (__int16 *)v26;
      do
      {
        v20 = 0;
        v21 = v19;
        do
        {
          v22 = 0;
          v23 = -4;
          v24 = v21;
          do
          {
            v25 = *v24;
            v24 += 12;
            v22 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v23] * v25;
            v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          *(_WORD *)(a6 + 2 * v20++) = v22 >> 6;
          ++v21;
        }
        while (v20 != 12);
        ++v18;
        a6 += 2 * a5;
        v19 += 12;
      }
      while (v18 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D87C4(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  unsigned __int16 *v11;
  int v12;
  uint64_t v13;
  unsigned __int16 *v14;
  int v15;
  BOOL v16;
  int v18;
  __int16 *v19;
  uint64_t v20;
  __int16 *v21;
  unsigned int v22;
  uint64_t v23;
  __int16 *v24;
  int v25;
  _BYTE v26[3216];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if ((int)result >= -2)
  {
    v6 = 0;
    v7 = 2 * a3;
    v8 = a4 - 2 * a3 - 4;
    v9 = v26;
    do
    {
      v10 = 0;
      v11 = (unsigned __int16 *)v8;
      do
      {
        v12 = 0;
        v13 = -4;
        v14 = v11;
        do
        {
          v15 = *v14;
          v14 += 2;
          v12 += byte_1B6920C6D[4 * (a2 & 7) + v13] * v15;
          v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *(_WORD *)&v9[2 * v10++] = (v12 + 229376) >> 2;
        ++v11;
      }
      while (v10 != 24);
      v9 += 48;
      v8 += v7;
    }
    while (v6++ != (_DWORD)result + 2);
    if ((int)result >= 1)
    {
      v18 = 0;
      v19 = (__int16 *)v26;
      do
      {
        v20 = 0;
        v21 = v19;
        do
        {
          v22 = 0;
          v23 = -4;
          v24 = v21;
          do
          {
            v25 = *v24;
            v24 += 24;
            v22 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v23] * v25;
            v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          *(_WORD *)(a6 + 2 * v20++) = v22 >> 6;
          ++v21;
        }
        while (v20 != 24);
        ++v18;
        a6 += 2 * a5;
        v19 += 24;
      }
      while (v18 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D8908()
{
  uint64_t result;
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  unsigned __int16 *v11;
  int v12;
  uint64_t v13;
  unsigned __int16 *v14;
  int v15;
  BOOL v16;
  int v18;
  __int16 *v19;
  uint64_t v20;
  __int16 *v21;
  unsigned int v22;
  uint64_t v23;
  __int16 *v24;
  int v25;
  _BYTE v26[6432];
  uint64_t v27;

  result = MEMORY[0x1E0C80A78]();
  v27 = *MEMORY[0x1E0C80C00];
  if ((int)result >= -2)
  {
    v6 = 0;
    v7 = 2 * v2;
    v8 = v3 - 2 * v2 - 4;
    v9 = v26;
    do
    {
      v10 = 0;
      v11 = (unsigned __int16 *)v8;
      do
      {
        v12 = 0;
        v13 = -4;
        v14 = v11;
        do
        {
          v15 = *v14;
          v14 += 2;
          v12 += byte_1B6920C6D[4 * (v1 & 7) + v13] * v15;
          v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *(_WORD *)&v9[2 * v10++] = (v12 + 229376) >> 2;
        ++v11;
      }
      while (v10 != 48);
      v9 += 96;
      v8 += v7;
    }
    while (v6++ != (_DWORD)result + 2);
    if ((int)result >= 1)
    {
      v18 = 0;
      v19 = (__int16 *)v26;
      do
      {
        v20 = 0;
        v21 = v19;
        do
        {
          v22 = 0;
          v23 = -4;
          v24 = v21;
          do
          {
            v25 = *v24;
            v24 += 48;
            v22 += byte_1B6920C6D[4 * ((v1 >> 16) & 7) + v23] * v25;
            v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          *(_WORD *)(v5 + 2 * v20++) = v22 >> 6;
          ++v21;
        }
        while (v20 != 48);
        ++v18;
        v5 += 2 * v4;
        v19 += 48;
      }
      while (v18 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D8A64(uint64_t result, int a2, __int16 *a3, __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  int v12;

  v7 = 1 << (a2 - 1);
  if (a2 <= 0)
    v7 = 0;
  if ((int)result >= 1)
  {
    v8 = 0;
    do
    {
      v9 = 0;
      v10 = -2;
      do
      {
        v11 = ((v7 + (*(__int16 *)(a5 + v9) + 0x2000) * *a3) >> a2) + *a4;
        if (v11 >= 1023)
          v11 = 1023;
        *(_WORD *)(a7 + v9) = v11 & ~(unsigned __int16)(v11 >> 31);
        v12 = ((v7 + (*(__int16 *)(a5 + v9 + 2) + 0x2000) * a3[1]) >> a2) + a4[1];
        if (v12 >= 1023)
          v12 = 1023;
        *(_WORD *)(a7 + v9 + 2) = v12 & ~(unsigned __int16)(v12 >> 31);
        v10 += 2;
        v9 += 4;
      }
      while (v10 < 0xA);
      ++v8;
      a5 += 24;
      a7 += 2 * a6;
    }
    while (v8 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D8B1C(uint64_t result, int a2, __int16 *a3, __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  int v12;

  v7 = 1 << (a2 - 1);
  if (a2 <= 0)
    v7 = 0;
  if ((int)result >= 1)
  {
    v8 = 0;
    do
    {
      v9 = 0;
      v10 = -2;
      do
      {
        v11 = ((v7 + (*(__int16 *)(a5 + v9) + 0x2000) * *a3) >> a2) + *a4;
        if (v11 >= 1023)
          v11 = 1023;
        *(_WORD *)(a7 + v9) = v11 & ~(unsigned __int16)(v11 >> 31);
        v12 = ((v7 + (*(__int16 *)(a5 + v9 + 2) + 0x2000) * a3[1]) >> a2) + a4[1];
        if (v12 >= 1023)
          v12 = 1023;
        *(_WORD *)(a7 + v9 + 2) = v12 & ~(unsigned __int16)(v12 >> 31);
        v10 += 2;
        v9 += 4;
      }
      while (v10 < 0x16);
      ++v8;
      a5 += 48;
      a7 += 2 * a6;
    }
    while (v8 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D8BD4(uint64_t result, int a2, __int16 *a3, __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  int v12;

  v7 = 1 << (a2 - 1);
  if (a2 <= 0)
    v7 = 0;
  if ((int)result >= 1)
  {
    v8 = 0;
    do
    {
      v9 = 0;
      v10 = -2;
      do
      {
        v11 = ((v7 + (*(__int16 *)(a5 + v9) + 0x2000) * *a3) >> a2) + *a4;
        if (v11 >= 1023)
          v11 = 1023;
        *(_WORD *)(a7 + v9) = v11 & ~(unsigned __int16)(v11 >> 31);
        v12 = ((v7 + (*(__int16 *)(a5 + v9 + 2) + 0x2000) * a3[1]) >> a2) + a4[1];
        if (v12 >= 1023)
          v12 = 1023;
        *(_WORD *)(a7 + v9 + 2) = v12 & ~(unsigned __int16)(v12 >> 31);
        v10 += 2;
        v9 += 4;
      }
      while (v10 < 0x2E);
      ++v8;
      a5 += 96;
      a7 += 2 * a6;
    }
    while (v8 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D8C8C(uint64_t result, char a2, __int16 *a3, __int16 *a4, uint64_t a5, __int16 *a6, __int16 *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  int v10;
  int v12;
  char v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  int v18;

  if ((int)result >= 1)
  {
    v10 = 0;
    v12 = (*a7 + *a4 + 1) << a2;
    v13 = a2 + 1;
    v14 = (a7[1] + a4[1] + 1) << a2;
    do
    {
      v15 = 0;
      v16 = -2;
      do
      {
        v17 = (v12 + (*(__int16 *)(a5 + v15) + 0x2000) * *a3 + (*(__int16 *)(a8 + v15) + 0x2000) * *a6) >> v13;
        if (v17 >= 1023)
          v17 = 1023;
        *(_WORD *)(a10 + v15) = v17 & ~(unsigned __int16)(v17 >> 31);
        v18 = (v14 + (*(__int16 *)(a5 + v15 + 2) + 0x2000) * a3[1] + (*(__int16 *)(a8 + v15 + 2) + 0x2000) * a6[1]) >> v13;
        if (v18 >= 1023)
          v18 = 1023;
        *(_WORD *)(a10 + v15 + 2) = v18 & ~(unsigned __int16)(v18 >> 31);
        v16 += 2;
        v15 += 4;
      }
      while (v16 < 0xA);
      ++v10;
      a5 += 24;
      a8 += 24;
      a10 += 2 * a9;
    }
    while (v10 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D8D80(uint64_t result, char a2, __int16 *a3, __int16 *a4, uint64_t a5, __int16 *a6, __int16 *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  int v10;
  int v12;
  char v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  int v18;

  if ((int)result >= 1)
  {
    v10 = 0;
    v12 = (*a7 + *a4 + 1) << a2;
    v13 = a2 + 1;
    v14 = (a7[1] + a4[1] + 1) << a2;
    do
    {
      v15 = 0;
      v16 = -2;
      do
      {
        v17 = (v12 + (*(__int16 *)(a5 + v15) + 0x2000) * *a3 + (*(__int16 *)(a8 + v15) + 0x2000) * *a6) >> v13;
        if (v17 >= 1023)
          v17 = 1023;
        *(_WORD *)(a10 + v15) = v17 & ~(unsigned __int16)(v17 >> 31);
        v18 = (v14 + (*(__int16 *)(a5 + v15 + 2) + 0x2000) * a3[1] + (*(__int16 *)(a8 + v15 + 2) + 0x2000) * a6[1]) >> v13;
        if (v18 >= 1023)
          v18 = 1023;
        *(_WORD *)(a10 + v15 + 2) = v18 & ~(unsigned __int16)(v18 >> 31);
        v16 += 2;
        v15 += 4;
      }
      while (v16 < 0x16);
      ++v10;
      a5 += 48;
      a8 += 48;
      a10 += 2 * a9;
    }
    while (v10 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D8E74(uint64_t result, char a2, __int16 *a3, __int16 *a4, uint64_t a5, __int16 *a6, __int16 *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  int v10;
  int v12;
  char v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  int v18;

  if ((int)result >= 1)
  {
    v10 = 0;
    v12 = (*a7 + *a4 + 1) << a2;
    v13 = a2 + 1;
    v14 = (a7[1] + a4[1] + 1) << a2;
    do
    {
      v15 = 0;
      v16 = -2;
      do
      {
        v17 = (v12 + (*(__int16 *)(a5 + v15) + 0x2000) * *a3 + (*(__int16 *)(a8 + v15) + 0x2000) * *a6) >> v13;
        if (v17 >= 1023)
          v17 = 1023;
        *(_WORD *)(a10 + v15) = v17 & ~(unsigned __int16)(v17 >> 31);
        v18 = (v14 + (*(__int16 *)(a5 + v15 + 2) + 0x2000) * a3[1] + (*(__int16 *)(a8 + v15 + 2) + 0x2000) * a6[1]) >> v13;
        if (v18 >= 1023)
          v18 = 1023;
        *(_WORD *)(a10 + v15 + 2) = v18 & ~(unsigned __int16)(v18 >> 31);
        v16 += 2;
        v15 += 4;
      }
      while (v16 < 0x2E);
      ++v10;
      a5 += 96;
      a8 += 96;
      a10 += 2 * a9;
    }
    while (v10 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D8F68(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v5;
  uint64_t i;
  int v7;

  if ((int)result >= 1)
  {
    v5 = 0;
    do
    {
      for (i = 0; i != 24; i += 2)
      {
        v7 = (*(__int16 *)(a2 + i) + *(__int16 *)(a3 + i) + 16400) >> 5;
        if (v7 >= 1023)
          v7 = 1023;
        *(_WORD *)(a5 + i) = v7 & ~(unsigned __int16)(v7 >> 31);
      }
      ++v5;
      a2 += 24;
      a3 += 24;
      a5 += 2 * a4;
    }
    while (v5 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D8FD0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v5;
  uint64_t i;
  int v7;

  if ((int)result >= 1)
  {
    v5 = 0;
    do
    {
      for (i = 0; i != 48; i += 2)
      {
        v7 = (*(__int16 *)(a2 + i) + *(__int16 *)(a3 + i) + 16400) >> 5;
        if (v7 >= 1023)
          v7 = 1023;
        *(_WORD *)(a5 + i) = v7 & ~(unsigned __int16)(v7 >> 31);
      }
      ++v5;
      a2 += 48;
      a3 += 48;
      a5 += 2 * a4;
    }
    while (v5 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D9038(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v5;
  uint64_t i;
  int v7;

  if ((int)result >= 1)
  {
    v5 = 0;
    do
    {
      for (i = 0; i != 96; i += 2)
      {
        v7 = (*(__int16 *)(a2 + i) + *(__int16 *)(a3 + i) + 16400) >> 5;
        if (v7 >= 1023)
          v7 = 1023;
        *(_WORD *)(a5 + i) = v7 & ~(unsigned __int16)(v7 >> 31);
      }
      ++v5;
      a2 += 96;
      a3 += 96;
      a5 += 2 * a4;
    }
    while (v5 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D90A0(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = a4 - 6;
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = 0;
        do
        {
          v11 += byte_1B6920C55[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        v12 = (v11 + 32) >> 6;
        if (v12 >= 511)
          v12 = 511;
        *(_WORD *)(a6 + 2 * v8++) = v12 & ~(unsigned __int16)(v12 >> 31);
        v9 += 2;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D9134(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = a4 - 6;
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = 0;
        do
        {
          v11 += byte_1B6920C55[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        v12 = (v11 + 32) >> 6;
        if (v12 >= 511)
          v12 = 511;
        *(_WORD *)(a6 + 2 * v8++) = v12 & ~(unsigned __int16)(v12 >> 31);
        v9 += 2;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D91C8(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = a4 - 6;
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = 0;
        do
        {
          v11 += byte_1B6920C55[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        v12 = (v11 + 32) >> 6;
        if (v12 >= 511)
          v12 = 511;
        *(_WORD *)(a6 + 2 * v8++) = v12 & ~(unsigned __int16)(v12 >> 31);
        v9 += 2;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D925C(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 6 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -8;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        v15 = (v11 + 32) >> 6;
        if (v15 >= 511)
          v15 = 511;
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D92F4(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 6 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -8;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        v15 = (v11 + 32) >> 6;
        if (v15 >= 511)
          v15 = 511;
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D938C(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 6 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -8;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        v15 = (v11 + 32) >> 6;
        if (v15 >= 511)
          v15 = 511;
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D9424(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v15;
  __int16 *v16;
  uint64_t v17;
  __int16 *v18;
  int v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  int v24;
  _QWORD v25[214];

  v25[213] = *MEMORY[0x1E0C80C00];
  if ((int)result >= -6)
  {
    v6 = 0;
    v7 = a4 - 6 * a3 - 6;
    v8 = 2 * a3;
    v9 = v25;
    do
    {
      v10 = 0;
      v11 = v7;
      do
      {
        v12 = 0;
        v13 = 0;
        do
        {
          v13 += byte_1B6920C55[8 * (a2 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *((_WORD *)v9 + v10++) = v13 >> 1;
        v11 += 2;
      }
      while (v10 != 12);
      v9 += 3;
      v7 += v8;
    }
    while (v6++ != (_DWORD)result + 6);
    if ((int)result >= 1)
    {
      v15 = 0;
      v16 = (__int16 *)v25;
      do
      {
        v17 = 0;
        v18 = v16;
        do
        {
          v19 = 0;
          v20 = -8;
          v21 = v18;
          do
          {
            v22 = *v21;
            v21 += 12;
            v19 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          v24 = (v19 + 1024) >> 11;
          if (v24 >= 511)
            v24 = 511;
          *(_WORD *)(a6 + 2 * v17++) = v24 & ~(unsigned __int16)(v24 >> 31);
          ++v18;
        }
        while (v17 != 12);
        ++v15;
        a6 += 2 * a5;
        v16 += 12;
      }
      while (v15 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D9580(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v15;
  __int16 *v16;
  uint64_t v17;
  __int16 *v18;
  int v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  int v24;
  _BYTE v25[3408];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if ((int)result >= -6)
  {
    v6 = 0;
    v7 = a4 - 6 * a3 - 6;
    v8 = 2 * a3;
    v9 = v25;
    do
    {
      v10 = 0;
      v11 = v7;
      do
      {
        v12 = 0;
        v13 = 0;
        do
        {
          v13 += byte_1B6920C55[8 * (a2 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *(_WORD *)&v9[2 * v10++] = v13 >> 1;
        v11 += 2;
      }
      while (v10 != 24);
      v9 += 48;
      v7 += v8;
    }
    while (v6++ != (_DWORD)result + 6);
    if ((int)result >= 1)
    {
      v15 = 0;
      v16 = (__int16 *)v25;
      do
      {
        v17 = 0;
        v18 = v16;
        do
        {
          v19 = 0;
          v20 = -8;
          v21 = v18;
          do
          {
            v22 = *v21;
            v21 += 24;
            v19 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          v24 = (v19 + 1024) >> 11;
          if (v24 >= 511)
            v24 = 511;
          *(_WORD *)(a6 + 2 * v17++) = v24 & ~(unsigned __int16)(v24 >> 31);
          ++v18;
        }
        while (v17 != 24);
        ++v15;
        a6 += 2 * a5;
        v16 += 24;
      }
      while (v15 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D96DC()
{
  uint64_t result;
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v15;
  __int16 *v16;
  uint64_t v17;
  __int16 *v18;
  int v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  int v24;
  _BYTE v25[6816];
  uint64_t v26;

  result = MEMORY[0x1E0C80A78]();
  v26 = *MEMORY[0x1E0C80C00];
  if ((int)result >= -6)
  {
    v6 = 0;
    v7 = v3 - 6 * v2 - 6;
    v8 = 2 * v2;
    v9 = v25;
    do
    {
      v10 = 0;
      v11 = v7;
      do
      {
        v12 = 0;
        v13 = 0;
        do
        {
          v13 += byte_1B6920C55[8 * (v1 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *(_WORD *)&v9[2 * v10++] = v13 >> 1;
        v11 += 2;
      }
      while (v10 != 48);
      v9 += 96;
      v7 += v8;
    }
    while (v6++ != (_DWORD)result + 6);
    if ((int)result >= 1)
    {
      v15 = 0;
      v16 = (__int16 *)v25;
      do
      {
        v17 = 0;
        v18 = v16;
        do
        {
          v19 = 0;
          v20 = -8;
          v21 = v18;
          do
          {
            v22 = *v21;
            v21 += 48;
            v19 += byte_1B6920C55[8 * ((v1 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          v24 = (v19 + 1024) >> 11;
          if (v24 >= 511)
            v24 = 511;
          *(_WORD *)(v5 + 2 * v17++) = v24 & ~(unsigned __int16)(v24 >> 31);
          ++v18;
        }
        while (v17 != 48);
        ++v15;
        v5 += 2 * v4;
        v16 += 48;
      }
      while (v15 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D9850(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;
  uint64_t v11;
  unsigned __int16 *v12;
  int v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = -4;
        v12 = v9;
        do
        {
          v13 = *v12;
          v12 += 2;
          v10 += byte_1B6920C6D[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        v15 = (v10 + 32) >> 6;
        if (v15 >= 511)
          v15 = 511;
        *(_WORD *)(a6 + 2 * v8++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v9;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D98E0(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;
  uint64_t v11;
  unsigned __int16 *v12;
  int v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = -4;
        v12 = v9;
        do
        {
          v13 = *v12;
          v12 += 2;
          v10 += byte_1B6920C6D[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        v15 = (v10 + 32) >> 6;
        if (v15 >= 511)
          v15 = 511;
        *(_WORD *)(a6 + 2 * v8++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v9;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D9970(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;
  uint64_t v11;
  unsigned __int16 *v12;
  int v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = -4;
        v12 = v9;
        do
        {
          v13 = *v12;
          v12 += 2;
          v10 += byte_1B6920C6D[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        v15 = (v10 + 32) >> 6;
        if (v15 >= 511)
          v15 = 511;
        *(_WORD *)(a6 + 2 * v8++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v9;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D9A00(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 2 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -4;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        v15 = (v11 + 32) >> 6;
        if (v15 >= 511)
          v15 = 511;
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D9A94(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 2 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -4;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        v15 = (v11 + 32) >> 6;
        if (v15 >= 511)
          v15 = 511;
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D9B28(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;
  int v15;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 2 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -4;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        v15 = (v11 + 32) >> 6;
        if (v15 >= 511)
          v15 = 511;
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67D9BBC(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned __int16 *v14;
  int v15;
  BOOL v16;
  int v18;
  __int16 *v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  uint64_t v23;
  __int16 *v24;
  int v25;
  int v26;
  _QWORD v27[202];

  v27[201] = *MEMORY[0x1E0C80C00];
  if ((int)result >= -2)
  {
    v6 = 0;
    v7 = 2 * a3;
    v8 = a4 - 2 * a3 - 4;
    v9 = v27;
    do
    {
      v10 = 0;
      v11 = (unsigned __int16 *)v8;
      do
      {
        v12 = 0;
        v13 = -4;
        v14 = v11;
        do
        {
          v15 = *v14;
          v14 += 2;
          v12 += byte_1B6920C6D[4 * (a2 & 7) + v13] * v15;
          v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *((_WORD *)v9 + v10++) = v12 >> 1;
        ++v11;
      }
      while (v10 != 12);
      v9 += 3;
      v8 += v7;
    }
    while (v6++ != (_DWORD)result + 2);
    if ((int)result >= 1)
    {
      v18 = 0;
      v19 = (__int16 *)v27;
      do
      {
        v20 = 0;
        v21 = v19;
        do
        {
          v22 = 0;
          v23 = -4;
          v24 = v21;
          do
          {
            v25 = *v24;
            v24 += 12;
            v22 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v23] * v25;
            v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          v26 = (v22 + 1024) >> 11;
          if (v26 >= 511)
            v26 = 511;
          *(_WORD *)(a6 + 2 * v20++) = v26 & ~(unsigned __int16)(v26 >> 31);
          ++v21;
        }
        while (v20 != 12);
        ++v18;
        a6 += 2 * a5;
        v19 += 12;
      }
      while (v18 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D9D10(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned __int16 *v14;
  int v15;
  BOOL v16;
  int v18;
  __int16 *v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  uint64_t v23;
  __int16 *v24;
  int v25;
  int v26;
  _BYTE v27[3216];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if ((int)result >= -2)
  {
    v6 = 0;
    v7 = 2 * a3;
    v8 = a4 - 2 * a3 - 4;
    v9 = v27;
    do
    {
      v10 = 0;
      v11 = (unsigned __int16 *)v8;
      do
      {
        v12 = 0;
        v13 = -4;
        v14 = v11;
        do
        {
          v15 = *v14;
          v14 += 2;
          v12 += byte_1B6920C6D[4 * (a2 & 7) + v13] * v15;
          v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *(_WORD *)&v9[2 * v10++] = v12 >> 1;
        ++v11;
      }
      while (v10 != 24);
      v9 += 48;
      v8 += v7;
    }
    while (v6++ != (_DWORD)result + 2);
    if ((int)result >= 1)
    {
      v18 = 0;
      v19 = (__int16 *)v27;
      do
      {
        v20 = 0;
        v21 = v19;
        do
        {
          v22 = 0;
          v23 = -4;
          v24 = v21;
          do
          {
            v25 = *v24;
            v24 += 24;
            v22 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v23] * v25;
            v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          v26 = (v22 + 1024) >> 11;
          if (v26 >= 511)
            v26 = 511;
          *(_WORD *)(a6 + 2 * v20++) = v26 & ~(unsigned __int16)(v26 >> 31);
          ++v21;
        }
        while (v20 != 24);
        ++v18;
        a6 += 2 * a5;
        v19 += 24;
      }
      while (v18 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D9E64()
{
  uint64_t result;
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned __int16 *v14;
  int v15;
  BOOL v16;
  int v18;
  __int16 *v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  uint64_t v23;
  __int16 *v24;
  int v25;
  int v26;
  _BYTE v27[6432];
  uint64_t v28;

  result = MEMORY[0x1E0C80A78]();
  v28 = *MEMORY[0x1E0C80C00];
  if ((int)result >= -2)
  {
    v6 = 0;
    v7 = 2 * v2;
    v8 = v3 - 2 * v2 - 4;
    v9 = v27;
    do
    {
      v10 = 0;
      v11 = (unsigned __int16 *)v8;
      do
      {
        v12 = 0;
        v13 = -4;
        v14 = v11;
        do
        {
          v15 = *v14;
          v14 += 2;
          v12 += byte_1B6920C6D[4 * (v1 & 7) + v13] * v15;
          v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *(_WORD *)&v9[2 * v10++] = v12 >> 1;
        ++v11;
      }
      while (v10 != 48);
      v9 += 96;
      v8 += v7;
    }
    while (v6++ != (_DWORD)result + 2);
    if ((int)result >= 1)
    {
      v18 = 0;
      v19 = (__int16 *)v27;
      do
      {
        v20 = 0;
        v21 = v19;
        do
        {
          v22 = 0;
          v23 = -4;
          v24 = v21;
          do
          {
            v25 = *v24;
            v24 += 48;
            v22 += byte_1B6920C6D[4 * ((v1 >> 16) & 7) + v23] * v25;
            v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          v26 = (v22 + 1024) >> 11;
          if (v26 >= 511)
            v26 = 511;
          *(_WORD *)(v5 + 2 * v20++) = v26 & ~(unsigned __int16)(v26 >> 31);
          ++v21;
        }
        while (v20 != 48);
        ++v18;
        v5 += 2 * v4;
        v19 += 48;
      }
      while (v18 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67D9FD0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t i;

  if ((int)result >= 1)
  {
    v6 = 0;
    do
    {
      for (i = 0; i != 24; i += 2)
        *(_WORD *)(a6 + i) = 32 * *(_WORD *)(a4 + i) - 0x2000;
      ++v6;
      a6 += 2 * a5;
      a4 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67DA01C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t i;

  if ((int)result >= 1)
  {
    v6 = 0;
    do
    {
      for (i = 0; i != 48; i += 2)
        *(_WORD *)(a6 + i) = 32 * *(_WORD *)(a4 + i) - 0x2000;
      ++v6;
      a6 += 2 * a5;
      a4 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67DA068(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t i;

  if ((int)result >= 1)
  {
    v6 = 0;
    do
    {
      for (i = 0; i != 96; i += 2)
        *(_WORD *)(a6 + i) = 32 * *(_WORD *)(a4 + i) - 0x2000;
      ++v6;
      a6 += 2 * a5;
      a4 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67DA0B4(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = a4 - 6;
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = 0;
        do
        {
          v11 += byte_1B6920C55[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        *(_WORD *)(a6 + 2 * v8++) = (v11 + 114688) >> 1;
        v9 += 2;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67DA138(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = a4 - 6;
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = 0;
        do
        {
          v11 += byte_1B6920C55[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        *(_WORD *)(a6 + 2 * v8++) = (v11 + 114688) >> 1;
        v9 += 2;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67DA1BC(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = a4 - 6;
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = 0;
        do
        {
          v11 += byte_1B6920C55[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        *(_WORD *)(a6 + 2 * v8++) = (v11 + 114688) >> 1;
        v9 += 2;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67DA240(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 6 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -8;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 114688) >> 1;
        ++v10;
      }
      while (v9 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67DA2C8(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 6 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -8;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 114688) >> 1;
        ++v10;
      }
      while (v9 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67DA350(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 6 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -8;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 114688) >> 1;
        ++v10;
      }
      while (v9 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67DA3D8(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v15;
  __int16 *v16;
  uint64_t v17;
  __int16 *v18;
  unsigned int v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  _QWORD v24[214];

  v24[213] = *MEMORY[0x1E0C80C00];
  if ((int)result >= -6)
  {
    v6 = 0;
    v7 = a4 - 6 * a3 - 6;
    v8 = 2 * a3;
    v9 = v24;
    do
    {
      v10 = 0;
      v11 = v7;
      do
      {
        v12 = 0;
        v13 = 0;
        do
        {
          v13 += byte_1B6920C55[8 * (a2 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *((_WORD *)v9 + v10++) = (v13 + 114688) >> 1;
        v11 += 2;
      }
      while (v10 != 12);
      v9 += 3;
      v7 += v8;
    }
    while (v6++ != (_DWORD)result + 6);
    if ((int)result >= 1)
    {
      v15 = 0;
      v16 = (__int16 *)v24;
      do
      {
        v17 = 0;
        v18 = v16;
        do
        {
          v19 = 0;
          v20 = -8;
          v21 = v18;
          do
          {
            v22 = *v21;
            v21 += 12;
            v19 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          *(_WORD *)(a6 + 2 * v17++) = v19 >> 6;
          ++v18;
        }
        while (v17 != 12);
        ++v15;
        a6 += 2 * a5;
        v16 += 12;
      }
      while (v15 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67DA524(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v15;
  __int16 *v16;
  uint64_t v17;
  __int16 *v18;
  unsigned int v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  _BYTE v24[3408];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if ((int)result >= -6)
  {
    v6 = 0;
    v7 = a4 - 6 * a3 - 6;
    v8 = 2 * a3;
    v9 = v24;
    do
    {
      v10 = 0;
      v11 = v7;
      do
      {
        v12 = 0;
        v13 = 0;
        do
        {
          v13 += byte_1B6920C55[8 * (a2 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *(_WORD *)&v9[2 * v10++] = (v13 + 114688) >> 1;
        v11 += 2;
      }
      while (v10 != 24);
      v9 += 48;
      v7 += v8;
    }
    while (v6++ != (_DWORD)result + 6);
    if ((int)result >= 1)
    {
      v15 = 0;
      v16 = (__int16 *)v24;
      do
      {
        v17 = 0;
        v18 = v16;
        do
        {
          v19 = 0;
          v20 = -8;
          v21 = v18;
          do
          {
            v22 = *v21;
            v21 += 24;
            v19 += byte_1B6920C55[8 * ((a2 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          *(_WORD *)(a6 + 2 * v17++) = v19 >> 6;
          ++v18;
        }
        while (v17 != 24);
        ++v15;
        a6 += 2 * a5;
        v16 += 24;
      }
      while (v15 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67DA670()
{
  uint64_t result;
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v15;
  __int16 *v16;
  uint64_t v17;
  __int16 *v18;
  unsigned int v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  _BYTE v24[6816];
  uint64_t v25;

  result = MEMORY[0x1E0C80A78]();
  v25 = *MEMORY[0x1E0C80C00];
  if ((int)result >= -6)
  {
    v6 = 0;
    v7 = v3 - 6 * v2 - 6;
    v8 = 2 * v2;
    v9 = v24;
    do
    {
      v10 = 0;
      v11 = v7;
      do
      {
        v12 = 0;
        v13 = 0;
        do
        {
          v13 += byte_1B6920C55[8 * (v1 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *(_WORD *)&v9[2 * v10++] = (v13 + 114688) >> 1;
        v11 += 2;
      }
      while (v10 != 48);
      v9 += 96;
      v7 += v8;
    }
    while (v6++ != (_DWORD)result + 6);
    if ((int)result >= 1)
    {
      v15 = 0;
      v16 = (__int16 *)v24;
      do
      {
        v17 = 0;
        v18 = v16;
        do
        {
          v19 = 0;
          v20 = -8;
          v21 = v18;
          do
          {
            v22 = *v21;
            v21 += 48;
            v19 += byte_1B6920C55[8 * ((v1 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          *(_WORD *)(v5 + 2 * v17++) = v19 >> 6;
          ++v18;
        }
        while (v17 != 48);
        ++v15;
        v5 += 2 * v4;
        v16 += 48;
      }
      while (v15 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67DA7D4(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;
  uint64_t v11;
  unsigned __int16 *v12;
  int v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = -4;
        v12 = v9;
        do
        {
          v13 = *v12;
          v12 += 2;
          v10 += byte_1B6920C6D[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = (v10 + 114688) >> 1;
        ++v9;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67DA854(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;
  uint64_t v11;
  unsigned __int16 *v12;
  int v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = -4;
        v12 = v9;
        do
        {
          v13 = *v12;
          v12 += 2;
          v10 += byte_1B6920C6D[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = (v10 + 114688) >> 1;
        ++v9;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67DA8D4(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;
  uint64_t v11;
  unsigned __int16 *v12;
  int v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      v8 = 0;
      v9 = v7;
      do
      {
        v10 = 0;
        v11 = -4;
        v12 = v9;
        do
        {
          v13 = *v12;
          v12 += 2;
          v10 += byte_1B6920C6D[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = (v10 + 114688) >> 1;
        ++v9;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67DA954(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 2 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -4;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 114688) >> 1;
        ++v10;
      }
      while (v9 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67DA9D8(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 2 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -4;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 114688) >> 1;
        ++v10;
      }
      while (v9 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67DAA5C(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int v11;
  uint64_t v12;
  unsigned __int16 *v13;

  if ((int)result >= 1)
  {
    v6 = 0;
    v7 = (unsigned __int16 *)(a4 - 2 * a3);
    v8 = 2 * a3;
    do
    {
      v9 = 0;
      v10 = v7;
      do
      {
        v11 = 0;
        v12 = -4;
        v13 = v10;
        do
        {
          v11 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v12] * *v13;
          v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 114688) >> 1;
        ++v10;
      }
      while (v9 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != (_DWORD)result);
  }
  return result;
}

uint64_t sub_1B67DAAE0(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unsigned __int16 *v11;
  int v12;
  uint64_t v13;
  unsigned __int16 *v14;
  int v15;
  BOOL v16;
  int v18;
  __int16 *v19;
  uint64_t v20;
  __int16 *v21;
  unsigned int v22;
  uint64_t v23;
  __int16 *v24;
  int v25;
  _QWORD v26[202];

  v26[201] = *MEMORY[0x1E0C80C00];
  if ((int)result >= -2)
  {
    v6 = 0;
    v7 = 2 * a3;
    v8 = a4 - 2 * a3 - 4;
    v9 = v26;
    do
    {
      v10 = 0;
      v11 = (unsigned __int16 *)v8;
      do
      {
        v12 = 0;
        v13 = -4;
        v14 = v11;
        do
        {
          v15 = *v14;
          v14 += 2;
          v12 += byte_1B6920C6D[4 * (a2 & 7) + v13] * v15;
          v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *((_WORD *)v9 + v10++) = (v12 + 114688) >> 1;
        ++v11;
      }
      while (v10 != 12);
      v9 += 3;
      v8 += v7;
    }
    while (v6++ != (_DWORD)result + 2);
    if ((int)result >= 1)
    {
      v18 = 0;
      v19 = (__int16 *)v26;
      do
      {
        v20 = 0;
        v21 = v19;
        do
        {
          v22 = 0;
          v23 = -4;
          v24 = v21;
          do
          {
            v25 = *v24;
            v24 += 12;
            v22 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v23] * v25;
            v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          *(_WORD *)(a6 + 2 * v20++) = v22 >> 6;
          ++v21;
        }
        while (v20 != 12);
        ++v18;
        a6 += 2 * a5;
        v19 += 12;
      }
      while (v18 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67DAC24(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  unsigned __int16 *v11;
  int v12;
  uint64_t v13;
  unsigned __int16 *v14;
  int v15;
  BOOL v16;
  int v18;
  __int16 *v19;
  uint64_t v20;
  __int16 *v21;
  unsigned int v22;
  uint64_t v23;
  __int16 *v24;
  int v25;
  _BYTE v26[3216];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if ((int)result >= -2)
  {
    v6 = 0;
    v7 = 2 * a3;
    v8 = a4 - 2 * a3 - 4;
    v9 = v26;
    do
    {
      v10 = 0;
      v11 = (unsigned __int16 *)v8;
      do
      {
        v12 = 0;
        v13 = -4;
        v14 = v11;
        do
        {
          v15 = *v14;
          v14 += 2;
          v12 += byte_1B6920C6D[4 * (a2 & 7) + v13] * v15;
          v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *(_WORD *)&v9[2 * v10++] = (v12 + 114688) >> 1;
        ++v11;
      }
      while (v10 != 24);
      v9 += 48;
      v8 += v7;
    }
    while (v6++ != (_DWORD)result + 2);
    if ((int)result >= 1)
    {
      v18 = 0;
      v19 = (__int16 *)v26;
      do
      {
        v20 = 0;
        v21 = v19;
        do
        {
          v22 = 0;
          v23 = -4;
          v24 = v21;
          do
          {
            v25 = *v24;
            v24 += 24;
            v22 += byte_1B6920C6D[4 * ((a2 >> 16) & 7) + v23] * v25;
            v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          *(_WORD *)(a6 + 2 * v20++) = v22 >> 6;
          ++v21;
        }
        while (v20 != 24);
        ++v18;
        a6 += 2 * a5;
        v19 += 24;
      }
      while (v18 != (_DWORD)result);
    }
  }
  return result;
}

uint64_t sub_1B67DAD68()
{
  uint64_t result;
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  unsigned __int16 *v11;
  int v12;
  uint64_t v13;
  unsigned __int16 *v14;
  int v15;
  BOOL v16;
  int v18;
  __int16 *v19;
  uint64_t v20;
  __int16 *v21;
  unsigned int v22;
  uint64_t v23;
  __int16 *v24;
  int v25;
  _BYTE v26[6432];
  uint64_t v27;

  result = MEMORY[0x1E0C80A78]();
  v27 = *MEMORY[0x1E0C80C00];
  if ((int)result >= -2)
  {
    v6 = 0;
    v7 = 2 * v2;
    v8 = v3 - 2 * v2 - 4;
    v9 = v26;
    do
    {
      v10 = 0;
      v11 = (unsigned __int16 *)v8;
      do
      {
        v12 = 0;
        v13 = -4;
        v14 = v11;
        do
        {
          v15 = *v14;
          v14 += 2;
          v12 += byte_1B6920C6D[4 * (v1 & 7) + v13] * v15;
          v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *(_WORD *)&v9[2 * v10++] = (v12 + 114688) >> 1;
        ++v11;
      }
      while (v10 != 48);
      v9 += 96;
      v8 += v7;
    }
    while (v6++ != (_DWORD)result + 2);
    if ((int)result >= 1)
    {
      v18 = 0;
      v19 = (__int16 *)v26;
      do
      {
        v20 = 0;
        v21 = v19;
        do
        {
          v22 = 0;
          v23 = -4;
          v24 = v21;
          do
          {
            v25 = *v24;
            v24 += 48;
            v22 += byte_1B6920C6D[4 * ((v1 >> 16) & 7) + v23] * v25;
            v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          *(_WORD *)(v5 + 2 * v20++) = v22 >> 6;
          ++v21;
        }
        while (v20 != 48);
        ++v18;
        v5 += 2 * v4;
        v19 += 48;
      }
      while (v18 != (_DWORD)result);
    }
  }
  return result;
}

