uint64_t apfs_container_iouc(char *__s, _DWORD *a2, io_connect_t *a3, io_registry_entry_t *a4, int a5)
{
  char *v9;
  char *v10;
  io_registry_entry_t volume_io_object;
  uint64_t v12;
  uint64_t v13;
  const char *apfs_io_object;
  io_service_t first_child_of_class;
  int v17;
  io_object_t v18;
  unsigned __int8 v20;
  io_registry_entry_t parent;

  parent = 0;
  if (a2)
  {
    v9 = strrchr(__s, 47);
    if (v9)
      v10 = v9 + 1;
    else
      v10 = __s;
    v20 = 0;
    volume_io_object = get_volume_io_object(v10, &v20);
    if (volume_io_object)
    {
      LODWORD(v12) = volume_io_object;
      if (IORegistryEntryGetParentEntry(volume_io_object, "IOService", &parent))
      {
        v13 = 49158;
LABEL_24:
        IOObjectRelease(v12);
        return v13;
      }
      if (IOObjectConformsTo(parent, "AppleAPFSContainer"))
      {
        v17 = fsindex_parse(v10, v20);
        *a2 = v17;
        if (v17 != -1)
        {
          first_child_of_class = parent;
LABEL_17:
          v13 = IOServiceOpen(first_child_of_class, *MEMORY[0x1E0C83DA0], 0, a3);
          v18 = parent;
          if (a4 && !(_DWORD)v13)
          {
            *a4 = parent;
            goto LABEL_24;
          }
LABEL_23:
          IOObjectRelease(v18);
          goto LABEL_24;
        }
        v13 = 49154;
      }
      else
      {
        v13 = 49231;
      }
      v18 = parent;
      goto LABEL_23;
    }
  }
  else
  {
    apfs_io_object = get_apfs_io_object(__s);
    if ((_DWORD)apfs_io_object)
    {
      v12 = (uint64_t)apfs_io_object;
      first_child_of_class = get_first_child_of_class((uint64_t)apfs_io_object, "AppleAPFSContainer");
      parent = first_child_of_class;
      if (!first_child_of_class)
      {
        if (!a5 || (first_child_of_class = physical_store_to_container(v12), (parent = first_child_of_class) == 0))
        {
          v13 = 49231;
          goto LABEL_24;
        }
      }
      goto LABEL_17;
    }
  }
  return 49154;
}

uint64_t APFSVolumeRole(char *a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  io_registry_entry_t volume_io_object;
  io_object_t v7;
  CFTypeRef CFProperty;
  const void *v9;
  CFTypeID v10;
  uint64_t v11;
  __int16 v12;
  __int16 v13;
  uint64_t v14;
  unsigned __int16 valuePtr;
  size_t outputStructCnt;
  int outputStruct;
  __int16 v19;
  __int16 v20;
  io_connect_t v21;

  outputStructCnt = 2;
  if (!a1)
    return 3758097090;
  v21 = 0;
  bzero(&outputStruct, 0x978uLL);
  volume_io_object = get_volume_io_object(a1, 0);
  if (volume_io_object)
  {
    v7 = volume_io_object;
    CFProperty = IORegistryEntryCreateCFProperty(volume_io_object, CFSTR("RoleValue"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    if (CFProperty)
    {
      v9 = CFProperty;
      v10 = CFGetTypeID(CFProperty);
      if (v10 == CFNumberGetTypeID())
      {
        valuePtr = 0;
        if (CFNumberGetValue((CFNumberRef)v9, kCFNumberSInt16Type, &valuePtr))
        {
          if (a2)
            *a2 = valuePtr;
          if (!a3 || *a3 == valuePtr)
          {
            CFRelease(v9);
            IOObjectRelease(v7);
            return 0;
          }
        }
      }
      CFRelease(v9);
    }
    IOObjectRelease(v7);
  }
  v11 = apfs_container_iouc(a1, &outputStruct, &v21, 0, 0);
  if (!(_DWORD)v11)
  {
    if (a3)
    {
      v12 = *a3;
      v13 = -1;
    }
    else
    {
      v13 = 0;
      v12 = 0;
    }
    v19 = v13;
    v20 = v12;
    v14 = IOConnectCallStructMethod(v21, 9u, &outputStruct, 8uLL, &outputStruct, &outputStructCnt);
    v11 = v14;
    if (a2 && !(_DWORD)v14)
      *a2 = outputStruct;
    IOServiceClose(v21);
  }
  return v11;
}

const char *get_volume_io_object(const char *a1, _BYTE *a2)
{
  const char *result;
  int volume_io_object_from_snapshot;
  io_object_t object;

  result = get_apfs_io_object(a1);
  object = result;
  if ((_DWORD)result)
  {
    volume_io_object_from_snapshot = get_volume_io_object_from_snapshot(&object, a2);
    result = (const char *)object;
    if (!volume_io_object_from_snapshot)
    {
      IOObjectRelease(object);
      return 0;
    }
  }
  return result;
}

const char *get_apfs_io_object(const char *result)
{
  const char *v1;
  int v2;
  mach_port_t v3;
  const __CFDictionary *v4;

  if (result)
  {
    v1 = result;
    if (!strncmp(result, "/dev/", 5uLL))
    {
      v2 = *((unsigned __int8 *)v1 + 5);
      v1 += 5;
      if (v2 == 114)
        ++v1;
    }
    v3 = *MEMORY[0x1E0CBBAB8];
    v4 = IOBSDNameMatching(*MEMORY[0x1E0CBBAB8], 0, v1);
    return (const char *)IOServiceGetMatchingService(v3, v4);
  }
  return result;
}

uint64_t get_volume_io_object_from_snapshot(io_object_t *a1, _BYTE *a2)
{
  BOOLean_t v4;
  io_registry_entry_t v5;
  uint64_t result;
  io_registry_entry_t parent;

  if (a2)
    *a2 = 0;
  v4 = IOObjectConformsTo(*a1, "AppleAPFSSnapshot");
  v5 = *a1;
  if (v4)
  {
    parent = 0;
    if (IORegistryEntryGetParentEntry(v5, "IOService", &parent))
      return 0;
    IOObjectRelease(*a1);
    v5 = parent;
    *a1 = parent;
    if (a2)
      *a2 = 1;
  }
  result = IOObjectConformsTo(v5, "AppleAPFSVolume");
  if ((_DWORD)result)
    return *a1;
  return result;
}

uint64_t fsindex_parse(char *a1, int a2)
{
  char *v4;
  char *v5;
  char v6;
  int v7;

  v4 = strrchr(a1, 115);
  if (!v4)
    return 0xFFFFFFFFLL;
  if (a2)
  {
    v5 = v4 - 1;
    while (v5 > a1)
    {
      v7 = *v5--;
      v6 = v7;
      if ((v7 - 48) >= 0xA)
      {
        if (v6 != 115)
          return 0xFFFFFFFFLL;
        v4 = v5 + 1;
        goto LABEL_8;
      }
    }
    return 0xFFFFFFFFLL;
  }
LABEL_8:
  if (v4 <= a1 || *(v4 - 1) == 47)
    return 0xFFFFFFFFLL;
  return strtoul(v4 + 1, 0, 10) - 1;
}

uint64_t enhanced_apfs_enabled()
{
  io_registry_entry_t v0;
  io_object_t v1;
  CFTypeRef CFProperty;

  v0 = IORegistryEntryFromPath(*MEMORY[0x1E0CBBAB8], "IODeviceTree:/filesystems");
  if (v0)
  {
    v1 = v0;
    CFProperty = IORegistryEntryCreateCFProperty(v0, CFSTR("e-apfs"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    if (CFProperty)
    {
      CFRelease(CFProperty);
      IOObjectRelease(v1);
      return 1;
    }
    IOObjectRelease(v1);
  }
  return os_parse_boot_arg_string();
}

char *jobj_type_to_str(unsigned int a1)
{
  char *v1;

  if (a1 < 0x15)
    return jobj_type_to_str_TYPE_STRINGS[a1];
  v1 = jobj_type_to_str_unknown_str;
  snprintf(jobj_type_to_str_unknown_str, 0x20uLL, "Unknown type %d", a1);
  return v1;
}

__n128 set_metric_default_values(uint64_t a1)
{
  __n128 result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = &stru_1EA984900;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 168) = 0;
  *(_DWORD *)(a1 + 252) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  result.n128_u64[0] = -1;
  result.n128_u64[1] = -1;
  *(__n128 *)(a1 + 256) = result;
  *(__n128 *)(a1 + 272) = result;
  *(_QWORD *)(a1 + 304) = 0;
  *(_QWORD *)(a1 + 312) = -1;
  *(_QWORD *)(a1 + 288) = -1;
  *(_QWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 320) = -1;
  *(_QWORD *)(a1 + 328) = -1;
  *(_QWORD *)(a1 + 336) = 0;
  *(__n128 *)(a1 + 344) = result;
  *(__n128 *)(a1 + 360) = result;
  *(__n128 *)(a1 + 376) = result;
  *(__n128 *)(a1 + 392) = result;
  *(__n128 *)(a1 + 408) = result;
  *(_QWORD *)(a1 + 424) = 0x7FFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 432) = 0x7FFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 440) = -1;
  *(_QWORD *)(a1 + 448) = -1;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(__n128 *)(a1 + 552) = result;
  *(__n128 *)(a1 + 568) = result;
  *(__n128 *)(a1 + 520) = result;
  *(__n128 *)(a1 + 536) = result;
  *(__n128 *)(a1 + 504) = result;
  *(_QWORD *)(a1 + 712) = 0;
  *(_OWORD *)(a1 + 680) = 0u;
  *(_OWORD *)(a1 + 696) = 0u;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_QWORD *)(a1 + 736) = -1;
  *(_QWORD *)(a1 + 728) = -1;
  *(_QWORD *)(a1 + 720) = -1;
  return result;
}

uint64_t set_metric_start_time(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 16) = a2;
  return result;
}

char *set_metric_path(uint64_t a1, char *__s1)
{
  char *result;

  result = strdup(__s1);
  *(_QWORD *)(a1 + 160) = result;
  return result;
}

_DWORD *record_failure(_DWORD *result, int a2, int a3)
{
  _DWORD *v5;
  int v6;
  BOOL v7;
  int v8;
  int v9;
  int v10;
  _DWORD *v11;
  _DWORD *v12;

  v5 = result;
  if ((a3 & 0x80000000) == 0)
  {
    v6 = result[17];
    if (v6 >= 11)
    {
      result = memmove(result + 18, result + 20, 0x48uLL);
      v8 = 9;
    }
    else
    {
      result[17] = v6 + 1;
      v7 = __OFSUB__(v6, 1);
      v8 = v6 - 1;
      if (v8 < 0 != v7)
        goto LABEL_10;
    }
    v10 = v5[42];
    v11 = &v5[2 * v8];
    v11[18] = v5[38];
    v11[19] = v10;
LABEL_10:
    v5[38] = a2;
    v5[42] = a3;
    return result;
  }
  v9 = result[6];
  if (v9 >= 5)
  {
    result = memmove(result + 7, result + 9, 0x48uLL);
    --v9;
  }
  else
  {
    result[6] = v9 + 1;
  }
  v12 = &v5[2 * v9];
  v12[7] = a2;
  v12[8] = a3;
  return result;
}

_QWORD *set_metrics_file(_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

void print_metrics_to_file(uint64_t a1, int a2)
{
  FILE *v3;
  const char *CStringPtr;

  if (*(_QWORD *)a1)
  {
    print_metrics(a1, a2);
    v3 = *(FILE **)a1;
    CStringPtr = CFStringGetCStringPtr(*(CFStringRef *)(a1 + 8), 0x8000100u);
    fprintf(v3, "%s\n", CStringPtr);
    cleanup_metrics(a1);
  }
}

void print_metrics(uint64_t a1, int a2)
{
  const __CFAllocator *v4;
  const char *v5;
  CFStringRef v6;
  const void *v7;
  CFStringRef v8;
  const void *v9;
  CFStringRef v10;
  const void *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  const void *v15;
  CFStringRef v16;
  const void *v17;
  CFStringRef v18;
  const void *v19;
  uint64_t v20;
  unsigned int *v21;
  const void *v22;
  CFStringRef v23;
  const void *v24;
  CFStringRef v25;
  const void *v26;
  uint64_t v27;
  unsigned int *v28;
  const void *v29;
  CFStringRef v30;
  const void *v31;
  uint64_t v32;
  time_t v33;
  CFStringRef v34;
  const void *v35;
  uint64_t v36;
  CFStringRef v37;
  CFStringRef v38;
  const void *v39;
  CFStringRef v40;
  const void *v41;

  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v5 = *(const char **)(a1 + 160);
  if (!v5)
    v5 = "";
  v6 = CFStringCreateWithFormat(v4, 0, CFSTR("%@dev=%s result=%d "), *(_QWORD *)(a1 + 8), v5, *(unsigned int *)(a1 + 168));
  v7 = *(const void **)(a1 + 8);
  if (v7)
    CFRelease(v7);
  *(_QWORD *)(a1 + 8) = v6;
  switch(a2)
  {
    case 2:
      v16 = CFStringCreateWithFormat(v4, 0, CFSTR("%@vers=%s "), v6, "2313.2.1");
      v17 = *(const void **)(a1 + 8);
      if (v17)
        CFRelease(v17);
      *(_QWORD *)(a1 + 8) = v16;
      goto LABEL_22;
    case 1:
LABEL_22:
      print_additional_migrator_metrics((_QWORD *)a1);
      break;
    case 0:
      v8 = CFStringCreateWithFormat(v4, 0, CFSTR("%@vers=%s "), v6, "2313.2.1");
      v9 = *(const void **)(a1 + 8);
      if (v9)
        CFRelease(v9);
      *(_QWORD *)(a1 + 8) = v8;
      v10 = CFStringCreateWithFormat(v4, 0, CFSTR("%@num_src=%llu num_dst=%llu "), v8, *(_QWORD *)(a1 + 176), *(_QWORD *)(a1 + 184));
      v11 = *(const void **)(a1 + 8);
      if (v11)
        CFRelease(v11);
      v12 = 0;
      *(_QWORD *)(a1 + 8) = v10;
      v13 = a1 + 192;
      do
      {
        if (*(_DWORD *)(v13 + 4 * v12))
        {
          v14 = jobj_type_to_str(v12);
          v10 = CFStringCreateWithFormat(v4, 0, CFSTR("%@%s:%d "), v10, v14, *(unsigned int *)(v13 + 4 * v12));
          v15 = *(const void **)(a1 + 8);
          if (v15)
            CFRelease(v15);
          *(_QWORD *)(a1 + 8) = v10;
        }
        ++v12;
      }
      while (v12 != 15);
      break;
  }
  if (*(_DWORD *)(a1 + 24))
  {
    v18 = CFStringCreateWithFormat(v4, 0, CFSTR("%@%s"), *(_QWORD *)(a1 + 8), "w:");
    v19 = *(const void **)(a1 + 8);
    if (v19)
      CFRelease(v19);
    *(_QWORD *)(a1 + 8) = v18;
    if (*(int *)(a1 + 24) >= 1)
    {
      v20 = 0;
      v21 = (unsigned int *)(a1 + 32);
      do
      {
        v18 = CFStringCreateWithFormat(v4, 0, CFSTR("%@(%d:%d)"), v18, *(v21 - 1), *v21);
        v22 = *(const void **)(a1 + 8);
        if (v22)
          CFRelease(v22);
        v21 += 2;
        *(_QWORD *)(a1 + 8) = v18;
        ++v20;
      }
      while (v20 < *(int *)(a1 + 24));
    }
    v23 = CFStringCreateWithFormat(v4, 0, CFSTR("%@%s"), v18, " ");
    v24 = *(const void **)(a1 + 8);
    if (v24)
      CFRelease(v24);
    *(_QWORD *)(a1 + 8) = v23;
  }
  if (*(int *)(a1 + 68) >= 2)
  {
    v25 = CFStringCreateWithFormat(v4, 0, CFSTR("%@%s"), *(_QWORD *)(a1 + 8), "e:");
    v26 = *(const void **)(a1 + 8);
    if (v26)
      CFRelease(v26);
    *(_QWORD *)(a1 + 8) = v25;
    if (*(int *)(a1 + 68) >= 2)
    {
      v27 = 0;
      v28 = (unsigned int *)(a1 + 76);
      do
      {
        v25 = CFStringCreateWithFormat(v4, 0, CFSTR("%@(%d:%d)"), v25, *(v28 - 1), *v28);
        v29 = *(const void **)(a1 + 8);
        if (v29)
          CFRelease(v29);
        v28 += 2;
        *(_QWORD *)(a1 + 8) = v25;
        ++v27;
      }
      while (v27 < *(int *)(a1 + 68) - 1);
    }
    v30 = CFStringCreateWithFormat(v4, 0, CFSTR("%@%s"), v25, " ");
    v31 = *(const void **)(a1 + 8);
    if (v31)
      CFRelease(v31);
    *(_QWORD *)(a1 + 8) = v30;
  }
  if (*(_QWORD *)(a1 + 16))
  {
    v32 = *(_QWORD *)(a1 + 8);
    v33 = time(0);
    v34 = CFStringCreateWithFormat(v4, 0, CFSTR("%@time=%ld "), v32, v33 - *(_QWORD *)(a1 + 16));
    v35 = *(const void **)(a1 + 8);
    if (v35)
      CFRelease(v35);
    *(_QWORD *)(a1 + 8) = v34;
  }
  v36 = *(_QWORD *)(a1 + 400);
  if (v36 == -1)
  {
    v38 = *(CFStringRef *)(a1 + 8);
  }
  else
  {
    if (*(_QWORD *)(a1 + 16))
      v37 = CFStringCreateWithFormat(v4, 0, CFSTR("%@total_t=%llu "), *(_QWORD *)(a1 + 8), v36);
    else
      v37 = CFStringCreateWithFormat(v4, 0, CFSTR("%@time=%llu "), *(_QWORD *)(a1 + 8), v36);
    v38 = v37;
    v39 = *(const void **)(a1 + 8);
    if (v39)
      CFRelease(v39);
    *(_QWORD *)(a1 + 8) = v38;
  }
  v40 = CFStringCreateWithFormat(v4, 0, CFSTR("%@fl=%d"), v38, *(unsigned int *)(a1 + 152));
  v41 = *(const void **)(a1 + 8);
  if (v41)
    CFRelease(v41);
  *(_QWORD *)(a1 + 8) = v40;
}

void cleanup_metrics(uint64_t a1)
{
  FILE *v2;
  void *v3;
  const void *v4;

  v2 = *(FILE **)a1;
  if (v2)
  {
    fclose(v2);
    *(_QWORD *)a1 = 0;
  }
  v3 = *(void **)(a1 + 160);
  if (v3)
  {
    free(v3);
    *(_QWORD *)(a1 + 160) = 0;
  }
  v4 = *(const void **)(a1 + 8);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

void print_additional_migrator_metrics(_QWORD *a1)
{
  uint64_t v2;
  CFAllocatorRef *v3;
  CFStringRef v4;
  const void *v5;
  uint64_t v6;
  CFStringRef v7;
  const void *v8;
  uint64_t v9;
  CFStringRef v10;
  const void *v11;
  uint64_t v12;
  CFStringRef v13;
  const void *v14;
  uint64_t v15;
  CFStringRef v16;
  const void *v17;
  uint64_t v18;
  CFStringRef v19;
  const void *v20;
  uint64_t v21;
  CFStringRef v22;
  const void *v23;
  uint64_t v24;
  CFStringRef v25;
  const void *v26;
  uint64_t v27;
  CFStringRef v28;
  const void *v29;
  uint64_t v30;
  CFStringRef v31;
  const void *v32;
  uint64_t v33;
  CFStringRef v34;
  const void *v35;
  uint64_t v36;
  CFStringRef v37;
  const void *v38;
  uint64_t v39;
  CFStringRef v40;
  const void *v41;
  uint64_t v42;
  CFStringRef v43;
  const void *v44;
  uint64_t v45;
  CFStringRef v46;
  const void *v47;
  uint64_t v48;
  CFStringRef v49;
  const void *v50;
  uint64_t v51;
  CFStringRef v52;
  const void *v53;
  uint64_t v54;
  CFStringRef v55;
  const void *v56;
  uint64_t v57;
  CFStringRef v58;
  const void *v59;
  uint64_t v60;
  CFStringRef v61;
  const void *v62;
  uint64_t v63;
  CFStringRef v64;
  const void *v65;
  uint64_t v66;
  CFStringRef v67;
  const void *v68;
  uint64_t v69;
  CFStringRef v70;
  const void *v71;
  uint64_t v72;
  CFStringRef v73;
  const void *v74;
  uint64_t v75;
  CFStringRef v76;
  const void *v77;
  uint64_t v78;
  CFStringRef v79;
  const void *v80;
  uint64_t v81;
  CFStringRef v82;
  const void *v83;
  uint64_t v84;
  CFStringRef v85;
  const void *v86;
  uint64_t v87;
  CFStringRef v88;
  const void *v89;
  uint64_t v90;
  CFStringRef v91;
  const void *v92;
  uint64_t v93;
  CFStringRef v94;
  const void *v95;
  uint64_t v96;
  CFStringRef v97;
  const void *v98;
  uint64_t v99;
  CFStringRef v100;
  const void *v101;
  uint64_t v102;
  CFStringRef v103;
  const void *v104;
  uint64_t v105;
  CFStringRef v106;
  const void *v107;
  uint64_t v108;
  CFStringRef v109;
  const void *v110;
  uint64_t v111;
  CFStringRef v112;
  const void *v113;
  uint64_t v114;
  CFStringRef v115;
  const void *v116;
  uint64_t v117;
  CFStringRef v118;
  const void *v119;
  uint64_t v120;
  CFStringRef v121;
  const void *v122;
  uint64_t v123;
  CFStringRef v124;
  const void *v125;
  uint64_t v126;
  CFStringRef v127;
  const void *v128;
  uint64_t v129;
  CFStringRef v130;
  const void *v131;
  uint64_t v132;
  CFStringRef v133;
  const void *v134;
  uint64_t v135;
  CFStringRef v136;
  const void *v137;
  uint64_t v138;
  CFStringRef v139;
  const void *v140;
  uint64_t v141;
  CFStringRef v142;
  const void *v143;
  uint64_t v144;
  CFStringRef v145;
  const void *v146;
  uint64_t v147;
  CFStringRef v148;
  const void *v149;
  uint64_t v150;
  CFStringRef v151;
  const void *v152;
  uint64_t v153;
  CFStringRef v154;
  const void *v155;
  uint64_t v156;
  CFStringRef v157;
  const void *v158;
  uint64_t v159;
  CFStringRef v160;
  const void *v161;
  uint64_t v162;
  CFStringRef v163;
  const void *v164;
  uint64_t v165;
  CFStringRef v166;
  const void *v167;
  uint64_t v168;
  CFStringRef v169;
  const void *v170;
  uint64_t v171;
  CFStringRef v172;
  const void *v173;
  uint64_t v174;
  CFStringRef v175;
  const void *v176;
  uint64_t v177;
  CFStringRef v178;
  const void *v179;

  v2 = a1[42];
  v3 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (v2)
  {
    v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@encoded_len=%zu "), a1[1], v2);
    v5 = (const void *)a1[1];
    if (v5)
      CFRelease(v5);
    a1[1] = v4;
  }
  v6 = a1[33];
  if (v6 != -1)
  {
    v7 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@num_dirs=%zu "), a1[1], v6);
    v8 = (const void *)a1[1];
    if (v8)
      CFRelease(v8);
    a1[1] = v7;
  }
  v9 = a1[32];
  if (v9 != -1)
  {
    v10 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@num_files=%zu "), a1[1], v9);
    v11 = (const void *)a1[1];
    if (v11)
      CFRelease(v11);
    a1[1] = v10;
  }
  v12 = a1[35];
  if (v12 != -1)
  {
    v13 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@num_total_dirs=%zu "), a1[1], v12);
    v14 = (const void *)a1[1];
    if (v14)
      CFRelease(v14);
    a1[1] = v13;
  }
  v15 = a1[34];
  if (v15 != -1)
  {
    v16 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@num_total_files=%zu "), a1[1], v15);
    v17 = (const void *)a1[1];
    if (v17)
      CFRelease(v17);
    a1[1] = v16;
  }
  v18 = a1[41];
  if (v18 != -1)
  {
    v19 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@max_stack=%zu "), a1[1], v18);
    v20 = (const void *)a1[1];
    if (v20)
      CFRelease(v20);
    a1[1] = v19;
  }
  v21 = a1[39];
  if (v21 != -1)
  {
    v22 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@num_sc=%zu "), a1[1], v21);
    v23 = (const void *)a1[1];
    if (v23)
      CFRelease(v23);
    a1[1] = v22;
  }
  v24 = a1[36];
  if (v24 != -1)
  {
    v25 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@num_sr=%zu "), a1[1], v24);
    v26 = (const void *)a1[1];
    if (v26)
      CFRelease(v26);
    a1[1] = v25;
  }
  v27 = a1[40];
  if (v27 != -1)
  {
    v28 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@num_sh=%zu "), a1[1], v27);
    v29 = (const void *)a1[1];
    if (v29)
      CFRelease(v29);
    a1[1] = v28;
  }
  v30 = a1[37];
  if (v30)
  {
    v31 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@num_sb=%zu "), a1[1], v30);
    v32 = (const void *)a1[1];
    if (v32)
      CFRelease(v32);
    a1[1] = v31;
  }
  v33 = a1[38];
  if (v33)
  {
    v34 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@ranges_to_move=%zu "), a1[1], v33);
    v35 = (const void *)a1[1];
    if (v35)
      CFRelease(v35);
    a1[1] = v34;
  }
  v36 = a1[44];
  if (v36 != -1)
  {
    v37 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@src_t=%llu "), a1[1], v36);
    v38 = (const void *)a1[1];
    if (v38)
      CFRelease(v38);
    a1[1] = v37;
  }
  v39 = a1[43];
  if (v39 != -1)
  {
    v40 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@mnt_t=%llu "), a1[1], v39);
    v41 = (const void *)a1[1];
    if (v41)
      CFRelease(v41);
    a1[1] = v40;
  }
  v42 = a1[45];
  if (v42 != -1)
  {
    v43 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@prepro_t=%llu "), a1[1], v42);
    v44 = (const void *)a1[1];
    if (v44)
      CFRelease(v44);
    a1[1] = v43;
  }
  v45 = a1[46];
  if (v45 != -1)
  {
    v46 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@psvr_t=%llu "), a1[1], v45);
    v47 = (const void *)a1[1];
    if (v47)
      CFRelease(v47);
    a1[1] = v46;
  }
  v48 = a1[47];
  if (v48 != -1)
  {
    v49 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@mv_t=%llu "), a1[1], v48);
    v50 = (const void *)a1[1];
    if (v50)
      CFRelease(v50);
    a1[1] = v49;
  }
  v51 = a1[48];
  if (v51 != -1)
  {
    v52 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@trgt_t=%llu "), a1[1], v51);
    v53 = (const void *)a1[1];
    if (v53)
      CFRelease(v53);
    a1[1] = v52;
  }
  v54 = a1[49];
  if (v54 != -1)
  {
    v55 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@pmv_t=%llu "), a1[1], v54);
    v56 = (const void *)a1[1];
    if (v56)
      CFRelease(v56);
    a1[1] = v55;
  }
  v57 = a1[51];
  if (v57 != -1)
  {
    v58 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@freeQ_d=%lld "), a1[1], v57);
    v59 = (const void *)a1[1];
    if (v59)
      CFRelease(v59);
    a1[1] = v58;
  }
  v60 = a1[52];
  if (v60 != -1)
  {
    v61 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@max_mem=%llu "), a1[1], v60);
    v62 = (const void *)a1[1];
    if (v62)
      CFRelease(v62);
    a1[1] = v61;
  }
  v63 = a1[53];
  if (v63 != 0x7FFFFFFFFFFFFFFFLL)
  {
    v64 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@xp_desc=%lld "), a1[1], v63);
    v65 = (const void *)a1[1];
    if (v65)
      CFRelease(v65);
    a1[1] = v64;
  }
  v66 = a1[54];
  if (v66 != 0x7FFFFFFFFFFFFFFFLL)
  {
    v67 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@xp_data=%lld "), a1[1], v66);
    v68 = (const void *)a1[1];
    if (v68)
      CFRelease(v68);
    a1[1] = v67;
  }
  v69 = a1[55];
  if (v69 != -1)
  {
    v70 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@oc_hit=%llu "), a1[1], v69);
    v71 = (const void *)a1[1];
    if (v71)
      CFRelease(v71);
    a1[1] = v70;
  }
  v72 = a1[56];
  if (v72 != -1)
  {
    v73 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@oc_miss=%llu "), a1[1], v72);
    v74 = (const void *)a1[1];
    if (v74)
      CFRelease(v74);
    a1[1] = v73;
  }
  v75 = a1[57];
  if (v75)
  {
    v76 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@dirstats=%llu "), a1[1], v75);
    v77 = (const void *)a1[1];
    if (v77)
      CFRelease(v77);
    a1[1] = v76;
  }
  v78 = a1[61];
  if (v78)
  {
    v79 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@decloned=%llu "), a1[1], v78);
    v80 = (const void *)a1[1];
    if (v80)
      CFRelease(v80);
    a1[1] = v79;
  }
  v81 = a1[62];
  if (v81)
  {
    v82 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@source_meta_size=%llu "), a1[1], v81);
    v83 = (const void *)a1[1];
    if (v83)
      CFRelease(v83);
    a1[1] = v82;
  }
  v84 = a1[58];
  if (v84)
  {
    v85 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@ever_cloned=%llu "), a1[1], v84);
    v86 = (const void *)a1[1];
    if (v86)
      CFRelease(v86);
    a1[1] = v85;
  }
  v87 = a1[59];
  if (v87)
  {
    v88 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@full_clones=%llu "), a1[1], v87);
    v89 = (const void *)a1[1];
    if (v89)
      CFRelease(v89);
    a1[1] = v88;
  }
  v90 = a1[63];
  if (v90 != -1)
  {
    v91 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@disk_free_start=%llu "), a1[1], v90);
    v92 = (const void *)a1[1];
    if (v92)
      CFRelease(v92);
    a1[1] = v91;
  }
  v93 = a1[64];
  if (v93 != -1)
  {
    v94 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@disk_free_curr=%llu "), a1[1], v93);
    v95 = (const void *)a1[1];
    if (v95)
      CFRelease(v95);
    a1[1] = v94;
  }
  v96 = a1[65];
  if (v96 != -1)
  {
    v97 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@ip_freeq_start=%llu "), a1[1], v96);
    v98 = (const void *)a1[1];
    if (v98)
      CFRelease(v98);
    a1[1] = v97;
  }
  v99 = a1[66];
  if (v99 != -1)
  {
    v100 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@ip_freeq_curr=%llu "), a1[1], v99);
    v101 = (const void *)a1[1];
    if (v101)
      CFRelease(v101);
    a1[1] = v100;
  }
  v102 = a1[79];
  if (v102)
  {
    v103 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@msu_shared_clone_blk=%llu "), a1[1], v102);
    v104 = (const void *)a1[1];
    if (v104)
      CFRelease(v104);
    a1[1] = v103;
  }
  v105 = a1[80];
  if (v105)
  {
    v106 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@msu_purgble_clone_blk=%llu "), a1[1], v105);
    v107 = (const void *)a1[1];
    if (v107)
      CFRelease(v107);
    a1[1] = v106;
  }
  v108 = a1[81];
  if (v108)
  {
    v109 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@cloned_apps_blk=%llu "), a1[1], v108);
    v110 = (const void *)a1[1];
    if (v110)
      CFRelease(v110);
    a1[1] = v109;
  }
  v111 = a1[82];
  if (v111)
  {
    v112 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@pure_cloned_apps_blk=%llu "), a1[1], v111);
    v113 = (const void *)a1[1];
    if (v113)
      CFRelease(v113);
    a1[1] = v112;
  }
  v114 = a1[83];
  if (v114)
  {
    v115 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@tmp_blk=%llu "), a1[1], v114);
    v116 = (const void *)a1[1];
    if (v116)
      CFRelease(v116);
    a1[1] = v115;
  }
  v117 = a1[84];
  if (v117)
  {
    v118 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@tmp_cloned_blk=%llu "), a1[1], v117);
    v119 = (const void *)a1[1];
    if (v119)
      CFRelease(v119);
    a1[1] = v118;
  }
  v120 = a1[67];
  if (v120 != -1)
  {
    v121 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@src_fsroot_nodes=%llu "), a1[1], v120);
    v122 = (const void *)a1[1];
    if (v122)
      CFRelease(v122);
    a1[1] = v121;
  }
  v123 = a1[70];
  if (v123 != -1)
  {
    v124 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@src_fsroot_depth=%llu "), a1[1], v123);
    v125 = (const void *)a1[1];
    if (v125)
      CFRelease(v125);
    a1[1] = v124;
  }
  v126 = a1[68];
  if (v126 != -1)
  {
    v127 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@src_fsroot_2nd_nodes=%llu "), a1[1], v126);
    v128 = (const void *)a1[1];
    if (v128)
      CFRelease(v128);
    a1[1] = v127;
  }
  v129 = a1[71];
  if (v129 != -1)
  {
    v130 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@src_fsroot_2nd_depth=%llu "), a1[1], v129);
    v131 = (const void *)a1[1];
    if (v131)
      CFRelease(v131);
    a1[1] = v130;
  }
  v132 = a1[69];
  if (v132 != -1)
  {
    v133 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@tgt_fsroot_nodes=%llu "), a1[1], v132);
    v134 = (const void *)a1[1];
    if (v134)
      CFRelease(v134);
    a1[1] = v133;
  }
  v135 = a1[72];
  if (v135 != -1)
  {
    v136 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@tgt_fsroot_depth=%llu "), a1[1], v135);
    v137 = (const void *)a1[1];
    if (v137)
      CFRelease(v137);
    a1[1] = v136;
  }
  v138 = a1[73];
  if (v138)
  {
    v139 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@data_num_hardlnks=%llu "), a1[1], v138);
    v140 = (const void *)a1[1];
    if (v140)
      CFRelease(v140);
    a1[1] = v139;
  }
  v141 = a1[75];
  if (v141)
  {
    v142 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@data_size_hardlnks=%llu "), a1[1], v141);
    v143 = (const void *)a1[1];
    if (v143)
      CFRelease(v143);
    a1[1] = v142;
  }
  v144 = a1[77];
  if (v144)
  {
    v145 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@data_ondisk_hardlnks=%llu "), a1[1], v144);
    v146 = (const void *)a1[1];
    if (v146)
      CFRelease(v146);
    a1[1] = v145;
  }
  v147 = a1[74];
  if (v147)
  {
    v148 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@data_num_fclones=%llu "), a1[1], v147);
    v149 = (const void *)a1[1];
    if (v149)
      CFRelease(v149);
    a1[1] = v148;
  }
  v150 = a1[76];
  if (v150)
  {
    v151 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@data_size_fclones=%llu "), a1[1], v150);
    v152 = (const void *)a1[1];
    if (v152)
      CFRelease(v152);
    a1[1] = v151;
  }
  v153 = a1[78];
  if (v153)
  {
    v154 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@data_ondisk_fclones=%llu "), a1[1], v153);
    v155 = (const void *)a1[1];
    if (v155)
      CFRelease(v155);
    a1[1] = v154;
  }
  v156 = a1[85];
  if (v156)
  {
    v157 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@purge_all=%llu "), a1[1], v156);
    v158 = (const void *)a1[1];
    if (v158)
      CFRelease(v158);
    a1[1] = v157;
  }
  v159 = a1[86];
  if (v159)
  {
    v160 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@purge_full=%llu "), a1[1], v159);
    v161 = (const void *)a1[1];
    if (v161)
      CFRelease(v161);
    a1[1] = v160;
  }
  v162 = a1[87];
  if (v162)
  {
    v163 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@purge_full_2=%llu "), a1[1], v162);
    v164 = (const void *)a1[1];
    if (v164)
      CFRelease(v164);
    a1[1] = v163;
  }
  v165 = a1[88];
  if (v165)
  {
    v166 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@purge_from_data=%llu "), a1[1], v165);
    v167 = (const void *)a1[1];
    if (v167)
      CFRelease(v167);
    a1[1] = v166;
  }
  v168 = a1[89];
  if (v168)
  {
    v169 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@purge_from_user=%llu "), a1[1], v168);
    v170 = (const void *)a1[1];
    if (v170)
      CFRelease(v170);
    a1[1] = v169;
  }
  v171 = a1[90];
  if (v171 != -1)
  {
    v172 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@incompat=0x%llx "), a1[1], v171);
    v173 = (const void *)a1[1];
    if (v173)
      CFRelease(v173);
    a1[1] = v172;
  }
  v174 = a1[91];
  if (v174 != -1)
  {
    v175 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@roincompat=0x%llx "), a1[1], v174);
    v176 = (const void *)a1[1];
    if (v176)
      CFRelease(v176);
    a1[1] = v175;
  }
  v177 = a1[92];
  if (v177 != -1)
  {
    v178 = CFStringCreateWithFormat(*v3, 0, CFSTR("%@features=0x%llx "), a1[1], v177);
    v179 = (const void *)a1[1];
    if (v179)
      CFRelease(v179);
    a1[1] = v178;
  }
}

void *authapfs_hexdump_hash(unsigned __int8 *a1, void *a2, unsigned int a3)
{
  unsigned int v6;
  uint64_t v7;
  char *v8;
  int v9;
  int v10;

  v6 = (2 * a3) | 1;
  bzero(a2, v6);
  if (a3)
  {
    v7 = a3;
    v8 = (char *)a2;
    do
    {
      v9 = *a1++;
      v10 = snprintf(v8, v6, "%02hhx", v9);
      v8 += v10;
      v6 -= v10;
      --v7;
    }
    while (v7);
  }
  return a2;
}

uint64_t authapfs_get_hash_info(int a1)
{
  uint64_t result;

  switch(a1)
  {
    case 1:
      result = ccsha256_di();
      break;
    case 2:
    case 5:
      result = ccsha512_256_di();
      break;
    case 3:
      result = ccsha384_di();
      break;
    case 4:
      result = ccsha512_di();
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t authapfs_should_hash_node(uint64_t a1)
{
  uint64_t v2;

  if ((*(_BYTE *)(a1 + 21) & 4) != 0)
    return 0;
  if ((obj_type_and_flags(a1) & 0x8000000) != 0 || (*(_BYTE *)(a1 + 17) & 2) != 0)
  {
    LODWORD(v2) = 0;
  }
  else
  {
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
      LODWORD(v2) = (*(unsigned __int8 *)(*(_QWORD *)(v2 + 376) + 56) >> 5) & 1;
  }
  if (*(_DWORD *)(a1 + 40) != 14)
    return 0;
  else
    return v2 | ((*(_WORD *)(*(_QWORD *)(a1 + 56) + 32) & 8) >> 3);
}

uint64_t authapfs_validate_node_hash(uint64_t a1, void *a2, unsigned int a3, unsigned int a4)
{
  uint64_t result;
  _OWORD v7[8];
  char v8;
  _OWORD v9[8];
  char v10;
  _OWORD __s1[4];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  memset(__s1, 0, sizeof(__s1));
  if (!a2)
    return 22;
  result = authapfs_hash_node(a1, (uint64_t)__s1, a3, a4);
  if (!(_DWORD)result)
  {
    result = memcmp(__s1, a2, a3);
    if ((_DWORD)result)
    {
      v10 = 0;
      memset(v9, 0, sizeof(v9));
      v8 = 0;
      memset(v7, 0, sizeof(v7));
      authapfs_hexdump_hash((unsigned __int8 *)a2, v7, a3);
      authapfs_hexdump_hash((unsigned __int8 *)__s1, v9, a3);
      log_err("%s:%d: hash mismatch! expected: %s, actual: %s\n", "authapfs_validate_node_hash", 234, (const char *)v7, (const char *)v9);
      return 80;
    }
  }
  return result;
}

uint64_t authapfs_hash_node(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t result;

  result = 22;
  if (a2 && (*(_WORD *)(*(_QWORD *)(a1 + 56) + 32) & 8) != 0)
  {
    if (authapfs_valid_hash_type(a4) || authapfs_hash_size(a4) != a3)
    {
      return 22;
    }
    else
    {
      authapfs_get_hash_info(a4);
      obj_size_phys(a1);
      ccdigest();
      return 0;
    }
  }
  return result;
}

uint64_t authapfs_validate_node(_QWORD *a1, uint64_t a2)
{
  const void *v4;
  unint64_t v5;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD __s2[4];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (!authapfs_should_hash_node((uint64_t)a1))
    return 0;
  if ((authapfs_state & 1) == 0)
    return 0;
  v4 = (const void *)a1[1];
  v5 = a1[50];
  if ((authapfs_seal_is_broken((uint64_t)v4, (uint64_t)a1) & 1) != 0)
    return 0;
  memset(__s2, 0, sizeof(__s2));
  if (!a2)
    return a2;
  v7 = (void *)(a2 + 32);
  if (!memcmp(v7, __s2, HIWORD(v5) & 0x7F))
    return 0;
  a2 = authapfs_validate_node_hash((uint64_t)a1, v7, HIWORD(v5) & 0x7F, (v5 >> 44) & 0xF);
  if ((_DWORD)a2)
  {
    v8 = obj_oid((uint64_t)a1);
    v9 = obj_xid((uint64_t)a1);
    v10 = obj_oid((uint64_t)v4);
    log_err("failed to validate node %p (oid:%llu, xid:%llu) of fs %p (%llu) - %d\n", a1, v8, v9, v4, v10, a2);
  }
  return a2;
}

uint64_t authapfs_valid_hash_type(unsigned int a1)
{
  if (a1 <= 5 && (a1 & 0xFFFFFFFD) != 0)
    return 0;
  log_err("%s:%d: Invalid or unknown hash type: %d\n", "authapfs_valid_hash_type", 50, a1);
  return 22;
}

uint64_t authapfs_hash_size(int a1)
{
  if ((a1 - 1) > 4)
    return 0;
  else
    return dword_1DF2E0F08[a1 - 1];
}

double integrity_meta_init_phys(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  int v3;
  double result;

  v3 = *a3;
  if (*a3 > 5u || (*a3 & 0xFFFFFFFD) == 0)
  {
    log_err("%s:%d: Invalid or unknown hash type: %d\n", "authapfs_valid_hash_type", 50, *a3);
  }
  else
  {
    *(_QWORD *)&result = 2;
    *(_QWORD *)(a1 + 32) = 2;
    *(_DWORD *)(a1 + 40) = v3;
    *(_DWORD *)(a1 + 44) = 128;
  }
  return result;
}

uint64_t integrity_meta_obj_init(uint64_t a1)
{
  _DWORD *v1;
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v6;

  v1 = *(_DWORD **)(a1 + 56);
  v2 = v1[10];
  if (v2 - 1 > 4)
    v3 = 0;
  else
    v3 = dword_1DF2E0F08[v2 - 1];
  if (v1[8])
  {
    v4 = v1[11];
    if (v4 >= 0x30)
    {
      if (v2 > 5 || (v2 & 0xFFFFFFFD) == 0)
      {
        log_err("%s:%d: Invalid or unknown hash type: %d\n", "authapfs_valid_hash_type", 50, v1[10]);
      }
      else if (*(_DWORD *)(a1 + 48) >= v4 + v3)
      {
        v6 = 0;
        *(_QWORD *)(a1 + 376) = v1;
        *(_QWORD *)(a1 + 384) = (char *)v1 + v4;
        *(_DWORD *)(a1 + 392) = v3;
        return v6;
      }
    }
  }
  return 92;
}

uint64_t authapfs_integrity_meta_get_internal(uint64_t a1, char **a2, int a3)
{
  uint64_t result;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  char *v11;
  int32x2_t *v12;
  char *v13;

  if (!a1)
    return 22;
  if (!a2 && !a3)
    return 22;
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 376) + 1024);
  if (v7)
  {
    v8 = *(_QWORD *)(a1 + 392);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1720));
    v9 = *(char **)(a1 + 3488);
    if (v9)
    {
      if (a2)
      {
        obj_retain(v9);
        *a2 = *(char **)(a1 + 3488);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1720));
      return 0;
    }
    v13 = 0;
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1720));
    result = obj_get(*(_QWORD *)(v8 + 392), 0, v7, (int *)&integrity_meta_desc, 0, a1, *(_QWORD *)(a1 + 432), 0, (uint64_t *)&v13);
    if (!(_DWORD)result)
    {
      v11 = v13;
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 3792));
      v12 = (int32x2_t *)*((_QWORD *)v11 + 47);
      *(int32x2_t *)(a1 + 3860) = vrev64_s32(v12[4]);
      *(int32x2_t *)(a1 + 3872) = v12[6];
      *(_BYTE *)(a1 + 3856) = 1;
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 3792));
      if (a3)
      {
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 1720));
        if (!*(_QWORD *)(a1 + 3488))
        {
          obj_retain(v13);
          *(_QWORD *)(a1 + 3488) = v13;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1720));
      }
      if (!a2)
      {
        obj_release((uint64_t *)v13);
        return 0;
      }
      result = 0;
      *a2 = v13;
    }
  }
  else
  {
    v10 = obj_oid(a1);
    log_err("%s:%d: %s integrity_meta object of fs %llu, oid invalid\n", "authapfs_integrity_meta_get_internal", 168, (const char *)(a1 + 3880), v10);
    return 2;
  }
  return result;
}

uint64_t authapfs_get_hash_args(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  uint64_t *v4;
  unsigned int v5;
  size_t v6;
  const void *v7;
  char *v8;

  v8 = 0;
  if (!a2)
    return 22;
  result = authapfs_integrity_meta_get_internal(a1, &v8, 0);
  if (!(_DWORD)result)
  {
    v4 = (uint64_t *)v8;
    v5 = *((_DWORD *)v8 + 98);
    if (v5 >= 0x40)
      v6 = 64;
    else
      v6 = v5;
    v7 = (const void *)*((_QWORD *)v8 + 48);
    a2[6] = *(_DWORD *)(*((_QWORD *)v8 + 47) + 40);
    a2[7] = v5;
    a2[5] |= 0x180u;
    memcpy(a2 + 8, v7, v6);
    obj_release(v4);
    return 0;
  }
  return result;
}

uint64_t authapfs_seal_is_broken(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  unint64_t *v9;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  BOOL v13;
  int v14;
  uint64_t result;

  v4 = (pthread_mutex_t *)(a1 + 1720);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1720));
  v5 = *(_QWORD *)(a1 + 3488);
  if (v5)
  {
    v6 = *(_QWORD *)(v5 + 376);
    v7 = (unsigned int *)(v6 + 36);
    v8 = (unsigned int *)(v6 + 32);
    v9 = (unint64_t *)(v6 + 48);
  }
  else
  {
    pthread_mutex_unlock(v4);
    if (!*(_BYTE *)(a1 + 3856))
      return 0;
    v4 = (pthread_mutex_t *)(a1 + 3792);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 3792));
    v7 = (unsigned int *)(a1 + 3860);
    v8 = (unsigned int *)(a1 + 3864);
    v9 = (unint64_t *)(a1 + 3872);
  }
  v10 = *v9;
  v11 = *v8;
  v12 = *v7;
  pthread_mutex_unlock(v4);
  if (a2)
    v13 = v11 >= 2;
  else
    v13 = 0;
  v14 = !v13;
  result = v14 & v12;
  if (v13 && (v12 & 1) != 0)
    return obj_xid(a2) >= v10;
  return result;
}

uint64_t delta_validate_op(unsigned __int8 *a1, unint64_t a2, _DWORD *a3)
{
  unsigned int v6;
  uint64_t result;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  int v27;
  unsigned int v28;
  int v29;
  int v30;
  unsigned int v31;
  int v32;
  int v33;

  if (!a2)
    return 35;
  v6 = *a1;
  if (delta_op_type_struct_size(v6) > a2)
    return 35;
  LODWORD(v8) = 1;
  switch(v6)
  {
    case 0u:
      goto LABEL_88;
    case 1u:
      v8 = *(unsigned int *)(a1 + 1);
      if (v8 > a2)
        v11 = 2;
      else
        v11 = 3;
      if ((v8 - 1048598) >= 0xFFEFFFEF)
      {
        v12 = v11;
      }
      else
      {
        LODWORD(v8) = 0;
        v12 = 4;
      }
      goto LABEL_77;
    case 2u:
      if (*(_DWORD *)(a1 + 1) != 18 || a1[5] > 1u || *(_DWORD *)(a1 + 6) < 3u || *(_QWORD *)(a1 + 10) >> 60)
        goto LABEL_89;
      if (a2 < 0x12)
        return 35;
      LODWORD(v8) = 18;
      goto LABEL_88;
    case 3u:
      if (*(_DWORD *)(a1 + 1) == 25 && !(*(_QWORD *)(a1 + 5) >> 60) && !(*(_QWORD *)(a1 + 13) >> 60))
        goto LABEL_28;
      goto LABEL_89;
    case 4u:
      if (*(_DWORD *)(a1 + 1) != 17 || *(_QWORD *)(a1 + 5) >> 60)
        goto LABEL_89;
      LODWORD(v8) = 17;
      goto LABEL_88;
    case 5u:
      if (*(_DWORD *)(a1 + 1) != 997994796
        || *(_QWORD *)(a1 + 5) > 3uLL
        || *(_OWORD *)(a1 + 41) == 0
        || (strnlen((const char *)a1 + 57, 0x100uLL) & 0xFFFFFFFFFFFFFEFFLL) == 0
        || (*(_DWORD *)(a1 + 21) - 65537) < 0xFFFF0FFF
        || (strnlen((const char *)a1 + 660, 0x100uLL) & 0xFFFFFFFFFFFFFEFFLL) == 0)
      {
        goto LABEL_89;
      }
      LODWORD(v8) = 1024;
      goto LABEL_88;
    case 6u:
      LODWORD(v8) = 141;
      goto LABEL_88;
    case 7u:
      v13 = *(unsigned __int16 *)(a1 + 1);
      if ((v13 - 833) < 0xFFFFFCC7)
        goto LABEL_89;
      v14 = *(unsigned __int16 *)(a1 + 3);
      if (v14 > 0xEE0)
        goto LABEL_89;
      v8 = v13 + v14 + 5;
      if (v8 > a2)
        return 35;
      v15 = *(_QWORD *)(a1 + 5);
      if ((v15 & 0xFFFFFFFFFFFFFFFLL) == 0)
        goto LABEL_89;
      v16 = v15 >> 60;
      if (v16 > 0xC)
        goto LABEL_89;
      v17 = 1 << v16;
      goto LABEL_51;
    case 8u:
      v18 = *(unsigned __int16 *)(a1 + 1);
      if ((v18 - 833) < 0xFFFFFCC7)
        goto LABEL_89;
      v8 = v18 + 3;
      if (v8 > a2)
        return 35;
      v19 = *(_QWORD *)(a1 + 3);
      if ((v19 & 0xFFFFFFFFFFFFFFFLL) == 0)
        goto LABEL_89;
      v20 = v19 >> 60;
      if (v20 > 0xC)
        goto LABEL_89;
      v17 = 1 << v20;
LABEL_51:
      if ((v17 & 0x1678) == 0)
        goto LABEL_89;
      goto LABEL_88;
    case 9u:
      if ((unint64_t)(*(_QWORD *)(a1 + 1) - 0x1000000000000000) < 0xF000000000000001)
        goto LABEL_89;
      v21 = *(unsigned int *)(a1 + 17);
      if ((v21 - 1048577) < 0xFFF00000 || __CFADD__(*(_QWORD *)(a1 + 9), v21))
        goto LABEL_89;
      v8 = (v21 + 21);
      if (v8 <= a2)
        goto LABEL_88;
      return 35;
    case 0xAu:
    case 0xCu:
      if ((unint64_t)(*(_QWORD *)(a1 + 1) - 0x1000000000000000) < 0xF000000000000001)
        goto LABEL_89;
      v9 = *(_QWORD *)(a1 + 17);
      if (!v9)
        goto LABEL_89;
      if ((v9 & 0xFFF) != 0)
        goto LABEL_89;
      v10 = *(_QWORD *)(a1 + 9);
      if ((v10 & 0xFFF) != 0 || __CFADD__(v10, v9))
        goto LABEL_89;
LABEL_28:
      LODWORD(v8) = 25;
      goto LABEL_88;
    case 0xBu:
      v22 = *(_QWORD *)(a1 + 1);
      if (!v22)
        goto LABEL_89;
      if (v22 >> 60)
        goto LABEL_89;
      v23 = *(_QWORD *)(a1 + 17);
      if ((unint64_t)(v23 - 0x1000000000000000) < 0xF000000000000001)
        goto LABEL_89;
      v24 = *(_QWORD *)(a1 + 33);
      if (!v24)
        goto LABEL_89;
      if ((v24 & 0xFFF) != 0)
        goto LABEL_89;
      v25 = *(_QWORD *)(a1 + 9);
      if ((v25 & 0xFFF) != 0)
        goto LABEL_89;
      v26 = *(_QWORD *)(a1 + 25);
      if ((v26 & 0xFFF) != 0 || __CFADD__(v25, v24) || __CFADD__(v26, v24))
        goto LABEL_89;
      if (v23 != v22)
      {
        LODWORD(v8) = 41;
LABEL_88:
        result = 0;
        *a3 = v8;
        return result;
      }
      LODWORD(v8) = 41;
      if (v25 + v24 <= v26 || v26 + v24 <= v25)
        goto LABEL_88;
LABEL_89:
      result = 92;
      break;
    case 0xDu:
      v27 = *(_DWORD *)(a1 + 9);
      v28 = v27 - 65537;
      v8 = (v27 + 13);
      if (v8 > a2)
        v29 = 2;
      else
        v29 = 3;
      if (v28 >= 0xFFFF0FFF)
      {
        v12 = v29;
      }
      else
      {
        LODWORD(v8) = 0;
        v12 = 4;
      }
LABEL_77:
      if (v12 == 3)
        goto LABEL_88;
      if (v12 == 4)
        goto LABEL_89;
      return 35;
    case 0xEu:
      v30 = *(_DWORD *)(a1 + 1);
      v31 = v30 - 65537;
      v8 = (v30 + 5);
      if (v8 > a2)
        v32 = 2;
      else
        v32 = 3;
      if (v31 >= 0xFFFF0FFF)
      {
        v33 = v32;
      }
      else
      {
        LODWORD(v8) = 0;
        v33 = 4;
      }
      if (v33 == 4)
        goto LABEL_89;
      if (v33 == 3)
        goto LABEL_88;
      return 35;
    default:
      goto LABEL_89;
  }
  return result;
}

uint64_t delta_op_type_struct_size(unsigned int a1)
{
  if (a1 > 0xE)
    return 0;
  else
    return dword_1DF2E0F30[(char)a1];
}

uint64_t delta_canonicalize(unsigned int *a1, unsigned __int8 *a2, unint64_t *a3, void (*a4)(unsigned __int8 *, size_t, uint64_t), uint64_t a5)
{
  _BYTE *v5;
  uint64_t v6;
  unsigned int v12;
  uint64_t v13;
  unsigned __int8 *v15;
  size_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  size_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  _BYTE *v28;
  unint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unsigned __int8 *v32;
  __int128 v33;
  size_t v34;
  unint64_t v35;
  _BYTE *v36;
  _BYTE *v37;
  __int16 v38;
  unint64_t v39;
  _BYTE *v41;
  uint64_t v42;
  char *__dst;
  unsigned int __n;
  unsigned int __n_4;
  uint64_t v46;

  v5 = (char *)a1 + 9;
  v6 = *a1;
  if ((_DWORD)v6)
    return v6;
  __n = 0;
  v12 = delta_validate_op(a2, *a3, &__n);
  v13 = 0;
  if (v12)
  {
LABEL_3:
    if (v12 == 35)
      v6 = 0;
    else
      v6 = v12;
    goto LABEL_6;
  }
  __dst = (char *)a1 + 30;
  v15 = a2;
  while (1)
  {
    v16 = __n;
    v13 += __n;
    if (*((_BYTE *)a1 + 8))
    {
      if (*v5 == *v15)
      {
        switch(*v5)
        {
          case 9:
            if (*(_QWORD *)((char *)a1 + 10) != *(_QWORD *)(v15 + 1))
              goto LABEL_30;
            v21 = *(unsigned int *)((char *)a1 + 26);
            if (*(_QWORD *)((char *)a1 + 18) + v21 != *(_QWORD *)(v15 + 9))
              goto LABEL_30;
            v22 = *(_DWORD *)(v15 + 17);
            if (0x100000 - (int)v21 >= v22)
              v20 = v22;
            else
              v20 = (0x100000 - v21);
            memcpy(&__dst[v21], v15 + 21, v20);
            v23 = *(unsigned int *)((char *)a1 + 26) + v20;
            *(unsigned int *)((char *)a1 + 26) = v23;
            a1[1] += v20;
            if (v23 < 0x100000)
              goto LABEL_65;
            goto LABEL_31;
          case 0xA:
          case 0xC:
            if (*(_QWORD *)((char *)a1 + 10) != *(_QWORD *)(v15 + 1))
              goto LABEL_30;
            v17 = *(_QWORD *)((char *)a1 + 26);
            if (v17 + *(_QWORD *)((char *)a1 + 18) != *(_QWORD *)(v15 + 9))
              goto LABEL_30;
            v18 = v15 + 17;
            v19 = (_QWORD *)((char *)a1 + 26);
            goto LABEL_16;
          case 0xB:
            if (*(_QWORD *)((char *)a1 + 26) != *(_QWORD *)(v15 + 17))
              goto LABEL_30;
            if (*(_QWORD *)((char *)a1 + 10) != *(_QWORD *)(v15 + 1))
              goto LABEL_30;
            v17 = *(_QWORD *)((char *)a1 + 42);
            if (v17 + *(_QWORD *)((char *)a1 + 34) != *(_QWORD *)(v15 + 25)
              || *(_QWORD *)((char *)a1 + 18) + v17 != *(_QWORD *)(v15 + 9))
            {
              goto LABEL_30;
            }
            v18 = v15 + 33;
            v19 = (_QWORD *)((char *)a1 + 42);
LABEL_16:
            *v19 = *v18 + v17;
            break;
          default:
            goto LABEL_30;
        }
        goto LABEL_65;
      }
LABEL_30:
      LODWORD(v20) = 0;
LABEL_31:
      a4(v5, a1[1], a5);
      *((_BYTE *)a1 + 8) = 0;
    }
    else
    {
      LODWORD(v20) = 0;
    }
    v24 = *v15;
    if ((v24 - 10) < 3)
    {
      memcpy(v5, v15, v16);
      a1[1] = v16;
LABEL_34:
      *((_BYTE *)a1 + 8) = 1;
      goto LABEL_64;
    }
    if (v24 != 9)
    {
      if (v24 == 7)
      {
        memcpy(v5, v15, v16);
        v25 = *(_QWORD *)((char *)a1 + 14);
        v26 = v25 & 0xFFFFFFFFFFFFFFFLL;
        v27 = v25 >> 60;
        if ((_DWORD)v27 == 4)
        {
          v35 = *((unsigned __int16 *)a1 + 6);
          if (v35 <= 3)
          {
            log_err("%s:%d: Corrupt xattr in ino %llu\n");
            goto LABEL_59;
          }
          v36 = &v5[*((unsigned __int16 *)a1 + 5)];
          v38 = *(_WORD *)(v36 + 5);
          v37 = v36 + 5;
          if ((v38 & 1) != 0)
          {
            v39 = *((unsigned __int16 *)v37 + 1);
            if (v39 < 0x30 || v39 + 4 > v35)
            {
              log_err("%s:%d: Corrupt dstream in xattr ino %llu\n");
              goto LABEL_59;
            }
            *(_QWORD *)(v37 + 28) = 0;
          }
        }
        else if ((_DWORD)v27 == 3)
        {
          v28 = &v5[*((unsigned __int16 *)a1 + 5)];
          v29 = *((unsigned __int16 *)a1 + 6) - 92;
          v46 = 0;
          __n_4 = 0;
          v41 = v28;
          v42 = v26;
          v30 = xf_get_from_blob((unsigned __int16 *)(v28 + 97), v29, 8, 0, &v46, &__n_4);
          if ((_DWORD)v30 != 2)
          {
            v6 = v30;
            if ((_DWORD)v30)
            {
              log_err("%s:%d: Hit error scanning blob in ino %llu, err %d\n", "delta_canonicalize_record", 1140, v42, v30);
              goto LABEL_7;
            }
            if (__n_4 <= 0x27)
            {
              log_err("%s:%d: Corrupt dstream ext in ino %llu\n");
LABEL_59:
              v6 = 92;
              goto LABEL_7;
            }
            *(_QWORD *)(v46 + 16) = 0;
          }
          *(_DWORD *)(v41 + 65) = 0;
          *(_QWORD *)(v41 + 53) &= ~8uLL;
        }
        v32 = v5;
      }
      else
      {
LABEL_45:
        v32 = v15;
      }
      a4(v32, v16, a5);
      goto LABEL_64;
    }
    v31 = *(_DWORD *)(v15 + 17);
    if (!(_DWORD)v20 && v31 == 0x100000)
      goto LABEL_45;
    if (v20 < v31)
    {
      v33 = *(_OWORD *)v15;
      *(_QWORD *)(v5 + 13) = *(_QWORD *)(v15 + 13);
      *(_OWORD *)v5 = v33;
      *(_QWORD *)((char *)a1 + 18) += v20;
      v34 = *(unsigned int *)((char *)a1 + 26) - v20;
      *(unsigned int *)((char *)a1 + 26) = v34;
      memcpy(__dst, &v15[v20 + 21], v34);
      a1[1] = v34 + 21;
      goto LABEL_34;
    }
LABEL_64:
    if (*v15 == 6)
      break;
LABEL_65:
    v15 = &a2[v13];
    v12 = delta_validate_op(&a2[v13], *a3 - v13, &__n);
    if (v12)
      goto LABEL_3;
  }
  v6 = 89;
LABEL_6:
  *a3 = v13;
LABEL_7:
  *a1 = v6;
  return v6;
}

uint64_t snap_meta_ext_obj_init(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[7];
  a1[47] = v1;
  a1[48] = v1 + 32;
  return 0;
}

uint64_t fs_lookup_snapshot_metadata_by_xid(uint64_t a1, uint64_t a2, unsigned __int16 **a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[2];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;

  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  v8[0] = 5242881;
  v8[1] = a2;
  v5 = lookup_jobj(a1, 3, 0, (unsigned __int8 *)v8, a3);
  v6 = v5;
  if ((_DWORD)v5)
    log_err("%s:%d: %s Couldn't find snap_meta for xid %llu: %d\n", "fs_lookup_snapshot_metadata_by_xid", 445, (const char *)(a1 + 3880), a2, v5);
  return v6;
}

uint64_t fs_delete_clone_superblock(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v7;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 392) + 392);
  v7 = 0;
  v5 = obj_get(v4, 0x40000000u, a2, (int *)&apfs_desc, 0, 0, 0, 0, (uint64_t *)&v7);
  if (!(_DWORD)v5)
  {
    obj_delete_and_free(v7, a3);
    obj_release(v7);
  }
  return v5;
}

uint64_t fs_delete_supplemental_tree(uint64_t a1, int a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t *v12;
  int *v13;
  int v14;
  uint64_t v15;
  uint64_t *v16;

  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 392) + 392);
  v16 = 0;
  result = obj_get(v9, 0x40000000u, a3, (int *)&apfs_desc, 0, 0, 0, a4, (uint64_t *)&v16);
  if (!(_DWORD)result)
  {
    v11 = v16[47];
    if (a2 == 6)
    {
      v12 = (uint64_t *)(v11 + 1048);
      v13 = (int *)(v11 + 1044);
    }
    else
    {
      if (a2 != 5)
      {
        obj_release(v16);
        return 45;
      }
      v12 = (uint64_t *)(v11 + 1032);
      v13 = (int *)(v11 + 1040);
    }
    v14 = *v13;
    v15 = *v12;
    obj_release(v16);
    if (v15)
      return supplemental_tree_destroy(a1, v14, a2, a4, v15, a5);
    else
      return 0;
  }
  return result;
}

uint64_t fs_delete_snapshot_metadata_tree(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t tree;
  uint64_t *v8;

  v8 = 0;
  tree = jfs_get_tree(a1, 3, 0, (uint64_t *)&v8);
  if (!(_DWORD)tree)
  {
    tree = btree_delete((uint64_t)v8, a2, a3);
    obj_release(v8);
    if (!(_DWORD)tree)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1464));
      *(_QWORD *)(*(_QWORD *)(a1 + 376) + 152) = 0;
      fs_sb_dirty(a1, a2);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1464));
    }
  }
  return tree;
}

uint64_t pfkur_tree_key_cmp(uint64_t a1, _QWORD *a2, int a3, _QWORD *a4, int a5, int *a6)
{
  uint64_t result;
  int v7;

  result = 22;
  if (a3 == 8 && a5 == 8)
  {
    result = 0;
    v7 = *a2 > *a4;
    if (*a2 < *a4)
      v7 = -1;
    *a6 = v7;
  }
  return result;
}

uint64_t spaceman_metazone_get_size(unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, _QWORD *a5, _QWORD *a6)
{
  unint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;

  if (!a4)
    return 28;
  v6 = a1;
  if (a1 <= a2 || a4 < a1)
  {
    if (0x180000000 * (a2 >> 12) > a4)
      return 28;
    if (a4 >> 34)
    {
      v9 = 0x1000000000;
      if (a4 >= 0x1000000000)
        v10 = 0x1000000000;
      else
        v10 = a4;
      v8 = v10 >> 5;
      if (a4 >= 0x1000000001)
      {
        if (a4 - 0x1000000000 < 0x1000000000)
          v9 = a4 - 0x1000000000;
        v8 += ((unint64_t)v9 * (unsigned __int128)0x666666666666667uLL) >> 64;
        if (a4 >= 0x2000000001)
        {
          v11 = a4 - 0x2000000000;
          if (a4 - 0x2000000000 >= 0x2000000000)
            v11 = 0x2000000000;
          v8 += v11 >> 7;
          if (a4 >= 0x4000000001)
            v8 += (a4 - 0x4000000000) / 0xA0;
        }
      }
    }
    else
    {
      v8 = 0x20000000;
    }
    v6 = v8 * (a2 >> 12);
    if (v6 >= a4 >> 2)
      v6 = a4 >> 2;
  }
  result = 0;
  v12 = v6 / a2;
  *a5 = v12 * a2;
  *a6 = a3 - v12;
  return result;
}

unint64_t spaceman_metazone_get_partitions(unint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, _QWORD *a6)
{
  unint64_t v6;

  if (a5)
    *a5 = (a2 >> 1) / result + a3;
  if (a6)
  {
    v6 = (a2 >> 4) / result;
    if (v6 >= 0x8000000 / result)
      v6 = 0x8000000 / result;
    *a6 = a4 - v6;
  }
  return result;
}

uint64_t get_timestamp()
{
  timespec v1;

  v1.tv_sec = 0;
  v1.tv_nsec = 0;
  clock_gettime(_CLOCK_REALTIME, &v1);
  return timespec_to_apfs_timestamp(&v1.tv_sec);
}

uint64_t timespec_to_apfs_timestamp(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;

  v1 = *a1;
  v2 = a1[1];
  v3 = v2 / 1000000000;
  v4 = v2 % 1000000000;
  if (*a1 < 0 && v2 >= 1)
  {
    v5 = v3 + 1;
    v4 -= 1000000000;
  }
  else
  {
    v6 = v2 >= 0;
    if (v2 < 0)
      v5 = v3 - 1;
    else
      v5 = v2 / 1000000000;
    if (v6)
      v7 = v4;
    else
      v7 = v4 + 1000000000;
    if (v1 >= 1)
      v4 = v7;
    else
      v5 = v3;
  }
  v8 = v1 + v5;
  if (__OFADD__(v1, v5)
    || (v9 = 1000000000 * v8, (unsigned __int128)(v8 * (__int128)1000000000) >> 64 != (1000000000 * v8) >> 63)
    || (result = v4 + v9, __OFADD__(v4, v9)))
  {
    if (v1 > 0)
      return 0x7FFFFFFFFFFFFFFFLL;
    else
      return 0x8000000000000000;
  }
  return result;
}

uint64_t omap_key_cmp(uint64_t a1, _QWORD *a2, int a3, _QWORD *a4, int a5, int *a6)
{
  uint64_t result;
  int v7;
  unint64_t v8;
  unint64_t v9;
  BOOL v10;

  result = 22;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        v7 = 1;
      }
      else
      {
        v8 = a2[1];
        v9 = a4[1];
        v10 = v8 >= v9;
        v7 = v8 > v9;
        if (!v10)
          v7 = -1;
      }
    }
    else
    {
      v7 = -1;
    }
    result = 0;
    *a6 = v7;
  }
  return result;
}

uint64_t omap_snapshot_key_cmp(uint64_t a1, _QWORD *a2, int a3, _QWORD *a4, int a5, int *a6)
{
  uint64_t result;
  int v7;

  result = 22;
  if (a3 == 8 && a5 == 8)
  {
    result = 0;
    v7 = *a2 > *a4;
    if (*a2 < *a4)
      v7 = -1;
    *a6 = v7;
  }
  return result;
}

uint64_t omap_map_tree_get(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t *a5)
{
  char *v9;
  uint64_t extended;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v18;
  _QWORD v19[3];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v9 = *(char **)(a2 + 472);
  if ((a3 & 1) == 0 && v9)
  {
    *a5 = (uint64_t)v9;
    obj_retain(v9);
    return 0;
  }
  if (v9)
  {
    *a5 = (uint64_t)v9;
    obj_retain(v9);
    if ((a3 & 1) == 0)
      return 0;
    v18 = obj_modify((_QWORD *)*a5, (*(_DWORD *)(*(_QWORD *)(a2 + 376) + 40) >> 29) & 2, a4);
    if ((_DWORD)v18)
    {
      extended = v18;
      obj_release(*a5);
      *a5 = 0;
      return extended;
    }
LABEL_19:
    if (obj_oid(*a5) != *(_QWORD *)(*(_QWORD *)(a2 + 376) + 48))
    {
      *(_QWORD *)(*(_QWORD *)(a2 + 376) + 48) = obj_oid(*a5);
      obj_dirty(a2, a4, 0);
    }
    return 0;
  }
  v12 = *(_QWORD *)(a2 + 376);
  v13 = *(_DWORD *)(v12 + 40);
  v14 = *(_QWORD *)(v12 + 48);
  v19[1] = 0;
  v20 = 0u;
  v24 = 0;
  v22 = 0u;
  v23 = 0u;
  v21 = 0u;
  v19[0] = omap_key_cmp;
  v19[2] = 0x20000000BLL;
  if ((unsigned __int16)v13 != 2)
    return 22;
  extended = btree_get_extended(a1, v13 & 0xFFFF0000, v14, 0, a3, (uint64_t)v19, a4, a5);
  if (!(_DWORD)extended)
  {
    v15 = (unint64_t *)(a2 + 472);
    v16 = *a5;
    while (!__ldaxr(v15))
    {
      if (!__stlxr(v16, v15))
      {
        obj_retain((char *)*a5);
        goto LABEL_18;
      }
    }
    __clrex();
LABEL_18:
    if ((a3 & 1) == 0)
      return 0;
    goto LABEL_19;
  }
  return extended;
}

uint64_t omap_init_phys(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  if (!a3)
    return 22;
  result = 0;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)a3;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a3 + 4);
  return result;
}

uint64_t omap_init(_QWORD *a1)
{
  uint64_t v2;
  int v3;
  BOOL v4;
  int v5;
  BOOL v6;
  uint64_t result;

  v2 = a1[7];
  v3 = *(_DWORD *)(v2 + 44);
  v4 = v3 == 1073741826 || v3 == -2147483646;
  if (v4 && ((v5 = *(_DWORD *)(v2 + 40), v5 != -2147483646) ? (v6 = v5 == 1073741826) : (v6 = 1), v6)
    || (result = nx_corruption_detected_int(*(_QWORD *)(*a1 + 392)), !(_DWORD)result))
  {
    result = 0;
    a1[47] = v2;
  }
  return result;
}

uint64_t omap_obj_destroy(_QWORD *a1)
{
  uint64_t *v2;

  v2 = (uint64_t *)a1[59];
  if (v2 && !*(_DWORD *)(*a1 + 912))
    obj_release(v2);
  return 0;
}

uint64_t omap_reap(uint64_t *a1, char a2, int *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t extended;
  const char *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  const char *v19;
  int v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  unsigned int v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  int v32;
  const char *v33;
  uint64_t v34;
  int v35;
  const char *v36;
  const char *v37;
  unsigned int v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v47;
  int v48;
  int v49;
  unsigned int v50;
  int v51;
  const char *v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  int v57;
  unint64_t *v58;
  unint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  unsigned int v63;
  int v64;
  int v65;
  int v66;
  const char *v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  BOOL v74;
  uint64_t v75;
  uint64_t *v76;
  int v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  const char *v81;
  uint64_t v82;
  uint64_t v83;
  _OWORD *v84;
  const char *v85;
  unint64_t v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unsigned int v92;
  unint64_t v93;
  unint64_t v94;
  unsigned int v95;
  const char *v96;
  unsigned int v97;
  unsigned int v98;
  unsigned int v99;
  int v100;
  uint64_t v101;
  _QWORD *v102;
  uint64_t v103;
  uint64_t *v104;
  uint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  _OWORD v109[4];
  uint64_t v110;
  uint64_t v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  _QWORD v116[2];
  uint64_t *v117;
  uint64_t *v118;
  unint64_t v119;
  uint64_t (*v120)(uint64_t, _QWORD *, int, _QWORD *, int, int *);
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  uint64_t v126;
  uint64_t v127;

  v5 = a5;
  v127 = *MEMORY[0x1E0C80C00];
  v8 = a1[47];
  v9 = (_QWORD *)a1[1];
  v10 = *(_QWORD *)(*a1 + 392);
  if (v9)
    v11 = a1[1];
  else
    v11 = *(_QWORD *)(*a1 + 392);
  v105 = 0;
  v106 = 0;
  v103 = 0;
  v104 = 0;
  v12 = *(unsigned int *)(*(_QWORD *)(v10 + 376) + 36);
  if ((a2 & 2) == 0)
  {
    if (*a3)
    {
      if (v9)
        goto LABEL_7;
    }
    else
    {
      *a3 = 1;
      if (v9)
      {
LABEL_7:
        extended = obj_modify(v9, 0, a5);
        if ((_DWORD)extended)
        {
          if (obj_type((uint64_t)v9) == 13)
            v14 = (const char *)(v9 + 485);
          else
            v14 = (const char *)(v9[48] + 208);
          log_err("%s:%d: %s obj_modify() failed: %d\n", "omap_reap", 309, v14, extended);
        }
LABEL_25:
        v20 = *a3;
        if (*a3 == 1)
        {
          v120 = 0;
          *(_QWORD *)&v109[0] = 0;
          spaceman_currently_available_space(v11, (unint64_t *)&v120, (unint64_t *)v109, 0, 0);
          v21 = omap_map_tree_get(v11, (uint64_t)a1, 0, 0, (uint64_t *)&v104);
          if ((_DWORD)v21)
          {
            extended = v21;
            if (obj_type(v11) == 13)
              v22 = (const char *)(v11 + 3880);
            else
              v22 = (const char *)(*(_QWORD *)(v11 + 384) + 208);
            log_err("%s:%d: %s failed to get omap tree for reaping: %d\n", "omap_reap", 322, v22, extended);
            return extended;
          }
          v24 = v12;
          v25 = 0;
          v26 = 1024;
          if (*(_QWORD *)&v109[0] < 0x7D1uLL)
            v26 = 102;
          if (*(_QWORD *)&v109[0] >= 0x3E9uLL)
            v27 = v26;
          else
            v27 = 51;
          v103 = 0x1000000010;
          v98 = v24;
          v92 = v24 - 1;
          v94 = v27;
          v96 = (const char *)(v11 + 3880);
          while (1)
          {
            v28 = bt_lookup_variant((uint64_t)v104, 0, (unint64_t *)a3 + 1, (unsigned int *)&v103 + 1, 0x10u, &v105, (unsigned int *)&v103, 4u, 0, 0);
            if ((_DWORD)v28)
              break;
            if ((v105 & 1) != 0)
            {
              v103 = 0x1000000010;
            }
            else
            {
              v88 = v8;
              v29 = (v92 + HIDWORD(v105)) / v98;
              v30 = spaceman_free((const char *)v11, 0, v106, v29, v5);
              if (v30)
              {
                v31 = v30;
                v32 = obj_type(v11);
                v33 = (const char *)(v11 + 3880);
                if (v32 != 13)
                  v33 = (const char *)(*(_QWORD *)(v11 + 384) + 208);
                log_err("%s:%d: %s spaceman_free(%lld, %lld) failed: %d\n", "omap_reap", 349, v33, v106, v29, v31);
              }
              obj_cache_remove(*(pthread_mutex_t **)(v10 + 392), (uint64_t)v9, *((_QWORD *)a3 + 1), *((_QWORD *)a3 + 2));
              v25 += v29;
              if (v25 >= v94)
              {
                extended = 36;
                v8 = v88;
                goto LABEL_59;
              }
              v103 = 0x1000000010;
              v8 = v88;
            }
          }
          extended = v28;
          if ((_DWORD)v28 != 36)
          {
            extended = btree_delete((uint64_t)v104, v5, 0);
            if ((_DWORD)extended)
            {
              if (obj_type(v11) != 13)
                v96 = (const char *)(*(_QWORD *)(v11 + 384) + 208);
              log_err("%s:%d: %s tree_delete() failed: %d\n", "omap_reap", 373, v96, extended);
            }
            *a3 = 2;
          }
LABEL_59:
          obj_release(v104);
          v20 = *a3;
        }
        if (v20 != 2)
          return extended;
        v34 = *(_QWORD *)(v8 + 56);
        if (v34)
        {
          v35 = *(_DWORD *)(v8 + 44);
          v121 = 0u;
          v126 = 0;
          v125 = 0u;
          v124 = 0u;
          v123 = 0u;
          v122 = 0u;
          v120 = omap_snapshot_key_cmp;
          DWORD2(v121) = 19;
          if ((unsigned __int16)v35 == 2)
          {
            extended = btree_get_extended(v11, v35 & 0xFFFF0000, v34, 0, 0, (uint64_t)&v120, 0, (uint64_t *)&v104);
            if (!(_DWORD)extended)
            {
              extended = btree_delete((uint64_t)v104, v5, 0);
              if ((_DWORD)extended)
              {
                if (obj_type(v11) == 13)
                  v36 = (const char *)(v11 + 3880);
                else
                  v36 = (const char *)(*(_QWORD *)(v11 + 384) + 208);
                log_err("%s:%d: %s tree_delete() failed: %d\n", "omap_reap", 390, v36, extended);
              }
              obj_release(v104);
              goto LABEL_72;
            }
          }
          else
          {
            extended = 22;
          }
          if (obj_type(v11) == 13)
            v37 = (const char *)(v11 + 3880);
          else
            v37 = (const char *)(*(_QWORD *)(v11 + 384) + 208);
          log_err("%s:%d: %s failed to get omap snapshot tree for reaping: %d\n", "omap_reap", 386, v37, extended);
        }
LABEL_72:
        obj_delete_and_free(a1, v5);
        *a3 = -1;
        return extended;
      }
    }
    extended = 0;
    goto LABEL_25;
  }
  v118 = 0;
  v119 = 0;
  v116[1] = 0;
  v117 = 0;
  v116[0] = 0;
  v115 = 0uLL;
  v114 = 0uLL;
  v113 = 0uLL;
  v112 = 0uLL;
  v110 = 0;
  v111 = 0;
  memset(v109, 0, sizeof(v109));
  v107 = 0;
  v108 = 0;
  spaceman_currently_available_space(v11, &v108, &v107, 0, 0);
  if (v107 >= 0x7D1)
    v15 = 1024;
  else
    v15 = 102;
  if (v107 >= 0x3E9)
    v16 = v15;
  else
    v16 = 51;
  obj_lock((uint64_t)a1, 2);
  v17 = *((_DWORD *)a1 + 96);
  if ((v17 & 1) != 0)
  {
    while (1)
      ;
  }
  *((_DWORD *)a1 + 96) = v17 | 1;
  v18 = omap_obj_modify((_QWORD *)v11, a1, v5);
  if (v18)
  {
    LODWORD(extended) = v18;
    if (obj_type(v11) == 13)
      v19 = (const char *)(v11 + 3880);
    else
      v19 = (const char *)(*(_QWORD *)(v11 + 384) + 208);
    log_err("%s:%d: %s error modifying omap: %d\n", "omap_cleanup", 1443, v19, extended);
    if ((_DWORD)extended == 28)
      extended = 36;
    else
      extended = extended;
    goto LABEL_75;
  }
  v23 = omap_map_tree_get(v11, (uint64_t)a1, 1, v5, (uint64_t *)&v117);
  if ((_DWORD)v23)
  {
    extended = v23;
    obj_type(v11);
    log_err("%s:%d: %s error getting mapping tree: %d\n");
    goto LABEL_75;
  }
  v95 = v16;
  if (*a3)
  {
    v38 = 0;
  }
  else
  {
    obj_unlock((uint64_t)a1, 2);
    v115 = 0uLL;
    v111 = 0x1000000010;
    bt_iterator_init_with_hint((uint64_t)v109, (uint64_t)v117, 0, 0, (unint64_t *)&v115, 16, 0x10u, &v113, 0x10u, 0);
    v38 = 0;
    if (!bt_iterator_ended((uint64_t)v109))
    {
      v38 = 0;
      v100 = v12 - 1;
      v90 = v8;
      do
      {
        if ((unint64_t)v115 >= *(_QWORD *)(v8 + 88))
          break;
        v60 = v12;
        v61 = bt_remove((uint64_t)v117, 0, (unint64_t *)&v115, 0x10u, v5);
        if (v61)
        {
          v62 = v61;
          if (obj_type(v11) == 13)
            log_err("%s:%d: %s remove mapping (%lld, %lld) below watermark failed: %d\n", "omap_cleanup", 1468, (const char *)(v11 + 3880), (_QWORD)v115, *((_QWORD *)&v115 + 1), v62);
          else
            log_err("%s:%d: %s remove mapping (%lld, %lld) below watermark failed: %d\n", "omap_cleanup", 1468, (const char *)(*(_QWORD *)(v11 + 384) + 208), (_QWORD)v115, *((_QWORD *)&v115 + 1), v62);
        }
        if ((v113 & 1) == 0)
        {
          v63 = (v100 + DWORD1(v113)) / v60;
          v64 = spaceman_free((const char *)v11, 0, *((unint64_t *)&v113 + 1), v63, v5);
          if (v64)
          {
            v65 = v64;
            v66 = obj_type(v11);
            v67 = (const char *)(v11 + 3880);
            if (v66 != 13)
              v67 = (const char *)(*(_QWORD *)(v11 + 384) + 208);
            log_err("%s:%d: %s spaceman_free(%lld, %d) failed: %d\n", "omap_cleanup", 1475, v67, *((_QWORD *)&v113 + 1), v63, v65);
          }
          obj_cache_remove(*(pthread_mutex_t **)(v10 + 392), (uint64_t)v9, v115, *((uint64_t *)&v115 + 1));
          v8 = v90;
        }
        if (v95 == v38)
        {
LABEL_191:
          obj_lock((uint64_t)a1, 2);
          extended = 36;
          goto LABEL_75;
        }
        v12 = v60;
        ++v38;
        bt_iterator_next((uint64_t)v109);
      }
      while (!bt_iterator_ended((uint64_t)v109));
    }
    obj_lock((uint64_t)a1, 2);
  }
  v40 = *(_QWORD *)(v8 + 56);
  if (!v40)
    goto LABEL_211;
  v99 = v12;
  if (*a3 && *((_QWORD *)a3 + 4) != -1)
    goto LABEL_85;
  v57 = *(_DWORD *)(v8 + 44);
  v121 = 0u;
  v126 = 0;
  v125 = 0u;
  v124 = 0u;
  v123 = 0u;
  v122 = 0u;
  v120 = omap_snapshot_key_cmp;
  DWORD2(v121) = 19;
  if ((unsigned __int16)v57 != 2)
  {
    extended = 22;
    goto LABEL_147;
  }
  extended = btree_get_extended(v11, v57 & 0xFFFF0000, v40, 0, 0, (uint64_t)&v120, v5, (uint64_t *)&v118);
  if ((_DWORD)extended)
  {
LABEL_147:
    obj_type(v11);
    log_err("%s:%d: %s unable to get snapshot tree: %d\n");
    goto LABEL_75;
  }
  if (!*a3)
  {
    v91 = v8;
    v75 = v5;
    *((_QWORD *)a3 + 2) = 0;
    *((_QWORD *)a3 + 3) = 0;
    v76 = (uint64_t *)(a3 + 4);
    v119 = 0;
    v111 = 0x800000010;
    bt_iterator_init_with_hint((uint64_t)v109, (uint64_t)v118, 0, 0, &v119, 8, 8u, v116, 0x10u, 0);
    while (!bt_iterator_ended((uint64_t)v109))
    {
      v77 = v116[0];
      v78 = *v76;
      if ((v116[0] & 1) != 0)
      {
        if (v78)
        {
          if (((a3[1] ^ LODWORD(v116[0])) & 2) != 0)
            break;
          *((_QWORD *)a3 + 3) = v119;
        }
        else
        {
          v79 = v119;
          *((_QWORD *)a3 + 2) = v119;
          *((_QWORD *)a3 + 3) = v79;
          a3[1] = v77;
        }
      }
      else if (v78)
      {
        goto LABEL_206;
      }
      bt_iterator_next((uint64_t)v109);
    }
    v78 = *v76;
    if (*v76)
    {
LABEL_206:
      *((_QWORD *)a3 + 1) = v78;
      v111 = 0x800000010;
      v80 = bt_lookup_variant((uint64_t)v118, 0, (unint64_t *)a3 + 1, (unsigned int *)&v111 + 1, 8u, v116, (unsigned int *)&v111, 2u, 0, 0);
      v5 = v75;
      v8 = v91;
      if ((_DWORD)v80)
      {
        extended = v80;
        if ((_DWORD)v80 != 2)
          goto LABEL_225;
        *((_QWORD *)a3 + 1) = 0;
      }
      *((_QWORD *)a3 + 5) = 0;
      *((_QWORD *)a3 + 6) = 0;
      if (obj_type(v11) == 13)
        v81 = (const char *)(v11 + 3880);
      else
        v81 = (const char *)(*(_QWORD *)(v11 + 384) + 208);
      log_debug("%s:%d: %s started cleaning snapshots %lld-%lld\n", "omap_cleanup", 1568, v81, *((_QWORD *)a3 + 2), *((_QWORD *)a3 + 3));
      a1[60] = *((_QWORD *)a3 + 1);
      v59 = *((_QWORD *)a3 + 3);
      a1[61] = v59;
      *a3 = 1;
      *((_DWORD *)a1 + 96) |= 2u;
      v58 = (unint64_t *)(a3 + 8);
      goto LABEL_222;
    }
LABEL_211:
    extended = 0;
    goto LABEL_75;
  }
  v58 = (unint64_t *)(a3 + 8);
  if (*((_QWORD *)a3 + 4) != -1)
    goto LABEL_85;
  v59 = *((_QWORD *)a3 + 3);
LABEL_222:
  *v58 = v59;
  v111 = 0x800000010;
  v82 = bt_lookup_variant((uint64_t)v118, 0, v58, (unsigned int *)&v111 + 1, 8u, v116, (unsigned int *)&v111, 4u, 0, 0);
  if ((_DWORD)v82)
  {
    extended = v82;
    if ((_DWORD)v82 == 2)
    {
      *v58 = -1;
      goto LABEL_85;
    }
LABEL_225:
    obj_type(v11);
    log_err("%s:%d: %s error searching snapshot tree: %d\n");
    goto LABEL_75;
  }
LABEL_85:
  if (v118)
  {
    obj_release(v118);
    v118 = 0;
  }
  v97 = a3[1];
  v93 = *((_QWORD *)a3 + 1);
  v86 = *((_QWORD *)a3 + 4);
  v87 = *((_QWORD *)a3 + 3);
  v115 = *(_OWORD *)(a3 + 10);
  v111 = 0x1000000010;
  v41 = bt_lookup_variant((uint64_t)v117, 0, (unint64_t *)&v115, (unsigned int *)&v111 + 1, 0x10u, &v113, (unsigned int *)&v111, 3u, 0, 0);
  if ((_DWORD)v41)
  {
    extended = v41;
    if ((_DWORD)v41 != 2)
      goto LABEL_75;
    *(_QWORD *)&v115 = 0;
  }
  obj_unlock((uint64_t)a1, 2);
  v42 = v115;
  if (!(_QWORD)v115)
  {
    obj_lock((uint64_t)a1, 2);
    goto LABEL_167;
  }
  v89 = v8;
  v43 = 0;
  v101 = 0;
  v84 = a3 + 10;
  v85 = (const char *)(v11 + 3880);
  do
  {
    v44 = v43;
    if (v42 != v101)
    {
      if (v38 >= v95)
      {
        *v84 = v115;
        goto LABEL_191;
      }
      v44 = 0;
    }
    v101 = v42;
    v114 = v115;
    v111 = 0x1000000010;
    v45 = bt_lookup_variant((uint64_t)v117, 0, (unint64_t *)&v114, (unsigned int *)&v111 + 1, 0x10u, &v112, (unsigned int *)&v111, 4u, 0, 0);
    if ((_DWORD)v45)
    {
      extended = v45;
      if ((_DWORD)v45 != 2)
      {
        if (obj_type(v11) != 13)
          v85 = (const char *)(*(_QWORD *)(v11 + 384) + 208);
        log_err("%s:%d: %s lookup returned unexpected error while iterating: %d\n", "omap_cleanup", 1665, v85, extended);
        *v84 = v115;
        obj_lock((uint64_t)a1, 2);
        goto LABEL_75;
      }
      *(_QWORD *)&v114 = 0;
    }
    v43 = (v44 + 1);
    if (*((_QWORD *)&v115 + 1) <= v93 || *((_QWORD *)&v115 + 1) > v87)
    {
      if ((v97 & 2) == 0 || (_QWORD)v114 != (_QWORD)v115)
      {
        extended = 0;
        v47 = 0;
        goto LABEL_126;
      }
      extended = 0;
      if (*((_QWORD *)&v114 + 1) > v93 && *((_QWORD *)&v114 + 1) <= v86)
      {
        extended = 0;
        v47 = v112 & 1;
        goto LABEL_126;
      }
LABEL_115:
      v47 = 0;
      goto LABEL_126;
    }
    if ((v97 & 2) == 0)
    {
      extended = 0;
      if ((_QWORD)v114 != (_QWORD)v115)
        goto LABEL_115;
      v47 = 0;
      if (*((_QWORD *)&v114 + 1) > v86)
        goto LABEL_126;
    }
    v48 = bt_remove((uint64_t)v117, 0, (unint64_t *)&v115, 0x10u, v5);
    if (v48)
    {
      v49 = v48;
      if (obj_type(v11) == 13)
        log_err("%s:%d: %s remove mapping (%lld, %lld) failed: %d\n", "omap_cleanup", 1689, v85, (_QWORD)v115, *((_QWORD *)&v115 + 1), v49);
      else
        log_err("%s:%d: %s remove mapping (%lld, %lld) failed: %d\n", "omap_cleanup", 1689, (const char *)(*(_QWORD *)(v11 + 384) + 208), (_QWORD)v115, *((_QWORD *)&v115 + 1), v49);
    }
    v50 = (v99 - 1 + DWORD1(v113)) / v99;
    extended = spaceman_free((const char *)v11, 0, *((unint64_t *)&v113 + 1), v50, v5);
    if ((_DWORD)extended)
    {
      v51 = obj_type(v11);
      v52 = (const char *)(v11 + 3880);
      if (v51 != 13)
        v52 = (const char *)(*(_QWORD *)(v11 + 384) + 208);
      log_err("%s:%d: %s spaceman_free(%lld, %d) failed: %d\n", "omap_cleanup", 1695, v52, *((_QWORD *)&v113 + 1), v50, extended);
    }
    if ((v97 & 2) == 0)
      obj_cache_remove(*(pthread_mutex_t **)(v10 + 392), (uint64_t)v9, v115, *((uint64_t *)&v115 + 1));
    v53 = (v97 >> 1) & 1;
    if (!(_DWORD)v44)
      LOBYTE(v53) = 1;
    v47 = (v112 & v53);
    v43 = v44;
LABEL_126:
    if ((v112 & 1) != 0)
    {
      if (v47)
      {
        v54 = bt_remove((uint64_t)v117, 0, (unint64_t *)&v114, 0x10u, v5);
        if (v54)
        {
          v55 = v54;
          if (obj_type(v11) == 13)
            log_err("%s:%d: %s remove mapping (%lld, %lld) failed: %d\n", "omap_cleanup", 1722, v85, (_QWORD)v114, *((_QWORD *)&v114 + 1), v55);
          else
            log_err("%s:%d: %s remove mapping (%lld, %lld) failed: %d\n", "omap_cleanup", 1722, (const char *)(*(_QWORD *)(v11 + 384) + 208), (_QWORD)v114, *((_QWORD *)&v114 + 1), v55);
        }
      }
      v111 = 0x1000000010;
      v56 = bt_lookup_variant((uint64_t)v117, 0, (unint64_t *)&v114, (unsigned int *)&v111 + 1, 0x10u, &v112, (unsigned int *)&v111, 4u, 0, 0);
      extended = v56;
      if ((_DWORD)v56)
      {
        if ((_DWORD)v56 == 2)
        {
          extended = 0;
          *(_QWORD *)&v114 = 0;
        }
        else if (obj_type(v11) == 13)
        {
          log_err("%s:%d: %s lookup returned unexpected error while iterating: %d\n", "omap_cleanup", 1739, v85, extended);
        }
        else
        {
          log_err("%s:%d: %s lookup returned unexpected error while iterating: %d\n", "omap_cleanup", 1739, (const char *)(*(_QWORD *)(v11 + 384) + 208), extended);
        }
      }
    }
    ++v38;
    v115 = v114;
    v113 = v112;
    v42 = v114;
  }
  while ((_QWORD)v114);
  obj_lock((uint64_t)a1, 2);
  v8 = v89;
  if ((_DWORD)extended)
    goto LABEL_75;
LABEL_167:
  v68 = *(_DWORD *)(v8 + 44);
  v69 = *(_QWORD *)(v8 + 56);
  v121 = 0u;
  v125 = 0u;
  v124 = 0u;
  v123 = 0u;
  v122 = 0u;
  v126 = 0;
  v120 = omap_snapshot_key_cmp;
  DWORD2(v121) = 19;
  if ((unsigned __int16)v68 != 2)
  {
    extended = 22;
    goto LABEL_147;
  }
  extended = btree_get_extended(v11, v68 & 0xFFFF0000, v69, 0, 1, (uint64_t)&v120, v5, (uint64_t *)&v118);
  if ((_DWORD)extended)
    goto LABEL_147;
  if (obj_oid((uint64_t)v118) != *(_QWORD *)(v8 + 56))
  {
    *(_QWORD *)(v8 + 56) = obj_oid((uint64_t)v118);
    obj_dirty((uint64_t)a1, v5, 0);
  }
  v119 = v93;
  v102 = (_QWORD *)(v8 + 72);
  while (1)
  {
    v111 = 0x800000010;
    v70 = bt_lookup_variant((uint64_t)v118, 0, &v119, (unsigned int *)&v111 + 1, 8u, v116, (unsigned int *)&v111, 4u, 0, 0);
    if ((_DWORD)v70)
      break;
    v71 = v119;
    if (v119 < v86)
    {
      v72 = bt_remove((uint64_t)v118, 0, &v119, HIDWORD(v111), v5);
      if ((_DWORD)v72)
      {
        extended = v72;
        obj_type(v11);
        log_err("%s:%d: %s error updating snapshot tree: %d\n");
        goto LABEL_75;
      }
      --*(_DWORD *)(v8 + 36);
      if (obj_type(v11) == 13)
        log_debug("%s:%d: %s completed cleaning snapshot %lld, om_snap_count %d om_most_recent_snap %lld\n", "omap_cleanup", 1793, (const char *)(v11 + 3880), v119, *(_DWORD *)(v8 + 36), *(_QWORD *)(v8 + 64));
      else
        log_debug("%s:%d: %s completed cleaning snapshot %lld, om_snap_count %d om_most_recent_snap %lld\n", "omap_cleanup", 1793, (const char *)(*(_QWORD *)(v11 + 384) + 208), v119, *(_DWORD *)(v8 + 36), *(_QWORD *)(v8 + 64));
      if ((v97 & 2) != 0 && v119 >= *v102)
      {
        v73 = *(_QWORD *)(v8 + 80);
        v74 = v119 >= v73;
        if (v119 <= v73)
        {
          *v102 = v119;
          if (v74)
          {
            *v102 = 0;
            *(_QWORD *)(v8 + 80) = 0;
          }
        }
      }
      obj_dirty((uint64_t)a1, v5, 0);
      v71 = v119;
    }
    if (v71 >= v86)
      goto LABEL_213;
  }
  extended = v70;
  if ((_DWORD)v70 != 2)
    goto LABEL_225;
LABEL_213:
  if (v9 && (v97 & 2) != 0)
    obj_cache_remove_reverted_fs_objects(*(_QWORD *)(v10 + 392), (uint64_t)v9, v93 + 1, v87);
  if (*(_DWORD *)(v8 + 36))
  {
    v119 = -1;
    v111 = 0x800000010;
    extended = bt_lookup_variant((uint64_t)v118, 0, &v119, (unsigned int *)&v111 + 1, 8u, v116, (unsigned int *)&v111, 1u, 0, 0);
    if ((_DWORD)extended)
      goto LABEL_75;
    *(_QWORD *)(v8 + 64) = v119;
  }
  else
  {
    *(_QWORD *)(v8 + 64) = 0;
    v83 = btree_delete((uint64_t)v118, v5, 0);
    if ((_DWORD)v83)
    {
      extended = v83;
      obj_type(v11);
      log_err("%s:%d: %s error deleting empty snapshot tree: %d\n");
      goto LABEL_75;
    }
    *(_QWORD *)(v8 + 56) = 0;
    obj_dirty((uint64_t)a1, v5, 0);
  }
  *a3 = 0;
  *((_DWORD *)a1 + 96) &= ~2u;
  a1[60] = 0;
  a1[61] = 0;
  if (*(_QWORD *)(v8 + 56))
    extended = 36;
  else
    extended = 0;
LABEL_75:
  *((_DWORD *)a1 + 96) &= ~1u;
  obj_unlock((uint64_t)a1, 2);
  if (v118)
    obj_release(v118);
  if (v117)
    obj_release(v117);
  return extended;
}

uint64_t omap_destroy(uint64_t a1, unint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  int v18;
  uint64_t *v20;

  if (obj_type(a1) == 13)
    v8 = a1;
  else
    v8 = 0;
  v9 = a1;
  if (v8)
    v9 = *(_QWORD *)(v8 + 392);
  v20 = 0;
  if (!xid_is_current_tx(v9, a3))
    return 22;
  v10 = obj_get(*(_QWORD *)(v9 + 392), 0x40000000u, a2, (int *)&om_desc, 0, v8, 0, a3, (uint64_t *)&v20);
  if (!(_DWORD)v10)
  {
    if (v8)
      v11 = obj_oid(v8);
    else
      v11 = 0;
    v12 = obj_type_and_flags((uint64_t)v20);
    v13 = obj_size_phys((uint64_t)v20);
    v14 = obj_oid((uint64_t)v20);
    if (a4)
      v15 = nx_reaper_add(v9, v12, v13, v11, v14, a3, 0, a4);
    else
      v15 = nx_reaper_add_sub_object(v9, v12, v13, v11, v14, a3, 0);
    v10 = v15;
    if ((_DWORD)v15)
    {
      if (obj_type(a1) == 13)
        v16 = (const char *)(a1 + 3880);
      else
        v16 = (const char *)(*(_QWORD *)(a1 + 384) + 208);
      v17 = obj_oid((uint64_t)v20);
      v18 = obj_type_and_flags((uint64_t)v20);
      log_err("%s:%d: %s error adding omap 0x%llx type 0x%x to reap list: %d\n", "omap_destroy", 522, v16, v17, v18, v10);
    }
    obj_release(v20);
  }
  return v10;
}

uint64_t omap_obj_get(uint64_t a1, uint64_t a2, uint64_t a3, char **a4)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  pthread_mutex_t *v16;
  uint64_t v17;
  char **v18;
  uint64_t v19;

  v8 = obj_type(a1);
  v9 = 0;
  v10 = a1;
  if (a1 && v8 == 13)
  {
    v10 = *(_QWORD *)(a1 + 392);
    if (*(_QWORD *)(a1 + 496))
      v9 = *(_QWORD *)(a1 + 496);
    else
      v9 = a1;
  }
  if ((a2 & 1) == 0)
  {
LABEL_9:
    if (v9)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v9 + 1144));
      v12 = *(char **)(v9 + 3496);
      *a4 = v12;
      v13 = (uint64_t *)(*(_QWORD *)(v9 + 376) + 128);
    }
    else
    {
      pthread_mutex_lock((pthread_mutex_t *)(v10 + 656));
      v12 = *(char **)(v10 + 720);
      *a4 = v12;
      v13 = (uint64_t *)(*(_QWORD *)(v10 + 376) + 160);
    }
    v14 = *v13;
    if (v12)
    {
      obj_retain(v12);
      if ((a2 & 1) == 0)
        goto LABEL_25;
      v15 = obj_modify(*a4, a2, a3);
      if ((_DWORD)v15)
      {
        v11 = v15;
        obj_release(*a4);
        if (v9)
          v16 = (pthread_mutex_t *)(v9 + 1144);
        else
          v16 = (pthread_mutex_t *)(v10 + 656);
        goto LABEL_33;
      }
    }
    else
    {
      v17 = obj_get(*(_QWORD *)(v10 + 392), a2 | 0x40000000, v14, &om_desc, 0, v9, 0, a3, a4);
      if ((_DWORD)v17)
      {
        v11 = v17;
        if (v9)
        {
LABEL_27:
          v16 = (pthread_mutex_t *)(v9 + 1144);
LABEL_33:
          pthread_mutex_unlock(v16);
          return v11;
        }
LABEL_32:
        v16 = (pthread_mutex_t *)(v10 + 656);
        goto LABEL_33;
      }
      v18 = (char **)(v9 + 3496);
      if (!v9)
        v18 = (char **)(v10 + 720);
      *v18 = *a4;
      obj_retain(*a4);
      if ((a2 & 1) == 0)
        goto LABEL_25;
    }
    if (obj_oid((uint64_t)*a4) != v14)
    {
      v19 = obj_oid((uint64_t)*a4);
      if (v9)
      {
        *(_QWORD *)(*(_QWORD *)(v9 + 376) + 128) = v19;
        fs_sb_dirty(v9, a3);
        goto LABEL_26;
      }
      *(_QWORD *)(*(_QWORD *)(v10 + 376) + 160) = v19;
      obj_dirty(a1, a3, 0);
      goto LABEL_31;
    }
LABEL_25:
    if (v9)
    {
LABEL_26:
      v11 = 0;
      goto LABEL_27;
    }
LABEL_31:
    v11 = 0;
    goto LABEL_32;
  }
  v11 = obj_modify(a1, 0, a3);
  if (!(_DWORD)v11)
  {
    a2 = a2 | 2;
    goto LABEL_9;
  }
  return v11;
}

uint64_t omap_checkpoint_traverse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t extended;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  __int128 v21;
  uint64_t (*v22)(uint64_t, _QWORD *, int, _QWORD *, int, int *);
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v8 = obj_type(a1);
  v21 = 0uLL;
  if ((_DWORD)a4 == 2)
  {
    if (v8 == 13)
      v9 = a1;
    else
      v9 = 0;
    *(_QWORD *)(a3 + 8) = v9;
  }
  if ((*(_BYTE *)(a3 + 20) & 0x40) != 0)
    return 0;
  obj_lock(a3, 1);
  v10 = obj_type_is_or_contains_ephemeral(*(_DWORD *)(*(_QWORD *)(a3 + 376) + 40));
  v11 = *(_QWORD *)(a3 + 376);
  if (!v10 || !*(_QWORD *)(v11 + 48))
  {
LABEL_12:
    if (obj_type_is_or_contains_ephemeral(*(_DWORD *)(v11 + 44))
      && (v14 = *(_QWORD *)(a3 + 376), (v15 = *(_QWORD *)(v14 + 56)) != 0))
    {
      v16 = *(_DWORD *)(v14 + 44);
      v23 = 0u;
      v24 = 0u;
      v28 = 0;
      v26 = 0u;
      v27 = 0u;
      v25 = 0u;
      v22 = omap_snapshot_key_cmp;
      DWORD2(v23) = 19;
      if ((unsigned __int16)v16 != 2)
      {
        obj_unlock(a3, 1);
        v18 = (uint64_t *)*((_QWORD *)&v21 + 1);
        if (!*((_QWORD *)&v21 + 1))
        {
          v17 = (uint64_t *)v21;
          extended = 22;
          if (!(_QWORD)v21)
            return extended;
          goto LABEL_39;
        }
        extended = 22;
        goto LABEL_35;
      }
      extended = btree_get_extended(a1, v16 & 0xFFFF0000, v15, 0, 0, (uint64_t)&v22, 0, (uint64_t *)&v21);
      obj_unlock(a3, 1);
      if ((_DWORD)extended)
        goto LABEL_32;
    }
    else
    {
      obj_unlock(a3, 1);
    }
    if ((obj_type_and_flags(a3) & 0x80000000) == 0)
    {
      v18 = (uint64_t *)*((_QWORD *)&v21 + 1);
      v17 = (uint64_t *)v21;
      if (v21 != 0)
      {
        if (!*((_QWORD *)&v21 + 1))
        {
          if (!(_QWORD)v21)
            return 0;
          goto LABEL_38;
        }
        goto LABEL_34;
      }
      obj_set_skip_checkpoint_traverse(a3, 1);
      goto LABEL_27;
    }
    if ((_DWORD)a4 == 2)
    {
      v19 = obj_checkpoint_known(a3);
    }
    else
    {
      if ((_DWORD)a4 != 1)
      {
LABEL_27:
        extended = 0;
        goto LABEL_32;
      }
      v19 = obj_checkpoint_start((unsigned int *)a3);
    }
    extended = v19;
LABEL_32:
    v18 = (uint64_t *)*((_QWORD *)&v21 + 1);
    if (!*((_QWORD *)&v21 + 1))
      goto LABEL_36;
    if ((_DWORD)extended)
    {
LABEL_35:
      obj_release(v18);
LABEL_36:
      v17 = (uint64_t *)v21;
      if (!(_QWORD)v21)
        return extended;
      if ((_DWORD)extended)
      {
LABEL_39:
        obj_release(v17);
        return extended;
      }
LABEL_38:
      extended = btree_checkpoint_traverse(a1, a2, (uint64_t)v17, a4);
      v17 = (uint64_t *)v21;
      goto LABEL_39;
    }
LABEL_34:
    extended = btree_checkpoint_traverse(a1, a2, (uint64_t)v18, a4);
    v18 = (uint64_t *)*((_QWORD *)&v21 + 1);
    goto LABEL_35;
  }
  v12 = omap_map_tree_get(a1, a3, 0, 0, (uint64_t *)&v21 + 1);
  if (!(_DWORD)v12)
  {
    v11 = *(_QWORD *)(a3 + 376);
    goto LABEL_12;
  }
  extended = v12;
  obj_unlock(a3, 1);
  return extended;
}

uint64_t omap_set(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, uint64_t a7)
{
  int v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v23;
  char *v24;
  _QWORD v25[2];
  unint64_t v26[2];
  uint64_t *v27;

  v14 = obj_type(a1);
  v15 = (_QWORD *)a1;
  if (a1)
  {
    v15 = (_QWORD *)a1;
    if (v14 == 13)
      v15 = *(_QWORD **)(a1 + 392);
  }
  v26[1] = a3;
  v27 = 0;
  v25[1] = a4;
  v26[0] = a2;
  v25[0] = __PAIR64__(a5, a6);
  v23 = 0;
  v24 = 0;
  v16 = 22;
  if (xid_is_current_tx((uint64_t)v15, a7) && a2 && a3 && a5)
  {
    v17 = v15[47];
    if ((*(_BYTE *)(v17 + 65) & 1) != 0)
    {
      v21 = spaceman_get(v15, (uint64_t *)&v27);
      if ((_DWORD)v21)
      {
        v16 = v21;
        if (obj_type(a1) == 13)
          log_err("%s:%d: %s unable to get spaceman: %d\n", "omap_set", 770, (const char *)(a1 + 3880), v16);
        else
          log_err("%s:%d: %s unable to get spaceman: %d\n", "omap_set", 770, (const char *)(*(_QWORD *)(a1 + 384) + 208), v16);
        return v16;
      }
      v17 = v15[47];
      v19 = (a5 + *(_DWORD *)(v17 + 36) - 1) / *(_DWORD *)(v17 + 36);
      if (v27)
        v18 = v27[47];
      else
        v18 = 0;
    }
    else
    {
      v18 = 0;
      v19 = (a5 + *(_DWORD *)(v17 + 36) - 1) / *(_DWORD *)(v17 + 36);
    }
    v16 = nx_superblock_sanity_check_extent(v17, v18, a4, v19, 0);
    if (v27)
      obj_release(v27);
    if (!(_DWORD)v16)
    {
      v16 = omap_obj_get(a1, 1, a7, &v24);
      if (!(_DWORD)v16)
      {
        obj_lock((uint64_t)v24, 2);
        v20 = omap_map_tree_get(a1, (uint64_t)v24, 1, a7, (uint64_t *)&v23);
        if ((_DWORD)v20)
        {
          v16 = v20;
        }
        else
        {
          if ((a6 & 4) != 0)
            LODWORD(v25[0]) = *(_DWORD *)(*((_QWORD *)v24 + 47) + 32) & 0x10 | a6;
          v16 = bt_insert(v23, 0, v26, 16, v25, 0x10u, a7);
          obj_release(v23);
        }
        obj_unlock((uint64_t)v24, 2);
        obj_release((uint64_t *)v24);
      }
    }
  }
  return v16;
}

uint64_t omap_delete(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7)
{
  int v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  BOOL v21;
  uint64_t v22;
  _BOOL4 v23;
  uint64_t v24;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28[3];
  uint64_t v29;
  uint64_t v30;
  char *v31;
  _DWORD v32[2];
  uint64_t v33;
  __int128 v34;

  v14 = obj_type(a1);
  v15 = a1;
  if (a1)
  {
    v15 = a1;
    if (v14 == 13)
      v15 = *(_QWORD *)(a1 + 392);
  }
  *(_QWORD *)&v34 = a2;
  *((_QWORD *)&v34 + 1) = a3;
  v32[0] = a6;
  v32[1] = a5;
  v33 = a4;
  v30 = 0;
  v31 = 0;
  v29 = 0;
  v16 = 22;
  if (!xid_is_current_tx(v15, a7))
    return v16;
  if (!a2)
    return v16;
  if (!a3)
    return v16;
  v16 = omap_obj_get(a1, 1, a7, &v31);
  if ((_DWORD)v16)
    return v16;
  obj_lock((uint64_t)v31, 2);
  v16 = omap_map_tree_get(a1, v31, 1, a7, &v30);
  v17 = v31;
  if ((_DWORD)v16)
  {
LABEL_45:
    obj_unlock((uint64_t)v17, 2);
    obj_release(v31);
    return v16;
  }
  v18 = *((_QWORD *)v31 + 47);
  v19 = *(_QWORD *)(v18 + 64);
  if ((v31[384] & 2) != 0 && *((_QWORD *)v31 + 61) == v19)
    v19 = *((_QWORD *)v31 + 60);
  if ((*(_BYTE *)(v18 + 32) & 1) != 0)
  {
    if ((a6 & 1) == 0)
    {
      *(_OWORD *)v28 = v34;
      v26 = 0;
      v27 = 0;
      v29 = 0x1000000010;
      v22 = bt_lookup_variant(v30, 0, v28, (unsigned int *)&v29 + 1, 0x10u, &v26, (unsigned int *)&v29, 0, 0, 0);
      if ((_DWORD)v22)
        goto LABEL_43;
      v20 = 0;
      v23 = ((v26 >> 1) & 1) == 0;
      goto LABEL_27;
    }
    v20 = 0;
    goto LABEL_26;
  }
  v20 = a6 & 1;
  if (v19 < a3)
  {
    if (v20)
    {
      *(_OWORD *)v28 = v34;
      v26 = 0;
      v27 = 0;
      v29 = 0x1000000010;
      if (bt_lookup_variant(v30, 0, v28, (unsigned int *)&v29 + 1, 0x10u, &v26, (unsigned int *)&v29, 2u, 0, 0))v21 = 0;
      else
        v21 = v28[0] == a2;
      v20 = v21;
    }
LABEL_26:
    v23 = 1;
    goto LABEL_27;
  }
  v23 = 0;
LABEL_27:
  if (v20 | v23)
  {
    if (v20)
    {
      *((_QWORD *)&v34 + 1) = a7;
      v16 = bt_insert(v30, 0, &v34, 16, v32, 16, a7);
    }
    else
    {
      v16 = 0;
    }
    if (v23 && !(_DWORD)v16)
    {
      if (a3 == a7 && v20)
      {
        v16 = 0;
      }
      else
      {
        *((_QWORD *)&v34 + 1) = a3;
        v24 = bt_remove(v30, 0, &v34, 16, a7);
        v16 = v24;
        if (v20 && (_DWORD)v24)
        {
          *((_QWORD *)&v34 + 1) = a7;
          bt_remove(v30, 0, &v34, 16, a7);
LABEL_44:
          obj_release(v30);
          v17 = v31;
          goto LABEL_45;
        }
      }
    }
    if (!v23 || (_DWORD)v16)
      goto LABEL_44;
    v22 = spaceman_free(a1, 0, a4, (a5 + *(_DWORD *)(*(_QWORD *)(v15 + 376) + 36) - 1)/ *(_DWORD *)(*(_QWORD *)(v15 + 376) + 36), a7);
LABEL_43:
    v16 = v22;
    goto LABEL_44;
  }
  obj_release(v30);
  obj_unlock((uint64_t)v31, 2);
  obj_release(v31);
  return 0;
}

uint64_t omap_get(uint64_t a1, unint64_t a2, unint64_t a3, _QWORD *a4, _DWORD *a5, _DWORD *a6, unint64_t *a7)
{
  uint64_t v11;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  BOOL v21;
  int v22;
  char v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  char *v32;

  v11 = a3;
  v31 = 0;
  v32 = 0;
  v29 = a2;
  v30 = a3;
  v27 = 0;
  v28 = 0;
  v25 = 16;
  v26 = 16;
  v24 = 0;
  v14 = omap_obj_get(a1, 0, 0, &v32);
  if (!(_DWORD)v14)
  {
    obj_lock((uint64_t)v32, 1);
    if (*(_QWORD *)(*((_QWORD *)v32 + 47) + 88) > a2)
    {
      obj_unlock((uint64_t)v32, 1);
      v14 = 2;
LABEL_33:
      obj_release(v32);
      return v14;
    }
    v15 = omap_map_tree_get(a1, (uint64_t)v32, 0, 0, &v31);
    if ((_DWORD)v15)
    {
      v14 = v15;
      obj_unlock((uint64_t)v32, 1);
      goto LABEL_33;
    }
    if (!v11)
    {
      v11 = -1;
      v30 = -1;
    }
    v16 = 1;
    v17 = bt_lookup_variant(v31, 0, &v29, &v26, 0x10u, &v27, &v25, 1u, 0, 0);
    if ((_DWORD)v17)
      goto LABEL_9;
    v18 = *((_QWORD *)v32 + 47);
    v19 = *(_QWORD *)(v18 + 72);
    v20 = v29;
    if (v19)
      v21 = v29 == a2;
    else
      v21 = 0;
    if (v21)
    {
      if (v30 < v19 || v30 > *(_QWORD *)(v18 + 80))
        goto LABEL_18;
      v29 = a2;
      v30 = v19 - 1;
      v17 = bt_lookup_variant(v31, 0, &v29, &v26, 0x10u, &v27, &v25, 1u, 0, 0);
      if ((_DWORD)v17)
      {
LABEL_9:
        v14 = v17;
        goto LABEL_31;
      }
      v20 = v29;
    }
    if (v20 != a2)
    {
LABEL_30:
      v14 = 2;
LABEL_31:
      obj_release(v31);
      obj_unlock((uint64_t)v32, 1);
      if (!v16)
        omap_tracking_stop(a1, (uint64_t)v32);
      goto LABEL_33;
    }
LABEL_18:
    v22 = v27;
    if ((v27 & 1) == 0)
    {
      if (a4)
        *a4 = v28;
      if (a5)
        *a5 = HIDWORD(v27);
      if (a6)
      {
        *a6 = v22 & 0xFFFFFFEF;
        if (((*(_DWORD *)(*((_QWORD *)v32 + 47) + 32) ^ v22) & 0x10) != 0)
          *a6 = v22 | 0x10;
      }
      if (a7)
        *a7 = v30;
      if (*((_QWORD *)v32 + 53))
      {
        omap_tracking((uint64_t)v32, a2, v11, &v24);
        v14 = 0;
        v16 = v24 == 0;
      }
      else
      {
        v14 = 0;
      }
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  return v14;
}

uint64_t omap_tracking(uint64_t result, unint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v4;
  unint64_t v7;
  int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unsigned __int8 v12;
  uint64_t v13;
  unint64_t v14;
  timespec __tp;

  v13 = 1;
  v14 = a2;
  if (*(_QWORD *)(result + 424))
  {
    v4 = result;
    if (!*(_DWORD *)(result + 440))
    {
      v12 = 0;
      v11 = 0;
      __tp.tv_sec = 0;
      __tp.tv_nsec = 0;
      clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
      if (__tp.tv_sec - *(_QWORD *)(v4 + 432) >= 601)
        *a4 = 1;
      btree_node_count(*(_QWORD *)(v4 + 424), &v13);
      v7 = v13;
      result = obj_size_phys(*(_QWORD *)(v4 + 424));
      if (v7 <= 0x200000 / result)
      {
        LODWORD(__tp.tv_sec) = 8;
        v10 = 9;
        result = bt_lookup_variant(*(_QWORD *)(v4 + 424), 0, &v14, (unsigned int *)&__tp, 8u, &v11, &v10, 0, 0, 0);
        if ((_DWORD)result == 2)
        {
          LOBYTE(v8) = *(_BYTE *)(v4 + 464);
        }
        else
        {
          if ((_DWORD)result)
            return result;
          if (!v11)
            return result;
          v8 = *(unsigned __int8 *)(v4 + 464);
          if (v12 == v8)
            return result;
        }
        if (a3 == -1)
          v9 = 0;
        else
          v9 = a3;
        v11 = v9;
        v12 = v8;
        return bt_insert(*(_QWORD **)(v4 + 424), 0, &v14, 8, &v11, 9u, 0);
      }
    }
  }
  return result;
}

uint64_t omap_tracking_stop(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  timespec v6;

  v3 = a1;
  if (obj_type(a1) != 13)
    v3 = 0;
  obj_lock(a2, 2);
  if (*(_QWORD *)(a2 + 424))
  {
    v6.tv_sec = 0;
    v6.tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v6);
    if (v6.tv_sec - *(_QWORD *)(a2 + 432) >= 601)
    {
      btree_delete(*(_QWORD *)(a2 + 424), 0, 0);
      obj_release(*(_QWORD *)(a2 + 424));
      *(_QWORD *)(a2 + 424) = 0;
    }
  }
  if (v3)
  {
    if (*(_QWORD *)(v3 + 496))
      v3 = *(_QWORD *)(v3 + 496);
    v4 = *(_QWORD *)(v3 + 3504);
    if (v4)
    {
      obj_release(v4);
      *(_QWORD *)(v3 + 3504) = 0;
    }
  }
  return obj_unlock(a2, 2);
}

uint64_t omap_find_next_snapshot_xid(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t extended;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v14;
  uint64_t v15;
  _QWORD v16[2];
  uint64_t *v17;
  char *v18;
  uint64_t (*v19)(uint64_t, _QWORD *, int, _QWORD *, int, int *);
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v17 = 0;
  v18 = 0;
  v16[0] = 0;
  v16[1] = 0;
  v14 = 0;
  v15 = 0;
  v6 = omap_obj_get(a1, 0, 0, &v18);
  if ((_DWORD)v6)
  {
    extended = v6;
    if (obj_type(a1) == 13)
      log_err("%s:%d: %s unable to get omap: %d\n", "omap_find_next_snapshot_xid", 1150, (const char *)(a1 + 3880), extended);
    else
      log_err("%s:%d: %s unable to get omap: %d\n", "omap_find_next_snapshot_xid", 1150, (const char *)(*(_QWORD *)(a1 + 384) + 208), extended);
    return extended;
  }
  v8 = *((_QWORD *)v18 + 47);
  obj_lock((uint64_t)v18, 1);
  if ((*(_BYTE *)(v8 + 32) & 1) == 0)
  {
    v9 = *(_QWORD *)(v8 + 56);
    if (v9)
    {
      v10 = *(_DWORD *)(v8 + 44);
      v20 = 0u;
      v21 = 0u;
      v25 = 0;
      v23 = 0u;
      v24 = 0u;
      v22 = 0u;
      v19 = omap_snapshot_key_cmp;
      DWORD2(v20) = 19;
      if ((unsigned __int16)v10 == 2)
      {
        extended = btree_get_extended(a1, v10 & 0xFFFF0000, v9, 0, 0, (uint64_t)&v19, 0, (uint64_t *)&v17);
        if (!(_DWORD)extended)
        {
          v14 = a2;
          do
          {
            v15 = 0x800000010;
            v11 = bt_lookup_variant((uint64_t)v17, 0, &v14, (unsigned int *)&v15 + 1, 8u, v16, (unsigned int *)&v15, 4u, 0, 0);
            if ((_DWORD)v11)
              v12 = 1;
            else
              v12 = (v16[0] & 1) == 0;
          }
          while (!v12);
          extended = v11;
          if (!(_DWORD)v11)
          {
            *a3 = v14;
            goto LABEL_20;
          }
          if ((_DWORD)v11 != 2)
          {
            obj_type(a1);
            log_err("%s:%d: %s error searching snapshot tree: %d\n");
            goto LABEL_20;
          }
          goto LABEL_16;
        }
      }
      else
      {
        extended = 22;
      }
      obj_type(a1);
      log_err("%s:%d: %s unable to get snapshot tree: %d\n");
      goto LABEL_20;
    }
  }
LABEL_16:
  extended = 2;
LABEL_20:
  if (v17)
    obj_release(v17);
  obj_unlock((uint64_t)v18, 1);
  obj_release((uint64_t *)v18);
  return extended;
}

uint64_t omap_obj_modify(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t result;
  pthread_mutex_t *v9;
  uint64_t v10;
  unsigned int v11;
  pthread_mutex_t *v12;
  uint64_t v13;

  if (obj_type((uint64_t)a1) == 13)
    v6 = (uint64_t)a1;
  else
    v6 = 0;
  if (v6)
  {
    v7 = *(_QWORD **)(v6 + 392);
    result = obj_modify(a1, 0, a3);
    if ((_DWORD)result)
      return result;
    v9 = (pthread_mutex_t *)(v6 + 1144);
  }
  else
  {
    result = obj_modify(a1, 0, a3);
    if ((_DWORD)result)
      return result;
    v9 = (pthread_mutex_t *)(a1 + 82);
    v7 = a1;
  }
  pthread_mutex_lock(v9);
  v10 = obj_oid((uint64_t)a2);
  v11 = obj_type_and_flags((uint64_t)a2);
  if (!obj_modify(a2, (v11 >> 29) & 2, a3) && obj_oid((uint64_t)a2) != v10)
  {
    v13 = obj_oid((uint64_t)a2);
    if (v6)
    {
      *(_QWORD *)(*(_QWORD *)(v6 + 376) + 128) = v13;
      fs_sb_dirty(v6, a3);
      goto LABEL_12;
    }
    *(_QWORD *)(v7[47] + 160) = v13;
    obj_dirty((uint64_t)a1, a3, 0);
LABEL_16:
    v12 = (pthread_mutex_t *)(v7 + 82);
    goto LABEL_17;
  }
  if (!v6)
    goto LABEL_16;
LABEL_12:
  v12 = (pthread_mutex_t *)(v6 + 1144);
LABEL_17:
  pthread_mutex_unlock(v12);
  return 0;
}

unint64_t parse_size(const char *a1)
{
  unint64_t result;
  char *v3;
  unsigned int v4;
  char *__endptr;

  __endptr = 0;
  result = strtoull(a1, &__endptr, 10);
  v3 = __endptr;
  v4 = *__endptr;
  if (v4 > 0x66)
  {
    if (*__endptr <= 0x6Cu)
    {
      if (v4 != 103)
      {
        if (v4 != 107)
          goto LABEL_19;
LABEL_9:
        result <<= 10;
LABEL_18:
        v3 = __endptr + 1;
        goto LABEL_19;
      }
LABEL_16:
      result <<= 30;
      goto LABEL_18;
    }
    if (v4 != 109)
    {
      if (v4 != 116)
        goto LABEL_19;
      goto LABEL_15;
    }
LABEL_17:
    result <<= 20;
    goto LABEL_18;
  }
  if (*__endptr <= 0x4Cu)
  {
    if (v4 != 71)
    {
      if (v4 != 75)
        goto LABEL_19;
      goto LABEL_9;
    }
    goto LABEL_16;
  }
  if (v4 == 77)
    goto LABEL_17;
  if (v4 == 84)
  {
LABEL_15:
    result <<= 40;
    goto LABEL_18;
  }
LABEL_19:
  if (v3 == a1)
    return -1;
  if (*v3)
    return -1;
  return result;
}

char *parse_apfs_format_options(char *a1, uint64_t a2)
{
  const char *v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  const char *v8;
  const char *v9;
  __int16 v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  const char *v14;
  const char *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  unsigned int v21;
  const char *v22;
  int v23;
  char *__lasts;
  char *__endptr;

  v3 = a1;
  if (!a1)
  {
    *(_OWORD *)(a2 + 464) = 0u;
    *(_OWORD *)(a2 + 480) = 0u;
    *(_OWORD *)(a2 + 432) = 0u;
    *(_OWORD *)(a2 + 448) = 0u;
    *(_OWORD *)(a2 + 400) = 0u;
    *(_OWORD *)(a2 + 416) = 0u;
    *(_OWORD *)(a2 + 368) = 0u;
    *(_OWORD *)(a2 + 384) = 0u;
    *(_OWORD *)(a2 + 336) = 0u;
    *(_OWORD *)(a2 + 352) = 0u;
    *(_OWORD *)(a2 + 304) = 0u;
    *(_OWORD *)(a2 + 320) = 0u;
    *(_OWORD *)(a2 + 272) = 0u;
    *(_OWORD *)(a2 + 288) = 0u;
    *(_OWORD *)(a2 + 240) = 0u;
    *(_OWORD *)(a2 + 256) = 0u;
    *(_OWORD *)(a2 + 208) = 0u;
    *(_OWORD *)(a2 + 224) = 0u;
    *(_OWORD *)(a2 + 176) = 0u;
    *(_OWORD *)(a2 + 192) = 0u;
    *(_OWORD *)(a2 + 144) = 0u;
    *(_OWORD *)(a2 + 160) = 0u;
    *(_OWORD *)(a2 + 112) = 0u;
    *(_OWORD *)(a2 + 128) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
    MEMORY[0x1E0BFD200](a2);
    *(_OWORD *)(a2 + 32) = xmmword_1DF2E0F90;
    *(_DWORD *)(a2 + 492) = 1073741826;
    *(_DWORD *)(a2 + 48) = -1;
    *(_DWORD *)(a2 + 444) = getuid();
    *(_DWORD *)(a2 + 448) = getgid();
    *(_WORD *)(a2 + 52) &= ~0x80u;
    __strlcpy_chk();
    *(_WORD *)(a2 + 52) = *(_WORD *)(a2 + 52) & 0xFBF3 | 8;
    return (char *)v3;
  }
  if (!strncasecmp(a1, "uuid_from_role", 0xEuLL))
  {
    v21 = *(unsigned __int16 *)(a2 + 54);
    if (v21 > 0xBF)
    {
      if (*(unsigned __int16 *)(a2 + 54) <= 0x1BFu)
      {
        if (*(unsigned __int16 *)(a2 + 54) > 0x13Fu)
        {
          if (v21 == 320)
          {
            v22 = "61706673-7575-6964-0140-766f6c756d00";
            goto LABEL_114;
          }
          if (v21 == 384)
          {
            v22 = "61706673-7575-6964-0180-766f6c756d00";
            goto LABEL_114;
          }
        }
        else
        {
          if (v21 == 192)
          {
            v22 = "61706673-7575-6964-00c0-766f6c756d00";
            goto LABEL_114;
          }
          if (v21 == 256)
          {
            v22 = "61706673-7575-6964-0100-766f6c756d00";
            goto LABEL_114;
          }
        }
      }
      else if (*(unsigned __int16 *)(a2 + 54) <= 0x23Fu)
      {
        if (v21 == 448)
        {
          v22 = "61706673-7575-6964-01c0-766f6c756d00";
          goto LABEL_114;
        }
        if (v21 == 512)
        {
          v22 = "61706673-7575-6964-0200-766f6c756d00";
          goto LABEL_114;
        }
      }
      else
      {
        switch(v21)
        {
          case 0x240u:
            v22 = "61706673-7575-6964-0240-766f6c756d00";
            goto LABEL_114;
          case 0x280u:
            v22 = "61706673-7575-6964-0280-766f6c756d00";
            goto LABEL_114;
          case 0x2C0u:
            v22 = "61706673-7575-6964-02c0-766f6c756d00";
LABEL_114:
            uuid_parse(v22, (unsigned __int8 *)a2);
            return 0;
        }
      }
    }
    else
    {
      if (*(unsigned __int16 *)(a2 + 54) <= 0xFu)
      {
        v22 = "61706673-7575-6964-0000-766f6c756d00";
        switch(*(_WORD *)(a2 + 54))
        {
          case 0:
            goto LABEL_114;
          case 1:
            v22 = "61706673-7575-6964-0001-766f6c756d00";
            goto LABEL_114;
          case 2:
            v22 = "61706673-7575-6964-0002-766f6c756d00";
            goto LABEL_114;
          case 4:
            v22 = "61706673-7575-6964-0004-766f6c756d00";
            goto LABEL_114;
          case 8:
            v22 = "61706673-7575-6964-0008-766f6c756d00";
            goto LABEL_114;
          default:
            return strerror(22);
        }
      }
      if (*(unsigned __int16 *)(a2 + 54) > 0x3Fu)
      {
        if (v21 == 64)
        {
          v22 = "61706673-7575-6964-0040-766f6c756d00";
          goto LABEL_114;
        }
        if (v21 == 128)
        {
          v22 = "61706673-7575-6964-0080-766f6c756d00";
          goto LABEL_114;
        }
      }
      else
      {
        if (v21 == 16)
        {
          v22 = "61706673-7575-6964-0010-766f6c756d00";
          goto LABEL_114;
        }
        if (v21 == 32)
        {
          v22 = "61706673-7575-6964-0020-766f6c756d00";
          goto LABEL_114;
        }
      }
    }
    return strerror(22);
  }
  if (!strncasecmp(v3, "password=", 9uLL))
  {
    v3 += 9;
    __strlcpy_chk();
    v23 = strnlen(v3, 0x80uLL);
    *(_DWORD *)(a2 + 440) = v23;
    if ((v23 & 0xFFFFFF80) == 0)
      return 0;
    return (char *)v3;
  }
  if (!strncasecmp(v3, "empty_password", 0xFuLL))
  {
    v3 = 0;
    *(_BYTE *)(a2 + 312) = 0;
    *(_DWORD *)(a2 + 440) = 0;
    return (char *)v3;
  }
  if (!strncasecmp(v3, "volname=", 8uLL))
  {
    __strlcpy_chk();
    return 0;
  }
  v4 = strdup(v3);
  if (!v4)
    return (char *)v3;
  v5 = v4;
  __lasts = 0;
  v6 = strtok_r(v4, ",", &__lasts);
  if (!v6)
  {
    v3 = 0;
    goto LABEL_103;
  }
  v7 = v6;
  v8 = "fsquota=";
  v9 = "fsindex=";
  while (1)
  {
    if (!strncasecmp(v7, "fssize=", 7uLL))
    {
      v11 = parse_size(v7 + 7);
      if (v11 == -1)
        goto LABEL_102;
      *(_QWORD *)(a2 + 16) = v11;
LABEL_36:
      *(_QWORD *)(a2 + 24) = v11;
      goto LABEL_37;
    }
    if (!strncasecmp(v7, "fsreserve=", 0xAuLL))
    {
      v12 = parse_size(v7 + 10);
      if (v12 == -1)
        goto LABEL_102;
      *(_QWORD *)(a2 + 16) = v12;
      goto LABEL_37;
    }
    if (!strncasecmp(v7, v8, 8uLL))
    {
      v11 = parse_size(v7 + 8);
      if (v11 == -1)
        goto LABEL_102;
      goto LABEL_36;
    }
    if (!strncasecmp(v7, v9, 8uLL))
      break;
    if (!strcasecmp(v7, "omap=btree") || !strcasecmp(v7, "omap=physical"))
    {
      v13 = 1073741826;
LABEL_40:
      *(_DWORD *)(a2 + 32) = v13;
      goto LABEL_37;
    }
    if (!strcasecmp(v7, "omap=ephemeral"))
    {
      v13 = -2147483646;
      goto LABEL_40;
    }
    if (!strcasecmp(v7, "fstree=btree"))
    {
      *(_QWORD *)(a2 + 36) = 0x4000000200000002;
      *(_DWORD *)(a2 + 44) = 1073741826;
      *(_DWORD *)(a2 + 492) = 1073741826;
      goto LABEL_37;
    }
    if (!strcasecmp(v7, "encrypted"))
    {
      v10 = *(_WORD *)(a2 + 52) | 1;
LABEL_55:
      *(_WORD *)(a2 + 52) = v10;
      goto LABEL_37;
    }
    if (!strncasecmp(v7, "role=", 5uLL))
    {
      v17 = parse_str_to_role(v7 + 5);
      if (v17 == -1)
        goto LABEL_102;
      *(_WORD *)(a2 + 54) = v17;
    }
    else
    {
      if (!strcasecmp(v7, "case=insensitive"))
      {
        v10 = *(_WORD *)(a2 + 52) & 0xFFF3 | 4;
        goto LABEL_55;
      }
      if (!strcasecmp(v7, "case=sensitive"))
      {
        v10 = *(_WORD *)(a2 + 52) & 0xFFF3 | 8;
        goto LABEL_55;
      }
      if (!strcasecmp(v7, "defragment=yes"))
      {
        v10 = *(_WORD *)(a2 + 52) & 0xFFCF | 0x20;
        goto LABEL_55;
      }
      if (!strcasecmp(v7, "defragment=no"))
      {
        v10 = *(_WORD *)(a2 + 52) & 0xFFCF | 0x10;
        goto LABEL_55;
      }
      if (!strncasecmp(v7, "uid=", 4uLL))
      {
        v14 = v8;
        v15 = v9;
        __endptr = 0;
        v18 = strtoull(v7 + 4, &__endptr, 10);
        if (__endptr == v7 + 4 || *__endptr || v18 == -1)
          goto LABEL_102;
        *(_DWORD *)(a2 + 444) = v18;
        goto LABEL_45;
      }
      if (!strncasecmp(v7, "gid=", 4uLL))
      {
        v14 = v8;
        v15 = v9;
        __endptr = 0;
        v19 = strtoull(v7 + 4, &__endptr, 10);
        if (__endptr == v7 + 4 || *__endptr || v19 == -1)
          goto LABEL_102;
        *(_DWORD *)(a2 + 448) = v19;
        goto LABEL_45;
      }
      if (!strcasecmp(v7, "sealed=yes"))
      {
        *(_WORD *)(a2 + 52) |= 0x80u;
        *(_DWORD *)(a2 + 488) = 1;
        *(_DWORD *)(a2 + 36) = 2;
        goto LABEL_37;
      }
      if (!strcasecmp(v7, "conformance"))
        goto LABEL_102;
      if (strncasecmp(v7, "hash=", 5uLL))
      {
        if (!strcasecmp(v7, "unwritten"))
        {
          v10 = *(_WORD *)(a2 + 52) | 0x400;
        }
        else
        {
          if (strcasecmp(v7, "unwritten=no"))
            goto LABEL_102;
          v10 = *(_WORD *)(a2 + 52) & 0xFBFF;
        }
        goto LABEL_55;
      }
      v20 = parse_hash_type(v7 + 5);
      if (v20 == -1)
        goto LABEL_102;
      *(_DWORD *)(a2 + 488) = v20;
    }
LABEL_37:
    v7 = strtok_r(0, ",", &__lasts);
    if (!v7)
    {
      v3 = 0;
      goto LABEL_103;
    }
  }
  v14 = v8;
  v15 = v9;
  __endptr = 0;
  v16 = strtoull(v7 + 8, &__endptr, 10);
  if (__endptr != v7 + 8 && !*__endptr && v16 != -1)
  {
    *(_DWORD *)(a2 + 48) = v16;
LABEL_45:
    v9 = v15;
    v8 = v14;
    goto LABEL_37;
  }
LABEL_102:
  v3 += v7 - v5;
LABEL_103:
  free(v5);
  return (char *)v3;
}

uint64_t parse_hash_type(const char *a1)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  if (!strncasecmp(a1, "sha256", 7uLL))
    return 1;
  if (!strncasecmp(a1, "sha512_256", 0xBuLL))
    return 5;
  if (!strncasecmp(a1, "sha384", 7uLL))
    return 3;
  if (!strncasecmp(a1, "sha512", 7uLL))
    return 4;
  return 0xFFFFFFFFLL;
}

char *parse_nx_mount_options(char *a1, int *a2)
{
  unsigned int v4;
  int v5;
  int v6;
  int v7;
  const char *v8;
  char *result;
  int v10;
  unsigned int v11;
  int v12;

  *MEMORY[0x1E0DE8BC0] = 1;
  if (!a1)
  {
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    a2[1] = -1;
    return 0;
  }
  v12 = *a2;
  v4 = *((unsigned __int16 *)a2 + 4);
  v5 = (v4 >> 6) & 8 | v4 & 5 | (v4 >> 8) & 0x10;
  v6 = v4 << 18;
  if ((v4 & 0x1000) != 0)
    v7 = 32;
  else
    v7 = 64;
  v11 = v7 & (v6 >> 31) | v5;
  if (!getmntopts())
    return "";
  *a2 = v12;
  *((_WORD *)a2 + 4) = a2[2] & 0xCDFA | v11 & 1 | v11 & 4 | (((v11 & 0x30) != 0) << 12) | (((v11 & 0x60) != 0) << 13) | (((v11 >> 3) & 1) << 9);
  if ((v11 & 2) != 0)
  {
    v10 = getmntoptnum();
    a2[1] = v10;
    if (v10 == -1)
      v8 = "checkpoint";
    else
      v8 = 0;
  }
  else
  {
    v8 = 0;
  }
  freemntopts();
  result = check_bad_option((const char **)&nx_mopts, a1, v8);
  if (!result)
    return 0;
  return result;
}

char *check_bad_option(const char **a1, char *__s1, const char *a3)
{
  char *v4;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  int v10;
  char *v11;
  char *v12;
  const char *v13;
  const char **v14;
  const char *v15;
  uint64_t v16;
  char *__lasts;

  v4 = __s1;
  v6 = strdup(__s1);
  if (v6)
  {
    v7 = v6;
    __lasts = 0;
    v8 = strtok_r(v6, ",", &__lasts);
    if (v8)
    {
      v9 = v8;
      while (1)
      {
        v10 = strncmp(v9, "no", 2uLL);
        v11 = &v9[2 * (v10 == 0)];
        v12 = strchr(v11, 61);
        if (v12)
          *v12 = 0;
        v13 = *a1;
        if (!*a1)
          break;
        v14 = a1 + 3;
        while (strcasecmp(v13, v11))
        {
          v15 = *v14;
          v14 += 3;
          v13 = v15;
          if (!v15)
            goto LABEL_15;
        }
        if (a3 && !strcasecmp(v11, a3))
          break;
        v9 = strtok_r(0, ",", &__lasts);
        if (!v9)
          goto LABEL_14;
      }
LABEL_15:
      v16 = -2;
      if (v10)
        v16 = 0;
      v4 = &v11[(_QWORD)v4 + v16 - (_QWORD)v7];
    }
    else
    {
LABEL_14:
      v4 = 0;
    }
    free(v7);
  }
  return v4;
}

uint64_t btree_entry_max_size(char a1, __int16 a2, int a3, int a4)
{
  __int16 v4;
  __int16 v5;
  unsigned __int16 v6;
  unsigned __int16 v7;
  __int16 v8;

  if (a3 && a4)
  {
    v4 = (a3 + 7) & 0xFFF8;
    if ((a1 & 0x40) != 0)
      v4 = a3;
    v5 = (a4 + 7) & 0xFFF8;
    if ((a1 & 0x40) != 0)
      v5 = a4;
    return (unsigned __int16)(v5 + v4);
  }
  else
  {
    v6 = a2 - 160;
    if (a4)
    {
      v7 = (v6 >> 2) - 72;
      if ((unsigned __int16)(a3 - 1) < v7)
        v7 = a3;
      if ((a1 & 0x40) == 0)
        v7 = (v7 + 7) & 0xFFF8;
      v8 = (a4 + 7) & 0xFFF8;
      if ((a1 & 0x40) != 0)
        v8 = a4;
      return (unsigned __int16)(v7 + v8);
    }
  }
  return v6;
}

uint64_t btree_entry_size_check(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unint64_t v4;
  unsigned int v5;
  BOOL v6;
  BOOL v8;
  uint64_t v9;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;

  v4 = *(_QWORD *)(a1 + 400);
  v5 = (v4 >> 9) & 0x3FFF;
  if (v5)
    v6 = v5 == a2;
  else
    v6 = 1;
  if (!v6)
    return 22;
  v8 = !(unsigned __int16)(v4 >> 23) || (unsigned __int16)(v4 >> 23) == a3;
  if (!v8 && (a3 != 65534 && a3 || (v4 & 4) == 0))
    return 22;
  v9 = (v4 >> 27) & 0x1F000;
  if (!v5 && a2 > (unsigned __int16)(((unsigned __int16)(v9 - 160) >> 2) - 72))
    return 22;
  if (a3 == 65534)
    v11 = 0;
  else
    v11 = a3;
  v12 = btree_entry_max_size(v4, v9, v5, (unsigned __int16)(v4 >> 23));
  v13 = (a2 + 7) & 0xFFFFFFF8;
  if ((v4 & 0x40) != 0)
    v13 = a2;
  v14 = (v11 + 7) & 0xFFFFFFF8;
  if ((v4 & 0x40) != 0)
    v14 = v11;
  if (v13 + v14 <= v12)
    return 0;
  else
    return 34;
}

uint64_t btree_node_sanity_check(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unint64_t v9;
  uint64_t v10;
  BOOL v11;
  int v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  char v15;
  unsigned __int8 v16;
  int v17;
  unsigned int v18;
  unsigned __int8 v19;
  __int16 v20;
  unsigned __int16 v21;
  unsigned int v22;
  char v23;
  unsigned int v24;
  unsigned int v25;
  BOOL v26;
  int v27;
  int v28;
  uint64_t v30;
  _BOOL8 is_panic_on_corruption_enabled;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  unsigned __int8 v41;
  unint64_t v42;
  uint64_t v43;
  unsigned __int8 v44;
  unsigned __int8 v45;

  v4 = a1[7];
  v5 = obj_size_phys((uint64_t)a1);
  v6 = v5;
  v7 = *(unsigned __int16 *)(v4 + 32);
  if ((v7 & 4) != 0)
    v8 = 4;
  else
    v8 = 8;
  if (a2)
  {
    v9 = *(_QWORD *)(a2 + 8);
    v10 = (v9 >> 27) & 0x1F000;
    v11 = v5 != (_DWORD)v10;
    v12 = *(unsigned __int16 *)(a2 + 6);
    if (v12 == 61455)
    {
      v13 = v5 != (_DWORD)v10;
    }
    else
    {
      if (v5 == (_DWORD)v10)
        v15 = 1;
      else
        v15 = 2;
      if (*(unsigned __int16 *)(v4 + 34) == v12)
        v13 = v11;
      else
        v13 = v15;
    }
    if (((v9 >> 7) & 1) != ((v7 >> 3) & 1))
      ++v13;
    if (((v9 >> 8) & 1) == ((v7 >> 4) & 1))
      v14 = v13;
    else
      v14 = v13 + 1;
  }
  else
  {
    v14 = 0;
  }
  if (v5 % *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 376) + 36))
    v16 = v14 + 1;
  else
    v16 = v14;
  v17 = obj_type((uint64_t)a1);
  v18 = *(unsigned __int16 *)(v4 + 32);
  if (v17 != 2)
  {
    if ((v18 & 0x10) == 0 && *(_WORD *)(v4 + 24) != 3)
      ++v16;
    if ((v18 & 1) != 0)
      v19 = v16 + 1;
    else
      v19 = v16;
    if ((v18 & 2) == 0)
      goto LABEL_38;
LABEL_36:
    if (*(_WORD *)(v4 + 34))
      ++v19;
    goto LABEL_38;
  }
  if ((v18 & 0x10) == 0 && *(_WORD *)(v4 + 24) != 2)
    ++v16;
  if ((v18 & 1) == 0)
  {
    v19 = v16 + 1;
    if ((v18 & 2) == 0)
      goto LABEL_38;
    goto LABEL_36;
  }
  v38 = v4 + v6;
  v39 = *(_DWORD *)(v38 - 40);
  if (v6 <= 0x10000 && *(_DWORD *)(v38 - 36) == v6)
    v41 = v16;
  else
    v41 = v16 + 1;
  v43 = *(unsigned int *)(v38 - 32);
  v42 = *(unsigned int *)(v38 - 28);
  if (v43 > (unsigned __int16)(((unsigned __int16)(v6 - 160) >> 2) - 72))
    ++v41;
  if (v6 - (v43 + (unint64_t)v8) - 96 > v42)
    v44 = v41;
  else
    v44 = v41 + 1;
  if (((v39 >> 7) & 1) == ((v18 >> 3) & 1))
    v45 = v44;
  else
    v45 = v44 + 1;
  if (((v39 >> 8) & 1) == ((v18 >> 4) & 1))
    v19 = v45;
  else
    v19 = v45 + 1;
  if ((v18 & 2) != 0)
    goto LABEL_36;
LABEL_38:
  if ((v18 & 1) != 0)
    v20 = -96;
  else
    v20 = -56;
  v21 = v20 + v6;
  if (*(_WORD *)(v4 + 40))
    ++v19;
  v22 = *(unsigned __int16 *)(v4 + 42);
  if (v21 < v22)
    ++v19;
  if (((v8 - 1) & v22) != 0)
    ++v19;
  if ((v7 & 4) != 0)
    v23 = 2;
  else
    v23 = 3;
  if (*(_DWORD *)(v4 + 36) > v22 >> v23)
    ++v19;
  v24 = *(unsigned __int16 *)(v4 + 44);
  v25 = (unsigned __int16)(v21 - v22);
  v26 = v25 >= v24;
  v27 = v25 - v24;
  if (!v26)
    ++v19;
  if (v27 >= *(unsigned __int16 *)(v4 + 46))
    v28 = 0;
  else
    v28 = 255;
  if (v28 == v19)
    return 0;
  v30 = *(_QWORD *)(*a1 + 392);
  if (v30)
  {
    is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(v30);
    obj_type((uint64_t)a1);
    obj_subtype((uint64_t)a1);
    obj_oid((uint64_t)a1);
    log_corrupt(is_panic_on_corruption_enabled, "%s:%d: %s BT node sanity check failed for node type %u subtype %u oid %llu with mask 0x%x!\n", v32, v33, v34, v35, v36, v37, (char)"btree_node_sanity_check");
    v30 = *(_QWORD *)(*a1 + 392);
  }
  return nx_corruption_detected_int(v30);
}

uint64_t btree_node_init_phys(uint64_t a1, unsigned int a2, uint64_t a3)
{
  __int16 v3;
  __int16 v4;
  unint64_t v5;
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  _DWORD *v13;

  if (!a3)
    return 22;
  v3 = *(_WORD *)(a3 + 4);
  v4 = v3 & 0x1B;
  *(_WORD *)(a1 + 32) = v4;
  *(_WORD *)(a1 + 34) = *(_WORD *)(a3 + 6);
  v5 = *(_QWORD *)(a3 + 8);
  if (((v5 >> 27) & 0x1F000) != a2)
    return 22;
  v6 = a2 - 56;
  v7 = (v5 >> 9) & 0x3FFF;
  v8 = (HIWORD(v5) & 0x7F) + 8;
  v9 = (unsigned __int16)(v5 >> 23);
  if ((v3 & 2) != 0)
    v10 = v9;
  else
    v10 = v8;
  LOWORD(v11) = 64;
  if (v7 && v10)
  {
    v4 |= 4u;
    *(_WORD *)(a1 + 32) = v4;
    v11 = (4 * (v6 / (v7 + v10 + 4))) & 0xFFFFFFF8;
  }
  v12 = 0;
  if ((v4 & 1) != 0)
    LOWORD(v6) = a2 - 96;
  *(_WORD *)(a1 + 40) = 0;
  *(_WORD *)(a1 + 42) = v11;
  *(_WORD *)(a1 + 44) = 0;
  *(_WORD *)(a1 + 46) = v6 - v11;
  *(_QWORD *)(a1 + 48) = 0xFFFF0000FFFFLL;
  if ((v4 & 1) != 0)
  {
    v12 = 0;
    v13 = (_DWORD *)(a1 + (unsigned __int16)(a2 - 96));
    v13[14] = *(_DWORD *)(a3 + 8) & 0x1FF;
    v13[15] = a2;
    v13[16] = (*(_DWORD *)(a3 + 8) >> 9) & 0x3FFF;
    v13[17] = (unsigned __int16)(*(_QWORD *)(a3 + 8) >> 23);
  }
  return v12;
}

uint64_t btree_node_obj_init(uint64_t a1, uint64_t a2)
{
  return btree_node_init_ext(a1, a2, 1);
}

uint64_t btree_node_reap(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __int16 v5;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  const char *v12;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v23;
  unint64_t v24;

  v5 = *(_WORD *)(a1[7] + 32);
  if ((v5 & 8) != 0)
    return 45;
  v8 = a1[1];
  if (v8)
  {
    v9 = obj_modify((_QWORD *)a1[1], 0, a5);
    if (v9)
    {
      v10 = v9;
      v11 = a1[1];
      if (v11)
        v12 = (const char *)(v11 + 3880);
      else
        v12 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 384) + 208);
      v15 = obj_oid(v8);
      log_err("%s:%d: %s obj_modify(fs %lld) failed: %d\n", "btree_node_reap", 393, v12, v15, v10);
    }
    if ((*(_WORD *)(a1[7] + 32) & 2) != 0)
      goto LABEL_25;
    v14 = obj_oid(v8);
    goto LABEL_13;
  }
  if ((v5 & 2) == 0)
  {
    v14 = 0;
LABEL_13:
    v16 = obj_type_and_flags((uint64_t)a1);
    if (((*(_WORD *)(a1[7] + 36) - 1) & 0x8000) == 0)
    {
      v17 = v16 & 0xFFFF0000 | 3;
      v18 = (unsigned __int16)(*(_WORD *)(a1[7] + 36) - 1);
      do
      {
        v24 = 0;
        if (btree_node_child_id((uint64_t)a1, (unsigned __int16)v18, &v24))
        {
          obj_oid((uint64_t)a1);
          log_err("%s:%d: %s error getting oid for child %d of 0x%llx: %d\n");
        }
        else
        {
          v19 = *a1;
          if (*(unsigned __int16 *)(a1[7] + 34) < 2u)
          {
            v23 = obj_size_phys((uint64_t)a1);
            if (obj_delete_and_free_by_oid(v19, v17, v23, v14, v24, a5))
              log_err("%s:%d: %s error deleting child 0x%llx type 0x%x: %d\n");
          }
          else
          {
            v20 = *(_QWORD *)(v19 + 392);
            v21 = obj_size_phys((uint64_t)a1);
            if (nx_reaper_add_sub_object(v20, v17, v21, v14, v24, a5, 0))
              log_err("%s:%d: %s error adding child 0x%llx type 0x%x to reap list: %d\n");
          }
        }
      }
      while (v18-- > 0);
    }
  }
LABEL_25:
  obj_delete_and_free(a1, a5);
  return 0;
}

uint64_t btree_node_get(_QWORD *a1, _QWORD *a2, uint64_t a3, int a4, __int16 a5, uint64_t a6, uint64_t *a7)
{
  unint64_t v14;
  size_t v15;
  uint64_t v16;
  char *v17;
  int v18;
  unint64_t v19;
  size_t v20;
  int v21;
  int v22;
  __int128 *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  char v28;
  __int128 v30;
  uint64_t v31[2];

  v31[1] = *MEMORY[0x1E0C80C00];
  v14 = a1[50];
  if ((v14 & 0x40000000000000) != 0)
    v15 = 96;
  else
    v15 = (HIWORD(v14) & 0x7F) + 32;
  MEMORY[0x1E0C80A78]();
  v17 = (char *)&v31[-2] - v16;
  bzero((char *)&v31[-2] - v16, v15);
  v31[0] = 0;
  v30 = btree_node_desc;
  v18 = obj_flags((uint64_t)a1) & 0xFC00;
  *(_WORD *)v17 = 25987;
  *((_WORD *)v17 + 1) = v15;
  *(_OWORD *)(v17 + 8) = *((_OWORD *)a1 + 25);
  *((_QWORD *)v17 + 3) = a1[52];
  v19 = a1[50];
  if ((v19 & 0x80) != 0)
  {
    if ((v19 & 0x40000000000000) != 0)
      v20 = 64;
    else
      v20 = HIWORD(v19) & 0x7F;
    memcpy(v17 + 32, a2 + 1, v20);
  }
  *((_WORD *)v17 + 2) = 0;
  *((_WORD *)v17 + 3) = a5;
  DWORD2(v30) = obj_size_phys((uint64_t)a1);
  v21 = obj_type_and_flags((uint64_t)a1);
  LODWORD(v30) = v21 & 0xFFFF0000 | 3;
  DWORD1(v30) = obj_subtype((uint64_t)a1);
  if ((v21 & 0x40000000) != 0)
    v22 = 3;
  else
    v22 = 1;
  if ((a4 & 0x40) != 0)
    v23 = 0;
  else
    v23 = &v30;
  v24 = obj_get(*a1, v18 | (a4 << 31 >> 31) & v22 | (2 * (a4 & 2)) | (8 * a4) & 0x20 | a4 & 0x180 | v21 & 0xFFFF0000, *a2, v23, v17, a1[1], a3, a6, v31);
  if ((_DWORD)v24)
  {
    v25 = v24;
    v26 = 0;
  }
  else
  {
    v26 = v31[0];
    if ((a4 & 0x104) == 4 && (*(_BYTE *)(v31[0] + 16) & 0x10) != 0)
    {
      if ((a4 & 1) != 0)
        v27 = 2;
      else
        v27 = 1;
      if ((a4 & 2) != 0)
        v28 = v27;
      else
        v28 = 0;
      btree_node_release(v31[0], v28);
      v26 = 0;
      v25 = 2;
    }
    else
    {
      v25 = 0;
    }
  }
  *a7 = v26;
  return v25;
}

uint64_t btree_node_release(uint64_t a1, char a2)
{
  int v3;

  v3 = a2 & 3;
  if (v3)
    obj_unlock(a1, v3);
  return obj_release(a1);
}

uint64_t btree_node_toc_entry_size(uint64_t a1)
{
  if ((*(_WORD *)(*(_QWORD *)(a1 + 56) + 32) & 4) != 0)
    return 4;
  else
    return 8;
}

uint64_t btree_node_toc_required_capacity(uint64_t a1, int a2)
{
  _WORD *v2;
  __int16 v3;
  unsigned int v4;
  unint64_t v5;
  unsigned int v6;
  BOOL v7;
  char v8;
  unint64_t v9;
  unint64_t v10;
  unsigned __int16 v11;

  v2 = *(_WORD **)(a1 + 56);
  v3 = v2[16];
  if ((v3 & 4) != 0)
  {
    v5 = *(_QWORD *)(a1 + 400);
    if ((v5 & 4) != 0)
    {
      if ((v3 & 2) != 0)
        v9 = v5 >> 23;
      else
        LODWORD(v9) = (HIWORD(v5) & 0x7F) + 8;
      v10 = (((v5 >> 27) & 0x1F000) - 56) / (((v5 >> 9) & 0x3FFF) + (unsigned __int16)v9 + 4);
      v11 = v2[18] + a2;
      if ((v10 & 0xFFFE) >= v11)
        LOWORD(v4) = v10 & 0xFFFE;
      else
        LOWORD(v4) = (v11 + 7) & 0xFFF8;
    }
    else
    {
      v6 = (unsigned __int16)v2[21];
      v7 = (v3 & 4) == 0;
      v8 = 2;
      if (v7)
        v8 = 3;
      return (unsigned __int16)(v6 >> v8);
    }
  }
  else
  {
    v4 = (a2 + *((_DWORD *)v2 + 9) + 7) & 0xFFFFFFF8;
    if (!v4)
      LOWORD(v4) = 8;
  }
  return (unsigned __int16)v4;
}

uint64_t btree_node_key_off(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  unsigned __int16 *v3;
  unsigned __int16 *v4;
  unsigned __int16 *v5;

  v2 = *(_QWORD *)(a1 + 376);
  v3 = (unsigned __int16 *)(v2 + 4 * a2);
  v4 = (unsigned __int16 *)(v2 + 8 * a2);
  if ((*(_WORD *)(*(_QWORD *)(a1 + 56) + 32) & 4) != 0)
    v5 = v3;
  else
    v5 = v4;
  return *v5;
}

uint64_t btree_node_key_len(uint64_t a1, unsigned int a2)
{
  if ((*(_WORD *)(*(_QWORD *)(a1 + 56) + 32) & 4) != 0)
    return (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  else
    return *(unsigned __int16 *)(*(_QWORD *)(a1 + 376) + 8 * a2 + 2);
}

uint64_t btree_node_val_off(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int16 *v5;

  v2 = *(_QWORD *)(a1 + 376);
  v3 = v2 + 4 * a2 + 2;
  v4 = v2 + 8 * a2 + 4;
  if ((*(_WORD *)(*(_QWORD *)(a1 + 56) + 32) & 4) != 0)
    v5 = (unsigned __int16 *)v3;
  else
    v5 = (unsigned __int16 *)v4;
  return *v5;
}

uint64_t btree_node_val_len(uint64_t a1, unsigned int a2)
{
  __int16 v2;
  uint64_t v3;
  unsigned __int16 *v4;
  uint64_t v5;
  int v6;

  v2 = *(_WORD *)(*(_QWORD *)(a1 + 56) + 32);
  v3 = *(_QWORD *)(a1 + 376);
  if ((v2 & 4) != 0)
  {
    v4 = (unsigned __int16 *)(v3 + 4 * a2 + 2);
    v5 = *(_QWORD *)(a1 + 400) >> 23;
  }
  else
  {
    v5 = v3 + 8 * a2;
    v4 = (unsigned __int16 *)(v5 + 4);
    LOWORD(v5) = *(_WORD *)(v5 + 6);
  }
  v6 = *v4;
  if (v6 == 0xFFFF)
  {
    LOWORD(v5) = 0;
  }
  else if (v6 == 65534)
  {
    LOWORD(v5) = -2;
  }
  else if ((v2 & 2) == 0)
  {
    LOWORD(v5) = (*(_WORD *)(a1 + 406) & 0x7F) + 8;
  }
  return (unsigned __int16)v5;
}

uint64_t btree_node_key_ptr(uint64_t a1, unsigned int a2, _QWORD *a3, _WORD *a4)
{
  uint64_t v5;
  __int16 v8;
  uint64_t v9;
  unsigned __int16 *v10;
  uint64_t v11;
  int v12;
  uint64_t result;

  if (!a1)
    return 22;
  v5 = *(_QWORD *)(a1 + 56);
  if (*(_DWORD *)(v5 + 36) <= a2)
    return 22;
  v8 = *(_WORD *)(v5 + 32);
  v9 = *(_QWORD *)(a1 + 376);
  v10 = (unsigned __int16 *)(v9 + 4 * a2);
  if ((v8 & 4) == 0)
    v10 = (unsigned __int16 *)(v9 + 8 * a2);
  v11 = *v10;
  if ((v8 & 4) != 0)
    v12 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  else
    v12 = *(unsigned __int16 *)(v9 + 8 * a2 + 2);
  result = btree_node_key_range_validate(a1, *v10, v12);
  if (!(_DWORD)result)
  {
    *a3 = *(_QWORD *)(a1 + 384) + v11;
    result = 0;
    if (a4)
      *a4 = v12;
  }
  return result;
}

uint64_t btree_node_key_range_validate(uint64_t a1, unsigned int a2, int a3)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  int v6;

  v3 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 56) + 44);
  v4 = v3 >= a2;
  v5 = v3 - a2;
  if (v5 == 0 || !v4)
    return nx_corruption_detected_int(*(_QWORD *)(*(_QWORD *)a1 + 392));
  v6 = (a3 + 7) & 0x1FFF8;
  if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
    v6 = a3;
  if (v6 <= v5)
    return 0;
  else
    return nx_corruption_detected_int(*(_QWORD *)(*(_QWORD *)a1 + 392));
}

uint64_t btree_node_val_ptr(_QWORD *a1, unsigned int a2, _QWORD *a3, __int16 *a4)
{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int16 *v11;
  uint64_t v12;
  unsigned int v13;
  __int16 v14;
  uint64_t result;

  v4 = a1[7];
  if (*(_DWORD *)(v4 + 36) <= (signed int)a2)
    return 22;
  v8 = a1[47];
  v9 = v8 + 4 * a2 + 2;
  v10 = v8 + 8 * a2 + 4;
  if ((*(_WORD *)(v4 + 32) & 4) != 0)
    v11 = (unsigned __int16 *)v9;
  else
    v11 = (unsigned __int16 *)v10;
  v12 = *v11;
  v13 = btree_node_val_len((uint64_t)a1, a2);
  v14 = v13;
  result = btree_node_val_range_validate((uint64_t)a1, v12, v13);
  if (!(_DWORD)result)
  {
    if (v12 >= 0xFFFE)
    {
      *a3 = 0;
      if (!a4)
        return 0;
      if ((_DWORD)v12 == 0xFFFF)
        v14 = 0;
      else
        v14 = -2;
    }
    else
    {
      *a3 = a1[49] - v12;
      if (!a4)
        return 0;
    }
    result = 0;
    *a4 = v14;
  }
  return result;
}

uint64_t btree_node_val_range_validate(uint64_t a1, unsigned int a2, unsigned int a3)
{
  __int16 v6;
  uint64_t v7;
  __int16 v8;
  unsigned int v9;

  if (a2 >= 0xFFFE)
  {
    if ((*(_BYTE *)(a1 + 400) & 4) == 0 || a3 && a3 != 65534)
      return nx_corruption_detected_int(*(_QWORD *)(*(_QWORD *)a1 + 392));
  }
  else
  {
    if (!a3 || a3 == 65534)
      return nx_corruption_detected_int(*(_QWORD *)(*(_QWORD *)a1 + 392));
    v6 = obj_size_phys(a1);
    v7 = *(_QWORD *)(a1 + 56);
    v8 = (*(_BYTE *)(v7 + 32) & 1) != 0 ? -96 : -56;
    if (a2 > (unsigned __int16)(v6 - *(_WORD *)(v7 + 42) + v8 - (*(_WORD *)(v7 + 46) + *(_WORD *)(v7 + 44))))
      return nx_corruption_detected_int(*(_QWORD *)(*(_QWORD *)a1 + 392));
    v9 = (a3 + 7) & 0x1FFF8;
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
      v9 = a3;
    if (v9 > a2)
      return nx_corruption_detected_int(*(_QWORD *)(*(_QWORD *)a1 + 392));
  }
  return 0;
}

uint64_t btree_node_child_val(uint64_t a1, unsigned int a2, _QWORD *a3)
{
  uint64_t result;
  _QWORD *v6;
  uint64_t v7;
  unsigned __int16 v8;
  _QWORD *v9;

  if ((*(_WORD *)(*(_QWORD *)(a1 + 56) + 32) & 2) != 0)
    return 22;
  v9 = 0;
  v8 = 0;
  result = btree_node_val_ptr((_QWORD *)a1, a2, &v9, (__int16 *)&v8);
  if ((_DWORD)result)
    return result;
  if ((*(_WORD *)(a1 + 406) & 0x7F) + 8 == v8)
  {
    result = 0;
    if (!a3)
      return result;
  }
  else
  {
    result = nx_corruption_detected_int(*(_QWORD *)(*(_QWORD *)a1 + 392));
    if (!a3)
      return result;
  }
  if (!(_DWORD)result)
  {
    v6 = v9;
    v7 = *v9;
    *a3 = *v9;
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 56) + 32) & 8) != 0)
    {
      *a3 = *(_QWORD *)(a1 + 408) + v7;
      memcpy(a3 + 1, v6 + 1, v8 - 8);
    }
    return 0;
  }
  return result;
}

uint64_t btree_node_child_id(uint64_t a1, unsigned int a2, _QWORD *a3)
{
  uint64_t v6;
  _QWORD *v7;
  size_t v8;
  uint64_t result;
  _QWORD v10[2];

  v10[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78]();
  v7 = (_QWORD *)((char *)v10 - v6);
  bzero((char *)v10 - v6, v8);
  result = btree_node_child_val(a1, a2, v7);
  if (!(_DWORD)result)
    *a3 = *v7;
  return result;
}

uint64_t bt_insert(_QWORD *a1, uint64_t a2, unint64_t *a3, int a4, _QWORD *a5, unsigned int a6, uint64_t a7)
{
  size_t v10;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  size_t v17;
  unsigned __int16 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  int v23;
  int v24;
  char v25;
  uint64_t v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  int v31;
  uint64_t v33;
  int v34;
  unsigned int v35;
  _BOOL4 v36;
  uint64_t v37;
  uint64_t (*v38)(uint64_t, unint64_t *, _QWORD);
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  BOOL *v45;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  unsigned int v49;
  __int16 v50;
  _BOOL4 v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  BOOL v57;
  BOOL v58;
  __int128 *v60;
  uint64_t v61;
  __int16 v62;
  _QWORD *v63;
  _QWORD *v64;
  uint64_t i;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  unsigned int v71;
  __int16 v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  int v77;
  int v78;
  _BOOL4 v79;
  int v80;
  uint64_t v81;
  int v82;
  unsigned int v83;
  int v84;
  char v85;
  uint64_t v86;
  unsigned int v87;
  uint64_t v88;
  unsigned int v89;
  unsigned int v90;
  int v91;
  int v92;
  unsigned int v93;
  unsigned __int16 v94;
  unint64_t v95;
  int v96;
  unsigned int v97;
  unsigned int v98;
  uint64_t v99;
  unsigned int v100;
  uint64_t v101;
  BOOL v102;
  uint64_t v103;
  BOOL has_room;
  unsigned int v105;
  unsigned int v106;
  unsigned int v107;
  unsigned int v108;
  unsigned int v109;
  unsigned int v110;
  __int16 v111;
  __int16 v112;
  unsigned __int16 v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  int v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  unint64_t *v121;
  uint64_t v122;
  BOOL v123;
  int v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  int v129;
  uint64_t v130;
  int v131;
  uint64_t v132;
  int v133;
  uint64_t v134;
  uint64_t v135;
  int v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t inserted;
  uint64_t v142;
  uint64_t v143;
  const char *v144;
  _QWORD *v145;
  uint64_t v146;
  int v147;
  uint64_t v148;
  uint64_t v149;
  const char *v150;
  uint64_t v151;
  uint64_t v152;
  int v153;
  uint64_t v154;
  int v155;
  uint64_t v156;
  unsigned int v157;
  BOOL v158;
  int v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  const char *v163;
  unint64_t *v164;
  unint64_t v165;
  uint64_t v166;
  uint64_t v167;
  const char *v168;
  _WORD *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  int v173;
  uint64_t v174;
  _QWORD *v175;
  size_t v176;
  uint64_t v177;
  int v178;
  int v179;
  BOOL v180;
  uint64_t v181;
  uint64_t v182;
  const char *v183;
  int v184;
  int v185;
  uint64_t v186;
  const char *v187;
  uint64_t v188;
  const char *v189;
  unint64_t *v190;
  uint64_t v191;
  uint64_t v192;
  int v193;
  int v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  char v200;
  unsigned __int16 v201;
  BOOL *v202;
  _WORD *v203;
  BOOL *v204;
  _WORD *v205;
  uint64_t v206;
  uint64_t v207;
  _QWORD *v208;
  unsigned int v209;
  __int128 *v210;
  __int128 *v211;
  int v212;
  _QWORD *v213;
  uint64_t v214;
  _QWORD *v215;
  uint64_t v216;
  int v217;
  uint64_t v218;
  _QWORD *v219;
  BOOL *v220;
  unsigned __int16 *v221;
  _BOOL4 v222;
  _BOOL4 v223;
  char *v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  unsigned __int16 v228;
  unsigned __int16 v229;
  unsigned __int16 v230;
  int v231;
  unint64_t *v232;
  _QWORD *v233;
  _QWORD *v234;
  __int128 v235;
  __int128 v236;
  __int128 v237;
  uint64_t v238;

  LODWORD(v10) = a4;
  v238 = *MEMORY[0x1E0C80C00];
  v14 = a1[50];
  MEMORY[0x1E0C80A78]();
  v16 = (BOOL **)((char *)&v202 - v15);
  bzero((char *)&v202 - v15, v17);
  v236 = 0u;
  v237 = 0u;
  v235 = 0u;
  v233 = 0;
  v234 = 0;
  v232 = 0;
  v231 = 0;
  v227 = 0;
  if (!a1[52])
    return 22;
  v225 = a2;
  v229 = v10;
  if (a6 == 65534)
    v18 = 0;
  else
    v18 = a6;
  v228 = v18;
  v19 = btree_entry_size_check((uint64_t)a1, v10, a6);
  if ((_DWORD)v19)
  {
    v20 = v19;
    v21 = a1[1];
    if (v21)
    {
      v22 = (const char *)(v21 + 3880);
      if ((v14 & 0x40) != 0)
        v23 = v10;
      else
        v23 = (v10 + 7) & 0xFFFFFFF8;
      if ((v14 & 0x40) != 0)
        v24 = v18;
      else
        v24 = (v18 + 7) & 0x1FFF8;
      v25 = v14;
      v26 = (v14 >> 27) & 0x1F000;
      v27 = (unsigned __int16)(v14 >> 23);
      v28 = (v14 >> 9) & 0x3FFF;
      if (v28)
        v29 = (v14 >> 9) & 0x3FFF;
      else
        v29 = ((unsigned __int16)((v26 - 160) & 0xFFE0) >> 2) - 72;
    }
    else
    {
      v22 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 384) + 208);
      if ((v14 & 0x40) != 0)
        v23 = v10;
      else
        v23 = (v10 + 7) & 0xFFFFFFF8;
      if ((v14 & 0x40) != 0)
        v24 = v18;
      else
        v24 = (v18 + 7) & 0x1FFF8;
      v25 = v14;
      v26 = (v14 >> 27) & 0x1F000;
      v27 = (unsigned __int16)(v14 >> 23);
      v28 = (v14 >> 9) & 0x3FFF;
      if (v28)
        v29 = (v14 >> 9) & 0x3FFF;
      else
        v29 = ((unsigned __int16)((v26 - 160) & 0xFFE0) >> 2) - 72;
    }
    v31 = btree_entry_max_size(v25, v26, v28, v27);
    log_err("%s:%d: %s request to insert entry %d (%d) %d (%d) = (%d), max size is %d key %d, error %d\n", "bt_insert", 3383, v22, v10, v23, v18, v24, v23 + v24, v31, v29, v20);
    return v20;
  }
  obj_lock((uint64_t)a1, 2);
  v30 = obj_modify(a1, (*((_DWORD *)a1 + 100) >> 3) & 2, a7);
  if ((_DWORD)v30)
  {
    v20 = v30;
    obj_unlock((uint64_t)a1, 2);
    return v20;
  }
  v230 = 0;
  *(_QWORD *)&v235 = a1;
  obj_retain((char *)a1);
  v33 = a1[49];
  v34 = *(_DWORD *)(v33 + 16);
  v35 = (unsigned __int16)v34;
  v36 = *(_DWORD *)(v33 + 20) >= v18;
  if ((unsigned __int16)v34 < (unsigned __int16)v10)
    v34 = v10;
  v212 = v34;
  if (v35 < (unsigned __int16)v10)
    v36 = 0;
  v222 = v36;
  v37 = (uint64_t)a1;
  if (a1[54])
  {
    v38 = (uint64_t (*)(uint64_t, unint64_t *, _QWORD))a1[53];
    v37 = (uint64_t)a1;
    if (v38)
    {
      v39 = a1[1];
      if (!v39)
        v39 = *(_QWORD *)(*a1 + 392);
      v40 = v38(v39, a3, (unsigned __int16)v10);
      v37 = (uint64_t)a1;
      if (v40)
      {
        v236 = v235;
        *(_QWORD *)&v235 = 0;
        v41 = a1[54];
        *v16 = v41;
        if (v41 != obj_oid((uint64_t)a1)
          && !btree_node_get(a1, v16, v225, (a7 != 0) | (((*(unsigned __int16 *)(a1[7] + 32) >> 3) & 1) << 6) | 6u, 0, a7, (uint64_t *)&v235))
        {
          v42 = v235;
          if ((*(_WORD *)(*(_QWORD *)(v235 + 56) + 32) & 2) != 0 && a1[54] == *(_QWORD *)(v235 + 112))
          {
            v43 = bt_search_node_insert(v235, a3, (unsigned __int16)v10, (_WORD *)&v235 + 4, (BOOL *)((unint64_t)&v235 | 0xA));
            v42 = v235;
            if (!v43)
            {
              if (WORD4(v235))
              {
                if (!(BYTE10(v235)
                     ? ((uint64_t (*)(_QWORD))btree_node_entry_update)(v235)
                     : ((uint64_t (*)(_QWORD))btree_node_insert_internal)(v235)))
                {
                  v216 = 0;
                  v47 = 0;
                  v20 = 0;
                  v217 = 0;
                  v223 = 0;
                  goto LABEL_340;
                }
              }
            }
          }
          obj_unlock(v42, 2);
          obj_release(v42);
        }
        v235 = v236;
        *(_QWORD *)&v236 = 0;
        v37 = v235;
      }
    }
  }
  v45 = (BOOL *)((unint64_t)&v235 | 0xA);
  if ((*(_WORD *)(*(_QWORD *)(v37 + 56) + 32) & 2) != 0)
    v46 = bt_search_node_insert(v37, a3, (unsigned __int16)v10, (_WORD *)&v235 + 4, v45);
  else
    v46 = bt_search_node(v37, a3, (unsigned __int16)v10, (_WORD *)&v235 + 4, v45);
  v20 = v46;
  if ((_DWORD)v46)
    goto LABEL_55;
  v220 = (BOOL *)((unint64_t)&v235 | 0xA);
  v221 = (unsigned __int16 *)&v235 + 4;
  v48 = *(_QWORD *)(v235 + 56);
  v49 = *(_DWORD *)(v48 + 36);
  v50 = *(_WORD *)(v48 + 32);
  v51 = (__PAIR64__(v49, v50 & 2) - 1) >> 32 == WORD4(v235);
  v52 = WORD4(v235) | BYTE10(v235) | v50 & 2;
  if (v52)
  {
    v47 = 0;
    if ((v50 & 2) == 0)
    {
      v53 = 0;
      goto LABEL_60;
    }
    v217 = 0;
    v223 = 0;
    v216 = 0;
LABEL_294:
    v135 = v237;
    if ((_QWORD)v237)
    {
      v136 = v222;
      if ((_QWORD *)v237 != a1)
        v136 = 1;
      if (v136 == 1 && (_QWORD *)v237 != v47 && (_QWORD)v237 != v216)
      {
        obj_unlock(v237, 2);
        obj_release(v135);
      }
      *(_QWORD *)&v237 = 0;
    }
    v137 = v225;
    if (v51)
    {
      v138 = a1[54];
      v139 = *(_QWORD *)(v235 + 112);
      if (v138 != v139)
      {
        v140 = a1[50];
        if (v138)
        {
          if ((v140 & 0x10) == 0)
            panic("btree rightmost leaf mismatch! (expected %lld found %lld)\n", *(_QWORD *)(v235 + 112), v138);
          panic("btree rightmost leaf field is set for physical tree!\n");
        }
        if ((v140 & 0x10) == 0)
          a1[54] = v139;
      }
    }
    v10 = v229;
    if (BYTE10(v235))
      inserted = btree_node_entry_update(v235, WORD4(v235), a3, v229, a5, (unsigned __int16)a6, a7);
    else
      inserted = btree_node_insert_internal(v235, WORD4(v235), a3, v229, a5, (unsigned __int16)a6, a7);
    v20 = inserted;
    if ((_DWORD)inserted != 28)
      goto LABEL_335;
    v142 = bt_shift_or_split(a1, (_QWORD *)v236, WORD4(v236), (_QWORD *)v235, WORD4(v235), a3, v10, 1, (__int16 *)&v229, (__int16 *)&v228, 0, v137, a7, (uint64_t *)&v234);
    if ((_DWORD)v142)
    {
      v20 = v142;
      v143 = a1[1];
      if (v143)
        v144 = (const char *)(v143 + 3880);
      else
        v144 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 384) + 208);
      log_err("%s:%d: %s bt_shift_or_split failed with error: %d\n", "bt_insert", 3866, v144, v142);
      goto LABEL_335;
    }
    v145 = v234;
    if (!v234)
    {
      v145 = (_QWORD *)v235;
      goto LABEL_330;
    }
    if ((_QWORD)v236)
    {
      ++WORD4(v236);
      v146 = v235;
      v147 = v222;
      if ((_QWORD *)v235 != a1)
        v147 = 1;
      if ((_QWORD)v235 && v147 && (_QWORD *)v235 != v47 && (_QWORD)v235 != v216)
      {
        v148 = (uint64_t)v234;
        obj_unlock(v235, 2);
        obj_release(v146);
        v145 = (_QWORD *)v148;
      }
      v234 = 0;
      *(_QWORD *)&v235 = v145;
LABEL_330:
      v20 = btree_node_insert(v145, a3, v10, a5, (unsigned __int16)a6, a7, v221, v220);
      if (!(_DWORD)v20)
        goto LABEL_335;
      goto LABEL_331;
    }
    v169 = (_WORD *)&v236 + 4;
    v170 = v235;
    *(_QWORD *)&v236 = v235;
    if (*(_DWORD *)(v234[7] + 36))
    {
      v224 = (char *)&v236 + 8;
      v171 = (uint64_t)v234;
      v172 = btree_node_key_ptr((uint64_t)v234, 0, &v232, &v230);
      if ((_DWORD)v172)
      {
        v20 = v172;
        v234 = 0;
        *(_QWORD *)&v235 = v171;
        goto LABEL_331;
      }
      v170 = v236;
      v190 = v232;
      v191 = v230;
      v169 = v224;
    }
    else
    {
      v171 = (uint64_t)v234;
      v190 = a3;
      v191 = v10;
    }
    v20 = bt_search_node(v170, v190, v191, v169, (BOOL *)&v236 + 10);
    v145 = (_QWORD *)v171;
    v234 = 0;
    *(_QWORD *)&v235 = v171;
    if (!(_DWORD)v20)
      goto LABEL_330;
LABEL_331:
    v149 = a1[1];
    if (v149)
      v150 = (const char *)(v149 + 3880);
    else
      v150 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 384) + 208);
    log_err("%s:%d: %s bt_shift_or_split failed with error: %d\n", "bt_insert", 3903, v150, v20);
LABEL_335:
    if (!(_DWORD)v20 && !WORD4(v235) && (_QWORD)v236)
    {
      v151 = btree_node_key_ptr(v236, WORD4(v236), &v232, &v230);
      if ((_DWORD)v151)
      {
        v20 = v151;
      }
      else
      {
        v160 = a1[1];
        if (!v160)
          v160 = *(_QWORD *)(*a1 + 392);
        v20 = ((uint64_t (*)(uint64_t, unint64_t *, size_t, unint64_t *, _QWORD, int *))a1[52])(v160, a3, v10, v232, v230, &v231);
        if (!(_DWORD)v20)
        {
          if (v231)
          {
            v161 = btree_node_entry_update(v236, WORD4(v236), a3, v10, 0, 0, a7);
            v20 = v161;
            if ((_DWORD)v161)
            {
              v162 = a1[1];
              if (v162)
                v163 = (const char *)(v162 + 3880);
              else
                v163 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 384) + 208);
              log_err("%s:%d: %s btree_node_key_update failed: %d\n", "bt_insert", 3917, v163, v161);
            }
          }
        }
      }
    }
LABEL_340:
    v152 = v236;
    if ((_QWORD)v236)
    {
      v153 = v222;
      if ((_QWORD *)v236 != a1)
        v153 = 1;
      if (v153 == 1 && (_QWORD *)v236 != v47 && (_QWORD)v236 != v216)
      {
        obj_unlock(v236, 2);
        obj_release(v152);
      }
      *(_QWORD *)&v236 = 0;
    }
    v154 = v235;
    if ((_QWORD)v235)
    {
      v155 = v222;
      if ((_QWORD *)v235 != a1)
        v155 = 1;
      if (v155 == 1 && (_QWORD *)v235 != v47 && (_QWORD)v235 != v216)
      {
        obj_unlock(v235, 2);
        obj_release(v154);
      }
      *(_QWORD *)&v235 = 0;
    }
    if ((_DWORD)v20)
      goto LABEL_444;
    v156 = a1[49];
    v157 = *(_DWORD *)(v156 + 16);
    v158 = v157 >= (unsigned __int16)v10;
    v159 = v157 < (unsigned __int16)v10;
    if (!v158)
      *(_DWORD *)(v156 + 16) = (unsigned __int16)v10;
    if (*(_DWORD *)(v156 + 20) < v228)
    {
      *(_DWORD *)(v156 + 20) = v228;
      v159 = 1;
    }
    if (BYTE10(v235))
    {
      if ((((a1[50] & 0x80) == 0) & ~v159) != 0)
        goto LABEL_374;
    }
    else
    {
      v164 = (unint64_t *)(v156 + 24);
      do
        v165 = __ldxr(v164);
      while (__stxr(v165 + 1, v164));
    }
    obj_dirty((uint64_t)a1, a7, 0);
LABEL_374:
    if (!v223 || WORD4(v235) != 0)
    {
      v20 = 0;
      goto LABEL_444;
    }
    if (v47)
    {
      v166 = btree_node_entry_update((uint64_t)v47, (unsigned __int16)v217, a3, (unsigned __int16)v10, 0, 0, a7);
      v20 = v166;
      if ((_DWORD)v166)
      {
        v167 = a1[1];
        if (v167)
          v168 = (const char *)(v167 + 3880);
        else
          v168 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 384) + 208);
        log_err("%s:%d: %s btree_node_key_update failed: %d\n", "bt_insert", 3957, v168, v166);
      }
      v173 = v222;
      if (v47 != a1)
        v173 = 1;
      if (v47 != (_QWORD *)v237 && v47 != (_QWORD *)v236 && v173)
      {
        obj_unlock((uint64_t)v47, 2);
        obj_release(v47);
      }
    }
    else
    {
      v20 = 0;
    }
    v174 = (uint64_t)v233;
    v175 = v233 + 7;
    if (*(unsigned __int16 *)(v233[7] + 34) < 2u)
    {
LABEL_437:
      v194 = v222;
      if ((_QWORD *)v174 != a1)
        v194 = 1;
      if (v174 != (_QWORD)v237 && v174 != (_QWORD)v236 && v194)
      {
        obj_unlock(v174, 2);
        obj_release(v174);
      }
      v47 = 0;
      v233 = 0;
      goto LABEL_444;
    }
    v176 = v229;
    while (1)
    {
      WORD2(v226) = 0;
      LOBYTE(v226) = 0;
      v177 = bt_search_node(v174, a3, v176, (_WORD *)&v226 + 2, (BOOL *)&v226);
      if ((_DWORD)v177)
      {
        v20 = v177;
        goto LABEL_55;
      }
      v178 = v226;
      v179 = WORD2(v226);
      if ((_BYTE)v226)
        v180 = 0;
      else
        v180 = WORD2(v226) == 0;
      if (!v180)
      {
        v188 = a1[1];
        if (v188)
          v189 = (const char *)(v188 + 3880);
        else
          v189 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 384) + 208);
        v192 = obj_oid(v174);
        v193 = obj_subtype(v174);
        log_err("%s:%d: %s minkey update traversal unexpectedly found the key (%d) or a non-zero index (%d); oid %llu subtype 0x%x level %d\n",
          "bt_insert",
          3975,
          v189,
          v178,
          v179,
          v192,
          v193,
          *(unsigned __int16 *)(*v175 + 34));
LABEL_436:
        v20 = 0;
        goto LABEL_437;
      }
      v181 = btree_node_entry_update(v174, 0, a3, v176, 0, 0, a7);
      v20 = v181;
      if ((_DWORD)v181)
      {
        v182 = a1[1];
        if (v182)
          v183 = (const char *)(v182 + 3880);
        else
          v183 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 384) + 208);
        log_err("%s:%d: %s btree_node_key_update failed: %d\n", "bt_insert", 3980, v183, v181);
      }
      v184 = *(unsigned __int16 *)(*v175 + 34);
      if (v184 == 2)
        goto LABEL_437;
      v20 = btree_node_child_val(v174, 0, v16);
      v233 = 0;
      if (!(_DWORD)v20)
        v20 = btree_node_get(a1, v16, v225, 3, (unsigned __int16)v184 - 1, a7, (uint64_t *)&v233);
      v185 = v222;
      if ((_QWORD *)v174 != a1)
        v185 = 1;
      if (v174 != (_QWORD)v237 && v174 != (_QWORD)v236 && v185)
      {
        obj_unlock(v174, 2);
        obj_release(v174);
      }
      v174 = (uint64_t)v233;
      if ((_DWORD)v20)
        break;
      v175 = v233 + 7;
      if (*(unsigned __int16 *)(v233[7] + 34) <= 1u)
        goto LABEL_436;
    }
    if (v233)
      goto LABEL_437;
LABEL_55:
    v47 = 0;
    goto LABEL_444;
  }
  v233 = (_QWORD *)v235;
  v53 = v235;
LABEL_60:
  v217 = 0;
  v47 = 0;
  v223 = v52 == 0;
  v211 = &v237;
  v210 = &v236;
  v205 = (_WORD *)&v236 + 4;
  v203 = (_WORD *)&v237 + 4;
  v204 = (BOOL *)&v236 + 10;
  v202 = (BOOL *)&v237 + 10;
  v213 = (_QWORD *)v53;
  v214 = v53;
  v215 = (_QWORD *)v53;
  v219 = (_QWORD *)v53;
  v216 = v53;
  v54 = v53;
  while (2)
  {
    v55 = v237;
    v56 = v222;
    if ((_QWORD *)v237 != a1)
      v56 = 1;
    if ((_QWORD)v237)
      v57 = v56 == 0;
    else
      v57 = 1;
    v58 = v57 || (_QWORD)v237 == (_QWORD)v47;
    v218 = v54;
    if (!v58 && (_QWORD)v237 != v54)
    {
      obj_unlock(v237, 2);
      obj_release(v55);
    }
    v60 = v210;
    *v211 = *v210;
    *v60 = v235;
    *(_QWORD *)&v235 = 0;
    v61 = btree_node_child_val(v236, WORD4(v236), v16);
    if ((_DWORD)v61)
    {
LABEL_292:
      v20 = v61;
      goto LABEL_444;
    }
    v62 = *(_WORD *)(*(_QWORD *)(v236 + 56) + 34) - 1;
    v63 = a1;
    v64 = v16;
    for (i = v225; ; i = v76)
    {
      v61 = btree_node_get(v63, v64, i, 3, v62, a7, (uint64_t *)&v235);
      if ((_DWORD)v61)
        goto LABEL_292;
      v66 = v235;
      if ((a1[50] & 0x10) != 0 && *(_QWORD *)(v235 + 112) != *v16)
      {
        btree_node_child_id_update(v236, WORD4(v236), (uint64_t *)(v235 + 112), a7);
        v66 = v235;
      }
      if ((*(_WORD *)(*(_QWORD *)(v66 + 56) + 32) & 2) != 0)
        v67 = bt_search_node_insert(v66, a3, v229, v221, v220);
      else
        v67 = bt_search_node(v66, a3, v229, v221, v220);
      v20 = v67;
      if ((_DWORD)v67)
        goto LABEL_444;
      v68 = v235;
      if (!v51)
      {
        LODWORD(v224) = 0;
        v70 = *(_QWORD *)(v235 + 56);
        v69 = WORD4(v235);
        if ((*(_WORD *)(v70 + 32) & 2) == 0)
          goto LABEL_119;
        goto LABEL_93;
      }
      v69 = WORD4(v235);
      v70 = *(_QWORD *)(v235 + 56);
      v71 = *(unsigned __int16 *)(v70 + 32);
      if (((v71 >> 1) & 1) + *(_DWORD *)(v70 + 36) - 1 == WORD4(v235))
        break;
      LODWORD(v224) = 0;
      if ((v71 & 2) == 0)
        goto LABEL_119;
LABEL_93:
      if (*(_DWORD *)(v70 + 36) != v69
        || (v72 = WORD4(v236), v73 = v236, *(_DWORD *)(*(_QWORD *)(v236 + 56) + 36) - 1 <= WORD4(v236))
        || btree_node_has_room(v68, 1u, (__int16 *)&v229, (__int16 *)&v228, 0, 0, 0))
      {
        v79 = v69 != 0;
        if (v223 || v79 || BYTE10(v235))
          goto LABEL_122;
LABEL_139:
        v223 = 0;
        goto LABEL_140;
      }
      v61 = btree_node_child_val(v73, (unsigned __int16)(v72 + 1), v16);
      if ((_DWORD)v61)
        goto LABEL_292;
      v74 = v235;
      obj_unlock(v235, 2);
      obj_release(v74);
      *(_QWORD *)&v235 = 0;
      v75 = WORD4(v236);
      ++WORD4(v236);
      if (v223 && v75 == 0)
      {
        v76 = v225;
        LOBYTE(v51) = (_BYTE)v224;
        if (v47)
        {
          v77 = v222;
          if (v47 != a1)
            v77 = 1;
          if (v47 != (_QWORD *)v237 && v47 != (_QWORD *)v236 && v77)
          {
            obj_unlock((uint64_t)v47, 2);
            obj_release(v47);
            v213 = v233;
            v214 = (uint64_t)v233;
            v215 = v233;
            v216 = (uint64_t)v233;
            v219 = v233;
          }
        }
        v47 = v219;
        if (v219)
        {
          v78 = v222;
          if (v219 != a1)
            v78 = 1;
          if (v219 != (_QWORD *)v237 && v219 != (_QWORD *)v236 && v78)
          {
            obj_unlock((uint64_t)v219, 2);
            obj_release(v47);
          }
          v216 = 0;
          v213 = 0;
          v214 = 0;
          v215 = 0;
          v218 = 0;
          v219 = 0;
          v47 = 0;
          v217 = 0;
          v223 = 0;
          v233 = 0;
        }
        else
        {
          v218 = 0;
          v219 = 0;
          v217 = 0;
          v223 = 0;
        }
      }
      else
      {
        v76 = v225;
        LOBYTE(v51) = (_BYTE)v224;
      }
      v62 = *(_WORD *)(*(_QWORD *)(v236 + 56) + 34) - 1;
      v63 = a1;
      v64 = v16;
    }
    if (a1[54] == *(_QWORD *)(v236 + 112))
      a1[54] = *(_QWORD *)(v235 + 112);
    LODWORD(v224) = 1;
    if ((v71 & 2) != 0)
      goto LABEL_93;
LABEL_119:
    v79 = v69 != 0;
    if (!v223 && !v79 && !BYTE10(v235))
    {
      v47 = (_QWORD *)v236;
      v223 = 1;
      v216 = v68;
      v213 = (_QWORD *)v68;
      v217 = WORD4(v236);
      v214 = v68;
      v215 = (_QWORD *)v68;
      v233 = (_QWORD *)v68;
      v218 = v68;
      v219 = (_QWORD *)v68;
      goto LABEL_140;
    }
LABEL_122:
    if (!v223 || !v79)
      goto LABEL_140;
    if (v47)
    {
      v80 = v222;
      if (v47 != a1)
        v80 = 1;
      if (v47 != (_QWORD *)v237 && v47 != (_QWORD *)v236 && v80)
      {
        obj_unlock((uint64_t)v47, 2);
        obj_release(v47);
        v213 = v233;
        v214 = (uint64_t)v233;
        v216 = (uint64_t)v233;
        v215 = v233;
      }
    }
    v81 = (uint64_t)v215;
    if (!v215)
    {
      v215 = 0;
      v218 = 0;
      v219 = 0;
      v47 = 0;
      v217 = 0;
      goto LABEL_139;
    }
    v82 = v222;
    if (v215 != a1)
      v82 = 1;
    if (v215 != (_QWORD *)v237 && v215 != (_QWORD *)v236 && v82)
    {
      obj_unlock((uint64_t)v215, 2);
      obj_release(v81);
    }
    v216 = 0;
    v213 = 0;
    v214 = 0;
    v215 = 0;
    v218 = 0;
    v219 = 0;
    v47 = 0;
    v217 = 0;
    v223 = 0;
    v233 = 0;
LABEL_140:
    v83 = btree_node_largest_key_len(v235);
    v84 = 0;
    if (WORD4(v235))
    {
      v85 = 0;
    }
    else
    {
      v85 = 0;
      if (!BYTE10(v235))
      {
        v61 = btree_node_key_ptr(v236, WORD4(v236), &v232, &v230);
        if ((_DWORD)v61)
          goto LABEL_292;
        v86 = a1[1];
        if (!v86)
          v86 = *(_QWORD *)(*a1 + 392);
        v87 = v229;
        v61 = ((uint64_t (*)(uint64_t, unint64_t *, _QWORD, unint64_t *, _QWORD, int *))a1[52])(v86, a3, v229, v232, v230, &v231);
        if ((_DWORD)v61)
          goto LABEL_292;
        if (v231 < 0)
        {
          v88 = *(_QWORD *)(v235 + 400);
          if ((v88 & 0x40) != 0)
            v89 = v87;
          else
            v89 = (v87 + 7) & 0x1FFF8;
          if ((v88 & 0x40) != 0)
            v90 = v230;
          else
            v90 = (v230 + 7) & 0x1FFF8;
          if (v89 <= v90)
          {
            v84 = 0;
          }
          else
          {
            if ((v88 & 0x40) != 0)
              v91 = v87;
            else
              v91 = (v87 + 7) & 0x1FFF8;
            if ((*(_QWORD *)(v235 + 400) & 0x40) != 0)
              v92 = v230;
            else
              v92 = (v230 + 7) & 0x1FFF8;
            v84 = v91 - v92;
          }
          v85 = 1;
        }
        else
        {
          v84 = 0;
          v85 = 0;
        }
      }
    }
    v93 = *(unsigned __int16 *)(*(_QWORD *)(v236 + 56) + 34);
    if (v93 < 2)
    {
      WORD2(v227) = v83;
      v95 = *(_QWORD *)(v236 + 400);
      LOWORD(v96) = (BYTE6(v95) & 0x7F) + 8;
      LOWORD(v227) = v96;
      if ((v85 & 1) == 0)
      {
        v94 = v229;
        goto LABEL_173;
      }
      goto LABEL_171;
    }
    v94 = v229;
    if (v83 > v229)
      v94 = v83;
    WORD2(v227) = v94;
    v95 = *(_QWORD *)(v236 + 400);
    v96 = (HIWORD(v95) & 0x7F) + 8;
    LOWORD(v227) = (BYTE6(v95) & 0x7F) + 8;
    if ((v85 & 1) != 0)
    {
LABEL_171:
      v97 = 1;
      goto LABEL_174;
    }
LABEL_173:
    HIWORD(v227) = v94;
    WORD1(v227) = v96;
    v97 = 2;
LABEL_174:
    v209 = v84;
    v208 = (_QWORD *)v236;
    LODWORD(v206) = v97;
    LODWORD(v207) = (__int16)v84;
    if (btree_node_has_room(v236, v97, (__int16 *)&v227 + 2, (__int16 *)&v227, v84, 0, 0))
    {
LABEL_175:
      v51 = (int)v224;
      v54 = v218;
      goto LABEL_176;
    }
    if (v93 < 2)
    {
      v99 = v235;
      if (BYTE10(v235))
      {
        if ((*(_WORD *)(*(_QWORD *)(v235 + 56) + 32) & 4) != 0)
        {
          v101 = *(_QWORD *)(v235 + 400);
          v100 = (v101 >> 9) & 0x3FFF;
        }
        else
        {
          v100 = *(unsigned __int16 *)(*(_QWORD *)(v235 + 376) + 8 * WORD4(v235) + 2);
          v101 = *(_QWORD *)(v235 + 400);
        }
        v230 = v100;
        v105 = btree_node_val_len(v235, WORD4(v235));
        if (v105 == 65534)
          v106 = 0;
        else
          v106 = v105;
        v107 = v229;
        if ((v101 & 0x40) == 0)
          v107 = (v229 + 7) & 0x1FFF8;
        v108 = (v100 + 7) & 0x1FFF8;
        if ((v101 & 0x40) != 0)
          v108 = v100;
        v109 = v228;
        if ((v101 & 0x40) == 0)
          v109 = (v228 + 7) & 0x1FFF8;
        v110 = (v106 + 7) & 0x1FFF8;
        if ((v101 & 0x40) != 0)
          v110 = v106;
        v111 = v107 - v108;
        if (v107 < v108)
          v111 = 0;
        v112 = v109 - v110;
        if (v109 < v110)
          v112 = 0;
        v103 = v225;
        if ((unsigned __int16)v111 | (unsigned __int16)v112 && !btree_node_has_room(v99, 0, 0, 0, v111, v112, 0))
          goto LABEL_209;
      }
      else
      {
        has_room = btree_node_has_room(v235, 1u, (__int16 *)&v229, (__int16 *)&v228, 0, 0, 0);
        v103 = v225;
        if (!has_room)
          goto LABEL_209;
      }
      if (!(_WORD)v209 || btree_node_has_room((uint64_t)v208, 0, 0, 0, v207, 0, 0))
        goto LABEL_175;
    }
    else
    {
      v226 = (unsigned __int16)((BYTE6(v95) & 0x7F) + 8);
      if ((v85 & 1) != 0)
      {
        v98 = 1;
      }
      else
      {
        HIWORD(v226) = v212;
        WORD1(v226) = (BYTE6(v95) & 0x7F) + 8;
        v98 = 2;
      }
      v102 = btree_node_has_room(v235, v98, (__int16 *)&v226 + 2, (__int16 *)&v226, v207, 0, 0);
      v103 = v225;
      if (v102)
        goto LABEL_175;
    }
LABEL_209:
    v113 = WORD4(v236);
    if (!BYTE10(v236))
      v113 = WORD4(v236) + 1;
    v201 = v209;
    v209 = v229;
    v114 = bt_shift_or_split(a1, (_QWORD *)v237, WORD4(v237), v208, v113, a3, v229, v206, (__int16 *)&v227 + 2, (__int16 *)&v227, v201, v103, a7, (uint64_t *)&v234);
    if ((_DWORD)v114)
    {
      v20 = v114;
      v186 = a1[1];
      if (v186)
        v187 = (const char *)(v186 + 3880);
      else
        v187 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 384) + 208);
      log_err("%s:%d: %s bt_shift_or_split failed with error: %d\n", "bt_insert", 3667, v187, v114);
      goto LABEL_444;
    }
    v115 = (uint64_t)v234;
    v51 = (int)v224;
    v54 = v218;
    if (!v234)
      goto LABEL_176;
    v116 = v236;
    v208 = (_QWORD *)v236;
    if ((_QWORD)v237)
    {
      ++WORD4(v237);
      if ((_QWORD)v236)
      {
        v117 = v222;
        if ((_QWORD *)v236 != a1)
          v117 = 1;
        if (v117 == 1)
        {
          if (v47 == (_QWORD *)v236)
          {
            v118 = v214;
          }
          else
          {
            v118 = v214;
            if ((_QWORD)v236 != v214)
            {
              v206 = (uint64_t)v234;
              v119 = v214;
              obj_unlock(v236, 2);
              obj_release(v116);
              v207 = 0;
              v215 = (_QWORD *)v119;
              v218 = v119;
              v219 = (_QWORD *)v119;
              v115 = v206;
              goto LABEL_230;
            }
          }
          v215 = (_QWORD *)v118;
          v218 = v118;
          v219 = (_QWORD *)v118;
        }
        v207 = v236;
LABEL_230:
        v123 = v47 != (_QWORD *)v237 || v47 == 0;
        v124 = v217;
        if (!v123)
          v124 = WORD4(v237);
        v217 = v124;
        *(_QWORD *)&v236 = v115;
        v234 = 0;
        v61 = bt_search_node(v115, a3, v209, v205, v204);
        if ((_DWORD)v61)
          goto LABEL_292;
        v125 = v235;
        obj_unlock(v235, 2);
        obj_release(v125);
        *(_QWORD *)&v235 = 0;
        v61 = btree_node_child_val(v236, WORD4(v236), v16);
        if ((_DWORD)v61)
          goto LABEL_292;
        v61 = btree_node_get(a1, v16, v225, 3, *(_WORD *)(*(_QWORD *)(v236 + 56) + 34) - 1, a7, (uint64_t *)&v235);
        if ((_DWORD)v61)
          goto LABEL_292;
        v126 = v235;
        if ((a1[50] & 0x10) != 0 && *(_QWORD *)(v235 + 112) != *v16)
        {
          btree_node_child_id_update(v236, WORD4(v236), (uint64_t *)(v235 + 112), a7);
          v126 = v235;
        }
        if ((*(_WORD *)(*(_QWORD *)(v126 + 56) + 32) & 2) != 0)
          v127 = bt_search_node_insert(v126, a3, v209, v221, v220);
        else
          v127 = bt_search_node(v126, a3, v209, v221, v220);
        v20 = v127;
        v54 = v218;
        if ((_DWORD)v127)
          goto LABEL_444;
        if (v47 != v208)
        {
          v128 = v207;
          if (!v223)
          {
            LODWORD(v130) = v217;
            goto LABEL_267;
          }
          if (WORD4(v236) | WORD4(v235))
          {
            if (v47)
            {
              v129 = v222;
              if (v47 != a1)
                v129 = 1;
              if (v47 != (_QWORD *)v237 && v47 != (_QWORD *)v236 && v129)
              {
                obj_unlock((uint64_t)v47, 2);
                obj_release(v47);
                v216 = (uint64_t)v233;
                v213 = v233;
              }
            }
            v130 = (uint64_t)v213;
            if (v213)
            {
              v131 = v222;
              if (v213 != a1)
                v131 = 1;
              if (v213 != (_QWORD *)v237 && v213 != (_QWORD *)v236 && v131)
              {
                obj_unlock((uint64_t)v213, 2);
                obj_release(v130);
              }
              v216 = 0;
              v213 = 0;
              v214 = 0;
              v215 = 0;
              v219 = 0;
              v54 = 0;
              v47 = 0;
              LODWORD(v130) = 0;
              v233 = 0;
            }
            else
            {
              v213 = 0;
              v214 = 0;
              v215 = 0;
              v219 = 0;
              v54 = 0;
              v47 = 0;
            }
LABEL_267:
            if (WORD4(v235))
            {
LABEL_268:
              v223 = 0;
              goto LABEL_281;
            }
            if (!WORD4(v236) && !BYTE10(v236))
            {
              v47 = (_QWORD *)v237;
              v132 = v236;
              v223 = 1;
              goto LABEL_279;
            }
            if (BYTE10(v235) || (*(_WORD *)(*(_QWORD *)(v235 + 56) + 32) & 2) != 0)
              goto LABEL_268;
            v47 = (_QWORD *)v236;
            v223 = 1;
            v216 = v235;
            v213 = (_QWORD *)v235;
            v214 = v235;
            v233 = (_QWORD *)v235;
            v215 = (_QWORD *)v235;
            v219 = (_QWORD *)v235;
            v54 = v235;
            LODWORD(v130) = WORD4(v236);
          }
          else
          {
            v223 = 1;
            LODWORD(v130) = v217;
          }
          goto LABEL_281;
        }
        LODWORD(v130) = WORD4(v236);
        v128 = v207;
        if (v47 == a1 && !WORD4(v236))
        {
          v213 = (_QWORD *)v236;
          v214 = v236;
          v233 = (_QWORD *)v236;
          v215 = (_QWORD *)v236;
          v219 = (_QWORD *)v236;
          v216 = v236;
          v54 = v236;
          v47 = a1;
          goto LABEL_176;
        }
        if (WORD4(v236))
        {
          v47 = (_QWORD *)v236;
          v132 = v235;
          v213 = (_QWORD *)v235;
        }
        else
        {
          v47 = (_QWORD *)v237;
          v132 = v236;
LABEL_279:
          v213 = (_QWORD *)v132;
          LODWORD(v130) = WORD4(v237);
        }
        v233 = (_QWORD *)v132;
        v214 = v132;
        v215 = (_QWORD *)v132;
        v219 = (_QWORD *)v132;
        v216 = v132;
        v54 = v132;
LABEL_281:
        if (v128)
        {
          v133 = v222;
          if ((_QWORD *)v128 != a1)
            v133 = 1;
          if (v133 == 1 && (_QWORD *)v128 != v47)
          {
            v134 = v216;
            if (v128 != v216)
            {
              obj_unlock(v128, 2);
              obj_release(v128);
            }
            v213 = (_QWORD *)v134;
            v214 = v134;
            v215 = (_QWORD *)v134;
            v219 = (_QWORD *)v134;
            v54 = v134;
            v217 = v130;
            v51 = (int)v224;
LABEL_176:
            if ((*(_WORD *)(*(_QWORD *)(v235 + 56) + 32) & 2) == 0)
              continue;
            goto LABEL_294;
          }
          v213 = (_QWORD *)v216;
          v214 = v216;
          v215 = (_QWORD *)v216;
          v219 = (_QWORD *)v216;
          v54 = v216;
        }
        v217 = v130;
        goto LABEL_176;
      }
LABEL_226:
      v207 = 0;
      goto LABEL_230;
    }
    break;
  }
  *(_QWORD *)&v237 = v236;
  if (*(_DWORD *)(v234[7] + 36))
  {
    v61 = btree_node_key_ptr((uint64_t)v234, 0, &v232, &v230);
    if ((_DWORD)v61)
      goto LABEL_292;
    v120 = v237;
    v121 = v232;
    v122 = v230;
  }
  else
  {
    v120 = v236;
    v121 = a3;
    v122 = v209;
  }
  v20 = bt_search_node(v120, v121, v122, v203, v202);
  if (!(_DWORD)v20)
    goto LABEL_226;
LABEL_444:
  v195 = v237;
  v196 = (uint64_t)v233;
  if ((_QWORD)v237 && (_QWORD *)v237 != v47 && (_QWORD *)v237 != v233)
  {
    obj_unlock(v237, 2);
    obj_release(v195);
  }
  v197 = v236;
  if ((_QWORD)v236 && (_QWORD *)v236 != v47 && (_QWORD)v236 != v196)
  {
    obj_unlock(v236, 2);
    obj_release(v197);
  }
  v198 = v235;
  if ((_QWORD)v235 && (_QWORD *)v235 != v47 && (_QWORD)v235 != v196)
  {
    obj_unlock(v235, 2);
    obj_release(v198);
  }
  if (v47)
  {
    obj_unlock((uint64_t)v47, 2);
    obj_release(v47);
    v196 = (uint64_t)v233;
  }
  if (v196)
  {
    obj_unlock(v196, 2);
    obj_release(v196);
  }
  v199 = (uint64_t)v234;
  if (v234)
  {
    obj_unlock((uint64_t)v234, 2);
    obj_release(v199);
  }
  v200 = v222;
  if ((_QWORD *)v237 == a1)
    v200 = 1;
  if ((_QWORD *)v196 != a1 && (v200 & 1) == 0 && (_QWORD *)v236 != a1 && (_QWORD *)v235 != a1 && v47 != a1)
  {
    obj_unlock((uint64_t)a1, 2);
    obj_release(a1);
  }
  return v20;
}

uint64_t bt_search_node_insert(uint64_t a1, unint64_t *a2, uint64_t a3, _WORD *a4, BOOL *a5)
{
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t result;
  uint64_t v15;
  BOOL v16;
  int v17;
  unint64_t v18;
  int v19;
  int v20;
  BOOL v21;
  unsigned __int16 v22;
  int v23;
  __int16 v24;
  unint64_t *v25;

  v23 = 0;
  v10 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 36) - 1;
  v22 = 0;
  if ((*(_BYTE *)(a1 + 400) & 1) == 0)
  {
    if ((v10 & 0x80000000) == 0)
    {
      v11 = 0;
      v25 = 0;
      while (1)
      {
        v12 = v10 + v11;
        if (v10 + v11 < 0 != __OFADD__(v10, v11))
          ++v12;
        v13 = v12 >> 1;
        result = btree_node_key_ptr(a1, (unsigned __int16)(v12 >> 1), &v25, &v22);
        if ((_DWORD)result)
          return result;
        v15 = *(_QWORD *)(a1 + 8);
        if (!v15)
          v15 = *(_QWORD *)(*(_QWORD *)a1 + 392);
        result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, unint64_t *, _QWORD, int *))(a1 + 416))(v15, a2, a3, v25, v22, &v23);
        if ((_DWORD)result)
          return result;
        v16 = v23 == 0;
        if (!v23)
        {
          LOWORD(v11) = v13;
          goto LABEL_38;
        }
        if (v23 < 0)
          v10 = v13 - 1;
        else
          v11 = v13 + 1;
        if (v11 > v10)
          goto LABEL_38;
      }
    }
    v16 = 0;
    LOWORD(v11) = 0;
LABEL_38:
    result = 0;
    *a4 = v11;
LABEL_41:
    *a5 = v16;
    return result;
  }
  if ((_DWORD)a3 != 8)
    return 22;
  if (v10 < 0)
  {
    v16 = 0;
    LOWORD(v17) = 0;
LABEL_40:
    result = 0;
    *a4 = v17;
    goto LABEL_41;
  }
  v17 = 0;
  v18 = *a2;
  v25 = 0;
  v24 = 0;
  while (1)
  {
    v19 = v17 + v10;
    if (v17 + v10 < 0 != __OFADD__(v17, v10))
      ++v19;
    v20 = v19 >> 1;
    LODWORD(result) = btree_node_key_ptr(a1, (unsigned __int16)(v19 >> 1), &v25, &v24);
    v21 = v24 != 8 && (_DWORD)result == 0;
    result = v21 ? 22 : result;
    if ((_DWORD)result)
      return result;
    v16 = *v25 == v18;
    if (*v25 == v18)
    {
      LOWORD(v17) = v20;
      goto LABEL_40;
    }
    if (*v25 > v18)
      v10 = v20 - 1;
    else
      v17 = v20 + 1;
    if (v17 > v10)
      goto LABEL_40;
  }
}

uint64_t btree_node_entry_update(uint64_t a1, unsigned int a2, void *__src, size_t __n, void *a5, unsigned int a6, uint64_t a7)
{
  unsigned int v8;
  uint64_t v12;
  __int16 v13;
  size_t v14;
  uint64_t v15;
  unsigned __int16 *v16;
  unsigned int v17;
  unsigned __int16 *v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  __int16 v22;
  unsigned int v23;
  __int16 v24;
  uint64_t v25;
  unsigned __int16 v26;
  int v27;
  unsigned __int16 v28;
  int v29;
  __int16 v30;
  __int16 v31;
  __int16 v32;
  __int16 v33;
  __int16 v34;
  unsigned __int16 v35;
  unsigned __int16 v36;
  _BOOL4 v37;
  __int16 v38;
  uint64_t v39;
  unsigned int v40;
  _BOOL4 v41;
  __int16 v42;
  unsigned __int16 v43;
  _WORD *v44;
  int v45;
  __int16 v46;
  unsigned __int16 v47;
  _WORD *v48;
  __int16 v49;
  uint64_t v50;
  uint64_t v51;
  unsigned __int16 v52;
  int v53;
  uint64_t v54;
  const char *v55;
  uint64_t v56;
  uint64_t v57;
  _WORD *v58;
  _WORD *v59;
  _WORD *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  _WORD *v65;
  uint64_t v66;
  uint64_t v67;
  _WORD *v68;
  unsigned int v69;
  __int16 v70;
  unsigned __int16 v72;
  int v73;
  int v74;
  _BOOL4 v75;
  int v76;
  __int16 v77;
  void *v79;
  void *v80;
  size_t v81;
  unsigned __int16 v82;
  unsigned __int16 v83;
  int v84;

  v8 = __n;
  v84 = 0;
  v83 = 0;
  v82 = 0;
  v12 = *(_QWORD *)(a1 + 56);
  v13 = *(_WORD *)(v12 + 32);
  if (a6 == 65534)
    v14 = 0;
  else
    v14 = a6;
  v80 = a5;
  v81 = v14;
  v79 = __src;
  v77 = *(_WORD *)(v12 + 32);
  if (*(_DWORD *)(v12 + 36) <= a2)
  {
    v21 = 0;
    v22 = 0;
    v20 = 0;
    LOWORD(v23) = 0;
    v24 = 0;
    v75 = 0;
    v17 = 0xFFFF;
    v19 = 0xFFFF;
  }
  else
  {
    v15 = *(_QWORD *)(a1 + 376);
    if ((v13 & 4) != 0)
      v16 = (unsigned __int16 *)(v15 + 4 * a2);
    else
      v16 = (unsigned __int16 *)(v15 + 8 * a2);
    v17 = *v16;
    v18 = (unsigned __int16 *)(v15 + 4 * a2 + 2);
    if ((v13 & 4) == 0)
      v18 = (unsigned __int16 *)(v15 + 8 * a2 + 4);
    v19 = *v18;
    if (v17 == 0xFFFF)
    {
      v20 = 0;
    }
    else if ((v13 & 4) != 0)
    {
      v20 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
    }
    else
    {
      v20 = *(unsigned __int16 *)(v15 + 8 * a2 + 2);
    }
    if (v19 > 0xFFFD)
      v23 = 0;
    else
      v23 = btree_node_val_len(a1, a2);
    v75 = v20 != 0;
    if (v20)
    {
      v25 = btree_node_key_range_validate(a1, v17, v20);
      if ((_DWORD)v25)
        return v25;
      v24 = v20;
    }
    else
    {
      v24 = 0;
    }
    a5 = v80;
    v14 = v81;
    if (v23)
    {
      v25 = btree_node_val_range_validate(a1, v19, v23);
      if ((_DWORD)v25)
        return v25;
      v21 = 1;
      v22 = v23;
      a5 = v80;
      v14 = v81;
    }
    else
    {
      v21 = 0;
      v22 = 0;
    }
    __src = v79;
  }
  HIWORD(v84) = v17;
  LOWORD(v84) = v19;
  v26 = v8 - v20;
  if (!__src)
    v26 = 0;
  v27 = (__int16)v26;
  v28 = v14 - v23;
  if (!a5)
    v28 = 0;
  v29 = (__int16)v28;
  if (!(v26 | v28))
    goto LABEL_148;
  if (__src)
  {
    if ((*(_QWORD *)(a1 + 400) & 0x40) != 0)
      v30 = v8;
    else
      v30 = (v8 + 7) & 0xFFF8;
    v31 = (v24 + 7) & 0xFFF8;
    if ((*(_QWORD *)(a1 + 400) & 0x40) != 0)
      v31 = v24;
    v32 = v30 - v31;
  }
  else
  {
    v32 = 0;
  }
  v73 = v29;
  v74 = v27;
  if (a5)
  {
    if ((*(_QWORD *)(a1 + 400) & 0x40) != 0)
      v33 = v14;
    else
      v33 = (v14 + 7) & 0xFFF8;
    if ((*(_QWORD *)(a1 + 400) & 0x40) == 0)
      v22 = (v22 + 7) & 0xFFF8;
    v34 = v33 - v22;
  }
  else
  {
    v34 = 0;
  }
  if (v34 + v32 > (int)btree_node_free_space_total(a1))
    return 28;
  v35 = 0;
  v82 = -1;
  v83 = -1;
  if (!v8)
    goto LABEL_55;
  v27 = v74;
  if (!v74)
    goto LABEL_56;
  btree_node_space_free_list_search(a1, 1, v8, (__int16 *)&v83, (unsigned __int16 *)&v84 + 1);
  if (SHIWORD(v84) != -1)
  {
    v35 = 0;
LABEL_55:
    v27 = v74;
    goto LABEL_56;
  }
  v27 = v74;
  if (v74 < 0)
  {
    v35 = 0;
    HIWORD(v84) = v17;
    v83 = -1;
  }
  else if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
  {
    v35 = v8;
  }
  else
  {
    v35 = (v8 + 7) & 0xFFF8;
  }
LABEL_56:
  v14 = v81;
  if (!(_DWORD)v81)
  {
    __src = v79;
    a5 = v80;
    v29 = v73;
    goto LABEL_72;
  }
  v29 = v73;
  if (!v73)
  {
    __src = v79;
    a5 = v80;
    goto LABEL_72;
  }
  v36 = v35;
  btree_node_space_free_list_search(a1, 2, v81, (__int16 *)&v82, (unsigned __int16 *)&v84);
  if ((__int16)v84 == -1)
  {
    v29 = v73;
    if (v73 < 0)
    {
      LOWORD(v84) = v19;
      v82 = -1;
      a5 = v80;
      v14 = v81;
      __src = v79;
      goto LABEL_60;
    }
    a5 = v80;
    v14 = v81;
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
      v38 = v81;
    else
      v38 = (v81 + 7) & 0xFFF8;
    v35 = v38 + v36;
    __src = v79;
    v27 = v74;
LABEL_72:
    v37 = v75;
    goto LABEL_73;
  }
  a5 = v80;
  v14 = v81;
  __src = v79;
  v29 = v73;
LABEL_60:
  v27 = v74;
  v37 = v75;
  v35 = v36;
LABEL_73:
  v39 = *(_QWORD *)(a1 + 56);
  v40 = *(unsigned __int16 *)(v39 + 46);
  if (v27)
    v41 = v37;
  else
    v41 = 0;
  if (v41)
  {
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
      v42 = v20;
    else
      v42 = (v20 + 7) & 0xFFF8;
    v43 = (v42 + 7) & 0xFFF8;
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
      v43 = v20;
    if (v43 >= 4u)
    {
      v44 = (_WORD *)(*(_QWORD *)(a1 + 384) + v17);
      v44[1] = v43;
      *v44 = *(_WORD *)(v39 + 48);
      *(_WORD *)(v39 + 48) = v17;
    }
    *(_WORD *)(v39 + 50) += v43;
    if (HIWORD(v84) != 0xFFFF && v83 == 0xFFFF && HIWORD(v84) != v17 && *(unsigned __int16 *)(v39 + 48) == v17)
      v83 = v17;
  }
  if (v29)
    v45 = v21;
  else
    v45 = 0;
  if (v45 == 1)
  {
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
      v46 = v23;
    else
      v46 = (v23 + 7) & 0xFFF8;
    v47 = (v46 + 7) & 0xFFF8;
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
      v47 = v23;
    if (v47 >= 4u)
    {
      v48 = (_WORD *)(*(_QWORD *)(a1 + 392) - v19);
      v48[1] = v47;
      *v48 = *(_WORD *)(v39 + 52);
      *(_WORD *)(v39 + 52) = v19;
    }
    *(_WORD *)(v39 + 54) += v47;
    if ((unsigned __int16)v84 != 0xFFFF
      && v82 == 0xFFFF
      && (unsigned __int16)v84 != v19
      && *(unsigned __int16 *)(v39 + 52) == v19)
    {
      v82 = v19;
    }
  }
  if (v40 < v35)
  {
    if ((v77 & 0x8000) == 0)
      *(_WORD *)(v39 + 32) |= 0x8000u;
    if (*(_DWORD *)(v39 + 36) > a2)
    {
      v49 = *(_WORD *)(v39 + 32);
      v50 = *(_QWORD *)(a1 + 376);
      if ((v49 & 4) != 0)
      {
        if (v41)
          *(_WORD *)(v50 + 4 * a2) = -1;
        if (v45)
          *(_WORD *)(v50 + 4 * a2 + 2) = -1;
      }
      else
      {
        if (v41)
          *(_DWORD *)(v50 + 8 * a2) = 0xFFFF;
        if (v45)
          *(_DWORD *)(v50 + 8 * a2 + 4) = 0xFFFF;
      }
    }
    v76 = v45;
    v51 = btree_node_compact(a1, 0, a7);
    if ((_DWORD)v51)
    {
      v25 = v51;
      if (v41)
      {
        v52 = (*(_QWORD *)(a1 + 400) & 0x40) != 0 ? v8 : (v8 + 7) & 0xFFF8;
        v53 = btree_node_space_free_list_alloc(a1, 1, v52, 0xFFFF, v17);
        if (v53)
        {
          v54 = *(_QWORD *)(a1 + 8);
          if (v54)
            v55 = (const char *)(v54 + 3880);
          else
            v55 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
          log_err("%s:%d: %s unable to reclaim just-freed key space on error path: %d\n", "btree_node_entry_update", 1763, v55, v53);
        }
      }
      if (v76)
      {
        if ((*(_QWORD *)(a1 + 400) & 0x40) != 0)
          v72 = v23;
        else
          v72 = (v23 + 7) & 0xFFF8;
        if (btree_node_space_free_list_alloc(a1, 2, v72, 0xFFFF, v19))
          log_err("%s:%d: %s unable to reclaim just-freed val space on error path: %d\n");
      }
      return v25;
    }
    v82 = -1;
    v83 = -1;
    v84 = -1;
    a5 = v80;
    v14 = v81;
    __src = v79;
    v29 = v73;
    v27 = v74;
  }
  if (v27)
  {
    if (HIWORD(v84) == 0xFFFF)
      v56 = btree_node_space_alloc(a1, 1, v8, (_WORD *)&v84 + 1);
    else
      v56 = btree_node_space_free_list_alloc(a1, 1, v8, v83, HIWORD(v84));
    v25 = v56;
    a5 = v80;
    v14 = v81;
    __src = v79;
    v29 = v73;
    v27 = v74;
    if ((_DWORD)v56)
      goto LABEL_189;
  }
  else
  {
    v57 = *(_QWORD *)(a1 + 376);
    v58 = (_WORD *)(v57 + 4 * a2);
    v59 = (_WORD *)(v57 + 8 * a2);
    if ((*(_WORD *)(*(_QWORD *)(a1 + 56) + 32) & 4) != 0)
      v60 = v58;
    else
      v60 = v59;
    HIWORD(v84) = *v60;
  }
  if (v29)
  {
    if ((_DWORD)v14)
    {
      if ((unsigned __int16)v84 == 0xFFFF)
        v61 = btree_node_space_alloc(a1, 2, v14, &v84);
      else
        v61 = btree_node_space_free_list_alloc(a1, 2, v14, v82, (unsigned __int16)v84);
      v25 = v61;
      __src = v79;
      a5 = v80;
      v29 = v73;
      v27 = v74;
      if (!(_DWORD)v61)
      {
        LOWORD(v19) = v84;
        v14 = v81;
        goto LABEL_148;
      }
LABEL_189:
      log_err("%s:%d: %s unable allocate space that should be there: %d\n");
      return v25;
    }
    if (a6 == 65534)
      LOWORD(v19) = -2;
    else
      LOWORD(v19) = -1;
  }
  else
  {
    v62 = *(_QWORD *)(a1 + 376);
    v63 = v62 + 4 * a2 + 2;
    v64 = v62 + 8 * a2 + 4;
    if ((*(_WORD *)(*(_QWORD *)(a1 + 56) + 32) & 4) != 0)
      v65 = (_WORD *)v63;
    else
      v65 = (_WORD *)v64;
    LOWORD(v19) = *v65;
  }
  LOWORD(v84) = v19;
LABEL_148:
  if (a6 == 65534 && (unsigned __int16)v19 != 65534)
  {
    LOWORD(v19) = -2;
    LOWORD(v84) = -2;
    v29 = 1;
  }
  v66 = *(_QWORD *)(a1 + 56);
  v67 = *(_QWORD *)(a1 + 376);
  if ((*(_WORD *)(v66 + 32) & 4) != 0)
  {
    if (v27)
      *(_WORD *)(v67 + 4 * a2) = HIWORD(v84);
    if (v29)
      *(_WORD *)(v67 + 4 * a2 + 2) = v19;
  }
  else
  {
    v68 = (_WORD *)(v67 + 8 * a2);
    if (v27)
    {
      *v68 = HIWORD(v84);
      v68[1] = v8;
    }
    if (v29)
    {
      v68[2] = v19;
      v68[3] = a6;
    }
  }
  if ((v77 & 0x8000) == 0)
    *(_WORD *)(v66 + 32) &= ~0x8000u;
  v69 = *(unsigned __int16 *)(a1 + 440);
  if (!*(_WORD *)(a1 + 440) || (v70 = v8, v69 >= v8))
  {
    if (v8 >= v20 || v69 > v20)
      goto LABEL_168;
    v70 = 0;
  }
  *(_WORD *)(a1 + 440) = v70;
LABEL_168:
  if (__src && v8)
  {
    memcpy((void *)(*(_QWORD *)(a1 + 384) + HIWORD(v84)), __src, v8);
    a5 = v80;
    v14 = v81;
  }
  if (a5 && (_DWORD)v14)
    memcpy((void *)(*(_QWORD *)(a1 + 392) - (unsigned __int16)v84), a5, v14);
  obj_dirty(a1, a7, 0);
  return 0;
}

uint64_t btree_node_insert_internal(uint64_t a1, unsigned int a2, const void *a3, unsigned int a4, const void *a5, unsigned int a6, uint64_t a7)
{
  unsigned int v11;
  unsigned int v12;
  const void *v13;
  const void *v14;
  unsigned __int16 v15;
  uint64_t v16;
  __int16 v17;
  unsigned int v18;
  uint64_t v19;
  unsigned __int16 v20;
  uint64_t v21;
  unsigned __int16 v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  const char *v26;
  unsigned __int16 v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  const char *v31;
  __int16 v32;
  __int16 v33;
  __int16 v34;
  uint64_t v35;
  unsigned int v36;
  __int16 v37;
  uint64_t v38;
  _WORD *v39;
  _WORD *v40;
  __int16 v42;
  int v43;
  int v44;
  unsigned __int16 v45;
  __int16 v46;

  v46 = a4;
  if (a6 == 65534)
    v11 = 0;
  else
    v11 = a6;
  v42 = v11;
  if (a3)
  {
    v12 = a4;
    if (a4)
      v13 = a3;
    else
      v13 = 0;
    if (a5)
      goto LABEL_9;
LABEL_13:
    v11 = 0;
    v14 = 0;
    v42 = 0;
    goto LABEL_14;
  }
  v12 = 0;
  v13 = 0;
  v46 = 0;
  if (!a5)
    goto LABEL_13;
LABEL_9:
  if (v11)
    v14 = a5;
  else
    v14 = 0;
LABEL_14:
  v45 = 0;
  v43 = 0;
  v44 = 0;
  if (!btree_node_has_room(a1, 1u, &v46, &v42, 0, 0, &v45))
    return 28;
  v43 = -1;
  v44 = -1;
  if (v13)
    btree_node_space_free_list_search(a1, 1, v12, (__int16 *)&v44 + 1, (unsigned __int16 *)&v44);
  if (v14)
    btree_node_space_free_list_search(a1, 2, v11, (__int16 *)&v43 + 1, (unsigned __int16 *)&v43);
  if ((__int16)v44 == -1)
  {
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
      v15 = v12;
    else
      v15 = (v12 + 7) & 0xFFF8;
  }
  else
  {
    v15 = 0;
  }
  if ((__int16)v43 == -1)
  {
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
      v17 = v11;
    else
      v17 = (v11 + 7) & 0xFFF8;
    v15 += v17;
  }
  v18 = v45 + v15;
  v19 = *(_QWORD *)(a1 + 56);
  if (v18 <= *(unsigned __int16 *)(v19 + 46))
  {
    if (v45)
    {
      memmove((void *)(*(_QWORD *)(a1 + 384) + v45), *(const void **)(a1 + 384), *(unsigned __int16 *)(v19 + 44));
      bzero(*(void **)(a1 + 384), v45);
      v20 = v45;
      *(_QWORD *)(a1 + 384) += v45;
      v21 = *(_QWORD *)(a1 + 56);
      *(_WORD *)(v21 + 46) -= v20;
      *(_WORD *)(v21 + 42) += v20;
    }
  }
  else
  {
    v16 = btree_node_compact(a1, 1, a7);
    if ((_DWORD)v16)
      return v16;
    LOWORD(v43) = -1;
    LOWORD(v44) = -1;
    v45 = 0;
  }
  if (!v13)
  {
LABEL_38:
    if (!v14)
      goto LABEL_62;
    goto LABEL_39;
  }
  if ((unsigned __int16)v44 != 0xFFFF)
  {
    v16 = btree_node_space_free_list_alloc(a1, 1, v12, HIWORD(v44), (unsigned __int16)v44);
    if (!(_DWORD)v16)
      goto LABEL_38;
LABEL_47:
    v25 = *(_QWORD *)(a1 + 8);
    if (v25)
      v26 = (const char *)(v25 + 3880);
    else
      v26 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
    log_err("%s:%d: %s unable allocate space that should be there: %d\n", "btree_node_insert_internal", 2184, v26, v16);
    return v16;
  }
  if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
    v22 = v12;
  else
    v22 = (v12 + 7) & 0xFFF8;
  v23 = *(_QWORD *)(a1 + 56);
  v24 = *(unsigned __int16 *)(v23 + 46);
  if (v24 < v22)
  {
    v16 = 28;
    goto LABEL_47;
  }
  v32 = *(_WORD *)(v23 + 44);
  *(_WORD *)(v23 + 44) = v32 + v22;
  *(_WORD *)(v23 + 46) = v24 - v22;
  LOWORD(v44) = v32;
  if (!v14)
    goto LABEL_62;
LABEL_39:
  if ((unsigned __int16)v43 != 0xFFFF)
  {
    v16 = btree_node_space_free_list_alloc(a1, 2, v11, HIWORD(v43), (unsigned __int16)v43);
    if (!(_DWORD)v16)
      goto LABEL_62;
LABEL_53:
    v30 = *(_QWORD *)(a1 + 8);
    if (v30)
      v31 = (const char *)(v30 + 3880);
    else
      v31 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
    log_err("%s:%d: %s unable allocate space that should be there: %d\n", "btree_node_insert_internal", 2196, v31, v16);
    return v16;
  }
  v27 = (v11 + 7) & 0xFFF8;
  if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
    v27 = v11;
  v28 = *(_QWORD *)(a1 + 56);
  v29 = *(unsigned __int16 *)(v28 + 46);
  if (v29 < v27)
  {
    v16 = 28;
    goto LABEL_53;
  }
  v33 = v29 - v27;
  *(_WORD *)(v28 + 46) = v33;
  LOWORD(v43) = *(_WORD *)(a1 + 392) - (v33 + *(_WORD *)(a1 + 384) + *(_WORD *)(v28 + 44));
LABEL_62:
  if (!v11)
  {
    if (a6 == 65534)
      v34 = -2;
    else
      v34 = -1;
    LOWORD(v43) = v34;
  }
  v35 = *(_QWORD *)(a1 + 56);
  v36 = *(_DWORD *)(v35 + 36);
  if (v36 > a2)
  {
    btree_node_toc_shift(a1, a2, 1);
    v35 = *(_QWORD *)(a1 + 56);
    v36 = *(_DWORD *)(v35 + 36);
  }
  *(_DWORD *)(v35 + 36) = v36 + 1;
  v37 = v43;
  v38 = *(_QWORD *)(a1 + 376);
  if ((*(_WORD *)(v35 + 32) & 4) != 0)
  {
    v40 = (_WORD *)(v38 + 4 * a2);
    *v40 = v44;
    v40[1] = v37;
  }
  else
  {
    v39 = (_WORD *)(v38 + 8 * a2);
    *v39 = v44;
    v39[1] = v12;
    v39[2] = v37;
    v39[3] = a6;
  }
  if (*(_WORD *)(a1 + 440) && *(unsigned __int16 *)(a1 + 440) < v12)
    *(_WORD *)(a1 + 440) = v12;
  if (v13)
    memcpy((void *)(*(_QWORD *)(a1 + 384) + (unsigned __int16)v44), v13, v12);
  if (v14)
    memcpy((void *)(*(_QWORD *)(a1 + 392) - (unsigned __int16)v43), v14, v11);
  obj_dirty(a1, a7, 0);
  return 0;
}

uint64_t bt_search_node(uint64_t a1, unint64_t *a2, uint64_t a3, _WORD *a4, BOOL *a5)
{
  uint64_t result;

  result = bt_search_node_insert(a1, a2, a3, a4, a5);
  if (!(_DWORD)result && !*a5)
  {
    if (*a4)
      --*a4;
  }
  return result;
}

uint64_t btree_node_child_id_update(uint64_t a1, unsigned int a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *v5;
  __int16 v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  v5 = a3;
  v12 = 0;
  v6 = *(_WORD *)(*(_QWORD *)(a1 + 56) + 32);
  if ((v6 & 8) == 0)
  {
LABEL_4:
    if ((v6 & 4) != 0)
      v8 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
    else
      v8 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 376) + 8 * a2 + 2);
    return btree_node_entry_update_via_callback(a1, a2, 0, v8, (uint64_t)v5, 8, 0, a4, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))btree_node_child_id_update_cb, 0);
  }
  v7 = *(_QWORD *)(a1 + 408);
  if (*a3 > v7)
  {
    v12 = *a3 - v7;
    v5 = (uint64_t *)&v12;
    goto LABEL_4;
  }
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
    v11 = (const char *)(v10 + 3880);
  else
    v11 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
  log_err("%s:%d: %s invalid relative OID: %llu < root OID: %llu\n", "btree_node_child_id_update", 1952, v11, *a3, v7);
  return 22;
}

BOOL btree_node_has_room(uint64_t a1, unsigned int a2, __int16 *a3, __int16 *a4, __int16 a5, __int16 a6, _WORD *a7)
{
  _WORD *v12;
  __int16 v13;
  int v14;
  unsigned int v15;
  char v16;
  char v17;
  unsigned int v18;
  _BOOL8 result;
  unsigned int v20;
  unsigned int v21;
  char v22;
  unsigned int v23;
  BOOL v24;
  unsigned int v25;
  unsigned int v26;
  __int16 v27;
  uint64_t v28;
  char v29;
  __int16 v30;
  __int16 v31;
  unsigned int v32;
  __int16 v33;
  __int16 v34;
  __int16 v35;
  unsigned __int16 v36;
  char v37;
  int v38;
  BOOL v39;
  int v40;
  char v43;

  v12 = *(_WORD **)(a1 + 56);
  v13 = v12[16];
  v14 = (unsigned __int16)v12[18];
  v15 = (unsigned __int16)v12[21];
  if ((v13 & 4) != 0)
    v16 = 2;
  else
    v16 = 3;
  v43 = v16;
  if ((v13 & 4) != 0)
    v17 = 2;
  else
    v17 = 3;
  v18 = btree_node_toc_required_capacity(a1, 0);
  if ((v13 & 4) == 0 || (*(_BYTE *)(a1 + 400) & 4) != 0 || v14 + a2 <= v18)
  {
    v20 = v18;
    v21 = btree_node_toc_required_capacity(a1, (__int16)a2);
    if (a7)
    {
      if ((v13 & 4) != 0)
        v22 = 2;
      else
        v22 = 3;
      v23 = v21 << v22;
      v24 = v23 >= v15;
      v25 = v23 - v15;
      if (v25 == 0 || !v24)
        LOWORD(v25) = 0;
      *a7 = v25;
    }
    v26 = v15 >> v17;
    v27 = 0;
    if (a2)
    {
      v28 = a2;
      v29 = v43;
      v31 = a5;
      v30 = a6;
      v32 = v20;
      do
      {
        v34 = *a3++;
        v33 = v34;
        if ((*(_QWORD *)(a1 + 400) & 0x40) != 0)
        {
          v35 = *a4;
        }
        else
        {
          v33 = (v33 + 7) & 0xFFF8;
          v35 = (*a4 + 7) & 0xFFF8;
        }
        v27 += v33 + v35;
        ++a4;
        --v28;
      }
      while (v28);
    }
    else
    {
      v29 = v43;
      v31 = a5;
      v30 = a6;
      v32 = v20;
    }
    v36 = v30 + v31 + v27;
    if ((v13 & 4) != 0)
      v37 = 2;
    else
      v37 = 3;
    v38 = ((v21 - v32) << v37) & 0xFFFC;
    if (v21 <= v32)
      v38 = 0;
    v39 = v26 > v32;
    v40 = (v26 - v32) << v29;
    if (!v39)
      LOWORD(v40) = 0;
    return v38 + v36 <= (unsigned __int16)(v12[23] + v40 + v12[25] + v12[27]);
  }
  else
  {
    result = 0;
    if (a7)
      *a7 = -1;
  }
  return result;
}

uint64_t btree_node_largest_key_len(uint64_t a1)
{
  int v1;
  uint64_t v2;
  int v3;
  int v4;
  __int16 v5;
  unsigned int v6;

  v1 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  if (!v1)
  {
    LOWORD(v1) = *(_WORD *)(a1 + 440);
    if (!(_WORD)v1)
    {
      v2 = *(_QWORD *)(a1 + 56);
      v3 = *(_DWORD *)(v2 + 36);
      if (v3)
      {
        v4 = 0;
        LOWORD(v1) = 0;
        v5 = *(_WORD *)(v2 + 32);
        do
        {
          if ((v5 & 4) != 0)
            v6 = 0;
          else
            v6 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 376) + 8 * (unsigned __int16)v4 + 2);
          if (v6 > (unsigned __int16)v1 && v6 != 0xFFFF)
            LOWORD(v1) = v6;
          ++v4;
        }
        while (v3 != v4);
      }
      else
      {
        LOWORD(v1) = 0;
      }
      *(_WORD *)(a1 + 440) = v1;
    }
  }
  return (unsigned __int16)v1;
}

uint64_t bt_shift_or_split(_QWORD *a1, _QWORD *a2, unsigned int a3, _QWORD *a4, uint64_t a5, void *a6, unsigned int a7, uint64_t a8, __int16 *a9, __int16 *a10, unsigned __int16 a11, uint64_t a12, uint64_t a13, uint64_t *a14)
{
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  size_t v22;
  unsigned __int16 v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int16 v26;
  uint64_t v29;
  __int16 v30;
  __int16 v31;
  __int16 v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  __int16 v38;
  uint64_t v39;
  int v40;
  unsigned int v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  int v45;
  __int16 v46;
  int v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  int v52;
  int v53;
  __int16 v54;
  uint64_t v55;
  uint64_t v56;
  unsigned int v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  int v63;
  int v64;
  int v65;
  __int16 v66;
  unsigned int v67;
  int v68;
  int v69;
  unsigned int v70;
  BOOL v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t *v77;
  unint64_t v78;
  int v79;
  _QWORD *v80;
  unsigned int v81;
  uint64_t v82;
  int v83;
  unsigned __int16 v84;
  int v85;
  int v86;
  int v87;
  char v88;
  int v89;
  int v90;
  unsigned int v91;
  int v92;
  int v93;
  int v94;
  unsigned int v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t *v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  unsigned int v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  unint64_t *v109;
  unint64_t v110;
  _QWORD *v111;
  uint64_t v112;
  int v113;
  uint64_t v114;
  __int16 v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  int v122;
  int v123;
  int v124;
  int v125;
  unint64_t *v126;
  unint64_t v127;
  __int16 v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  const char *v134;
  uint64_t v135;
  int v136;
  __int16 v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  const char *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  const char *v146;
  uint64_t v147;
  uint64_t v148;
  const char *v149;
  unsigned int v150;
  uint64_t v151;
  uint64_t *v152;
  uint64_t v153;
  _QWORD *v154;
  uint64_t v155;
  const char *v156;
  void *v157;
  uint64_t v158;
  __int16 v159;
  uint64_t v160;
  uint64_t v161;
  _QWORD *v162;
  uint64_t v163;
  const char *v164;
  uint64_t v165;
  const char *v166;
  unint64_t *v167;
  size_t v168;
  uint64_t v169;
  const char *v170;
  int v171;
  int v172;
  unsigned int v173;
  uint64_t v174;
  _QWORD *v175;
  void *v176;
  unint64_t *v177;
  size_t v178;
  uint64_t v179;
  uint64_t v180;
  const char *v181;
  unint64_t *v182;
  unint64_t v183;
  _QWORD *v184;
  uint64_t v185;
  const char *v186;
  uint64_t v187;
  const char *v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  const char *v192;
  int v193;
  _QWORD *v194;
  _QWORD *v195;
  unsigned int v196;
  int v197;
  uint64_t v198;
  const char *v199;
  uint64_t v200;
  int v201;
  uint64_t v202;
  const char *v203;
  int v204;
  uint64_t v205;
  const char *v206;
  int v207;
  uint64_t v208;
  const char *v209;
  int v210;
  uint64_t v211;
  const char *v212;
  _QWORD *v213;
  uint64_t v214;
  int v215;
  char v216;
  uint64_t v217;
  const char *v218;
  int v219;
  uint64_t v220;
  const char *v221;
  uint64_t *v222;
  unint64_t *v223;
  unint64_t v224;
  uint64_t *v225;
  unint64_t *v226;
  unint64_t v227;
  uint64_t *v228;
  unint64_t *v229;
  unint64_t v230;
  unint64_t *v232;
  unint64_t v233;
  __int16 v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  const char *v241;
  uint64_t v242;
  uint64_t v243;
  unint64_t *v244;
  unint64_t v245;
  _BYTE v246[4];
  unsigned int v247;
  uint64_t *v248;
  _QWORD *v249;
  int v250;
  unsigned int v251;
  unsigned int v252;
  unsigned int v253;
  void *v254;
  unsigned int v255;
  int v256;
  uint64_t v257;
  int v258;
  int v259;
  _QWORD *v260;
  int v261;
  int v262;
  int v263;
  int v264;
  int v265;
  unsigned int v266;
  uint64_t v267;
  int v268;
  unsigned int v269;
  _BYTE *v270;
  uint64_t v271;
  int v272;
  int v273;
  _BOOL4 v274;
  _QWORD *v275;
  uint64_t v276;
  void *v277;
  uint64_t v278;
  _QWORD *v279;
  int v280;
  int v281;
  const void *v282;
  void *v283;
  uint64_t *v284;
  uint64_t *v285;
  uint64_t *v286;
  _OWORD v287[2];
  uint64_t v288;

  v255 = a7;
  v254 = a6;
  v19 = a13;
  v288 = *MEMORY[0x1E0C80C00];
  v279 = a1;
  MEMORY[0x1E0C80A78]();
  v21 = &v246[-v20];
  bzero(&v246[-v20], v22);
  LODWORD(v277) = 0;
  memset(v287, 0, sizeof(v287));
  v285 = 0;
  v286 = 0;
  v283 = 0;
  v284 = 0;
  v282 = 0;
  v280 = 0;
  v281 = 0;
  if ((*(_WORD *)(a4[7] + 32) & 4) != 0)
    LODWORD(v277) = (a4[50] & 4) == 0;
  v270 = v279 + 50;
  *a14 = 0;
  v253 = a3;
  v248 = a14;
  if (a2 && *(_DWORD *)(a2[7] + 36) - 1 > a3)
  {
    v23 = a3 + 1;
    if (btree_node_child_val((uint64_t)a2, v23, v21)
      || btree_node_get(v279, v21, a12, 3, *(_WORD *)(a2[7] + 34) - 1, a13, (uint64_t *)&v286)
      || (v24 = (uint64_t)v286) == 0)
    {
      v24 = 0;
      v286 = 0;
    }
    else if ((*v270 & 0x10) != 0 && v286[14] != *v21)
    {
      btree_node_child_id_update((uint64_t)a2, v23, v286 + 14, a13);
    }
  }
  else
  {
    v24 = 0;
  }
  *(_OWORD *)((char *)v287 + 8) = *(_OWORD *)v270;
  *((_QWORD *)&v287[1] + 1) = a4[52];
  LODWORD(v287[0]) = 2123139;
  v25 = a4[7];
  WORD2(v287[0]) = *(_WORD *)(v25 + 32) & 0x1A;
  WORD3(v287[0]) = *(_WORD *)(v25 + 34);
  v26 = 0;
  if ((_DWORD)a8)
  {
    v29 = a8;
    do
    {
      v31 = *a9++;
      v30 = v31;
      if ((a4[50] & 0x40) != 0)
      {
        v32 = *a10;
      }
      else
      {
        v30 = (v30 + 7) & 0xFFF8;
        v32 = (*a10 + 7) & 0xFFF8;
      }
      v26 += v30 + v32;
      ++a10;
      --v29;
    }
    while (v29);
  }
  v249 = v21;
  v33 = *(_DWORD *)(v25 + 36);
  v260 = a2;
  if (v33 > a5)
  {
    v34 = btree_node_key_ptr((uint64_t)a4, a5, &v283, (_WORD *)&v280 + 1);
    if ((_DWORD)v34)
      return v34;
    v35 = v279[1];
    if (!v35)
      v35 = *(_QWORD *)(*v279 + 392);
    v34 = ((uint64_t (*)(uint64_t, void *, _QWORD, void *, _QWORD, int *))v279[52])(v35, v254, v255, v283, HIWORD(v280), &v281);
    if ((_DWORD)v34)
      return v34;
    if (v281)
    {
      v266 = 0;
      v263 = 0;
      v36 = 0;
      a2 = v260;
    }
    else
    {
      a2 = v260;
      if ((*(_WORD *)(a4[7] + 32) & 2) != 0)
      {
        v171 = btree_node_val_len((uint64_t)a4, a5);
        if (v171 == 65534)
          v172 = 0;
        else
          v172 = v171;
        LOWORD(v280) = v172;
        if ((a4[50] & 0x40) != 0)
          v173 = HIWORD(v280);
        else
          v173 = (HIWORD(v280) + 7) & 0xFFFFFFF8;
        if ((a4[50] & 0x40) == 0)
          v172 = (v172 + 7) & 0x1FFF8;
        v266 = v173 + v172;
        v263 = 1;
      }
      else
      {
        v266 = 0;
        v263 = 0;
      }
      v36 = 1;
    }
  }
  else
  {
    v266 = 0;
    v263 = 0;
    v36 = 0;
  }
  v274 = v24 == 0;
  v267 = a13;
  v275 = a4;
  if (!v24)
  {
    v106 = obj_flags((uint64_t)a4) & 0xFFFFFC00;
    v107 = v279[1];
    if (!v107)
      v107 = *(_QWORD *)(*v279 + 392);
    v108 = obj_subtype((uint64_t)a4);
    v34 = btree_node_create(v107, v106, v108, v287, a13, &v286);
    if ((_DWORD)v34)
      return v34;
    v109 = (unint64_t *)(v279[49] + 32);
    a2 = v260;
    do
      v110 = __ldxr(v109);
    while (__stxr(v110 + 1, v109));
    v111 = v279;
    obj_dirty((uint64_t)v279, a13, 0);
    if ((v111[50] & 2) != 0 || v279[54] == a4[14])
    {
      v112 = a4[7];
      if (*(_DWORD *)(v112 + 36) == (_DWORD)a5)
      {
        v113 = 0;
        LODWORD(a8) = 0;
        v40 = a5 + ((*(unsigned __int16 *)(v112 + 32) >> 1) & 1) - 1;
        v274 = 1;
        goto LABEL_146;
      }
    }
  }
  v37 = a4[7];
  v38 = *(_WORD *)(v37 + 32);
  v261 = btree_node_toc_required_capacity((uint64_t)a4, 0);
  if ((v38 & 4) != 0)
    v39 = 2;
  else
    v39 = 3;
  v40 = *(_DWORD *)(v37 + 36);
  if (((v40 - 1) & 0x8000) != 0)
  {
    v113 = 0;
    goto LABEL_146;
  }
  v250 = v26;
  v41 = a11 + v26;
  v247 = v36 + a5;
  v42 = a8;
  v43 = (__int16)(v40 - 1);
  v44 = (uint64_t)v286;
  v268 = btree_node_free_space_total((uint64_t)v286);
  v278 = v44;
  v269 = btree_node_toc_required_capacity(v44, 0) << v39;
  v258 = btree_node_free_space_total((uint64_t)a4);
  LOWORD(v44) = 0;
  v272 = 0;
  v256 = v263 ^ 1;
  v262 = v42;
  v45 = v263;
  v252 = v41;
  v276 = v41;
  v19 = v267;
  v271 = v39;
  while (1)
  {
    v265 = v40;
    v46 = v42 - v45;
    v47 = btree_node_toc_required_capacity((uint64_t)a4, (__int16)(v42 - v45));
    v48 = v258 + (unsigned __int16)v266 + (__int16)((v261 - v47) << v39);
    v49 = (__int16)(v258 + v266 + ((v261 - v47) << v39) - v276);
    v50 = (int)v277;
    if (v48 < (unsigned __int16)v276)
      v50 = 0;
    v273 = v45;
    if (v50 == 1)
    {
      v51 = *(_DWORD *)(a4[7] + 36) - (__int16)v45 + (__int16)v42;
      if (v51 >= btree_node_toc_required_capacity((uint64_t)a4, 0))
        goto LABEL_32;
    }
    else if (v48 < (unsigned __int16)v276)
    {
LABEL_32:
      v52 = v272;
      goto LABEL_41;
    }
    if (!v274)
      goto LABEL_143;
    if ((*v270 & 2) != 0 || v279[54] == a4[14])
    {
      if ((*(_WORD *)(a4[7] + 32) & 2) != 0)
        goto LABEL_143;
      if (!(_WORD)v43)
        goto LABEL_143;
      v52 = v272;
      if ((unsigned __int16)(v272 + *(_WORD *)(*(_QWORD *)(v278 + 56) + 36)) > 1u)
        goto LABEL_143;
      v53 = btree_node_toc_required_capacity(v278, (__int16)v272);
      v54 = v268 + v269 + v44 - (v53 << v39);
      if (v49 >= (__int16)(v54 + ((v54 >> 29) & 3)) >> 2)
        goto LABEL_143;
    }
    else if ((_DWORD)v277)
    {
      if (!(_WORD)v43)
        goto LABEL_143;
      v84 = v46 + *(_WORD *)(a4[7] + 36);
      v52 = v272;
      if (v84 <= (unsigned __int16)(v272 + *(_WORD *)(*(_QWORD *)(v278 + 56) + 36)))
        goto LABEL_143;
    }
    else
    {
      v52 = v272;
      v105 = btree_node_toc_required_capacity(v278, (__int16)v272);
      if (!(_WORD)v43 || v49 >= (__int16)(v268 + v269 + v44 - (v105 << v39)))
        goto LABEL_143;
    }
LABEL_41:
    v264 = v49;
    v55 = v42;
    v56 = a5;
    v57 = (unsigned __int16)v43;
    v58 = a4[7];
    v59 = *(unsigned __int16 *)(v58 + 32);
    v259 = v59;
    if ((v59 & 2) == 0 || v256 + (unsigned __int16)v43 != (_DWORD)v56)
    {
      v79 = v276;
      if ((v59 & 4) == 0)
        goto LABEL_56;
      goto LABEL_72;
    }
    v60 = v56;
    v251 = (unsigned __int16)v43;
    v257 = v58;
    v61 = v264;
    v42 = v55;
    v62 = v19;
    v63 = v262;
    v64 = v52 + v262;
    v65 = btree_node_toc_required_capacity(v278, (__int16)(v52 + v262));
    v66 = v268;
    v67 = (v65 << v271) - v269;
    v68 = v250 + WORD2(v276) + (__int16)(((_WORD)v65 << v271) - v269);
    v69 = (int)v277;
    if (v68 > (unsigned __int16)v268)
      v69 = 0;
    if (v69 == 1)
    {
      v70 = v63 + (__int16)v52 + *(_DWORD *)(*(_QWORD *)(v278 + 56) + 36);
      v71 = v70 >= btree_node_toc_required_capacity(v278, 0);
      v19 = v267;
      if (v71)
        goto LABEL_48;
    }
    else
    {
      v19 = v62;
      if (v68 > (unsigned __int16)v268)
      {
LABEL_48:
        a5 = v60;
        if (!v274)
        {
          a4 = v275;
          v72 = obj_flags((uint64_t)v275);
          v73 = v278;
          obj_unlock(v278, 2);
          obj_release(v73);
          v286 = 0;
          v74 = v279[1];
          v40 = v265;
          if (!v74)
            v74 = *(_QWORD *)(*v279 + 392);
          v75 = obj_subtype((uint64_t)a4);
          v76 = btree_node_create(v74, v72 & 0xFFFFFC00, v75, v287, v19, &v286);
          v45 = v273;
          if ((_DWORD)v76)
            return v76;
          v77 = (unint64_t *)(v279[49] + 32);
          do
            v78 = __ldxr(v77);
          while (__stxr(v78 + 1, v77));
          goto LABEL_100;
        }
        if (v263)
          LOWORD(v43) = v265 - 2;
        if (v61 < 0)
        {
          LOWORD(v40) = v43 + 1;
          v113 = 2834;
LABEL_136:
          v114 = v257;
          goto LABEL_137;
        }
LABEL_128:
        v274 = 1;
LABEL_142:
        a4 = v275;
LABEL_143:
        v113 = 0;
        LOWORD(v40) = v43 + 1;
LABEL_144:
        LODWORD(a8) = v42;
LABEL_145:
        a2 = v260;
        goto LABEL_146;
      }
    }
    v42 = (v42 - v262);
    a5 = v60;
    if (!v274)
    {
      v274 = 0;
      if (v263)
        LOWORD(v43) = v265 - 2;
      goto LABEL_142;
    }
    v83 = v61;
    v58 = v257;
    if ((*v270 & 2) != 0 || v279[54] == v275[14])
    {
LABEL_126:
      if (v263)
        LOWORD(v43) = v265 - 2;
      goto LABEL_128;
    }
    v79 = v276 - v252;
    HIDWORD(v276) += v252;
    if ((_DWORD)v277)
    {
      if (!(_WORD)v43
        || (unsigned __int16)(v42 - v273 + *(_WORD *)(v257 + 36)) <= (unsigned __int16)(v64 + *(_WORD *)(*(_QWORD *)(v278 + 56) + 36)))
      {
        goto LABEL_126;
      }
    }
    else if (!(_WORD)v43 || v83 >= (__int16)(v66 - WORD2(v276) - v67))
    {
      goto LABEL_126;
    }
    v55 = v42;
    v56 = a5;
    v52 = v64;
    v57 = v251;
    if ((v259 & 4) == 0)
    {
LABEL_56:
      v80 = v275;
      v81 = *(unsigned __int16 *)(v275[47] + 8 * (unsigned __int16)v43 + 2);
      v82 = v275[50];
      goto LABEL_73;
    }
LABEL_72:
    v80 = v275;
    v82 = v275[50];
    v81 = (v82 >> 9) & 0x3FFF;
LABEL_73:
    HIWORD(v280) = v81;
    v85 = btree_node_val_len((uint64_t)v80, (unsigned __int16)v43);
    if (v85 == 65534)
      v86 = 0;
    else
      v86 = v85;
    LOWORD(v280) = v86;
    v87 = (v81 + 7) & 0x1FFF8;
    if ((v82 & 0x40) != 0)
      v87 = v81;
    else
      v86 = (v86 + 7) & 0x1FFF8;
    v88 = v263;
    if ((unsigned __int16)v43 != (_DWORD)v56)
      v88 = 0;
    v272 = v52;
    if ((v88 & 1) == 0)
      break;
    LODWORD(v276) = v79;
    v40 = v43;
    v19 = v267;
    a4 = v275;
    LOBYTE(v39) = v271;
    v45 = v273;
    a5 = v56;
    v42 = v55;
LABEL_106:
    LODWORD(v44) = -HIDWORD(v276);
    v43 = (__int16)(v40 - 1);
    if (((v40 - 1) & 0x8000) != 0)
    {
      v113 = 0;
      goto LABEL_144;
    }
  }
  v257 = v58;
  v89 = v87 + v86;
  if ((unsigned __int16)v55 != 0 && v247 > v57)
    v90 = v262;
  else
    v90 = 0;
  if ((unsigned __int16)v55 != 0 && v247 > v57)
    v91 = v252;
  else
    v91 = 0;
  LODWORD(v39) = v52 + v90 + 1;
  v92 = btree_node_toc_required_capacity(v278, (__int16)(v52 + v90 + 1));
  v93 = (unsigned __int16)v91 + WORD2(v276) + (unsigned __int16)v89 + (__int16)((v92 << v271) - v269);
  v94 = (int)v277;
  if (v93 > (unsigned __int16)v268)
    v94 = 0;
  if (v94 == 1)
  {
    v95 = v90 + (__int16)v52 + *(_DWORD *)(*(_QWORD *)(v278 + 56) + 36) + 1;
    v71 = v95 >= btree_node_toc_required_capacity(v278, 0);
    a5 = v56;
    v42 = v55;
    if (!v71)
      goto LABEL_102;
  }
  else
  {
    a5 = v56;
    v42 = v55;
    if (v93 <= (unsigned __int16)v268)
    {
LABEL_102:
      HIDWORD(v276) += v91 + v89;
      v42 = (v42 - v90);
      if (v90)
        v104 = v91;
      else
        v104 = 0;
      LODWORD(v276) = v79 - v104;
      v45 = v273 + 1;
      v266 += v89;
      v40 = v43;
      v272 = v39;
      v19 = v267;
      a4 = v275;
      LOBYTE(v39) = v271;
      goto LABEL_106;
    }
  }
  if (!v274)
  {
    LODWORD(v276) = v79;
    a4 = v275;
    v96 = obj_flags((uint64_t)v275);
    v97 = v278;
    obj_unlock(v278, 2);
    obj_release(v97);
    v286 = 0;
    v98 = v279[1];
    v19 = v267;
    if (!v98)
      v98 = *(_QWORD *)(*v279 + 392);
    v99 = obj_subtype((uint64_t)a4);
    v76 = btree_node_create(v98, v96 & 0xFFFFFC00, v99, v287, v19, &v286);
    v40 = v265;
    v45 = v273;
    if ((_DWORD)v76)
      return v76;
    v100 = (unint64_t *)(v279[49] + 32);
    do
      v101 = __ldxr(v100);
    while (__stxr(v101 + 1, v100));
LABEL_100:
    obj_dirty((uint64_t)v279, v19, 0);
    v102 = (uint64_t)v286;
    v103 = btree_node_toc_required_capacity((uint64_t)v286, 0);
    LOBYTE(v39) = v271;
    v269 = v103 << v271;
    v278 = v102;
    v268 = btree_node_free_space_total(v102);
    v274 = 1;
    goto LABEL_106;
  }
  v19 = v267;
  if ((v264 & 0x80000000) == 0)
    goto LABEL_239;
  v113 = 2908;
  if ((__int16)v265 > 1)
  {
    LOWORD(v40) = v265;
    goto LABEL_136;
  }
  v114 = v257;
  if ((v259 & 2) == 0)
  {
LABEL_239:
    v113 = 0;
    v274 = 1;
    LODWORD(a8) = v42;
    a4 = v275;
    a2 = v260;
    LOWORD(v40) = v265;
    goto LABEL_146;
  }
  LOWORD(v40) = v265;
LABEL_137:
  if (*(unsigned __int16 *)(v114 + 36) == (unsigned __int16)v40 && v278)
  {
    v274 = 0;
    v284 = (uint64_t *)v278;
    v286 = 0;
    LODWORD(a8) = v42;
    a4 = v275;
    goto LABEL_145;
  }
  LODWORD(a8) = v42;
  v234 = v40;
  a4 = v275;
  v235 = obj_flags((uint64_t)v275) & 0xFFFFFC00;
  v236 = v279[1];
  if (!v236)
    v236 = *(_QWORD *)(*v279 + 392);
  v237 = obj_subtype((uint64_t)a4);
  v238 = btree_node_create(v236, v235, v237, v287, v19, &v284);
  if ((_DWORD)v238)
  {
    v34 = v238;
    v277 = 0;
    v278 = 0;
    LOWORD(v120) = 0;
    v121 = 0;
    LOWORD(v122) = 0;
    v123 = 0;
    v276 = 0;
    v124 = 0;
    v125 = 0;
    v273 = 0;
    v274 = 1;
    goto LABEL_264;
  }
  v244 = (unint64_t *)(v279[49] + 32);
  do
    v245 = __ldxr(v244);
  while (__stxr(v245 + 1, v244));
  obj_dirty((uint64_t)v279, v19, 0);
  v274 = 1;
  a2 = v260;
  LOWORD(v40) = v234;
LABEL_146:
  if (!a2 && (v113 != 0 || v274))
  {
    v115 = v40;
    v116 = obj_flags((uint64_t)a4) & 0xFFFFFC00;
    v117 = v279[1];
    if (!v117)
      v117 = *(_QWORD *)(*v279 + 392);
    v118 = obj_subtype((uint64_t)a4);
    v119 = btree_node_create(v117, v116, v118, v287, v19, &v285);
    if ((_DWORD)v119)
    {
      v34 = v119;
      v277 = 0;
      v278 = 0;
      LOWORD(v120) = 0;
      v121 = 0;
      LOWORD(v122) = 0;
      v123 = 0;
      v276 = 0;
      v124 = 0;
      v273 = 0;
      v125 = 0;
      v260 = 0;
      goto LABEL_264;
    }
    v126 = (unint64_t *)(v279[49] + 32);
    a2 = v260;
    do
      v127 = __ldxr(v126);
    while (__stxr(v127 + 1, v126));
    obj_dirty((uint64_t)v279, v19, 0);
    LOWORD(v40) = v115;
  }
  v128 = v40;
  if ((__int16)v40 <= (int)a5)
    v129 = v263;
  else
    v129 = 0;
  v130 = a4[7];
  if (v129 == 1)
  {
    v120 = *(_DWORD *)(v130 + 36) + ~(_DWORD)a5;
    if (v120 << 16 < 1)
      goto LABEL_181;
    v131 = (uint64_t)v286;
    v132 = bt_move_entries((uint64_t)a4, (uint64_t)v286, (__int16)v120, v19);
    if ((_DWORD)v132)
    {
      v34 = v132;
      v133 = v279[1];
      if (v133)
        v134 = (const char *)(v133 + 3880);
      else
        v134 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
      log_err("%s:%d: %s bt_move_entries %d failed: %d\n", "bt_shift_or_split", 3014, v134, 0, v132);
      v277 = 0;
      v278 = 0;
      LOWORD(v120) = 0;
LABEL_263:
      v121 = 0;
      LOWORD(v122) = 0;
      v123 = 0;
      v276 = 0;
      v124 = 0;
      v273 = 0;
      v125 = 0;
      goto LABEL_264;
    }
    if (v274)
    {
LABEL_181:
      v150 = a5;
      LODWORD(v271) = 1;
      v272 = v120;
      v135 = v19;
      v136 = 0;
    }
    else
    {
      v34 = btree_node_key_ptr(v131, 0, &v283, (_WORD *)&v280 + 1);
      if ((_DWORD)v34
        || (v34 = btree_node_entry_update((int)v260, (unsigned __int16)(v253 + 1), v283, HIWORD(v280), 0), (_DWORD)v34))
      {
        v169 = v279[1];
        if (v169)
          v170 = (const char *)(v169 + 3880);
        else
          v170 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
        log_err("%s:%d: %s btree_node_key_update failed: %d\n", "bt_shift_or_split", 3022, v170, v34);
        v274 = 0;
        v277 = 0;
        v278 = 0;
        goto LABEL_263;
      }
      v150 = a5;
      LODWORD(v271) = 1;
      v272 = v120;
      v135 = v19;
      v136 = 1;
    }
    v151 = btree_node_val_ptr(a4, v150, &v282, (__int16 *)&v280);
    if ((_DWORD)v151)
    {
      v34 = v151;
      LODWORD(v276) = 0;
      HIDWORD(v276) = v136;
      v277 = 0;
      v278 = 0;
      v121 = 0;
      LOWORD(v122) = 0;
      v123 = 0;
      v124 = 0;
      v273 = 0;
      v125 = 0;
LABEL_184:
      LOWORD(v120) = v272;
      goto LABEL_264;
    }
    v277 = 0;
    v278 = (unsigned __int16)v280;
    if ((_WORD)v280)
    {
      a2 = v260;
      if ((unsigned __int16)v280 != 65534)
      {
        v157 = _apfs_malloc(v278);
        if (!v157)
        {
          LODWORD(v276) = 0;
          HIDWORD(v276) = v136;
          v277 = 0;
          v278 = 0;
          v121 = 0;
          LOWORD(v122) = 0;
          v123 = 0;
          v124 = 0;
          v273 = 0;
          v125 = 0;
          v34 = 12;
          goto LABEL_184;
        }
        v277 = v157;
        memcpy(v157, v282, (unsigned __int16)v280);
        v278 = (unsigned __int16)v280;
      }
    }
    else
    {
      a2 = v260;
    }
    v262 = a8;
    btree_node_remove((uint64_t)a4, v150, v135);
    v182 = (unint64_t *)(v279[49] + 24);
    do
      v183 = __ldxr(v182);
    while (__stxr(v183 - 1, v182));
    obj_dirty((uint64_t)v279, v135, 0);
    v130 = a4[7];
  }
  else
  {
    LODWORD(v271) = v129;
    v135 = v19;
    v262 = a8;
    v277 = 0;
    v278 = 0;
    v272 = 0;
    v136 = 0;
  }
  v137 = *(_WORD *)(v130 + 36) - v128;
  v121 = v137;
  HIDWORD(v276) = v136;
  if (v137 < 1)
  {
    LODWORD(v276) = 0;
LABEL_169:
    v273 = 0;
    goto LABEL_170;
  }
  v138 = (uint64_t)v286;
  v139 = bt_move_entries((uint64_t)a4, (uint64_t)v286, v137, v135);
  if ((_DWORD)v139)
  {
    v34 = v139;
    v140 = v279[1];
    if (v140)
      v141 = (const char *)(v140 + 3880);
    else
      v141 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
    log_err("%s:%d: %s bt_move_entries %d failed: %d\n", "bt_shift_or_split", 3059, v141, v121, v139);
    v121 = 0;
    goto LABEL_254;
  }
  if (!v274)
  {
    v34 = btree_node_key_ptr(v138, 0, &v283, (_WORD *)&v280 + 1);
    if ((_DWORD)v34
      || (v34 = btree_node_entry_update((int)v260, (unsigned __int16)(v253 + 1), v283, HIWORD(v280), 0), (_DWORD)v34))
    {
      v165 = v279[1];
      if (v165)
        v166 = (const char *)(v165 + 3880);
      else
        v166 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
      log_err("%s:%d: %s btree_node_key_update failed: %d\n", "bt_shift_or_split", 3067, v166, v34);
      v274 = 0;
LABEL_254:
      LOWORD(v122) = 0;
      v123 = 0;
      LODWORD(v276) = 0;
LABEL_255:
      v273 = 0;
LABEL_259:
      v125 = 0;
LABEL_260:
      LOWORD(v120) = v272;
      v124 = v271;
      goto LABEL_264;
    }
  }
  LODWORD(v276) = !v274;
  a2 = v260;
  if (!v260 || *(_DWORD *)(a4[7] + 36))
    goto LABEL_169;
  v147 = btree_node_entry_update((int)v260, v253, v254, v255, 0);
  if ((_DWORD)v147)
  {
    v34 = v147;
    v148 = v279[1];
    if (v148)
      v149 = (const char *)(v148 + 3880);
    else
      v149 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
    log_err("%s:%d: %s btree_node_key_update failed: %d\n", "bt_shift_or_split", 3078, v149, v147);
    LOWORD(v122) = 0;
    v123 = 0;
    goto LABEL_255;
  }
  v273 = 1;
  a2 = v260;
LABEL_170:
  v142 = (uint64_t)v285;
  if (v285)
  {
    v143 = a4[7];
    v122 = *(_DWORD *)(v143 + 36);
    v144 = bt_move_entries((uint64_t)v285, (uint64_t)a4, (__int16)-*(_WORD *)(v143 + 36), v135);
    if ((_DWORD)v144)
    {
      v34 = v144;
      v145 = v279[1];
      if (v145)
        v146 = (const char *)(v145 + 3880);
      else
        v146 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
      log_err("%s:%d: %s bt_move_entries %d failed: %d\n", "bt_shift_or_split", 3094, v146, -(__int16)v122, v144);
      LOWORD(v122) = 0;
LABEL_258:
      v123 = 0;
      goto LABEL_259;
    }
    btree_node_reinit_root((uint64_t)a4, (unsigned __int16)(*(_WORD *)(a4[7] + 34) + 1), v135);
    if (*(_DWORD *)(*(_QWORD *)(v142 + 56) + 36))
    {
      v34 = btree_node_key_ptr(v142, 0, &v283, (_WORD *)&v280 + 1);
      if (!(_DWORD)v34)
      {
        v167 = (unint64_t *)v283;
        v168 = HIWORD(v280);
        goto LABEL_249;
      }
      goto LABEL_250;
    }
    v167 = (unint64_t *)v254;
    v283 = v254;
    v168 = v255;
    HIWORD(v280) = v255;
LABEL_249:
    v184 = v249;
    *v249 = *(_QWORD *)(v142 + 112);
    v34 = btree_node_insert(a4, v167, v168, v184, (*((_WORD *)a4 + 203) & 0x7Fu) + 8, v135, 0, 0);
    if ((_DWORD)v34)
    {
LABEL_250:
      v185 = v279[1];
      if (v185)
        v186 = (const char *)(v185 + 3880);
      else
        v186 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
      log_err("%s:%d: %s btree_node_insert failed: %d\n", "bt_shift_or_split", 3117, v186, v34);
      goto LABEL_258;
    }
    a2 = a4;
  }
  else
  {
    LOWORD(v122) = 0;
  }
  if (v274 && (v152 = v286) != 0)
  {
    v153 = v286[7];
    if (*(_DWORD *)(v153 + 36))
    {
      v260 = a2;
      v34 = btree_node_key_ptr((uint64_t)v286, 0, &v283, (_WORD *)&v280 + 1);
      if ((_DWORD)v34
        || (v154 = v249,
            *v249 = v152[14],
            v34 = btree_node_insert(v260, (unint64_t *)v283, HIWORD(v280), v154, (*((_WORD *)v260 + 203) & 0x7Fu) + 8, v135, 0, 0), (_DWORD)v34))
      {
        v155 = v279[1];
        if (v155)
          v156 = (const char *)(v155 + 3880);
        else
          v156 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
        log_err("%s:%d: %s btree_node_insert failed: %d\n", "bt_shift_or_split", 3133, v156, v34);
        v123 = 0;
        v125 = 0;
        v274 = 1;
        goto LABEL_260;
      }
      v125 = 1;
      a2 = v260;
    }
    else
    {
      if ((*(_WORD *)(v153 + 32) & 2) != 0)
      {
        v284 = v286;
        v113 = 1;
      }
      else
      {
        v232 = (unint64_t *)(v279[49] + 32);
        do
          v233 = __ldxr(v232);
        while (__stxr(v233 - 1, v232));
        obj_delete_and_free(v152, v135);
        obj_unlock((uint64_t)v152, 2);
        obj_release(v152);
      }
      v125 = 0;
      v286 = 0;
    }
  }
  else
  {
    v125 = 0;
  }
  if (!v113)
  {
    if ((_WORD)v262)
    {
      v174 = (uint64_t)v286;
      v175 = v279;
      v176 = v277;
      if (v142)
        v286 = (uint64_t *)v142;
      else
        v286 = 0;
    }
    else
    {
      v174 = 0;
      v175 = v279;
      v176 = v277;
    }
    if (!v274)
      goto LABEL_356;
    goto LABEL_355;
  }
  if (v142)
    v158 = v142;
  else
    v158 = (uint64_t)a4;
  v159 = *(_WORD *)(*(_QWORD *)(v158 + 56) + 32);
  v260 = a2;
  if ((v159 & 2) != 0)
  {
    v123 = 0;
    v177 = (unint64_t *)v254;
    v283 = v254;
    v178 = v255;
    HIWORD(v280) = v255;
    v160 = (uint64_t)v284;
    v162 = v249;
    LOWORD(v120) = v272;
    v124 = v271;
LABEL_241:
    *v162 = *(_QWORD *)(v160 + 112);
    v179 = btree_node_insert(a2, v177, v178, v162, (*((_WORD *)a2 + 203) & 0x7Fu) + 8, v267, 0, 0);
    if ((_DWORD)v179)
    {
      v34 = v179;
      v180 = v279[1];
      if (v180)
        v181 = (const char *)(v180 + 3880);
      else
        v181 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
      log_err("%s:%d: %s btree_node_insert failed: %d\n", "bt_shift_or_split", 3177, v181, v179);
      goto LABEL_264;
    }
    v174 = (uint64_t)v286;
    v286 = (uint64_t *)v160;
    v175 = v279;
    a4 = v275;
    a2 = v260;
    v176 = v277;
LABEL_355:
    bt_update_last_leaf((uint64_t)v175, (uint64_t)a2, (uint64_t)a4);
LABEL_356:
    if (v176)
      _apfs_free(v176, v278);
    if (v174)
    {
      obj_unlock(v174, 2);
      obj_release(v174);
    }
    v242 = (uint64_t)v285;
    v243 = (uint64_t)v286;
    if (v285 && v286 != v285)
    {
      obj_unlock((uint64_t)v285, 2);
      obj_release(v242);
    }
    v34 = 0;
    *v248 = v243;
    return v34;
  }
  v160 = (uint64_t)v284;
  v161 = bt_move_entries(v158, (uint64_t)v284, 1, v267);
  v162 = v249;
  LOWORD(v120) = v272;
  v124 = v271;
  if ((_DWORD)v161)
  {
    v34 = v161;
    v163 = v279[1];
    if (v163)
      v164 = (const char *)(v163 + 3880);
    else
      v164 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
    log_err("%s:%d: %s bt_move_entries %d failed: %d\n", "bt_shift_or_split", 3160, v164, 1, v161);
    goto LABEL_385;
  }
  v239 = btree_node_key_ptr(v160, 0, &v283, (_WORD *)&v280 + 1);
  if (!(_DWORD)v239)
  {
    v177 = (unint64_t *)v283;
    v123 = 1;
    v178 = HIWORD(v280);
    a2 = v260;
    goto LABEL_241;
  }
  v34 = v239;
  v240 = v279[1];
  if (v240)
    v241 = (const char *)(v240 + 3880);
  else
    v241 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
  log_err("%s:%d: %s failed to get newnode minkey: %d\n", "bt_shift_or_split", 3165, v241, v239);
LABEL_385:
  v123 = 0;
LABEL_264:
  v187 = v279[1];
  if (v187)
    v188 = (const char *)(v187 + 3880);
  else
    v188 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
  log_err("%s:%d: %s reverting on error: %d\n", "bt_shift_or_split", 3213, v188, v34);
  if (v125)
    btree_node_remove((uint64_t)v260, (unsigned __int16)(v253 + 1), v267);
  v189 = v267;
  if (v123)
  {
    v190 = bt_move_entries((uint64_t)v275, (uint64_t)v284, -1, v267);
    v34 = v190;
    if ((_DWORD)v190)
    {
      v191 = v279[1];
      if (v191)
        v192 = (const char *)(v191 + 3880);
      else
        v192 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
      log_err("%s:%d: %s bt_move_entries %d failed: %d\n", "bt_shift_or_split", 3220, v192, -1, v190);
    }
  }
  v193 = (__int16)v122;
  v194 = v275;
  v195 = v277;
  v196 = v278;
  if (v193 >= 1)
  {
    btree_node_reinit_root((uint64_t)v275, (unsigned __int16)(*(_WORD *)(v275[7] + 34) - 1), v189);
    v197 = bt_move_entries((uint64_t)v285, (uint64_t)v194, v193, v189);
    if (v197)
    {
      v198 = v279[1];
      if (v198)
        v199 = (const char *)(v198 + 3880);
      else
        v199 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
      log_err("%s:%d: %s bt_move_entries() failed (%d) while trying to revert changes due to error: %d\n", "bt_shift_or_split", 3230, v199, v197, v34);
    }
    v260 = 0;
  }
  if (v121 >= 1)
  {
    v200 = (uint64_t)v286;
    v201 = bt_move_entries((uint64_t)v194, (uint64_t)v286, (__int16)-(__int16)v121, v189);
    if (v201)
    {
      v202 = v279[1];
      if (v202)
        v203 = (const char *)(v202 + 3880);
      else
        v203 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
      log_err("%s:%d: %s bt_move_entries() failed (%d) while trying to revert changes due to error: %d\n", "bt_shift_or_split", 3237, v203, v201, v34);
    }
    if (!v274 && (v276 & 1) != 0)
    {
      v204 = btree_node_key_ptr(v200, 0, &v283, (_WORD *)&v280 + 1);
      if (v204
        || (v204 = btree_node_entry_update((int)v260, (unsigned __int16)(v253 + 1), v283, HIWORD(v280), 0)) != 0)
      {
        v205 = v279[1];
        if (v205)
          v206 = (const char *)(v205 + 3880);
        else
          v206 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
        log_err("%s:%d: %s btree_node_key_update() failed (%d) while trying to revert changes due to error: %d\n", "bt_shift_or_split", 3245, v206, v204, v34);
      }
    }
    if (v273)
    {
      v207 = btree_node_key_ptr((uint64_t)v194, 0, &v283, (_WORD *)&v280 + 1);
      if (v207 || (v207 = btree_node_entry_update((int)v260, v253, v283, HIWORD(v280), 0)) != 0)
      {
        v208 = v279[1];
        if (v208)
          v209 = (const char *)(v208 + 3880);
        else
          v209 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
        log_err("%s:%d: %s btree_node_key_update() failed (%d) while trying to revert changes due to error: %d\n", "bt_shift_or_split", 3254, v209, v207, v34);
      }
    }
  }
  if (v124)
  {
    v210 = btree_node_insert(v194, (unint64_t *)v254, v255, v195, v196, v189, 0, 0);
    if (v210)
    {
      v211 = v279[1];
      if (v211)
        v212 = (const char *)(v211 + 3880);
      else
        v212 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v279 + 392) + 384) + 208);
      log_err("%s:%d: %s btree_node_insert() failed (%d) while trying to revert changes due to error: %d\n", "bt_shift_or_split", 3261, v212, v210, v34);
    }
    if (v195)
      _apfs_free(v195, v196);
  }
  v213 = v279;
  if ((__int16)v120 >= 1)
  {
    v214 = (uint64_t)v286;
    v215 = bt_move_entries((uint64_t)v194, (uint64_t)v286, (__int16)-(__int16)v120, v189);
    v216 = BYTE4(v276);
    if (v215)
    {
      v217 = v213[1];
      if (v217)
        v218 = (const char *)(v217 + 3880);
      else
        v218 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v213 + 392) + 384) + 208);
      log_err("%s:%d: %s bt_move_entries() failed (%d) while trying to revert changes due to error: %d\n", "bt_shift_or_split", 3270, v218, v215, v34);
    }
    if (!v274 && (v216 & 1) != 0)
    {
      v219 = btree_node_key_ptr(v214, 0, &v283, (_WORD *)&v280 + 1);
      if (v219
        || (v219 = btree_node_entry_update((int)v260, (unsigned __int16)(v253 + 1), v283, HIWORD(v280), 0)) != 0)
      {
        v220 = v213[1];
        if (v220)
          v221 = (const char *)(v220 + 3880);
        else
          v221 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v213 + 392) + 384) + 208);
        log_err("%s:%d: %s btree_node_key_update() failed (%d) while trying to revert changes due to error: %d\n", "bt_shift_or_split", 3278, v221, v219, v34);
      }
    }
  }
  v222 = v286;
  if (v286)
  {
    if (!*(_DWORD *)(v286[7] + 36))
    {
      v223 = (unint64_t *)(v213[49] + 32);
      do
        v224 = __ldxr(v223);
      while (__stxr(v224 - 1, v223));
      obj_delete_and_free(v222, v189);
    }
    obj_unlock((uint64_t)v222, 2);
    obj_release(v222);
  }
  v225 = v284;
  if (v284)
  {
    v226 = (unint64_t *)(v213[49] + 32);
    do
      v227 = __ldxr(v226);
    while (__stxr(v227 - 1, v226));
    obj_delete_and_free(v225, v189);
    obj_unlock((uint64_t)v225, 2);
    obj_release(v225);
  }
  v228 = v285;
  if (v285)
  {
    v229 = (unint64_t *)(v213[49] + 32);
    do
      v230 = __ldxr(v229);
    while (__stxr(v230 - 1, v229));
    obj_delete_and_free(v228, v189);
    obj_unlock((uint64_t)v228, 2);
    obj_release(v228);
  }
  return v34;
}

uint64_t btree_node_insert(_QWORD *a1, unint64_t *a2, size_t a3, _QWORD *a4, unsigned int a5, uint64_t a6, unsigned __int16 *a7, _BYTE *a8)
{
  uint64_t v16;
  _QWORD *v17;
  size_t v18;
  uint64_t result;
  unint64_t v20;
  uint64_t v21;
  const char *v22;
  _BYTE v23[5];
  BOOL v24;
  unsigned __int16 v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78]();
  v17 = &v23[-v16];
  bzero(&v23[-v16], v18);
  v25 = 0;
  v24 = 0;
  result = bt_search_node_insert((uint64_t)a1, a2, a3, &v25, &v24);
  if (!(_DWORD)result)
  {
    if (a8)
      *a8 = v24;
    if (a7)
      *a7 = v25;
    if ((*(_WORD *)(a1[7] + 32) & 0xA) != 8)
      goto LABEL_9;
    v20 = a1[51];
    if (*a4 > v20)
    {
      *v17 = *a4 - v20;
      a4 = v17;
LABEL_9:
      if (v24)
        return btree_node_entry_update((int)a1, v25, a2, a3, a4);
      else
        return btree_node_insert_internal((uint64_t)a1, v25, a2, a3, a4, a5, a6);
    }
    v21 = a1[1];
    if (v21)
      v22 = (const char *)(v21 + 3880);
    else
      v22 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 384) + 208);
    log_err("%s:%d: %s invalid relative OID: %llu < root OID: %llu\n", "btree_node_insert", 2264, v22, *a4, v20);
    return 22;
  }
  return result;
}

uint64_t bt_update_with_hint(uint64_t *a1, uint64_t a2, unint64_t *a3, uint64_t a4, void *a5, unsigned int a6, uint64_t a7, uint64_t *a8)
{
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  _BOOL4 v21;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  _QWORD *v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  BOOL v31;
  unsigned int v32;
  int v33;
  uint64_t *v34;
  uint64_t v35;
  const void *v36;
  uint64_t v37;
  unsigned int v38;
  char v39;
  void *v40;
  uint64_t *v41;
  _BOOL4 v42;
  unint64_t *v43;
  unsigned __int16 v44;
  int v45;
  const void *v46;
  BOOL v47;
  unsigned __int16 v48;
  uint64_t *v49;
  uint64_t v50[2];

  v43 = a3;
  v50[1] = *MEMORY[0x1E0C80C00];
  v15 = a1[50];
  MEMORY[0x1E0C80A78]();
  v17 = (void **)((char *)&v40 - v16);
  bzero((char *)&v40 - v16, v18);
  v49 = 0;
  v48 = 0;
  if (!a1[52])
    return 22;
  v19 = btree_entry_size_check((uint64_t)a1, a4, a6);
  if (!(_DWORD)v19)
  {
    v19 = obj_modify(a1, (v15 >> 3) & 2, a7);
    if (!(_DWORD)v19)
    {
      v20 = a1[49];
      v21 = *(_DWORD *)(v20 + 16) < a4 || *(_DWORD *)(v20 + 20) < a6;
      v42 = v21;
      v50[0] = 0;
      v47 = 0;
      v40 = a5;
      v41 = a8;
      if (a8)
      {
        v23 = *a8;
        if (*a8)
        {
          if ((uint64_t *)a8[1] == a1 && ((v42 | ((a1[50] & 0x10) >> 4)) & 1) == 0)
          {
            *v17 = v23;
            if (v23 != obj_oid((uint64_t)a1)
              && !btree_node_get(a1, v17, a2, (a7 != 0) | (((*(unsigned __int16 *)(a1[7] + 32) >> 3) & 1) << 6) | 6u, 0, a7, v50))
            {
              v24 = (uint64_t *)v50[0];
              if ((*(_WORD *)(*(_QWORD *)(v50[0] + 56) + 32) & 2) != 0
                && !bt_search_node(v50[0], v43, (unsigned __int16)a4, &v48, &v47)
                && v47)
              {
                if ((*(_WORD *)(v24[7] + 32) & 2) == 0)
                  goto LABEL_53;
                goto LABEL_39;
              }
              obj_unlock((uint64_t)v24, 2);
              obj_release(v24);
            }
          }
        }
      }
      v19 = 2;
      obj_lock((uint64_t)a1, 2);
      obj_retain((char *)a1);
      v26 = a1 + 7;
      v25 = a1[7];
      if ((*(_WORD *)(v25 + 32) & 2) == 0)
      {
        v27 = 0;
        v28 = 2;
        v24 = a1;
        while (1)
        {
          if (!*(_DWORD *)(v25 + 36))
          {
            v19 = v28;
            goto LABEL_34;
          }
          v29 = bt_search_node((uint64_t)v24, v43, (unsigned __int16)a4, &v48, &v47);
          if ((_DWORD)v29
            || (v30 = v48, v29 = btree_node_child_val((uint64_t)v24, v48, v17), (_DWORD)v29)
            || (v29 = btree_node_get(a1, v17, a2, 3, *(_WORD *)(*v26 + 34) - 1, a7, (uint64_t *)&v49), (_DWORD)v29))
          {
            v19 = v29;
            v50[0] = (uint64_t)v24;
            goto LABEL_55;
          }
          if ((a1[50] & 0x10) != 0 && v49[14] != *v17)
            btree_node_child_id_update((uint64_t)v24, v30, v49 + 14, a7);
          v31 = v42;
          if (v24 != a1)
            v31 = 0;
          if (!v31)
          {
            obj_unlock((uint64_t)v24, 2);
            obj_release(v24);
          }
          v24 = v49;
          if (!v49)
            break;
          v28 = 0;
          v19 = 0;
          v26 = v49 + 7;
          v25 = v49[7];
          v27 = 1;
          if ((*(_WORD *)(v25 + 32) & 2) != 0)
            goto LABEL_34;
        }
        v50[0] = 0;
        goto LABEL_53;
      }
      v27 = 0;
      v24 = a1;
LABEL_34:
      v50[0] = (uint64_t)v24;
      if ((*(_WORD *)(v24[7] + 32) & 2) == 0)
      {
        if ((v27 & 1) == 0)
          goto LABEL_54;
        goto LABEL_53;
      }
      v19 = bt_search_node((uint64_t)v24, v43, (unsigned __int16)a4, &v48, &v47);
      if ((_DWORD)v19)
      {
LABEL_54:
        v24 = (uint64_t *)v50[0];
        if (v50[0])
        {
LABEL_55:
          obj_unlock((uint64_t)v24, 2);
          obj_release(v24);
        }
        v39 = !v42;
        if (v24 == a1)
          v39 = 1;
        if ((v39 & 1) == 0)
        {
          obj_unlock((uint64_t)a1, 2);
          obj_release(a1);
        }
        return v19;
      }
      if (!v47)
      {
LABEL_53:
        v19 = 2;
        goto LABEL_54;
      }
LABEL_39:
      v46 = 0;
      v45 = 0;
      v44 = 0;
      v32 = v48;
      v33 = btree_node_key_ptr((uint64_t)v24, v48, &v46, &v44);
      v34 = v41;
      if (!v33)
      {
        v35 = a1[1];
        if (!v35)
          v35 = *(_QWORD *)(*a1 + 392);
        v36 = v46;
        if (!((unsigned int (*)(uint64_t, const void *, _QWORD, unint64_t *, uint64_t, int *))a1[52])(v35, v46, v44, v43, a4, &v45)&& v45)
        {
          panic("you can't change a key here!  (ekey %p eklen %d; key %p klen %d; n %p bt %p)\n",
            v36,
            v44,
            v43,
            a4,
            v24,
            a1);
        }
      }
      v19 = btree_node_entry_update((uint64_t)v24, v32, v43, (unsigned __int16)a4, v40, (unsigned __int16)a6, a7);
      if ((_DWORD)v19)
        goto LABEL_54;
      v37 = a1[49];
      v38 = *(_DWORD *)(v37 + 16);
      if (v38 < a4)
        *(_DWORD *)(v37 + 16) = a4;
      if (*(_DWORD *)(v37 + 20) >= a6)
      {
        if (v38 >= a4 && (a1[50] & 0x80) == 0)
        {
LABEL_63:
          if (v34)
          {
            *v34 = obj_oid((uint64_t)v24);
            v34[1] = (uint64_t)a1;
          }
          goto LABEL_54;
        }
      }
      else
      {
        *(_DWORD *)(v37 + 20) = a6;
      }
      obj_dirty((uint64_t)a1, a7, 0);
      goto LABEL_63;
    }
  }
  return v19;
}

uint64_t bt_update(uint64_t *a1, uint64_t a2, unint64_t *a3, uint64_t a4, void *a5, unsigned int a6, uint64_t a7)
{
  return bt_update_with_hint(a1, a2, a3, a4, a5, a6, a7, 0);
}

uint64_t btree_node_entry_update_via_callback(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a10)
{
  uint64_t v10;
  __int16 v17;
  uint64_t v18;
  unsigned __int16 *v19;
  uint64_t v20;
  unsigned __int16 *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t result;
  int v26;
  int v28;

  v10 = *(_QWORD *)(a1 + 56);
  if (*(_DWORD *)(v10 + 36) <= a2)
    return 22;
  v17 = *(_WORD *)(v10 + 32);
  v18 = *(_QWORD *)(a1 + 376);
  if ((v17 & 4) != 0)
    v19 = (unsigned __int16 *)(v18 + 4 * a2);
  else
    v19 = (unsigned __int16 *)(v18 + 8 * a2);
  v20 = *v19;
  v21 = (unsigned __int16 *)(v18 + 4 * a2 + 2);
  if ((v17 & 4) == 0)
    v21 = (unsigned __int16 *)(v18 + 8 * a2 + 4);
  v22 = *v21;
  if (v20 == 0xFFFF)
  {
    v23 = 0;
  }
  else if ((v17 & 4) != 0)
  {
    v23 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  }
  else
  {
    v23 = *(unsigned __int16 *)(v18 + 8 * a2 + 2);
  }
  if (v22 > 0xFFFD)
  {
    v24 = 0;
    if (!(_DWORD)v23)
      goto LABEL_17;
  }
  else
  {
    v24 = btree_node_val_len(a1, a2);
    if (!(_DWORD)v23)
      goto LABEL_17;
  }
  result = btree_node_key_range_validate(a1, v20, v23);
  if ((_DWORD)result)
    return result;
LABEL_17:
  if (!(_DWORD)v24)
  {
    if ((_DWORD)v20 != 0xFFFF)
    {
LABEL_27:
      if (v24 >= a6)
        v28 = 1;
      else
        v28 = a7;
      result = 22;
      if ((_DWORD)v23 == (_DWORD)a4 && v28)
      {
        result = a9(*(_QWORD *)(a1 + 384) + v20, v23, a3, a4, *(_QWORD *)(a1 + 392) - v22, v24, a5, a6, a10);
        if (!(_DWORD)result)
        {
          obj_dirty(a1, a8, 0);
          return 0;
        }
      }
      return result;
    }
    return 22;
  }
  LODWORD(result) = btree_node_val_range_validate(a1, v22, v24);
  v26 = result;
  if ((_DWORD)result)
    result = result;
  else
    result = 22;
  if ((_DWORD)v20 != 0xFFFF && v26 == 0)
    goto LABEL_27;
  return result;
}

uint64_t bt_remove_internal(uint64_t a1, uint64_t a2, int a3, unint64_t *a4, unsigned int a5, void *a6, unsigned int *a7, void *a8, unsigned int *a9, uint64_t a10)
{
  uint64_t v18;
  _QWORD *v19;
  size_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  BOOL v33;
  BOOL *v34;
  uint64_t v35;
  __int16 v36;
  __int16 v37;
  __int16 v38;
  __int16 v39;
  _QWORD *v40;
  unsigned __int16 v41;
  unint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t *v50;
  uint64_t v51;
  BOOL v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int v66;
  unsigned int *v67;
  unsigned int v68;
  size_t v69;
  BOOL v70;
  uint64_t v71;
  unsigned int v72;
  unsigned int v73;
  unsigned int *v74;
  unsigned int v75;
  size_t v76;
  unint64_t *v77;
  unint64_t v78;
  BOOL v79;
  int is_underused;
  uint64_t v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  const char *v86;
  uint64_t v87;
  uint64_t v88;
  const char *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t *v94;
  uint64_t v95;
  unsigned int v96;
  int v97;
  uint64_t v98;
  const char *v99;
  __int16 v100;
  uint64_t v101;
  const char *v102;
  uint64_t v103;
  int v104;
  uint64_t v105;
  unint64_t *v106;
  unsigned __int16 v107;
  unsigned __int16 v108;
  uint64_t v109;
  unint64_t *v110;
  uint64_t v111;
  uint64_t v112;
  unsigned int *v113;
  unsigned int *v114;
  BOOL *v115;
  _WORD *v116;
  BOOL *v117;
  _WORD *v118;
  int v119;
  int v120;
  void *v121;
  uint64_t *v122;
  uint64_t v123;
  void *v124;
  __int128 *v125;
  _WORD *v126;
  unint64_t *v127;
  int v128;
  uint64_t v129;
  int v130;
  uint64_t v131;
  BOOL *v132;
  __int16 v133;
  __int16 v134;
  uint64_t v135;
  unsigned __int16 v136;
  int v137;
  unsigned __int16 v138;
  const void *v139;
  const void *v140;
  unint64_t *v141;
  uint64_t v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  uint64_t v146;

  v146 = *MEMORY[0x1E0C80C00];
  v144 = 0u;
  v145 = 0u;
  v143 = 0u;
  v142 = 0;
  MEMORY[0x1E0C80A78]();
  v19 = (uint64_t *)((char *)&v111 - v18);
  bzero((char *)&v111 - v18, v20);
  v140 = 0;
  v141 = 0;
  v139 = 0;
  v138 = a5;
  v137 = 0;
  v136 = 0;
  if (!*(_QWORD *)(a1 + 416))
    return 22;
  v21 = *(_QWORD *)(a1 + 400);
  v22 = (v21 >> 9) & 0x3FFF;
  if (!v22)
  {
    if (((unsigned __int16)((((v21 >> 27) & 0xF000) - 160) & 0xFFE0) >> 2) - 72 >= a5)
      goto LABEL_4;
    return 22;
  }
  if ((_DWORD)v22 != a5)
    return 22;
LABEL_4:
  v128 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 392) + 16);
  v124 = a8;
  v131 = a2;
  obj_lock(a1, 2);
  v23 = obj_modify(a1, (*(_DWORD *)(a1 + 400) >> 3) & 2, a10);
  if ((_DWORD)v23)
  {
    v24 = v23;
    obj_unlock(a1, 2);
    return v24;
  }
  v121 = a6;
  v123 = a10;
  v122 = &v111;
  *(_QWORD *)&v143 = a1;
  obj_retain((char *)a1);
  v26 = btri_search_node(a1, a3, 1, a4, &v138, (unsigned __int16)a5, (_WORD *)&v143 + 4, (BOOL *)((unint64_t)&v143 | 0xA));
  if ((_DWORD)v26)
  {
LABEL_10:
    v24 = v26;
    goto LABEL_11;
  }
  v132 = (BOOL *)((unint64_t)&v143 | 0xA);
  v126 = (_WORD *)&v143 + 4;
  v27 = 0;
  v129 = 0;
  v120 = 0;
  v29 = 0;
  v113 = a9;
  v118 = (_WORD *)&v144 + 4;
  v119 = (v128 + 7) & 0x1FFF8;
  v125 = &v145;
  v116 = (_WORD *)&v145 + 4;
  v117 = (BOOL *)&v144 + 10;
  v115 = (BOOL *)&v145 + 10;
  v127 = a4;
  v30 = v123;
  v114 = a7;
  v31 = v121;
  while (1)
  {
    if ((v29 & 1) != 0)
    {
      v130 = 1;
      v32 = v144;
    }
    else
    {
      v32 = v144;
      if (BYTE10(v143))
        v33 = WORD4(v143) == 0;
      else
        v33 = 0;
      if (v33)
      {
        v120 = WORD4(v144);
        v130 = 1;
        v27 = v143;
        v129 = v144;
      }
      else
      {
        v130 = 0;
      }
    }
    v34 = v132;
    if (!v32 || (*(_DWORD *)(a1 + 400) & 0x7FFE00) != 0)
      goto LABEL_94;
    v135 = 0;
    if (BYTE10(v143))
    {
      v35 = btree_node_key_ptr(v32, WORD4(v144), &v141, &v136);
      if ((_DWORD)v35)
        goto LABEL_106;
      v36 = v128;
      if ((*(_QWORD *)(v144 + 400) & 0x40) == 0)
        v36 = v119;
      v37 = v136;
      if ((*(_QWORD *)(v144 + 400) & 0x40) == 0)
        v37 = (v136 + 7) & 0xFFF8;
      v38 = v36 - v37;
      if (v38 < 0)
        v39 = 0;
      else
        v39 = v38;
    }
    else
    {
      v39 = 0;
    }
    v134 = btree_node_largest_key_len(v143);
    v40 = (_QWORD *)v144;
    v133 = (*(_WORD *)(v143 + 406) & 0x7F) + 8;
    if (btree_node_has_room(v144, 1u, &v134, &v133, v39, 0, 0))
    {
      v30 = v123;
LABEL_36:
      v34 = v132;
      goto LABEL_94;
    }
    v41 = WORD4(v144);
    if (!BYTE10(v144))
      v41 = WORD4(v144) + 1;
    v42 = a4;
    v43 = v138;
    v35 = bt_shift_or_split((_QWORD *)a1, (_QWORD *)v145, WORD4(v145), v40, v41, v42, v138, 1, &v134, &v133, v39, v131, v123, &v135);
    if ((_DWORD)v35)
    {
LABEL_106:
      v24 = v35;
      goto LABEL_107;
    }
    v44 = v135;
    v34 = v132;
    if (!v135)
    {
      a4 = v127;
      v30 = v123;
      goto LABEL_94;
    }
    v45 = v144;
    v30 = v123;
    v112 = v144;
    if ((_QWORD)v145)
    {
      ++WORD4(v145);
      if ((_QWORD)v144)
      {
        if (v129 == (_QWORD)v144 || (_QWORD)v144 == v27)
        {
          v49 = v144;
        }
        else
        {
          v46 = v135;
          v47 = v144;
          obj_unlock(v144, 2);
          v48 = v47;
          v44 = v46;
          obj_release(v48);
          v49 = 0;
        }
      }
      else
      {
        v49 = 0;
      }
      goto LABEL_58;
    }
    *(_QWORD *)&v145 = v144;
    if (*(_DWORD *)(*(_QWORD *)(v135 + 56) + 36))
    {
      v111 = v135;
      v35 = btree_node_key_ptr(v135, 0, &v141, &v136);
      if ((_DWORD)v35)
        goto LABEL_106;
      v45 = v145;
      v50 = v141;
      v51 = v136;
    }
    else
    {
      if ((a3 & 1) != 0)
      {
        if (!*(_DWORD *)(*(_QWORD *)(v144 + 56) + 36))
          goto LABEL_149;
        v49 = 0;
        WORD4(v145) = 0;
        BYTE10(v145) = 1;
        goto LABEL_58;
      }
      v111 = v135;
      v50 = v127;
      v51 = v43;
    }
    v24 = bt_search_node(v45, v50, v51, v116, v115);
    if ((_DWORD)v24)
      goto LABEL_107;
    v49 = 0;
    v44 = v111;
LABEL_58:
    v52 = v129 != (_QWORD)v145 || v129 == 0;
    v53 = v120;
    if (!v52)
      v53 = WORD4(v145);
    v120 = v53;
    *(_QWORD *)&v144 = v44;
    if (a3)
    {
      if (!*(_DWORD *)(*(_QWORD *)(v44 + 56) + 36))
      {
LABEL_149:
        v24 = 2;
LABEL_107:
        v142 = v27;
LABEL_108:
        v28 = v129;
        goto LABEL_109;
      }
      WORD4(v144) = 0;
      BYTE10(v144) = 1;
    }
    else
    {
      v35 = bt_search_node(v44, v127, v43, v118, v117);
      if ((_DWORD)v35)
        goto LABEL_106;
    }
    v54 = v143;
    obj_unlock(v143, 2);
    obj_release(v54);
    *(_QWORD *)&v143 = 0;
    v35 = btree_node_child_val(v144, WORD4(v144), v19);
    if ((_DWORD)v35)
      goto LABEL_106;
    v35 = btree_node_get((_QWORD *)a1, v19, v131, 3, *(_WORD *)(*(_QWORD *)(v144 + 56) + 34) - 1, v30, (uint64_t *)&v143);
    if ((_DWORD)v35)
      goto LABEL_106;
    v55 = v143;
    if ((*(_BYTE *)(a1 + 400) & 0x10) != 0)
    {
      a4 = v127;
      if (*(_QWORD *)(v143 + 112) != *v19)
      {
        btree_node_child_id_update(v144, WORD4(v144), (uint64_t *)(v143 + 112), v30);
        v55 = v143;
      }
    }
    else
    {
      a4 = v127;
    }
    v35 = btri_search_node(v55, a3, 1, a4, &v138, (unsigned __int16)a5, v126, v132);
    if ((_DWORD)v35)
      goto LABEL_106;
    if (v129 == v112)
    {
      v58 = WORD4(v144);
      v56 = v49;
      if (v129 == a1 && !WORD4(v144))
      {
        v27 = v144;
        v129 = a1;
        v34 = v132;
        v31 = v121;
        goto LABEL_94;
      }
      v57 = v130;
      v31 = v121;
      if (!WORD4(v144))
      {
        v120 = WORD4(v145);
        goto LABEL_85;
      }
      goto LABEL_89;
    }
    v56 = v49;
    if ((v130 & 1) != 0)
    {
      v57 = 1;
      v31 = v121;
      goto LABEL_90;
    }
    v58 = WORD4(v144);
    v31 = v121;
    if (BYTE10(v144) && !WORD4(v144))
    {
      v120 = WORD4(v145);
      v57 = 1;
LABEL_85:
      v129 = v145;
      v27 = v144;
      goto LABEL_90;
    }
    v57 = 0;
    if (BYTE10(v143) && !WORD4(v143))
    {
      v57 = 1;
LABEL_89:
      v129 = v144;
      v27 = v143;
      v120 = v58;
    }
LABEL_90:
    v130 = v57;
    if (!v56)
      goto LABEL_36;
    v34 = v132;
    if (v56 != v129 && v56 != v27)
    {
      obj_unlock(v56, 2);
      obj_release(v56);
      goto LABEL_36;
    }
LABEL_94:
    if ((*(_WORD *)(*(_QWORD *)(v143 + 56) + 32) & 2) != 0)
      break;
    v59 = v145;
    if ((_QWORD)v145 && (_QWORD)v145 != v129 && (_QWORD)v145 != v27)
    {
      obj_unlock(v145, 2);
      obj_release(v59);
    }
    *v125 = v144;
    v144 = v143;
    *(_QWORD *)&v143 = 0;
    v35 = btree_node_child_val(v144, WORD4(v144), v19);
    if (!(_DWORD)v35)
    {
      v35 = btree_node_get((_QWORD *)a1, v19, v131, 3, *(_WORD *)(*(_QWORD *)(v144 + 56) + 34) - 1, v30, (uint64_t *)&v143);
      if (!(_DWORD)v35)
      {
        v60 = v143;
        if ((*(_BYTE *)(a1 + 400) & 0x10) != 0)
        {
          a4 = v127;
          if (*(_QWORD *)(v143 + 112) != *v19)
          {
            btree_node_child_id_update(v144, WORD4(v144), (uint64_t *)(v143 + 112), v30);
            v60 = v143;
          }
        }
        else
        {
          a4 = v127;
        }
        v35 = btri_search_node(v60, a3, 1, a4, &v138, (unsigned __int16)a5, v126, v132);
        v29 = v130;
        if (!(_DWORD)v35)
          continue;
      }
    }
    goto LABEL_106;
  }
  v142 = v27;
  v65 = btri_search_node(v143, a3, 1, a4, &v138, (unsigned __int16)a5, v126, v34);
  if ((_DWORD)v65)
    goto LABEL_136;
  if (!BYTE10(v143))
  {
    v24 = 2;
    goto LABEL_108;
  }
  if (!v31)
    goto LABEL_146;
  v65 = btree_node_key_ptr(v143, 0, &v140, (_WORD *)&v137 + 1);
  if ((_DWORD)v65)
  {
LABEL_136:
    v24 = v65;
    goto LABEL_108;
  }
  v66 = HIWORD(v137);
  v67 = v114;
  v68 = *v114;
  if (*v114 >= HIWORD(v137))
    v69 = HIWORD(v137);
  else
    v69 = v68;
  memcpy(v31, v140, v69);
  *v67 = v66;
  v70 = v68 >= v66;
  v30 = v123;
  if (!v70)
  {
    v24 = 34;
    goto LABEL_108;
  }
LABEL_146:
  v28 = v129;
  if (v124)
  {
    v71 = btree_node_val_ptr((_QWORD *)v143, 0, &v139, (__int16 *)&v137);
    if ((_DWORD)v71)
      goto LABEL_148;
    v72 = (unsigned __int16)v137;
    v73 = (unsigned __int16)v137 == 65534 ? 0 : (unsigned __int16)v137;
    v74 = v113;
    v75 = *v113;
    v76 = *v113 >= v73 ? v73 : v75;
    memcpy(v124, v139, v76);
    *v74 = v72;
    v30 = v123;
    if (v75 < v73)
    {
      v24 = 34;
      goto LABEL_109;
    }
  }
  btree_node_remove(v143, WORD4(v143), v30);
  v77 = (unint64_t *)(*(_QWORD *)(a1 + 392) + 24);
  do
    v78 = __ldxr(v77);
  while (__stxr(v78 - 1, v77));
  obj_dirty(a1, v30, 0);
  if (WORD4(v143) || (*(_DWORD *)(*(_QWORD *)(v143 + 56) + 36) ? (v79 = (_QWORD)v144 == 0) : (v79 = 1), v79))
  {
    v24 = 0;
  }
  else
  {
    v87 = btree_node_key_ptr(v143, 0, &v141, &v136);
    v24 = v87;
    if ((_DWORD)v87 || (v24 = btree_node_entry_update(v144, WORD4(v144), v141, v136, 0), (_DWORD)v24))
    {
      v88 = *(_QWORD *)(a1 + 8);
      if (v88)
        v89 = (const char *)(v88 + 3880);
      else
        v89 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
      log_err("%s:%d: %s btree_node_key_update failed: %d\n", "bt_remove_internal", 5056, v89, v24);
    }
    v28 = v129;
  }
  is_underused = btree_node_is_underused(a1, v143);
  v81 = v145;
  v82 = v130;
  if ((_QWORD)v145)
  {
    if ((_QWORD)v145 != v28 && (_QWORD)v145 != v27)
    {
      obj_unlock(v145, 2);
      obj_release(v81);
      v82 = v130;
    }
    *(_QWORD *)&v145 = 0;
  }
  v83 = v144;
  if ((_QWORD)v144)
  {
    if ((_QWORD)v144 != v28 && (_QWORD)v144 != v27)
    {
      obj_unlock(v144, 2);
      obj_release(v83);
      v82 = v130;
    }
    *(_QWORD *)&v144 = 0;
  }
  if (v82 && *(_DWORD *)(*(_QWORD *)(v143 + 56) + 36))
  {
    v71 = btree_node_key_ptr(v143, 0, &v141, &v136);
    if ((_DWORD)v71)
    {
LABEL_148:
      v24 = v71;
      goto LABEL_109;
    }
    if (v28)
    {
      v84 = btree_node_entry_update(v129, (unsigned __int16)v120, v141, v136, 0);
      v24 = v84;
      if ((_DWORD)v84)
      {
        v85 = *(_QWORD *)(a1 + 8);
        if (v85)
          v86 = (const char *)(v85 + 3880);
        else
          v86 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
        log_err("%s:%d: %s btree_node_key_update failed: %d\n", "bt_remove_internal", 5082, v86, v84);
      }
      if (v129 != (_QWORD)v145 && v129 != (_QWORD)v144 && v129 != (_QWORD)v143)
      {
        v90 = v129;
        obj_unlock(v129, 2);
        obj_release(v90);
      }
    }
    else
    {
      v24 = 0;
    }
    v91 = v142;
    v92 = v142 + 56;
    if ((*(_WORD *)(*(_QWORD *)(v142 + 56) + 32) & 2) == 0)
    {
      v93 = v138;
      v94 = v141;
      while (1)
      {
        LOWORD(v135) = 0;
        LOBYTE(v134) = 0;
        v27 = v91;
        v95 = bt_search_node(v91, v127, v93, &v135, (BOOL *)&v134);
        if ((_DWORD)v95)
        {
          v24 = v95;
          goto LABEL_12;
        }
        if (!(_BYTE)v134)
          break;
        if (*(_WORD *)(*(_QWORD *)v92 + 34) == 1)
        {
          v101 = *(_QWORD *)(a1 + 8);
          if (v101)
            v102 = (const char *)(v101 + 3880);
          else
            v102 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
          v103 = obj_oid(v27);
          v104 = obj_subtype(v27);
          log_err("%s:%d: %s minkey update traversal unexpectedly found the removed key in level 1 node; oid %llu subtype 0x%x level %d\n",
            "bt_remove_internal",
            5105,
            v102,
            v103,
            v104,
            *(unsigned __int16 *)(*(_QWORD *)v92 + 34));
          break;
        }
        v96 = (unsigned __int16)v135;
        v97 = btree_node_entry_update(v27, (unsigned __int16)v135, v94, v136, 0);
        if (v97)
        {
          v98 = *(_QWORD *)(a1 + 8);
          if (v98)
            v99 = (const char *)(v98 + 3880);
          else
            v99 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
          log_err("%s:%d: %s btree_node_key_update failed: %d\n", "bt_remove_internal", 5111, v99, v97);
        }
        v24 = btree_node_child_val(v27, v96, v19);
        v100 = *(_WORD *)(*(_QWORD *)v92 + 34);
        v142 = 0;
        if (!(_DWORD)v24)
          v24 = btree_node_get((_QWORD *)a1, v19, v131, 3, v100 - 1, v123, &v142);
        if (v27 != (_QWORD)v145 && v27 != (_QWORD)v144 && v27 != (_QWORD)v143)
        {
          obj_unlock(v27, 2);
          obj_release(v27);
        }
        if (!(_DWORD)v24)
        {
          v91 = v142;
          v92 = v142 + 56;
          if ((*(_WORD *)(*(_QWORD *)(v142 + 56) + 32) & 2) == 0)
            continue;
        }
        goto LABEL_227;
      }
      v24 = 0;
    }
  }
  else if (v28 && v28 != (_QWORD)v145 && v28 != (_QWORD)v143)
  {
    obj_unlock(v28, 2);
    obj_release(v28);
  }
LABEL_227:
  v105 = v142;
  if (v142)
  {
    if (v142 != (_QWORD)v145 && v142 != (_QWORD)v144 && v142 != (_QWORD)v143)
    {
      obj_unlock(v142, 2);
      obj_release(v105);
    }
    v142 = 0;
  }
  if (!is_underused)
  {
    v106 = 0;
    v108 = 0;
    goto LABEL_240;
  }
  if (WORD4(v143) || !*(_DWORD *)(*(_QWORD *)(v143 + 56) + 36))
  {
    v106 = 0;
    v107 = 0;
    goto LABEL_236;
  }
  v26 = btree_node_key_ptr(v143, 0, &v141, &v136);
  if ((_DWORD)v26)
    goto LABEL_10;
  v107 = v136;
  v110 = (unint64_t *)_apfs_malloc(v136);
  v106 = v110;
  if (v110)
    memcpy(v110, v141, v136);
  v24 = 0;
LABEL_236:
  if (v106)
  {
    v108 = v107;
  }
  else
  {
    v106 = v127;
    v108 = v138;
  }
LABEL_240:
  v109 = v143;
  obj_unlock(v143, 2);
  obj_release(v109);
  *(_QWORD *)&v143 = 0;
  if (is_underused)
  {
    bt_merge_up(a1, v131, v106, v108, v123);
    if (v106 != v127)
      _apfs_free(v106, v108);
  }
LABEL_11:
  v27 = 0;
LABEL_12:
  v28 = 0;
LABEL_109:
  v61 = v145;
  if ((_QWORD)v145)
  {
    if ((_QWORD)v145 != v28 && (_QWORD)v145 != v27)
    {
      obj_unlock(v145, 2);
      obj_release(v61);
    }
    *(_QWORD *)&v145 = 0;
  }
  v63 = v144;
  if ((_QWORD)v144)
  {
    if ((_QWORD)v144 != v28 && (_QWORD)v144 != v27)
    {
      obj_unlock(v144, 2);
      obj_release(v63);
    }
    *(_QWORD *)&v144 = 0;
  }
  v64 = v143;
  if ((_QWORD)v143)
  {
    if ((_QWORD)v143 != v28 && (_QWORD)v143 != v27)
    {
      obj_unlock(v143, 2);
      obj_release(v64);
    }
    *(_QWORD *)&v143 = 0;
  }
  if (v28 && v28 != (_QWORD)v145 && v28 != (_QWORD)v144)
  {
    obj_unlock(v28, 2);
    obj_release(v28);
    v27 = v142;
  }
  if (v27 && v27 != (_QWORD)v145 && v27 != (_QWORD)v144 && v27 != (_QWORD)v143)
  {
    obj_unlock(v27, 2);
    obj_release(v27);
  }
  return v24;
}

uint64_t btri_search_node(uint64_t a1, char a2, int a3, unint64_t *a4, _WORD *a5, unsigned int a6, _WORD *a7, BOOL *a8)
{
  uint64_t v10;
  size_t v12;
  unsigned __int16 v14;
  void *__src;

  if ((a2 & 1) == 0)
    return bt_search_node(a1, a4, (unsigned __int16)*a5, a7, a8);
  if (!*(_DWORD *)(*(_QWORD *)(a1 + 56) + 36))
    return 2;
  v10 = 0;
  *a7 = 0;
  *a8 = 1;
  if (a3)
  {
    __src = 0;
    v14 = 0;
    v10 = btree_node_key_ptr(a1, 0, &__src, &v14);
    if (!(_DWORD)v10)
    {
      if (v14 >= a6)
        v12 = a6;
      else
        v12 = v14;
      *a5 = v12;
      memcpy(a4, __src, v12);
    }
  }
  return v10;
}

void btree_node_remove(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned __int16 *v10;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int16 v15;
  int v16;
  unsigned __int16 v17;
  _WORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int16 *v22;
  unint64_t v23;
  unsigned __int16 v24;
  unsigned __int16 v25;
  int v26;
  unsigned __int16 v27;
  _WORD *v28;
  unsigned int v29;
  __int16 v30;
  unsigned int v31;
  unsigned int v32;
  __int16 v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unsigned __int16 v37;
  int v38;
  __int16 v39;
  unsigned __int16 v40;
  uint64_t v41;

  v6 = *(_QWORD *)(a1 + 56);
  v7 = *(_WORD *)(v6 + 32) & 4;
  if (v7)
    v8 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  else
    v8 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 376) + 8 * a2 + 2);
  if (*(unsigned __int16 *)(a1 + 440) <= v8)
  {
    *(_WORD *)(a1 + 440) = 0;
    v7 = *(_WORD *)(v6 + 32) & 4;
  }
  v9 = *(_QWORD *)(a1 + 376);
  v10 = (unsigned __int16 *)(v9 + 4 * a2);
  v11 = (unsigned __int16 *)(v9 + 8 * a2);
  if (v7)
    v12 = v10;
  else
    v12 = v11;
  v13 = *v12;
  v14 = *(_QWORD *)(a1 + 400);
  if ((v14 & 0x40) != 0)
    v15 = v8;
  else
    v15 = (v8 + 7) & 0xFFF8;
  if (v13 != 0xFFFF)
  {
    v16 = btree_node_key_range_validate(a1, v13, v15);
    v6 = *(_QWORD *)(a1 + 56);
    v14 = *(_QWORD *)(a1 + 400);
    if (!v16)
    {
      v17 = (v15 + 7) & 0xFFF8;
      if ((v14 & 0x40) != 0)
        v17 = v15;
      if (v17 >= 4u)
      {
        v18 = (_WORD *)(*(_QWORD *)(a1 + 384) + v13);
        v18[1] = v17;
        *v18 = *(_WORD *)(v6 + 48);
        *(_WORD *)(v6 + 48) = v13;
      }
      *(_WORD *)(v6 + 50) += v17;
      v14 = *(_QWORD *)(a1 + 400);
    }
  }
  v19 = *(_QWORD *)(a1 + 376);
  v20 = v19 + 4 * a2 + 2;
  v21 = v19 + 8 * a2 + 4;
  if ((*(_WORD *)(v6 + 32) & 4) != 0)
    v22 = (unsigned __int16 *)v20;
  else
    v22 = (unsigned __int16 *)v21;
  v23 = *v22;
  v24 = btree_node_val_len(a1, a2);
  if ((v14 & 0x40) != 0)
    v25 = v24;
  else
    v25 = (v24 + 7) & 0xFFF8;
  if (v23 <= 0xFFFD)
  {
    v26 = btree_node_val_range_validate(a1, v23, v25);
    v6 = *(_QWORD *)(a1 + 56);
    if (!v26)
    {
      if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
        v27 = v25;
      else
        v27 = (v25 + 7) & 0xFFF8;
      if (v27 >= 4u)
      {
        v28 = (_WORD *)(*(_QWORD *)(a1 + 392) - v23);
        v28[1] = v27;
        *v28 = *(_WORD *)(v6 + 52);
        *(_WORD *)(v6 + 52) = v23;
      }
      *(_WORD *)(v6 + 54) += v27;
    }
  }
  v29 = *(_DWORD *)(v6 + 36) - 1;
  if (v29 > a2)
  {
    btree_node_toc_shift(a1, a2, -1);
    v6 = *(_QWORD *)(a1 + 56);
    v29 = *(_DWORD *)(v6 + 36) - 1;
  }
  *(_DWORD *)(v6 + 36) = v29;
  v30 = *(_WORD *)(v6 + 32);
  if ((v30 & 4) != 0)
  {
    if ((*(_BYTE *)(a1 + 400) & 4) == 0)
      goto LABEL_50;
    v31 = 4;
  }
  else
  {
    v31 = 8;
  }
  v32 = *(unsigned __int16 *)(v6 + 42) / v31;
  if (v32 - v29 >= 0x10)
  {
    if ((v30 & 4) == 0)
    {
      v33 = 8;
LABEL_49:
      v40 = v33 * v31;
      memmove((void *)(*(_QWORD *)(a1 + 384) - (unsigned __int16)(v33 * v31)), *(const void **)(a1 + 384), *(unsigned __int16 *)(v6 + 44));
      *(_QWORD *)(a1 + 384) -= v40;
      v41 = *(_QWORD *)(a1 + 56);
      *(_WORD *)(v41 + 42) -= v40;
      *(_WORD *)(v41 + 46) += v40;
      goto LABEL_50;
    }
    v34 = *(_QWORD *)(a1 + 400);
    if ((v30 & 2) != 0)
      v35 = v34 >> 23;
    else
      LODWORD(v35) = (HIWORD(v34) & 0x7F) + 8;
    v36 = (((v34 >> 27) & 0x1F000) - 56) / (((v34 >> 9) & 0x3FFF) + (unsigned __int16)v35 + 4);
    if (v32 > (v36 & 0xFFFE))
    {
      v37 = v36 & 0xFFFE;
      v38 = v32 - 8;
      v39 = v32 - v37;
      if (v38 >= v37)
        v33 = 8;
      else
        v33 = v39;
      goto LABEL_49;
    }
  }
LABEL_50:
  obj_dirty(a1, a3, 0);
}

uint64_t btree_node_is_underused(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;
  __int16 v7;
  __int16 v8;

  v2 = *(_QWORD *)(a2 + 56);
  v3 = *(unsigned __int16 *)(v2 + 32);
  if ((~v3 & 3) == 0)
    return 0;
  v4 = *(_DWORD *)(v2 + 36);
  if (!v4)
    return 1;
  if (*(_QWORD *)(a1 + 432) == *(_QWORD *)(a2 + 112))
    return 0;
  if ((v3 & 4) != 0 && (*(_BYTE *)(a2 + 400) & 4) == 0)
    return v4 < *(unsigned __int16 *)(v2 + 42) >> 3;
  v7 = obj_size_phys(a2);
  if ((*(_WORD *)(*(_QWORD *)(a2 + 56) + 32) & 1) != 0)
    v8 = -96;
  else
    v8 = -56;
  return btree_node_free_space_total(a2) > (unsigned __int16)((v8 + v7) & 0xFFFE) >> 1;
}

void bt_merge_up(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  _QWORD *v10;
  size_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  uint64_t *v22;
  unsigned __int16 v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int16 *v29;
  int v30;
  int v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  void *v36;
  int v37;
  uint64_t v38;
  const char *v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _WORD *v45;
  BOOL v46;
  int v47;
  int v48;
  uint64_t v49;
  void *v50;
  _QWORD v51[2];
  _OWORD v52[4];
  uint64_t v53;

  v44 = a2;
  v53 = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78]();
  v10 = (uint64_t *)((char *)&v42 - v9);
  bzero((char *)&v42 - v9, v11);
  v12 = *(_QWORD *)(a1 + 56);
  if (v12)
  {
    memset(v52, 0, sizeof(v52));
    v13 = *(unsigned __int16 *)(v12 + 34);
    if (v13 >= 6)
    {
      v14 = v13 + 11;
      v16 = (unsigned __int16)(v13 + 11);
      v15 = (uint64_t *)_apfs_malloc(8 * v16);
      v45 = _apfs_malloc(2 * v16);
    }
    else
    {
      v14 = 8;
      v45 = v51;
      v15 = (uint64_t *)v52;
    }
    obj_lock(a1, 2);
    if (obj_modify(a1, (*(_DWORD *)(a1 + 400) >> 3) & 2, a5))
    {
      obj_unlock(a1, 2);
      return;
    }
    v51[0] = 0;
    v51[1] = 0;
    v47 = 0;
    v48 = 0;
    *v15 = a1;
    obj_retain((char *)a1);
    LOWORD(v17) = 0;
    v18 = *v15;
    if ((*(_WORD *)(*(_QWORD *)(*v15 + 56) + 32) & 2) == 0)
    {
      v19 = 0;
      v17 = 0;
      v49 = 0;
      v50 = 0;
      v46 = 0;
      v20 = v14;
      v43 = v14;
      if ((v14 & 0xFFFE) == 0)
        v20 = 1;
      v21 = (unsigned __int16)(v20 - 1);
      v22 = v15 + 1;
      do
      {
        if (bt_search_node(v18, a3, a4, &v45[v19], &v46))
          goto LABEL_64;
        if (v21 == v17)
        {
          LOWORD(v14) = v43;
          LOWORD(v17) = v43 - 1;
          goto LABEL_65;
        }
        *v10 = 0;
        if (btree_node_child_val(*(v22 - 1), (unsigned __int16)v45[v17], v10)
          || btree_node_get((_QWORD *)a1, v10, v44, 3, *(_WORD *)(*(_QWORD *)(*(v22 - 1) + 56) + 34) - 1, a5, v22))
        {
          goto LABEL_64;
        }
        v18 = *v22;
        if ((*(_BYTE *)(a1 + 400) & 0x10) != 0 && *(_QWORD *)(v18 + 112) != *v10)
        {
          btree_node_child_id_update(*(v22 - 1), (unsigned __int16)v45[v17], (uint64_t *)(v18 + 112), a5);
          v18 = *v22;
        }
        ++v19;
        ++v22;
        ++v17;
      }
      while ((*(_WORD *)(*(_QWORD *)(v18 + 56) + 32) & 2) == 0);
      if ((_WORD)v17)
      {
        v23 = v17;
        LOWORD(v14) = v43;
        while (1)
        {
          v24 = ((__int16)v23 - 1);
          if ((__int16)v23 < 1)
            break;
          if ((int)v17 <= (__int16)v23)
            v25 = 0;
          else
            v25 = v15[(__int16)v23 + 1];
          bt_merge_nodes(a1, v15[v24], (unsigned __int16)v45[v24], v15[v23], (unsigned __int16)v45[v23], v25, v44, a5);
          v26 = *(_DWORD *)(*(_QWORD *)(v15[v23] + 56) + 36);
          if ((__int16)v23 < 2 || v26)
          {
            if (v26)
            {
              if (btree_node_key_ptr(v15[v24], (unsigned __int16)v45[v24], &v49, &v47))
                goto LABEL_65;
              v48 = 0;
              if (btree_node_key_ptr(v15[v23], 0, &v50, (_WORD *)&v47 + 1))
                goto LABEL_65;
              v35 = *(_QWORD *)(a1 + 8);
              if (!v35)
                v35 = *(_QWORD *)(*(_QWORD *)a1 + 392);
              v36 = v50;
              v37 = (*(uint64_t (**)(uint64_t, void *, _QWORD, uint64_t, _QWORD, int *))(a1 + 416))(v35, v50, HIWORD(v47), v49, (unsigned __int16)v47, &v48);
              if (!v37 && v48)
                v37 = btree_node_entry_update(v15[v24], (unsigned __int16)v45[v24], v36, HIWORD(v47), 0);
              if (v37)
                goto LABEL_65;
            }
          }
          else if (!v45[v24])
          {
            v27 = (unsigned __int16)(v23 - 1);
            if (v23 != 1)
            {
              v28 = v15[(unsigned __int16)(v23 - 1)];
              if (*(_DWORD *)(*(_QWORD *)(v28 + 56) + 36))
              {
                v29 = &v45[v27];
                v30 = v27 - 1;
                --v23;
                while (1)
                {
                  if (*v29--)
                    goto LABEL_25;
                  v32 = btree_node_key_ptr(v28, 0, &v50, (_WORD *)&v47 + 1);
                  if (v32)
                    goto LABEL_60;
                  v48 = 0;
                  v32 = btree_node_key_ptr(v15[v30], (unsigned __int16)v45[v30], &v49, &v47);
                  if (v32)
                    goto LABEL_60;
                  v33 = *(_QWORD *)(a1 + 8);
                  if (!v33)
                    v33 = *(_QWORD *)(*(_QWORD *)a1 + 392);
                  v34 = v50;
                  v32 = (*(uint64_t (**)(uint64_t, void *, _QWORD, uint64_t, _QWORD, int *))(a1 + 416))(v33, v50, HIWORD(v47), v49, (unsigned __int16)v47, &v48);
                  if (!v32 && v48)
                    v32 = btree_node_entry_update(v15[v30], (unsigned __int16)v45[v30], v34, HIWORD(v47), 0);
                  if (v32)
                  {
LABEL_60:
                    v38 = *(_QWORD *)(a1 + 8);
                    if (v38)
                      v39 = (const char *)(v38 + 3880);
                    else
                      v39 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
                    log_err("%s:%d: %s updating grandparent failed w/%d\n", "bt_merge_up", 4619, v39, v32);
                    goto LABEL_64;
                  }
                  LOWORD(v24) = v24 - 1;
                  if ((_WORD)v24)
                  {
                    v28 = v15[(unsigned __int16)v24];
                    --v30;
                    if (*(_DWORD *)(*(_QWORD *)(v28 + 56) + 36))
                      continue;
                  }
                  goto LABEL_25;
                }
              }
            }
          }
          --v23;
LABEL_56:
          if ((btree_node_is_underused(a1, v15[v23]) & 1) == 0)
            goto LABEL_65;
        }
        --v23;
        bt_merge_nodes(a1, 0, 0, *v15, (unsigned __int16)*v45, v15[1], v44, a5);
LABEL_25:
        if ((v23 & 0x8000) != 0)
          goto LABEL_64;
        LOWORD(v14) = v43;
        goto LABEL_56;
      }
      LOWORD(v17) = 0;
LABEL_64:
      LOWORD(v14) = v43;
    }
LABEL_65:
    v40 = 0;
    do
    {
      v41 = v15[(__int16)v40];
      obj_unlock(v41, 2);
      obj_release(v41);
      ++v40;
    }
    while ((unsigned __int16)v17 >= (__int16)v40);
    if ((unsigned __int16)v14 >= 9u)
    {
      _apfs_free(v15, 8 * (unsigned __int16)v14);
      _apfs_free(v45, 2 * (unsigned __int16)v14);
    }
  }
}

uint64_t bt_remove(uint64_t a1, uint64_t a2, unint64_t *a3, unsigned int a4, uint64_t a5)
{
  return bt_remove_internal(a1, a2, 0, a3, a4, 0, 0, 0, 0, a5);
}

uint64_t bt_remove_first(uint64_t a1, uint64_t a2, void *a3, unsigned int *a4, void *a5, unsigned int *a6, uint64_t a7)
{
  size_t v14;
  unint64_t *v15;
  unint64_t *v16;
  uint64_t v17;

  v14 = *(unsigned int *)(*(_QWORD *)(a1 + 392) + 16);
  v15 = (unint64_t *)_apfs_malloc(v14);
  if (!v15)
    return 12;
  v16 = v15;
  v17 = bt_remove_internal(a1, a2, 1, v15, v14, a3, a4, a5, a6, a7);
  _apfs_free(v16, v14);
  return v17;
}

uint64_t bt_lookup_first(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, void *a5, unsigned int *a6)
{
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  size_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  size_t v24;
  size_t v26;
  _BYTE v28[12];
  int v29;
  const void *v30;
  const void *v31;
  uint64_t v32[2];

  v32[1] = *MEMORY[0x1E0C80C00];
  v12 = *(_QWORD *)(a1 + 400);
  MEMORY[0x1E0C80A78]();
  v14 = &v28[-v13];
  bzero(&v28[-v13], v15);
  v32[0] = 0;
  if (!*(_QWORD *)(a1 + 416))
    return 22;
  v16 = (v12 >> 9) & 0x3FFF;
  if (v16)
  {
    if (*a4 != v16)
      return 22;
  }
  if ((unsigned __int16)(v12 >> 23) && *a6 != (unsigned __int16)(v12 >> 23))
    return 22;
  v29 = 0;
  obj_lock(a1, 1);
  obj_retain((char *)a1);
  v18 = a1 + 56;
  v17 = *(_QWORD *)(a1 + 56);
  if ((*(_WORD *)(v17 + 32) & 2) != 0)
  {
    v19 = (_QWORD *)a1;
LABEL_15:
    if (*(_DWORD *)(v17 + 36))
    {
      v31 = 0;
      v20 = btree_node_key_ptr((uint64_t)v19, 0, &v31, (_WORD *)&v29 + 1);
      if (!(_DWORD)v20)
      {
        v30 = 0;
        v20 = btree_node_val_ptr(v19, 0, &v30, (__int16 *)&v29);
        if (!(_DWORD)v20)
        {
          v21 = (unsigned __int16)v29;
          if ((unsigned __int16)v29 == 65534)
            v22 = 0;
          else
            v22 = (unsigned __int16)v29;
          v23 = HIWORD(v29);
          if (*a4 >= HIWORD(v29))
            v24 = HIWORD(v29);
          else
            v24 = *a4;
          if (*a4 >= HIWORD(v29) && *a6 >= v22)
            v20 = 0;
          else
            v20 = 34;
          memcpy(a3, v31, v24);
          if (*a6 >= v22)
            v26 = v22;
          else
            v26 = *a6;
          memcpy(a5, v30, v26);
          *a4 = v23;
          *a6 = v21;
        }
      }
    }
    else
    {
      v20 = 2;
    }
    obj_unlock((uint64_t)v19, 1);
    obj_release(v19);
  }
  else
  {
    v19 = (_QWORD *)a1;
    while (1)
    {
      *v14 = 0;
      v20 = btree_node_child_val((uint64_t)v19, 0, v14);
      if (!(_DWORD)v20)
        v20 = btree_node_get((_QWORD *)a1, v14, a2, 2, *(_WORD *)(*(_QWORD *)v18 + 34) - 1, 0, v32);
      obj_unlock((uint64_t)v19, 1);
      obj_release(v19);
      if ((_DWORD)v20)
        break;
      v19 = (_QWORD *)v32[0];
      v18 = v32[0] + 56;
      v17 = *(_QWORD *)(v32[0] + 56);
      if ((*(_WORD *)(v17 + 32) & 2) != 0)
        goto LABEL_15;
    }
  }
  return v20;
}

uint64_t bt_lookup_variant(uint64_t a1, uint64_t a2, unint64_t *a3, unsigned int *a4, unsigned int a5, void *a6, unsigned int *a7, unsigned int a8, int a9, uint64_t *a10)
{
  unint64_t v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  char *v22;
  uint64_t v23;
  unsigned __int16 v24;
  char *v25;

  if (!*(_QWORD *)(a1 + 416))
    return 22;
  v17 = *(_QWORD *)(a1 + 400);
  v18 = (v17 >> 9) & 0x3FFF;
  if (v18)
  {
    if (*a4 != v18)
      return 22;
  }
  if ((unsigned __int16)(v17 >> 23) && *a7 != (unsigned __int16)(v17 >> 23))
    return 22;
  v19 = *a4;
  if ((v17 & 0x7FFE00) == 0 && v19 > ((unsigned __int16)((((v17 >> 27) & 0xF000) - 160) & 0xFFE0) >> 2) - 72)
    return 22;
  v25 = 0;
  v24 = 0;
  v20 = bt_lookup_internal((char *)a1, a2, a3, (unsigned __int16)v19, a8, a9, a10, &v25, &v24);
  if (!(_DWORD)v20)
  {
    v22 = v25;
    v23 = bt_lookup_copy_out(a1, v25, v24, a3, a4, a5, a6, a7, a8);
    v20 = v23;
    if (a10 && !(_DWORD)v23)
    {
      *a10 = obj_oid((uint64_t)v22);
      a10[1] = a1;
    }
    obj_unlock((uint64_t)v22, 1);
    obj_release(v22);
  }
  return v20;
}

uint64_t bt_lookup_internal(char *a1, uint64_t a2, unint64_t *a3, unsigned int a4, unsigned int a5, int a6, uint64_t *a7, char **a8, unsigned __int16 *a9)
{
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  size_t v15;
  uint64_t v16;
  char *v17;
  BOOL v18;
  BOOL v19;
  unsigned __int16 v20;
  char *v21;
  char *v22;
  char *v23;
  uint64_t v24;
  unsigned int v25;
  char *v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  char **v32;
  int v33;
  _BYTE v35[12];
  unsigned int v36;
  char **v37;
  unsigned int v38;
  int v39;
  uint64_t v40;
  unint64_t *v41;
  unsigned int v42;
  char v43;
  unsigned __int16 v44;
  char *v45;
  char *v46[2];

  v37 = a8;
  v39 = a6;
  v42 = a4;
  v40 = a2;
  v41 = a3;
  v46[1] = *(char **)MEMORY[0x1E0C80C00];
  v12 = *((_QWORD *)a1 + 50);
  MEMORY[0x1E0C80A78]();
  v14 = &v35[-v13];
  bzero(&v35[-v13], v15);
  v45 = 0;
  v46[0] = 0;
  v44 = 0;
  v43 = 0;
  if (!a7)
    goto LABEL_9;
  v16 = *a7;
  if (!*a7)
    goto LABEL_9;
  if ((char *)a7[1] != a1)
    goto LABEL_9;
  if ((v12 & 0x10) != 0)
    goto LABEL_9;
  *v14 = v16;
  if (v16 == obj_oid((uint64_t)a1)
    || btree_node_get(a1, v14, v40, (((*(unsigned __int16 *)(*((_QWORD *)a1 + 7) + 32) >> 3) & 1) << 6) | 6u, 0, 0, (uint64_t *)v46))
  {
    goto LABEL_9;
  }
  v17 = v46[0];
  if ((*(_WORD *)(*((_QWORD *)v46[0] + 7) + 32) & 2) == 0)
    goto LABEL_8;
  v33 = bt_search_node_insert((uint64_t)v46[0], v41, v42, &v44, (BOOL *)&v43);
  if (!v33 && v43)
  {
    if (a5 != 4)
    {
      if (a5 != 2)
        goto LABEL_79;
      if (v44)
      {
        --v44;
        goto LABEL_79;
      }
LABEL_82:
      v43 = 0;
      goto LABEL_8;
    }
    if (*(_DWORD *)(*((_QWORD *)v17 + 7) + 36) <= ++v44)
      goto LABEL_82;
LABEL_79:
    v32 = v37;
LABEL_80:
    v31 = 0;
    *v32 = v17;
    *a9 = v44;
    return v31;
  }
  if (!(v33 | a5))
  {
    if (v44 && *(_DWORD *)(*((_QWORD *)v17 + 7) + 36) > v44)
    {
      v23 = 0;
      v31 = 2;
      v32 = v37;
      goto LABEL_52;
    }
    goto LABEL_8;
  }
  if (!v33 && a5 - 3 <= 1 && v44 && *(_DWORD *)(*((_QWORD *)v17 + 7) + 36) > v44)
    goto LABEL_79;
LABEL_8:
  obj_unlock((uint64_t)v17, 1);
  obj_release(v17);
LABEL_9:
  v18 = a5 == 2;
  v36 = a5 - 3;
  v19 = a5 - 3 < 2;
  obj_lock((uint64_t)a1, 1);
  v46[0] = a1;
  obj_retain(a1);
  v20 = 0;
  v21 = a1;
  v38 = a5;
  while (1)
  {
    v43 = 0;
    v22 = v21 + 56;
    if ((*(_WORD *)(*((_QWORD *)v21 + 7) + 32) & 2) == 0)
    {
      v23 = 0;
      while (1)
      {
        v24 = bt_search_node((uint64_t)v21, v41, v42, &v44, (BOOL *)&v43);
        if ((_DWORD)v24)
          break;
        v25 = v44;
        if (v18 && v44 != 0 || v19 && *(_DWORD *)(*(_QWORD *)v22 + 36) - 1 > v44)
        {
          if (v23)
          {
            obj_unlock((uint64_t)v23, 1);
            obj_release(v23);
            v25 = v44;
          }
          v23 = v46[0];
          obj_retain(v46[0]);
          v20 = v19 - v18 + v25;
        }
        v26 = v46[0];
        if ((v39 & 0x100) != 0)
        {
          v27 = *((_QWORD *)v46[0] + 7);
          if (*(_WORD *)(v27 + 34) == 1
            && *(_DWORD *)(v27 + 36) - 1 > v25
            && !btree_node_child_val((uint64_t)v46[0], (unsigned __int16)(v25 + 1), v14))
          {
            btree_node_get(a1, v14, v40, 256, *(_WORD *)(*((_QWORD *)v26 + 7) + 34) - 1, 0, (uint64_t *)&v45);
          }
        }
        v24 = btree_node_child_val((uint64_t)v26, v25, v14);
        if ((_DWORD)v24)
          break;
        v24 = btree_node_get(a1, v14, v40, 2, *(_WORD *)(*((_QWORD *)v26 + 7) + 34) - 1, 0, (uint64_t *)&v45);
        if ((_DWORD)v24)
          break;
        btree_node_release((uint64_t)v26, v26 != v23);
        v21 = v45;
        v46[0] = v45;
        v22 = v45 + 56;
        if ((*(_BYTE *)(*((_QWORD *)v45 + 7) + 32) & 2) != 0)
          goto LABEL_29;
      }
LABEL_47:
      v31 = v24;
      goto LABEL_48;
    }
    v23 = 0;
LABEL_29:
    v24 = bt_search_node_insert((uint64_t)v21, v41, v42, &v44, (BOOL *)&v43);
    if ((_DWORD)v24)
      goto LABEL_47;
    if (v43)
      break;
    if (!v38)
    {
      v31 = 2;
      goto LABEL_48;
    }
    v28 = v44;
    if (v38 <= 2 && v44)
    {
      v31 = 0;
      v43 = 1;
      goto LABEL_68;
    }
    if (v36 <= 1)
    {
      v29 = *(_DWORD *)(*(_QWORD *)v22 + 36);
      goto LABEL_42;
    }
LABEL_43:
    if (!v23)
    {
      v31 = 2;
      v17 = v46[0];
      v32 = v37;
      if (v46[0])
        goto LABEL_52;
      goto LABEL_53;
    }
    btree_node_release((uint64_t)v21, v21 != v23);
    v30 = btree_node_child_val((uint64_t)v23, v20, v14);
    if ((_DWORD)v30
      || (v30 = btree_node_get(a1, v14, v40, 2, *(_WORD *)(*((_QWORD *)v23 + 7) + 34) - 1, 0, (uint64_t *)v46),
          (_DWORD)v30))
    {
      v31 = v30;
      v46[0] = 0;
      v32 = v37;
      goto LABEL_49;
    }
    obj_unlock((uint64_t)v23, 1);
    obj_release(v23);
    v18 = 0;
    v19 = 0;
    v21 = v46[0];
  }
  if (v38 != 2)
  {
    if (v38 != 4 || (++v44, v29 = *(_DWORD *)(*(_QWORD *)v22 + 36), v29 > v44))
    {
      v31 = 0;
      goto LABEL_48;
    }
    v28 = v44;
    v43 = 0;
LABEL_42:
    if (v29 > v28)
    {
      v31 = 0;
      v43 = 1;
      goto LABEL_48;
    }
    goto LABEL_43;
  }
  LOWORD(v28) = v44;
  if (!v44)
  {
    v43 = 0;
    goto LABEL_43;
  }
  v31 = 0;
LABEL_68:
  v44 = v28 - 1;
LABEL_48:
  v32 = v37;
  if (!v23)
    goto LABEL_50;
LABEL_49:
  obj_unlock((uint64_t)v23, 1);
  obj_release(v23);
LABEL_50:
  v17 = v46[0];
  if (!(_DWORD)v31)
    goto LABEL_80;
  if (!v46[0])
    goto LABEL_53;
LABEL_52:
  btree_node_release((uint64_t)v17, v17 != v23);
LABEL_53:
  *v32 = 0;
  return v31;
}

uint64_t bt_lookup_copy_out(uint64_t a1, _QWORD *a2, unsigned __int16 a3, void *a4, _DWORD *a5, unsigned int a6, void *a7, unsigned int *a8, int a9)
{
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  size_t v25;
  size_t v26;
  int v28;
  int v29;
  void *v30;
  void *__src;

  __src = 0;
  v28 = 0;
  v29 = 0;
  if (!(a9 | a6))
  {
    __src = 0;
    HIWORD(v28) = 0;
    goto LABEL_22;
  }
  v17 = btree_node_key_ptr((uint64_t)a2, a3, &__src, (_WORD *)&v28 + 1);
  v18 = v17;
  if (a9)
    v19 = (_DWORD)v17 == 0;
  else
    v19 = 0;
  if (!v19)
  {
LABEL_19:
    if ((_DWORD)v18)
      return v18;
    goto LABEL_22;
  }
  v20 = *(_QWORD *)(a1 + 8);
  if (!v20)
    v20 = *(_QWORD *)(*(_QWORD *)a1 + 392);
  v18 = (*(uint64_t (**)(uint64_t, void *, _QWORD, void *, _QWORD, int *))(a1 + 416))(v20, __src, HIWORD(v28), a4, *a5, &v29);
  if (!(_DWORD)v18)
  {
    if (a9 == 2 && (v29 & 0x80000000) == 0 || a9 == 1 && v29 > 0 || a9 == 3 && v29 < 0 || a9 == 4 && v29 <= 0)
    {
      v18 = nx_corruption_detected_int(*(_QWORD *)(*(_QWORD *)a1 + 392));
      goto LABEL_19;
    }
LABEL_22:
    v30 = 0;
    v18 = btree_node_val_ptr(a2, a3, &v30, (__int16 *)&v28);
    if (!(_DWORD)v18)
    {
      v21 = (unsigned __int16)v28;
      if ((unsigned __int16)v28 == 65534)
        v22 = 0;
      else
        v22 = (unsigned __int16)v28;
      v23 = *a8;
      if (*a8 < v22 || (v18 = 0, a6) && HIWORD(v28) > a6)
        v18 = 34;
      if (a6)
      {
        v24 = HIWORD(v28);
        if (HIWORD(v28) >= a6)
          v25 = a6;
        else
          v25 = HIWORD(v28);
        memcpy(a4, __src, v25);
        *a5 = v24;
        v23 = *a8;
      }
      if (v23 >= v22)
        v26 = v22;
      else
        v26 = v23;
      memcpy(a7, v30, v26);
      *a8 = v21;
    }
  }
  return v18;
}

__n128 bt_iterator_init_with_hint(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unint64_t *a5, int a6, unsigned int a7, void *a8, unsigned int a9, _OWORD *a10)
{
  int v16;
  uint64_t *v17;
  unsigned int v18;
  int v19;
  __n128 result;
  int v21;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  v16 = a4 & 0x180;
  *(_DWORD *)(a1 + 16) = a4;
  *(_DWORD *)(a1 + 20) = a7;
  *(_QWORD *)(a1 + 32) = a5;
  *(_QWORD *)(a1 + 40) = a8;
  *(_QWORD *)(a1 + 24) = a9;
  v17 = (uint64_t *)(a1 + 56);
  if (a10)
  {
    *(_OWORD *)v17 = *a10;
  }
  else
  {
    *v17 = 0;
    *(_QWORD *)(a1 + 64) = 0;
  }
  *(_DWORD *)(a1 + 48) = a6;
  *(_DWORD *)(a1 + 52) = a9;
  if ((a4 & 4) != 0)
  {
    v18 = 4;
  }
  else if ((a4 & 2) != 0)
  {
    v21 = a4 & 0x180;
    v19 = bt_lookup_variant(a2, a3, a5, (unsigned int *)(a1 + 48), a7, a8, (unsigned int *)(a1 + 52), 1u, v16, (uint64_t *)(a1 + 56));
    if (v19 != 2)
      goto LABEL_11;
    v18 = 3;
    v16 = v21;
  }
  else
  {
    v18 = 3;
  }
  v19 = bt_lookup_variant(a2, a3, a5, (unsigned int *)(a1 + 48), a7, a8, (unsigned int *)(a1 + 52), v18, v16, v17);
LABEL_11:
  if (v19)
  {
    *(_DWORD *)(a1 + 16) |= 1u;
    if (v19 != 2)
      *(_DWORD *)(a1 + 28) = v19;
  }
  else if (a10)
  {
    result = *(__n128 *)v17;
    *a10 = *(_OWORD *)v17;
  }
  return result;
}

double bt_iterator_init(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unint64_t *a5, int a6, unsigned int a7, void *a8, unsigned int a9)
{
  double result;

  *(_QWORD *)&result = bt_iterator_init_with_hint(a1, a2, a3, a4, a5, a6, a7, a8, a9, 0).n128_u64[0];
  return result;
}

uint64_t bt_iterator_ended(uint64_t a1)
{
  uint64_t result;

  result = *(unsigned int *)(a1 + 28);
  if (!(_DWORD)result)
    return *(_DWORD *)(a1 + 16) & 1;
  return result;
}

uint64_t bt_iterator_next(uint64_t a1)
{
  uint64_t result;
  int v3;
  unsigned int v4;
  unsigned int v5;

  result = *(unsigned int *)(a1 + 28);
  if (!(_DWORD)result)
  {
    v3 = *(_DWORD *)(a1 + 16);
    result = 2;
    if ((v3 & 1) == 0)
    {
      v4 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 52) = *(_DWORD *)(a1 + 24);
      if ((v3 & 0x1000) != 0)
        v5 = 2;
      else
        v5 = 4;
      result = bt_lookup_variant(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(unint64_t **)(a1 + 32), (unsigned int *)(a1 + 48), v4, *(void **)(a1 + 40), (unsigned int *)(a1 + 52), v5, v3 & 0x180, (uint64_t *)(a1 + 56));
      if ((_DWORD)result == 2)
      {
        result = 0;
        *(_DWORD *)(a1 + 16) |= 1u;
      }
      *(_DWORD *)(a1 + 28) = result;
    }
  }
  return result;
}

uint64_t btree_create_extended(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5, uint64_t *a6, uint64_t a7, uint64_t *a8)
{
  unsigned __int16 v11;
  __int16 v12;
  unsigned int v13;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  unsigned int v21;
  unint64_t v22;
  uint64_t v23;
  __int16 v24;
  uint64_t result;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v11 = a5;
  v12 = a4;
  v13 = a3;
  v33 = 0;
  v15 = *((_DWORD *)a6 + 5);
  v16 = a2 >> 30;
  v17 = (v15 << 26) & 0x40000000 | ((v15 >> 3) << 31) | (((v15 >> 5) & 1) << 27) | a2;
  if ((v15 & 0x18) == 0)
    v17 = a2;
  v18 = v15 | (a2 >> 26) & 0x10;
  if ((a2 & 0x80000000) != 0)
    v18 |= 8u;
  v19 = v18 | (a2 >> 22) & 0x20;
  if (v16)
    v20 = a2;
  else
    v20 = v17;
  if (v16)
    v21 = v19;
  else
    v21 = *((_DWORD *)a6 + 5);
  if (!a3)
    v13 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 376) + 36);
  if (v13 - 65537 < 0xFFFF0060
    || a4 != 8 && (v21 & 1) != 0
    || a4 > (unsigned __int16)(((unsigned __int16)(v13 - 160) >> 2) - 72)
    || a5 + a4 > btree_entry_max_size(v21, v13, (unsigned __int16)a4, (unsigned __int16)a5)
    || v21 > 0x1FF)
  {
    return 22;
  }
  v22 = ((unsigned __int16)(v12 & 0x3FFF) << 9) | ((unint64_t)v11 << 23) | v21 & 0x1FF | ((unint64_t)(v13 >> 12) << 39);
  v23 = *a6;
  v32 = v22;
  v34 = v23;
  v31 = 0x300086583;
  if ((v21 & 0x80) == 0)
  {
    v24 = 19;
    if ((v21 & 0x100) == 0)
      goto LABEL_22;
    goto LABEL_21;
  }
  if (authapfs_valid_hash_type(*((_DWORD *)a6 + 6)))
    return 22;
  v29 = *((_DWORD *)a6 + 6);
  if (v29 > 0xF)
    return 22;
  v30 = *((_DWORD *)a6 + 7);
  v32 = v22 & 0xFF800FFFFFFFFFFFLL | ((unint64_t)(v29 & 0xF) << 44) | ((unint64_t)(v30 & 0x7F) << 48);
  if (v30 > 0x7F)
    return 22;
  WORD2(v31) = 11;
  v24 = 27;
  if ((v21 & 0x100) != 0)
LABEL_21:
    WORD2(v31) = v24;
LABEL_22:
  result = btree_node_create(a1, v20, *((unsigned int *)a6 + 4), &v31, a7, a8);
  if (!(_DWORD)result)
  {
    v26 = (unint64_t *)(*(_QWORD *)(*a8 + 392) + 32);
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
    v28 = a6[1];
    if (v28)
      *(_QWORD *)(*a8 + 424) = v28;
    obj_unlock(*a8, 2);
    return 0;
  }
  return result;
}

uint64_t btree_node_create(pthread_mutex_t **a1, int a2, int a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  __int16 v10;
  int v11;
  int v12;
  pthread_mutex_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v18;
  uint64_t v19;

  v18 = btree_node_desc;
  DWORD2(v18) = (*(_QWORD *)(a4 + 8) >> 27) & 0x1F000;
  v10 = *(_WORD *)(a4 + 4);
  if ((v10 & 1) != 0)
    LODWORD(v18) = 2;
  v19 = 0;
  DWORD1(v18) = a3;
  if ((v10 & 0x10) != 0)
    v11 = 536870916;
  else
    v11 = 4;
  v12 = v11 | a2;
  v13 = *a1;
  if (obj_type((uint64_t)a1) == 13)
    v14 = (uint64_t)a1;
  else
    v14 = 0;
  v15 = obj_create(v13, v12, 0, (uint64_t)&v18, a4, v14, a5, &v19);
  if (!(_DWORD)v15)
  {
    v16 = v19;
    *a6 = v19;
    obj_dirty(v16, a5, 0);
  }
  return v15;
}

uint64_t btree_create(uint64_t a1, unsigned int a2, int a3, int a4, unsigned int a5, unsigned int a6, int a7, uint64_t a8, uint64_t a9, uint64_t *a10)
{
  uint64_t v11[2];
  int v12;
  int v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v11[1] = 0;
  v14 = 0u;
  v18 = 0;
  v16 = 0u;
  v17 = 0u;
  v15 = 0u;
  v11[0] = a8;
  v12 = a4;
  v13 = a3;
  return btree_create_extended(a1, a2, a5, a6, a7, v11, a9, a10);
}

uint64_t btree_get_extended(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  unsigned int v14;
  size_t v15;
  uint64_t v16;
  char *v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  unint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t result;
  uint64_t v32;
  unsigned int v33;
  unint64_t v34;
  unsigned int v35;
  size_t v36;
  uint64_t v37;
  uint64_t v38;
  char v39;
  char v40;
  uint64_t *v41;
  uint64_t v42;
  __int128 v43;
  uint64_t v44[2];

  v41 = a8;
  v42 = a7;
  v44[1] = *MEMORY[0x1E0C80C00];
  v14 = *(_DWORD *)(a6 + 28);
  if (v14 >= 0x40)
    v14 = 64;
  v15 = v14 + 32;
  MEMORY[0x1E0C80A78]();
  v17 = (char *)&v41 - v16;
  bzero((char *)&v41 - v16, v15);
  v44[0] = 0;
  v43 = btree_node_desc;
  v18 = *(_DWORD *)(a6 + 20);
  v19 = a2 >> 30;
  v20 = (v18 << 26) & 0x40000000 | ((v18 >> 3) << 31) | (((v18 >> 5) & 1) << 27) | a2;
  if ((v18 & 0x18) == 0)
    v20 = a2;
  v21 = v18 | (a2 >> 26) & 0x10;
  if ((a2 & 0x80000000) != 0)
    v21 |= 8u;
  v22 = v21 | (a2 >> 22) & 0x20;
  if (v19)
    v23 = a2;
  else
    v23 = v20;
  if (v19)
    v24 = v22;
  else
    v24 = *(_DWORD *)(a6 + 20);
  *(_WORD *)v17 = 25987;
  *((_WORD *)v17 + 1) = v15;
  if (v24 > 0x1FF)
    return 22;
  v25 = *(_QWORD *)a1;
  v26 = *((_QWORD *)v17 + 1) & 0xFFFFF07FFFFFFE00 | v24 & 0x1FF | ((unint64_t)((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 376) + 36) >> 12) & 0x1F) << 39);
  *((_QWORD *)v17 + 1) = v26;
  *((_QWORD *)v17 + 3) = *(_QWORD *)a6;
  *((_DWORD *)v17 + 1) = -267452416;
  if ((v24 & 0x80) == 0)
    goto LABEL_15;
  if (authapfs_valid_hash_type(*(_DWORD *)(a6 + 24)))
    return 22;
  v33 = *(_DWORD *)(a6 + 24);
  if (v33 > 0xF)
    return 22;
  v34 = v26 & 0xFF800FFFFFFFFFFFLL | ((unint64_t)(v33 & 0xF) << 44);
  v35 = *(_DWORD *)(a6 + 28);
  *((_QWORD *)v17 + 1) = v34 | ((unint64_t)(v35 & 0x7F) << 48);
  if (v35 > 0x7F)
    return 22;
  if (v35 >= 0x40)
    v36 = 64;
  else
    v36 = v35;
  memcpy(v17 + 32, (const void *)(a6 + 32), v36);
  v25 = *(_QWORD *)a1;
LABEL_15:
  v27 = *(_DWORD *)(a6 + 16);
  LODWORD(v43) = (v24 << 21) & 0x20000000 | v23 & 0xFFFF0000 | 2;
  DWORD1(v43) = v27;
  if ((v23 & 0x40000000) != 0)
    v28 = 3;
  else
    v28 = 1;
  v29 = (2 * (a5 & 2)) & 0xDF | (32 * (((a5 & 4) >> 2) & 1)) | (a5 << 31 >> 31) & v28 | (v24 << 21) & 0x20000000 | v23;
  if (obj_type(a1) == 13)
    v30 = a1;
  else
    v30 = 0;
  result = obj_get(v25, v29, a3, &v43, v17, v30, a4, v42, v44);
  if ((a5 & 4) == 0 || (_DWORD)result)
  {
    v32 = v44[0];
    if ((_DWORD)result)
      v37 = 0;
    else
      v37 = v44[0];
    *v41 = v37;
    if (!(_DWORD)result)
      goto LABEL_38;
  }
  else
  {
    v32 = v44[0];
    if ((*(_BYTE *)(v44[0] + 16) & 0x10) == 0)
    {
      *v41 = v44[0];
LABEL_38:
      v38 = *(_QWORD *)(a6 + 8);
      result = 0;
      if (v38)
        *(_QWORD *)(v32 + 424) = v38;
      return result;
    }
    if ((a5 & 1) != 0)
      v39 = 2;
    else
      v39 = 1;
    if ((a5 & 2) != 0)
      v40 = v39;
    else
      v40 = 0;
    btree_node_release(v44[0], v40);
    *v41 = 0;
    return 2;
  }
  return result;
}

uint64_t btree_get(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, uint64_t a8, uint64_t a9, uint64_t *a10)
{
  _QWORD v11[2];
  int v12;
  int v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v11[1] = 0;
  v14 = 0u;
  v18 = 0;
  v16 = 0u;
  v17 = 0u;
  v15 = 0u;
  v11[0] = a8;
  v12 = a7;
  v13 = a5;
  return btree_get_extended(a1, a2, a3, a4, a6, (uint64_t)v11, a9, a10);
}

uint64_t btree_iterate_nodes(uint64_t a1, uint64_t a2, int a3, uint64_t (*a4)(void), uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  _QWORD *v10;
  size_t v11;
  int v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 *v17;
  uint64_t v18;
  int v19;
  int v20;
  unsigned __int16 v21;
  uint64_t v22;
  int v23;
  unsigned __int16 v25;
  unsigned int v26;
  _BOOL4 v27;
  _BOOL4 v28;
  unsigned __int16 v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  __int128 *v33;
  unsigned int v34;
  _WORD *v35;
  unsigned int v36;
  uint64_t v37;
  __int128 *v38;
  uint64_t v39;
  const char *v40;
  int v41;
  uint64_t v42;
  __int128 *v43;
  unsigned __int16 *v44;
  unsigned int v45;
  uint64_t v46;
  _QWORD *v47;
  size_t v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v55;
  uint64_t v56;
  _QWORD *v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  const char *v61;
  uint64_t v62;
  const char *v63;
  __int128 *v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  const char *v69;
  int v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  const char *v80;
  uint64_t v81;
  int v82;
  unsigned int v83;
  uint64_t v84;
  unsigned int v85;
  uint64_t *v86;
  _BOOL4 v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  uint64_t v95;
  uint64_t *v96;
  uint64_t v97;
  _BOOL4 v98;
  uint64_t (*v99)(void);
  uint64_t v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  uint64_t v109;

  v97 = a6;
  v99 = a4;
  v95 = a2;
  v109 = *MEMORY[0x1E0C80C00];
  v107 = 0u;
  v108 = 0u;
  v105 = 0u;
  v106 = 0u;
  v103 = 0u;
  v104 = 0u;
  v101 = 0u;
  v102 = 0u;
  MEMORY[0x1E0C80A78]();
  v10 = (uint64_t *)((char *)&v78 - v9);
  bzero((char *)&v78 - v9, v11);
  v94 = a3 & 0x180;
  v12 = v94 != 0;
  if ((a3 & 1) != 0)
    v13 = 2;
  else
    v13 = 1;
  obj_lock(a1, v13);
  v14 = *(_QWORD *)(a1 + 56);
  if (!v14)
  {
    obj_unlock(a1, v13);
    return 22;
  }
  v15 = *(unsigned __int16 *)(v14 + 34);
  v16 = v15 + 1;
  v92 = v15;
  if (v15 < 8)
  {
    v107 = 0u;
    v108 = 0u;
    v105 = 0u;
    v106 = 0u;
    v103 = 0u;
    v104 = 0u;
    v17 = &v101;
    v101 = 0u;
    v102 = 0u;
  }
  else
  {
    v17 = (__int128 *)_apfs_calloc(v15 + 1, 0x10uLL);
    if (!v17)
    {
      obj_unlock(a1, v13);
      return 12;
    }
  }
  *(_QWORD *)v17 = a1;
  *((_WORD *)v17 + 4) = 0;
  obj_retain((char *)a1);
  v18 = 0;
  if ((a3 & 1) != 0)
  {
    v18 = obj_modify((_QWORD *)a1, 2, v97);
    if (!(_DWORD)v18)
    {
      if ((*(_BYTE *)(a1 + 400) & 0x80) != 0)
        obj_dirty(a1, v97, 0);
      v18 = 0;
    }
  }
  v89 = v16;
  v19 = a3 & 0x20;
  v90 = &v78;
  if (v99 && !(v18 | v19) && ((a3 & 0x10) == 0 || *(_WORD *)(*(_QWORD *)(a1 + 56) + 34)))
    v18 = ((uint64_t (*)(uint64_t, uint64_t))v99)(a1, a5);
  if (!(_DWORD)v18)
  {
    v25 = 0;
    v83 = a3 & 0xFFFFFE4F;
    v26 = a3 & 0xFFFFFE4D | 2;
    if (v94)
      v26 = a3 & 0xFFFFFE4C;
    v27 = v19 != 0;
    if (!v99)
      v27 = 0;
    v98 = v27;
    v82 = v12 << 7;
    v91 = (v12 << 7) | v26;
    v85 = a3 & 0xFFFFFE4C;
    v84 = a3 & 0xFFFFFE4C | 0x100;
    if (v99)
      v28 = v19 == 0;
    else
      v28 = 0;
    v87 = v28;
    v88 = a5;
    while (1)
    {
      v29 = v25;
      v30 = (uint64_t *)&v17[v25];
      v31 = *v30;
      v32 = *(_QWORD *)(*v30 + 56);
      if ((*(_WORD *)(v32 + 32) & 2) != 0
        || (v33 = &v17[v25],
            v36 = *((unsigned __int16 *)v33 + 4),
            v35 = (_WORD *)v33 + 4,
            v34 = v36,
            *(_DWORD *)(v32 + 36) <= v36)
        || (a3 & 0x10) != 0 && *(_WORD *)(v32 + 34) == 1)
      {
        if (v98)
        {
          v18 = v99();
          v31 = *v30;
        }
        else
        {
          v18 = 0;
        }
        btree_node_release(v31, v13);
        *v30 = 0;
        v25 = v29 - 1;
        goto LABEL_45;
      }
      *v10 = 0;
      v37 = btree_node_child_val(v31, v34, v10);
      if ((_DWORD)v37)
      {
        v18 = v37;
        obj_oid(*v30);
        log_err("%s:%d: %s level %d node 0x%llx: error getting index %d child oid: %d\n");
        goto LABEL_21;
      }
      ++*v35;
      v25 = v29 + 1;
      if (v92 < (__int16)(v29 + 1))
      {
        v60 = *(_QWORD *)(a1 + 8);
        if (v60)
          v61 = (const char *)(v60 + 3880);
        else
          v61 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
        v64 = &v17[(__int16)v25];
        v65 = *((_QWORD *)v64 - 2);
        v66 = *(unsigned __int16 *)(*(_QWORD *)(v65 + 56) + 34);
        v67 = obj_oid(v65);
        log_err("%s:%d: %s level %d node 0x%llx index %d: more levels than expected\n", "btree_iterate_nodes", 6349, v61, v66, v67, *((unsigned __int16 *)v64 - 4) - 1);
        v18 = 22;
        goto LABEL_21;
      }
      v38 = &v17[(__int16)v25];
      *((_WORD *)v38 + 4) = 0;
      v93 = (__int16)v25 - 1;
      v96 = (uint64_t *)&v17[v93];
      v18 = btree_node_get((_QWORD *)a1, v10, v95, v91, *(_WORD *)(*(_QWORD *)(*v96 + 56) + 34) - 1, v97, (uint64_t *)v38);
      if ((_DWORD)v18)
        break;
      if (v94)
        goto LABEL_58;
      if ((a3 & 1) != 0)
        goto LABEL_77;
LABEL_79:
      if (v87)
        v18 = ((uint64_t (*)(_QWORD, uint64_t))v99)(*(_QWORD *)v38, v88);
      else
        v18 = 0;
LABEL_45:
      if ((_DWORD)v18 || (v25 & 0x8000) != 0)
        goto LABEL_21;
    }
    v39 = *(_QWORD *)(a1 + 8);
    if (v39)
      v40 = (const char *)(v39 + 3880);
    else
      v40 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
    v41 = *(unsigned __int16 *)(*(_QWORD *)(*v96 + 56) + 34);
    v42 = obj_oid(*v96);
    log_err("%s:%d: %s level %d node 0x%llx: error getting index %d child 0x%llx flags 0x%x: %d\n", "btree_iterate_nodes", 6364, v40, v41, v42, WORD4(v17[v93]) - 1, *v10, v91, v18);
    if (!v94)
      goto LABEL_96;
LABEL_58:
    v43 = &v17[v93];
    v45 = *((unsigned __int16 *)v43 + 4);
    v44 = (unsigned __int16 *)v43 + 4;
    if (*(_DWORD *)(*(_QWORD *)(*v96 + 56) + 36) > v45)
    {
      v86 = &v78;
      MEMORY[0x1E0C80A78]();
      v47 = (uint64_t *)((char *)&v78 - v46);
      bzero((char *)&v78 - v46, v48);
      v49 = *v44;
      if (*(_DWORD *)(*(_QWORD *)(*v96 + 56) + 36) > v49)
      {
        v50 = btree_node_child_val(*v96, v49, v47);
        if ((_DWORD)v50
          || (v50 = btree_node_get((_QWORD *)a1, v47, v95, v84, *(_WORD *)(*(_QWORD *)(*v96 + 56) + 34) - 1, v97, &v100), (_DWORD)v50))
        {
          v81 = v50;
          v51 = *(_QWORD *)(a1 + 8);
          if (v51)
            v80 = (const char *)(v51 + 3880);
          else
            v80 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
          v52 = *v96;
          v79 = *(unsigned __int16 *)(*(_QWORD *)(*v96 + 56) + 34);
          v53 = obj_oid(v52);
          log_err("%s:%d: %s level %d node 0x%llx: error prefetching index %d child 0x%llx flags 0x%x: %d\n", "btree_iterate_nodes", 6383, v80, v79, v53, *v44, *v47, v84, v81);
        }
      }
    }
    if ((_DWORD)v18)
    {
      if ((_DWORD)v18 != 45 && (_DWORD)v18 != 16)
        goto LABEL_96;
      v55 = btree_node_get((_QWORD *)a1, v10, v95, v85, *(_WORD *)(*(_QWORD *)(*v96 + 56) + 34) - 1, v97, (uint64_t *)&v17[(__int16)v25]);
      if ((_DWORD)v55)
      {
        v18 = v55;
LABEL_96:
        obj_oid(*v96);
        log_err("%s:%d: %s level %d node 0x%llx: error getting index %d child flags 0x%x: %d\n", "btree_iterate_nodes");
        goto LABEL_21;
      }
    }
    else
    {
      v56 = obj_async_wait(*(_QWORD *)v38);
      if ((_DWORD)v56)
      {
        v18 = v56;
        v68 = *(_QWORD *)(a1 + 8);
        if (v68)
          v69 = (const char *)(v68 + 3880);
        else
          v69 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
        v74 = *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)v38 + 56) + 34);
        v75 = obj_oid(*v96);
        v76 = *v44 - 1;
        v77 = obj_oid(*(_QWORD *)v38);
        log_err("%s:%d: %s level %d node 0x%llx: error ON WAIT getting index %d child 0x%llx flags 0x%x: %d\n", "btree_iterate_nodes", 6396, v69, v74, v75, v76, v77, v91, v18);
        obj_release(*(uint64_t **)v38);
        goto LABEL_95;
      }
    }
    obj_lock(*(_QWORD *)v38, v13);
    if ((a3 & 1) == 0)
      goto LABEL_79;
    v57 = *(_QWORD **)v38;
    v58 = obj_type_and_flags(*(_QWORD *)v38);
    v59 = obj_modify(v57, (v58 >> 29) & 2, v97);
    if ((_DWORD)v59)
    {
      v18 = v59;
      v62 = *(_QWORD *)(a1 + 8);
      if (v62)
        v63 = (const char *)(v62 + 3880);
      else
        v63 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
      v70 = *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)v38 + 56) + 34);
      v71 = obj_oid(*v96);
      v72 = *v44 - 1;
      v73 = obj_oid(*(_QWORD *)v38);
      log_err("%s:%d: %s level %d node 0x%llx: error MODIFYING index %d child 0x%llx flags 0x%x: %d\n", "btree_iterate_nodes", 6410, v63, v70, v71, v72, v73, v91, v18);
      btree_node_release(*(_QWORD *)v38, 2);
LABEL_95:
      *(_QWORD *)v38 = 0;
      goto LABEL_96;
    }
LABEL_77:
    if (obj_oid(*(_QWORD *)v38) != *v10)
      btree_node_child_id_update(*v96, (unsigned __int16)(WORD4(v17[v93]) - 1), (uint64_t *)(*(_QWORD *)v38 + 112), v97);
    goto LABEL_79;
  }
LABEL_21:
  v20 = v89;
  if ((((_WORD)v89 - 1) & 0x8000) == 0)
  {
    v21 = v89 - 1;
    do
    {
      v22 = *(_QWORD *)&v17[v21];
      if (v22)
        btree_node_release(v22, v13);
      v23 = (__int16)v21--;
    }
    while (v23 > 0);
  }
  if (v17 != &v101)
    _apfs_free(v17, (16 * v20));
  return v18;
}

uint64_t btree_level_count(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  uint64_t result;

  if (!a1)
    return 22;
  v2 = *(_QWORD *)(a1 + 56);
  if (!v2)
    return 22;
  result = 0;
  *a2 = *(unsigned __int16 *)(v2 + 34) + 1;
  return result;
}

uint64_t btree_node_checkpoint_traverse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  _QWORD *v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int16 v15;
  void *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v22[2];

  v22[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78]();
  v11 = (uint64_t *)((char *)v22 - v10);
  bzero((char *)v22 - v10, v12);
  if ((_DWORD)a5 == 2)
  {
    if (obj_type(a1) == 13)
      v14 = a1;
    else
      v14 = 0;
    *(_QWORD *)(a4 + 8) = v14;
    v15 = obj_subtype(a4);
    v16 = tree_key_compare_function_for_type(v15);
    if (!v16)
      return 22;
    *(_QWORD *)(a4 + 416) = v16;
    if (a4 != a3)
      *(_OWORD *)(a4 + 400) = *(_OWORD *)(a3 + 400);
    v13 = obj_checkpoint_known(a4);
    goto LABEL_11;
  }
  if ((_DWORD)a5 == 1)
  {
    v13 = obj_checkpoint_start((unsigned int *)a4);
LABEL_11:
    v17 = v13;
    goto LABEL_13;
  }
  v17 = 0;
LABEL_13:
  if (!(*(_WORD *)(*(_QWORD *)(a4 + 56) + 32) & 2 | v17))
  {
    v18 = 0;
    v22[0] = 0;
    while (v18 < *(_DWORD *)(*(_QWORD *)(a4 + 56) + 36))
    {
      *v11 = 0;
      v19 = btree_node_child_val(a4, (unsigned __int16)v18, v11);
      if ((_DWORD)v19)
        return v19;
      v19 = btree_node_get((_QWORD *)a3, v11, 0, 2, *(_WORD *)(*(_QWORD *)(a4 + 56) + 34) - 1, 0, v22);
      if ((_DWORD)v19)
        return v19;
      v20 = (uint64_t *)v22[0];
      v17 = btree_node_checkpoint_traverse(a1, a2, a3, v22[0], a5);
      obj_unlock((uint64_t)v20, 1);
      obj_release(v20);
      ++v18;
      if ((_DWORD)v17)
        return v17;
    }
    return 0;
  }
  return v17;
}

uint64_t btree_checkpoint_traverse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return btree_node_checkpoint_traverse(a1, a2, a3, a3, a4);
}

uint64_t btree_node_copy(_QWORD *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v14;
  _QWORD *v15;
  size_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  pthread_mutex_t **v20;
  int v21;
  uint64_t v22;
  uint64_t inserted;
  void *v24;
  const void *v25;
  unsigned int v26;
  uint64_t v27;
  int *v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  uint64_t v36;
  uint64_t *v37;
  unsigned int v38;
  unsigned __int16 v39;
  const void *v40;
  _OWORD v41[2];
  uint64_t v42;
  uint64_t v43[2];

  v43[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78]();
  v15 = (uint64_t *)((char *)&v36 - v14);
  bzero((char *)&v36 - v14, v16);
  v42 = 0;
  memset(v41, 0, sizeof(v41));
  v17 = (a3 >> 26) & 0x10 | a4;
  if ((int)a3 < 0)
    v17 |= 8u;
  LODWORD(v41[0]) = 2123139;
  *(_OWORD *)((char *)v41 + 8) = *(_OWORD *)(a2 + 400);
  v38 = v17 | (a3 >> 22) & 0x20;
  v18 = *(_QWORD *)(a2 + 416);
  *((_QWORD *)&v41[0] + 1) = *((_QWORD *)&v41[0] + 1) & 0xFFFFFFFFFFFFFE00 | BYTE8(v41[0]) & 0x47 | v17 & 0x1B8 | (a3 >> 22) & 0x20;
  *((_QWORD *)&v41[1] + 1) = v18;
  v19 = *(_QWORD *)(a2 + 56);
  WORD2(v41[0]) = *(_WORD *)(v19 + 32) & 0x1B;
  WORD3(v41[0]) = *(_WORD *)(v19 + 34);
  v20 = *(pthread_mutex_t ***)(a2 + 8);
  if (!v20)
    v20 = *(pthread_mutex_t ***)(*(_QWORD *)a2 + 392);
  v39 = 0;
  v21 = obj_subtype(a2);
  v22 = btree_node_create(v20, a3, v21, (uint64_t)v41, a5, a7);
  inserted = v22;
  if ((_DWORD)a6 && !(*(_WORD *)(*(_QWORD *)(a2 + 56) + 32) & 2 | v22))
  {
    v37 = a7;
    v29 = 0;
    v43[0] = 0;
    v40 = 0;
    while (1)
    {
      if (v29 >= *(_DWORD *)(*(_QWORD *)(a2 + 56) + 36))
      {
        inserted = 0;
        goto LABEL_28;
      }
      *v15 = 0;
      v30 = btree_node_child_val(a2, (unsigned __int16)v29, v15);
      if ((_DWORD)v30
        || (v30 = btree_node_get(a1, v15, 0, 2, *(_WORD *)(*(_QWORD *)(a2 + 56) + 34) - 1, 0, v43), (_DWORD)v30))
      {
        inserted = v30;
        goto LABEL_28;
      }
      v31 = v43[0];
      v32 = btree_node_copy(a1, v43[0], a3, v38, a5, a6, &v42);
      if ((_DWORD)v32)
        break;
      inserted = btree_node_key_ptr(a2, (unsigned __int16)v29, &v40, &v39);
      if ((_DWORD)inserted
        || (*v15 = *(_QWORD *)(v42 + 112),
            inserted = btree_node_insert_internal(*v37, (unsigned __int16)v29, v40, v39, v15, (*(_WORD *)(*v37 + 406) & 0x7Fu) + 8, a5), (_DWORD)inserted))
      {
        v33 = a1[1];
        if (v33)
          v34 = (const char *)(v33 + 3880);
        else
          v34 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 384) + 208);
        log_err("%s:%d: %s btree_node_insert_internal failed: %d\n", "btree_node_copy", 6601, v34, inserted);
      }
      obj_release(v42);
      obj_unlock(v31, 1);
      obj_release(v31);
      v42 = 0;
      ++v29;
      if ((_DWORD)inserted)
        goto LABEL_28;
    }
    inserted = v32;
    obj_unlock(v31, 1);
    obj_release(v31);
    if (v42)
      obj_release(v42);
LABEL_28:
    a7 = v37;
    obj_dirty(*v37, a5, 0);
    goto LABEL_29;
  }
  if (!(_DWORD)v22)
  {
    v24 = (void *)(*(_QWORD *)(*a7 + 56) + 32);
    v25 = (const void *)(*(_QWORD *)(a2 + 56) + 32);
    v26 = obj_size_phys(a2);
    memcpy(v24, v25, v26 - 32);
    v27 = *a7;
    if ((*(_WORD *)(*(_QWORD *)(a2 + 56) + 32) & 1) != 0)
    {
      v28 = *(int **)(v27 + 392);
      *v28 = WORD4(v41[0]) & 0x1FF;
      v28[1] = (*((_QWORD *)&v41[0] + 1) >> 27) & 0x1F000;
      v28[2] = (DWORD2(v41[0]) >> 9) & 0x3FFF;
      v28[3] = (unsigned __int16)(*((_QWORD *)&v41[0] + 1) >> 23);
    }
    btree_node_init_ext(v27, (uint64_t)v41, 0);
    inserted = 0;
LABEL_29:
    obj_unlock(*a7, 2);
  }
  return inserted;
}

uint64_t btree_delete(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  int v18;

  obj_lock(a1, 2);
  if ((*(_BYTE *)(a1 + 19) & 0x80) != 0 || (*(_BYTE *)(a1 + 400) & 0x80) != 0)
  {
    v8 = btree_delete_node((_QWORD *)a1, (uint64_t *)a1, a2);
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 8);
    if (v6)
      v7 = obj_oid(v6);
    else
      v7 = 0;
    v10 = *(_QWORD *)(*(_QWORD *)a1 + 392);
    v11 = obj_type_and_flags(a1);
    v12 = obj_size_phys(a1);
    v13 = obj_oid(a1);
    if (a3)
      v14 = nx_reaper_add(v10, v11, v12, v7, v13, a2, 0, a3);
    else
      v14 = nx_reaper_add_sub_object(v10, v11, v12, v7, v13, a2, 0);
    v8 = v14;
    if ((_DWORD)v14)
    {
      v15 = *(_QWORD *)(a1 + 8);
      if (v15)
        v16 = (const char *)(v15 + 3880);
      else
        v16 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
      v17 = obj_oid(a1);
      v18 = obj_type_and_flags(a1);
      log_err("%s:%d: %s error adding btree 0x%llx type 0x%x to reap list: %d\n", "btree_delete", 6727, v16, v17, v18, v8);
    }
  }
  obj_unlock(a1, 2);
  return v8;
}

uint64_t btree_delete_node(_QWORD *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD *v7;
  size_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78]();
  v7 = (uint64_t *)((char *)v14 - v6);
  bzero((char *)v14 - v6, v8);
  if ((*(_WORD *)(a2[7] + 32) & 2) == 0)
  {
    v9 = 0;
    v14[0] = 0;
    while (v9 < *(_DWORD *)(a2[7] + 36))
    {
      *v7 = 0;
      v10 = btree_node_child_val((uint64_t)a2, (unsigned __int16)v9, v7);
      if ((_DWORD)v10 || (v10 = btree_node_get(a1, v7, 0, 0, *(_WORD *)(a2[7] + 34) - 1, 0, v14), (_DWORD)v10))
      {
        v12 = v10;
        goto LABEL_10;
      }
      v11 = v14[0];
      obj_lock(v14[0], 2);
      v12 = btree_delete_node(a1, v11, a3);
      obj_unlock(v11, 2);
      obj_release(v11);
      ++v9;
      if ((_DWORD)v12)
        goto LABEL_10;
    }
  }
  v12 = 0;
LABEL_10:
  obj_delete_and_free(a2, a3);
  return v12;
}

uint64_t btree_node_count(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  if (!a1)
    return 22;
  if (obj_type(a1) != 2)
    return 22;
  result = 0;
  *a2 = *(_QWORD *)(*(_QWORD *)(a1 + 392) + 32);
  return result;
}

uint64_t btree_node_init_ext(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  unsigned int v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;

  v6 = *(_QWORD *)(a1 + 56);
  result = btree_node_sanity_check((_QWORD *)a1, a2);
  if (!(_DWORD)result)
  {
    if (a2)
    {
      *(_OWORD *)(a1 + 400) = *(_OWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 416) = *(_QWORD *)(a2 + 24);
    }
    v8 = v6 + 56 + *(unsigned __int16 *)(v6 + 42);
    *(_QWORD *)(a1 + 376) = v6 + 56;
    *(_QWORD *)(a1 + 384) = v8;
    v9 = obj_size_phys(a1);
    v10 = *(_WORD *)(v6 + 32);
    v11 = -40;
    if ((v10 & 1) == 0)
      v11 = 0;
    v12 = v6 + v9 + v11;
    *(_QWORD *)(a1 + 392) = v12;
    if ((v10 & 1) != 0)
    {
      v13 = *(_QWORD *)(a1 + 400) & 0xFFFFFFFFFFFFFE00 | *(_DWORD *)v12 & 0x1FF;
      *(_QWORD *)(a1 + 400) = v13;
      v14 = v13 & 0xFFFFF07FFFFFFFFFLL | ((unint64_t)((*(_DWORD *)(v12 + 4) >> 12) & 0x1F) << 39);
      *(_QWORD *)(a1 + 400) = v14;
      v15 = v14 & 0xFFFFFFFFFF8001FFLL | ((*(_DWORD *)(v12 + 8) & 0x3FFFLL) << 9);
      *(_QWORD *)(a1 + 400) = v15;
      *(_QWORD *)(a1 + 400) = v15 & 0xFFFFFF80007FFFFFLL | ((unint64_t)*(unsigned __int16 *)(v12 + 12) << 23);
      *(_QWORD *)(a1 + 408) = obj_oid(a1);
    }
    if (a3)
      return authapfs_validate_node((_QWORD *)a1, a2);
    else
      return 0;
  }
  return result;
}

uint64_t btree_node_free_space_total(uint64_t a1)
{
  _WORD *v1;
  __int16 v2;
  __int16 v3;
  unsigned int v4;
  __int16 v5;

  v1 = *(_WORD **)(a1 + 56);
  if ((v1[16] & 4) != 0)
  {
    if ((*(_BYTE *)(a1 + 400) & 4) == 0)
    {
      v3 = 0;
      return (unsigned __int16)(v1[23] + v3 + v1[25] + v1[27]);
    }
    v2 = 4;
  }
  else
  {
    v2 = 8;
  }
  v4 = (unsigned __int16)v1[21];
  v5 = btree_node_toc_required_capacity(a1, 0);
  v3 = v4 - v5 * v2;
  if (v4 < (unsigned __int16)(v5 * v2))
    v3 = 0;
  return (unsigned __int16)(v1[23] + v3 + v1[25] + v1[27]);
}

uint64_t btree_node_space_free_list_search(uint64_t result, int a2, unsigned __int16 a3, __int16 *a4, unsigned __int16 *a5)
{
  unsigned __int16 v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned __int16 v9;
  uint64_t v11;
  uint64_t v12;
  __int16 v13;
  uint64_t v14;
  unsigned int v15;
  BOOL v16;
  unsigned int v17;
  uint64_t v18;
  __int16 v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  unsigned __int16 *v23;
  __int16 *v24;
  unsigned __int16 *v25;

  if ((*(_BYTE *)(result + 400) & 0x40) != 0)
    v5 = a3;
  else
    v5 = (a3 + 7) & 0xFFF8;
  v6 = 48;
  if (a2 != 1)
    v6 = 52;
  v7 = 392;
  if (a2 == 1)
    v7 = 384;
  v8 = *(unsigned __int16 *)(*(_QWORD *)(result + 56) + v6);
  v9 = -1;
  if (v8 == 0xFFFF)
  {
    v13 = -1;
    if (a4)
      goto LABEL_40;
    goto LABEL_41;
  }
  v11 = result;
  v24 = a4;
  v25 = a5;
  v12 = *(_QWORD *)(result + v7);
  v13 = -1;
  do
  {
    v9 = v8;
    v14 = (unsigned __int16)v8;
    if (a2 == 1)
    {
      v15 = *(unsigned __int16 *)(*(_QWORD *)(v11 + 56) + 44);
      v16 = v15 >= v9;
      v17 = v15 - v9;
      if (v17 != 0 && v16 && v17 >= 4)
      {
        v20 = *(unsigned __int16 *)(*(_QWORD *)(v11 + 384) + v14 + 2);
        if (v20 >= 4)
        {
          if ((*(_BYTE *)(v11 + 400) & 0x40) == 0)
            v20 = (v20 + 7) & 0x1FFF8;
          if (v20 <= (int)v17)
            goto LABEL_33;
        }
      }
    }
    else
    {
      result = obj_size_phys(v11);
      v18 = *(_QWORD *)(v11 + 56);
      if ((*(_BYTE *)(v18 + 32) & 1) != 0)
        v19 = -96;
      else
        v19 = -56;
      if (v9 <= (unsigned __int16)(result
                                                - *(_WORD *)(v18 + 42)
                                                + v19
                                                - (*(_WORD *)(v18 + 46)
                                                 + *(_WORD *)(v18 + 44)))
        && v9 >= 4u)
      {
        v21 = *(unsigned __int16 *)(*(_QWORD *)(v11 + 392) - v14 + 2);
        if (v21 >= 4)
        {
          if ((*(_BYTE *)(v11 + 400) & 0x40) == 0)
            v21 = (v21 + 7) & 0x1FFF8;
          if (v21 <= v9)
            goto LABEL_33;
        }
      }
    }
    result = nx_corruption_detected_int(*(_QWORD *)(*(_QWORD *)v11 + 392));
    if ((_DWORD)result)
      break;
LABEL_33:
    if (a2 == 1)
      v22 = v14;
    else
      v22 = -v14;
    v23 = (unsigned __int16 *)(v12 + v22);
    if (v23[1] >= v5)
      goto LABEL_39;
    v8 = *v23;
    v13 = v9;
  }
  while (v8 != 0xFFFF);
  v9 = -1;
  v13 = -1;
LABEL_39:
  a4 = v24;
  a5 = v25;
  if (v24)
LABEL_40:
    *a4 = v13;
LABEL_41:
  if (a5)
    *a5 = v9;
  return result;
}

uint64_t btree_node_compact(uint64_t a1, __int16 a2, uint64_t a3)
{
  uint64_t v6;
  __int16 v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  _OWORD *v16;
  _OWORD *v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  char v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int16 v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int16 *v32;
  unsigned __int16 *v33;
  int v34;
  uint64_t v35;
  unsigned __int16 *v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t inserted;
  const void *v41;
  const void *v42;
  _QWORD *v43;
  __int128 v45;
  int v46;
  __int16 v47;
  __int16 v48;
  __int128 v49;
  uint64_t v50;
  _QWORD *v51;

  v51 = 0;
  v6 = *(_QWORD *)(a1 + 56);
  v7 = *(_WORD *)(v6 + 32);
  if ((v7 & 1) != 0)
  {
    v10 = btree_node_copy(0, a1, 2281701376, (16 * v7) & 0x180, a3, 0, (uint64_t *)&v51);
    if ((_DWORD)v10)
      return v10;
    v11 = *(_QWORD *)(a1 + 56);
    *(_DWORD *)(v11 + 36) = 0;
    *(_WORD *)(v11 + 44) = 0;
    v12 = *(_QWORD *)(a1 + 392) - *(_QWORD *)(a1 + 384);
    *(_WORD *)(v11 + 46) = v12;
    *(_QWORD *)(v11 + 48) = 0xFFFF0000FFFFLL;
    bzero(*(void **)(a1 + 376), *(unsigned __int16 *)(v11 + 42) + (unint64_t)(unsigned __int16)v12);
    v13 = v51;
    v14 = v51[7];
    goto LABEL_11;
  }
  v45 = btree_node_desc;
  v46 = 2123139;
  v49 = *(_OWORD *)(a1 + 400);
  v50 = *(_QWORD *)(a1 + 416);
  v47 = v7;
  v48 = *(_WORD *)(v6 + 34);
  v8 = *(_DWORD *)(a1 + 40);
  LODWORD(v45) = *(unsigned __int16 *)(a1 + 36);
  DWORD1(v45) = v8;
  DWORD2(v45) = (*(_QWORD *)(a1 + 400) >> 27) & 0x1F000;
  v9 = obj_create(*(pthread_mutex_t **)a1, -2013265920, 0, (uint64_t)&v45, (uint64_t)&v46, *(_QWORD *)(a1 + 8), a3, (uint64_t *)&v51);
  if (!(_DWORD)v9)
  {
    v15 = v51;
    v16 = (_OWORD *)v51[7];
    v17 = *(_OWORD **)(a1 + 56);
    v18 = v17[1];
    *v16 = *v17;
    v16[1] = v18;
    v19 = obj_exchange_phys(a1, (uint64_t)v15);
    if ((_DWORD)v19)
    {
      v10 = v19;
      v20 = *(_QWORD *)(a1 + 8);
      if (v20)
        v21 = (const char *)(v20 + 3880);
      else
        v21 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
      v22 = obj_oid(a1);
      v23 = obj_oid((uint64_t)v51);
      log_err("%s:%d: %s obj_exchange_phys (%llx, %llx) with xid %llu failed: %d\n", "btree_node_compact", 1563, v21, v22, v23, a3, v10);
LABEL_36:
      obj_free((uint64_t)v51);
      obj_release(v51);
      obj_dirty(a1, a3, 0);
      return v10;
    }
    btree_node_init_ext(a1, (uint64_t)&v46, 0);
    btree_node_init_ext((uint64_t)v51, (uint64_t)&v46, 0);
    v13 = v51;
    v14 = v51[7];
    *(_WORD *)(*(_QWORD *)(a1 + 56) + 32) |= *(_WORD *)(v14 + 32) & 0x8000;
LABEL_11:
    v24 = btree_node_toc_required_capacity((uint64_t)v13, a2);
    v25 = 2;
    if ((*(_WORD *)(v14 + 32) & 4) == 0)
      v25 = 3;
    btree_node_toc_resize(a1, (v24 << v25) & 0xFFFC);
    v26 = v51;
    v27 = v51[7];
    if (*(_DWORD *)(v27 + 36))
    {
      v28 = 0;
      while (1)
      {
        v29 = *(_WORD *)(v27 + 32);
        v30 = v26[47];
        v31 = v28;
        v32 = (unsigned __int16 *)(v30 + 4 * v28);
        v33 = (unsigned __int16 *)(v30 + 8 * v28);
        if ((v29 & 4) != 0)
        {
          v33 = v32;
          v34 = (*((_DWORD *)v26 + 100) >> 9) & 0x3FFF;
        }
        else
        {
          v34 = *(unsigned __int16 *)(v30 + 8 * v31 + 2);
        }
        v35 = *v33;
        v36 = (unsigned __int16 *)(v30 + 4 * v31 + 2);
        v37 = v30 + 8 * v31 + 4;
        if ((v29 & 4) == 0)
          v36 = (unsigned __int16 *)v37;
        v38 = *v36;
        v39 = btree_node_val_len((uint64_t)v26, v31);
        if ((_DWORD)v35 == 0xFFFF)
        {
          v41 = 0;
        }
        else
        {
          inserted = btree_node_key_range_validate((uint64_t)v26, v35, v34);
          if ((_DWORD)inserted)
            break;
          v26 = v51;
          v41 = (const void *)(v51[48] + v35);
        }
        if (v38 > 0xFFFD)
        {
          v42 = 0;
        }
        else
        {
          inserted = btree_node_val_range_validate((uint64_t)v26, v38, v39);
          if ((_DWORD)inserted)
            break;
          v42 = (const void *)(v51[49] - v38);
        }
        inserted = btree_node_insert_internal(a1, v31, v41, v34, v42, v39, a3);
        if ((_DWORD)inserted)
          break;
        v28 = v31 + 1;
        v26 = v51;
        v27 = v51[7];
        if (*(_DWORD *)(v27 + 36) <= (unsigned __int16)(v31 + 1))
          goto LABEL_30;
      }
      v10 = inserted;
      if ((v7 & 1) != 0)
      {
        memcpy((void *)(*(_QWORD *)(a1 + 56) + 32), (const void *)(v51[7] + 32), v51[49] - v51[7] - 32);
        v43 = (_QWORD *)a1;
      }
      else
      {
        obj_exchange_phys(a1, (uint64_t)v51);
        btree_node_init_ext(a1, 0, 0);
        v43 = v51;
      }
      btree_node_init_ext((uint64_t)v43, 0, 0);
    }
    else
    {
LABEL_30:
      v10 = 0;
    }
    goto LABEL_36;
  }
  return v9;
}

uint64_t btree_node_space_free_list_alloc(uint64_t a1, int a2, unsigned __int16 a3, int a4, int a5)
{
  unsigned __int16 v5;
  uint64_t v6;
  _WORD *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t result;
  int v13;
  int v14;
  _WORD *v15;
  unsigned __int16 v16;
  int v17;
  _WORD *v18;

  if (a5 == 0xFFFF)
    return 22;
  if ((*(_QWORD *)(a1 + 400) & 0x40) != 0)
    v5 = a3;
  else
    v5 = (a3 + 7) & 0xFFF8;
  v6 = *(_QWORD *)(a1 + 56);
  v7 = (_WORD *)(v6 + 48);
  v8 = 48;
  if (a2 != 1)
  {
    v8 = 52;
    v7 = (_WORD *)(v6 + 52);
  }
  v9 = 392;
  if (a2 == 1)
  {
    v9 = 384;
    v10 = 1;
  }
  else
  {
    v10 = -1;
  }
  v11 = *(_QWORD *)(a1 + v9);
  v7[1] -= v5;
  if (a4 != 0xFFFF || (result = 0, *(unsigned __int16 *)(v6 + v8) == a5))
  {
    v13 = v5;
    v14 = v10;
    v15 = (_WORD *)(v11 + a5 * (uint64_t)v10);
    v16 = v15[1] - v13;
    if (v16 < 5u)
    {
      v18 = (_WORD *)(v11 + v10 * (uint64_t)a4);
      if (a4 != 0xFFFF)
        v7 = v18;
    }
    else
    {
      if (a4 != 0xFFFF)
        v7 = (_WORD *)(v11 + v10 * (uint64_t)a4);
      v17 = v10 * v13 + a5;
      *v7 = v17;
      v7 = (_WORD *)(v11 + v14 * (uint64_t)v17);
      v7[1] = v16;
    }
    result = 0;
    *v7 = *v15;
  }
  return result;
}

uint64_t btree_node_space_alloc(uint64_t a1, int a2, unsigned __int16 a3, _WORD *a4)
{
  uint64_t result;
  int v9;
  unsigned __int16 v10;
  uint64_t v11;
  unsigned int v12;
  unsigned __int16 v13;
  unsigned __int16 v14;

  v14 = -1;
  v13 = -1;
  btree_node_space_free_list_search(a1, a2, a3, (__int16 *)&v13, &v14);
  if (v14 == 0xFFFF)
  {
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
      v10 = a3;
    else
      v10 = (a3 + 7) & 0xFFF8;
    v11 = *(_QWORD *)(a1 + 56);
    v12 = *(unsigned __int16 *)(v11 + 46);
    if (v12 < v10)
      return 28;
    if (a2 == 1)
    {
      LOWORD(v9) = *(_WORD *)(v11 + 44);
      *(_WORD *)(v11 + 44) = v9 + v10;
      *(_WORD *)(v11 + 46) = v12 - v10;
    }
    else
    {
      *(_WORD *)(v11 + 46) = v12 - v10;
      if (a2 == 2)
        v9 = *(_DWORD *)(a1 + 392)
           - *(unsigned __int16 *)(v11 + 44)
           - (*(_DWORD *)(a1 + 384)
            + (unsigned __int16)(v12 - v10));
      else
        LOWORD(v9) = -1;
    }
  }
  else
  {
    result = btree_node_space_free_list_alloc(a1, a2, a3, v13, v14);
    if ((_DWORD)result)
      return result;
    LOWORD(v9) = v14;
  }
  result = 0;
  *a4 = v9;
  return result;
}

void btree_node_toc_resize(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  unsigned int v4;
  unsigned __int16 v5;
  unsigned __int16 v6;
  uint64_t v7;
  __int16 v8;

  v3 = *(_QWORD *)(a1 + 56);
  v4 = *(unsigned __int16 *)(v3 + 42);
  v5 = v4 - a2;
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
    memmove((void *)(*(_QWORD *)(a1 + 384) - v5), *(const void **)(a1 + 384), *(unsigned __int16 *)(v3 + 44));
    *(_QWORD *)(a1 + 384) -= v5;
    v7 = *(_QWORD *)(a1 + 56);
    *(_WORD *)(v7 + 46) += v5;
    v8 = *(_WORD *)(v7 + 42) - v5;
  }
  else
  {
    v6 = a2 - v4;
    memmove((void *)(*(_QWORD *)(a1 + 384) + (unsigned __int16)(a2 - v4)), *(const void **)(a1 + 384), *(unsigned __int16 *)(v3 + 44));
    bzero(*(void **)(a1 + 384), v6);
    *(_QWORD *)(a1 + 384) += v6;
    v7 = *(_QWORD *)(a1 + 56);
    *(_WORD *)(v7 + 46) -= v6;
    v8 = *(_WORD *)(v7 + 42) + v6;
  }
  *(_WORD *)(v7 + 42) = v8;
}

void *btree_node_toc_shift(uint64_t a1, int a2, int a3)
{
  uint64_t v3;
  __int16 v4;
  char v5;
  unsigned int v6;
  int v7;
  char v8;
  uint64_t v9;

  v3 = *(_QWORD *)(a1 + 56);
  v4 = *(_WORD *)(v3 + 32);
  if ((v4 & 4) != 0)
    v5 = 2;
  else
    v5 = 3;
  v6 = (a2 + (unsigned __int16)a3) << v5;
  v7 = a2 + (__int16)-(__int16)a3;
  if ((v4 & 4) != 0)
    v8 = 2;
  else
    v8 = 3;
  v9 = v7 << v8;
  if (a3 >= 0)
    v7 = a2;
  else
    v6 = a2 << v8;
  if (a3 >= 0)
  {
    v8 = v5;
    v9 = (a2 << v5);
  }
  return memmove((void *)(*(_QWORD *)(a1 + 376) + v6), (const void *)(*(_QWORD *)(a1 + 376) + v9), ((*(_DWORD *)(v3 + 36) - v7) << v8) & 0xFFFC);
}

uint64_t btree_node_child_id_update_cb(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, uint64_t a6, _QWORD *a7, int a8)
{
  uint64_t result;

  if (a8 != 8)
    return 22;
  result = 0;
  *a5 = *a7;
  return result;
}

uint64_t bt_move_entries(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  _WORD *v11;
  __int16 v12;
  unsigned __int16 v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int16 v24;
  unsigned __int16 v25;
  unsigned __int16 *v26;
  uint64_t v27;
  _WORD *v28;
  unsigned __int16 v29;
  __int16 v30;
  unsigned __int16 v31;
  uint64_t v32;
  unsigned __int16 *v33;
  uint64_t v34;
  _WORD *v35;
  uint64_t v36;
  __int16 v37;
  int v38;
  uint64_t inserted;
  _WORD *v40;
  uint64_t v41;
  __int16 v42;
  unsigned __int16 v43;
  unsigned __int16 *v44;
  uint64_t v45;
  _WORD *v46;
  unsigned __int16 v47;
  __int16 v48;
  unsigned __int16 v49;
  uint64_t v50;
  unsigned __int16 *v51;
  uint64_t v52;
  _WORD *v53;
  uint64_t v54;
  __int16 v55;
  __int16 v56;
  _DWORD __n[3];
  void *v59;

  if (a3 >= 0)
    LOWORD(v7) = a3;
  else
    v7 = -a3;
  v8 = (__int16)v7;
  if (a3 >= 0)
    v9 = a1;
  else
    v9 = a2;
  if (a3 >= 0)
    v10 = a2;
  else
    v10 = a1;
  v11 = *(_WORD **)(v10 + 56);
  if ((v11[16] & 4) != 0)
  {
    if ((*(_BYTE *)(v10 + 400) & 4) == 0)
      goto LABEL_19;
    v12 = 4;
  }
  else
  {
    v12 = 8;
  }
  v13 = btree_node_toc_required_capacity(v10, (__int16)v7) * v12;
  v14 = (unsigned __int16)v11[21];
  if (v14 >= v13)
    goto LABEL_19;
  if (v13 - v14 <= (unsigned __int16)v11[23])
  {
    btree_node_toc_resize(v10, v13);
    goto LABEL_19;
  }
  v15 = btree_node_compact(v10, (unsigned __int16)v8, a4);
  if (!(_DWORD)v15)
  {
LABEL_19:
    v59 = 0;
    memset(__n, 0, sizeof(__n));
    if (v9 == a2)
    {
      if (v8 < 1)
      {
        v37 = 0;
        v38 = 0;
LABEL_60:
        v15 = 0;
      }
      else
      {
        v36 = btree_node_key_ptr(a2, 0, &v59, (_WORD *)__n + 1);
        if ((_DWORD)v36)
        {
          v15 = v36;
          v37 = 0;
          v38 = 0;
        }
        else
        {
          v38 = 0;
          do
          {
            inserted = btree_node_val_ptr((_QWORD *)a2, (unsigned __int16)v38, &__n[1], (__int16 *)__n);
            if ((_DWORD)inserted)
              break;
            inserted = btree_node_insert_internal(a1, *(unsigned __int16 *)(*(_QWORD *)(a1 + 56) + 36), v59, HIWORD(__n[0]), *(const void **)&__n[1], LOWORD(__n[0]), a4);
            if ((_DWORD)inserted)
              break;
            v40 = *(_WORD **)(a2 + 56);
            v41 = *(_QWORD *)(a2 + 376);
            if ((*(_BYTE *)(a2 + 400) & 0x40) != 0)
              v42 = HIWORD(__n[0]);
            else
              v42 = (HIWORD(__n[0]) + 7) & 0xFFF8;
            v43 = (v42 + 7) & 0xFFF8;
            if ((*(_BYTE *)(a2 + 400) & 0x40) != 0)
              v43 = HIWORD(__n[0]);
            if (v43 >= 4u)
            {
              if ((v40[16] & 4) != 0)
                v44 = (unsigned __int16 *)(v41 + 4 * (unsigned __int16)v38);
              else
                v44 = (unsigned __int16 *)(v41 + 8 * (unsigned __int16)v38);
              v45 = *v44;
              v46 = (_WORD *)(*(_QWORD *)(a2 + 384) + v45);
              v46[1] = v43;
              *v46 = v40[24];
              v40[24] = v45;
            }
            v40[25] += v43;
            v47 = __n[0];
            if (LOWORD(__n[0]) && LOWORD(__n[0]) != 65534)
            {
              if ((*(_BYTE *)(a2 + 400) & 0x40) != 0)
                v48 = __n[0];
              else
                v48 = (LOWORD(__n[0]) + 7) & 0xFFF8;
              v49 = (v48 + 7) & 0xFFF8;
              if ((*(_BYTE *)(a2 + 400) & 0x40) == 0)
                v47 = v49;
              if (v47 >= 4u)
              {
                v50 = v41 + 8 * (unsigned __int16)v38 + 4;
                v51 = (unsigned __int16 *)(v41 + 4 * (unsigned __int16)v38 + 2);
                if ((v40[16] & 4) == 0)
                  v51 = (unsigned __int16 *)v50;
                v52 = *v51;
                v53 = (_WORD *)(*(_QWORD *)(a2 + 392) - v52);
                v53[1] = v47;
                *v53 = v40[26];
                v40[26] = v52;
              }
              v40[27] += v47;
            }
            v37 = ++v38;
            if ((__int16)v38 >= v8)
              goto LABEL_60;
            inserted = btree_node_key_ptr(a2, (unsigned __int16)v38, &v59, (_WORD *)__n + 1);
          }
          while (!(_DWORD)inserted);
          v15 = inserted;
          v37 = v38;
        }
      }
      btree_node_toc_shift(a2, 0, (__int16)-v37);
      *(_DWORD *)(*(_QWORD *)(a2 + 56) + 36) -= v38;
    }
    else if (v8 < 1)
    {
      v15 = 0;
    }
    else
    {
      btree_node_toc_shift(a2, 0, v8);
      v16 = 0;
      v17 = *(_QWORD *)(a2 + 56);
      *(_DWORD *)(v17 + 36) += (unsigned __int16)v8;
      *(_WORD *)(v17 + 32) |= 0x8000u;
      v18 = *(_QWORD *)(a2 + 376);
      do
      {
        if ((*(_WORD *)(v17 + 32) & 4) != 0)
          *(_DWORD *)(v18 + 4 * v16) = -1;
        else
          *(_QWORD *)(v18 + 8 * v16) = 0xFFFF0000FFFFLL;
        ++v16;
      }
      while (v8 > (__int16)v16);
      LOWORD(v19) = 0;
      v20 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 36);
      while (1)
      {
        v21 = btree_node_key_ptr(a1, (unsigned __int16)(v20 - 1), &v59, (_WORD *)__n + 1);
        if ((_DWORD)v21)
          break;
        v21 = btree_node_val_ptr((_QWORD *)a1, (unsigned __int16)(*(_WORD *)(*(_QWORD *)(a1 + 56) + 36) - 1), &__n[1], (__int16 *)__n);
        if ((_DWORD)v21)
          break;
        v21 = btree_node_entry_update(a2, (unsigned __int16)(v8 + ~(_WORD)v19), v59, HIWORD(__n[0]), *(void **)&__n[1]);
        if ((_DWORD)v21)
          break;
        v22 = *(_QWORD *)(a1 + 56);
        v20 = *(_DWORD *)(v22 + 36) - 1;
        *(_DWORD *)(v22 + 36) = v20;
        v23 = *(_QWORD *)(a1 + 376);
        if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
          v24 = HIWORD(__n[0]);
        else
          v24 = (HIWORD(__n[0]) + 7) & 0xFFF8;
        v25 = (v24 + 7) & 0xFFF8;
        if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
          v25 = HIWORD(__n[0]);
        if (v25 >= 4u)
        {
          if ((*(_WORD *)(v22 + 32) & 4) != 0)
            v26 = (unsigned __int16 *)(v23 + 4 * (unsigned __int16)v20);
          else
            v26 = (unsigned __int16 *)(v23 + 8 * (unsigned __int16)v20);
          v27 = *v26;
          v28 = (_WORD *)(*(_QWORD *)(a1 + 384) + v27);
          v28[1] = v25;
          *v28 = *(_WORD *)(v22 + 48);
          *(_WORD *)(v22 + 48) = v27;
        }
        *(_WORD *)(v22 + 50) += v25;
        v29 = __n[0];
        if (LOWORD(__n[0]) && LOWORD(__n[0]) != 65534)
        {
          if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
            v30 = __n[0];
          else
            v30 = (LOWORD(__n[0]) + 7) & 0xFFF8;
          v31 = (v30 + 7) & 0xFFF8;
          if ((*(_BYTE *)(a1 + 400) & 0x40) == 0)
            v29 = v31;
          if (v29 >= 4u)
          {
            v32 = v23 + 8 * (unsigned __int16)v20 + 4;
            v33 = (unsigned __int16 *)(v23 + 4 * (unsigned __int16)v20 + 2);
            if ((*(_WORD *)(v22 + 32) & 4) == 0)
              v33 = (unsigned __int16 *)v32;
            v34 = *v33;
            v35 = (_WORD *)(*(_QWORD *)(a1 + 392) - v34);
            v35[1] = v29;
            *v35 = *(_WORD *)(v22 + 52);
            *(_WORD *)(v22 + 52) = v34;
          }
          *(_WORD *)(v22 + 54) += v29;
        }
        v19 = (__int16)(v19 + 1);
        if (v19 >= v8)
        {
          v15 = 0;
          *(_WORD *)(*(_QWORD *)(a2 + 56) + 32) &= ~0x8000u;
          goto LABEL_90;
        }
      }
      v15 = v21;
      *(_WORD *)(*(_QWORD *)(a2 + 56) + 32) &= ~0x8000u;
      btree_node_toc_shift(a2, 0, (__int16)(v19 - v8));
    }
LABEL_90:
    v54 = *(_QWORD *)(v9 + 56);
    if ((*(_WORD *)(v54 + 32) & 4) != 0)
    {
      if ((*(_BYTE *)(v9 + 400) & 4) == 0)
      {
LABEL_96:
        *(_WORD *)(v9 + 440) = 0;
        obj_dirty(a1, a4, 0);
        obj_dirty(a2, a4, 0);
        return v15;
      }
      v55 = 4;
    }
    else
    {
      v55 = 8;
    }
    v56 = btree_node_toc_required_capacity(v9, 8);
    if (*(unsigned __int16 *)(v54 + 42) > (unsigned __int16)(v56 * v55))
      btree_node_toc_resize(v9, (unsigned __int16)(v56 * v55));
    goto LABEL_96;
  }
  return v15;
}

void btree_node_reinit_root(uint64_t a1, int a2, uint64_t a3)
{
  __int16 v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  __int16 v10;
  __int16 v11;
  __int128 v12;
  uint64_t v13;

  v9 = 2123139;
  if (a2)
    v5 = 1;
  else
    v5 = 3;
  v6 = *(_QWORD *)(a1 + 56);
  v10 = *(_WORD *)(v6 + 32) & 0x18 | v5;
  v11 = a2;
  v12 = *(_OWORD *)(a1 + 400);
  v13 = *(_QWORD *)(a1 + 416);
  bzero((void *)(v6 + 32), ((*(_QWORD *)(a1 + 400) >> 27) & 0x1F000) - 72);
  v7 = *(_QWORD *)(a1 + 56);
  v8 = obj_size_phys(a1);
  btree_node_init_phys(v7, v8, (uint64_t)&v9);
  btree_node_init_ext(a1, (uint64_t)&v9, 0);
  obj_dirty(a1, a3, 0);
}

uint64_t bt_update_last_leaf(uint64_t result, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  size_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(result + 432) == *(_QWORD *)(a3 + 112))
  {
    v4 = (_QWORD *)result;
    v5 = *(_QWORD *)(a2 + 56);
    if ((*(_WORD *)(v5 + 32) & 2) != 0 || !*(_DWORD *)(v5 + 36))
    {
      *(_QWORD *)(result + 432) = *(_QWORD *)(a2 + 112);
    }
    else
    {
      MEMORY[0x1E0C80A78]();
      v7 = (_QWORD *)((char *)v12 - v6);
      bzero((char *)v12 - v6, v8);
      result = btree_node_child_val(a2, (unsigned __int16)(*(_WORD *)(*(_QWORD *)(a2 + 56) + 36) - 1), v7);
      if ((_DWORD)result)
      {
        v9 = v4[1];
        if (v9)
          v10 = (const char *)(v9 + 3880);
        else
          v10 = (const char *)(*(_QWORD *)(*(_QWORD *)(*v4 + 392) + 384) + 208);
        result = (uint64_t)log_err("%s:%d: %s failed to update rightmost leaf field: %d\n", "bt_update_last_leaf", 2512, v10, result);
        v11 = 0;
      }
      else
      {
        v11 = *v7;
      }
      v4[54] = v11;
    }
  }
  return result;
}

void bt_merge_nodes(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v16;
  _QWORD *v17;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int16 v22;
  unsigned int v23;
  uint64_t *v24;
  int v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  __int16 v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  unint64_t *v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  const char *v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  int v55;
  uint64_t v56;
  unsigned int v57;
  unsigned int v58;
  _BOOL4 has_room;
  int v60;
  uint64_t v61;
  const char *v62;
  unint64_t *v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t *v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  unsigned int v71;
  uint64_t v72;
  uint64_t v73;
  unsigned __int16 v74;
  void *v75;
  uint64_t *v76;
  uint64_t v77[2];

  v10 = a6;
  v77[1] = *MEMORY[0x1E0C80C00];
  v77[0] = a6;
  MEMORY[0x1E0C80A78]();
  v17 = (uint64_t *)((char *)&v68 - v16);
  bzero((char *)&v68 - v16, v18);
  v75 = 0;
  v74 = 0;
  v19 = *(_QWORD *)(a4 + 56);
  if (!a2)
  {
    if ((*(_WORD *)(v19 + 32) & 2) != 0 || *(_DWORD *)(v19 + 36) != 1)
      return;
    if (a5 || v10 && (*(_BYTE *)(v10 + 16) & 0x10) != 0)
    {
      if (btree_node_child_val(a4, 0, v17)
        || btree_node_get((_QWORD *)a1, v17, a7, 3, *(_WORD *)(*(_QWORD *)(a4 + 56) + 34) - 1, a8, v77))
      {
        return;
      }
      v10 = v77[0];
      if ((*(_BYTE *)(a1 + 400) & 0x10) != 0 && *(_QWORD *)(v77[0] + 112) != *v17)
        btree_node_child_id_update(a4, 0, (uint64_t *)(v77[0] + 112), a8);
      v44 = 1;
    }
    else
    {
      v44 = 0;
    }
    if (btree_node_free_space_total(v10) > 0x27)
    {
      v48 = *(_QWORD *)(v10 + 56);
      if (*(unsigned __int16 *)(v48 + 46) > 0x27u
        || ((*(_WORD *)(v48 + 32) & 4) == 0 || (*(_BYTE *)(v10 + 400) & 4) != 0)
        && (btree_node_compact(v10, 0, a8), *(unsigned __int16 *)(*(_QWORD *)(v10 + 56) + 46) > 0x27u))
      {
        btree_node_remove(a4, 0, a8);
        btree_node_reinit_root(a4, (unsigned __int16)(*(_WORD *)(*(_QWORD *)(a4 + 56) + 34) - 1), a8);
        v49 = bt_move_entries(a4, v10, (__int16)-*(_WORD *)(*(_QWORD *)(v10 + 56) + 36), a8);
        if (!v49)
        {
          bt_update_last_leaf(a1, a4, v10);
          obj_delete_and_free((uint64_t *)v10, a8);
          if (v44)
          {
            obj_unlock(v10, 2);
            obj_release(v10);
          }
          v63 = (unint64_t *)(*(_QWORD *)(a1 + 392) + 32);
          do
            v64 = __ldxr(v63);
          while (__stxr(v64 - 1, v63));
          goto LABEL_51;
        }
        v50 = *(_QWORD *)(a1 + 8);
        if (v50)
          v51 = (const char *)(v50 + 3880);
        else
          v51 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
        log_err("%s:%d: %s failed to move all entries: %d\n", "bt_merge_nodes", 4362, v51, v49);
        bt_move_entries(a4, v10, *(__int16 *)(*(_QWORD *)(a4 + 56) + 36), a8);
        btree_node_reinit_root(a4, (unsigned __int16)(*(_WORD *)(*(_QWORD *)(a4 + 56) + 34) + 1), a8);
        if (!btree_node_key_ptr(v10, 0, &v75, &v74))
        {
          *v17 = *(_QWORD *)(v10 + 112);
          btree_node_insert_internal(a4, 0, v75, v74, v17, (*(_WORD *)(a4 + 406) & 0x7F) + 8, a8);
        }
      }
    }
    if (!v44)
      return;
    obj_unlock(v10, 2);
    v65 = v10;
    goto LABEL_110;
  }
  if (!*(_DWORD *)(v19 + 36))
  {
    btree_node_remove(a2, a3, a8);
    v45 = *(_QWORD *)(a2 + 56);
    if ((*(_WORD *)(v45 + 32) & 1) != 0 && !*(_DWORD *)(v45 + 36))
      btree_node_reinit_root(a2, 0, a8);
    bt_update_last_leaf(a1, a2, a4);
    obj_delete_and_free((uint64_t *)a4, a8);
    v46 = (unint64_t *)(*(_QWORD *)(a1 + 392) + 32);
    do
      v47 = __ldxr(v46);
    while (__stxr(v47 - 1, v46));
LABEL_51:
    obj_dirty(a1, a8, 0);
    return;
  }
  if (*(_DWORD *)(*(_QWORD *)(a2 + 56) + 36) - 1 > a3)
  {
    v20 = a3 + 1;
    if (!btree_node_child_val(a2, (unsigned __int16)v20, v17))
    {
      v76 = 0;
      if (!btree_node_get((_QWORD *)a1, v17, a7, 3, *(_WORD *)(*(_QWORD *)(a2 + 56) + 34) - 1, a8, (uint64_t *)&v76))
      {
        if ((*(_BYTE *)(a1 + 400) & 0x10) != 0 && v76[14] != *v17)
          btree_node_child_id_update(a2, (unsigned __int16)v20, v76 + 14, a8);
        v21 = *(_QWORD *)(a4 + 56);
        if ((*(_WORD *)(v21 + 32) & 4) != 0)
        {
          v52 = *(_DWORD *)(v21 + 36);
          v24 = v76;
          v72 = v76[7];
          v43 = *(_DWORD *)(v72 + 36);
          v53 = v43 + v52;
          if (v43 + v52 <= btree_node_toc_required_capacity(a4, 0))
          {
            v73 = 0;
            LOWORD(v30) = v43;
          }
          else
          {
            if (v52 >= (unsigned __int16)(v53 >> 1))
              v30 = 0;
            else
              v30 = (v53 >> 1) - v52;
            v73 = v30;
          }
        }
        else
        {
          v69 = v20;
          v22 = btree_node_toc_required_capacity(a4, 0);
          v23 = btree_node_free_space_total(a4);
          v24 = v76;
          v25 = btree_node_free_space_total((uint64_t)v76);
          v26 = 0;
          v27 = 0;
          v72 = v24[7];
          v73 = 0;
          v28 = *(_DWORD *)(v72 + 36);
          v29 = 8 * (v22 & 0x1FFF);
          v70 = v23 - ((v25 + v23) >> 1);
          v71 = v28;
          do
          {
            LODWORD(v30) = v26;
            if (v71 <= (unsigned __int16)v26)
              break;
            if (!(_WORD)v73 && (_WORD)v26)
            {
              v31 = btree_node_toc_required_capacity(a4, (__int16)v26);
              v32 = (8 * (_WORD)v31 - (_WORD)v29) & 0xFFF8;
              if (((8 * v31) & 0xFFF8u) <= v29)
                v32 = 0;
              if (v32 + (unsigned __int16)v27 <= v70)
                v33 = 0;
              else
                v33 = v26;
              v73 = v33;
            }
            v34 = v24[50];
            v35 = *(_WORD *)(v72 + 32);
            if ((v34 & 0x40) != 0)
            {
              if ((v35 & 4) != 0)
                v37 = (v34 >> 9) & 0x3FFF;
              else
                v37 = *(unsigned __int16 *)(v24[47] + 8 * (unsigned __int16)v30 + 2);
            }
            else
            {
              if ((v35 & 4) != 0)
                v36 = (v34 >> 9) & 0x3FFF;
              else
                v36 = *(unsigned __int16 *)(v24[47] + 8 * (unsigned __int16)v30 + 2);
              v37 = (v36 + 7) & 0x1FFF8;
            }
            v38 = v37 + v27;
            v39 = btree_node_val_len((uint64_t)v24, (unsigned __int16)v30);
            if (v39 == 65534)
              v40 = 0;
            else
              v40 = v39;
            if ((v34 & 0x40) == 0)
              v40 = (v40 + 7) & 0x1FFF8;
            v27 = v38 + v40;
            v26 = v30 + 1;
            v41 = btree_node_toc_required_capacity(a4, (__int16)(v30 + 1));
            v42 = (8 * (_WORD)v41 - (_WORD)v29) & 0xFFF8;
            if (((8 * v41) & 0xFFF8u) <= v29)
              v42 = 0;
          }
          while (v42 + (unsigned __int16)v27 <= v23);
          LOWORD(v20) = v69;
          v43 = v71;
        }
        if (v43 != (unsigned __int16)v30)
        {
          if ((*(_WORD *)(*(_QWORD *)(a2 + 56) + 32) & 4) != 0)
            v54 = (*(_DWORD *)(a2 + 400) >> 9) & 0x3FFF;
          else
            v54 = *(unsigned __int16 *)(*(_QWORD *)(a2 + 376) + 8 * (unsigned __int16)v20 + 2);
          if ((*(_WORD *)(v72 + 32) & 4) != 0)
            v55 = (*((_DWORD *)v24 + 100) >> 9) & 0x3FFF;
          else
            v55 = *(unsigned __int16 *)(v24[47] + 8 * (unsigned __int16)v73 + 2);
          v74 = v55;
          v56 = *(_QWORD *)(a2 + 400);
          if ((v56 & 0x40) != 0)
            v57 = v54;
          else
            v57 = (v54 + 7) & 0x1FFF8;
          v58 = (v55 + 7) & 0x1FFF8;
          if ((v56 & 0x40) != 0)
            v58 = v55;
          if (v57 >= v58)
          {
            LOWORD(v30) = v73;
          }
          else
          {
            if ((v56 & 0x40) == 0)
            {
              LOWORD(v55) = (v55 + 7) & 0xFFF8;
              LOWORD(v54) = (v54 + 7) & 0xFFF8;
            }
            has_room = btree_node_has_room(a2, 0, 0, 0, v55 - v54, 0, 0);
            LOWORD(v30) = v73;
            if (!has_room)
              goto LABEL_109;
          }
        }
        if ((_WORD)v30 && !bt_move_entries(a4, (uint64_t)v24, (__int16)-(__int16)v30, a8))
        {
          if (*(_DWORD *)(v24[7] + 36))
          {
            v60 = btree_node_key_ptr((uint64_t)v24, 0, &v75, &v74);
            if (v60 || (v60 = btree_node_entry_update(a2, (unsigned __int16)v20, v75, v74, 0)) != 0)
            {
              v61 = *(_QWORD *)(a1 + 8);
              if (v61)
                v62 = (const char *)(v61 + 3880);
              else
                v62 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
              log_err("%s:%d: %s btree_node_key_update failed: %d\n", "bt_merge_nodes", 4503, v62, v60);
            }
          }
          else
          {
            btree_node_remove(a2, (unsigned __int16)v20, a8);
            bt_update_last_leaf(a1, a2, (uint64_t)v24);
            obj_delete_and_free(v24, a8);
            v66 = (unint64_t *)(*(_QWORD *)(a1 + 392) + 32);
            do
              v67 = __ldxr(v66);
            while (__stxr(v67 - 1, v66));
            obj_dirty(a1, a8, 0);
          }
        }
LABEL_109:
        obj_unlock((uint64_t)v24, 2);
        v65 = (uint64_t)v24;
LABEL_110:
        obj_release(v65);
      }
    }
  }
}

uint64_t spaceman_metazone_init(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t *v4;
  uint64_t v6;
  char v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;

  v25 = 0;
  if (*(_BYTE *)(a1 + 639))
  {
    log_debug("%s:%d: %s Skipping metazone_init() as backing store is sparse\n", "spaceman_metazone_init", 72, (const char *)(*(_QWORD *)(a1 + 384) + 208));
    return 0;
  }
  v27 = 0;
  v28 = 0;
  v26 = 0;
  v2 = spaceman_get((_QWORD *)a1, &v25);
  if ((_DWORD)v2)
    return v2;
  v4 = (uint64_t *)v25;
  if (!v25)
    return 19;
  if (!*(_QWORD *)(v25 + 376))
  {
    v2 = 19;
    goto LABEL_11;
  }
  if (*(_BYTE *)(v25 + 1104) || *(_BYTE *)(v25 + 1208))
  {
    v2 = 0;
LABEL_11:
    obj_release(v4);
    return v2;
  }
  v6 = 0;
  v7 = 1;
  do
  {
    v8 = v7;
    v9 = v25;
    v10 = v25 + 104 * v6;
    *(_OWORD *)(v10 + 1008) = 0u;
    *(_OWORD *)(v10 + 1024) = 0u;
    *(_OWORD *)(v10 + 1040) = 0u;
    *(_OWORD *)(v10 + 1056) = 0u;
    *(_OWORD *)(v10 + 1072) = 0u;
    *(_OWORD *)(v10 + 1088) = 0u;
    *(_QWORD *)(v10 + 1104) = 0;
    v11 = *(_QWORD *)(v9 + 376);
    v12 = *(unsigned int *)(v11 + 32);
    v13 = *(_QWORD *)(v11 + 48 * v6 + 48);
    if (is_mul_ok(v13, v12))
      v14 = v13 * v12;
    else
      v14 = 0x40000000000;
    if (!spaceman_metazone_get_size(a2, v12, v13, v14, &v28, &v27))
    {
      v15 = v9 + 104 * v6;
      v16 = v27 + v28 / v12;
      spaceman_metazone_get_partitions(v12, v28, v27, v16, &v26, 0);
      *(_QWORD *)(v15 + 1008) = v27;
      *(_QWORD *)(v15 + 1024) = v27;
      *(_QWORD *)(v15 + 1016) = v26;
      *(_BYTE *)(v15 + 1034) = 1;
      *(_QWORD *)(v15 + 1040) = v26;
      *(_QWORD *)(v15 + 1056) = v26;
      *(_QWORD *)(v15 + 1048) = v16;
      *(_BYTE *)(v15 + 1066) = 1;
      *(_BYTE *)(v15 + 1105) = 1;
      v17 = v25;
      v18 = v25 + 8 * v6;
      v19 = *(_QWORD *)(v18 + 992);
      if (v19 < v16 && v19 >= v27)
      {
        if (v16 == v13)
          v21 = 0;
        else
          v21 = v16;
        *(_QWORD *)(v18 + 992) = v21;
      }
      if (*(_QWORD *)(v18 + 1488))
      {
        v22 = *(unsigned int *)(*(_QWORD *)(v17 + 376) + 36);
        v23 = v27 / v22;
        v24 = (v16 - 1) / v22;
        if (v23 <= v24)
        {
          do
            *(_DWORD *)(*(_QWORD *)(v25 + 8 * v6 + 1488) + 4 * v23++) |= 0x4000000u;
          while (v23 <= v24);
          v17 = v25;
        }
      }
      *(_BYTE *)(v17 + 104 * v6 + 1104) = 1;
    }
    v7 = 0;
    v6 = 1;
  }
  while ((v8 & 1) != 0);
  v2 = 0;
  v4 = (uint64_t *)v25;
  if (v25)
    goto LABEL_11;
  return v2;
}

uint64_t spaceman_handle_metazone_freed(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = (a3 << __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(result + 376) + 36))) >> 62) & 1;
  v4 = a2 + 104 * v3;
  if (*(_BYTE *)(v4 + 1104) && *(_BYTE *)(a2 + 104 * v3 + 1105))
  {
    v5 = (unint64_t *)(v4 + 1008);
    if (*v5 <= a3 && v5[1] > a3)
    {
      v7 = v5[2];
      v6 = v5 + 2;
      if (v7 <= a3)
        return result;
LABEL_15:
      *v6 = a3;
      return result;
    }
    if (*(_QWORD *)(a2 + 104 * v3 + 1040) > a3
      || *(_QWORD *)(a2 + 104 * v3 + 1048) <= a3)
    {
      if (*(_QWORD *)(a2 + 104 * v3 + 1072) <= a3
        && *(_QWORD *)(a2 + 104 * v3 + 1080) > a3)
      {
        v9 = a2 + 104 * v3;
        if (*(_QWORD *)(v9 + 1088) > a3)
        {
          v6 = (unint64_t *)(v9 + 1088);
          goto LABEL_15;
        }
      }
    }
    else
    {
      v8 = a2 + 104 * v3;
      if (*(_QWORD *)(v8 + 1056) > a3)
      {
        v6 = (unint64_t *)(v8 + 1056);
        goto LABEL_15;
      }
    }
  }
  return result;
}

uint64_t spaceman_update_metazone_alloc_index(uint64_t result, unsigned int a2, int a3, unint64_t a4)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t *v7;
  __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  __int16 v12;
  __int16 v13;

  if (a3 == 2)
  {
    v9 = result + 104 * a2;
    v5 = (unint64_t *)(v9 + 1072);
    v6 = (unint64_t *)(v9 + 1080);
    v7 = (unint64_t *)(v9 + 1088);
    v8 = (__int16 *)(v9 + 1096);
  }
  else if (a3 == 1)
  {
    v10 = result + 104 * a2;
    v5 = (unint64_t *)(v10 + 1040);
    v6 = (unint64_t *)(v10 + 1048);
    v7 = (unint64_t *)(v10 + 1056);
    v8 = (__int16 *)(v10 + 1064);
  }
  else
  {
    if (a3)
      return result;
    v4 = result + 104 * a2;
    v5 = (unint64_t *)(v4 + 1008);
    v6 = (unint64_t *)(v4 + 1016);
    v7 = (unint64_t *)(v4 + 1024);
    v8 = (__int16 *)(v4 + 1032);
  }
  v11 = *v5;
  if (v11 <= a4 && *v6 > a4)
  {
    *v7 = a4;
LABEL_18:
    *v8 = 0;
    return result;
  }
  if (*v7 == v11)
  {
    *v7 = a4;
    v12 = 1;
  }
  else
  {
    if (*v8 < 0)
    {
      *v7 = v11;
      goto LABEL_18;
    }
    v13 = *v8;
    if (!*v8)
    {
      *v7 = v11;
      return result;
    }
    *v7 = a4;
    v12 = v13 + 1;
  }
  *v8 = v12;
  return result;
}

uint64_t spaceman_get_metazone_alloc_index(_QWORD *a1, unsigned int a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;

  v4 = a2;
  if (a3 == 2)
  {
    if (BYTE2(a1[13 * a2 + 137]))
      v5 = (uint64_t)&a1[13 * a2 + 136];
    else
      v5 = (uint64_t)&a1[13 * a2 + 132];
  }
  else if (a3 == 1)
  {
    v5 = (uint64_t)&a1[13 * a2 + 132];
  }
  else if (a3)
  {
    v6 = a1[1];
    if (v6)
      v7 = (const char *)(v6 + 3880);
    else
      v7 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 384) + 208);
    log_err("%s:%d: %s tried to get metazone alloc index for unknown type: %d\n", "spaceman_get_metazone_alloc_index", 348, v7, a3);
    v5 = (uint64_t)&a1[v4 + 124];
  }
  else
  {
    v5 = (uint64_t)&a1[13 * a2 + 128];
  }
  return *(_QWORD *)v5;
}

uint64_t spaceman_allocation_init(_QWORD *a1)
{
  uint64_t v2;
  pthread_mutex_t *v3;
  _DWORD *v4;
  int v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  pthread_mutex_t *v18;

  v18 = 0;
  v2 = spaceman_get(a1, (uint64_t *)&v18);
  if (!(_DWORD)v2)
  {
    pthread_mutex_lock(v18 + 6);
    v3 = v18;
    v4 = *(_DWORD **)&v18[5].__opaque[48];
    if ((v4[36] & 1) == 0 || !v4[84])
    {
      v5 = v4[29];
      if (!v5)
        v5 = v4[28];
      v6 = (v4[32] + 8 * v5);
      v7 = v4[8];
      if ((int)v6 + 2184 <= (v6 + v7 - 1) / v7 * v7)
      {
        memmove(v4 + 630, v4 + 84, v6 - 336);
        v10 = (v4[81] + 2184);
        v4[81] = v10;
        v11 = (v4[82] + 2184);
        v4[82] = v11;
        v12 = (v4[83] + 2184);
        v4[83] = v12;
        v13 = (v4[20] + 2184);
        v4[20] = v13;
        v14 = (v4[32] + 2184);
        v4[32] = v14;
        *(_QWORD *)&v3[13].__opaque[24] = (char *)v4 + v10;
        *(_QWORD *)&v3[13].__opaque[32] = (char *)v4 + v11;
        *(_QWORD *)&v3[13].__opaque[40] = (char *)v4 + v12;
        *(_QWORD *)&v3[13].__opaque[48] = (char *)v4 + v13;
        v3[14].__sig = (uint64_t)v4 + v14;
        *((_QWORD *)v4 + 42) = 0x9D800000001;
        bzero(v4 + 86, 0x880uLL);
        v4[36] |= 1u;
      }
      else
      {
        v8 = *(_QWORD *)v18->__opaque;
        if (v8)
          v9 = (const char *)(v8 + 3880);
        else
          v9 = (const char *)(*(_QWORD *)(*(_QWORD *)(v18->__sig + 392) + 384) + 208);
        log_debug("%s:%d: %s refusing to upgrade spaceman! new_smp_size %u old_smp_size %u block_size %u\n", "spaceman_upgrade_sm_version_0_to_1", 398, v9, v6 + 2184, v6, v7);
        log_warn("%s:%d: %s failed to upgrade spaceman from version 0 to 1: %d\n", "spaceman_allocation_init", 456, (const char *)(a1[48] + 208), 27);
      }
    }
    spaceman_free_queue_trim_list_init((uint64_t)a1, (uint64_t)v18);
    v2 = spaceman_metazone_init((uint64_t)a1, 0);
    if (!(_DWORD)v2)
    {
      spaceman_sanitize_datazone((const char *)v18);
      v15 = 1;
      while (1)
      {
        v16 = spaceman_datazone_init(a1, v15);
        if ((_DWORD)v16)
          break;
        if (++v15 == 5)
        {
          v2 = spaceman_free_extent_cache_setup((uint64_t)a1, (uint64_t)v18);
          goto LABEL_18;
        }
      }
      v2 = v16;
      log_err("%s:%d: %s failed to initialize data zone for allocations of size %llu, error %d\n", "spaceman_allocation_init", 491, (const char *)(a1[48] + 208), v15, v16);
    }
  }
LABEL_18:
  if (v18)
  {
    pthread_mutex_unlock(v18 + 6);
    obj_release(&v18->__sig);
  }
  return v2;
}

const char *spaceman_sanitize_datazone(const char *result)
{
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  BOOL v10;
  uint64_t v11;
  const char *v12;
  char v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  char v25;

  if (result)
  {
    v1 = result;
    v24 = *((_QWORD *)result + 47);
    if ((*(_BYTE *)(v24 + 144) & 1) != 0)
    {
      if (*(_DWORD *)(v24 + 336))
      {
        v2 = 0;
        v3 = v24 + 344;
        v4 = 1;
        do
        {
          v25 = v4;
          v5 = *(_QWORD *)(v24 + 48 * v2 + 48);
          if (v5)
          {
            v6 = 0;
            v7 = v24 + 368 + 1088 * v2;
            do
            {
              v8 = v3 + 1088 * v2 + 136 * v6;
              if (*(_QWORD *)v8 >= v5
                || ((v9 = *(_QWORD *)(v8 + 8), v9 <= v5) ? (v10 = *(_QWORD *)v8 > v9) : (v10 = 1), v10))
              {
                v11 = *((_QWORD *)v1 + 1);
                if (v11)
                  v12 = (const char *)(v11 + 3880);
                else
                  v12 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 392) + 384) + 208);
                result = log_warn("%s:%d: %s Persistent allocation zone at slot %llu has invalid current boundaries\n", "spaceman_sanitize_datazone", 676, v12, v6);
                v13 = 1;
              }
              else
              {
                v13 = 0;
              }
              v14 = 0;
              v15 = (unint64_t *)v7;
              while (1)
              {
                v16 = *(v15 - 1);
                if (v16 >= v5)
                  break;
                if (*v15 > v5 || v16 > *v15)
                  break;
                ++v14;
                v15 += 2;
                if (v14 == 7)
                {
                  if (*(unsigned __int16 *)(v3 + 1088 * v2 + 136 * v6 + 130) <= 6u)
                  {
                    if ((v13 & 1) == 0)
                      goto LABEL_39;
                    goto LABEL_35;
                  }
LABEL_31:
                  v20 = *((_QWORD *)v1 + 1);
                  if (v20)
                    v21 = (const char *)(v20 + 3880);
                  else
                    v21 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 392) + 384) + 208);
                  log_warn("%s:%d: %s Persistent allocation zone at slot %llu has invalid previous boundary index\n", "spaceman_sanitize_datazone", 695, v21, v6);
                  goto LABEL_35;
                }
              }
              v18 = *((_QWORD *)v1 + 1);
              if (v18)
                v19 = (const char *)(v18 + 3880);
              else
                v19 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 392) + 384) + 208);
              log_warn("%s:%d: %s Persistent allocation zone at slot %llu has invalid previous boundary %llu\n", "spaceman_sanitize_datazone", 686, v19, v6, v14);
              if (*(unsigned __int16 *)(v3 + 1088 * v2 + 136 * v6 + 130) >= 7u)
                goto LABEL_31;
LABEL_35:
              v22 = *((_QWORD *)v1 + 1);
              if (v22)
                v23 = (const char *)(v22 + 3880);
              else
                v23 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 392) + 384) + 208);
              result = log_warn("%s:%d: %s Clearing persistent allocation zone at slot %llu\n", "spaceman_sanitize_datazone", 701, v23, v6);
              *(_QWORD *)(v8 + 128) = 0;
              *(_OWORD *)(v8 + 96) = 0u;
              *(_OWORD *)(v8 + 112) = 0u;
              *(_OWORD *)(v8 + 64) = 0u;
              *(_OWORD *)(v8 + 80) = 0u;
              *(_OWORD *)(v8 + 32) = 0u;
              *(_OWORD *)(v8 + 48) = 0u;
              *(_OWORD *)v8 = 0u;
              *(_OWORD *)(v8 + 16) = 0u;
LABEL_39:
              ++v6;
              v7 += 136;
            }
            while (v6 != 8);
          }
          v4 = 0;
          v2 = 1;
        }
        while ((v25 & 1) != 0);
      }
    }
  }
  return result;
}

uint64_t spaceman_datazone_init(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  unint64_t v9;
  uint64_t v11;
  uint64_t *v12;

  v12 = 0;
  v4 = spaceman_get(a1, (uint64_t *)&v12);
  if ((_DWORD)v4)
    return v4;
  if (!v12)
    return 19;
  v6 = v12[47];
  if (!v6)
  {
    v4 = 19;
    goto LABEL_15;
  }
  if ((unint64_t)(a2 - 5) < 0xFFFFFFFFFFFFFFFCLL)
  {
    v4 = 22;
    goto LABEL_15;
  }
  v7 = v12 + 152;
  v8 = &v12[4 * a2 + 148];
  if (*((_BYTE *)v8 + 24))
    goto LABEL_14;
  v9 = *(_QWORD *)(v6 + 56);
  if (!*((_BYTE *)v12 + 1104) || v9 < 8)
    goto LABEL_14;
  *((_BYTE *)v12 + 1344) = 1;
  *(_OWORD *)v8 = 0u;
  *((_OWORD *)v8 + 1) = 0u;
  v11 = spaceman_initialize_allocation_zone_from_disk(v12, 0, a2);
  if ((_DWORD)v11)
  {
    v4 = v11;
    log_err("%s:%d: %s failed to initialize allocation zone for allocations of %llu blocks from disk: error %d\n", "spaceman_datazone_init", 600, (const char *)(a1[48] + 208), a2, v11);
  }
  else
  {
    if (BYTE1(v7[4 * a2 - 1]))
    {
LABEL_14:
      v4 = 0;
      goto LABEL_15;
    }
    log_debug("%s:%d: %s allocation zone on dev %d for allocations of %llu blocks starting at paddr %llu\n", "spaceman_datazone_init", 611, (const char *)(a1[48] + 208), 0, a2, *v8);
    v4 = 0;
    *((_BYTE *)v8 + 24) = 1;
  }
LABEL_15:
  if (v12)
    obj_release(v12);
  return v4;
}

uint64_t spaceman_initialize_allocation_zone_from_disk(_QWORD *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  unsigned __int16 v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  int v16;
  uint64_t v18;
  _QWORD *v20;
  uint64_t updated;
  uint64_t v22;
  const char *v23;

  v3 = 22;
  if (a1)
  {
    v4 = a3;
    if ((unint64_t)(a3 - 5) >= 0xFFFFFFFFFFFFFFFCLL)
    {
      v6 = a3 - 1;
      v7 = (uint64_t)&a1[17 * a2 + 152];
      v8 = a1[47];
      if ((*(_BYTE *)(v8 + 144) & 1) != 0 && *(_DWORD *)(v8 + 336))
      {
        v9 = v8 + 344;
        v10 = v4;
        v11 = -1;
        v12 = 1;
        v13 = 8;
        v14 = v6;
        do
        {
          v15 = v14 & 7;
          v16 = *(unsigned __int16 *)(v9 + 1088 * a2 + 136 * v15 + 128);
          if (v16 == v10)
          {
            v20 = (_QWORD *)(v9 + 1088 * a2 + 136 * v15);
            *(_QWORD *)(v7 + 32 * v6 + 16) = v20;
            updated = spaceman_update_allocation_zone_boundaries((uint64_t)a1, a2, v6, *v20 / (unint64_t)*(unsigned int *)(v8 + 36));
            v3 = updated;
            if ((_DWORD)updated)
            {
              v22 = a1[1];
              if (v22)
                v23 = (const char *)(v22 + 3880);
              else
                v23 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 384) + 208);
              log_err("%s:%d: %s failed to update allocation zone boundaries: error %d\n", "spaceman_initialize_allocation_zone_from_disk", 965, v23, updated);
            }
            return v3;
          }
          if (!*(_WORD *)(v9 + 1088 * a2 + 136 * v15 + 128))
            v12 = 0;
          if (v11 == -1 && v16 == 0)
            v11 = v15;
          v14 = v15 + 1;
          --v13;
        }
        while (v13);
        if ((v12 & 1) != 0)
          goto LABEL_17;
        v3 = 0;
        v18 = v7 + 32 * v6;
        *(_QWORD *)(v18 + 16) = v9 + 1088 * a2 + 136 * v11;
        *(_BYTE *)(v18 + 25) = 1;
      }
      else
      {
LABEL_17:
        v3 = 0;
        *(_WORD *)(v7 + 32 * v6 + 25) = 257;
      }
    }
  }
  return v3;
}

void spaceman_datazone_destroy(uint64_t a1)
{
  uint64_t v2;
  char v3;
  char v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  if (a1)
  {
    v2 = 0;
    v3 = 1;
    do
    {
      v4 = v3;
      if (*(_BYTE *)(a1 + 136 * v2 + 1344))
      {
        v5 = 0;
        v6 = a1 + 136 * v2;
        do
        {
          v7 = v6 + v5;
          if (*(_BYTE *)(v6 + v5 + 1240) && *(_BYTE *)(v7 + 1242))
          {
            v8 = *(void **)(v6 + v5 + 1232);
            if (v8)
            {
              *(_BYTE *)(v7 + 1240) = 0;
              _apfs_free(v8, 136);
              *(_QWORD *)(v6 + v5 + 1232) = 0;
            }
          }
          v5 += 32;
        }
        while (v5 != 128);
      }
      v3 = 0;
      v2 = 1;
    }
    while ((v4 & 1) != 0);
  }
}

uint64_t spaceman_update_allocation_zone_boundaries(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned __int16 *v23;
  uint64_t result;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  if (!a1)
    return 22;
  v6 = *(_QWORD *)(a1 + 376);
  v7 = *(_QWORD *)(v6 + 48 * a2 + 56);
  if (v7 <= a4)
    return 22;
  v8 = a2;
  v9 = v6 + 48 * a2;
  v10 = a1 + 136 * a2;
  v11 = v10 + 1216;
  v12 = v10 + 1216 + 32 * a3;
  v13 = *(unsigned __int16 **)(v12 + 16);
  v14 = *(unsigned int *)(v6 + 36);
  v15 = *(_QWORD *)(v9 + 48);
  v16 = *(_QWORD *)v12;
  if (*(_BYTE *)(v12 + 26))
    v17 = v13 == 0;
  else
    v17 = 0;
  if (v17)
  {
    v30 = v10 + 1216;
    v18 = a3;
    v13 = (unsigned __int16 *)_apfs_calloc(1uLL, 0x88uLL);
    a3 = v18;
    v11 = v30;
    *(_QWORD *)(v12 + 16) = v13;
    if (!v13)
      return 12;
  }
  if (*(_BYTE *)(v12 + 24))
  {
    v19 = 0;
    v20 = v13[65];
    while (1)
    {
      v21 = ((unint64_t)(v20 + v19) * (unsigned __int128)0x2492492492492493uLL) >> 64;
      v22 = v20 + v19 - 7 * ((v21 + ((unint64_t)(v20 + v19 - v21) >> 1)) >> 2);
      v23 = &v13[8 * v22];
      if (*((_QWORD *)v23 + 3))
      {
        if (*((_QWORD *)v23 + 2) / (unint64_t)*(unsigned int *)(*(_QWORD *)(a1 + 376) + 36) == a4)
          break;
      }
      if (++v19 == 7)
        goto LABEL_19;
    }
    if (v22 == v20)
    {
LABEL_19:
      *(_OWORD *)&v13[8 * v20 + 8] = *(_OWORD *)v12;
      v13[65] = v20
              + 1
              - 7
              * ((((unsigned __int16)(v20 + 1 - ((9363 * (unsigned __int16)(v20 + 1)) >> 16)) >> 1)
                + ((9363 * (unsigned __int16)(v20 + 1)) >> 16)) >> 2);
      goto LABEL_20;
    }
    do
    {
      if (v22 == 6)
        v27 = 0;
      else
        v27 = v22 + 1;
      *(_OWORD *)&v13[8 * v22 + 8] = *(_OWORD *)&v13[8 * v27 + 8];
      v22 = v27;
    }
    while (v27 != v20);
    v28 = v20 - 1;
    v17 = (_DWORD)v20 == 0;
    v29 = 6;
    if (!v17)
      v29 = v28;
    *(_OWORD *)&v13[8 * v29 + 8] = *(_OWORD *)v12;
  }
LABEL_20:
  *(_QWORD *)v12 = v14 * a4;
  if (v7 - 1 == a4)
    v25 = v15;
  else
    v25 = v14 + v14 * a4;
  *(_QWORD *)v13 = v14 * a4;
  *((_QWORD *)v13 + 1) = v25;
  v26 = v11 + 32 * a3;
  *(_QWORD *)(v26 + 8) = v25;
  v13[64] = a3 + 1;
  *(_BYTE *)(v26 + 25) = 0;
  if (*(_BYTE *)(v12 + 24))
    *(_DWORD *)(*(_QWORD *)(a1 + 8 * v8 + 1488) + 4 * (v16 / v14)) &= ~0x8000000u;
  result = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 8 * v8 + 1488) + 4 * a4) |= 0x8000000u;
  return result;
}

uint64_t spaceman_get_number_of_disabled_allocation_zones(uint64_t result, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    if (*(_BYTE *)(result + 136 * a2 + 1344))
    {
      v2 = 0;
      v3 = result + 136 * a2;
      result = 4;
      do
      {
        if (*(_BYTE *)(v3 + v2 + 1240) || !*(_BYTE *)(v3 + v2 + 1241))
          result = (result - 1);
        v2 += 32;
      }
      while (v2 != 128);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t spaceman_evaluate_chunk_for_disabled_allocation_zones(_QWORD *a1, unsigned int a2, unint64_t a3, _BYTE *a4)
{
  unint64_t v8;
  _BYTE *i;
  int v10;
  int v11;
  unint64_t v12;
  uint64_t v14;
  uint64_t updated;
  uint64_t v17;
  const char *v18;
  const char *v19;

  if (!a1 || !LOBYTE(a1[17 * a2 + 168]) || *(_QWORD *)(a1[47] + 48 * a2 + 56) <= a3)
    return 22;
  v8 = 0;
  for (i = (char *)&a1[17 * a2 + 155] + 1; ; i += 32)
  {
    if (!*(i - 1) && *i)
    {
      v10 = *(_DWORD *)(a1[a2 + 186] + 4 * a3);
      v11 = v10 & 0xC000000;
      v12 = *(_QWORD *)&v10 & 0xFFFFFFLL;
      if (!v11 && v8 < v12)
        break;
    }
    if (++v8 == 4)
      return 0;
  }
  updated = spaceman_update_allocation_zone_boundaries((uint64_t)a1, a2, v8, a3);
  v17 = a1[1];
  if ((_DWORD)updated)
  {
    v14 = updated;
    if (v17)
      v18 = (const char *)(v17 + 3880);
    else
      v18 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 384) + 208);
    log_err("%s:%d: %s failed to assign chunk %llu to allocation zone %llu\n", "spaceman_evaluate_chunk_for_disabled_allocation_zones", 1135, v18, a3, v8);
  }
  else
  {
    if (v17)
      v19 = (const char *)(v17 + 3880);
    else
      v19 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 384) + 208);
    log_debug("%s:%d: %s allocation zone on dev %d for allocations of %llu blocks starting at paddr %llu\n", "spaceman_evaluate_chunk_for_disabled_allocation_zones", 1140, v19, a2, v8 + 1, *(_QWORD *)(i - 25));
    v14 = 0;
    *(i - 1) = 1;
    *a4 = 1;
  }
  return v14;
}

uint64_t spaceman_get_new_chunk_for_allocation_zone(uint64_t a1, uint64_t a2, unsigned int a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  int v19;
  unint64_t v20;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v26;
  unsigned int *v27;
  unint64_t v28;
  unsigned int *v29;
  unsigned int v30;
  unint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  unsigned int *v34;
  unint64_t v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  uint64_t v39;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  BOOL v49;
  int v50;
  unint64_t v51;
  int *v52;
  unint64_t v53;
  int v54;
  unint64_t v55;
  int v56;
  uint64_t updated;
  uint64_t v60;
  uint64_t *v61;
  int v62;
  int v63;
  unint64_t v65;
  _QWORD *v66;
  unsigned int *v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  uint64_t v73;
  uint64_t v74;
  unsigned int *v75;
  unint64_t v76;
  unsigned int *v77;
  unint64_t v78;

  v4 = 22;
  if (a1)
  {
    v5 = a2;
    if (a2)
    {
      if (a3 <= 1 && a4 <= 3)
      {
        v7 = *(unsigned int **)(a2 + 376);
        v77 = 0;
        v78 = 0;
        v75 = 0;
        v76 = 0;
        v73 = 0;
        v74 = 0;
        v8 = a3;
        v9 = a2 + 136 * a3 + 32 * a4;
        v10 = *(_QWORD *)(v9 + 1216);
        v11 = v7[9];
        v12 = *(_QWORD *)(v9 + 1232);
        v13 = *(_QWORD *)&v7[12 * a3 + 14];
        if (!v12)
          goto LABEL_14;
        v14 = *(unsigned __int16 *)(v12 + 130);
        v15 = 7;
        while (1)
        {
          v16 = *(_QWORD *)(v12 + 16 * v14 + 24);
          if (v16 && v16 <= *(_QWORD *)&v7[12 * a3 + 12])
          {
            v17 = *(_QWORD *)(v12 + 16 * v14 + 16) / v11;
            v18 = *(_DWORD *)(*(_QWORD *)(a2 + 8 * a3 + 1488) + 4 * v17);
            v19 = v18 & 0xC000000;
            v20 = *(_QWORD *)&v18 & 0xFFFFFFLL;
            if (!v19 && v20 > a4)
              break;
          }
          v14 = ((unsigned __int16)v14
                             + 1
                             - 7 * ((613566757 * (unint64_t)((unsigned __int16)v14 + 1)) >> 32));
          if (!--v15)
            goto LABEL_14;
        }
        if (v17 < v13)
        {
          v31 = 0;
LABEL_55:
          updated = spaceman_update_allocation_zone_boundaries(v5, a3, a4, v17);
          if ((_DWORD)updated)
          {
            v4 = updated;
            log_err("%s:%d: %s failed to update allocate zone %llu: error %d\n");
          }
          else
          {
            v60 = *(_QWORD *)(v5 + 1584);
            if (v60)
              ++*(_QWORD *)(v60 + (v8 << 6) + 8 * a4 + 120);
            if (*(_DWORD *)(v5 + 1592))
            {
              v61 = (uint64_t *)(*(_QWORD *)(v5 + 1600) + 16 * *(unsigned int *)(v5 + 1596));
              v4 = 0;
              *v61 = get_timestamp();
              v61[1] = v8 & 1 | (2 * (a4 & 7)) & 0xF | (v31 << 44) | (16 * (v17 & 0xFFFFFFFFFFLL));
              v62 = *(_DWORD *)(v5 + 1596);
              if ((v62 + 1) < *(_DWORD *)(v5 + 1592))
                v63 = v62 + 1;
              else
                v63 = 0;
              *(_DWORD *)(v5 + 1596) = v63;
            }
            else
            {
              v4 = 0;
            }
          }
        }
        else
        {
LABEL_14:
          v22 = v10 / v11;
          v23 = v7[10];
          v24 = v13 - 1;
          v26 = v22 + 1 == v23 || v22 == v24;
          v27 = &v7[12 * a3];
          v30 = v27[16];
          v29 = v27 + 16;
          LODWORD(v28) = v30;
          if (v30 > v26)
          {
            v31 = 0;
            v70 = 0;
            v65 = v22;
            v67 = &v7[12 * a3 + 17];
            v68 = (v22 / v23);
            v32 = a2 + 8 * a3;
            v66 = (_QWORD *)(v32 + 888);
            v33 = (_QWORD *)(v32 + 1488);
            v69 = -1;
            v17 = -1;
            v34 = v29;
            do
            {
              v35 = (v68 + v26) % v28;
              if (*v67)
              {
                v36 = v7[11];
                v37 = v35 / v36;
                v38 = v69;
                v39 = v70;
                if (v35 / v36 != v69 || v70 == 0)
                {
                  v41 = *(_QWORD *)(*v66 + 8 * v37);
                  if (v74)
                  {
                    obj_release(v74);
                    v74 = 0;
                  }
                  v77 = v7;
                  v78 = __PAIR64__(v37, a3);
                  v42 = obj_get(*(_QWORD *)(a1 + 392), 0x40000000, v41, &sm_cab_desc, &v77, 0, 0, 0, &v74);
                  if ((_DWORD)v42)
                  {
                    v4 = v42;
                    log_err("%s:%d: %s error getting cab %d: %d\n", "spaceman_get_new_chunk_for_allocation_zone", 1248, (const char *)(*(_QWORD *)(a1 + 384) + 208), v37, v42);
                    goto LABEL_58;
                  }
                  v39 = *(_QWORD *)(v74 + 56);
                  v36 = v7[11];
                  v38 = v37;
                }
                v69 = v38;
                v70 = v39;
                v43 = (uint64_t *)(v39 + 8 * (v35 - v36 * v38) + 40);
              }
              else
              {
                v43 = (uint64_t *)(*v66 + 8 * v35);
              }
              v44 = *v43;
              v75 = v7;
              v76 = __PAIR64__(v35, a3);
              v45 = obj_get(*(_QWORD *)(a1 + 392), 0x40000000, v44, &sm_cib_desc, &v75, 0, 0, 0, &v73);
              if ((_DWORD)v45)
              {
                v4 = v45;
                log_err("%s:%d: %s error getting cib %d: %d\n");
                goto LABEL_58;
              }
              if (v26)
                LODWORD(v46) = 0;
              else
                LODWORD(v46) = v65 % v7[10] + 1;
              v47 = *(_QWORD *)(v73 + 56);
              v48 = *(_DWORD *)(v47 + 36);
              v49 = v48 >= v46;
              v50 = v48 - v46;
              if (v50 != 0 && v49)
              {
                v51 = v35 * v7[10];
                v46 = v46;
                v52 = (int *)(v47 + 32 * v46 + 60);
                v53 = v17;
                do
                {
                  v54 = *v52;
                  v52 += 8;
                  v55 = v54 & 0xFFFFF;
                  if (v31 < v55)
                  {
                    v17 = v51 + v46;
                    v56 = *(_DWORD *)(*v33 + 4 * (v51 + v46));
                    if ((v56 & 0xC000000) == 0 && (*(_QWORD *)&v56 & 0xFFFFFFuLL) > a4)
                    {
                      v31 = v55;
                      v53 = v51 + v46;
                      if ((_DWORD)v55 == v7[9])
                        break;
                    }
                  }
                  ++v46;
                  v17 = v53;
                  --v50;
                }
                while (v50);
              }
              if (v31 == v7[9])
                break;
              obj_release(v73);
              v73 = 0;
              ++v26;
              v28 = *v34;
            }
            while (v26 < v28);
            v8 = a3;
            v5 = a2;
            if (v17 != -1)
              goto LABEL_55;
          }
          v4 = 28;
        }
LABEL_58:
        if (v74)
          obj_release(v74);
        if (v73)
          obj_release(v73);
      }
    }
  }
  return v4;
}

BOOL spaceman_should_avoid_data_allocation_at_block(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  uint64_t v8;
  uint64_t v9;

  if (!a4)
    return 0;
  v4 = *(_QWORD *)(a1 + 8 * a2 + 1488);
  if (!v4)
    return 0;
  if (*(_BYTE *)(a1 + 104 * a2 + 1104))
  {
    v5 = a1 + 104 * a2;
    v6 = (unint64_t *)(*(_BYTE *)(v5 + 1098) ? v5 + 1080 : v5 + 1048);
    if (*(_QWORD *)(v5 + 1008) <= a3 && *v6 > a3)
      return 1;
  }
  if ((*(_DWORD *)(v4 + 4 * (a3 / *(unsigned int *)(*(_QWORD *)(a1 + 376) + 36))) & 0x8000000) == 0)
    return 0;
  if (a4 <= 4
    && (v8 = a4 - 1, v9 = a1 + 136 * a2 + 1216, *(_BYTE *)(v9 + 32 * (a4 - 1) + 24))
    && *(_QWORD *)(v9 + 32 * v8) <= a3)
  {
    return *(_QWORD *)(v9 + 32 * v8 + 8) <= a3;
  }
  else
  {
    return 1;
  }
}

BOOL spaceman_clip_extent(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, __int16 a5, unint64_t a6, unint64_t *a7, unint64_t *a8)
{
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v19;

  v19 = 0;
  v14 = calc_overlap_range(a1, a2, a3, a4, &v19);
  if (v14)
  {
    v15 = a2 - v14;
    if (a2 == v14)
    {
      v16 = 0;
LABEL_17:
      *a8 = v16;
      return v14 != 0;
    }
    v16 = v19 - a1;
    if (v19 == a1)
    {
      v17 = v14 + a1;
LABEL_9:
      *a7 = v17;
LABEL_10:
      v16 = v15;
      goto LABEL_17;
    }
    v15 = a2 - (v16 + v14);
    if ((a5 & 0x4000) != 0)
    {
      if (a6 > v19 && a2 != v16 + v14 && (v19 + v14 <= a6 || a6 - v19 > v19 + v14 - a6))
      {
        *a7 = v19 + v14;
        goto LABEL_10;
      }
    }
    else if (v15 > v16)
    {
      v17 = v19 + v14;
      goto LABEL_9;
    }
    *a7 = a1;
    goto LABEL_17;
  }
  return v14 != 0;
}

uint64_t spaceman_clip_extent_to_zones(uint64_t a1, uint64_t a2, unsigned int a3, unint64_t a4, uint64_t a5, __int16 a6, unint64_t a7, unint64_t *a8, unint64_t *a9)
{
  uint64_t v12;
  unint64_t v13;
  uint64_t v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  unint64_t v20;
  char v21;
  unsigned int v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v31;
  _BOOL4 v32;

  v12 = a5;
  v13 = a4;
  v16 = *(_QWORD *)(a1 + 1760);
  if (v16
    && !*(_BYTE *)(a1 + 636)
    && (v17 = *(_QWORD *)(a1 + 1752),
        v18 = __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(a1 + 376) + 36))),
        (((v17 << v18) & 0x4000000000000000) != 0) == a3))
  {
    v19 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v18;
    v20 = v19 & v17;
    if ((a6 & 0x200) != 0)
    {
      if (v20 && (v31 = v19 & v17, v32 = spaceman_clip_extent(a4, a5, 0, v19 & v17, a6, a7, a8, a9), v20 = v31, v32))
      {
        v13 = *a8;
        v12 = *a9;
        v21 = 1;
      }
      else
      {
        v21 = 0;
      }
      v20 += v16;
      v16 = *(_QWORD *)(*(_QWORD *)(a2 + 376) + 48 * a3 + 48) - v20;
    }
    else
    {
      v21 = 0;
    }
    if (spaceman_clip_extent(v13, v12, v20, v16, a6, a7, a8, a9))
    {
      v13 = *a8;
      v12 = *a9;
      v21 = 1;
    }
  }
  else
  {
    v21 = 0;
  }
  if ((a6 & 0x2000) != 0)
  {
    v22 = a3;
    if (*(_BYTE *)(a2 + 104 * a3 + 1104))
    {
      v23 = a2 + 104 * a3;
      v24 = *(_QWORD *)(v23 + 1008);
      v25 = *(unsigned __int8 *)(v23 + 1098);
      v26 = (_QWORD *)(v23 + 1080);
      v27 = (_QWORD *)(v23 + 1048);
      if (v25)
        v27 = v26;
      if (spaceman_clip_extent(v13, v12, v24, *v27 - v24, a6, a7, a8, a9))
      {
        v13 = *a8;
        v12 = *a9;
        v21 = 1;
      }
    }
    if (*(_BYTE *)(a2 + 136 * a3 + 1344))
    {
      v28 = 0;
      v29 = a2 + 136 * v22;
      do
      {
        if (*(_BYTE *)(v29 + v28 + 1240)
          && spaceman_clip_extent(v13, v12, *(_QWORD *)(v29 + v28 + 1216), *(_QWORD *)(v29 + v28 + 1224) - *(_QWORD *)(v29 + v28 + 1216), a6, a7, a8, a9))
        {
          v13 = *a8;
          v12 = *a9;
          v21 = 1;
        }
        v28 += 32;
      }
      while (v28 != 128);
    }
  }
  return v21 & 1;
}

uint64_t utf8_normalizeOptCaseFoldAndHash(unint64_t a1, uint64_t a2, int a3, void (*a4)(_OWORD *, uint64_t, uint64_t), uint64_t a5)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v12;
  unsigned int v13;
  char v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  _OWORD v18[2];
  _OWORD v19[8];
  _QWORD v20[5];

  v20[2] = *MEMORY[0x1E0C80C00];
  v16 = 0;
  v17 = a1;
  v20[0] = 0;
  v20[1] = 0;
  v8 = a1 + a2;
  v15 = 0;
  v14 = 1;
  do
  {
    memset(v19, 0, sizeof(v19));
    memset(v18, 0, sizeof(v18));
    v13 = 0;
    v12 = 0;
    v9 = nextBaseAndAnyMarks(&v17, v8, a3, (unsigned int *)v20, (uint64_t)&v16 + 4, (int *)&v16, &v15, (uint64_t)v19, (uint64_t)v18, (int *)&v13, &v12, &v14);
    if ((_DWORD)v9)
      break;
    v10 = v13;
    if ((int)v13 >= 1)
    {
      if (v12)
        doReorder((uint64_t)v19, (uint64_t)v18, v13);
      a4(v19, 4 * v10, a5);
    }
  }
  while (v17 < v8 || (int)v16 > 0);
  return v9;
}

uint64_t nextBaseAndAnyMarks(unint64_t *a1, unint64_t a2, int a3, unsigned int *a4, uint64_t a5, int *a6, int *a7, uint64_t a8, uint64_t a9, int *a10, _BYTE *a11, _BYTE *a12)
{
  int v18;
  int v19;
  uint64_t result;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int8 *v25;
  unsigned __int8 *v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v33;
  char v34;
  BOOL v35;
  unsigned __int8 v36;
  unsigned int v37;
  unsigned int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  signed int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  uint64_t v53;
  unsigned int v54;
  char *v55;
  unsigned __int16 *v56;
  unsigned int v57;
  unsigned int v58;
  _DWORD *v59;
  uint64_t v60;
  int v61;
  int v62;
  char CombClassU32Char;
  uint64_t v64;
  uint64_t v65;
  int v66;
  unsigned int v67;
  int v68;
  int *v69;
  _BYTE *v70;
  int v71;
  uint64_t v72;
  char *v73;

  v18 = *a6;
  v19 = *a7;
  if (*a6 >= 1 && v19 < v18)
  {
    v22 = 0;
    *a11 = 0;
    *a10 = 0;
    v19 = *a7;
    while (1)
    {
      if (v22 >= 1
        && *(_BYTE *)(a5 + v19)
        && *(unsigned __int8 *)(a5 + v19) < *(unsigned __int8 *)(a9 + (v22 - 1)))
      {
        *a11 = 1;
      }
      *(_DWORD *)(a8 + 4 * v22) = a4[v19];
      v23 = *a7;
      *a7 = v23 + 1;
      LOBYTE(v23) = *(_BYTE *)(a5 + v23);
      v24 = *a10;
      *a10 = v24 + 1;
      *(_BYTE *)(a9 + v24) = v23;
      v19 = *a7;
      v18 = *a6;
      if (*a7 >= *a6 || !*(_BYTE *)(a5 + v19))
        break;
      v22 = *a10;
    }
  }
  if (v19 < v18)
    return 0;
  result = 0;
  *a6 = 0;
  *a7 = 0;
  v25 = (unsigned __int8 *)*a1;
  if (*a1 < a2)
  {
    while (1)
    {
      v27 = v25 + 1;
      *a1 = (unint64_t)(v25 + 1);
      v28 = *v25;
      result = 92;
      if (!*v25 || v28 == 47)
        return result;
      if ((v28 & 0x80) == 0)
      {
        result = 0;
        if (v28 - 91 < 0xFFFFFFE6)
          v66 = 1;
        else
          v66 = a3;
        if (v66)
          v67 = *v25;
        else
          v67 = v28 + 32;
        *a4 = v67;
        *a6 = 1;
        *(_BYTE *)a5 = 0;
        goto LABEL_136;
      }
      if (v28 - 225 > 0xB)
      {
        if (v28 - 194 <= 0x1D && (unint64_t)v27 < a2)
        {
          v33 = *v27 ^ 0x80;
          if (v33 <= 0x3F)
          {
            v31 = ((v28 & 0x1F) << 6) | v33;
            v27 = v25 + 2;
            goto LABEL_52;
          }
        }
      }
      else if ((unint64_t)(v25 + 2) < a2)
      {
        v29 = *v27 ^ 0x80;
        if (v29 <= 0x3F)
        {
          v30 = v25[2] ^ 0x80;
          if (v30 <= 0x3F)
          {
            v31 = ((v28 & 0xF) << 12) | (v29 << 6) | v30;
            v27 = v25 + 3;
            goto LABEL_52;
          }
        }
      }
      if (v28 > 0xEF)
      {
        if (v28 > 0xFD)
        {
          v36 = 0;
          goto LABEL_41;
        }
        if (v28 <= 0xF7)
          v34 = 3;
        else
          v34 = 4;
        v35 = v28 > 0xFB;
      }
      else
      {
        v34 = v28 > 0xDF;
        v35 = v28 > 0xBF;
      }
      if (v35)
        v36 = v34 + 1;
      else
        v36 = v34;
LABEL_41:
      v31 = -1;
      if ((unint64_t)&v27[v36] <= a2)
      {
        v37 = v28 & ~(-1 << (6 - v36));
        if (v36 == 1)
          goto LABEL_49;
        if (v36 == 2
          || v36 == 3
          && (v27 = v25 + 2, v38 = v25[1] ^ 0x80, v31 = -1, v38 <= 0x3F)
          && (v37 = v38 | (v37 << 6), v37 <= 0x10F))
        {
          v39 = *v27++;
          v40 = v39 ^ 0x80;
          v31 = -1;
          if ((v39 ^ 0x80u) <= 0x3F)
          {
            v37 = v40 | (v37 << 6);
            if ((v37 & 0xFFE0) != 0x360)
            {
LABEL_49:
              v41 = *v27++;
              v42 = v41 ^ 0x80;
              if ((v41 ^ 0x80u) > 0x3F || (v31 = v42 | (v37 << 6), (signed int)v31 < utf8_minLegal[v36]))
                v31 = -1;
            }
          }
        }
      }
LABEL_52:
      *a1 = (unint64_t)v27;
      if ((int)v31 < 1)
        return result;
      *(_BYTE *)a5 = 0;
      if (v31 >= 0xF0000)
      {
        if ((~v31 & 0xFFFE) == 0)
          goto LABEL_137;
LABEL_55:
        *a4 = v31;
        goto LABEL_63;
      }
      v43 = v31;
      if (v31 >> 10 >= 0xC9)
      {
        if (v31 - 918016 < 0xFFFFFE00)
          goto LABEL_137;
        v43 = v31 - 711680;
      }
      v44 = (unsigned __int16)nfTrieHi[v43 >> 8];
      if (!nfTrieHi[v43 >> 8])
        goto LABEL_62;
      if (v44 == 0xFFFF)
        goto LABEL_137;
      if ((v44 & 0xFF00) == 0xAD00)
      {
LABEL_62:
        *a4 = v31;
        *(_BYTE *)a5 = v44;
        goto LABEL_63;
      }
      if ((unint64_t)(((uint64_t)v43 >> 8) - 172) <= 0x2A)
        goto LABEL_77;
      v52 = nfTrieMid[16 * (v44 & 0xFFF) + (v43 >> 4)];
      if (!v52)
      {
LABEL_83:
        *a4 = v31;
        *(_BYTE *)a5 = v52;
        goto LABEL_84;
      }
      if (v52 == 0xFFFF)
        goto LABEL_137;
      if ((v52 & 0xFF00) == 0xAE00)
      {
        if (((nfU16InvMasks[v52] >> (v43 & 0xF)) & 1) != 0)
          goto LABEL_137;
        *a4 = v31;
        v45 = 1;
        if (v31 <= 0x4FF && (a3 & 1) == 0)
          *a4 = nfBasicCF[v31];
        goto LABEL_64;
      }
      if ((v52 & 0xFF00) == 0xAD00)
        goto LABEL_83;
      if (v52 == 44032 || (v54 = (unsigned __int16)nfTrieLo[16 * (v52 & 0xFFF) + (v43 & 0xF)], v54 == 44032))
      {
LABEL_77:
        v48 = v31 - 44032;
        v49 = v48 / 28;
        v50 = v48 / 588;
        *(_WORD *)(a5 + 1) = 0;
        v51 = v48 % 28;
        *a4 = v50 + 4352;
        a4[1] = (unsigned __int16)(v49
                                 - 21
                                 * (((__int16)((49933 * (__int16)v49) >> 16) >> 4)
                                  + ((unsigned __int16)(((49933 * (__int16)v49) >> 16) & 0x8000) >> 15))
                                 + 4449);
        if (v51)
        {
          a4[2] = v51 + 4519;
          v45 = 3;
        }
        else
        {
          v45 = 2;
        }
        goto LABEL_64;
      }
      if (v54 == 0xFFFF)
      {
LABEL_137:
        v68 = -1;
        goto LABEL_138;
      }
      if (((unsigned __int16)(v54 + 1792) >> 8) <= 0xB6u)
      {
        if (!v54 || (v54 & 0xFF00) == 0xAD00)
        {
          *a4 = v31;
          *(_BYTE *)a5 = v54;
        }
        else
        {
          *a4 = v54;
        }
LABEL_84:
        if ((a3 & 1) == 0)
        {
          v53 = (int)*a4;
          if ((int)v53 <= 1279)
          {
            v31 = nfBasicCF[v53];
            goto LABEL_55;
          }
        }
LABEL_63:
        v45 = 1;
LABEL_64:
        *a6 = v45;
        goto LABEL_65;
      }
      switch(((v54 & 0xF000) - 45056) >> 12)
      {
        case 0u:
          if ((v54 & 0x800) != 0 && a3)
            goto LABEL_55;
          v69 = 0;
          v55 = (char *)&nfU16Seq2 + 4 * (v54 & 0x7FF);
          v45 = 2;
          goto LABEL_113;
        case 1u:
          if ((v54 & 0x800) != 0 && a3)
            goto LABEL_55;
          v69 = 0;
          v55 = (char *)&nfU16Seq3 + 6 * (v54 & 0x7FF);
          v45 = 3;
          goto LABEL_113;
        case 2u:
          v69 = 0;
          v56 = (unsigned __int16 *)((char *)&nfU16SeqMisc + 2 * (v54 & 0x3FF));
          v58 = *v56;
          v55 = (char *)(v56 + 1);
          v57 = v58;
          goto LABEL_112;
        case 3u:
          if ((v54 & 0x800) != 0 && a3)
            goto LABEL_55;
          v55 = 0;
          v69 = (int *)((char *)&nfU32Char + 4 * (v54 & 0x7FF));
          v45 = 1;
          goto LABEL_113;
        case 4u:
          v55 = 0;
          v59 = (_DWORD *)((char *)&nfU32SeqMisc + 4 * (v54 & 0x3FF));
          v57 = *v59;
          v69 = v59 + 1;
LABEL_112:
          v45 = v57 & 0xF;
          *(_BYTE *)a5 = v57 >> 4;
          if ((v45 - 5) < 0xFFFFFFFC)
          {
            v68 = 0;
LABEL_138:
            *a6 = v68;
            return result;
          }
LABEL_113:
          v60 = 0;
          v70 = a12;
          v71 = a3;
          do
          {
            if (v55)
            {
              v62 = *(unsigned __int16 *)v55;
              v55 += 2;
              v61 = v62;
            }
            else
            {
              v61 = *v69++;
            }
            a4[v60] = v61;
            if (v60)
            {
              v72 = v60;
              v73 = v55;
              CombClassU32Char = getCombClassU32Char(v61);
              v60 = v72;
              v55 = v73;
              *(_BYTE *)(a5 + v72) = CombClassU32Char;
            }
            ++v60;
            a12 = v70;
            a3 = v71;
          }
          while (v45 != v60);
          if ((v71 & 1) != 0)
            goto LABEL_126;
          v64 = (int)*a4;
          if ((int)v64 <= 1279)
            *a4 = nfBasicCF[v64];
          if (v45 < 2)
            goto LABEL_63;
          v65 = (v45 - 1);
          if (a4[v65] == 837)
            a4[v65] = 953;
LABEL_126:
          *a6 = v45;
          if (v45 < 1)
            return 92;
          break;
        default:
          goto LABEL_137;
      }
LABEL_65:
      if (!*(_BYTE *)a5 || *a12)
      {
        result = 0;
LABEL_136:
        *a12 = 0;
        return result;
      }
      v46 = *a10;
      if (v45 + *a10 > 32)
        return 92;
      v47 = 0;
      do
      {
        if (v46 >= 1
          && *(_BYTE *)(a5 + v47)
          && *(unsigned __int8 *)(a5 + v47) < *(unsigned __int8 *)(a9 + (v46 - 1)))
        {
          *a11 = 1;
        }
        *(_DWORD *)(a8 + 4 * v46) = a4[v47];
        *(_BYTE *)(a9 + *a10) = *(_BYTE *)(a5 + v47++);
        v46 = *a10 + 1;
        *a10 = v46;
      }
      while (v47 < *a6);
      *a6 = 0;
      v25 = (unsigned __int8 *)*a1;
      if (*a1 >= a2)
        return 0;
    }
  }
  return result;
}

uint64_t doReorder(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  int v10;

  if ((int)a3 >= 2)
  {
    v3 = 0;
    v4 = result + 4 * a3 - 4;
    do
    {
      v5 = *(unsigned __int8 *)(a2 + a3 - 1);
      v6 = (int *)v4;
      v7 = a3 - 2;
      do
      {
        v8 = *(unsigned __int8 *)(a2 + v7);
        if (v5 < v8)
        {
          v9 = (_BYTE *)(a2 + v7);
          v10 = *v6;
          *v6 = *(v6 - 1);
          result = *(unsigned __int8 *)(a2 + v7);
          v9[1] = result;
          *(v6 - 1) = v10;
          *v9 = v5;
          v8 = v5;
        }
        --v6;
        v5 = v8;
      }
      while (v7-- > v3);
      ++v3;
    }
    while (v3 != a3 - 1);
  }
  return result;
}

uint64_t getCombClassU32Char(int a1)
{
  int v2;
  int v3;
  BOOL v4;
  __int16 v5;

  if (a1 >= 983040)
    return 0;
  if (a1 == 953)
    return 240;
  v2 = a1 - 711680;
  if (a1 <= 205823)
    v2 = a1;
  LOWORD(v3) = nfTrieHi[v2 >> 8];
  if ((_WORD)v3)
    v4 = (v3 & 0xFF00) == 44288;
  else
    v4 = 1;
  if (v4)
    return v3;
  v3 = nfTrieMid[16 * (v3 & 0xFFF) + (v2 >> 4)];
  if (!v3)
    return v3;
  if ((v3 & 0xFF00) == 0xAE00)
    return 0;
  if ((v3 & 0xFF00) == 0xAD00)
    return v3;
  v5 = nfTrieLo[16 * (v3 & 0xFFF) + (v2 & 0xF)];
  if ((v5 & 0xFF00) == 0xAD00)
    return v5;
  else
    return 0;
}

uint64_t spaceman_init_phys(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v22;
  uint64_t v23;
  unsigned int v24;

  if (!a3)
    return 22;
  v3 = *(_QWORD *)a3;
  v4 = *(_QWORD *)(*(_QWORD *)a3 + 16);
  if (!v4)
    return 22;
  v5 = *(_QWORD *)(v3 + 128);
  if (!v5)
    return 22;
  v6 = a3[2] | 1;
  *(_QWORD *)(a1 + 336) = 0x9D800000001;
  *(_DWORD *)(a1 + 32) = *(_QWORD *)(v3 + 8);
  *(int32x2_t *)(a1 + 36) = vmovn_s64(*(int64x2_t *)(v3 + 80));
  *(_DWORD *)(a1 + 44) = *(_QWORD *)(v3 + 96);
  v7 = *(_QWORD *)(v3 + 24);
  *(_QWORD *)(a1 + 48) = v4;
  *(_QWORD *)(a1 + 56) = v7;
  v8 = *(_DWORD *)(v3 + 32);
  v9 = *(_DWORD *)(v3 + 40);
  *(_DWORD *)(a1 + 64) = v8;
  *(_DWORD *)(a1 + 68) = v9;
  *(_QWORD *)(a1 + 72) = v4;
  v10 = *(_OWORD *)(v3 + 48);
  *(_OWORD *)(a1 + 96) = v10;
  v11 = *(_QWORD *)(v3 + 64);
  v12 = *(_QWORD *)(v3 + 72);
  *(_DWORD *)(a1 + 112) = v11;
  *(_DWORD *)(a1 + 116) = v12;
  *(_QWORD *)(a1 + 120) = v10;
  *(_QWORD *)(a1 + 152) = *(_QWORD *)(v3 + 104);
  v13 = *(_QWORD *)(v3 + 120);
  *(_DWORD *)(a1 + 144) = v6;
  *(_DWORD *)(a1 + 148) = v13;
  v14 = *(_QWORD *)(v3 + 152);
  *(_WORD *)(a1 + 224) = *(_QWORD *)(v3 + 144);
  v15 = *(_DWORD *)(v3 + 112);
  *(_DWORD *)(a1 + 160) = v15;
  *(_DWORD *)(a1 + 164) = v5;
  *(_WORD *)(a1 + 264) = v14;
  *(_WORD *)(a1 + 304) = *(_QWORD *)(v3 + 160);
  *(_DWORD *)(a1 + 324) = 2520;
  v16 = 8 * v15 + 2520;
  *(_DWORD *)(a1 + 328) = v16;
  v17 = ((2 * v15 + 6) & 0xFFFFFFF8) + v16;
  *(_DWORD *)(a1 + 332) = v17;
  v18 = a1 + v17;
  *(_WORD *)(a1 + 322) = v5 - 1;
  *(_WORD *)(a1 + 320) = 0;
  v19 = (v5 & 0x7FFFFFFF) - 1;
  if ((v5 & 0x7FFFFFFF) == 1)
  {
    v19 = 0;
  }
  else
  {
    v20 = 0;
    do
    {
      *(_WORD *)(v18 + 2 * v20) = v20 + 1;
      ++v20;
    }
    while (v19 != v20);
  }
  *(_WORD *)(v18 + 2 * v19) = -1;
  v22 = v17 + ((2 * v5 + 6) & 0xFFFFFFF8);
  *(_DWORD *)(a1 + 80) = v22;
  if (v9)
    v8 = v9;
  v23 = (v22 + 8 * v8);
  *(_DWORD *)(a1 + 128) = v23;
  if ((_DWORD)v12)
    v24 = v12;
  else
    v24 = v11;
  if (8 * (unint64_t)v24 + v23 <= a2)
    return 0;
  else
    return 22;
}

uint64_t spaceman_init(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  _BOOL4 v8;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  unint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v22;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unsigned int v31;
  unint64_t v32;
  int v33;
  unint64_t v34;
  int v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  int v39;
  unint64_t v40;
  _BOOL4 v41;
  int v42;
  int v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v47;
  int v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char v53;
  char v54;
  uint64_t v55;
  size_t v56;
  unint64_t *v57;
  size_t v58;
  void *v59;
  uint64_t v60;
  unint64_t v61;
  _QWORD *v62;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  uint64_t v77;

  v2 = *(_QWORD *)(a1 + 56);
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 392);
  v77 = 0;
  v75 = 0u;
  v76 = 0u;
  v73 = 0u;
  v74 = 0u;
  v71 = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  v67 = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  v64 = 0u;
  v4 = *(_DWORD *)(v2 + 32);
  v5 = *(_QWORD *)(v3 + 376);
  v6 = *(_DWORD *)(v5 + 36);
  if (*(_BYTE *)(v3 + 624))
  {
    if (v4 == v6)
      goto LABEL_3;
LABEL_9:
    v10 = v3;
    goto LABEL_10;
  }
  if (*(_QWORD *)(v2 + 96) + *(_QWORD *)(v2 + 48) != *(_QWORD *)(v5 + 40) || v4 != v6)
    goto LABEL_9;
LABEL_3:
  v7 = 336;
  if ((*(_BYTE *)(v2 + 144) & 1) != 0)
  {
    if (*(_DWORD *)(v2 + 336))
      v12 = 2520;
    else
      v12 = 336;
    v13 = *(_DWORD *)(v2 + 340);
    if (*(_DWORD *)(v2 + 336))
      v14 = 1;
    else
      v14 = 2;
    if (v13 <= v12)
      v7 = v12;
    else
      v7 = *(_DWORD *)(v2 + 340);
    if (v13 >= v12)
      v8 = *(_DWORD *)(v2 + 336) == 0;
    else
      v8 = v14;
  }
  else
  {
    v8 = 0;
  }
  v15 = *(_DWORD *)(a1 + 48);
  v16 = nx_calculate_metadata_parameters(v4, *(_QWORD *)(v2 + 48), *(_QWORD *)(v2 + 96), *(_DWORD *)(v5 + 180), (uint64_t)&v64);
  if ((_DWORD)v16)
    return v16;
  if (v7 < v15)
    v17 = v8;
  else
    v17 = v8 + 1;
  if (*(_DWORD *)(v2 + 36) != (_DWORD)v69)
    ++v17;
  if (*(_DWORD *)(v2 + 40) != DWORD2(v69))
    ++v17;
  if (*(_DWORD *)(v2 + 44) != (_DWORD)v70)
    ++v17;
  v18 = *(_QWORD *)(v2 + 48);
  if (*(_QWORD *)(v2 + 56) != *((_QWORD *)&v65 + 1))
    ++v17;
  v19 = *(_DWORD *)(v2 + 64);
  v20 = *(unsigned int *)(v2 + 68);
  if (v19 != (_DWORD)v66)
    ++v17;
  if ((_DWORD)v20 != DWORD2(v66) && *((_QWORD *)&v66 + 1) + v20 != 1)
    ++v17;
  if (*(_QWORD *)(v2 + 104) != *((_QWORD *)&v67 + 1))
    ++v17;
  v22 = *(unsigned int *)(v2 + 116);
  if (*(_DWORD *)(v2 + 112) != (_DWORD)v68)
    ++v17;
  if ((_DWORD)v22 != DWORD2(v68) && *((_QWORD *)&v68 + 1) + v22 != 1)
    ++v17;
  if ((*(_QWORD *)(v2 + 152) & 0x7FFFFFFFFFFFFFFFLL) != *((_QWORD *)&v70 + 1))
    ++v17;
  v24 = *(unsigned int *)(v2 + 160);
  if ((_DWORD)v24 != (_DWORD)v71)
    ++v17;
  v25 = *(_DWORD *)(v2 + 164) & 0x7FFFFFFF;
  if (v25 > 0xFFFE)
    ++v17;
  if (*(_DWORD *)(v2 + 148) < 4u)
    ++v17;
  if (v25 / v24 < 4)
    ++v17;
  if (*(unsigned __int16 *)(v2 + 224) != (_DWORD)v73)
    ++v17;
  if (*(unsigned __int16 *)(v2 + 264) != DWORD2(v73))
    ++v17;
  if (*(unsigned __int16 *)(v2 + 304) != (_DWORD)v74)
    ++v17;
  v26 = *(unsigned int *)(v2 + 324);
  if (v26 < v7)
    ++v17;
  v27 = *(unsigned int *)(v2 + 328);
  if (v26 + 8 * v24 > v27)
    ++v17;
  v28 = *(unsigned int *)(v2 + 332);
  if (v27 + 2 * (((_DWORD)v24 + 3) & 0xFFFFFFFC) > v28)
    ++v17;
  v29 = *(unsigned int *)(v2 + 80);
  if (v28 + 2 * ((v25 + 3) & 0xFFFFFFFC) > v29)
    ++v17;
  v30 = *(unsigned int *)(v2 + 128);
  if ((_DWORD)v20)
    v19 = *(_DWORD *)(v2 + 68);
  if (v29 + 8 * v19 > v30)
    ++v17;
  if ((_DWORD)v22)
    v31 = *(_DWORD *)(v2 + 116);
  else
    v31 = *(_DWORD *)(v2 + 112);
  if (v30 + 8 * v31 > *(unsigned int *)(a1 + 48))
    ++v17;
  if (*(_QWORD *)(v2 + 72) > v18)
    ++v17;
  v32 = *(_QWORD *)(v2 + 240);
  if (v32 < v18)
    v33 = v17;
  else
    v33 = v17 + 1;
  if (v32 && !*(_QWORD *)(v2 + 248))
    ++v33;
  v34 = *(_QWORD *)(v2 + 256);
  if (v34 <= obj_xid(a1))
    v35 = v33;
  else
    v35 = v33 + 1;
  v36 = *(_QWORD *)(v2 + 96);
  v37 = *(_QWORD *)(v2 + 120);
  v38 = *(_QWORD *)(v2 + 280);
  if (v36)
  {
    if (v37 > v36)
      ++v35;
    if (v38 < v36)
      v39 = v35;
    else
      v39 = v35 + 1;
    if (v38 && !*(_QWORD *)(v2 + 288))
      ++v39;
    v40 = *(_QWORD *)(v2 + 296);
    v41 = v40 > obj_xid(a1);
  }
  else
  {
    if (v37)
      ++v35;
    if (v38)
      v42 = v35 + 1;
    else
      v42 = v35;
    if (*(_QWORD *)(v2 + 288))
      v39 = v42 + 1;
    else
      v39 = v42;
    v41 = *(_QWORD *)(v2 + 296) != 0;
  }
  v43 = v39 + v41;
  v44 = *(unsigned __int16 *)(v2 + 320);
  v45 = *(_DWORD *)(v2 + 164) & 0x7FFFFFFF;
  if (v44 != 0xFFFF && v45 <= v44)
    ++v43;
  v47 = *(unsigned __int16 *)(v2 + 322);
  if (v47 != 0xFFFF && v45 <= v47)
    ++v43;
  if (*(_QWORD *)(v2 + 192) <= *(_QWORD *)(v2 + 184))
    v49 = 0;
  else
    v49 = -1;
  if (v43 == v49)
  {
LABEL_130:
    *(_QWORD *)(a1 + 376) = v2;
    *(_QWORD *)(a1 + 864) = v2 + *(unsigned int *)(v2 + 324);
    *(_QWORD *)(a1 + 872) = v2 + *(unsigned int *)(v2 + 328);
    *(_QWORD *)(a1 + 880) = v2 + *(unsigned int *)(v2 + 332);
    *(_QWORD *)(a1 + 888) = v2 + *(unsigned int *)(v2 + 80);
    *(_QWORD *)(a1 + 896) = v2 + *(unsigned int *)(v2 + 128);
    *(_QWORD *)(a1 + 904) = 0;
    *(_OWORD *)(a1 + 992) = 0u;
    *(_WORD *)(a1 + 1528) = 8;
    *(_QWORD *)(a1 + 1512) = *(_QWORD *)(v2 + 48) >> 5;
    *(_QWORD *)(a1 + 1520) = *(_QWORD *)(v2 + 96) >> 5;
    if (*(_BYTE *)(v3 + 625))
    {
      *(_WORD *)(a1 + 1528) = 0;
    }
    else if ((*(_BYTE *)(*(_QWORD *)(v3 + 376) + 65) & 1) == 0)
    {
      if (*(_BYTE *)(v3 + 628))
      {
        *(_WORD *)(a1 + 1528) = 32;
      }
      else
      {
        LODWORD(v64) = 0;
        dev_features(*(_QWORD *)(v3 + 384));
        if ((v64 & 2) != 0)
        {
          *(_WORD *)(a1 + 1528) = 2;
          v50 = 0x40000000u / *(_DWORD *)(v2 + 32);
          if (*(_QWORD *)(a1 + 1512) > v50)
            *(_QWORD *)(a1 + 1512) = v50;
          if (*(_QWORD *)(a1 + 1520) > v50)
            *(_QWORD *)(a1 + 1520) = v50;
        }
      }
    }
    if ((*(_BYTE *)(a1 + 16) & 0x40) != 0)
      v51 = 0;
    else
      v51 = obj_xid(a1);
    v52 = 0;
    *(_QWORD *)(a1 + 912) = v51;
    v53 = 1;
    do
    {
      v54 = v53;
      v55 = v2 + 48 * v52;
      v58 = *(_QWORD *)(v55 + 56);
      v57 = (unint64_t *)(v55 + 56);
      v56 = v58;
      if (v58)
      {
        v59 = _apfs_calloc(v56, 4uLL);
        v60 = a1 + 8 * v52;
        *(_QWORD *)(v60 + 1488) = v59;
        if (v59 && *v57)
        {
          v61 = 0;
          v62 = (_QWORD *)(v60 + 1488);
          do
          {
            *(_DWORD *)(*v62 + 4 * v61) = *(_DWORD *)(v2 + 36) & 0xFFFFFF | (*(unsigned __int8 *)(*v62 + 4 * v61 + 3) << 24);
            *(_BYTE *)(*v62 + 4 * v61++ + 3) = 3;
          }
          while (v61 < *v57);
        }
      }
      else
      {
        *(_QWORD *)(a1 + 8 * v52 + 1488) = 0;
      }
      v53 = 0;
      v52 = 1;
    }
    while ((v54 & 1) != 0);
    v11 = new_lock((pthread_mutex_t *)(a1 + 384));
    if ((_DWORD)v11)
      goto LABEL_166;
    v11 = new_lock((pthread_mutex_t *)(a1 + 448));
    if (!(_DWORD)v11)
    {
      v11 = new_lock((pthread_mutex_t *)(a1 + 512));
      if (!(_DWORD)v11)
      {
        v11 = new_lock((pthread_mutex_t *)(a1 + 576));
        if (!(_DWORD)v11)
        {
          v11 = new_lock((pthread_mutex_t *)(a1 + 640));
          if (!(_DWORD)v11)
          {
            v11 = new_lock((pthread_mutex_t *)(a1 + 704));
            if (!(_DWORD)v11)
            {
              v11 = new_cv((pthread_cond_t *)(a1 + 768));
              if (!(_DWORD)v11)
              {
LABEL_166:
                *(_QWORD *)(a1 + 1584) = _apfs_calloc(1uLL, 0xF8uLL);
                return v11;
              }
              free_lock((pthread_mutex_t *)(a1 + 704));
            }
            free_lock((pthread_mutex_t *)(a1 + 640));
          }
          free_lock((pthread_mutex_t *)(a1 + 576));
        }
        free_lock((pthread_mutex_t *)(a1 + 512));
      }
      free_lock((pthread_mutex_t *)(a1 + 448));
    }
    free_lock((pthread_mutex_t *)(a1 + 384));
    goto LABEL_166;
  }
  v10 = v3;
LABEL_10:
  v11 = nx_corruption_detected_int(v10);
  if (!(_DWORD)v11)
    goto LABEL_130;
  return v11;
}

uint64_t spaceman_destroy(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  _apfs_free(*(void **)(a1 + 1488), 4 * *(_QWORD *)(*(_QWORD *)(a1 + 376) + 56));
  _apfs_free(*(void **)(a1 + 1496), 4 * *(_QWORD *)(*(_QWORD *)(a1 + 376) + 104));
  v2 = *(void **)(a1 + 1600);
  if (v2)
    _apfs_free(v2, 16 * *(unsigned int *)(a1 + 1592));
  v3 = *(void **)(a1 + 1584);
  if (v3)
    _apfs_free(v3, 248);
  v4 = *(void **)(a1 + 1536);
  if (v4)
    _apfs_free(v4, 16 * *(unsigned __int16 *)(a1 + 1530));
  spaceman_datazone_destroy(a1);
  v5 = *(_QWORD *)(a1 + 1568);
  if (v5)
  {
    spaceman_free_extent_cache_destroy(v5);
    _apfs_free(*(void **)(a1 + 1568), 1368);
  }
  v6 = *(_QWORD *)(a1 + 1576);
  if (v6)
  {
    spaceman_free_extent_cache_destroy(v6);
    _apfs_free(*(void **)(a1 + 1576), 1368);
  }
  free_lock((pthread_mutex_t *)(a1 + 384));
  free_lock((pthread_mutex_t *)(a1 + 448));
  free_lock((pthread_mutex_t *)(a1 + 512));
  free_lock((pthread_mutex_t *)(a1 + 576));
  free_lock((pthread_mutex_t *)(a1 + 640));
  free_lock((pthread_mutex_t *)(a1 + 704));
  free_cv((pthread_cond_t *)(a1 + 768));
  return 0;
}

uint64_t spaceman_cab_sanity_check(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  _BOOL4 v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;

  v4 = a1[7];
  v5 = obj_size_phys((uint64_t)a1);
  v6 = *(_QWORD *)(*a1 + 392);
  v7 = *(_DWORD *)(*(_QWORD *)(v6 + 376) + 36);
  v8 = v5 != v7;
  if (a2)
  {
    v9 = *a2;
    v11 = *((_DWORD *)a2 + 2);
    v10 = *((_DWORD *)a2 + 3);
    if (v5 == v7)
      v12 = 1;
    else
      v12 = 2;
    if (*(_DWORD *)(v4 + 32) != v10)
      v8 = v12;
    v13 = v10 == *(_DWORD *)(v9 + 48 * v11 + 68) - 1
        ? *(_DWORD *)(v9 + 48 * v11 + 64) - *(_DWORD *)(v9 + 44) * v10
        : *(_DWORD *)(v9 + 44);
    if (*(_DWORD *)(v4 + 36) != v13)
      return nx_corruption_detected_int(v6);
  }
  if (v8)
    return nx_corruption_detected_int(v6);
  else
    return 0;
}

uint64_t spaceman_cib_sanity_check(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  _BOOL4 v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  int v12;

  v4 = a1[7];
  v5 = obj_size_phys((uint64_t)a1);
  v6 = *(_QWORD *)(*a1 + 392);
  v7 = *(_DWORD *)(*(_QWORD *)(v6 + 376) + 36);
  v8 = v5 != v7;
  if (a2)
  {
    v9 = *a2;
    v11 = *((_DWORD *)a2 + 2);
    v10 = *((_DWORD *)a2 + 3);
    if (v5 == v7)
      v12 = 1;
    else
      v12 = 2;
    if (*(_DWORD *)(v4 + 32) != v10)
      v8 = v12;
    if (v10 == *(_DWORD *)(v9 + 48 * v11 + 64) - 1)
    {
      if (*(_DWORD *)(v4 + 36) != *(_DWORD *)(v9 + 48 * v11 + 56) - *(_DWORD *)(v9 + 40) * v10)
        return nx_corruption_detected_int(v6);
    }
    else if (*(_DWORD *)(v4 + 36) != *(_DWORD *)(v9 + 40))
    {
      return nx_corruption_detected_int(v6);
    }
  }
  if (v8)
    return nx_corruption_detected_int(v6);
  return 0;
}

uint64_t spaceman_ip_bm_block_alloc(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, _WORD *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v10;

  v5 = *(_QWORD *)(a2 + 376);
  v6 = *(unsigned __int16 *)(v5 + 320);
  if (v6 == 0xFFFF)
    return 28;
  if ((*(_DWORD *)(v5 + 164) & 0x7FFFFFFFu) <= v6)
    return nx_corruption_detected_int(a1);
  if (*(unsigned __int16 *)(v5 + 322) == (_DWORD)v6)
    *(_WORD *)(v5 + 322) = -1;
  v10 = *(_QWORD *)(a2 + 880);
  *(_WORD *)(v5 + 320) = *(_WORD *)(v10 + 2 * v6);
  *(_WORD *)(v10 + 2 * v6) = -1;
  obj_dirty(a2, a3, 0);
  *a5 = v6;
  return spaceman_ip_bm_block_address(a1, v5, v6, a4);
}

uint64_t spaceman_ip_block_alloc(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  unsigned int v11;
  unint64_t v12;
  unsigned int v13;
  unint64_t v14;
  unint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t *v31;
  pthread_mutex_t *v32;
  int v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  __int16 v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;

  v5 = a3;
  v7 = a1;
  v8 = *(_QWORD *)(a2 + 376);
  v42 = 0;
  v43 = 0;
  v40 = 0;
  v41 = 0;
  if (!xid_is_current_tx(a1, a3))
    return 22;
  v9 = 8 * *(_DWORD *)(v8 + 32);
  if (!v9)
    return 22;
  v31 = a4;
  v32 = (pthread_mutex_t *)(a2 + 448);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 448));
  v10 = v9;
  v35 = v5;
  v36 = v7;
  v33 = v9;
  v34 = v9;
LABEL_4:
  v11 = 0;
  v12 = *(_QWORD *)(a2 + 904);
  v39 = 0;
  while (1)
  {
    v13 = *(_DWORD *)(v8 + 160);
    if (v11 > v13)
    {
LABEL_34:
      if (spaceman_free_completed(v7, a2, 0, 1, 0, v5))
        goto LABEL_4;
      log_err("%s:%d: %s unable to find free IP block or to free pending free IP blocks\n", "spaceman_ip_block_alloc", 5100, (const char *)(*(_QWORD *)(v7 + 384) + 208));
      v29 = 28;
      goto LABEL_38;
    }
    v14 = v12 / v10;
    v37 = v11;
    if (v11 == v13)
    {
      v15 = *(_QWORD *)(a2 + 904) % v10;
      if (!v15)
        goto LABEL_34;
    }
    else
    {
      LODWORD(v15) = v14 == v13 - 1
                   ? *(_QWORD *)(v8 + 152) - (*(_QWORD *)(v8 + 152) & 0x7FFFFFFFFFFFFFFFuLL) / v10 * v10
                   : v33;
    }
    v16 = *(unsigned __int16 *)(*(_QWORD *)(a2 + 872) + 2 * v14);
    v17 = v8;
    v18 = spaceman_ip_bm_block_address(v7, v8, v16, &v41);
    if ((_DWORD)v18
      || (v18 = obj_get(*(_QWORD *)(v7 + 392), 1073741825, v41, &sm_bm_desc, 0, 0, 0, v5, &v43), (_DWORD)v18))
    {
      v29 = v18;
      pthread_mutex_unlock(v32);
      return v29;
    }
    v19 = v12;
    v20 = v12 % v10;
    v21 = *(_QWORD *)(v43 + 56);
    if (bitmap_range_find_first(0, v21, v20, v15 - v20, &v42))
      break;
    v26 = v10 - v20 + v19;
    v8 = v17;
    if (v26 >= (*(_QWORD *)(v17 + 152) & 0x7FFFFFFFFFFFFFFFuLL))
      v12 = 0;
    else
      v12 = v26;
    v5 = v35;
    v7 = v36;
LABEL_32:
    obj_release(v43);
    v11 = v37 + 1;
    if (v39)
    {
      v29 = 0;
LABEL_38:
      pthread_mutex_unlock(v32);
      *v31 = v39;
      return v29;
    }
  }
  v22 = v42;
  v23 = v42 + v14 * v10;
  v24 = *(_QWORD *)(v17 + 152);
  if ((v24 & 0x7FFFFFFFFFFFFFFFuLL) > v23)
  {
    v25 = v19;
    v8 = v17;
    if (v24 < 0)
    {
      v27 = nx_metadata_fragmented_block_address_lookup(v36, *(_QWORD *)(v17 + 176), v23, &v39, 0);
      if ((_DWORD)v27)
        goto LABEL_39;
      v22 = v42;
      v8 = v17;
    }
    else
    {
      v39 = *(_QWORD *)(v17 + 176) + v23;
    }
    bitmap_set_range(v21, v22, 1);
    v5 = v35;
    v7 = v36;
    if (*(_QWORD *)(*(_QWORD *)(a2 + 864) + 8 * v14) != v35)
    {
      v38 = 0;
      v27 = spaceman_ip_bm_block_alloc(v36, a2, v35, &v40, &v38);
      if ((_DWORD)v27 || (v27 = spaceman_ip_bm_block_free(v36, a2, v16, v35), (_DWORD)v27))
      {
LABEL_39:
        v29 = v27;
        goto LABEL_41;
      }
      v41 = v40;
      *(_WORD *)(*(_QWORD *)(a2 + 872) + 2 * v14) = v38;
      *(_QWORD *)(*(_QWORD *)(a2 + 864) + 8 * v14) = v35;
      v8 = v17;
    }
    obj_dirty(v43, v35, v41);
    v28 = v25 - v20 + v42;
    if (v28 + 1 < (*(_QWORD *)(v8 + 152) & 0x7FFFFFFFFFFFFFFFuLL))
      v12 = v28 + 1;
    else
      v12 = 0;
    *(_QWORD *)(a2 + 904) = v12;
    v10 = v34;
    goto LABEL_32;
  }
  v29 = 22;
LABEL_41:
  pthread_mutex_unlock(v32);
  obj_release(v43);
  return v29;
}

uint64_t spaceman_extent_check(_QWORD *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t result;

  result = nx_superblock_sanity_check_extent(a1[47], *(_QWORD *)(a2 + 376), a3, a4, 0);
  if (!(_DWORD)result)
    return nx_metadata_range_overlap_check(a1, a3, a4, 0);
  return result;
}

uint64_t spaceman_ip_bm_block_address(uint64_t a1, uint64_t a2, unsigned int a3, _QWORD *a4)
{
  int v4;
  uint64_t v5;
  uint64_t result;

  v4 = *(_DWORD *)(a2 + 164);
  if ((v4 & 0x7FFFFFFFu) <= a3)
    return 22;
  v5 = *(_QWORD *)(a2 + 168);
  if (v4 < 0)
    return nx_metadata_fragmented_block_address_lookup(a1, v5, a3, a4, 0);
  result = 0;
  *a4 = v5 + a3;
  return result;
}

uint64_t spaceman_get(_QWORD *a1, uint64_t *a2)
{
  char *v3;
  uint64_t result;

  v3 = (char *)a1[51];
  *a2 = (uint64_t)v3;
  if (v3)
    goto LABEL_2;
  result = obj_get(a1[49], 0x80000000, *(_QWORD *)(a1[47] + 152), (int *)&sm_desc, 0, 0, 0, 0, a2);
  if (!(_DWORD)result)
  {
    a1[51] = *a2;
    v3 = (char *)*a2;
LABEL_2:
    obj_retain(v3);
    return 0;
  }
  return result;
}

uint64_t spaceman_currently_available_space(uint64_t a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, BOOL *a5)
{
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  pthread_mutex_t *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v19;
  unint64_t v20;
  pthread_mutex_t *v21;

  v9 = (_QWORD *)a1;
  if (obj_type(a1) == 13)
    v10 = (uint64_t)v9;
  else
    v10 = 0;
  if (v10)
    v9 = *(_QWORD **)(v10 + 392);
  v21 = 0;
  v11 = spaceman_get(v9, (uint64_t *)&v21);
  if ((_DWORD)v11)
  {
    if (a2)
      *a2 = 0;
    if (a3)
LABEL_10:
      *a3 = 0;
  }
  else
  {
    v13 = *(_QWORD *)&v21[5].__opaque[48];
    pthread_mutex_lock(v21 + 9);
    if (v10)
    {
      v14 = v21;
      v15 = *(_QWORD *)(v10 + 376);
      v17 = *(_QWORD *)(v15 + 72);
      v16 = *(_QWORD *)(v15 + 80);
      if (v16 >= *(_QWORD *)(*(_QWORD *)&v21[5].__opaque[48] + 96)
                + *(_QWORD *)(*(_QWORD *)&v21[5].__opaque[48] + 48)
                - *(_QWORD *)(*(_QWORD *)&v21[5].__opaque[48] + 184)
                + v17
        || v16 == 0)
      {
        v19 = *(_QWORD *)(*(_QWORD *)&v21[5].__opaque[48] + 96)
            + *(_QWORD *)(*(_QWORD *)&v21[5].__opaque[48] + 48)
            - *(_QWORD *)(*(_QWORD *)&v21[5].__opaque[48] + 184)
            + v17;
      }
      else
      {
        v19 = v16;
      }
    }
    else
    {
      v19 = *(_QWORD *)(v13 + 96) + *(_QWORD *)(v13 + 48);
      v14 = v21;
    }
    v20 = spaceman_available_space(v14, v10, a5);
    pthread_mutex_unlock(v14 + 9);
    obj_release(&v21->__sig);
    if (a2)
      *a2 = v19;
    if (a3)
      *a3 = v20;
    a3 = a4;
    if (a4)
      goto LABEL_10;
  }
  return v11;
}

unint64_t spaceman_available_space(_QWORD *a1, uint64_t a2, BOOL *a3)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;

  v3 = (_QWORD *)a1[47];
  v4 = v3[30];
  v5 = v3[35];
  v6 = v3[24] - v3[23];
  v7 = v3[15] + v3[9];
  v8 = v7 + v4 + v5 + v6;
  if (!a2)
    goto LABEL_6;
  v9 = *(_QWORD *)(a2 + 376);
  v10 = *(_QWORD *)(v9 + 72);
  v13 = v9 + 80;
  v12 = *(_QWORD *)(v9 + 80);
  v11 = *(_QWORD *)(v13 + 8);
  v14 = v10 >= v11;
  v15 = v10 - v11;
  if (!v14)
    v15 = 0;
  v8 += v15;
  if (v12)
    v16 = v12 - (v11 + *(_QWORD *)(a2 + 408));
  else
LABEL_6:
    v16 = v8;
  v17 = v7 - (a1[104] + a1[105]);
  if (v8 >= v16)
    v8 = v16;
  if (a3)
    *a3 = v17 < v8;
  if (v17 >= v8)
    return v8;
  else
    return v17;
}

uint64_t spaceman_size_info(_QWORD *a1, _QWORD *a2, char a3, _DWORD *a4, unint64_t *a5, _QWORD *a6, _QWORD *a7, uint64_t *a8, uint64_t *a9)
{
  uint64_t v16;
  uint64_t v17;
  pthread_mutex_t *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v28;
  pthread_mutex_t *v30;

  v30 = 0;
  v16 = spaceman_get(a1, (uint64_t *)&v30);
  if (!(_DWORD)v16)
  {
    v17 = *(_QWORD *)&v30[5].__opaque[48];
    pthread_mutex_lock(v30 + 9);
    if (a4)
      *a4 = *(_DWORD *)(v17 + 32);
    v18 = v30;
    v19 = *(_QWORD *)(v17 + 240)
        + *(_QWORD *)(v17 + 72)
        + *(_QWORD *)&v30[15].__opaque[8]
        + *(_QWORD *)(v17 + 120)
        + *(_QWORD *)(v17 + 280)
        + *(_QWORD *)&v30[15].__opaque[16];
    if ((a2 || (a3 & 1) != 0) && (v19 += *(_QWORD *)(v17 + 192) - *(_QWORD *)(v17 + 184), a2))
    {
      v20 = a2[10];
      v21 = a2[11];
      v22 = a2[9];
      v23 = v22 - v21;
      if (v22 < v21)
        v23 = 0;
      v24 = v23 + v19;
      v25 = v20 - v21;
      if (v24 < v25)
        v25 = v24;
      if (v20)
        v24 = v25;
      if (a5)
      {
        v26 = *(_QWORD *)(*(_QWORD *)&v30[5].__opaque[48] + 48)
            + v22
            + *(_QWORD *)(*(_QWORD *)&v30[5].__opaque[48] + 96)
            - *(_QWORD *)(*(_QWORD *)&v30[5].__opaque[48] + 184);
        if (v20 >= v26 || v20 == 0)
          v20 = v26;
        *a5 = v20;
      }
      if (a8)
        *a8 = v24;
      if (a6)
        *a6 = a2[9];
      if (a7)
        *a7 = a2[10];
      if (!a9)
        goto LABEL_40;
      v28 = a2[11];
    }
    else
    {
      if (a5)
        *a5 = *(_QWORD *)(v17 + 96) + *(_QWORD *)(v17 + 48);
      if (a6)
        *a6 = *(_QWORD *)(v17 + 184);
      if (a7)
        *a7 = 0;
      if (a8)
        *a8 = v19;
      if (!a9)
        goto LABEL_40;
      v28 = *(_QWORD *)(v17 + 48) - v19 + *(_QWORD *)(v17 + 96);
    }
    *a9 = v28;
LABEL_40:
    pthread_mutex_unlock(v18 + 9);
    obj_release(&v30->__sig);
  }
  return v16;
}

uint64_t trim_time_tracking_start(uint64_t result, uint64_t a2, int a3, int a4)
{
  __darwin_time_t tv_sec;
  uint64_t tv_nsec;
  uint64_t v9;
  __int16 v10;
  timespec __tp;

  if (a2)
  {
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    result = dev_features(*(_QWORD *)(result + 384));
    if ((_DWORD)result)
    {
      if (!a4)
        return result;
    }
    else if ((a4 & 1) == 0)
    {
      return result;
    }
    __tp.tv_sec = 0;
    __tp.tv_nsec = 0;
    result = clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    tv_sec = __tp.tv_sec;
    tv_nsec = __tp.tv_nsec;
    *(_QWORD *)a2 = __tp.tv_sec;
    tv_nsec /= 1000;
    *(_DWORD *)(a2 + 8) = tv_nsec;
    v9 = 1000000 * tv_sec + (int)tv_nsec;
    *(_QWORD *)(a2 + 16) = v9;
    *(_QWORD *)(a2 + 24) = v9;
    if (a3)
      v10 = a3;
    else
      v10 = 30;
    *(_WORD *)(a2 + 60) = v10;
    *(_BYTE *)(a2 + 62) = 1;
    *(_BYTE *)(a2 + 63) = a4 & 1;
  }
  return result;
}

uint64_t spaceman_free_completed(uint64_t a1, uint64_t a2, unsigned int a3, char a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _WORD *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  pthread_mutex_t *v16;
  uint64_t v17;
  pthread_mutex_t *v18;
  int v19;
  unint64_t v20;
  uint64_t v21;
  char v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  int v27;
  int v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  int v48;
  uint64_t v50;
  pthread_mutex_t *v51;
  _QWORD *v52;
  _QWORD *v53;
  unsigned __int16 *v54;
  int v55;
  uint64_t v56;
  int v57;
  pthread_mutex_t *v59;
  pthread_mutex_t *v62;
  unint64_t v63;
  timespec __rqtp;
  unsigned int v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _QWORD *v72;

  v6 = a5;
  v7 = *(_QWORD *)(a2 + 376);
  v71 = 0;
  v72 = 0;
  v69 = 0;
  v70 = 0;
  v56 = v7;
  v55 = *(_DWORD *)(v7 + 36);
  v8 = 1532;
  if (!a3)
    v8 = 1534;
  v54 = (unsigned __int16 *)(a2 + 1534);
  if (a3)
    v9 = (_WORD *)(a2 + 1532);
  else
    v9 = (_WORD *)(a2 + 1534);
  if (a3)
    v10 = 1552;
  else
    v10 = 1544;
  if (a3)
    v11 = 1560;
  else
    v11 = 1561;
  v12 = *(unsigned __int16 *)(a2 + v8);
  if (*(_WORD *)(a2 + v8))
  {
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = (pthread_mutex_t *)(a2 + 512);
    v62 = (pthread_mutex_t *)(a2 + 448);
    do
    {
      if ((a4 & 2) == 0)
        v13 = 16;
      v17 = *(_QWORD *)(a2 + v10);
      *(_BYTE *)(a2 + v11) = 1;
      if (a3)
      {
        pthread_mutex_unlock(v16);
        v18 = v16;
      }
      else
      {
        v18 = v62;
        pthread_mutex_unlock(v62);
      }
      v14 += v17;
      v15 += v12;
      __rqtp = (timespec)xmmword_1DF2E8D40;
      nanosleep(&__rqtp, 0);
      pthread_mutex_lock(v18);
      v12 = (unsigned __int16)*v9;
    }
    while (*v9);
    v6 = a5;
    if (v13)
      goto LABEL_31;
  }
  else
  {
    v14 = 0;
    v15 = 0;
  }
  if (!spaceman_fq_tree_get(a1, a2, a3, 0, 0, (uint64_t *)&v72) && v72)
  {
    LODWORD(__rqtp.tv_sec) = 16;
    v68 = 8;
    v19 = bt_lookup_first((uint64_t)v72, 0, &v69, &__rqtp, &v71, &v68);
    v63 = v69;
    if (a3 && !*(_QWORD *)(a2 + 1536))
      pthread_mutex_lock((pthread_mutex_t *)(a2 + 384));
    v20 = a6;
    if (v19)
    {
LABEL_29:
      if (*(_QWORD *)(a2 + 1536))
      {
        spaceman_fq_trim_list_flush(a1, a2, a3, v6, v20);
      }
      else
      {
        dev_unmap_flush(*(_QWORD *)(a1 + 384));
        if (a3)
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 384));
        trim_time_tracking_check(a1, v6);
      }
      obj_release(v72);
      return v14;
    }
    v22 = 0;
    v53 = (_QWORD *)(v56 + 40 * a3 + 216);
    v59 = (pthread_mutex_t *)(a2 + 576);
    v51 = (pthread_mutex_t *)(a2 + 448);
    v57 = 2;
    while (1)
    {
      if ((v22 & 1) == 0 && obj_modify(a2, 0, v20))
        goto LABEL_29;
      if (v68)
      {
        v23 = v71;
      }
      else
      {
        v71 = 1;
        v23 = 1;
      }
      v24 = v69;
      if (v69 <= v20)
      {
        if (v69 > v63)
        {
          *v53 = v69;
          if ((a4 & 2) == 0)
            goto LABEL_29;
        }
        if (*(_BYTE *)(a1 + 632))
        {
          v25 = *(_QWORD *)(a1 + 376);
          if (v24 >= *(_QWORD *)(v25 + 1408))
          {
            v50 = a2 + 8 * a3;
            if (*(_QWORD *)(v50 + 920) < v20)
            {
              *(_QWORD *)(v50 + 920) = v20;
              log_info("%s:%d: %s sfq %d processing xid %lld blocked by temporary checkpoints %lld\n", "spaceman_free_completed", 6096, (const char *)(*(_QWORD *)(a1 + 384) + 208), a3, v24, *(_QWORD *)(v25 + 1408));
            }
            goto LABEL_29;
          }
        }
        v26 = *(_QWORD *)(a2 + 912);
        if (v24 > v26)
        {
          if ((a4 & 3) != 0 && v57 && v24 != v20)
          {
            tx_barrier(a1, 0xD0u);
            --v57;
            v24 = v69;
            v26 = *(_QWORD *)(a2 + 912);
          }
          if (v24 > v26)
            goto LABEL_29;
        }
        if (a3)
        {
          if (spaceman_fq_over_threshold(a1, a2, 0, 0))
            goto LABEL_29;
          v27 = spaceman_extent_check((_QWORD *)a1, a2, v70, v71);
          if (v27)
          {
            v28 = v27;
            pthread_mutex_lock(v59);
            spaceman_decrement_free_queue_count(a1, a2, a3, v23);
            pthread_mutex_unlock(v59);
LABEL_59:
            if (nx_ratelimit_log_allowed(a1))
              log_err("%s:%d: %s sfq %d error validating extent %lld %lld: %d\n", "spaceman_free_completed", 6154, (const char *)(*(_QWORD *)(a1 + 384) + 208), a3, v70, v23, v28);
            goto LABEL_80;
          }
          if (v23 >= (4 * v55))
            v23 = (4 * v55);
          pthread_mutex_lock(v59);
          v52 = (_QWORD *)(a2 + 8 * (a3 - 1) + 976);
          *v52 += v23;
          spaceman_decrement_free_queue_count(a1, a2, a3, v23);
          pthread_mutex_unlock(v59);
          v29 = v70;
          v30 = *(_QWORD *)(a2 + 1536);
          if (v30)
          {
            v31 = *(unsigned __int16 *)(a2 + 1532);
            *(_WORD *)(a2 + 1532) = v31 + 1;
            v32 = *(_QWORD *)(a2 + 1552) + v23;
            *(_QWORD *)(a2 + 1552) = v32;
            v33 = *(_DWORD *)(*(_QWORD *)(a2 + 376) + 36);
            v34 = v30 + 16 * v31;
            *(_QWORD *)(v34 + 256) = v29;
            *(_QWORD *)(v34 + 264) = v23;
            if (v31 > 0xEE || v32 >= (4 * v33))
              spaceman_fq_trim_list_flush(a1, a2, a3, v6, v20);
            goto LABEL_80;
          }
          dev_unmap(*(_QWORD *)(a1 + 384), v70);
          spaceman_freed_internal((_QWORD *)a1, a2, v29, v23, 1, v20);
        }
        else
        {
          spaceman_decrement_free_queue_count(a1, a2, 0, v23);
          v28 = spaceman_ip_extent_validate(a1, a2, v70, v23, 0);
          if (v28)
            goto LABEL_59;
          v35 = v70;
          v36 = *(_QWORD *)(a2 + 1536);
          if (v36)
          {
            v37 = *(unsigned __int16 *)(a2 + 1534);
            *(_WORD *)(a2 + 1534) = v37 + 1;
            *(_QWORD *)(a2 + 1544) += v23;
            v38 = (unint64_t *)(v36 + 16 * v37);
            *v38 = v35;
            v38[1] = v23;
            if ((unsigned __int16)(v37 + 1) >= 0x10u)
            {
              pthread_mutex_unlock(v51);
              v39 = *v54;
              trim_time_tracking_check(a1, v6);
              if (v39)
              {
                v40 = 0;
                v41 = 16 * v39;
                do
                {
                  dev_unmap(*(_QWORD *)(a1 + 384), *(_QWORD *)(*(_QWORD *)(a2 + 1536) + v40));
                  v40 += 16;
                }
                while (v41 != v40);
                dev_unmap_flush(*(_QWORD *)(a1 + 384));
                pthread_mutex_lock(v51);
                v42 = 0;
                v43 = a6;
                do
                {
                  spaceman_ip_freed(a1, (_QWORD *)a2, *(_QWORD *)(*(_QWORD *)(a2 + 1536) + v42), *(_QWORD *)(*(_QWORD *)(a2 + 1536) + v42 + 8), a6);
                  v42 += 16;
                }
                while (v41 != v42);
              }
              else
              {
                dev_unmap_flush(*(_QWORD *)(a1 + 384));
                pthread_mutex_lock(v51);
                v43 = a6;
              }
              *(_QWORD *)(a2 + 1544) = 0;
              *(_WORD *)(a2 + 1534) = 0;
              v20 = v43;
            }
            goto LABEL_80;
          }
          dev_unmap(*(_QWORD *)(a1 + 384), v70);
          spaceman_ip_freed(a1, (_QWORD *)a2, v35, v23, v20);
        }
        trim_time_tracking_check(a1, v6);
      }
      else
      {
        log_err("%s:%d: %s sfq %d entry %lld:%lld %lld - bad xid, current xid %lld\n", "spaceman_free_completed", 6069, (const char *)(*(_QWORD *)(a1 + 384) + 208), a3, v69, v70, v23, v20);
        if (a3)
        {
          pthread_mutex_lock(v59);
          spaceman_decrement_free_queue_count(a1, a2, a3, v23);
          pthread_mutex_unlock(v59);
        }
        else
        {
          spaceman_decrement_free_queue_count(a1, a2, 0, v23);
        }
      }
LABEL_80:
      if (v6 && *(_BYTE *)(v6 + 62))
      {
        v44 = *(_QWORD *)(v6 + 48) + v23;
        ++*(_QWORD *)(v6 + 40);
        *(_QWORD *)(v6 + 48) = v44;
      }
      v45 = bt_remove_first((uint64_t)v72, 0, 0, 0, 0, 0, v20);
      if (v45)
        log_err("%s:%d: %s sfq %d error removing entry %lld %lld from free queue: %d\n", "spaceman_free_completed", 6166, (const char *)(*(_QWORD *)(a1 + 384) + 208), a3, v70, v71, v45);
      v46 = v71 - v23;
      if (v71 != v23)
      {
        v70 += v23;
        v71 -= v23;
        v68 = 8 * (v46 != 1);
        v47 = bt_insert(v72, 0, &v69, 16, &v71, v68, v20);
        if (v47)
          log_err("%s:%d: %s sfq %d error inserting shortened entry %lld %lld into free queue: %d\n", "spaceman_free_completed", 6176, (const char *)(*(_QWORD *)(a1 + 384) + 208), a3, v70, v71, v47);
      }
      v14 += v23;
      LODWORD(__rqtp.tv_sec) = 16;
      v68 = 8;
      v48 = bt_lookup_first((uint64_t)v72, 0, &v69, &__rqtp, &v71, &v68);
      v22 = 1;
      if (v48)
        goto LABEL_29;
    }
  }
LABEL_31:
  if (v6 && *(_BYTE *)(v6 + 62))
  {
    v21 = *(_QWORD *)(v6 + 48) + v14;
    *(_QWORD *)(v6 + 40) += v15;
    *(_QWORD *)(v6 + 48) = v21;
  }
  return v14;
}

uint64_t trim_time_tracking_end(uint64_t a1, uint64_t a2)
{
  __darwin_time_t tv_sec;
  int tv_nsec;
  uint64_t v6;
  unint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  timespec v11;

  if (!a2)
    return 0;
  if (!*(_BYTE *)(a2 + 62))
    return 0;
  v11.tv_sec = 0;
  v11.tv_nsec = 0;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v11);
  tv_sec = v11.tv_sec;
  tv_nsec = v11.tv_nsec;
  *(_QWORD *)a2 = v11.tv_sec;
  tv_nsec /= 1000;
  *(_DWORD *)(a2 + 8) = tv_nsec;
  *(_QWORD *)(a2 + 32) = 1000000 * tv_sec + tv_nsec;
  *(_BYTE *)(a2 + 62) = 0;
  v6 = *(int *)(a2 + 56);
  if (!(_DWORD)v6)
    return 0;
  v7 = (unint64_t *)(*(_QWORD *)(a1 + 384) + 168);
  v8 = -v6;
  do
    v9 = __ldxr(v7);
  while (__stxr(v9 + v8, v7));
  return 1;
}

void spaceman_manage_free_queues(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  pthread_mutex_t *v6;
  pthread_mutex_t *v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  _OWORD v11[2];
  pthread_mutex_t *v12;

  v12 = 0;
  memset(v11, 0, sizeof(v11));
  v9 = 0u;
  v10 = 0u;
  v4 = *(_QWORD *)(a2 + 16);
  if (!spaceman_get(a1, (uint64_t *)&v12))
  {
    v5 = *(_QWORD **)&v12[5].__opaque[48];
    trim_time_tracking_start((uint64_t)a1, (uint64_t)&v9, 0, 1);
    pthread_mutex_lock(v12 + 7);
    if (spaceman_fq_over_threshold((uint64_t)a1, (uint64_t)v12, 0, 0))
    {
      while (spaceman_fq_over_threshold((uint64_t)a1, (uint64_t)v12, 0, 1)
           && spaceman_free_completed((uint64_t)a1, (uint64_t)v12, 0, 1, (uint64_t)&v9, v4))
        ;
    }
    while (1)
    {
      v6 = v12;
      if (v4 - v5[27] <= (unint64_t)*(unsigned __int16 *)&v12[23].__opaque[48])
        break;
      if (!spaceman_free_completed((uint64_t)a1, (uint64_t)v12, 0, 0, (uint64_t)&v9, v4))
      {
        v6 = v12;
        break;
      }
    }
    pthread_mutex_unlock(v6 + 7);
    pthread_mutex_lock(v12 + 8);
    v7 = v12;
    if (v5[30] > *(_QWORD *)&v12[23].__opaque[32])
    {
      while (1)
      {
        v7 = v12;
        if (v5[30] <= *(_QWORD *)&v12[23].__opaque[32] >> 1)
          break;
        if (!spaceman_free_completed((uint64_t)a1, (uint64_t)v12, 1u, 1, (uint64_t)&v9, v4))
        {
          v7 = v12;
          break;
        }
      }
    }
    if (v5[35] > *(_QWORD *)&v7[23].__opaque[40])
    {
      while (v5[35] > *(_QWORD *)&v12[23].__opaque[40] >> 1
           && spaceman_free_completed((uint64_t)a1, (uint64_t)v12, 2u, 1, (uint64_t)&v9, v4))
        ;
    }
    if (v5[30] > v5[9])
    {
      while (v5[30] > v5[9] >> 1 && spaceman_free_completed((uint64_t)a1, (uint64_t)v12, 1u, 1, (uint64_t)&v9, v4))
        ;
    }
    if (v5[35] > v5[15])
    {
      while (v5[35] > v5[15] >> 1 && spaceman_free_completed((uint64_t)a1, (uint64_t)v12, 2u, 1, (uint64_t)&v9, v4))
        ;
    }
    if (spaceman_fq_over_threshold((uint64_t)a1, (uint64_t)v12, 1u, 0))
    {
      while (spaceman_fq_over_threshold((uint64_t)a1, (uint64_t)v12, 1u, 1)
           && spaceman_free_completed((uint64_t)a1, (uint64_t)v12, 1u, 1, (uint64_t)&v9, v4))
        ;
    }
    if (spaceman_fq_over_threshold((uint64_t)a1, (uint64_t)v12, 2u, 0))
    {
      while (spaceman_fq_over_threshold((uint64_t)a1, (uint64_t)v12, 2u, 1)
           && spaceman_free_completed((uint64_t)a1, (uint64_t)v12, 2u, 1, (uint64_t)&v9, v4))
        ;
    }
    while (v4 - v5[32] > (unint64_t)*(unsigned __int16 *)&v12[23].__opaque[48]
         && spaceman_free_completed((uint64_t)a1, (uint64_t)v12, 1u, 0, (uint64_t)&v9, v4))
      ;
    do
      v8 = v5[37];
    while (v8
         && v4 - v8 > (unint64_t)*(unsigned __int16 *)&v12[23].__opaque[48]
         && spaceman_free_completed((uint64_t)a1, (uint64_t)v12, 2u, 0, (uint64_t)&v9, v4));
    trim_time_tracking_end((uint64_t)a1, (uint64_t)&v9);
    *(_OWORD *)(a2 + 88) = *(_OWORD *)((char *)v11 + 8);
    *(_QWORD *)(a2 + 80) = *(_QWORD *)&v11[0] - v10;
    pthread_mutex_unlock(v12 + 8);
    obj_release(&v12->__sig);
  }
}

uint64_t spaceman_fq_over_threshold(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v7;
  uint64_t v9;

  v9 = 0;
  v7 = 0;
  if (!spaceman_fq_tree_get(a1, a2, a3, 0, 0, &v9) && v9)
  {
    v7 = spaceman_fq_tree_over_threshold(a2, a3, v9, a4);
    obj_release(v9);
  }
  return v7;
}

uint64_t spaceman_tx_start_closing(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  BOOL v12;
  pthread_mutex_t *v14;

  v14 = 0;
  if (spaceman_get(a1, (uint64_t *)&v14))
    return 0;
  v3 = *(_QWORD **)&v14[5].__opaque[48];
  pthread_mutex_lock(v14 + 9);
  v4 = v3[9];
  v5 = *(_QWORD *)&v14[23].__opaque[32] >> (v4 - v14[13].__sig < v3[6] >> 5);
  v6 = v3[30];
  v7 = v3[15];
  v8 = *(_QWORD *)&v14[23].__opaque[40] >> (v7 - *(_QWORD *)v14[13].__opaque < v3[12] >> 5);
  v9 = v3[35];
  pthread_mutex_unlock(v14 + 9);
  v12 = v9 > v7 || v9 > v8 || v6 > v4 || v6 > v5;
  if (v12 || spaceman_fq_over_threshold((uint64_t)a1, (uint64_t)v14, 0, 0))
  {
    v2 = 1;
  }
  else
  {
    v2 = 1;
    if (!spaceman_fq_over_threshold((uint64_t)a1, (uint64_t)v14, 1u, 0))
      v2 = spaceman_fq_over_threshold((uint64_t)a1, (uint64_t)v14, 2u, 0);
  }
  obj_release(&v14->__sig);
  return v2;
}

uint64_t spaceman_tx_complete(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;

  v5 = 0;
  result = spaceman_get(a1, &v5);
  if (!(_DWORD)result)
  {
    v4 = v5;
    *(_QWORD *)(v5 + 912) = a2;
    return obj_release(v4);
  }
  return result;
}

uint64_t spaceman_checkpoint_traverse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  char v16;
  unint64_t v17;
  char v18;
  unint64_t v19;
  char v20;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t *v24;

  v8 = *(unsigned __int16 **)(a3 + 376);
  v24 = 0;
  v22 = 0;
  v23 = 0;
  v9 = spaceman_fq_tree_get(a1, a3, 0, 0, 0, (uint64_t *)&v23);
  if ((_DWORD)v9)
    goto LABEL_49;
  v9 = spaceman_fq_tree_get(a1, a3, 1u, 0, 0, (uint64_t *)&v24);
  if ((_DWORD)v9)
    goto LABEL_49;
  v9 = spaceman_fq_tree_get(a1, a3, 2u, 0, 0, (uint64_t *)&v22);
  if ((_DWORD)v9)
    goto LABEL_49;
  if ((_DWORD)a4 == 1)
  {
    v14 = obj_checkpoint_start((unsigned int *)a3);
    v9 = v14;
    if ((_DWORD)v14 || (v11 = v23) == 0)
    {
      if ((_DWORD)v14 || (v12 = v24) == 0)
      {
        if (!(_DWORD)v14)
        {
          v13 = v22;
          if (v22)
            goto LABEL_42;
        }
        goto LABEL_49;
      }
      goto LABEL_32;
    }
    v15 = *(_QWORD *)(v23[49] + 32);
    if (v15 <= v8[112])
    {
      v16 = 0;
    }
    else if (*(_BYTE *)(a3 + 968))
    {
      v16 = 1;
    }
    else
    {
      log_err("%s:%d: %s IP free queue tree is too large: %lld nodes (limit %d) xid %lld\n", "spaceman_checkpoint_traverse", 3107, (const char *)(*(_QWORD *)(a1 + 384) + 208), v15, v8[112], *(_QWORD *)(a2 + 16));
      v16 = 1;
      v11 = v23;
    }
    *(_BYTE *)(a3 + 968) = v16;
    goto LABEL_28;
  }
  if ((_DWORD)a4 == 2)
  {
    v10 = obj_checkpoint_known(a3);
    v9 = v10;
    if ((_DWORD)v10 || (v11 = v23) == 0)
    {
      if ((_DWORD)v10 || (v12 = v24) == 0)
      {
        if ((_DWORD)v10)
          goto LABEL_49;
        v13 = v22;
        if (!v22)
          goto LABEL_49;
LABEL_48:
        v9 = btree_checkpoint_traverse(a1, a2, (uint64_t)v13, a4);
        goto LABEL_49;
      }
      goto LABEL_38;
    }
    goto LABEL_28;
  }
  v11 = v23;
  if (v23)
  {
LABEL_28:
    v9 = btree_checkpoint_traverse(a1, a2, (uint64_t)v11, a4);
    goto LABEL_29;
  }
  v9 = 0;
LABEL_29:
  if (!(_DWORD)v9)
  {
    v12 = v24;
    if (v24)
    {
      if ((_DWORD)a4 != 1)
      {
LABEL_38:
        v9 = btree_checkpoint_traverse(a1, a2, (uint64_t)v12, a4);
        goto LABEL_39;
      }
LABEL_32:
      v17 = *(_QWORD *)(v12[49] + 32);
      if (v17 <= v8[132])
      {
        v18 = 0;
      }
      else if (*(_BYTE *)(a3 + 969))
      {
        v18 = 1;
      }
      else
      {
        log_err("%s:%d: %s main free queue tree is too large: %lld nodes (limit %d) xid %lld\n", "spaceman_checkpoint_traverse", 3122, (const char *)(*(_QWORD *)(a1 + 384) + 208), v17, v8[132], *(_QWORD *)(a2 + 16));
        v18 = 1;
        v12 = v24;
      }
      *(_BYTE *)(a3 + 969) = v18;
      goto LABEL_38;
    }
  }
LABEL_39:
  if (!(_DWORD)v9)
  {
    v13 = v22;
    if (v22)
    {
      if ((_DWORD)a4 != 1)
        goto LABEL_48;
LABEL_42:
      v19 = *(_QWORD *)(v13[49] + 32);
      if (v19 <= v8[152])
      {
        v20 = 0;
      }
      else if (*(_BYTE *)(a3 + 970))
      {
        v20 = 1;
      }
      else
      {
        log_err("%s:%d: %s tier2 free queue tree is too large: %lld nodes (limit %d) xid %lld\n", "spaceman_checkpoint_traverse", 3137, (const char *)(*(_QWORD *)(a1 + 384) + 208), v19, v8[152], *(_QWORD *)(a2 + 16));
        v20 = 1;
        v13 = v22;
      }
      *(_BYTE *)(a3 + 970) = v20;
      goto LABEL_48;
    }
  }
LABEL_49:
  if (v23)
    obj_release(v23);
  if (v24)
    obj_release(v24);
  if (v22)
    obj_release(v22);
  return v9;
}

uint64_t spaceman_fq_tree_get(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;

  if (a3 > 2)
    return 22;
  v10 = *(_QWORD *)(a2 + 376);
  v11 = a2 + 8 * a3;
  v12 = *(char **)(v11 + 944);
  *a6 = (uint64_t)v12;
  if (v12)
    goto LABEL_4;
  v13 = v10 + 40 * a3;
  v16 = *(_QWORD *)(v13 + 208);
  v15 = (uint64_t *)(v13 + 208);
  v14 = v16;
  if (v16)
  {
    result = btree_get(a1, 0x80000000, v14, 0, 0, 0, 9, (uint64_t)spaceman_free_queue_key_cmp, 0, a6);
    if (!(_DWORD)result)
    {
LABEL_8:
      *(_QWORD *)(v11 + 944) = *a6;
      v12 = (char *)*a6;
LABEL_4:
      obj_retain(v12);
      return 0;
    }
    return result;
  }
  if (!a5)
  {
    result = 0;
    goto LABEL_14;
  }
  result = obj_modify(a2, 0, a4);
  if ((_DWORD)result)
  {
LABEL_14:
    *a6 = 0;
    return result;
  }
  result = btree_create(a1, 0x80000000, 6, 9, 0, 0x10u, 8, (uint64_t)spaceman_free_queue_key_cmp, a4, a6);
  if (!(_DWORD)result)
  {
    *v15 = obj_oid(*a6);
    obj_dirty(a2, a4, 0);
    goto LABEL_8;
  }
  return result;
}

uint64_t spaceman_iterate_free_extents_internal(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t (*a4)(_QWORD *a1, unint64_t a2, int64_t a3), _QWORD *a5)
{
  uint64_t v8;
  pthread_mutex_t *v9;
  uint64_t v10;
  _DWORD *v11;
  unsigned int v12;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  _DWORD *v23;
  _DWORD *v24;
  unint64_t v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  unsigned int v29;
  unint64_t v30;
  _DWORD *v31;
  int v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  unint64_t v46;
  unsigned int v47;
  size_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  char *v52;
  unsigned int v53;
  size_t v54;
  uint64_t v55;
  int v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v63;
  int v64;
  unsigned int *v65;
  uint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  unsigned int v69;
  unint64_t v70;
  int v71;
  char v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  uint64_t v76;
  unsigned int v77;
  _QWORD *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  char v82;
  unint64_t v83;
  char v84;
  unint64_t v85;
  unsigned int v86;
  BOOL v87;
  uint64_t v88;
  unint64_t v89;
  unsigned int v90;
  int v91;
  BOOL v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  int v96;
  int v97;
  int v98;
  int v99;
  unsigned int v100;
  char v101;
  unint64_t v102;
  unsigned int v103;
  int v104;
  uint64_t v105;
  const char *v106;
  unsigned int v107;
  unint64_t v108;
  int v109;
  int v110;
  BOOL v111;
  int v113;
  uint64_t v114;
  unsigned int v115;
  unsigned int *v116;
  unsigned int v117;
  unsigned int v118;
  unsigned int v119;
  unsigned int v120;
  BOOL v121;
  size_t v122;
  uint64_t v123;
  char *v124;
  size_t v125;
  uint64_t v126;
  BOOL v127;
  uint64_t v128;
  uint64_t v130;
  int v131;
  BOOL v132;
  uint64_t v133;
  int v134;
  unint64_t v135;
  unint64_t v136;
  uint64_t v137;
  char *v138;
  unint64_t v139;
  unint64_t v140;
  unint64_t v141;
  uint64_t v142;
  unsigned int v143;
  BOOL v144;
  unint64_t v145;
  uint64_t v146;
  unsigned int v147;
  unint64_t v148;
  uint64_t v149;
  size_t v150;
  unsigned int v151;
  BOOL v152;
  uint64_t v153;
  unsigned int v154;
  BOOL v155;
  BOOL v156;
  unsigned int v157;
  int v158;
  unsigned int v159;
  uint64_t v160;
  unsigned int v161;
  _DWORD *v162;
  unint64_t v163;
  int v164;
  int v165;
  char v166;
  unsigned int v167;
  uint64_t v168;
  char v169;
  char v170;
  uint64_t i;
  uint64_t v172;
  char v173;
  uint64_t v174;
  uint64_t v175;
  unint64_t v176;
  int v177;
  uint64_t v178;
  uint64_t *v179;
  BOOL v180;
  int v181;
  uint64_t *v182;
  _DWORD *v183;
  int *v184;
  unsigned int v185;
  int v186;
  pthread_mutex_t *v187;
  char v188;
  unsigned int v189;
  char v190;
  int v191;
  char *v192;
  unsigned int v193;
  unsigned int v194;
  unsigned int v195;
  char v196;
  char v197;
  _QWORD *v198;
  int v199;
  unsigned int v200;
  char *v201;
  _DWORD *v202;
  uint64_t v203;
  uint64_t v204;
  int v205;
  char *v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t *v209;
  uint64_t v210;
  size_t __nel;
  size_t __nela;
  unsigned int v213;
  char *v215;
  _QWORD *v216;
  unint64_t *v217;
  uint64_t (*v218)(_QWORD *, unint64_t, int64_t);
  _QWORD *v219;
  uint64_t v220;
  BOOL v221;
  pthread_mutex_t *v222;
  unint64_t v223;
  char v224;
  uint64_t v225;
  uint64_t v226;
  unint64_t v227;
  __int128 __base;
  __int128 v229;
  __int128 v230;
  __int128 v231;
  __int128 v232;
  __int128 v233;
  __int128 v234;
  __int128 v235;
  uint64_t v236;
  pthread_mutex_t *v237;
  _DWORD *v238;
  unint64_t v239;
  uint64_t v240;
  uint64_t v241;
  _BYTE v242[32];
  __int128 v243;
  __int128 v244;
  char v245;
  uint64_t v246;
  uint64_t v247;
  _QWORD v248[17];
  uint64_t v249;

  v8 = a1;
  v249 = *MEMORY[0x1E0C80C00];
  v243 = 0u;
  v244 = 0u;
  memset(v242, 0, sizeof(v242));
  v241 = 0;
  v240 = 0;
  memset(v248, 0, 128);
  v9 = (pthread_mutex_t *)(a1 + 848);
  v227 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 848));
  if ((a2 & 0x30) == 0 && *(_BYTE *)(v8 + 641))
  {
    pthread_mutex_unlock(v9);
    return 16;
  }
  v239 = 0;
  v238 = 0;
  v237 = 0;
  __base = 0u;
  v229 = 0u;
  v230 = 0u;
  v231 = 0u;
  v232 = 0u;
  v233 = 0u;
  v234 = 0u;
  v235 = 0u;
  v236 = 0;
  ++*(_DWORD *)(v8 + 824);
  pthread_mutex_unlock(v9);
  v10 = spaceman_get(v8, &v237);
  if ((_DWORD)v10)
    goto LABEL_376;
  v191 = a2 & 0x30;
  v11 = *(_DWORD **)&v237[5].__opaque[48];
  v218 = a4;
  if ((a2 & 0x40) != 0)
  {
    v12 = 4;
  }
  else if ((a2 & 0x20) != 0)
  {
    v12 = 8;
  }
  else if (a4 == spaceman_trim_free_extent_callback)
  {
    v12 = 1;
  }
  else
  {
    v12 = v11[10];
  }
  v14 = (char *)_apfs_malloc(16 * v11[10]);
  v15 = (char *)_apfs_malloc(8 * v11[10]);
  v16 = v15;
  v10 = 12;
  if (!v14 || !v15)
    goto LABEL_371;
  if ((a2 & 2) == 0)
    pthread_mutex_lock(v237 + 6);
  v187 = v9;
  if (a3)
  {
    if ((a2 & 0x6C) != 0x40)
    {
      v10 = 22;
      goto LABEL_360;
    }
    v17 = ((unint64_t)(a3 << __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(v8 + 376) + 36)))) >> 62) & 1;
  }
  else
  {
    if ((a2 & 4) != 0)
    {
      LODWORD(v17) = 0;
      v18 = 1;
      goto LABEL_24;
    }
    LODWORD(v17) = (a2 >> 3) & 1;
  }
  v18 = 2;
LABEL_24:
  v180 = 0;
  v188 = 0;
  v190 = 0;
  v19 = 0;
  v225 = 0;
  v20 = &v227;
  if ((a2 & 0x20) == 0)
    v20 = 0;
  v179 = (uint64_t *)v20;
  v196 = a2 & 0xFE;
  v197 = a2;
  v220 = v17;
  v175 = v18;
  v182 = (uint64_t *)(v14 + 8);
  v192 = v14 - 16;
  v198 = (_QWORD *)v8;
  v206 = v16;
  v201 = v14;
  v202 = v11;
  v185 = v18;
  while (1)
  {
    if ((a2 & 1) != 0)
    {
      v236 = 0;
      v234 = 0u;
      v235 = 0u;
      v232 = 0u;
      v233 = 0u;
      v230 = 0u;
      v231 = 0u;
      __base = 0u;
      v229 = 0u;
      LODWORD(v236) = spaceman_get_number_of_disabled_allocation_zones((uint64_t)v237, v220);
    }
    v227 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(v8 + 376) + 36)))) & a3;
    v181 = spaceman_free_extent_cache_bitmap_scan_begin(*(_QWORD *)&v237[24].__opaque[8 * v220 + 24], v179);
    v21 = v227;
    v22 = v11[9];
    if ((a2 & 0x40) == 0)
    {
      v21 = v227 / v22 * v22;
      v227 = v21;
    }
    v176 = v21;
    v23 = &v11[12 * v220];
    v24 = v23 + 16;
    v183 = v23 + 16;
    v184 = v23 + 17;
    v186 = -1;
    v25 = v21 / v22 / v11[10];
    v26 = v185;
    v27 = v19;
LABEL_32:
    v193 = v25;
    if (v25 < *v24)
      break;
    v19 = v27;
    if ((a2 & 1) != 0)
    {
      v160 = v225;
      if ((_DWORD)v236)
      {
        qsort(&__base, 8uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))spaceman_candidate_free_chunk_cmp);
        if ((_DWORD)v236)
        {
          v26 = v185;
          LODWORD(v25) = v193;
          v24 = v183;
          if (DWORD2(v235))
          {
            v161 = 6;
            v163 = (unint64_t)&v235;
            v162 = (_DWORD *)&v235 + 2;
            while (1)
            {
              LOBYTE(v247) = 0;
              v164 = spaceman_evaluate_chunk_for_disabled_allocation_zones(v237, v220, *(_QWORD *)v163, &v247);
              if (v164)
                log_err("%s:%d: %s failed to evaluate chunk %llu (average free ext len %u) for disabled allocation zones, error %d\n", "spaceman_iterate_free_extents_internal", 3914, (const char *)(*(_QWORD *)(v8 + 384) + 208), *(_QWORD *)v163, *v162, v164);
              v165 = v236;
              if ((_BYTE)v247)
              {
                v165 = v236 - 1;
                LODWORD(v236) = v236 - 1;
              }
              v26 = v185;
              v24 = v183;
              v160 = 0;
              LODWORD(v25) = v193;
              if (!v165 || v161 == -1)
                break;
              v163 = (unint64_t)(&__base + v161);
              v162 = (_DWORD *)(v163 | 8);
              --v161;
              if (!*(_DWORD *)(v163 + 8))
              {
                v160 = 0;
                break;
              }
            }
          }
        }
        else
        {
          v26 = v185;
          LODWORD(v25) = v193;
          v24 = v183;
        }
      }
    }
    else
    {
      v160 = v225;
    }
    if (v181)
    {
      if (v176)
        v166 = 0;
      else
        v166 = (_DWORD)v25 == *v24;
      spaceman_free_extent_cache_bitmap_scan_finished(*(_QWORD *)&v237[24].__opaque[8 * v220 + 24], v227, v166);
      v26 = v185;
    }
    v225 = v160;
    a3 = 0;
    ++v220;
    v9 = v187;
    if (v220 == v175)
    {
      v173 = 0;
      v167 = v26;
      goto LABEL_349;
    }
  }
  v189 = v12;
  v28 = v227;
  v31 = v11 + 9;
  v30 = v11[9];
  v29 = v31[1];
  if (!v191)
  {
    v32 = v25;
    pthread_mutex_lock(v9);
    if (*(_BYTE *)(v8 + 641))
    {
      log_info("%s:%d: %s nx_resize detected while processing dev=%d cib=%u out of %u cibs\n", "spaceman_iterate_free_extents_internal", 3608, (const char *)(*(_QWORD *)(v8 + 384) + 208), v220, v32, *v183);
      pthread_mutex_unlock(v9);
      v173 = 0;
      v168 = 16;
      v11 = v202;
LABEL_380:
      v169 = v181;
      goto LABEL_344;
    }
    pthread_mutex_unlock(v9);
    LODWORD(v25) = v32;
  }
  v223 = v30;
  v33 = v28;
  v34 = v27;
  v35 = v25;
  v36 = v25;
  pthread_mutex_lock(&v237[v220 + 10]);
  v37 = *v184;
  v221 = *v184 == 0;
  if (*v184)
  {
    v38 = v36 / v202[11];
    if (v38 == v186 && v34)
    {
      obj_lock(v241, 1);
      v38 = v186;
      v39 = v35;
      v27 = v34;
    }
    else
    {
      v41 = *(_QWORD *)(*(_QWORD *)&v237[13].__opaque[8 * v220 + 48] + 8 * v38);
      v39 = v35;
      if (v241)
      {
        obj_release(v241);
        v241 = 0;
      }
      v238 = v202;
      v239 = __PAIR64__(v38, v220);
      v42 = obj_get(*(_QWORD *)(v8 + 392), 1073741892, v41, &sm_cab_desc, &v238, 0, 0, 0, &v241);
      if ((_DWORD)v42)
      {
        v225 = v42;
        log_err("%s:%d: %s error getting cab %d @ %lld: %d\n", "spaceman_iterate_free_extents_internal", 3635, (const char *)(*(_QWORD *)(v8 + 384) + 208), v38, v41, v42);
        v173 = 0;
        if (v181)
        {
          v190 = 1;
          v14 = v201;
          v11 = v202;
          goto LABEL_347;
        }
        v14 = v201;
        v11 = v202;
        v167 = v220;
        goto LABEL_350;
      }
      v225 = 0;
      v27 = *(_QWORD *)(v241 + 56);
      v186 = v38;
    }
    pthread_mutex_unlock(&v237[v220 + 10]);
    v190 = 0;
    v40 = (uint64_t *)(v27 + 8 * (v193 - v202[11] * v38) + 40);
    v188 = 1;
  }
  else
  {
    v40 = (uint64_t *)(*(_QWORD *)&v237[13].__opaque[8 * v220 + 48] + 8 * v35);
    v190 = 1;
    v39 = v35;
    v27 = v34;
  }
  v194 = v39;
  if (v240)
  {
    obj_lock(v240, 1);
    goto LABEL_50;
  }
  v43 = *v40;
  v238 = v202;
  v239 = __PAIR64__(v193, v220);
  v44 = obj_get(*(_QWORD *)(v8 + 392), 1073741892, v43, &sm_cib_desc, &v238, 0, 0, 0, &v240);
  if ((_DWORD)v44)
  {
    v174 = v44;
    log_err("%s:%d: %s error getting cib %d @ %lld: %d\n", "spaceman_iterate_free_extents_internal", 3662, (const char *)(*(_QWORD *)(v8 + 384) + 208), v193, v43, v44);
    v173 = 0;
    v168 = v174;
    v190 = v221;
    v14 = v201;
    v11 = v202;
    v16 = v206;
    goto LABEL_380;
  }
  v225 = 0;
  v16 = v206;
LABEL_50:
  v210 = *(_QWORD *)(v240 + 56);
  v14 = v201;
  if (v218 == spaceman_trim_free_extent_callback)
  {
    trim_time_tracking_start(v8, (uint64_t)v242, 125, 0);
    if (v37)
      goto LABEL_52;
  }
  else if (v37)
  {
    goto LABEL_52;
  }
  pthread_mutex_unlock(&v237[v220 + 10]);
  v190 = 0;
LABEL_52:
  if (v241)
  {
    obj_unlock(v241, 1);
    v188 = 0;
  }
  v45 = v33 % v223;
  v46 = v33 / v223 - v29 * (unint64_t)v193;
  v11 = v202;
  bzero(v16, 8 * v202[10]);
  v47 = *(_DWORD *)(v210 + 36) - v46;
  v12 = v189;
  if (v189 >= v47)
    v48 = v47;
  else
    v48 = v189;
  __nel = v48;
  v199 = v46;
  if ((_DWORD)v48)
  {
    v49 = 0;
    v50 = v202[9];
    v51 = 16 * v48;
    do
    {
      v52 = &v201[v49];
      *(_DWORD *)v52 = v46;
      *((_QWORD *)v52 + 1) = *(_QWORD *)(v210 + 32 * v46 + 64);
      if (v49)
        v53 = 0;
      else
        v53 = v45;
      v227 += v50 - v53;
      LODWORD(v46) = v46 + 1;
      v49 += 16;
    }
    while (v51 != v49);
    if ((a2 & 0x40) != 0)
      goto LABEL_65;
  }
  else if ((a2 & 0x40) != 0)
  {
    goto LABEL_65;
  }
  qsort(v201, __nel, 0x10uLL, (int (__cdecl *)(const void *, const void *))ipaddr_cmp);
LABEL_65:
  v54 = __nel;
  if (!(_DWORD)__nel)
  {
    v213 = 0;
    v9 = v187;
    goto LABEL_296;
  }
  v177 = v46;
  v178 = v27;
  v55 = 0;
  v56 = 0;
  v57 = v182;
  while (1)
  {
    v58 = v55;
    v59 = *v57;
    if (*v57)
      break;
LABEL_76:
    v55 = v58 + 1;
    v57 += 2;
    if (v54 == v58 + 1)
    {
LABEL_77:
      v63 = 0;
      v64 = 0;
      v213 = 0;
      v195 = v58 + 1;
      v11 = v202;
      do
      {
        v204 = v63;
        v65 = (unsigned int *)&v14[16 * v63];
        v200 = v11[10];
        v66 = *v65;
        v67 = &v248[v64];
        v208 = v66;
        v209 = v67;
        v207 = *((_QWORD *)v65 + 1);
        v205 = v64;
        if (v207)
        {
          if (*v67)
            v68 = obj_async_wait(*v67);
          else
            v68 = obj_get(*(_QWORD *)(v8 + 392), 1073741888, v207, &sm_bm_desc, 0, 0, 0, 0, &v248[v64]);
          v168 = v68;
          if ((_DWORD)v68)
          {
            log_err("%s:%d: %s error getting cib %d bitmap %d @ %lld: %d\n", "spaceman_iterate_free_extents_internal", 3744, (const char *)(*(_QWORD *)(v8 + 384) + 208), v193, *v65, v207, v68);
            if (*v209)
            {
              obj_release(*v209);
              *v209 = 0;
            }
            goto LABEL_343;
          }
          v66 = v208;
          v219 = *(_QWORD **)(*v209 + 56);
          v69 = *v65;
        }
        else
        {
          v219 = 0;
          v69 = v66;
        }
        if ((a2 & 0x40) != 0 && v69)
        {
          *(_QWORD *)&v16[8 * v69] = *(_QWORD *)&v16[8 * v69 - 8];
          *(_QWORD *)&v16[8 * *v65 - 8] = 0;
          v69 = *v65;
        }
        v70 = 0;
        v215 = &v16[8 * v69];
        v71 = *(_DWORD *)(v210 + 32 * v66 + 56);
        v246 = 0;
        v203 = *(_QWORD *)&v237[23].__opaque[8 * v220 + 8];
        v72 = v196;
        if (v203)
          v72 = a2;
        v224 = v72;
        if ((v72 & 0x40) != 0)
          v70 = *(_QWORD *)v215;
        v73 = *(_QWORD *)&v71 & 0xFFFFFLL;
        v247 = 0;
        v222 = v237;
        if ((v71 & 0xFFFFFu) <= v45)
        {
          v75 = 0;
          LODWORD(v74) = 0;
          v226 = 0;
          v78 = v219;
LABEL_151:
          v14 = v201;
          v11 = v202;
          if ((v224 & 0x40) != 0)
            goto LABEL_152;
          goto LABEL_153;
        }
        v226 = 0;
        v74 = 0;
        v75 = 0;
        v76 = v45;
        v216 = (_QWORD *)(v210 + 32 * v66 + 48);
        v217 = (unint64_t *)&v237[24].__opaque[8 * v220 + 24];
        v77 = 1;
        v78 = v219;
        while (1)
        {
          if (!v78)
          {
            v246 = v73;
            v247 = v76;
            v79 = v73;
            v80 = v76;
            goto LABEL_101;
          }
          if (!bitmap_range_find_first(0, (uint64_t)v78, v76, v73 - v76, &v247))
            break;
          if (bitmap_range_find_first(1, (uint64_t)v78, v247, v73 - v247, &v246))
          {
            v79 = v246;
          }
          else
          {
            v246 = v73;
            v79 = v73;
          }
          v80 = v247;
LABEL_101:
          v76 = v79;
          v81 = v79 - v80;
          if (v79 - v80 > v74)
            v74 = v79 - v80;
          if ((v224 & 0x40) != 0)
          {
            if (v70 && v80)
            {
              if (v220 == 1)
              {
                v82 = __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v222->__sig + 392) + 376) + 36)));
                v83 = (0x4000000000000000uLL >> v82) | (*v216 - v70);
              }
              else
              {
                v83 = *v216 - v70;
                v82 = __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v222->__sig + 392) + 376) + 36)));
              }
              spaceman_free_extent_cache_insert(*v217, 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v82) & v83, v70);
              if (v218)
              {
                v86 = v218(a5, v83, v70);
                if (BYTE14(v244))
                {
                  ++*((_QWORD *)&v243 + 1);
                  *(_QWORD *)&v244 = v244 + v70;
                }
              }
              else
              {
                v86 = 0;
              }
              v78 = v219;
              v70 = 0;
              if ((_DWORD)v226)
                v87 = 1;
              else
                v87 = v86 == 0;
              if (v87)
                v88 = v226;
              else
                v88 = v86;
              v226 = v88;
              v79 = v246;
            }
            if (v79 != v73)
            {
              if (v220 == 1)
              {
                v84 = __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v222->__sig + 392) + 376) + 36)));
                v85 = (0x4000000000000000uLL >> v84) | (v80 - v70 + *v216);
              }
              else
              {
                v85 = v80 - v70 + *v216;
                v84 = __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v222->__sig + 392) + 376) + 36)));
              }
              v89 = v70 + v81;
LABEL_135:
              spaceman_free_extent_cache_insert(*v217, 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v84) & v85, v89);
              if (v218)
              {
                v90 = v218(a5, v85, v89);
                v91 = BYTE14(v244);
                if (BYTE14(v244))
                {
                  ++*((_QWORD *)&v243 + 1);
                  *(_QWORD *)&v244 = v244 + v89;
                  v91 = 1;
                }
              }
              else
              {
                v90 = 0;
                v91 = BYTE14(v244);
              }
              v78 = v219;
              v70 = 0;
              if ((_DWORD)v226)
                v92 = 1;
              else
                v92 = v90 == 0;
              if (v92)
                v93 = v226;
              else
                v93 = v90;
              v226 = v93;
              if (v91 && 100 * (v77 / 0x64) - 1 == v75)
              {
                trim_time_tracking_check(*(_QWORD *)(v222->__sig + 392), (uint64_t)v242);
                v70 = 0;
              }
              goto LABEL_148;
            }
            v70 += v81;
          }
          else if (v80)
          {
            if (v79 != v73)
            {
              if (v220 == 1)
              {
                v84 = __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v222->__sig + 392) + 376) + 36)));
                v85 = (0x4000000000000000uLL >> v84) | (v80 - v70 + *v216);
              }
              else
              {
                v85 = v80 - v70 + *v216;
                v84 = __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v222->__sig + 392) + 376) + 36)));
              }
              v89 = v81 + v70;
              goto LABEL_135;
            }
            *((_DWORD *)v215 + 1) = v81;
          }
          else
          {
            *(_DWORD *)v215 = v81;
          }
LABEL_148:
          ++v77;
          ++v75;
          if (v76 >= v73)
            goto LABEL_151;
        }
        v11 = v202;
        if ((v224 & 0x40) == 0 || !v70 || v75)
          goto LABEL_151;
        if (v220 == 1)
        {
          v101 = __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v222->__sig + 392) + 376) + 36)));
          v102 = (0x4000000000000000uLL >> v101) | (*v216 - v70);
        }
        else
        {
          v102 = *v216 - v70;
          v101 = __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v222->__sig + 392) + 376) + 36)));
        }
        v14 = v201;
        spaceman_free_extent_cache_insert(*v217, 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v101) & v102, v70);
        if (v218)
        {
          v119 = v218(a5, v102, v70);
          if (BYTE14(v244))
          {
            ++*((_QWORD *)&v243 + 1);
            *(_QWORD *)&v244 = v244 + v70;
          }
        }
        else
        {
          v119 = 0;
        }
        v78 = v219;
        v75 = 0;
        v70 = 0;
        if ((_DWORD)v226)
          v132 = 1;
        else
          v132 = v119 == 0;
        if (v132)
          v133 = v226;
        else
          v133 = v119;
        v226 = v133;
LABEL_152:
        *(_QWORD *)v215 = v70;
LABEL_153:
        v8 = (uint64_t)v198;
        if ((v224 & 1) == 0)
          goto LABEL_196;
        v94 = v208 + v200 * (unint64_t)v194;
        v95 = v203;
        v96 = *(_DWORD *)(v203 + 4 * v94);
        v97 = v96 & 0xFF000000 | v74 & 0xFFFFFF;
        *(_DWORD *)(v203 + 4 * v94) = v97;
        if (v78)
        {
          v98 = v96 & 0xFE000000 | v74 & 0xFFFFFF;
          v95 = v203;
          v99 = v97 | 0x1000000;
          if ((*v78 & 1) != 0)
            v99 = v98;
          *(_DWORD *)(v203 + 4 * v94) = v99;
          if (v73 < 0x40 || (v78[(v73 >> 6) - 1] & 0x8000000000000000) != 0)
          {
            v100 = v99 & 0xFDFFFFFF;
            goto LABEL_167;
          }
        }
        else
        {
          v99 = v97 | 0x1000000;
        }
        v100 = v99 | 0x2000000;
LABEL_167:
        *(_DWORD *)(v95 + 4 * v94) = v100;
        if (!(_DWORD)v236)
          goto LABEL_196;
        v103 = *(_DWORD *)(v210 + 32 * v208 + 60) & 0xFFFFF;
        if (v103 == *(_DWORD *)(*(_QWORD *)&v222[5].__opaque[48] + 36))
        {
          v245 = 0;
          v104 = spaceman_evaluate_chunk_for_disabled_allocation_zones(v222, v220, v94, &v245);
          if (v104)
          {
            v105 = *(_QWORD *)v222->__opaque;
            if (v105)
              v106 = (const char *)(v105 + 3880);
            else
              v106 = (const char *)(*(_QWORD *)(*(_QWORD *)(v222->__sig + 392) + 384) + 208);
            log_err("%s:%d: %s failed to evaluate free chunk %llu for disabled allocation zone, error %d\n", "spaceman_iterate_process_bitmap_block", 3390, v106, v94, v104);
          }
          if (v245)
            LODWORD(v236) = v236 - 1;
          goto LABEL_196;
        }
        if (!v75 || v103 < 4)
          goto LABEL_196;
        v107 = v103 / v75;
        v108 = (unint64_t)(&__base + HIDWORD(v236));
        v109 = v100 & 0xC000000;
        v110 = v100 & 0xFFFFFC;
        v111 = v107 > *(_DWORD *)(v108 + 8) && v109 == 0;
        if (!v111 || v110 == 0)
          goto LABEL_196;
        v113 = 0;
        *(_DWORD *)(v108 | 8) = v107;
        *(_QWORD *)v108 = v94;
        v114 = -7;
        v115 = DWORD2(__base);
        v116 = (unsigned int *)&v229 + 2;
        while (2)
        {
          v118 = *v116;
          v116 += 4;
          v117 = v118;
          if (v118 >= v115)
          {
LABEL_185:
            v127 = __CFADD__(v114++, 1);
            if (v127)
              goto LABEL_235;
            continue;
          }
          break;
        }
        if (v117)
        {
          v113 = v114 + 8;
          v115 = v117;
          goto LABEL_185;
        }
        v113 = v114 + 8;
LABEL_235:
        HIDWORD(v236) = v113;
LABEL_196:
        v120 = v213;
        v168 = v226;
        if (v213)
          v121 = 1;
        else
          v121 = (_DWORD)v226 == 0;
        if (!v121)
          v120 = v226;
        LOBYTE(a2) = v197;
        if ((v197 & 0x40) != 0 && v120)
          goto LABEL_342;
        v213 = v120;
        v16 = v206;
        if (!v207)
        {
          v122 = __nel;
          v130 = v204;
          v64 = v205;
          goto LABEL_222;
        }
        obj_release(*v209);
        *v209 = 0;
        v122 = __nel;
        if (v195 >= __nel)
          goto LABEL_220;
        v123 = 1;
        v124 = &v192[16 * v195];
        do
        {
          v125 = v195 + v123;
          v126 = *((_QWORD *)v124 + 3);
          v124 += 16;
          ++v123;
          if (v126)
            v127 = 1;
          else
            v127 = v125 >= __nel;
        }
        while (!v127);
        v195 = v195 + v123 - 1;
        if (!v126)
        {
          v168 = v226;
          goto LABEL_220;
        }
        v128 = obj_get(v198[49], 1073742016, v126, &sm_bm_desc, 0, 0, 0, 0, v209);
        if ((_DWORD)v128 == 45 || (_DWORD)v128 == 16)
        {
          v168 = 0;
          *v209 = 0;
          v122 = __nel;
LABEL_220:
          v130 = v204;
          v131 = v205;
          goto LABEL_221;
        }
        v168 = v128;
        v131 = v205;
        if ((_DWORD)v128)
        {
          log_err("%s:%d: %s error getting cib %d bitmap %d @ %lld: %d\n", "spaceman_iterate_free_extents_internal", 3793, (const char *)(v198[48] + 208), v193, *(_DWORD *)v124, v126, v128);
          goto LABEL_343;
        }
        v122 = __nel;
        v130 = v204;
LABEL_221:
        v64 = (v131 + 1) & 0xF;
LABEL_222:
        v45 = 0;
        v63 = v130 + 1;
      }
      while (v63 != v122);
      v225 = v168;
      v134 = 0;
      v135 = 0;
      v136 = 0;
      while (1)
      {
        v137 = (v134 + v199);
        v138 = &v206[8 * v137];
        if ((v197 & 0x40) != 0)
        {
          v139 = *(_QWORD *)v138;
          if (*(_QWORD *)v138)
          {
            if (v220 == 1)
              v136 = (*(_QWORD *)(v210 + 32 * v137 + 48) - v139 + (*(_DWORD *)(v210 + 32 * v137 + 56) & 0xFFFFF)) | (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v198[47] + 36))));
            else
              v136 = *(_QWORD *)(v210 + 32 * v137 + 48) - v139 + (*(_DWORD *)(v210 + 32 * v137 + 56) & 0xFFFFF);
            v135 = *(_QWORD *)v138;
          }
          goto LABEL_283;
        }
        v140 = *(unsigned int *)v138;
        if ((_DWORD)v140)
          break;
LABEL_265:
        v145 = *((unsigned int *)v138 + 1);
        if ((_DWORD)v145)
        {
          v146 = v210 + 32 * v137;
          v147 = (*(_DWORD *)(v146 + 56) & 0xFFFFF) - v145;
          if (v220 == 1)
          {
            v148 = (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v198[47] + 36)))) | (*(_QWORD *)(v146 + 48) + v147);
            if (v135)
            {
LABEL_268:
              if (v135 + v136 == v148)
              {
                v149 = 0;
                v145 += v135;
                v148 = v136;
              }
              else
              {
                v150 = v122;
                spaceman_free_extent_cache_insert(*(_QWORD *)&v237[24].__opaque[8 * v220 + 24], 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(v198[47] + 36)))) & v136, v135);
                if (v218)
                {
                  v149 = v218(a5, v136, v135);
                  if (BYTE14(v244))
                  {
                    ++*((_QWORD *)&v243 + 1);
                    *(_QWORD *)&v244 = v244 + v135;
                  }
                }
                else
                {
                  v149 = 0;
                }
                v122 = v150;
              }
              goto LABEL_277;
            }
          }
          else
          {
            v148 = *(_QWORD *)(v146 + 48) + v147;
            if (v135)
              goto LABEL_268;
          }
          v149 = 0;
LABEL_277:
          v151 = v213;
          if (v213)
            v152 = 1;
          else
            v152 = (_DWORD)v149 == 0;
          v225 = v149;
          if (!v152)
            v151 = v149;
          v213 = v151;
          v136 = v148;
          v135 = v145;
        }
LABEL_283:
        ++v134;
        if (!--v122)
        {
          v12 = v189;
          if (v135)
          {
            spaceman_free_extent_cache_insert(*(_QWORD *)&v237[24].__opaque[8 * v220 + 24], 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(v198[47] + 36)))) & v136, v135);
            v9 = v187;
            v11 = v202;
            if (v218)
            {
              v153 = v218(a5, v136, v135);
              if (BYTE14(v244))
              {
                ++*((_QWORD *)&v243 + 1);
                *(_QWORD *)&v244 = v244 + v135;
              }
            }
            else
            {
              v153 = 0;
            }
            v27 = v178;
            LODWORD(v46) = v177;
            v154 = v213;
            if (v213)
              v155 = 1;
            else
              v155 = (_DWORD)v153 == 0;
            v225 = v153;
            if (!v155)
              v154 = v153;
            v213 = v154;
          }
          else
          {
            v9 = v187;
            v11 = v202;
            v27 = v178;
            LODWORD(v46) = v177;
          }
LABEL_296:
          if (v218 == spaceman_trim_free_extent_callback)
            spaceman_trim_free_extent_flush(v8);
          obj_unlock(v240, 1);
          if (BYTE14(v244))
          {
            if (trim_time_tracking_end(v8, (uint64_t)v242))
            {
              if (v12 <= 1)
                v12 = 1;
              else
                v12 >>= 1;
              v156 = 1;
            }
            else
            {
              v157 = v11[10];
              v158 = 4 * v12;
              if (v157 < 4 * v12)
                v158 = v11[10];
              if (v157 >= v12 + 1)
                v157 = v12 + 1;
              if (v180)
                v12 = v157;
              else
                v12 = v158;
              v156 = v180;
            }
            v180 = v156;
          }
          if (*(_DWORD *)(v210 + 36) == (_DWORD)v46)
          {
            obj_release(v240);
            v240 = 0;
            v26 = v185;
            v159 = v193;
          }
          else
          {
            v159 = v193 - 1;
            v26 = v185;
          }
          v24 = v183;
          LODWORD(v25) = v159 + 1;
          if (v213)
          {
            v173 = 0;
            v168 = v213;
            goto LABEL_380;
          }
          goto LABEL_32;
        }
      }
      if (v220 == 1)
      {
        v141 = (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v198[47] + 36)))) | *(_QWORD *)(v210 + 32 * v137 + 48);
        if (v135)
          goto LABEL_248;
      }
      else
      {
        v141 = *(_QWORD *)(v210 + 32 * v137 + 48);
        if (v135)
        {
LABEL_248:
          if (v135 + v136 == v141)
          {
            v142 = 0;
            v140 += v135;
            v141 = v136;
          }
          else
          {
            __nela = v122;
            spaceman_free_extent_cache_insert(*(_QWORD *)&v237[24].__opaque[8 * v220 + 24], 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(v198[47] + 36)))) & v136, v135);
            if (v218)
            {
              v142 = v218(a5, v136, v135);
              if (BYTE14(v244))
              {
                ++*((_QWORD *)&v243 + 1);
                *(_QWORD *)&v244 = v244 + v135;
              }
            }
            else
            {
              v142 = 0;
            }
            v122 = __nela;
          }
          goto LABEL_259;
        }
      }
      v142 = 0;
LABEL_259:
      v143 = v213;
      if (v213)
        v144 = 1;
      else
        v144 = (_DWORD)v142 == 0;
      v225 = v142;
      if (!v144)
        v143 = v142;
      v213 = v143;
      v136 = v141;
      v135 = v140;
      v14 = v201;
      goto LABEL_265;
    }
  }
  v60 = obj_get(*(_QWORD *)(v8 + 392), 1073742016, v59, &sm_bm_desc, 0, 0, 0, 0, &v248[v56]);
  v54 = __nel;
  if (!(_DWORD)v60)
  {
LABEL_75:
    ++v56;
    v16 = v206;
    if (v56 == 16)
      goto LABEL_77;
    goto LABEL_76;
  }
  v61 = v60;
  if ((_DWORD)v60 == 45 || (_DWORD)v60 == 16)
  {
    v248[v56] = 0;
    goto LABEL_75;
  }
  log_err("%s:%d: %s error getting cib %d bitmap %d @ %lld: %d\n", "spaceman_iterate_free_extents_internal", 3720, (const char *)(*(_QWORD *)(v8 + 384) + 208), v193, *((_DWORD *)v57 - 2), v59, v60);
  v168 = v61;
  v11 = v202;
LABEL_342:
  v16 = v206;
LABEL_343:
  v169 = v181;
  v173 = 1;
LABEL_344:
  v225 = v168;
  if (!(_DWORD)v168)
    v169 = 0;
  if ((v169 & 1) != 0)
  {
LABEL_347:
    v167 = v220;
    spaceman_free_extent_cache_bitmap_scan_finished(*(_QWORD *)&v237[24].__opaque[8 * v220 + 24], v227, 0);
  }
  else
  {
    v167 = v220;
  }
LABEL_349:
  if ((v190 & 1) != 0)
LABEL_350:
    pthread_mutex_unlock(&v237[(unint64_t)v167 + 10]);
  if (v241 && (v188 & 1) != 0)
    obj_unlock(v241, 1);
  v170 = v173 ^ 1;
  if (!v240)
    v170 = 1;
  v10 = v225;
  if ((v170 & 1) == 0)
  {
    trim_time_tracking_end(v8, (uint64_t)v242);
    if (v218 == spaceman_trim_free_extent_callback)
      spaceman_trim_free_extent_flush(v8);
    obj_unlock(v240, 1);
  }
LABEL_360:
  if (v241)
    obj_release(v241);
  if (v240)
    obj_release(v240);
  for (i = 0; i != 16; ++i)
  {
    v172 = v248[i];
    if (v172)
    {
      obj_async_wait(v172);
      obj_release(v248[i]);
    }
  }
  if ((a2 & 2) == 0)
    pthread_mutex_unlock(v237 + 6);
  v9 = v187;
LABEL_371:
  if (v16)
    _apfs_free(v16, 8 * v11[10]);
  if (v14)
    _apfs_free(v14, 16 * v11[10]);
  obj_release(v237);
LABEL_376:
  pthread_mutex_lock(v9);
  --*(_DWORD *)(v8 + 824);
  pthread_mutex_unlock(v9);
  return v10;
}

uint64_t spaceman_trim_free_extent_callback(_QWORD *a1, unint64_t a2, int64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  __darwin_time_t tv_sec;
  int v11;
  int v13;
  uint64_t v14;
  timespec __tp;

  v14 = 0;
  if (spaceman_get(a1, &v14) || (v13 = spaceman_extent_check(a1, v14, a2, a3), obj_release(v14), !v13))
  {
    a1[212] += a3;
    if (a3 < 2)
    {
      v8 = 0;
    }
    else
    {
      v6 = 0;
      v7 = a3;
      do
      {
        v8 = v6 + 1;
        if (v7 < 4)
          break;
        v7 >>= 2;
      }
      while (v6++ < 4);
    }
    ++a1[v8 + 213];
    __tp.tv_sec = 0;
    __tp.tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    tv_sec = __tp.tv_sec;
    v11 = SLODWORD(__tp.tv_nsec) / 1000;
    dev_unmap(a1[48], a2);
    __tp.tv_sec = 0;
    __tp.tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    a1[211] += 1000000 * (__tp.tv_sec - tv_sec) - v11 + SLODWORD(__tp.tv_nsec) / 1000;
  }
  else if (nx_ratelimit_log_allowed((uint64_t)a1))
  {
    log_err("%s:%d: %s free extent %lld:%lld appears to span container metadata and should not be free: %d\n", "spaceman_trim_free_extent_callback", 4022, (const char *)(a1[48] + 208), a2, a3, v13);
  }
  return 0;
}

uint64_t ipaddr_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = v2 < v3;
  v5 = v2 > v3;
  if (v4)
    return 0xFFFFFFFFLL;
  else
    return v5;
}

uint64_t spaceman_trim_free_extent_flush(uint64_t a1)
{
  __darwin_time_t tv_sec;
  int v3;
  uint64_t result;
  timespec v5;

  v5.tv_sec = 0;
  v5.tv_nsec = 0;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v5);
  tv_sec = v5.tv_sec;
  v3 = SLODWORD(v5.tv_nsec) / 1000;
  dev_unmap_flush(*(_QWORD *)(a1 + 384));
  v5.tv_sec = 0;
  v5.tv_nsec = 0;
  result = clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v5);
  *(_QWORD *)(a1 + 1688) += 1000000 * (v5.tv_sec - tv_sec) - v3 + SLODWORD(v5.tv_nsec) / 1000;
  return result;
}

uint64_t spaceman_candidate_free_chunk_cmp(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a2 + 8);
  v4 = v2 >= v3;
  v5 = v2 != v3;
  if (v4)
    return v5;
  else
    return 0xFFFFFFFFLL;
}

uint64_t spaceman_iterate_free_extents(uint64_t a1, uint64_t (*a2)(_QWORD *a1, unint64_t a2, int64_t a3), _QWORD *a3)
{
  return spaceman_iterate_free_extents_internal(a1, 2u, 0, a2, a3);
}

uint64_t spaceman_scan_free_blocks(_QWORD *a1, int a2, int a3)
{
  uint64_t v6;
  int v7;
  unsigned int v8;
  timespec __tp;

  dev_features(a1[48]);
  v6 = 0;
  if (a3)
  {
    if (a2)
      v7 = 2;
    else
      v7 = 0;
    v8 = v7 | a3;
    __tp.tv_sec = 0;
    __tp.tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    a1[210] = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
    v6 = spaceman_iterate_free_extents_internal((uint64_t)a1, v8, 0, 0, a1);
    __tp.tv_sec = 0;
    __tp.tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    log_debug("%s:%d: %s scan took %lld.%06lld s (no trims)\n");
  }
  return v6;
}

uint64_t spaceman_free_queue_key_cmp(uint64_t a1, _QWORD *a2, int a3, _QWORD *a4, int a5, int *a6)
{
  uint64_t result;
  int v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;

  result = 22;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        v7 = 1;
      }
      else
      {
        v8 = a2[1];
        v9 = a4[1];
        v10 = v8 < v9;
        v7 = v8 > v9;
        if (v10)
          v7 = -1;
      }
    }
    else
    {
      v7 = -1;
    }
    result = 0;
    *a6 = v7;
  }
  return result;
}

uint64_t spaceman_fq_tree_find_overlap(uint64_t a1, uint64_t a2, unsigned int a3, unint64_t a4, uint64_t a5, _BYTE *a6)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  unint64_t v24;
  int64_t v25;
  uint64_t v26;
  uint64_t v27;

  v6 = *(_QWORD *)(a2 + 376);
  v26 = 0;
  v27 = 0;
  v24 = 0;
  v25 = 0;
  *a6 = 0;
  v7 = v6 + 40 * a3;
  v9 = *(_QWORD *)(v7 + 208);
  v8 = (_QWORD *)(v7 + 208);
  if (!v9)
    return 0;
  v23 = 0;
  v16 = spaceman_fq_tree_get(a1, a2, a3, 0, 0, &v27);
  if ((_DWORD)v16)
  {
    v17 = v16;
    log_err("%s:%d: %s can't get spaceman %d free queue tree %lld: %d\n", "spaceman_fq_tree_find_overlap", 4656, (const char *)(*(_QWORD *)(a1 + 384) + 208), a3, *v8, v16);
  }
  else
  {
    v18 = *(_QWORD *)(v6 + 40 * a3 + 216);
    if (v18 > obj_xid(a2))
    {
LABEL_23:
      v17 = 0;
    }
    else
    {
      v19 = a5 + a4;
      do
      {
        v23 = 0x1000000008;
        v24 = v18;
        v25 = a4;
        v20 = bt_lookup_variant(v27, 0, &v24, (unsigned int *)&v23 + 1, 0x10u, &v26, (unsigned int *)&v23, 1u, 0, 0);
        if ((_DWORD)v20 != 2)
        {
          v17 = v20;
          if ((_DWORD)v20)
            break;
          if (!(_DWORD)v23)
            v26 = 1;
          if (v18 == v24 && v26 + v25 > a4 && v19 > v25)
            goto LABEL_27;
        }
        v23 = 0x1000000008;
        v24 = v18;
        v25 = a4;
        v21 = bt_lookup_variant(v27, 0, &v24, (unsigned int *)&v23 + 1, 0x10u, &v26, (unsigned int *)&v23, 4u, 0, 0);
        v17 = v21;
        if ((_DWORD)v21 != 2)
        {
          if ((_DWORD)v21)
            break;
          if (!(_DWORD)v23)
            v26 = 1;
          if (v18 == v24 && v26 + v25 > a4 && v19 > v25)
          {
LABEL_27:
            v17 = 0;
            *a6 = 1;
            goto LABEL_24;
          }
        }
        ++v18;
      }
      while (v18 <= obj_xid(a2));
      if ((v17 | 2) == 2)
        goto LABEL_23;
      log_err("%s:%d: %s error searching spaceman free queue tree: %d\n", "spaceman_fq_tree_find_overlap", 4710, (const char *)(*(_QWORD *)(a1 + 384) + 208), v17);
    }
LABEL_24:
    obj_release(v27);
  }
  return v17;
}

uint64_t spaceman_fq_tree_over_threshold(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  unsigned __int16 *v4;
  unint64_t v5;
  unint64_t v6;
  unsigned int v9;
  BOOL v10;
  unsigned int v11;

  v4 = *(unsigned __int16 **)(a3 + 56);
  v5 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 376) + 40 * a2 + 224);
  if (a4)
  {
    v6 = *(_QWORD *)(*(_QWORD *)(a3 + 392) + 32);
    if (v5 >= 2)
      return v6 > v5 >> 1;
    if (v6 <= 1)
    {
      v9 = v4[25] + v4[23] + v4[27];
      v10 = v9 >= obj_size_phys(a3) >> 1;
      return !v10;
    }
    return 1;
  }
  if (v5 >= 2)
    return *(_QWORD *)(*(_QWORD *)(a3 + 392) + 32) > (3 * v5) >> 2;
  if (*(_QWORD *)(*(_QWORD *)(a3 + 392) + 32) > 1uLL)
    return 1;
  v11 = v4[25] + v4[23] + v4[27];
  v10 = v11 >= obj_size_phys(a3) >> 2;
  return !v10;
}

uint64_t spaceman_ip_block_index(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t *v15;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  _QWORD v26[2];
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _OWORD v30[4];
  uint64_t v31;
  uint64_t v32;

  v6 = *(_QWORD *)(a2 + 376);
  v7 = *(_QWORD *)(v6 + 152);
  if ((v7 & 0x8000000000000000) == 0)
  {
    v8 = *(_QWORD *)(v6 + 176);
    v9 = v8 + v7;
    v10 = __OFSUB__(a3, v8);
    v11 = a3 - v8;
    if (v11 < 0 != v10 || v9 <= a3)
      return 22;
    v13 = 0;
LABEL_12:
    *a4 = v11;
    return v13;
  }
  v23 = 0;
  v24 = 0;
  v15 = (uint64_t *)(a2 + 1504);
  if (*(_QWORD *)(a2 + 1504))
  {
LABEL_8:
    *(_QWORD *)&v30[0] = a3;
    LODWORD(v27) = 8;
    LODWORD(v26[0]) = 16;
    v13 = bt_lookup_variant(*v15, 0, (unint64_t *)v30, (unsigned int *)&v27, 8u, &v23, (unsigned int *)v26, 1u, 0, 0);
    if ((_DWORD)v13)
      return v13;
    if (a3 - *(_QWORD *)&v30[0] >= v24)
      return 2;
    v13 = 0;
    v11 = v23 + a3 - *(_QWORD *)&v30[0];
    goto LABEL_12;
  }
  v13 = btree_create(a1, 0x88000000, 0, 0, 0, 8u, 16, (uint64_t)extent_list_key_cmp, 0, (uint64_t *)(a2 + 1504));
  if (!(_DWORD)v13)
  {
    v32 = 0;
    memset(v30, 0, sizeof(v30));
    v31 = 0;
    v27 = 0;
    v28 = 0;
    v13 = nx_metadata_fragmented_extent_list_tree_get(a1, *(_QWORD *)(*(_QWORD *)(a2 + 376) + 176), &v32);
    if (!(_DWORD)v13)
    {
      v29 = 0;
      bt_iterator_init((uint64_t)v30, v32, 0, 0, &v29, 8, 8u, &v27, 0x10u);
      v13 = v18;
      if (bt_iterator_ended((uint64_t)v30))
      {
        obj_release(v32);
        if ((_DWORD)v13)
          return v13;
        goto LABEL_8;
      }
      while (1)
      {
        v25 = v27;
        v26[0] = v29;
        v26[1] = v28;
        v19 = bt_insert(*v15, 0, &v25, 8, v26, 16, 0);
        if ((_DWORD)v19)
          break;
        v20 = bt_iterator_next((uint64_t)v30);
        if ((_DWORD)v20)
        {
          v13 = v20;
          v21 = (const char *)(*(_QWORD *)(a1 + 384) + 208);
          v22 = strerror(v20);
          log_err("%s:%d: %s failed to get next internal pool reverse mapping, error %s(%d)\n", "spaceman_set_up_ip_reverse_mapping_tree", 4861, v21, v22, v13);
          goto LABEL_26;
        }
        if (bt_iterator_ended((uint64_t)v30))
        {
          obj_release(v32);
          goto LABEL_8;
        }
      }
      v13 = v19;
LABEL_26:
      obj_release(v32);
    }
  }
  return v13;
}

void *spaceman_free_queue_trim_list_init(uint64_t a1, uint64_t a2)
{
  void *result;

  *(_DWORD *)(a2 + 1530) = 256;
  *(_WORD *)(a2 + 1534) = 0;
  result = _apfs_calloc(0x100uLL, 0x10uLL);
  *(_QWORD *)(a2 + 1536) = result;
  if (!result)
    *(_WORD *)(a2 + 1530) = 0;
  return result;
}

uint64_t spaceman_alloc(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, unint64_t *a5, uint64_t *a6)
{
  uint64_t v9;
  _QWORD *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  unint64_t v15;
  _BOOL4 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  unint64_t v30;
  int v31;
  uint64_t v32;
  _BOOL4 is_current_tx;
  _QWORD *v34;
  uint64_t v35;
  _QWORD *v36;
  unsigned int v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  unsigned int v43;
  char v44;
  int v45;
  int v46;
  unint64_t v47;
  char v48;
  int v49;
  int v50;
  int v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  unsigned int v56;
  int v57;
  int v58;
  const char *v59;
  uint64_t v60;
  BOOL v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  _BOOL4 v68;
  _BOOL4 v69;
  unsigned int v70;
  unsigned __int8 v71;
  _QWORD *v72;
  int v73;
  _QWORD *v74;
  uint64_t v75;
  BOOL v76;
  int v77;
  uint64_t metazone_alloc_index;
  uint64_t v79;
  _BOOL4 v80;
  char v81;
  int v82;
  uint64_t v83;
  char v84;
  char v85;
  unsigned int v86;
  int v87;
  int v88;
  _QWORD *v89;
  int v90;
  _QWORD *v91;
  _QWORD *v92;
  uint64_t *v93;
  uint64_t v94;
  uint64_t v95;
  unsigned int v96;
  unsigned int v98;
  _QWORD *v99;
  uint64_t v100;
  int v101;
  int v102;
  unsigned int v103;
  int v104;
  int v105;
  int v106;
  _BOOL4 v107;
  uint64_t v108;
  uint64_t v109;
  BOOL v111;
  unint64_t v112;
  BOOL v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  unint64_t v118;
  uint64_t v119;
  unint64_t v120;
  unsigned int v121;
  unsigned int v122;
  uint64_t v123;
  unint64_t v124;
  unint64_t v125;
  uint64_t *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  unsigned int v131;
  unsigned int v132;
  uint64_t v133;
  unint64_t v134;
  unsigned int v135;
  unint64_t v136;
  unint64_t v137;
  __int16 v138;
  uint64_t v139;
  unsigned int v140;
  uint64_t v141;
  unint64_t v142;
  unint64_t v143;
  uint64_t v144;
  int v145;
  const char *v146;
  unint64_t v147;
  unint64_t v148;
  BOOL v149;
  int v150;
  char v151;
  int v152;
  int v153;
  uint64_t v154;
  _BOOL4 v156;
  _BOOL4 v158;
  unsigned int v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t *v162;
  uint64_t v163;
  unint64_t v164;
  _BOOL4 should_avoid_data_allocation_at_block;
  _BOOL4 v166;
  int v167;
  uint64_t v168;
  uint64_t v169;
  unint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  unint64_t v175;
  int first;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  unint64_t v181;
  unint64_t v182;
  unint64_t v183;
  unint64_t v184;
  uint64_t v185;
  unint64_t v186;
  unint64_t v187;
  unint64_t v188;
  uint64_t v189;
  int64_t v190;
  uint64_t v191;
  unsigned int v192;
  unint64_t v193;
  unint64_t v194;
  _BOOL4 v195;
  int v196;
  unint64_t v197;
  unint64_t v198;
  unint64_t v199;
  unint64_t v200;
  uint64_t v201;
  uint64_t v202;
  _BOOL4 v203;
  BOOL v204;
  char v205;
  uint64_t v206;
  unint64_t v207;
  unint64_t v208;
  unint64_t v209;
  unint64_t v210;
  unint64_t v211;
  uint64_t v212;
  unint64_t v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  uint64_t v217;
  uint64_t v218;
  int last_set;
  unint64_t v220;
  _BOOL4 v221;
  int v222;
  unint64_t v223;
  unint64_t v224;
  BOOL v225;
  unsigned int v226;
  unint64_t v227;
  int should_pause;
  unint64_t v229;
  int64_t v230;
  BOOL v231;
  _BOOL4 v232;
  unint64_t v233;
  uint64_t v234;
  uint64_t v235;
  unint64_t v236;
  int v237;
  unint64_t v238;
  unint64_t v239;
  unint64_t v240;
  unint64_t v241;
  BOOL v242;
  unint64_t v243;
  uint64_t v244;
  char v245;
  uint64_t v246;
  uint64_t v247;
  _BOOL4 v248;
  int v249;
  const char *v250;
  uint64_t v251;
  unint64_t v252;
  int v253;
  unint64_t v254;
  uint64_t v255;
  unint64_t v256;
  int v257;
  const char *v258;
  uint64_t v259;
  uint64_t v261;
  int64_t v262;
  unint64_t v263;
  unint64_t v264;
  _QWORD *v265;
  _QWORD *v266;
  int v267;
  int new_chunk_for_allocation_zone;
  unint64_t v269;
  char v270;
  unint64_t v271;
  uint64_t v272;
  unint64_t v273;
  int v274;
  char v275;
  BOOL v276;
  char v277;
  int v278;
  uint64_t *v279;
  int v280;
  unsigned int v281;
  unint64_t v282;
  unint64_t v283;
  _DWORD *v284;
  int v285;
  uint64_t v286;
  int v287;
  char v288;
  _BOOL4 v289;
  int v290;
  int v291;
  uint64_t v292;
  unint64_t v293;
  char v294;
  int v295;
  uint64_t v296;
  unint64_t v297;
  int v298;
  int v299;
  unint64_t v300;
  unint64_t *v301;
  int v302;
  int v303;
  unsigned __int8 v304;
  unint64_t v305;
  uint64_t v306;
  unsigned int *v307;
  unsigned int v308;
  const char *v309;
  unint64_t v310;
  unint64_t v311;
  int v312;
  unint64_t *v313;
  unint64_t v314;
  unint64_t v315;
  unsigned int v316;
  _BOOL4 v317;
  unsigned int v318;
  unint64_t v319;
  unint64_t v320;
  unint64_t v321;
  uint64_t v322;
  uint64_t v323;
  unint64_t v324;
  _QWORD *v325;
  _BOOL4 v326;
  int v327;
  unsigned __int8 v328;
  int v329;
  unint64_t v330;
  unint64_t v331;
  unsigned int v332;
  int v333;
  unint64_t v335;
  unint64_t v336;
  int v337;
  unint64_t v338;
  unint64_t v339;
  unsigned int v340;
  __int128 v343;
  __int128 v344;
  __int128 v345;
  unint64_t v346;
  unint64_t v347;
  unint64_t v348;
  int64_t v349;
  int64_t v350;
  _OWORD v351[4];
  uint64_t v352;
  unint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  __int128 v359;
  __int128 v360;
  __int128 v361;
  __int128 v362;
  __int128 v363;
  __int128 v364;
  _QWORD *v365;
  uint64_t v366;
  _QWORD v367[3];

  v9 = (uint64_t)a1;
  v367[1] = *MEMORY[0x1E0C80C00];
  v363 = 0u;
  v364 = 0u;
  v362 = 0u;
  v355 = 0;
  v356 = 0;
  v354 = 0;
  v350 = 0;
  v366 = 0;
  v367[0] = 0;
  v10 = 0;
  if (obj_type((uint64_t)a1) == 13)
  {
    v10 = a1;
    v9 = a1[49];
  }
  v360 = 0u;
  v361 = 0u;
  v359 = 0u;
  memset(v351, 0, sizeof(v351));
  v11 = a2 | 0x1000;
  if (!a6)
    v11 = a2 & 0xFFFFEBFF;
  v12 = *(_QWORD *)(v9 + 376);
  v13 = *(_QWORD *)(v12 + 1240);
  v14 = __clz(__rbit64(*(unsigned int *)(v12 + 36)));
  v15 = 0x4000000000000000uLL >> v14;
  v16 = ((0x4000000000000000uLL >> v14) & v13) != 0;
  v17 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v14;
  v18 = v17 & v13;
  v19 = *(_QWORD *)(v12 + 1248);
  v20 = (v18 + v19) & v17;
  v21 = v19 == 0;
  if (v19)
    v22 = v18;
  else
    v22 = 0;
  v331 = v22;
  if (v21)
    v23 = 0;
  else
    v23 = v20;
  v330 = v23;
  v24 = *(_QWORD *)(v9 + 1752);
  v25 = v15 & v24;
  v329 = (v15 & v24) != 0;
  if (*(_BYTE *)(v9 + 636) || (v27 = *(_QWORD *)(v9 + 1760)) == 0)
  {
    v336 = 0;
    v26 = 0;
  }
  else
  {
    v336 = v17 & v24;
    v26 = (v27 + (v17 & v24)) & v17;
  }
  if ((v11 & 0x80) != 0)
    v11 |= 0x8100u;
  if ((v11 & 0x200) != 0)
  {
    v11 |= 0x102u;
    *a5 = *(_QWORD *)(v9 + 1768);
  }
  v335 = v26;
  v28 = (v11 >> 2) & 0x100;
  if (*(_BYTE *)(v9 + 639))
    v28 = 2304;
  v29 = v28 | v11;
  if ((v11 & 2) != 0)
  {
    v29 &= ~0x40u;
    v30 = *a5;
    if ((v29 & 0x40) == 0)
      goto LABEL_23;
LABEL_25:
    v31 = *(_DWORD *)a5;
    goto LABEL_26;
  }
  v30 = 0;
  if ((v29 & 0x40) != 0)
    goto LABEL_25;
LABEL_23:
  v31 = 3;
LABEL_26:
  *a5 = 0;
  v337 = v29;
  if ((v29 & 4) != 0)
  {
    if (a3 < 1)
      return 22;
  }
  else
  {
    is_current_tx = xid_is_current_tx(v9, a4);
    v32 = 22;
    if (a3 < 1 || !is_current_tx)
      return v32;
  }
  v365 = 0;
  v357 = 0;
  v358 = 0;
  v353 = 0;
  v352 = 0;
  v349 = 0;
  v348 = 0;
  v347 = 0;
  v346 = 0;
  v32 = spaceman_get(v9, &v365);
  if ((_DWORD)v32)
    return v32;
  v308 = v31;
  v301 = a5;
  v34 = v365;
  v35 = v365[47];
  v36 = (_QWORD *)v365[198];
  v37 = v337;
  if (v36)
  {
    v38 = v36[1] + a3;
    ++*v36;
    v36[1] = v38;
    if ((v337 & 0x40) != 0)
    {
      v39 = v36 + 2;
    }
    else
    {
      switch(a3)
      {
        case 1:
          v40 = v36 + 4;
          v37 = v337;
          goto LABEL_45;
        case 2:
          v39 = v36 + 5;
          break;
        case 3:
          v39 = v36 + 6;
          break;
        case 4:
          v39 = v36 + 7;
          break;
        default:
          goto LABEL_42;
      }
      v37 = v337;
    }
    ++*v39;
LABEL_42:
    if ((unint64_t)a3 >= 2 && !a6)
    {
      v40 = v36 + 8;
LABEL_45:
      ++*v40;
    }
  }
  if ((v37 & 0x200) != 0)
  {
    v41 = v335;
    v335 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(v9 + 376) + 36)))) & *(_QWORD *)(v35 + 48 * (v25 != 0) + 48);
    v336 = v41;
  }
  if (!a6 && *(_QWORD *)(v35 + 96) + *(_QWORD *)(v35 + 48) <= (unint64_t)a3)
  {
    v32 = 28;
    goto LABEL_661;
  }
  v42 = *(_QWORD *)(v9 + 376);
  v43 = v37;
  if ((v37 & 2) != 0)
  {
    v44 = __clz(__rbit64(*(unsigned int *)(v42 + 36)));
    if ((((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v44) & v30) >= *(_QWORD *)(v35 + 48 * ((v30 << v44 >> 62) & 1) + 48))
      v43 = v37 & 0xFFFFFFFD;
    else
      v43 = v37;
  }
  if ((v43 & 0x1A) == 2)
  {
    if (((v30 << __clz(__rbit64(*(unsigned int *)(v42 + 36)))) & 0x4000000000000000) != 0)
      v45 = 16;
    else
      v45 = 8;
    v43 |= v45;
  }
  if ((~v43 & 0x38) == 0)
    panic("Absurd combination of allocation flags for spaceman %llx", v34);
  if (*(_QWORD *)(v35 + 96))
    __asm { BR              X12 }
  if ((v43 & 0x10) != 0)
  {
    v32 = 22;
    v34 = v365;
    goto LABEL_661;
  }
  v300 = v30;
  v290 = v16;
  LODWORD(v367[0]) = 0;
  LODWORD(v366) = 1;
  v46 = v37 & 0x40;
  v289 = v46 == 0;
  pthread_mutex_lock((pthread_mutex_t *)v365 + 6);
  v322 = 0;
  v318 = 0;
  v47 = 0;
  v294 = 0;
  v298 = 0;
  v48 = 0;
  v49 = v43 & 0x100 | v46;
  v50 = 0;
  v328 = v49 == 0;
  if (v365[186])
    v51 = v43;
  else
    v51 = v43 | 0x100;
  v332 = v51;
  v309 = (const char *)(a1 + 485);
  v52 = a6;
  v291 = 2;
  v339 = a3;
  v53 = a3;
LABEL_68:
  v288 = v48;
  v338 = v47;
  do
  {
LABEL_69:
    v327 = v50;
    do
    {
      v54 = v53;
      v55 = v327;
      while (1)
      {
        v56 = v332;
        v53 = v339;
        if (!(_BYTE)v55)
        {
          v57 = v55;
          goto LABEL_82;
        }
        if (!v336)
        {
          if ((v328 & 1) == 0)
          {
            v32 = 28;
LABEL_653:
            v53 = v54;
            goto LABEL_654;
          }
          v336 = 0;
          goto LABEL_81;
        }
        if ((v332 & 0x200) != 0)
        {
          v335 = 0;
          v336 = 0;
LABEL_81:
          v57 = 0;
          v328 = 0;
          goto LABEL_82;
        }
        v58 = obj_type((uint64_t)a1);
        v59 = (const char *)(a1 + 485);
        if (v58 != 13)
          v59 = (const char *)(a1[48] + 208);
        log_debug("%s:%d: %s Could not find data to allocate outside the soft block-out range, disable soft block-out range\n", "spaceman_alloc", 6927, v59);
        v335 = 0;
        v336 = 0;
        v57 = 0;
        v328 = 0;
        *(_BYTE *)(v9 + 636) = 1;
        *(_QWORD *)(v9 + 1784) = 0;
        v52 = a6;
LABEL_82:
        v60 = *((unsigned int *)v367 + v57);
        v340 = *((_DWORD *)&v367[-1] + v57);
        v312 = v57;
        v327 = v57 + 1;
        if ((v337 & 4) != 0)
        {
          v68 = v60 == v329;
          if (v335)
            v69 = v60 == v329;
          else
            v69 = 0;
          goto LABEL_112;
        }
        if ((v332 & 1) != 0)
          break;
        v61 = 1;
        while (1)
        {
          if (v10)
          {
            v62 = v10[47];
            v63 = *(_QWORD *)(v62 + 80);
            if (v63)
            {
              v64 = v10[51] + *(_QWORD *)(v62 + 88);
              if (v64 + v53 > v63)
              {
                v53 = v63 - v64;
                v32 = 69;
                if (!v52 || v53 < 1)
                  goto LABEL_654;
              }
            }
          }
          v54 = *(_QWORD *)(v35 + 240)
              + *(_QWORD *)(v35 + 72)
              + *(_QWORD *)(v35 + 120)
              + *(_QWORD *)(v35 + 280)
              + *(_QWORD *)(v35 + 192)
              - *(_QWORD *)(v35 + 184);
          if (v10)
          {
            v65 = v10[47];
            v66 = *(_QWORD *)(v65 + 72);
            v67 = *(_QWORD *)(v65 + 88);
            if (v66 > v67)
              v54 = v66 + v54 - v67;
          }
          if (v53 > (unint64_t)v54)
          {
            v32 = 28;
            if (!v52)
              goto LABEL_653;
            v53 = v54;
            if (v54 < 1)
              goto LABEL_653;
          }
          v54 = *(_QWORD *)(v35 + 48 * v60 + 72) - v365[v60 + 104];
          if (v53 <= v54)
            goto LABEL_105;
          if (v61)
            v54 += *(_QWORD *)(v35 + 40 * v340 + 200);
          if (v53 > v54)
            break;
LABEL_103:
          if (!v61)
            goto LABEL_108;
          pthread_mutex_unlock((pthread_mutex_t *)v365 + 6);
          pthread_mutex_lock((pthread_mutex_t *)v365 + 8);
          trim_time_tracking_start(v9, (uint64_t)v351, 0, 0);
          v61 = spaceman_free_completed(v9, (uint64_t)v365, v340, 1, (uint64_t)v351, a4) != 0;
          trim_time_tracking_end(v9, (uint64_t)v351);
          pthread_mutex_unlock((pthread_mutex_t *)v365 + 8);
          pthread_mutex_lock((pthread_mutex_t *)v365 + 6);
          v52 = a6;
          v54 = 0;
          v53 = v339;
LABEL_105:
          if (v53 <= v54)
          {
LABEL_108:
            v68 = v60 == v329;
            if (v335)
              v69 = v60 == v329;
            else
              v69 = 0;
            v56 = v332;
LABEL_112:
            v70 = v337;
            goto LABEL_113;
          }
        }
        if (v52 && v54 > 0)
        {
          v53 = v54;
          goto LABEL_103;
        }
        v55 = v327;
        v328 &= v327 == 0;
      }
      v68 = v60 == v329;
      if (v335)
        v69 = v60 == v329;
      else
        v69 = 0;
      v70 = v337;
      v89 = &v365[v60];
      if ((v332 & 0x40) != 0)
      {
        if (v89[106] >= v339)
          goto LABEL_113;
        obj_type((uint64_t)a1);
        v53 = v339;
        log_err("%s:%d: %s Bogus attempt to perform metadata reserved allocation %lld with insufficient reserve %lld (%lld)\n");
LABEL_684:
        v32 = 28;
        goto LABEL_654;
      }
      if (v89[104] - v89[106] < v339)
      {
        obj_type((uint64_t)a1);
        v53 = v339;
        log_err("%s:%d: %s Bogus attempt to perform non-metadata reserved allocation %lld with insufficient reserve %lld (%lld)\n");
        goto LABEL_684;
      }
LABEL_113:
      v317 = v68;
      v71 = 0;
      v72 = v365;
      v73 = (LOBYTE(v365[13 * v60 + 138]) != 0) & (v70 >> 6);
      v303 = v73;
      if (v53 <= 4
        && (v73 & 1) == 0
        && ((v71 = v53 - 1,
             v74 = &v365[17 * v60 + 152],
             v75 = (v53 - 1),
             LOBYTE(v74[4 * v75 + 3]))
          ? (v76 = (v56 & 0x100) == 0)
          : (v76 = 0),
            v76))
      {
        v304 = v53 - 1;
        v79 = 0;
        v350 = v74[4 * v75];
        v80 = v53 <= (*(_DWORD *)(v365[v60 + 186] + 4 * (v350 / *(unsigned int *)(v35 + 36))) & 0xFFFFFFu);
      }
      else
      {
        if (v308 < 3)
          v77 = (LOBYTE(v365[13 * v60 + 138]) != 0) & (v70 >> 6);
        else
          v77 = 0;
        v304 = v71;
        if (v77 == 1)
        {
          metazone_alloc_index = spaceman_get_metazone_alloc_index(v365, v60, v308);
          v70 = v337;
          v79 = 0;
          v80 = 0;
          v350 = metazone_alloc_index;
          v72 = v365;
          goto LABEL_132;
        }
        if ((v56 & 2) != 0)
        {
          v81 = __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(v9 + 376) + 36)));
          if ((_DWORD)v60 == (((v300 << v81) & 0x4000000000000000) != 0))
          {
            v80 = 0;
            v79 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v81) & v300;
            v350 = v79;
            goto LABEL_131;
          }
        }
        v79 = 0;
        v80 = 0;
        if ((v56 & 0x800) != 0)
        {
          v350 = 0;
LABEL_131:
          v56 |= 0x4000u;
        }
        else
        {
          v350 = v365[v60 + 124];
        }
      }
LABEL_132:
      v82 = (v70 >> 6) & 1;
      v357 = 0;
      v358 = 0;
      v349 = 0;
      v347 = 0;
      v83 = v72[v60 + 196];
      if (!v83)
        LOBYTE(v82) = 1;
      v84 = v80 | v82;
      if ((v56 & 0x8400) != 0)
        v85 = 1;
      else
        v85 = v84;
      if ((v85 & 1) != 0)
      {
        if (((v80 | ((v70 & 0x40) >> 6)) & 1) != 0)
        {
          v316 = 0;
          v279 = 0;
          v101 = v80 || v289;
          v326 = v60 == v290;
          v102 = !v317;
          v276 = v317;
          v103 = v56;
          goto LABEL_214;
        }
        v333 = v56;
LABEL_190:
        if (!v365[v60 + 186] || (v333 & 0x100) != 0)
          goto LABEL_210;
        *(_QWORD *)&v362 = v350;
        *((_QWORD *)&v362 + 1) = v53;
        LOBYTE(v363) = v328 & 1;
        BYTE8(v364) = a6 == 0;
        *((_QWORD *)&v363 + 1) = 0;
        *(_QWORD *)&v364 = 0;
        if (v69)
        {
          *((_QWORD *)&v363 + 1) = v336;
          *(_QWORD *)&v364 = v335 - v336;
        }
        spaceman_search_bitmap_hints_for_space((unint64_t)v365, v60, (uint64_t)&v362, &v359);
        if (v104 != 28)
        {
          v105 = v104;
          if (!v104)
          {
            v106 = v360;
            v350 = v359;
            if (a6)
              v53 = *((_QWORD *)&v359 + 1);
            v294 = 1;
LABEL_203:
            LOBYTE(v70) = v337;
            if (v106)
              v107 = 0;
            else
              v107 = v69;
            if (v107)
            {
              v335 = 0;
              v336 = 0;
              if ((v333 & 0x200) == 0)
              {
                *(_BYTE *)(v9 + 636) = 1;
                *(_QWORD *)(v9 + 1784) = 0;
              }
            }
            v328 = v106 != 0;
LABEL_210:
            v326 = v60 == v290;
            if ((v85 & 1) != 0)
            {
              v316 = 0;
              v101 = 0;
              v279 = 0;
              v102 = !v317;
              v276 = v317;
            }
            else
            {
              v276 = 0;
              v101 = 0;
              v279 = &v350;
              v102 = 1;
              v316 = 1;
            }
            v103 = v333;
LABEL_214:
            v292 = 0;
            v311 = 0;
            v108 = v35 + 48 * v60;
            v313 = (unint64_t *)(v108 + 48);
            v307 = (unsigned int *)(v108 + 64);
            v284 = (_DWORD *)(v108 + 68);
            v299 = v103 & 0x400;
            v287 = v102 ^ 1;
            v275 = v101;
            v295 = v101 | ((v70 & 0x40) >> 6);
            v277 = v102;
            v278 = !v69;
            v109 = v322;
            v332 = v103;
            v282 = v79;
            while (2)
            {
              if (v326 && v350 >= (uint64_t)v331 && v350 < (uint64_t)v330)
              {
                v111 = v276;
                if ((uint64_t)v330 < (uint64_t)v336)
                  v111 = 0;
                if (v111 && (uint64_t)v330 < (uint64_t)v335)
                  v112 = v335;
                else
                  v112 = v330;
                v350 = v112;
              }
              if ((v102 & 1) == 0 && v350 >= (uint64_t)v336 && v350 < (uint64_t)v335)
              {
                v114 = v326;
                if ((uint64_t)v335 < (uint64_t)v331)
                  v114 = 0;
                if (v114 && (uint64_t)v335 < (uint64_t)v330)
                  v115 = v330;
                else
                  v115 = v335;
                v350 = v115;
              }
              v116 = v365[v60 + 196];
              if (v116)
              {
                LODWORD(v116) = spaceman_free_extent_cache_bitmap_scan_begin(v116, v279);
                v298 = 0;
              }
              v117 = v350;
              if (v350 >= *v313)
              {
                v117 = 0;
                v350 = 0;
              }
              LODWORD(v321) = 0;
              v318 = 0;
              v118 = 0;
              v280 = v116;
              v302 = v316 & v116;
              v285 = -1;
              v314 = v338;
              v119 = v311;
              while (1)
              {
                v324 = v118;
                v120 = v117 / *(unsigned int *)(v35 + 36) / *(unsigned int *)(v35 + 40);
                v311 = v119;
                if (*v284)
                {
                  v121 = *(_DWORD *)(v35 + 44);
                  v122 = v120 / v121;
                  v123 = v356;
                  if (v120 / v121 == v285)
                  {
                    LODWORD(v124) = v117 / *(unsigned int *)(v35 + 36) / *(unsigned int *)(v35 + 40);
                    v122 = v285;
                  }
                  else
                  {
                    v125 = v117;
                    v127 = *(_QWORD *)(v365[v60 + 111] + 8 * v122);
                    if (v356)
                    {
                      obj_release(v356);
                      v356 = 0;
                    }
                    v352 = v35;
                    v353 = __PAIR64__(v122, v60);
                    v128 = obj_get(*(_QWORD *)(v9 + 392), 0x40000000, v127, &sm_cab_desc, &v352, 0, 0, 0, &v356);
                    if ((_DWORD)v128)
                    {
                      v32 = v128;
                      v52 = a6;
                      v119 = v311;
LABEL_571:
                      v117 = v125;
LABEL_572:
                      if (v318 <= *v307)
                      {
                        if (v280)
                        {
                          if (v316)
                          {
                            if ((_DWORD)v32)
                              v242 = 0;
                            else
                              v242 = v117 > v350;
                            if (v242)
                            {
                              v243 = v357 || !v119
                                   ? *(_QWORD *)(v109 + 32 * v314 + 48) + v357 + v358
                                   : v119 + v292;
                              if (v117 <= v243)
                                v117 = v243;
                            }
                          }
                          else
                          {
                            v117 = 0;
                          }
                          v244 = v365[v60 + 196];
                          v241 = v117;
                          v245 = 0;
LABEL_593:
                          spaceman_free_extent_cache_bitmap_scan_finished(v244, v241, v245);
                          v52 = a6;
                        }
                      }
                      else if (v280)
                      {
                        if (v316)
                          v241 = *(_QWORD *)(v365[47] + 48 * v60 + 48);
                        else
                          v241 = 0;
                        v244 = v365[v60 + 196];
                        v245 = 1;
                        goto LABEL_593;
                      }
LABEL_594:
                      v246 = v357;
                      v322 = v109;
                      if (!v357 && v119)
                      {
                        v251 = *(unsigned int *)(v35 + 36);
                        v252 = v292;
                        v357 = v119;
                        v358 = v292 % v251;
                        if ((_DWORD)v32)
                          goto LABEL_654;
                        v246 = v119;
                        if (!v292)
                          goto LABEL_628;
                      }
                      else
                      {
                        if (v357 || (_DWORD)v32)
                        {
                          if ((_DWORD)v32)
                            goto LABEL_654;
                        }
                        else
                        {
                          if (v318 == *(_DWORD *)(v35 + 48 * v60 + 64) + 1)
                          {
                            v50 = v327;
                            if ((v337 & 4) == 0)
                            {
                              pthread_mutex_unlock((pthread_mutex_t *)v365 + 6);
                              pthread_mutex_lock((pthread_mutex_t *)v365 + 8);
                              trim_time_tracking_start(v9, (uint64_t)v351, 0, 0);
                              v247 = spaceman_free_completed(v9, (uint64_t)v365, v340, 1, (uint64_t)v351, a4);
                              trim_time_tracking_end(v9, (uint64_t)v351);
                              pthread_mutex_unlock((pthread_mutex_t *)v365 + 8);
                              pthread_mutex_lock((pthread_mutex_t *)v365 + 6);
                              v52 = a6;
                              if (v247)
                                v50 = v312;
                            }
                            v338 = v314;
                            if (v356)
                            {
                              obj_release(v356);
                              v52 = a6;
                              v356 = 0;
                              v338 = v314;
                            }
                            goto LABEL_69;
                          }
                          v246 = 0;
                        }
LABEL_628:
                        v252 = v358 + *(_QWORD *)(v109 + 32 * v314 + 48);
                        v119 = v246;
                      }
                      v293 = v252;
                      if ((_DWORD)v60 == 1)
                        v252 |= 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(v9 + 376) + 36)));
                      v253 = spaceman_extent_check((_QWORD *)v9, (uint64_t)v365, v252, v119);
                      if (v253)
                      {
                        v267 = v253;
                        if (nx_ratelimit_log_allowed(*(_QWORD *)(*a1 + 392)))
                        {
                          if (obj_type((uint64_t)a1) == 13)
                          {
                            if ((_DWORD)v60 == 1)
                              v293 |= 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(v9 + 376)
                                                                                              + 36)));
                            log_err("%s:%d: %s found free extent (0x%llx:0x%llx) which should not be free!: %d\n", "spaceman_alloc", 7903, v309, v293, v119, v267);
                          }
                          else
                          {
                            if ((_DWORD)v60 == 1)
                              v293 |= 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(v9 + 376)
                                                                                              + 36)));
                            log_err("%s:%d: %s found free extent (0x%llx:0x%llx) which should not be free!: %d\n", "spaceman_alloc", 7903, (const char *)(a1[48] + 208), v293, v119, v267);
                          }
                        }
                        v255 = nx_corruption_detected_int(v9);
                      }
                      else
                      {
                        v254 = *(_QWORD *)(v35 + 48 * v60 + 48);
                        if ((v337 & 4) != 0 || v357 < 1)
                          goto LABEL_685;
                        if (*(_BYTE *)(v9 + 627))
                        {
                          v32 = 30;
                          goto LABEL_654;
                        }
                        if (v356)
                        {
                          obj_release(v356);
                          v356 = 0;
                        }
                        if (v355)
                        {
                          obj_release(v355);
                          v355 = 0;
                        }
                        if (v354)
                        {
                          obj_release(v354);
                          v354 = 0;
                        }
                        v255 = obj_modify(v365, 0, a4);
                        if (!(_DWORD)v255)
                        {
                          v256 = v293;
                          if ((_DWORD)v60 == 1)
                            v256 = (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(v9 + 376)
                                                                                            + 36)))) | v293;
                          v32 = spaceman_modify_bits((_QWORD *)v9, v10, (uint64_t)v365, v256, v119, a4, 0, v332);
                          spaceman_free_extent_cache_remove(v365[v60 + 196], v293, v119);
                          if ((_DWORD)v32)
                          {
                            v257 = obj_type((uint64_t)a1);
                            v258 = (const char *)(a1 + 485);
                            if (v257 != 13)
                              v258 = (const char *)(a1[48] + 208);
                            log_err("%s:%d: %s Failed to set bits for allocation %lld:%lld: %d\n", "spaceman_alloc", 7948, v258, v293, v119, v32);
                            v50 = v312;
                            if (!v316)
                              goto LABEL_654;
                            spaceman_free_extent_cache_reset(v365[v60 + 196]);
                            v48 = 1;
                            v52 = a6;
                            v47 = v314;
                            if ((v288 & 1) != 0)
                              goto LABEL_654;
                            goto LABEL_68;
                          }
LABEL_685:
                          if (v293 + v119 >= v254)
                            v264 = 0;
                          else
                            v264 = v293 + v119;
                          if ((_DWORD)v60 == 1)
                            v293 |= 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(v9 + 376)
                                                                                            + 36)));
                          *v301 = v293;
                          if (a6)
                            *a6 = v119;
                          v265 = v365;
                          v266 = (_QWORD *)v365[198];
                          if (v266)
                          {
                            v266[10] += v119;
                            if (v119 < (uint64_t)v339)
                              ++v266[11];
                            if ((v275 & 1) != 0)
                            {
                              ++v266[3];
LABEL_704:
                              if ((*(_DWORD *)(v265[v60 + 186]
                                              + 4
                                              * (v265[17 * v60 + 152 + 4 * v304]
                                               / (unint64_t)*(unsigned int *)(v35 + 36))) & 0xFFFFFFu) <= v304)
                              {
                                new_chunk_for_allocation_zone = spaceman_get_new_chunk_for_allocation_zone(v9, (uint64_t)v265, v60, v304);
                                v32 = 0;
                                if (!new_chunk_for_allocation_zone || new_chunk_for_allocation_zone == 28)
                                  goto LABEL_654;
                                obj_type((uint64_t)a1);
                                log_err("%s:%d: %s failed to update chunk for alloc zone %d: %d\n");
                              }
LABEL_732:
                              v32 = 0;
                              goto LABEL_654;
                            }
                          }
                          else if ((v275 & 1) != 0)
                          {
                            goto LABEL_704;
                          }
                          if ((v332 & 0x200) != 0)
                          {
                            v269 = *(_QWORD *)(v9 + 1752);
                            v270 = __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(v9 + 376) + 36)));
                            v271 = 0x4000000000000000uLL >> v270;
                            if ((_DWORD)v60 == (((0x4000000000000000uLL >> v270) & v269) != 0)
                              && (v272 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v270, v264 >= (v272 & v269))
                              && v264 < ((*(_QWORD *)(v9 + 1760) + v269) & v272))
                            {
                              v32 = 0;
                              if ((_DWORD)v60 == 1)
                                v273 = v271;
                              else
                                v273 = 0;
                              v269 = v273 | v264;
                            }
                            else
                            {
                              v32 = 0;
                            }
                            *(_QWORD *)(v9 + 1768) = v269;
                            goto LABEL_654;
                          }
                          if ((v332 & 0x142) != 0
                            && (_DWORD)v60 == (((v300 << __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(v9 + 376) + 36)))) & 0x4000000000000000) != 0))
                          {
                            if (v303)
                              spaceman_update_metazone_alloc_index((uint64_t)v265, v60, v308, v264);
                          }
                          else
                          {
                            v265[v60 + 124] = v264;
                            if ((v328 & 1) != 0
                              && spaceman_should_avoid_data_allocation_at_block((uint64_t)v265, v60, v264, 5))
                            {
                              *(_QWORD *)&v362 = v264;
                              *((_QWORD *)&v362 + 1) = 1;
                              LOBYTE(v363) = 1;
                              BYTE8(v364) = 1;
                              *((_QWORD *)&v363 + 1) = 0;
                              *(_QWORD *)&v364 = 0;
                              spaceman_search_bitmap_hints_for_space((unint64_t)v365, v60, (uint64_t)&v362, &v359);
                              if (v274)
                              {
                                if (v274 != 28)
                                {
                                  obj_type((uint64_t)a1);
                                  log_err("%s:%d: %s failed to move roving pointer for dev %d error %d\n");
                                }
                              }
                              else if (*((uint64_t *)&v359 + 1) >= 1)
                              {
                                v32 = 0;
                                v365[v60 + 124] = v359;
                                goto LABEL_654;
                              }
                            }
                          }
                          goto LABEL_732;
                        }
                      }
                      v32 = v255;
                      goto LABEL_654;
                    }
                    v121 = *(_DWORD *)(v35 + 44);
                    v123 = v356;
                    v117 = v125;
                    v285 = v122;
                    v124 = v125 / *(unsigned int *)(v35 + 36) / *(unsigned int *)(v35 + 40);
                  }
                  v125 = v117;
                  v126 = (uint64_t *)(*(_QWORD *)(v123 + 56) + 8 * (v120 - v121 * v122) + 40);
                  LODWORD(v120) = v124;
                  v119 = v311;
                }
                else
                {
                  v125 = v117;
                  v126 = (uint64_t *)(v365[v60 + 111] + 8 * v120);
                }
                v129 = *v126;
                v352 = v35;
                v353 = __PAIR64__(v120, v60);
                v306 = v129;
                v130 = obj_get(*(_QWORD *)(v9 + 392), 0x40000000, v129, &sm_cib_desc, &v352, 0, 0, 0, &v355);
                if ((_DWORD)v130)
                {
                  v32 = v130;
                  v52 = a6;
                  goto LABEL_571;
                }
                v109 = *(_QWORD *)(v355 + 56);
                v131 = *(_DWORD *)(v109 + 32);
                v133 = *(unsigned int *)(v35 + 36);
                v132 = *(_DWORD *)(v35 + 40);
                v134 = v132 * (unint64_t)v131;
                v52 = a6;
                v117 = v125;
                v135 = v318 == *v307 ? v350 / v133 - v134 + 1 : *(_DWORD *)(v109 + 36);
                v136 = v324;
                v137 = v125 / v133 - v132 * (unint64_t)v131;
                if (v135 > v137)
                  break;
                v314 = v137;
                v32 = 0;
LABEL_540:
                if (!v357 && v119 != v53)
                {
                  v231 = v136 || !v119 ? (_DWORD)v32 == 0 : (v32 | v299) == 0;
                  v232 = !v231;
                  if (((v232 | v298) & 1) == 0)
                  {
                    v233 = v117;
                    v234 = v119;
                    v235 = v109;
                    v236 = v136;
                    obj_release(v355);
                    v118 = v236;
                    v109 = v235;
                    v119 = v234;
                    v117 = v233;
                    v52 = a6;
                    v355 = 0;
                    if (++v318 <= *v307)
                      continue;
                  }
                }
                goto LABEL_572;
              }
              v283 = v135 - 1;
              v338 = v137;
              v281 = v135;
              v315 = v135;
              v138 = v332;
              v323 = *(_QWORD *)(v355 + 56);
              v305 = v134;
LABEL_259:
              if (v321 <= 2)
              {
                v140 = *(_DWORD *)(v35 + 36);
              }
              else
              {
                v139 = v361;
                v140 = *(_DWORD *)(v35 + 36);
                if (!((v294 ^ 1) & 1 | ((uint64_t)v361 < 1)) && v53 <= 2 * v140)
                {
                  if (v355)
                  {
                    obj_release(v355);
                    v52 = a6;
                    v355 = 0;
                    v139 = v361;
                  }
                  v294 = 0;
                  v350 = *((_QWORD *)&v360 + 1);
                  if (v52)
                    v53 = v139;
                  v328 = BYTE8(v361) != 0;
                  LOBYTE(v102) = v277;
                  v237 = v278;
                  if (BYTE8(v361))
                    v237 = 1;
                  if (v237)
                    v238 = v336;
                  else
                    v238 = 0;
                  v239 = v335;
                  if (!v237)
                    v239 = 0;
                  v335 = v239;
                  v336 = v238;
                  if ((v237 & 1) == 0 && (v138 & 0x200) == 0)
                  {
                    v335 = 0;
                    v336 = 0;
                    v328 = 0;
                    v294 = 0;
                    *(_BYTE *)(v9 + 636) = 1;
                    *(_QWORD *)(v9 + 1784) = 0;
                  }
                  continue;
                }
              }
              break;
            }
            v141 = v109 + 32 * v338;
            v142 = *(_QWORD *)(v141 + 48);
            v325 = (_QWORD *)(v141 + 48);
            v143 = v134 + v338;
            if (v142 != (v134 + v338) * v140)
            {
              v145 = obj_type((uint64_t)a1);
              v146 = (const char *)(a1 + 485);
              if (v145 != 13)
                v146 = (const char *)(a1[48] + 208);
              log_err("%s:%d: %s skip bad chunk info ci @ block %lld (cib %lld) ci_index 0x%x ci_addr 0x%llx (expect 0x%llx)\n", "spaceman_alloc", 7422, v146, v306, *(_QWORD *)(v109 + 8), v338, *v325, v143 * *(unsigned int *)(v35 + 36));
              v147 = *(unsigned int *)(v35 + 36) + *(unsigned int *)(v35 + 36) * v143;
              v52 = a6;
LABEL_344:
              v136 = 0;
              if (v147 >= *v313)
                v117 = 0;
              else
                v117 = v147;
              goto LABEL_347;
            }
            if (v318 == *v307 && v350 / v140 - v134 == v338)
              v144 = v350 - v142;
            else
              v144 = *(_DWORD *)(v109 + 32 * v338 + 56) & 0xFFFFFLL;
            if (v326 && v331 > v142 && v331 < v144 + v142 && v331 - v142 < v144)
              v144 = v331 - v142;
            if (v317)
            {
              v148 = v336 - v142;
              v149 = v336 <= v142 || v336 >= v144 + v142;
              v150 = v149;
              v151 = v316;
              if (v149)
                v151 = 1;
              v152 = v150 ^ 1;
              if (v148 >= v144)
                v148 = v144;
              if ((v151 & 1) != 0)
              {
                v153 = v152;
              }
              else
              {
                v144 = v148;
                v153 = 0;
              }
            }
            else
            {
              v153 = 0;
            }
            v154 = v117 - v142;
            if (v326 && v330 > v142 && v330 < v144 + v142)
            {
              if (v330 - v142 > v154)
                v154 = v330 - v142;
              v117 = v154 + v142;
              if (v154 > 0)
                v136 = 0;
            }
            if (v317 && v335 > v142 && v335 < v144 + v142)
            {
              if ((v316 & 1) != 0)
              {
                v153 = 1;
                goto LABEL_305;
              }
              if (v335 - v142 > v154)
                v154 = v335 - v142;
              v117 = v154 + v142;
              if (v154 > 0)
                v136 = 0;
              if (!v52)
              {
LABEL_391:
                v189 = v323 + 32 * v338;
                v190 = *(_DWORD *)(v189 + 60) & 0xFFFFF;
                if (!v136 || v190 < (*(_DWORD *)(v189 + 56) & 0xFFFFFu) && (uint64_t)(v53 - v136) > v190)
                {
                  if ((_DWORD)v190)
                  {
                    if (v338 >= v283
                      || (v191 = v323 + 32 * (v338 + 1),
                          v192 = *(_DWORD *)(v191 + 60) & 0xFFFFF,
                          v53 <= v192 + v190))
                    {
                      v136 = 0;
                    }
                    else
                    {
                      v136 = 0;
                      if (v192 < (*(_DWORD *)(v191 + 56) & 0xFFFFFu))
                        v153 = 1;
                    }
                  }
                  else
                  {
                    v136 = 0;
                    v153 = 2;
                  }
                }
              }
            }
            else
            {
LABEL_305:
              if (!v52)
                goto LABEL_391;
            }
            if (v326 && v330 >= v144 + v142 && v331 <= v154 + v142)
              v153 = 2;
            if (v153)
              v156 = 0;
            else
              v156 = v317;
            v158 = v336 <= v154 + v142 && v335 >= v144 + v142;
            if (v156)
              v159 = v158;
            else
              v159 = v153;
            if (v52)
            {
              v160 = v323;
              if ((*(_DWORD *)(v323 + 32 * v338 + 60) & 0xFFFFF) == 0)
                v159 = 2;
            }
            else
            {
              v160 = v323;
            }
            v161 = v160 + 32 * v338;
            v163 = *(_QWORD *)(v161 + 64);
            v162 = (uint64_t *)(v161 + 64);
            if (!v163 && ((*(_DWORD *)(v160 + 32 * v338 + 56) ^ *(_DWORD *)(v160 + 32 * v338 + 60)) & 0xFFFFF) != 0)
              v159 = 2;
            v319 = v117;
            if (((v159 == 0) & v328) == 1)
            {
              v164 = v136;
              should_avoid_data_allocation_at_block = spaceman_should_avoid_data_allocation_at_block((uint64_t)v365, v60, v142, v53);
              v136 = v164;
              v117 = v319;
              v52 = a6;
              v159 = should_avoid_data_allocation_at_block;
            }
            if (v159 > v316)
            {
              v147 = v117 + v144 - v154;
              v166 = v326;
              if (v147 < v331)
                v166 = 0;
              v138 = v332;
              v109 = v323;
              v134 = v305;
              if (v166 && v147 < v330)
                goto LABEL_343;
              v167 = v287;
              if (v147 < v336)
                v167 = 0;
              if (v167 == 1 && v147 < v335)
LABEL_343:
                v147 = *v325 + (*(_DWORD *)(v323 + 32 * v338 + 56) & 0xFFFFF);
              goto LABEL_344;
            }
            v321 = (v321 + 1);
            v168 = *v162;
            v354 = 0;
            if (v168)
            {
              v169 = v60;
              v170 = v136;
              v171 = obj_get(*(_QWORD *)(v9 + 392), 0x40000000, v168, &sm_bm_desc, 0, 0, 0, 0, &v354);
              if ((_DWORD)v171)
              {
                v32 = v171;
                v314 = v338;
                v52 = a6;
                v109 = v323;
                v119 = v311;
                v117 = v319;
                v136 = v170;
                v60 = v169;
                goto LABEL_540;
              }
              v172 = v354;
              v117 = v319;
              v136 = v170;
              v60 = v169;
              if (!v136)
              {
LABEL_435:
                v320 = v117;
                if (v172)
                {
                  if (v365[v60 + 196])
                  {
                    if (v144 <= v154)
                    {
                      v286 = 0;
                      v201 = 0;
                    }
                    else
                    {
                      v201 = 0;
                      v286 = 0;
                      v297 = v117 - v154;
                      v202 = v154;
                      do
                      {
                        bitmap_range_find_first_clear_range(*(_QWORD *)(v354 + 56), v144 - v202, v202, v144, &v358, &v357);
                        if (!v357)
                          break;
                        if (v357 > v201)
                        {
                          v203 = v201 < v53;
                          if (v299)
                            v203 = v201 == 0;
                          if (v203)
                          {
                            v286 = v358;
                            if (v53 >= v357)
                              v201 = v357;
                            else
                              v201 = v53;
                          }
                        }
                        if (v159)
                          v204 = 1;
                        else
                          v204 = v201 < v53;
                        v205 = v295;
                        if (v204)
                          v205 = 0;
                        if ((v205 & 1) != 0)
                          break;
                        spaceman_free_extent_cache_insert(v365[v60 + 196], v302, v297 + v358, v357);
                        v202 = v357 + v358;
                      }
                      while (v357 + v358 < v144);
                    }
                    v208 = 0;
                    v357 = v201;
                    v358 = v286;
                    if (!v159)
                    {
                      v52 = a6;
                      if (v201 >= v53)
                      {
                        v136 = 0;
                        v32 = 0;
                        v117 = v144 - v154 + v320;
LABEL_525:
                        v314 = v338;
                        goto LABEL_538;
                      }
LABEL_469:
                      v210 = v357;
                      if (!v52)
                      {
                        v211 = v320;
                        goto LABEL_482;
                      }
                      v211 = v320;
                      if (v357 > (uint64_t)v311)
                      {
                        v212 = v358;
                        if (v159)
                        {
                          v213 = v208;
                          v214 = v320 - v154;
                          if ((spaceman_clip_extent_to_zones(v9, (uint64_t)v365, v60, v320 - v154 + v358, v357, v332, v282, &v348, &v346) & 1) != 0)
                          {
                            v215 = v311;
                            v216 = v292;
                            if (v346 > v311)
                              v216 = v348;
                            v292 = v216;
                            if (v346 > v311)
                              v215 = v346;
                            v311 = v215;
                            v210 = v357;
                            v52 = a6;
                            v211 = v320;
                            v208 = v213;
                            goto LABEL_482;
                          }
                          v210 = v357;
                          v212 = v358;
                          v52 = a6;
                          v211 = v320;
                          v208 = v213;
                        }
                        else
                        {
                          v214 = v320 - v154;
                        }
                        v292 = v214 + v212;
                        v311 = v210;
                      }
LABEL_482:
                      v138 = v332;
                      v134 = v305;
                      if (!v210 || v358 + v210 != v144)
                      {
                        if (v299 && v311)
                        {
                          v136 = 0;
                          v32 = 0;
                          v117 = v144 - v154 + v211;
                          goto LABEL_525;
                        }
                        v210 = v208;
                        if (!v208)
                        {
                          v217 = v144 - v53;
                          if (v144 >= v53)
                          {
                            v218 = v53;
                          }
                          else
                          {
                            v217 = 0;
                            v218 = v144;
                          }
                          last_set = bitmap_range_find_last_set(*(_QWORD *)(v354 + 56), v217, v218, &v358);
                          v52 = a6;
                          v211 = v320;
                          if (last_set && v358 < v144 - 1)
                          {
                            v210 = v144 + ~v358;
                            spaceman_free_extent_cache_insert(v365[v60 + 196], v302, v320 - v154 + v358 + 1, v210);
                            v211 = v320;
                            v52 = a6;
                          }
                          else
                          {
                            v210 = 0;
                          }
                        }
                      }
                      v357 = 0;
                      v220 = v211 + v144 - v154;
                      v221 = v326;
                      if (v220 < v331)
                        v221 = 0;
                      v109 = v323;
                      if (v221 && v220 < v330)
                        goto LABEL_502;
                      v222 = v287;
                      if (v220 < v336)
                        v222 = 0;
                      if (v222 == 1 && v220 < v335)
                      {
LABEL_502:
                        v210 = 0;
                        v220 = *v325 + (*(_DWORD *)(v323 + 32 * v338 + 56) & 0xFFFFF);
                      }
                      if (v220 >= *v313)
                        v136 = 0;
                      else
                        v136 = v210;
                      if (v220 >= *v313)
                        v117 = 0;
                      else
                        v117 = v220;
                      if (v354)
                      {
                        v223 = v117;
                        v224 = v136;
                        obj_release(v354);
                        v136 = v224;
                        v109 = v323;
                        v117 = v223;
                        v52 = a6;
                      }
                      v354 = 0;
                      if ((_DWORD)v321)
                        v225 = v136 == 0;
                      else
                        v225 = 0;
                      v226 = v316;
                      if (!v225)
                        v226 = 0;
                      if (v226 == 1)
                      {
                        if (v311 | v347)
                        {
                          v227 = v117;
                          should_pause = spaceman_free_extent_cache_scan_should_pause(v365[v60 + 196], v321);
                          v136 = 0;
                          if (should_pause)
                          {
                            v32 = 0;
                            v229 = v311;
                            v230 = v292;
                            if (v347 > v311)
                              v230 = v349;
                            v292 = v230;
                            if (v347 > v311)
                              v229 = v347;
                            v298 = 1;
                            v314 = v338;
                            v119 = v229;
                            v52 = a6;
                            v117 = v227;
                            goto LABEL_540;
                          }
                          v52 = a6;
                          v117 = v227;
LABEL_520:
                          v134 = v305;
                        }
                        else
                        {
                          v136 = 0;
                          v311 = 0;
                        }
                      }
                      goto LABEL_347;
                    }
                  }
                  else
                  {
                    if (bitmap_range_find_desired_or_first_clear_range(*(_QWORD *)(v172 + 56), v53, v154, v144, &v358, &v357, v299 != 0))
                    {
                      v136 = 0;
                      v32 = 0;
                      v314 = v338;
                      v52 = a6;
                      v109 = v323;
                      v119 = v311;
                      v117 = v320;
                      goto LABEL_540;
                    }
                    v208 = 0;
                  }
                }
                else
                {
                  v206 = v144 - v154;
                  if (v53 >= v144 - v154)
                    v207 = v144 - v154;
                  else
                    v207 = v53;
                  v357 = v207;
                  v358 = v154;
                  if (v53 <= v144 - v154)
                  {
                    if (!v159)
                    {
                      v136 = 0;
                      v32 = 0;
LABEL_537:
                      v314 = v338;
                      v52 = a6;
LABEL_538:
                      v109 = v323;
LABEL_539:
                      v119 = v311;
                      goto LABEL_540;
                    }
                  }
                  else
                  {
                    v206 = 0;
                  }
                  v209 = v206;
                  spaceman_free_extent_cache_insert(v365[v60 + 196], v302, v117, v207);
                  v208 = v209;
                }
                v52 = a6;
                goto LABEL_469;
              }
            }
            else
            {
              v172 = 0;
              if (!v136)
                goto LABEL_435;
            }
            v173 = v53 - v136;
            if ((uint64_t)(v53 - v136) >= v144)
              v173 = v144;
            if (v159)
              v174 = v144;
            else
              v174 = v173;
            if (!v172
              || (v296 = v154,
                  v175 = v136,
                  first = bitmap_range_find_first(1, *(_QWORD *)(v172 + 56), 0, v174, &v358),
                  v136 = v175,
                  v177 = v296,
                  v117 = v319,
                  !first))
            {
              v185 = v174 + v136;
              if (!v159 && v53 == v185)
              {
                if (v354)
                {
                  v240 = v136;
                  obj_release(v354);
                  v136 = v240;
                  v117 = v319;
                }
                v32 = 0;
                v292 = v117 - v136;
                v354 = 0;
                v314 = v338;
                v119 = v53;
                v52 = a6;
                v109 = v323;
                goto LABEL_572;
              }
              v186 = v117 - v136;
              spaceman_free_extent_cache_insert(v365[v60 + 196], v302, v117 - v136, v174 + v136);
              if (a6 && v185 > (uint64_t)v311)
              {
                if (v159
                  && spaceman_clip_extent_to_zones(v9, (uint64_t)v365, v60, v186, v185, v332, v282, &v348, &v346))
                {
                  v187 = v346;
                  if (v346 >= v53)
                    v187 = v53;
                  v346 = v187;
                  v188 = v311;
                  if (v187 <= v311)
                    v186 = v292;
                  else
                    v186 = v348;
                  if (v187 > v311)
                    v188 = v187;
                  v311 = v188;
                }
                else
                {
                  if (v185 >= v53)
                    v193 = v53;
                  else
                    v193 = v185;
                  v311 = v193;
                }
              }
              else
              {
                v186 = v292;
              }
              v194 = v174 + v319;
              v195 = v326;
              if (v194 < v331)
                v195 = 0;
              if (v195 && v194 < v330)
                goto LABEL_414;
              v196 = v287;
              if (v194 < v336)
                v196 = 0;
              if (v196 == 1 && v194 < v335)
              {
LABEL_414:
                v185 = 0;
                v194 = *v325 + (*(_DWORD *)(v323 + 32 * v338 + 56) & 0xFFFFF);
              }
              v197 = *v313;
              if (v194 < *v313)
                v117 = v194;
              else
                v117 = 0;
              if (v354)
              {
                v198 = v117;
                obj_release(v354);
                v117 = v198;
              }
              v354 = 0;
              if (v194 < v197 && v185)
              {
                v136 = v185;
                v292 = v186;
                v52 = a6;
                v138 = v332;
                v109 = v323;
                goto LABEL_520;
              }
              v136 = 0;
              v52 = a6;
              v138 = v332;
              v134 = v305;
              if (v299 && v311)
              {
                v136 = 0;
                v32 = 0;
                v314 = v338;
                v292 = v186;
                goto LABEL_538;
              }
              v292 = v186;
              v109 = v323;
LABEL_347:
              if (++v338 >= v315)
              {
                v32 = 0;
                v314 = v281;
                goto LABEL_539;
              }
              goto LABEL_259;
            }
            v178 = v358;
            if (!a6)
              goto LABEL_434;
            v179 = v358 + v136;
            if ((uint64_t)(v358 + v136) <= (uint64_t)v311)
              goto LABEL_434;
            if (v159)
            {
              v180 = v319 - v136;
              v181 = v136;
              if ((spaceman_clip_extent_to_zones(v9, (uint64_t)v365, v60, v319 - v136, v179, v332, v282, &v348, &v346) & 1) != 0)
              {
                v182 = v346;
                if (v346 >= v53)
                  v182 = v53;
                v346 = v182;
                v183 = v311;
                v184 = v292;
                if (v182 > v311)
                  v184 = v348;
                v292 = v184;
                if (v182 > v311)
                  v183 = v182;
                v117 = v319;
                v136 = v181;
                v177 = v296;
LABEL_431:
                v311 = v183;
                if (v183 && v299)
                {
                  if (v354)
                  {
                    obj_release(v354);
                    v117 = v319;
                  }
                  v136 = 0;
                  v32 = 0;
                  v354 = 0;
                  goto LABEL_537;
                }
                v178 = v358;
LABEL_434:
                v199 = v117;
                spaceman_free_extent_cache_insert(v365[v60 + 196], v302, v117 - v136, v178 + v136);
                v200 = v199 - v177;
                v154 = v358;
                v117 = v200 + v358;
                v172 = v354;
                goto LABEL_435;
              }
              v179 = v358 + v181;
              v292 = v180;
              v117 = v319;
              v136 = v181;
              v177 = v296;
            }
            else
            {
              v292 = v319 - v136;
            }
            if (v179 >= v53)
              v183 = v53;
            else
              v183 = v179;
            goto LABEL_431;
          }
          if (obj_type((uint64_t)a1) == 13)
            log_err("%s:%d: %s failed to search bitmap hints: %d\n", "spaceman_alloc", 7255, v309, v105);
          else
            log_err("%s:%d: %s failed to search bitmap hints: %d\n", "spaceman_alloc", 7255, (const char *)(a1[48] + 208), v105);
        }
        v106 = 0;
        goto LABEL_203;
      }
      v349 = v79;
      v347 = v53;
      v86 = v56 & 0xFFFFDFFF;
      if ((v328 & 1) != 0)
        v87 = 0x2000;
      else
        v87 = 0;
      v332 = v86 | v87;
      v88 = spaceman_free_extent_cache_search(v83, (unsigned __int16)v86 | (unsigned __int16)v87, &v349, &v347);
      v52 = a6;
    }
    while (v88 == 28);
    v310 = v347;
    v292 = v349;
    if (v347 && !v349)
    {
      v310 = 0;
      v347 = 0;
    }
    if (v291 == (_DWORD)v60)
      v90 = 0;
    else
      v90 = 3;
    if (v88 != 3)
      v90 = v88;
    if (v90 != 3)
    {
      if (!v90 && v310 && v349)
      {
        v248 = (v56 & 0x200) == 0 && v69;
        v316 = 1;
        v275 = 0;
        if (v248)
        {
          if (v349 >= (uint64_t)v335)
          {
            v314 = v338;
            v32 = 0;
          }
          else
          {
            if ((uint64_t)(v310 + v349) < (uint64_t)v336)
            {
              v314 = v338;
              v32 = 0;
            }
            else
            {
              v249 = obj_type((uint64_t)a1);
              v250 = (const char *)(a1 + 485);
              if (v249 != 13)
                v250 = (const char *)(a1[48] + 208);
              log_debug("%s:%d: %s Could not find data to allocate outside the soft block-out range, disable soft block-out range\n", "spaceman_alloc", 7208, v250);
              v275 = 0;
              v32 = 0;
              v316 = 1;
              *(_BYTE *)(v9 + 636) = 1;
              *(_QWORD *)(v9 + 1784) = 0;
              v314 = v338;
            }
            v52 = a6;
          }
        }
        else
        {
          v314 = v338;
          v32 = 0;
        }
        v109 = v322;
        v119 = v310;
        goto LABEL_594;
      }
      v333 = v332 | 0x100;
      LOBYTE(v70) = v337;
      goto LABEL_190;
    }
    v344 = 0u;
    v345 = 0u;
    v343 = 0u;
    *(_QWORD *)&v343 = v365[v60 + 196];
    *((_QWORD *)&v343 + 1) = v53;
    *(_QWORD *)&v344 = v310;
    *((_QWORD *)&v344 + 1) = spaceman_free_extent_cache_search_better_length(v332, v53, v310);
    *(_QWORD *)&v345 = 0;
    *((_QWORD *)&v345 + 1) = v332;
    v91 = v365;
    v92 = &v365[v60];
    v93 = v92 + 102;
    v94 = v92[102];
    if ((v94 & 0x10) != 0)
    {
      v95 = v92[102];
      do
      {
        *v93 = v95 | 0x20;
        cv_wait((pthread_cond_t *)v91 + 16, (pthread_mutex_t *)v91 + 6, 8, (uint64_t)"spaceman_alloc_fxc_scan_wait", 0);
        v91 = v365;
        v93 = &v365[v60 + 102];
        v95 = *v93;
      }
      while ((*v93 & 0x10) != 0);
      *v93 = v95 | 0x10;
      v50 = v312;
      if ((v94 & 0x10) == 0 || *(_QWORD *)(v91[v60 + 196] + 128) < *((_QWORD *)&v344 + 1))
        goto LABEL_169;
      v32 = 0;
    }
    else
    {
      *v93 = v94 | 0x10;
      v50 = v312;
LABEL_169:
      pthread_mutex_unlock((pthread_mutex_t *)v91 + 6);
      if ((_DWORD)v60 == 1)
        v96 = 42;
      else
        v96 = 38;
      LODWORD(v32) = spaceman_iterate_free_extents_internal(v9, v96, 0, (uint64_t (*)(_QWORD *, unint64_t, int64_t))spaceman_alloc_fxc_scan_free_extent_callback, &v343);
      pthread_mutex_lock((pthread_mutex_t *)v365 + 6);
      if ((_DWORD)v32 == 34 || (_DWORD)v32 == 37)
        v98 = 0;
      else
        v98 = v32;
      if ((_DWORD)v32 == HIDWORD(v345))
        v32 = v98;
      else
        v32 = v32;
      v291 = v60;
    }
    v347 = 0;
    v349 = 0;
    v99 = v365;
    v100 = v365[v60 + 102];
    if ((v100 & 0x20) != 0)
    {
      cv_wakeup((pthread_cond_t *)v365 + 16);
      v99 = v365;
      v100 = v365[v60 + 102];
    }
    v52 = a6;
    v99[v60 + 102] = v100 & 0xFFFFFFFFFFFFFFCFLL;
  }
  while (!(_DWORD)v32);
LABEL_654:
  if (v356)
    obj_release(v356);
  if (v355)
    obj_release(v355);
  if (v354)
    obj_release(v354);
  pthread_mutex_unlock((pthread_mutex_t *)v365 + 6);
  v34 = v365;
  if ((_DWORD)v32)
  {
LABEL_661:
    v259 = v34[198];
    if (v259)
      ++*(_QWORD *)(v259 + 72);
    obj_release(v34);
    return v32;
  }
  obj_release(v365);
  if ((v332 & 4) != 0)
    return 0;
  v32 = 0;
  v261 = *(_QWORD *)(v9 + 1760);
  if (!v261 || (v332 & 0x200) != 0)
    return v32;
  v262 = *(_QWORD *)(v9 + 1752);
  if ((uint64_t)*v301 >= v262 && *v301 < v262 + v261)
    return 0;
  if (*(_BYTE *)(v9 + 636))
  {
    if (a6)
      v53 = *a6;
    v263 = *(_QWORD *)(v9 + 1784) + v53;
    *(_QWORD *)(v9 + 1784) = v263;
    if (v263 >= 0x401)
    {
      if (obj_type((uint64_t)a1) != 13)
        v309 = (const char *)(a1[48] + 208);
      log_debug("%s:%d: %s Found enough data to allocate outside the soft block-out range, re-enable soft block-out range\n", "spaceman_alloc", 8085, v309);
      v32 = 0;
      *(_BYTE *)(v9 + 636) = 0;
      return v32;
    }
    return 0;
  }
  if (!a6 || 10000 * *a6 >= v53 || *a6 * *(unsigned int *)(*(_QWORD *)(v9 + 376) + 36) >= 0x40000)
    return 0;
  if (obj_type((uint64_t)a1) != 13)
    v309 = (const char *)(a1[48] + 208);
  log_debug("%s:%d: %s Space outside soft block-out range seems fragmented (requested %llu, but could alloc only %llu), disable soft block-out range\n", "spaceman_alloc", 8092, v309, v53, *a6);
  v32 = 0;
  *(_BYTE *)(v9 + 636) = 1;
  *(_QWORD *)(v9 + 1784) = 0;
  return v32;
}

uint64_t spaceman_alloc_fxc_scan_free_extent_callback(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  result = *(unsigned int *)(a1 + 44);
  if (!(_DWORD)result)
  {
    v5 = *(_QWORD *)(a1 + 32);
    if (!v5)
    {
      *(_QWORD *)(a1 + 32) = a2;
      v5 = a2;
    }
    if (*(_QWORD *)(a1 + 24) <= a3)
    {
      result = 37;
    }
    else
    {
      v6 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8) + 376) + 36);
      result = spaceman_free_extent_cache_scan_should_pause(*(_QWORD *)a1, (a2 - v5 / v6 * v6) / v6);
      if (!(_DWORD)result)
        return result;
      result = 34;
    }
    *(_DWORD *)(a1 + 44) = result;
  }
  return result;
}

double spaceman_search_bitmap_hints_for_space(unint64_t a1, unsigned int a2, uint64_t a3, _OWORD *a4)
{
  char v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v13;
  uint64_t v14;
  __int128 v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  BOOL v28;
  int v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  int v37;
  unint64_t v38;
  uint64_t v39;
  BOOL v40;
  int v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  _OWORD *v50;
  int v52;
  uint64_t v53;
  uint64_t v56;
  uint64_t v57;
  int v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  _OWORD v62[4];

  v6 = 0;
  v7 = *(_OWORD *)(a3 + 16);
  v8 = *(_OWORD *)(a3 + 32);
  v62[0] = *(_OWORD *)a3;
  v62[1] = v7;
  v9 = *(_QWORD *)(a1 + 376);
  v58 = *(unsigned __int8 *)(a3 + 16);
  v52 = *(unsigned __int8 *)(a3 + 40);
  v10 = *(_QWORD *)a3 / (uint64_t)*(unsigned int *)(v9 + 36);
  v11 = v10;
  v62[2] = v8;
  v13 = (_QWORD *)(a1 + 8 * a2 + 1488);
  v14 = *v13 + 4 * v10;
  v56 = *(_QWORD *)(a3 + 8);
  *(_QWORD *)&v15 = 0;
  a4[1] = 0u;
  a4[2] = 0u;
  *a4 = 0u;
  v57 = v9;
  v16 = (_QWORD *)(v9 + 48 * a2 + 56);
  v53 = v14;
  do
  {
    if (!v58)
    {
      v29 = 1;
      v30 = v56;
      v14 = v53;
      v31 = v10;
      goto LABEL_24;
    }
    v17 = *(_QWORD *)(a1 + 376);
    if ((*(_BYTE *)(v14 + 3) & 0xC) == 0)
    {
      v18 = v17 + 48 * a2;
      v19 = *(_QWORD *)(v18 + 56);
      if (v19 <= v11)
        goto LABEL_19;
      v20 = *(_QWORD *)(a3 + 32);
      if (!v20)
        goto LABEL_19;
      v21 = *(unsigned int *)(v17 + 36);
      v22 = v21;
      if (v19 - 1 == v11)
        v22 = *(_QWORD *)(v18 + 48) % v21;
      if (!calc_overlap_range(v11 * v21, v22, *(_QWORD *)(a3 + 24), v20, 0))
      {
LABEL_19:
        if (v11 == v10)
        {
          v29 = 1;
        }
        else
        {
          v29 = 0;
          *(_QWORD *)&v62[0] = v11 * *(unsigned int *)(v57 + 36);
        }
        v31 = v11;
        v30 = v56;
        goto LABEL_24;
      }
      v17 = *(_QWORD *)(a1 + 376);
    }
    v23 = v17 + 48 * a2;
    v24 = *(_QWORD *)(v23 + 56);
    if (v24 > v11 && (v25 = *(_QWORD *)(a3 + 32)) != 0)
    {
      v26 = *(unsigned int *)(v17 + 36);
      v27 = v26;
      if (v24 - 1 == v11)
        v27 = *(_QWORD *)(v23 + 48) % v26;
      v28 = calc_overlap_range(v11 * v26, v27, *(_QWORD *)(a3 + 24), v25, 0) != 0;
    }
    else
    {
      v28 = 0;
    }
    v6 |= v28;
    v11 = (v11 + 1) % *v16;
    v14 = *v13 + 4 * v11;
  }
  while (v11 != v10);
  if ((v6 & 1) == 0)
    return *(double *)&v15;
  v29 = 1;
  v30 = v56;
  v31 = v10;
LABEL_24:
  if (v30 < 2)
    goto LABEL_55;
  LODWORD(v32) = *(_DWORD *)v14 & 0xFFFFFF;
  if (v30 <= (unint64_t)v32)
    goto LABEL_55;
  if ((*(_DWORD *)v14 & 0x2000000) != 0 && v31 < *v16 - 1)
  {
    v33 = *(_DWORD *)(*v13 + 4 * v31 + 4);
    if ((v33 & 0x1000000) != 0 && (!v58 || (v33 & 0xC000000) == 0))
    {
      v42 = v33 & 0xFFFFFF;
      v37 = v52;
      if (v52)
      {
        v36 = (uint64_t)a4;
        v34 = v57;
        if (v30 <= (unint64_t)(v42 + v32))
          goto LABEL_56;
        v35 = *(_DWORD *)(v57 + 36);
        goto LABEL_32;
      }
      if (v32 <= v42)
        v32 = v42;
      else
        v32 = v32;
      if (v30 >= v32)
        v30 = v32;
LABEL_55:
      v36 = (uint64_t)a4;
      v34 = v57;
      goto LABEL_56;
    }
  }
  v34 = v57;
  v35 = *(_DWORD *)(v57 + 36);
  v36 = (uint64_t)a4;
  v37 = v52;
  if (!v52)
  {
LABEL_36:
    *(_QWORD *)&v62[0] = v31 * v35;
    spaceman_iterate_bitmap_hints(a1, a2, 0, (uint64_t)v62, v36);
    v39 = *(_QWORD *)(v36 + 8);
    if (v37)
      v40 = v39 < v30;
    else
      v40 = 0;
    v41 = v40;
    if (!v39 || v41)
    {
      v15 = *(_OWORD *)(v36 + 24);
      *(_OWORD *)v36 = v15;
      *(_QWORD *)(v36 + 16) = *(_QWORD *)(v36 + 40);
      *(_QWORD *)(v36 + 24) = 0;
      *(_QWORD *)(v36 + 32) = 0;
      *(_QWORD *)(v36 + 40) = 0;
    }
    return *(double *)&v15;
  }
LABEL_32:
  if (v35 >= 0xFFFFFF)
    v38 = 0xFFFFFFLL;
  else
    v38 = v35;
  if (v30 <= v38)
    goto LABEL_36;
LABEL_56:
  v43 = *(_QWORD *)&v62[0];
  *(_QWORD *)v36 = *(_QWORD *)&v62[0];
  *(_QWORD *)(v36 + 8) = v30;
  *(_BYTE *)(v36 + 16) = v58;
  if (v29)
  {
    v44 = *(_QWORD *)(a1 + 376);
    v45 = v44 + 48 * a2;
    v46 = *(_QWORD *)(v45 + 56);
    if (v46 > v10)
    {
      v47 = *(_QWORD *)(a3 + 32);
      if (v47)
      {
        v48 = *(unsigned int *)(v44 + 36);
        v49 = v10 * v48;
        if (v46 - 1 == v10)
          v48 = *(_QWORD *)(v45 + 48) % v48;
        if (calc_overlap_range(v49, v48, *(_QWORD *)(a3 + 24), v47, 0))
          *(_BYTE *)(v36 + 16) = 0;
      }
    }
  }
  if (v43 % *(unsigned int *)(v34 + 36))
  {
    v60 = 0u;
    v61 = 0u;
    v59 = 0u;
    spaceman_iterate_bitmap_hints(a1, a2, 3uLL, (uint64_t)v62, (uint64_t)&v59);
    v50 = (_OWORD *)(v36 + 24);
    if (*((uint64_t *)&v59 + 1) >= v30)
    {
      *(_QWORD *)&v15 = v59;
      *v50 = v59;
      *(_QWORD *)(v36 + 40) = v60;
    }
    else
    {
      v15 = *(_OWORD *)v36;
      *v50 = *(_OWORD *)v36;
      *(_QWORD *)(v36 + 40) = *(_QWORD *)(v36 + 16);
      *(_QWORD *)(v36 + 24) = v43 / *(unsigned int *)(v34 + 36) * *(unsigned int *)(v34 + 36);
    }
  }
  return *(double *)&v15;
}

uint64_t spaceman_modify_bits(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, char a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  pthread_mutex_t *v16;
  unsigned int *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t v20;
  unsigned int v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t *v39;
  unint64_t v40;
  uint64_t v41;
  _DWORD *v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  int64_t v46;
  unint64_t v47;
  unint64_t v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  int64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  _BOOL8 v68;
  uint64_t v69;
  unint64_t v70;
  BOOL v71;
  unint64_t v72;
  int v73;
  char v74;
  uint64_t v75;
  _QWORD *v76;
  unint64_t v77;
  const char *v78;
  _QWORD *v79;
  unint64_t v80;
  unint64_t v81;
  int v82;
  const char *v83;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  uint64_t v88;
  _QWORD *v89;
  uint64_t v90;
  unint64_t v91;
  char v92;
  uint64_t v93;
  int v94;
  char v95;
  uint64_t v96;
  char v97;
  uint64_t v98;
  uint64_t v99;
  const char *v101;
  uint64_t v102;
  const char *v103;
  uint64_t v104;
  uint64_t *v105;
  pthread_mutex_t *v106;
  uint64_t v107;
  uint64_t v108;
  char v109;
  unsigned int v110;
  unint64_t v111;
  unsigned int *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unsigned int v119;
  unint64_t v120;
  pthread_mutex_t *v121;
  uint64_t v122;
  unsigned int v123;
  unint64_t v124;
  uint64_t v126;
  uint64_t v128;
  uint64_t v130;
  uint64_t v131;
  unsigned int *v132;
  unint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  unint64_t v137;

  v9 = a4;
  v10 = a3;
  v11 = (uint64_t)a1;
  v107 = 0;
  v111 = 0;
  v109 = 0;
  v12 = *(unsigned int **)(a3 + 376);
  v135 = 0;
  v136 = 0;
  v133 = 0;
  v134 = 0;
  v13 = __clz(__rbit64(*(unsigned int *)(a1[47] + 36)));
  v131 = 0;
  v132 = 0;
  v14 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v13) & a4;
  v15 = ((unint64_t)(a4 << v13) >> 62) & 1;
  v16 = (pthread_mutex_t *)(a3 + (v15 << 6) + 640);
  v17 = &v12[12 * v15 + 17];
  v108 = v15;
  v105 = (uint64_t *)(a3 + 8 * v15 + 888);
  v106 = v16;
  v121 = (pthread_mutex_t *)(a3 + 576);
  if (a2)
    v18 = a2;
  else
    v18 = a1;
  v102 = (uint64_t)v18;
  v101 = (const char *)(v18 + 485);
  v103 = (const char *)(a2 + 485);
  v110 = -1;
  v115 = v12;
  v104 = (uint64_t)&v12[12 * v15 + 17];
  while (1)
  {
    v128 = v9;
    pthread_mutex_lock(v16);
    v19 = v14 / v12[9];
    v20 = v19 / v12[10];
    v130 = v14;
    v123 = *v17;
    if (*v17)
    {
      v21 = v20 / v12[11];
      if (v21 != v110 || v107 == 0)
      {
        v111 = *(_QWORD *)(*v105 + 8 * v21);
        if (v136)
        {
          obj_release(v136);
          v136 = 0;
        }
        v132 = v12;
        v133 = __PAIR64__(v21, v108);
        v23 = obj_get(*(_QWORD *)(v11 + 392), 1073741829, v111, &sm_cab_desc, &v132, 0, 0, a6, &v136);
        if ((_DWORD)v23)
        {
          v96 = v23;
          log_err("%s:%d: %s error getting cab %d @ %lld: %d\n", "spaceman_modify_bits", 5492, (const char *)(*(_QWORD *)(v11 + 384) + 208), v21, v111, v23);
          v95 = 0;
          goto LABEL_127;
        }
        v107 = *(_QWORD *)(v136 + 56);
        v110 = v21;
      }
      else
      {
        obj_lock(v136, 2);
      }
      pthread_mutex_unlock(v16);
      if (obj_xid(v136) == a6)
      {
        v25 = v111;
        v26 = v110;
      }
      else
      {
        v27 = spaceman_ip_block_alloc(v11, v10, a6, (unint64_t *)&v131);
        if ((_DWORD)v27)
        {
          v96 = v27;
          if (nx_ratelimit_log_allowed(v11))
            log_err("%s:%d: %s failed to allocate block from internal pool: %d\n", "spaceman_modify_bits", 5511, (const char *)(*(_QWORD *)(v11 + 384) + 208), v96);
          v95 = 0;
          v109 = 1;
          goto LABEL_128;
        }
        v25 = v131;
        v26 = v110;
        *(_QWORD *)(*v105 + 8 * v110) = v131;
        obj_dirty(v136, a6, v25);
        v28 = spaceman_ip_block_free(v11, (pthread_mutex_t *)v10, v111, a6);
        if ((_DWORD)v28)
        {
          v96 = v28;
          log_err("%s:%d: %s failed to free internal pool block %lld: %d\n", "spaceman_modify_bits", 5518, (const char *)(*(_QWORD *)(v11 + 384) + 208), v111, v28);
          v95 = 0;
          v109 = 1;
          goto LABEL_128;
        }
      }
      v24 = v107 + 40;
      v29 = v12[10];
      LODWORD(v20) = v20 - v12[11] * v26;
      v132 = v12;
      LODWORD(v133) = v108;
      HIDWORD(v133) = v19 / v29;
      v109 = 1;
      v111 = v25;
    }
    else
    {
      v24 = *v105;
      v132 = v12;
      v133 = __PAIR64__(v20, v108);
      if (!v24)
      {
        v95 = 0;
        v96 = 22;
        v16 = v106;
        goto LABEL_127;
      }
    }
    v30 = *(_QWORD *)(v24 + 8 * v20);
    v31 = obj_get(*(_QWORD *)(v11 + 392), 1073741829, v30, &sm_cib_desc, &v132, 0, 0, a6, &v135);
    if ((_DWORD)v31)
    {
      v96 = v31;
      if (v110 == -1)
        v94 = 0;
      else
        v94 = v12[11] * v110;
      v16 = v106;
      log_err("%s:%d: %s error getting cib %d @ %lld: %d\n", "spaceman_modify_bits", 5544, (const char *)(*(_QWORD *)(v11 + 384) + 208), v94 + v20, v30, v31);
      v95 = 0;
      goto LABEL_124;
    }
    v126 = *(_QWORD *)(v135 + 56);
    if (obj_xid(v135) == a6)
    {
      v116 = v30;
      v16 = v106;
      v32 = v126;
      goto LABEL_29;
    }
    v33 = spaceman_ip_block_alloc(v11, v10, a6, (unint64_t *)&v131);
    if ((_DWORD)v33)
      break;
    *(_QWORD *)(v24 + 8 * v20) = v131;
    if (v136)
      obj_dirty(v136, a6, v111);
    v116 = v131;
    obj_dirty(v135, a6, v131);
    v34 = spaceman_ip_block_free(v11, (pthread_mutex_t *)v10, v30, a6);
    v16 = v106;
    v32 = v126;
    if ((_DWORD)v34)
    {
      v96 = v34;
      log_err("%s:%d: %s failed to free internal pool block %lld: %d\n", "spaceman_modify_bits", 5564, (const char *)(*(_QWORD *)(v11 + 384) + 208), v30, v34);
      v95 = 1;
      goto LABEL_124;
    }
LABEL_29:
    if (!v123)
      pthread_mutex_unlock(v16);
    v35 = a6;
    if (v136)
    {
      obj_unlock(v136, 2);
      v109 = 0;
    }
    v36 = v19 % v12[10];
    v37 = v32 + 32 * v36;
    v40 = *(_QWORD *)(v37 + 64);
    v39 = (uint64_t *)(v37 + 64);
    v38 = v40;
    if (a7 == 1)
    {
LABEL_34:
      if (v38)
        goto LABEL_35;
      if (((*(_DWORD *)(v32 + 32 * v36 + 56) ^ *(_DWORD *)(v32 + 32 * v36 + 60)) & 0xFFFFF) != 0)
        v96 = nx_corruption_detected_int(v11);
      else
        v96 = 22;
      v95 = 1;
      goto LABEL_128;
    }
    while (1)
    {
LABEL_35:
      if (v38)
      {
        v41 = obj_get(*(_QWORD *)(v11 + 392), 1073741825, v38, &sm_bm_desc, 0, 0, 0, v35, &v134);
        if ((_DWORD)v41)
        {
          v96 = v41;
          log_err("%s:%d: %s error getting cib %d bitmap %d @ %lld: %d\n");
LABEL_117:
          v95 = 1;
          goto LABEL_128;
        }
        v42 = *(_DWORD **)(v134 + 56);
      }
      else
      {
        v42 = 0;
      }
      v43 = (uint64_t *)(v32 + 32 * v36 + 40);
      v44 = v12[9];
      v45 = v130 % v44;
      v46 = v44 - v130 % v44;
      if (a5 >= v46)
        v47 = v46;
      else
        v47 = a5;
      if (v38 && *v43 == v35)
      {
        v48 = v38;
        v49 = a1;
      }
      else
      {
        v50 = spaceman_ip_block_alloc((uint64_t)a1, v10, v35, (unint64_t *)&v131);
        if ((_DWORD)v50)
        {
          v93 = v50;
          log_err("%s:%d: %s failed to allocate block from internal pool: %d\n");
          goto LABEL_115;
        }
        *v43 = v35;
        v48 = v131;
        *v39 = v131;
        if (v38)
        {
          obj_dirty(v134, v35, v48);
          v49 = a1;
          v51 = spaceman_ip_block_free((uint64_t)a1, (pthread_mutex_t *)v10, v38, v35);
          if ((_DWORD)v51)
          {
            v93 = v51;
            log_err("%s:%d: %s failed to free internal pool block %lld: %d\n");
LABEL_115:
            v95 = 1;
            v96 = v93;
            goto LABEL_128;
          }
        }
        else
        {
          v49 = a1;
          v52 = obj_create(a1[49], 0x40000000, v48, (int)&sm_bm_desc, 0, 0, v35, (uint64_t)&v134);
          if ((_DWORD)v52)
          {
            v96 = v52;
            log_err("%s:%d: %s failed to create bitmap object %lld: %d\n");
            goto LABEL_117;
          }
          v42 = *(_DWORD **)(v134 + 56);
        }
      }
      v122 = v48;
      v124 = v47;
      v53 = *(_QWORD *)(v10 + 376);
      v54 = __clz(__rbit64(*(unsigned int *)(v49[47] + 36)));
      v55 = (0x4000000000000000uLL >> v54) & v128;
      if (a7 == 1)
      {
        v117 = *(_QWORD *)(v10 + 376);
        v119 = v55 != 0;
        v56 = bitmap_count_bits((uint64_t)v42, 0, v45, v47 + v45);
        v57 = v56;
        if (v56)
          log_err("%s:%d: %s freeing 0x%llx:%lld, but %lld bits are already clear.  Double free?\n", "spaceman_clear_bits_in_bm", 5290, (const char *)(a1[48] + 208), v128, a5, v56);
        v58 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v54) & v128;
        v59 = a1[47];
        v60 = *(_QWORD *)(v59 + 1248);
        if (!v60
          || (v61 = *(_QWORD *)(v59 + 1240),
              v62 = __clz(__rbit64(*(unsigned int *)(v59 + 36))),
              (v55 != 0) == (((v61 << v62) & 0x4000000000000000) == 0)))
        {
          v63 = a5;
          v65 = 0;
          v66 = v57;
        }
        else
        {
          v63 = a5;
          v137 = 0;
          v64 = calc_overlap_range(v58, v47, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v62) & v61, v60, &v137);
          v65 = v64;
          if (v64)
            v64 = bitmap_count_bits((uint64_t)v42, 0, v137 - *(_QWORD *)(v126 + 32 * v36 + 48), v137 + v64 - *(_QWORD *)(v126 + 32 * v36 + 48));
          v66 = v57 - v64;
        }
        v68 = v55 != 0;
        bitmap_clear_range((uint64_t)v42, v45, v47);
        update_bm_hint(a3, v119, v42, v58 / *(unsigned int *)(v117 + 36));
        v120 = v36;
        *(_DWORD *)(v126 + 32 * v36 + 60) += v47 - v57;
        pthread_mutex_lock(v121);
        *(_QWORD *)(v117 + 48 * v68 + 72) += v47 - v66 - v65;
        a5 = v63;
        v10 = a3;
        v12 = v115;
        if ((a8 & 1) != 0)
        {
          v69 = a3 + 8 * v68;
          v70 = *(_QWORD *)(v69 + 976);
          v71 = v70 >= v47;
          v72 = v70 - v47;
          if (!v71)
            v72 = 0;
          *(_QWORD *)(v69 + 976) = v72;
        }
        goto LABEL_98;
      }
      v67 = v126 + 32 * v36;
      if ((*(_DWORD *)(v67 + 56) & 0xFFFFF) - v45 < (uint64_t)v47)
        v47 = (*(_DWORD *)(v67 + 56) & 0xFFFFF) - v45;
      if (bitmap_range_is_clear((uint64_t)v42, v45, v47))
      {
        bitmap_set_range((uint64_t)v42, v45, v47);
        v120 = v36;
        update_bm_hint(v10, v55 != 0, v42, v36 + *(unsigned int *)(v53 + 40) * (unint64_t)*(unsigned int *)(v126 + 32));
        pthread_mutex_lock(v121);
        *(_DWORD *)(v67 + 60) -= v47;
        v118 = v53;
        *(_QWORD *)(v53 + 48 * (v55 != 0) + 72) -= v47;
        if ((a8 & 1) != 0)
        {
          v75 = v10 + 8 * (v55 != 0);
          v76 = (_QWORD *)(v75 + 848);
          v77 = *(_QWORD *)(v75 + 848);
          if (*(_QWORD *)(v75 + 832) < v77)
          {
            v78 = "Main";
            if (v55)
              v78 = "T2";
            panic("%s, Reserved space < reserved metadata: %llu < %llu\n", v78, *(_QWORD *)(v10 + 832), *(_QWORD *)(v10 + 848));
          }
          v79 = (_QWORD *)(v75 + 832);
          v12 = v115;
          if ((a8 & 0x40) != 0)
          {
            if (v77 < v47)
              panic("reserved metadata space underflow: %lld (%lld)\n", v77, v47);
            *v76 = v77 - v47;
            *v79 -= v47;
          }
          else
          {
            if (*v79 - v77 >= v47)
            {
              v77 = *v79 - v47;
            }
            else if (obj_type(v102) == 13)
            {
              log_err("%s:%d: %s reserved space underflow: %lld (+meta:%llu) < %lld\n", "spaceman_set_bits_in_bm", 5403, v101, *v79 - v77, v77, v47);
            }
            else
            {
              log_err("%s:%d: %s reserved space underflow: %lld (+meta:%llu) < %lld\n", "spaceman_set_bits_in_bm", 5403, (const char *)(*(_QWORD *)(v102 + 384) + 208), *v79 - v77, v77, v47);
            }
            *v79 = v77;
          }
          if (!a2)
            goto LABEL_98;
          v80 = a2[51];
          v71 = v80 >= v47;
          v81 = v80 - v47;
          if (!v71)
          {
            v82 = obj_type((uint64_t)a2);
            v83 = v103;
            if (v82 != 13)
              v83 = (const char *)(a2[48] + 208);
            log_err("%s:%d: %s fs reserved space underflow: %lld (%lld)\n", "spaceman_set_bits_in_bm", 5415, v83, a2[51], v47);
            v81 = 0;
          }
          a2[51] = v81;
        }
        else
        {
          v12 = v115;
          if (!a2)
            goto LABEL_98;
        }
        v84 = a2[47];
        v85 = *(_QWORD *)(v84 + 88);
        *(_QWORD *)(v84 + 88) = v85 + v47;
        v86 = *(_QWORD *)(v84 + 72);
        if (v85 + v47 <= v86)
        {
          v89 = (_QWORD *)(v118 + 192);
          v87 = *(_QWORD *)(v118 + 192);
          v88 = a6;
        }
        else
        {
          v71 = v86 >= v85;
          v87 = v86 - v85;
          v88 = a6;
          if (v87 == 0 || !v71)
            goto LABEL_97;
          v89 = (_QWORD *)(v118 + 192);
          v47 = *(_QWORD *)(v118 + 192);
        }
        *v89 = v87 + v47;
LABEL_97:
        fs_sb_dirty((uint64_t)a2, v88);
LABEL_98:
        pthread_mutex_unlock(v121);
        v74 = 0;
        v96 = 0;
        v73 = 1;
        v11 = (uint64_t)a1;
        v36 = v120;
        goto LABEL_99;
      }
      v73 = 0;
      v96 = 22;
      v74 = 1;
      v11 = (uint64_t)a1;
      v12 = v115;
LABEL_99:
      obj_dirty(v10, a6, 0);
      obj_dirty(v135, a6, v116);
      obj_dirty(v134, a6, v122);
      obj_release(v134);
      v134 = 0;
      v9 = v124 + v128;
      v130 += v124;
      a5 -= v124;
      v32 = v126;
      if (!v73 || a5 < 1 || v36 >= (*(_DWORD *)(v126 + 36) - 1))
        break;
      v128 += v124;
      ++v36;
      v90 = v126 + 32 * v36;
      v91 = *(_QWORD *)(v90 + 64);
      v39 = (uint64_t *)(v90 + 64);
      v38 = v91;
      v35 = a6;
      if (a7 == 1)
        goto LABEL_34;
    }
    obj_unlock(v135, 2);
    obj_release(v135);
    v135 = 0;
    if (a5 < 1)
      v92 = 1;
    else
      v92 = v74;
    v16 = v106;
    v14 = v130;
    v17 = (unsigned int *)v104;
    if ((v92 & 1) != 0)
    {
      v95 = 0;
      goto LABEL_128;
    }
  }
  v96 = v33;
  log_err("%s:%d: %s failed to allocate block from internal pool: %d\n", "spaceman_modify_bits", 5554, (const char *)(*(_QWORD *)(v11 + 384) + 208), v33);
  v95 = 1;
  v16 = v106;
LABEL_124:
  if (!v123)
LABEL_127:
    pthread_mutex_unlock(v16);
LABEL_128:
  if (v136 && (v109 & 1) != 0)
    obj_unlock(v136, 2);
  v97 = v95 ^ 1;
  if (!v135)
    v97 = 1;
  if ((v97 & 1) == 0)
    obj_unlock(v135, 2);
  if (v136)
    obj_release(v136);
  if (v135)
    obj_release(v135);
  if (v134)
    obj_release(v134);
  if (a7 == 1)
  {
    if ((_DWORD)v96)
    {
      if (a5)
      {
        v98 = a3 + 8 * v108;
        v99 = *(_QWORD *)(v98 + 976);
        if (v99)
          *(_QWORD *)(v98 + 976) = v99 - a5;
      }
    }
  }
  return v96;
}

uint64_t spaceman_free(const char *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BOOL4 is_current_tx;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  const char *v19;
  int is_allocated_in_stable_state;
  uint64_t v22;
  pthread_mutex_t *v23;
  _BOOL4 v24;
  uint64_t v25;

  v24 = 0;
  if (obj_type((uint64_t)a1) == 13)
  {
    v9 = *((_QWORD *)a1 + 49);
    v10 = (uint64_t)a1;
  }
  else
  {
    v10 = 0;
    v9 = (uint64_t)a1;
  }
  if (((a3 << __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(v9 + 376) + 36)))) & 0x4000000000000000) != 0)
    v11 = 2;
  else
    v11 = 1;
  is_current_tx = xid_is_current_tx(v9, a5);
  v13 = 22;
  if (a4 >= 1 && is_current_tx)
  {
    v25 = 0;
    v13 = spaceman_get(v9, &v25);
    if (!(_DWORD)v13)
    {
      v14 = v25;
      v15 = *(_QWORD *)(v25 + 1584);
      if (v15)
      {
        v16 = *(_QWORD *)(v15 + 104) + a4;
        ++*(_QWORD *)(v15 + 96);
        *(_QWORD *)(v15 + 104) = v16;
      }
      v17 = spaceman_extent_check((_QWORD *)v9, v14, a3, a4);
      if (v17)
      {
        v18 = v17;
        if (nx_ratelimit_log_allowed(*(_QWORD *)(*(_QWORD *)a1 + 392)))
        {
          if (obj_type((uint64_t)a1) == 13)
            v19 = a1 + 3880;
          else
            v19 = (const char *)(*((_QWORD *)a1 + 48) + 208);
          log_err("%s:%d: %s attempt to free extent (0x%llx:0x%llx) which should not be freed: %d\n", "spaceman_free", 8194, v19, a3, a4, v18);
        }
        v13 = 22;
        goto LABEL_23;
      }
      v13 = obj_modify(v25, 0, a5);
      if (!(_DWORD)v13)
      {
        if (*(_BYTE *)(v9 + 629))
        {
          is_allocated_in_stable_state = spaceman_is_allocated_in_stable_state((_QWORD *)v9, a3, a4, &v24);
          if (is_allocated_in_stable_state | v24)
          {
            v13 = 0;
            goto LABEL_23;
          }
          pthread_mutex_lock((pthread_mutex_t *)(v25 + 384));
          v13 = spaceman_freed((_QWORD *)v9, v25, a3, a4, a5);
          dev_unmap_flush(*(_QWORD *)(v9 + 384));
          if (v10 && !(_DWORD)v13)
          {
            spaceman_free_fs_deduct_block_counts(v10, v25, a4, a5);
            obj_dirty(v25, a5, 0);
          }
          v23 = (pthread_mutex_t *)(v25 + 384);
        }
        else
        {
          pthread_mutex_lock((pthread_mutex_t *)(v25 + 512));
          v22 = spaceman_fq_tree_insert(v9, v25, v11, a3, a4, a5);
          v13 = v22;
          if (v10 && !(_DWORD)v22)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v25 + 384));
            spaceman_free_fs_deduct_block_counts(v10, v25, a4, a5);
            obj_dirty(v25, a5, 0);
            pthread_mutex_unlock((pthread_mutex_t *)(v25 + 384));
          }
          v23 = (pthread_mutex_t *)(v25 + 512);
        }
        pthread_mutex_unlock(v23);
      }
LABEL_23:
      obj_release(v25);
    }
  }
  return v13;
}

uint64_t spaceman_is_allocated_in_stable_state(_QWORD *a1, unint64_t a2, uint64_t a3, _BOOL4 *a4)
{
  pthread_mutex_t *v8;
  uint64_t v9;

  v8 = (pthread_mutex_t *)a1[52];
  pthread_mutex_lock(v8 + 8);
  pthread_mutex_lock(v8 + 6);
  v9 = spaceman_check_allocation_status_internal(a1, (uint64_t)v8, 1, a2, a3, a4, 0);
  pthread_mutex_unlock(v8 + 6);
  pthread_mutex_unlock(v8 + 8);
  return v9;
}

uint64_t spaceman_freed(_QWORD *a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  int v10;
  int v11;

  if (!xid_is_current_tx((uint64_t)a1, a5))
    return 22;
  v10 = spaceman_extent_check(a1, a2, a3, a4);
  if (v10)
  {
    v11 = v10;
    if (nx_ratelimit_log_allowed((uint64_t)a1))
      log_err("%s:%d: %s attempt to free extent (0x%llx:0x%llx) which should not be free: %d\n", "spaceman_freed", 5744, (const char *)(a1[48] + 208), a3, a4, v11);
    return 22;
  }
  dev_unmap(a1[48], a3);
  return spaceman_freed_internal(a1, a2, a3, a4, 0, a5);
}

void spaceman_free_fs_deduct_block_counts(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7;
  pthread_mutex_t *v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;

  v7 = *(_QWORD *)(a2 + 376);
  v8 = (pthread_mutex_t *)(a2 + 576);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 576));
  v9 = *(_QWORD *)(a1 + 376);
  v10 = *(_QWORD *)(v9 + 88);
  v11 = v10 >= a3;
  v12 = v10 - a3;
  if (v11)
  {
    *(_QWORD *)(v9 + 88) = v12;
  }
  else
  {
    v13 = obj_oid(a1);
    log_err("%s:%d: %s fs %lld alloc count underflow: %lld (%lld)\n", "spaceman_free_fs_deduct_block_counts", 8118, (const char *)(a1 + 3880), v13, *(_QWORD *)(*(_QWORD *)(a1 + 376) + 88), a3);
    v12 = 0;
    v9 = *(_QWORD *)(a1 + 376);
    *(_QWORD *)(v9 + 88) = 0;
  }
  v14 = *(_QWORD *)(v9 + 72);
  if (v14)
  {
    v15 = v12 + a3;
    v11 = v14 >= v12;
    v16 = v14 - v12;
    if (!v11)
      v16 = 0;
    if (v15 <= v14)
      v16 = a3;
    v17 = *(_QWORD *)(v7 + 192);
    v18 = v17 - v16;
    if (v17 < v16)
    {
      log_err("%s:%d: %s spaceman fs reserve alloc count underflow: %lld (%lld)\n", "spaceman_free_fs_deduct_block_counts", 8133, (const char *)(a1 + 3880), *(_QWORD *)(v7 + 192), v16);
      v18 = 0;
    }
    *(_QWORD *)(v7 + 192) = v18;
  }
  pthread_mutex_unlock(v8);
  fs_sb_dirty(a1, a4);
}

uint64_t spaceman_fq_tree_insert(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  _OWORD v28[4];
  int v29;
  unsigned int v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  __int128 v34;
  _QWORD v35[2];
  uint64_t v36;

  v12 = *(_QWORD *)(a2 + 376);
  v36 = 0;
  v35[0] = 0;
  v32 = 0uLL;
  v33 = 0;
  *((_QWORD *)&v31 + 1) = 0;
  v13 = spaceman_fq_tree_get(a1, a2, a3, a6, 1, &v36);
  if (!(_DWORD)v13)
  {
    *(_QWORD *)&v31 = 0;
    *(_QWORD *)&v34 = a6;
    *((_QWORD *)&v34 + 1) = a4;
    v29 = 8;
    v30 = 16;
    v14 = bt_lookup_variant(v36, 0, (unint64_t *)&v34, &v30, 0x10u, v35, (unsigned int *)&v29, 1u, 0, 0);
    if ((_DWORD)v14 == 2)
      goto LABEL_13;
    v13 = v14;
    if ((_DWORD)v14)
      goto LABEL_43;
    if ((_QWORD)v34 != a6)
      goto LABEL_13;
    if (v29)
    {
      v15 = v35[0];
    }
    else
    {
      v15 = 1;
      v35[0] = 1;
    }
    if (v15 + *((_QWORD *)&v34 + 1) <= a4)
    {
      if (v15 + *((_QWORD *)&v34 + 1) != a4)
        goto LABEL_13;
    }
    else
    {
      log_err("%s:%d: %s range 0x%llx:%lld overlaps with recently-freed range 0x%llx:%lld\n", "spaceman_fq_tree_insert", 4542, (const char *)(*(_QWORD *)(a1 + 384) + 208), a4, a5, *((_QWORD *)&v34 + 1), v15);
      v15 = v35[0];
      a5 += a4 - (v35[0] + *((_QWORD *)&v34 + 1));
      if (a5 < 1)
      {
        v13 = 22;
        goto LABEL_43;
      }
      a4 = v35[0] + *((_QWORD *)&v34 + 1);
    }
    v32 = v34;
    v16 = v15 + a5;
    v33 = v15 + a5;
    if ((_QWORD)v34)
    {
LABEL_14:
      v34 = v32;
      v29 = 8;
      v30 = 16;
      v17 = bt_lookup_variant(v36, 0, (unint64_t *)&v34, &v30, 0x10u, v35, (unsigned int *)&v29, 4u, 0, 0);
      if ((_DWORD)v17 == 2)
      {
LABEL_31:
        v29 = 8 * (v16 != 1);
        v13 = bt_insert(v36, 0, &v32, 16, &v33, v29, a6);
        if (!(_DWORD)v13)
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 576));
          v22 = v12 + 40 * a3;
          v25 = *(_QWORD *)(v22 + 200);
          v23 = (_QWORD *)(v22 + 200);
          v24 = v25;
          if (!v25)
            *(_QWORD *)(v12 + 40 * a3 + 216) = a6;
          *v23 = v24 + a5;
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 576));
          obj_dirty(a2, a6, 0);
          if ((_QWORD)v31)
          {
            v26 = bt_remove(v36, 0, (unint64_t *)&v31, 0x10u, a6);
            if (v26)
              log_err("%s:%d: %s removal of replaced free extent failed: %d\n", "spaceman_fq_tree_insert", 4619, (const char *)(*(_QWORD *)(a1 + 384) + 208), v26);
          }
          if (spaceman_fq_tree_over_threshold(a2, a3, v36, 0))
          {
            memset(v28, 0, sizeof(v28));
            trim_time_tracking_start(a1, (uint64_t)v28, 0, 0);
            while (spaceman_fq_tree_over_threshold(a2, a3, v36, 1)
                 && spaceman_free_completed(a1, a2, a3, 1, v28, a6))
              ;
            trim_time_tracking_end(a1, (uint64_t)v28);
          }
          v13 = 0;
        }
        goto LABEL_43;
      }
      v13 = v17;
      if (!(_DWORD)v17)
      {
        if ((_QWORD)v34 == a6)
        {
          if (v29)
          {
            v18 = v35[0];
          }
          else
          {
            v18 = 1;
            v35[0] = 1;
          }
          v19 = v16 + *((_QWORD *)&v32 + 1);
          if (*((uint64_t *)&v34 + 1) <= v16 + *((_QWORD *)&v32 + 1))
          {
            if (*((uint64_t *)&v34 + 1) < v16 + *((_QWORD *)&v32 + 1))
            {
              v20 = v18 + *((_QWORD *)&v34 + 1);
              log_err("%s:%d: %s range 0x%llx:%lld overlaps with recently-freed range 0x%llx:%lld\n", "spaceman_fq_tree_insert", 4584, (const char *)(*(_QWORD *)(a1 + 384) + 208), a4, a5, *((_QWORD *)&v34 + 1), v18);
              if (v20 > v19)
              {
                v16 += v20 - v19;
                v33 = v16;
              }
              if (v20 >= v19)
                v21 = v19;
              else
                v21 = v20;
              a5 = a5 - v21 + *((_QWORD *)&v34 + 1);
            }
            else
            {
              v16 += v18;
              v33 = v16;
            }
            v31 = v34;
          }
        }
        goto LABEL_31;
      }
LABEL_43:
      obj_release(v36);
      return v13;
    }
LABEL_13:
    *(_QWORD *)&v32 = a6;
    *((_QWORD *)&v32 + 1) = a4;
    v16 = a5;
    v33 = a5;
    goto LABEL_14;
  }
  return v13;
}

uint64_t spaceman_check_allocation_status_internal(_QWORD *a1, uint64_t a2, char a3, unint64_t a4, uint64_t a5, _BOOL4 *a6, _QWORD *a7)
{
  _BOOL4 *v7;
  uint64_t v8;
  unint64_t v9;
  char v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  unsigned int *v15;
  unint64_t v16;
  const char *v18;
  uint64_t v19;
  _BOOL4 is_set;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unsigned int v27;
  unsigned int v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int is_clear;
  int v46;
  uint64_t v47;
  uint64_t overlap;
  unsigned int v53;
  uint64_t *v56;
  unsigned int *v57;
  int v58;
  unint64_t v59;
  int v60;
  _BOOL4 v61;
  char v64;
  unsigned int *v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;

  v7 = a6;
  v8 = a5;
  v9 = a4;
  v68 = 0;
  v69 = 0;
  v67 = 0;
  v11 = __clz(__rbit64(*(unsigned int *)(a1[47] + 36)));
  v12 = (0x4000000000000000uLL >> v11) & a4;
  v61 = v12 != 0;
  if (v12)
    v13 = 2;
  else
    v13 = 1;
  v14 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v11) & a4;
  if ((a3 & 2) != 0)
    *a7 = 0;
  v65 = 0;
  v66 = 0;
  v15 = *(unsigned int **)(a2 + 376);
  v16 = *(_QWORD *)&v15[12 * (v12 != 0) + 12];
  if (v16 <= a5 || v14 > v16 - a5)
  {
    if (v12)
      v18 = "tier2";
    else
      v18 = "main";
    log_err("%s:%d: %s block range %lld:%lld out of %s bounds %lld\n", "spaceman_check_allocation_status_internal", 8292, (const char *)(a1[48] + 208), v14, a5, v18, v16);
    return 22;
  }
  v53 = v13;
  if (a5 <= 0)
  {
    is_set = 0;
    v19 = 0;
    if ((a3 & 3) == 0)
      goto LABEL_65;
    goto LABEL_73;
  }
  is_set = 0;
  v21 = 0;
  v22 = v14 + a5;
  v57 = &v15[12 * (v12 != 0) + 17];
  v56 = (uint64_t *)(a2 + 8 * (v12 != 0) + 888);
  v60 = a3 & 3;
  v23 = -1;
  while (1)
  {
    v24 = v15[10];
    v25 = v14 / v15[9];
    v59 = v25;
    v26 = v25 / v24;
    if (*v57)
      break;
    v21 = *v56;
    v32 = v25 / v24;
LABEL_25:
    v65 = v15;
    v66 = __PAIR64__(v26, v61);
    if (!v21)
    {
      v19 = 22;
LABEL_60:
      v7 = a6;
      v9 = a4;
      v8 = a5;
      goto LABEL_64;
    }
    v58 = v23;
    v33 = v21;
    v34 = *(_QWORD *)(v21 + 8 * v32);
    v35 = obj_get(a1[49], 0x40000000, v34, &sm_cib_desc, &v65, 0, 0, 0, &v68);
    if ((_DWORD)v35)
    {
      v19 = v35;
      log_err("%s:%d: %s error getting cib %d @ %lld: %d\n", "spaceman_check_allocation_status_internal", 8344, (const char *)(a1[48] + 208), v59 / v15[10], v34, v35);
      goto LABEL_63;
    }
    if (v14 < v22)
    {
      v36 = *(_QWORD *)(v68 + 56);
      v37 = v59 % v15[10];
      do
      {
        if (v37 >= *(unsigned int *)(v36 + 36))
          break;
        v38 = *(_QWORD *)(v36 + 32 * v37 + 64);
        if (v38)
        {
          v39 = obj_get(a1[49], 0x40000000, v38, &sm_bm_desc, 0, 0, 0, 0, &v67);
          if ((_DWORD)v39)
          {
            v19 = v39;
            log_err("%s:%d: %s error getting cib %d bitmap %d @ %lld: %d\n", "spaceman_check_allocation_status_internal", 8371, (const char *)(a1[48] + 208), v59 / v15[10], v37, v38, v39);
            goto LABEL_50;
          }
          v40 = *(_QWORD *)(v67 + 56);
          v41 = v15[9];
          v42 = v14 % v41;
          v43 = v41 - v14 % v41;
          if (v22 - v14 >= v43)
            v44 = v43;
          else
            v44 = v22 - v14;
          if ((a3 & 1) != 0)
          {
            is_clear = bitmap_range_is_clear(v40, v42, v44);
            v46 = a3 & 2 | is_clear;
            is_set = is_clear == 0;
            obj_release(v67);
            v67 = 0;
            if (!v46)
            {
              v19 = 0;
              is_set = 1;
              goto LABEL_58;
            }
          }
          else if ((a3 & 2) != 0)
          {
            *a7 += bitmap_count_bits(v40, 0, v42, v44 + v42);
            obj_release(v67);
            v67 = 0;
          }
          else
          {
            is_set = bitmap_range_is_set(v40, v42, v44);
            obj_release(v67);
            v67 = 0;
            if (!is_set)
              goto LABEL_57;
          }
        }
        else
        {
          if (!v60)
          {
            is_set = 0;
LABEL_57:
            v19 = 0;
LABEL_58:
            v7 = a6;
            goto LABEL_75;
          }
          if (v22 - v14 >= (*(_DWORD *)(v36 + 32 * v37 + 60) & 0xFFFFF) + v14 / v15[9] * v15[9] - v14)
            v44 = (*(_DWORD *)(v36 + 32 * v37 + 60) & 0xFFFFF) + v14 / v15[9] * v15[9] - v14;
          else
            v44 = v22 - v14;
          is_set = 0;
          if (a7)
            *a7 += v44;
        }
        v14 += v44;
        ++v37;
      }
      while (v14 < v22);
    }
    v19 = 0;
LABEL_50:
    obj_release(v68);
    v68 = 0;
    if (v14 < v22)
    {
      v21 = v33;
      v23 = v58;
      if (!(_DWORD)v19)
        continue;
    }
    goto LABEL_60;
  }
  v27 = v15[11];
  v28 = v26 / v27;
  v29 = v25 / v24;
  if (v26 / v27 == v23)
  {
LABEL_23:
    LODWORD(v32) = v26 - v27 * v23;
    LODWORD(v26) = v29;
    goto LABEL_25;
  }
  v30 = *(_QWORD *)(*v56 + 8 * v28);
  if (v69)
  {
    obj_release(v69);
    v69 = 0;
  }
  v65 = v15;
  v66 = __PAIR64__(v28, v61);
  v31 = obj_get(a1[49], 0x40000000, v30, &sm_cab_desc, &v65, 0, 0, 0, &v69);
  if (!(_DWORD)v31)
  {
    v21 = *(_QWORD *)(v69 + 56) + 40;
    v27 = v15[11];
    v23 = v28;
    v29 = v59 / v15[10];
    goto LABEL_23;
  }
  v47 = v31;
  log_err("%s:%d: %s error getting cab %d @ %lld: %d\n", "spaceman_check_allocation_status_internal", 8319, (const char *)(a1[48] + 208), v28, v30, v31);
  v19 = v47;
LABEL_63:
  v7 = a6;
  v9 = a4;
  v8 = a5;
LABEL_64:
  if (!v60)
  {
LABEL_65:
    if (!(_DWORD)v19 && is_set)
    {
      v64 = 0;
      overlap = spaceman_fq_tree_find_overlap((uint64_t)a1, a2, v53, v9, v8, &v64);
      v19 = overlap;
      if (v64 && (_DWORD)overlap == 0)
        is_set = 0;
    }
  }
LABEL_73:
  if ((_DWORD)v19)
    log_debug("%s:%d: %s %lld:%lld error: %d\n", "spaceman_check_allocation_status_internal", 8423, (const char *)(a1[48] + 208), v9, v8, v19);
LABEL_75:
  if (v69)
    obj_release(v69);
  if (v68)
    obj_release(v68);
  if (v67)
    obj_release(v67);
  *v7 = is_set;
  return v19;
}

uint64_t spaceman_reserve(uint64_t a1, int a2, unint64_t a3, uint64_t a4, int *a5)
{
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  BOOL v22;
  unint64_t v23;
  pthread_mutex_t *v24;
  unint64_t v25;
  uint64_t v26;
  int v27;
  int v29;
  _OWORD v31[4];
  uint64_t v32;
  uint64_t v33;
  _QWORD v34[2];

  v8 = a1;
  v34[1] = *MEMORY[0x1E0C80C00];
  if (obj_type(a1) == 13)
    v9 = (_QWORD *)v8;
  else
    v9 = 0;
  if (v9)
    v8 = v9[49];
  v32 = 0;
  memset(v31, 0, sizeof(v31));
  v33 = 0;
  v34[0] = 0;
  if ((uint64_t)a3 < 1)
    return 22;
  v10 = spaceman_get(v8, &v32);
  if (!(_DWORD)v10)
  {
    v11 = *(_QWORD **)(v32 + 376);
    if ((~a2 & 0x38) == 0)
      panic("Absurd combination of allocation flags for spaceman %llx", v32);
    if (*(_QWORD *)(*(_QWORD *)(v32 + 376) + 96))
      __asm { BR              X12 }
    if ((a2 & 0x10) != 0)
    {
      v10 = 22;
      goto LABEL_45;
    }
    LODWORD(v34[0]) = 0;
    LODWORD(v33) = 1;
    v29 = a2 & 0x40;
    pthread_mutex_lock((pthread_mutex_t *)(v32 + 384));
    pthread_mutex_lock((pthread_mutex_t *)(v32 + 576));
    v12 = 0;
LABEL_15:
    v13 = *((unsigned int *)v34 + v12);
    v14 = *((unsigned int *)&v34[-1] + v12++);
    v15 = 1;
    while (1)
    {
      if (v9)
      {
        v16 = v9[47];
        v17 = *(_QWORD *)(v16 + 80);
        if (v17)
        {
          if (*(_QWORD *)(v16 + 88) + a3 + v9[51] > v17)
          {
            v10 = 69;
            goto LABEL_43;
          }
        }
      }
      v18 = v11[30] + v11[9] + v11[15] + v11[35] + v11[24] - v11[23];
      if (v9)
      {
        v19 = v9[47];
        v20 = *(_QWORD *)(v19 + 72);
        v21 = *(_QWORD *)(v19 + 88);
        v22 = v20 >= v21;
        v23 = v20 - v21;
        if (!v22)
          v23 = 0;
        v18 += v23;
      }
      if (v18 < a3)
      {
        v10 = 28;
LABEL_43:
        v24 = (pthread_mutex_t *)v32;
        goto LABEL_44;
      }
      v24 = (pthread_mutex_t *)v32;
      v25 = v11[6 * v13 + 9] - *(_QWORD *)(v32 + 8 * v13 + 832);
      if (v25 < a3)
      {
        if (!v15 || v11[5 * v14 + 25] + v25 < a3 || !v15)
        {
          if (v12 != 1)
            goto LABEL_15;
          v10 = 28;
LABEL_44:
          pthread_mutex_unlock(v24 + 9);
          pthread_mutex_unlock((pthread_mutex_t *)(v32 + 384));
LABEL_45:
          obj_release(v32);
          return v10;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(v32 + 576));
        pthread_mutex_unlock((pthread_mutex_t *)(v32 + 384));
        pthread_mutex_lock((pthread_mutex_t *)(v32 + 512));
        trim_time_tracking_start(v8, (uint64_t)v31, 0, 0);
        v15 = spaceman_free_completed(v8, v32, v14, 1, v31, a4) != 0;
        trim_time_tracking_end(v8, (uint64_t)v31);
        pthread_mutex_unlock((pthread_mutex_t *)(v32 + 512));
        pthread_mutex_lock((pthread_mutex_t *)(v32 + 384));
        pthread_mutex_lock((pthread_mutex_t *)(v32 + 576));
        v25 = 0;
      }
      if (v25 >= a3)
      {
        v24 = (pthread_mutex_t *)v32;
        v26 = v32 + 8 * v13;
        *(_QWORD *)(v26 + 832) += a3;
        if (v29)
          *(_QWORD *)(v26 + 848) += a3;
        if (v9)
          v9[51] += a3;
        v10 = 0;
        if ((_DWORD)v13 == 1)
          v27 = 16;
        else
          v27 = 8;
        *a5 = v27 | v29;
        goto LABEL_44;
      }
    }
  }
  return v10;
}

uint64_t spaceman_unreserve(uint64_t a1, unsigned int a2, unint64_t a3)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  const char *v15;
  unint64_t v16;
  BOOL v17;
  unint64_t v18;
  const char *v19;
  uint64_t v21;

  if (obj_type(a1) == 13)
    v6 = a1;
  else
    v6 = 0;
  v7 = (_QWORD *)a1;
  if (v6)
    v7 = *(_QWORD **)(v6 + 392);
  v21 = 0;
  v8 = spaceman_get(v7, &v21);
  if (!(_DWORD)v8)
  {
    v9 = (a2 >> 4) & 1;
    pthread_mutex_lock((pthread_mutex_t *)(v21 + 384));
    pthread_mutex_lock((pthread_mutex_t *)(v21 + 576));
    if (*(_QWORD *)(v21 + 8 * v9 + 832) < *(_QWORD *)(v21 + 8 * v9 + 848))
    {
      v10 = "T2";
      if (!(_DWORD)v9)
        v10 = "Main";
      panic("%s, Reserved space < reserved metadata: %llu < %llu\n", v10, *(_QWORD *)(v21 + 832), *(_QWORD *)(v21 + 848));
    }
    v11 = v21;
    v12 = v21 + 8 * v9;
    v13 = *(_QWORD *)(v12 + 848);
    if ((a2 & 0x40) != 0)
    {
      if (v13 < a3)
        panic("reserved metadata space underflow: %lld (%lld)\n", *(_QWORD *)(v12 + 848), a3);
      *(_QWORD *)(v12 + 848) = v13 - a3;
      *(_QWORD *)(v11 + 8 * v9 + 832) -= a3;
      if (!v6)
        goto LABEL_29;
      goto LABEL_23;
    }
    v14 = *(_QWORD *)(v12 + 832);
    if (v14 - v13 >= a3)
    {
      *(_QWORD *)(v12 + 832) = v14 - a3;
      if (v6)
      {
LABEL_23:
        v16 = *(_QWORD *)(v6 + 408);
        v17 = v16 >= a3;
        v18 = v16 - a3;
        if (!v17)
        {
          if (obj_type(a1) == 13)
            v19 = (const char *)(a1 + 3880);
          else
            v19 = (const char *)(*(_QWORD *)(a1 + 384) + 208);
          log_err("%s:%d: %s fs reserved space underflow: %lld (%lld)\n", "spaceman_unreserve", 8678, v19, *(_QWORD *)(v6 + 408), a3);
          v18 = 0;
        }
        *(_QWORD *)(v6 + 408) = v18;
      }
    }
    else
    {
      if (obj_type(a1) == 13)
        v15 = (const char *)(a1 + 3880);
      else
        v15 = (const char *)(*(_QWORD *)(a1 + 384) + 208);
      log_err("%s:%d: %s reserved space underflow: %lld (+meta:%llu) < %lld\n", "spaceman_unreserve", 8669, v15, *(_QWORD *)(v21 + 8 * v9 + 832) - v13, v13, a3);
      *(_QWORD *)(v21 + 8 * v9 + 832) = v13;
      if (v6)
        goto LABEL_23;
    }
LABEL_29:
    pthread_mutex_unlock((pthread_mutex_t *)(v21 + 576));
    pthread_mutex_unlock((pthread_mutex_t *)(v21 + 384));
    obj_release(v21);
  }
  return v8;
}

uint64_t spaceman_fs_bounds_clear(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  BOOL v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  pthread_mutex_t *v19;

  v19 = 0;
  result = spaceman_get(a1, (uint64_t *)&v19);
  if (!(_DWORD)result)
  {
    v6 = *(_QWORD *)&v19[5].__opaque[48];
    result = obj_modify(v19, 0, a3);
    if (!(_DWORD)result)
    {
      pthread_mutex_lock(v19 + 6);
      pthread_mutex_lock(v19 + 9);
      v7 = *(_QWORD **)(a2 + 376);
      v8 = v7[9];
      v9 = v7[11];
      if (v9)
      {
        v10 = obj_oid(a2);
        log_err("%s:%d: %s file system %lld alloc block count is not zero: %lld/%lld\n", "spaceman_fs_bounds_clear", 8844, (const char *)(a2 + 3880), v10, v9, v8);
        v7 = *(_QWORD **)(a2 + 376);
        if (v7[9])
          goto LABEL_8;
      }
      else if (v8)
      {
        goto LABEL_8;
      }
      if (!v7[10])
      {
LABEL_15:
        pthread_mutex_unlock(v19 + 9);
        pthread_mutex_unlock(v19 + 6);
        obj_release(&v19->__sig);
        return 0;
      }
LABEL_8:
      if (v9 >= v8)
        v9 = v8;
      v11 = *(_QWORD *)(v6 + 184);
      v12 = v11 >= v8;
      v13 = v11 - v8;
      if (!v12)
      {
        v14 = obj_oid(a2);
        log_err("%s:%d: %s file system %lld fs reserve block count %lld larger than global fs reserve block count %lld\n", "spaceman_fs_bounds_clear", 8862, (const char *)(a2 + 3880), v14, v8, *(_QWORD *)(v6 + 184));
        v13 = 0;
      }
      *(_QWORD *)(v6 + 184) = v13;
      v15 = *(_QWORD *)(v6 + 192);
      v12 = v15 >= v9;
      v16 = v15 - v9;
      if (!v12)
      {
        v17 = obj_oid(a2);
        log_err("%s:%d: %s file system %lld fs reserve alloc count %lld larger than global fs reserve alloc count %lld\n", "spaceman_fs_bounds_clear", 8870, (const char *)(a2 + 3880), v17, v9, *(_QWORD *)(v6 + 192));
        v16 = 0;
      }
      *(_QWORD *)(v6 + 192) = v16;
      v18 = *(_QWORD *)(a2 + 376);
      *(_QWORD *)(v18 + 72) = 0;
      *(_QWORD *)(v18 + 80) = 0;
      obj_dirty((uint64_t)v19, a3, 0);
      fs_sb_dirty(a2, a3);
      goto LABEL_15;
    }
  }
  return result;
}

uint64_t spaceman_unset_block_out_range(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  pthread_mutex_t *v10;
  _BOOL4 v11;

  v2 = a1[47];
  if (!*(_QWORD *)(v2 + 1248))
    return 0;
  v9 = 0;
  v10 = 0;
  v5 = spaceman_get(a1, (uint64_t *)&v10);
  if (!(_DWORD)v5)
  {
    v6 = *(_QWORD *)&v10[5].__opaque[48];
    v5 = obj_modify(v10, 0, a2);
    if (!(_DWORD)v5)
    {
      v7 = (*(_QWORD *)(v2 + 1240) << __clz(__rbit64(*(unsigned int *)(a1[47] + 36))) >> 62) & 1;
      pthread_mutex_lock(v10 + 8);
      pthread_mutex_lock(v10 + 6);
      v5 = spaceman_check_allocation_status_internal(a1, (uint64_t)v10, 2, *(_QWORD *)(v2 + 1240), *(_QWORD *)(v2 + 1248), &v11, &v9);
      pthread_mutex_lock(v10 + 9);
      *(_QWORD *)(v6 + 48 * v7 + 72) += v9;
      pthread_mutex_unlock(v10 + 9);
      *(_OWORD *)(a1[47] + 1240) = 0u;
      pthread_mutex_unlock(v10 + 6);
      pthread_mutex_unlock(v10 + 8);
      obj_dirty((uint64_t)v10, a2, 0);
    }
    obj_release(&v10->__sig);
  }
  return v5;
}

uint64_t update_bm_hint(uint64_t result, unsigned int a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v8;
  unint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *(_QWORD *)(result + 376);
  v5 = *(_QWORD *)(result + 8 * a2 + 1488);
  v11 = 0;
  v12 = 0;
  if (v5)
  {
    v8 = *(_QWORD *)(result + 1584);
    if (v8)
      ++*(_QWORD *)(v8 + 112);
    if (*(_QWORD *)(v4 + 48 * a2 + 56) - 1 == a4)
      v9 = *(_QWORD *)(v4 + 48 * a2 + 48) % (unint64_t)*(unsigned int *)(v4 + 36);
    else
      v9 = *(unsigned int *)(v4 + 36);
    *(_DWORD *)(v5 + 4 * a4) = (*(_DWORD *)(v5 + 4 * a4) & 0xFEFFFFFF | ((*a3 & 1) << 24)) ^ 0x1000000;
    result = bitmap_range_find_clear_range((uint64_t)a3, 0xFFFFFFLL, 0, v9, &v12, &v11);
    if (v9 < 0x40 || (*(_QWORD *)&a3[2 * (v9 >> 6) - 2] & 0x8000000000000000) != 0)
      v10 = *(_DWORD *)(v5 + 4 * a4) & 0xFDFFFFFF;
    else
      v10 = *(_DWORD *)(v5 + 4 * a4) | 0x2000000;
    *(_DWORD *)(v5 + 4 * a4) = v10 & 0xFF000000 | v11 & 0xFFFFFF;
  }
  return result;
}

uint64_t trim_time_tracking_check(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  __darwin_time_t tv_sec;
  int tv_nsec;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  timespec v9;

  if (a2)
  {
    if (*(_BYTE *)(a2 + 62))
    {
      if (!*(_BYTE *)(a2 + 63))
      {
        v3 = result;
        v9.tv_sec = 0;
        v9.tv_nsec = 0;
        result = clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v9);
        tv_sec = v9.tv_sec;
        tv_nsec = v9.tv_nsec;
        *(_QWORD *)a2 = v9.tv_sec;
        tv_nsec /= 1000;
        *(_DWORD *)(a2 + 8) = tv_nsec;
        v6 = 1000000 * tv_sec + tv_nsec;
        *(_QWORD *)(a2 + 32) = v6;
        if (v6 - *(_QWORD *)(a2 + 24) >= 1000 * (unint64_t)*(unsigned __int16 *)(a2 + 60))
        {
          v7 = (unint64_t *)(*(_QWORD *)(v3 + 384) + 168);
          do
            v8 = __ldxr(v7);
          while (__stxr(v8 + 1, v7));
          ++*(_DWORD *)(a2 + 56);
          *(_QWORD *)(a2 + 24) = *(_QWORD *)(a2 + 32);
        }
      }
    }
  }
  return result;
}

uint64_t spaceman_ip_bm_block_free(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;

  v4 = *(_QWORD *)(a2 + 376);
  v5 = *(_DWORD *)(v4 + 164) & 0x7FFFFFFF;
  if (v5 <= a3)
    return 22;
  v6 = *(unsigned __int16 *)(v4 + 322);
  if (v6 == 0xFFFF)
  {
    v7 = *(_QWORD *)(a2 + 880);
  }
  else
  {
    if (v5 <= v6)
      return nx_corruption_detected_int(a1);
    v7 = *(_QWORD *)(a2 + 880);
    *(_WORD *)(v7 + 2 * *(unsigned __int16 *)(v4 + 322)) = a3;
  }
  *(_WORD *)(v7 + 2 * a3) = -1;
  *(_WORD *)(v4 + 322) = a3;
  if (*(__int16 *)(v4 + 320) == -1)
    *(_WORD *)(v4 + 320) = a3;
  obj_dirty(a2, a4, 0);
  return 0;
}

uint64_t spaceman_decrement_free_queue_count(uint64_t result, uint64_t a2, unsigned int a3, unint64_t a4)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v11;

  v4 = *(_QWORD *)(a2 + 376) + 40 * a3;
  v6 = *(_QWORD *)(v4 + 200);
  v5 = (unint64_t *)(v4 + 200);
  v7 = v6 - a4;
  if (v6 >= a4)
  {
    *v5 = v7;
  }
  else
  {
    v11 = result;
    result = nx_ratelimit_log_allowed(result);
    if ((_DWORD)result)
      result = (uint64_t)log_err("%s:%d: %s sfq %d count underflow %lld - %lld\n", "spaceman_decrement_free_queue_count", 5765, (const char *)(*(_QWORD *)(v11 + 384) + 208), a3, *(_QWORD *)(*(_QWORD *)(a2 + 376) + 40 * a3 + 200), a4);
    *(_QWORD *)(*(_QWORD *)(a2 + 376) + 40 * a3 + 200) = 0;
  }
  return result;
}

uint64_t spaceman_ip_extent_validate(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  unint64_t v9;

  v7 = *(_QWORD *)(*(_QWORD *)(a2 + 376) + 152);
  v9 = 0;
  result = spaceman_ip_block_index(a1, a2, a3, (uint64_t *)&v9);
  if ((_DWORD)result == 2)
    return 22;
  if ((_DWORD)result)
    return result;
  if ((v7 & 0x7FFFFFFFFFFFFFFFLL) <= a4 || v9 > (v7 & 0x7FFFFFFFFFFFFFFFuLL) - a4)
    return 22;
  result = 0;
  if (a5)
    *a5 = v9;
  return result;
}

uint64_t spaceman_fq_trim_list_flush(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  pthread_mutex_t *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;

  v9 = (_QWORD *)result;
  if (a3)
  {
    if (!*(_WORD *)(a2 + 1532))
      return result;
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 512));
    v10 = *(unsigned __int16 *)(a2 + 1532) + 16;
    v11 = 16;
  }
  else
  {
    if (!*(_WORD *)(a2 + 1534))
      return result;
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 448));
    v11 = 0;
    v10 = *(unsigned __int16 *)(a2 + 1534);
  }
  trim_time_tracking_check((uint64_t)v9, a4);
  if (v11 < v10)
  {
    v12 = 16 * v11;
    v13 = v10 - (unint64_t)v11;
    do
    {
      dev_unmap(v9[48], *(_QWORD *)(*(_QWORD *)(a2 + 1536) + v12));
      v12 += 16;
      --v13;
    }
    while (v13);
  }
  dev_unmap_flush(v9[48]);
  if (a3)
  {
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 512));
    v14 = (pthread_mutex_t *)(a2 + 384);
  }
  else
  {
    v14 = (pthread_mutex_t *)(a2 + 448);
  }
  result = pthread_mutex_lock(v14);
  if (v11 < v10)
  {
    v15 = 16 * v11;
    v16 = v10 - (unint64_t)v11;
    do
    {
      v17 = (unint64_t *)(*(_QWORD *)(a2 + 1536) + v15);
      v18 = *v17;
      v19 = v17[1];
      if (a3)
        result = spaceman_freed_internal(v9, a2, v18, v19, 1, a5);
      else
        result = spaceman_ip_freed((uint64_t)v9, (_QWORD *)a2, v18, v19, a5);
      v15 += 16;
      --v16;
    }
    while (v16);
  }
  if (a3)
  {
    result = pthread_mutex_unlock((pthread_mutex_t *)(a2 + 384));
    *(_QWORD *)(a2 + 1552) = 0;
    *(_WORD *)(a2 + 1532) = 0;
  }
  else
  {
    *(_QWORD *)(a2 + 1544) = 0;
    *(_WORD *)(a2 + 1534) = 0;
  }
  return result;
}

uint64_t spaceman_ip_freed(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t result;
  int v12;
  BOOL v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unsigned int v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;

  v10 = a2[47];
  v25 = 0;
  result = xid_is_current_tx(a1, a5);
  if ((_DWORD)result)
  {
    v26 = 0;
    v23 = 0;
    v24 = 0;
    result = spaceman_ip_extent_validate(a1, (uint64_t)a2, a3, a4, &v26);
    if ((_DWORD)result)
    {
      if ((_DWORD)result == 22)
        return (uint64_t)log_err("%s:%d: %s attempt to free block(s) outside of internal pool: 0x%llx:0x%llx\n");
      else
        return (uint64_t)log_err("%s:%d: %s Error mapping freed IP block range 0x%llx:0x%llx to index: %d\n");
    }
    else
    {
      v12 = 8 * *(_DWORD *)(v10 + 32);
      if (v12)
        v13 = a4 < 1;
      else
        v13 = 1;
      if (!v13)
      {
        v14 = v12;
        v15 = v26;
        v21 = v10;
        do
        {
          v16 = v15 / v14;
          v17 = *(unsigned __int16 *)(a2[109] + 2 * (v15 / v14));
          result = spaceman_ip_bm_block_address(a1, v10, v17, &v24);
          if ((_DWORD)result)
            break;
          result = obj_get(*(_QWORD *)(a1 + 392), 1073741825, v24, &sm_bm_desc, 0, 0, 0, a5, &v25);
          if ((_DWORD)result)
            break;
          v18 = *(_QWORD *)(v25 + 56);
          v19 = v26 % v14;
          if (a4 >= (uint64_t)(v14 - v26 % v14))
            v20 = v14 - v26 % v14;
          else
            v20 = a4;
          if (*(_QWORD *)(a2[108] + 8 * v16) != a5)
          {
            v23 = 0;
            v22 = 0;
            if (spaceman_ip_bm_block_alloc(a1, (uint64_t)a2, a5, &v23, &v22)
              || spaceman_ip_bm_block_free(a1, (uint64_t)a2, v17, a5))
            {
              return obj_release(v25);
            }
            v24 = v23;
            *(_WORD *)(a2[109] + 2 * v16) = v22;
            *(_QWORD *)(a2[108] + 8 * v16) = a5;
          }
          bitmap_clear_range(v18, v19, v20);
          obj_dirty(v25, a5, v24);
          result = obj_release(v25);
          v15 = v26 + v20;
          v26 += v20;
          v13 = a4 <= v20;
          a4 -= v20;
          v10 = v21;
        }
        while (!v13);
      }
    }
  }
  return result;
}

uint64_t spaceman_freed_internal(_QWORD *a1, uint64_t a2, unint64_t a3, unint64_t a4, char a5, uint64_t a6)
{
  uint64_t v12;
  char v13;

  if (a4)
    spaceman_handle_metazone_freed((uint64_t)a1, a2, a3);
  v12 = spaceman_modify_bits(a1, 0, a2, a3, a4, a6, 1, a5);
  if (!(_DWORD)v12)
  {
    v13 = __clz(__rbit64(*(unsigned int *)(a1[47] + 36)));
    spaceman_free_extent_cache_insert(*(_QWORD *)(a2 + (((a3 << v13) & 0x4000000000000000) >> 59) + 1568), 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v13) & a3, a4);
  }
  return v12;
}

unint64_t spaceman_iterate_bitmap_hints(unint64_t result, unsigned int a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unint64_t v16;
  int v17;
  unint64_t v19;
  uint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  int v33;
  unint64_t v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;

  v5 = a5;
  v7 = result;
  v8 = *(_QWORD *)(result + 376);
  v9 = a2;
  v10 = *(_QWORD *)(v8 + 48 * a2 + 56);
  v11 = *(_QWORD *)(a4 + 8);
  v12 = *(unsigned int *)(v8 + 36);
  v13 = *(_QWORD *)a4 / v12;
  v14 = result + 8 * a2;
  v15 = *(_DWORD *)(*(_QWORD *)(v14 + 1488) + 4 * v13) & 0xFFFFFF;
  if (a3)
    v16 = a3;
  else
    v16 = *(_QWORD *)(v8 + 48 * a2 + 56);
  if (v10 < v16)
    v16 = *(_QWORD *)(v8 + 48 * a2 + 56);
  if (v12 >= 0xFFFFFF)
    v17 = 0xFFFFFF;
  else
    v17 = *(_DWORD *)(v8 + 36);
  if (v15 == v17 || v16 < 2)
  {
    v19 = *(_QWORD *)a4 / v12;
    LODWORD(v14) = *(_DWORD *)(*(_QWORD *)(v14 + 1488) + 4 * v13) & 0xFFFFFF;
    goto LABEL_37;
  }
  v20 = (uint64_t *)(v14 + 1488);
  v21 = v16 - 1;
  v22 = v13 + 1;
  v23 = *(_DWORD *)(*(_QWORD *)(v14 + 1488) + 4 * v13) & 0xFFFFFF;
  v24 = *(_QWORD *)a4 / v12;
  do
  {
    v19 = v22 % v10;
    v25 = *v20;
    v26 = *(_DWORD *)(*v20 + 4 * (v22 % v10));
    LODWORD(v14) = v26 & 0xFFFFFF;
    if ((v26 & 0xFFFFFFu) > v15)
    {
      v13 = v22 % v10;
      v15 = v26 & 0xFFFFFF;
    }
    if (v14 > v23)
    {
      if (*(_BYTE *)(a4 + 16))
      {
        if ((v26 & 0xC000000) != 0)
          goto LABEL_34;
        v27 = *(_QWORD *)(v7 + 376);
        v28 = v27 + 48 * v9;
        v29 = *(_QWORD *)(v28 + 56);
        if (v29 > v19)
        {
          v30 = *(_QWORD *)(a4 + 32);
          if (v30)
          {
            v47 = v24;
            v48 = v7;
            v49 = v9;
            v50 = v11;
            v51 = v8;
            v31 = *(unsigned int *)(v27 + 36);
            v32 = v31;
            if (v29 - 1 == v19)
              v32 = *(_QWORD *)(v28 + 48) % v31;
            result = calc_overlap_range(v19 * v31, v32, *(_QWORD *)(a4 + 24), v30, 0);
            v11 = v50;
            v8 = v51;
            v7 = v48;
            v9 = v49;
            v24 = v47;
            if (result)
              goto LABEL_34;
            LODWORD(v14) = *(_DWORD *)(v25 + 4 * v19) & 0xFFFFFF;
          }
        }
      }
      LODWORD(v12) = *(_DWORD *)(v8 + 36);
      if (v12 >= 0xFFFFFF)
        v33 = 0xFFFFFF;
      else
        v33 = *(_DWORD *)(v8 + 36);
      if (v11 <= v14 || (_DWORD)v14 == v33)
        goto LABEL_36;
      v24 = v22 % v10;
      v23 = v14;
    }
LABEL_34:
    ++v22;
    --v21;
  }
  while (v21);
  LODWORD(v12) = *(_DWORD *)(v8 + 36);
  v19 = v24;
  LODWORD(v14) = v23;
LABEL_36:
  v12 = v12;
  v5 = a5;
LABEL_37:
  v35 = v19 * v12;
  if (v11 >= v14)
    v14 = v14;
  else
    v14 = v11;
  *(_QWORD *)v5 = v35;
  *(_QWORD *)(v5 + 8) = v14;
  v36 = *(_BYTE *)(a4 + 16);
  if (v36)
  {
    v37 = *(_QWORD *)(v7 + 376);
    v38 = v37 + 48 * v9;
    v39 = *(_QWORD *)(v38 + 56);
    if (v39 > v19 && (v40 = *(_QWORD *)(a4 + 32)) != 0)
    {
      v41 = *(unsigned int *)(v37 + 36);
      v42 = v19 * v41;
      if (v39 - 1 == v19)
        v41 = *(_QWORD *)(v38 + 48) % v41;
      v43 = *(_QWORD *)(a4 + 24);
      v44 = v8;
      v45 = v11;
      result = calc_overlap_range(v42, v41, v43, v40, 0);
      v11 = v45;
      v8 = v44;
      v36 = result == 0;
    }
    else
    {
      v36 = 1;
    }
  }
  *(_BYTE *)(v5 + 16) = v36;
  if (v19 != v13)
  {
    v46 = v15;
    if (v11 < v15)
      v46 = v11;
    *(_QWORD *)(v5 + 24) = v13 * *(unsigned int *)(v8 + 36);
    *(_QWORD *)(v5 + 32) = v46;
    *(_BYTE *)(v5 + 40) = 0;
  }
  return result;
}

uint64_t spaceman_ip_block_free(uint64_t a1, pthread_mutex_t *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unsigned int v9;
  uint64_t v11;

  v8 = 22;
  if (xid_is_current_tx(a1, a4))
  {
    pthread_mutex_lock(a2 + 7);
    v9 = spaceman_ip_block_index(a1, (uint64_t)a2, a3, &v11);
    if (v9 == 2)
      v8 = 22;
    else
      v8 = v9;
    if (!(_DWORD)v8)
      v8 = spaceman_fq_tree_insert(a1, (uint64_t)a2, 0, a3, 1, a4);
    pthread_mutex_unlock(a2 + 7);
  }
  return v8;
}

uint64_t supplemental_tree_destroy(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v11;
  uint64_t (*v12)(uint64_t, _QWORD *, int, _QWORD *, int, int *);
  uint64_t tree;
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t *v18;
  _QWORD v19[3];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a3 == 5)
  {
    v11 = 0x20000001FLL;
    v12 = fext_tree_key_cmp;
  }
  else
  {
    if (a3 != 6)
    {
      log_err("%s:%d: %s unsupported tree type: %d\n", "supplemental_tree_get_descriptor", 64, (const char *)(a1 + 3880), a3);
      return 45;
    }
    v11 = 32;
    v12 = pfkur_tree_key_cmp;
  }
  v18 = 0;
  if (!a5)
  {
    tree = jfs_get_tree(a1, a3, a4, (uint64_t *)&v18);
    if ((_DWORD)tree)
      return tree;
    goto LABEL_11;
  }
  v19[1] = 0;
  v20 = 0u;
  v24 = 0;
  v22 = 0u;
  v23 = 0u;
  v21 = 0u;
  v19[0] = v12;
  v19[2] = v11;
  if ((unsigned __int16)a2 != 2)
  {
    tree = 22;
    goto LABEL_15;
  }
  tree = btree_get_extended(a1, a2 & 0xFFFF0000, a5, 0, 0, (uint64_t)v19, 0, (uint64_t *)&v18);
  if ((_DWORD)tree)
  {
LABEL_15:
    v16 = strerror(tree);
    log_err("%s:%d: %s Failed to get supplemental tree (type %d, oid %llu): %d (%s)\n", "supplemental_tree_destroy", 159, (const char *)(a1 + 3880), a3, a5, tree, v16);
    return tree;
  }
LABEL_11:
  v14 = btree_delete((uint64_t)v18, a4, a6);
  tree = v14;
  if ((_DWORD)v14)
  {
    v15 = strerror(v14);
    log_err("%s:%d: %s Failed to delete supplemental tree (type %d): %d (%s)\n", "supplemental_tree_destroy", 167, (const char *)(a1 + 3880), a3, tree, v15);
  }
  obj_release(v18);
  return tree;
}

unint64_t fletcher64_set_cksum(unint64_t *a1, uint32x4_t *a2, unint64_t a3, unint64_t a4, int8x16_t a5, int8x16_t a6)
{
  unint64_t result;
  unint64_t v8;

  result = fletcher64(a2, a3, a4, a5, a6);
  v8 = (HIDWORD(result)
      + result
      - 0xFFFFFFFF
      * ((unint64_t)(((HIDWORD(result) + result) * (unsigned __int128)0x200000003uLL) >> 64) >> 1)) ^ 0xFFFFFFFF;
  *a1 = v8 | ((unint64_t)~((_DWORD)v8
                                + (_DWORD)result
                                + ((unint64_t)(((v8 + result)
                                                                   * (unsigned __int128)0x200000003uLL) >> 64) >> 1)) << 32);
  return result;
}

unint64_t fletcher64_verify_cksum(_QWORD *a1, uint32x4_t *a2, unint64_t a3, unint64_t a4, int8x16_t a5, int8x16_t a6)
{
  unint64_t v7;
  unint64_t v8;

  v7 = fletcher64(a2, a3, a4, a5, a6);
  v8 = (HIDWORD(v7)
      + v7
      - 0xFFFFFFFF
      * ((unint64_t)(((HIDWORD(v7) + v7) * (unsigned __int128)0x200000003uLL) >> 64) >> 1)) ^ 0xFFFFFFFF;
  return (v8 | ((unint64_t)~((_DWORD)v8
                                  + (_DWORD)v7
                                  + ((unint64_t)(((v8 + v7)
                                                                     * (unsigned __int128)0x200000003uLL) >> 64) >> 1)) << 32)) ^ *a1;
}

uint64_t Base85::Decode(Base85 *this, const char *a2, uint64_t a3, unsigned __int8 *a4, uint64_t *a5, unint64_t *a6)
{
  char v6;
  const char *v7;
  Base85 *v8;
  int v9;
  int v10;
  const char *v12;
  int v13;
  Base85 *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  _BOOL4 v26;
  int v27;
  unsigned int v28;
  uint64_t v29;

  *a5 = 0;
  v6 = 1;
LABEL_2:
  v7 = a2;
  v8 = this;
  do
  {
    if (!v7)
      return (v7 == 0) & v6;
    v9 = *(char *)v8;
    if (v9 < 0)
      return (--v7 == 0) & v6;
    v8 = (Base85 *)((char *)v8 + 1);
    v10 = Base85::m_DecodeTable[v9];
    --v7;
  }
  while (v10 == -2);
  if (v10 == -3 || v10 == -1)
    return (v7 == 0) & v6;
  v12 = 0;
  while (v7 != v12 && (v12[(_QWORD)v8] & 0x80000000) == 0)
  {
    v13 = Base85::m_DecodeTable[(v12++)[(_QWORD)v8]];
    if (v13 != -2)
    {
      if (v13 != -3 && v13 != -1)
      {
        this = (Base85 *)&a2[(_QWORD)this];
        v15 = (Base85 *)&v12[(_QWORD)v8];
        a2 = (const char *)(v7 - v12);
        while (a2)
        {
          v16 = *(char *)v15;
          if (v16 < 0)
            return 0;
          v15 = (Base85 *)((char *)v15 + 1);
          v17 = Base85::m_DecodeTable[v16];
          --a2;
          if (v17 != -2)
          {
            if (v17 != -1)
            {
              this = v15;
              goto LABEL_25;
            }
            return 0;
          }
        }
        v17 = -3;
        while (1)
        {
LABEL_25:
          if (!a2)
          {
            v19 = -3;
            goto LABEL_31;
          }
          v18 = *(char *)this;
          if (v18 < 0)
            break;
          this = (Base85 *)((char *)this + 1);
          v19 = Base85::m_DecodeTable[v18];
          --a2;
          if (v19 != -2)
          {
            if (v19 == -1)
              return 0;
            do
            {
LABEL_31:
              if (!a2)
              {
                v21 = -3;
                goto LABEL_37;
              }
              v20 = *(char *)this;
              if (v20 < 0)
                return 0;
              this = (Base85 *)((char *)this + 1);
              v21 = Base85::m_DecodeTable[v20];
              --a2;
            }
            while (v21 == -2);
            if (v21 == -1)
              return 0;
LABEL_37:
            if (v17 == -3)
              v22 = -2;
            else
              v22 = -1;
            if (v17 == -3)
              v23 = -1;
            else
              v23 = 0;
            if (v17 == -3)
              v24 = 84;
            else
              v24 = v17;
            if (v19 == -3)
              v25 = v22;
            else
              v25 = v23;
            if (v19 == -3)
              v19 = 84;
            v26 = v21 == -3;
            if (v21 == -3)
              v21 = 84;
            v27 = v25 - v26 + 4;
            v28 = bswap32(v21 + 85 * (v19 + 85 * (v24 + 85 * (v13 + 85 * v10))));
            do
            {
              v29 = *a5;
              if (*a5 >= (unint64_t)a4)
              {
                v6 = 0;
              }
              else
              {
                *a5 = v29 + 1;
                *(_BYTE *)(a3 + v29) = v28;
              }
              v28 >>= 8;
              --v27;
            }
            while (v27);
            goto LABEL_2;
          }
        }
      }
      return 0;
    }
  }
  return 0;
}

uint64_t fusion_mt_key_cmp(uint64_t a1, _QWORD *a2, int a3, _QWORD *a4, int a5, int *a6)
{
  uint64_t result;
  int v7;

  result = 22;
  if (a3 == 8 && a5 == 8)
  {
    result = 0;
    v7 = *a2 > *a4;
    if (*a2 < *a4)
      v7 = -1;
    *a6 = v7;
  }
  return result;
}

double nx_obj_cache_reset(uint64_t a1)
{
  double result;

  obj_cache_reset(*(pthread_mutex_t **)(a1 + 392), 0);
  *(_QWORD *)(a1 + 408) = 0;
  *(_QWORD *)(a1 + 720) = 0;
  *(_QWORD *)(a1 + 920) = 0;
  *(_QWORD *)(a1 + 1128) = 0;
  *(_QWORD *)(a1 + 1336) = 0;
  *(_BYTE *)(a1 + 635) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  return result;
}

uint64_t nx_checkpoint_find_highest_xid(uint64_t a1, int *a2, unint64_t *a3)
{
  _DWORD *v6;
  _DWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  int8x16_t v12;
  int8x16_t v13;
  int v14;
  unint64_t v15;
  int v16;
  _BOOL4 v18;
  uint64_t v19;

  v6 = _apfs_malloc(*(unsigned int *)(*(_QWORD *)(a1 + 376) + 36));
  if (!v6)
    return 12;
  v7 = v6;
  v19 = 0;
  v8 = *(_QWORD *)(a1 + 376);
  if ((*(_DWORD *)(v8 + 104) & 0x7FFFFFFF) != 0)
  {
    v9 = 0;
    v18 = 0;
    v10 = 0;
    v11 = -1;
    while (1)
    {
      v7[6] = 0;
      if (nx_checkpoint_desc_block_address(a1, v9, &v19)
        || dev_read(*(_QWORD *)(a1 + 384), v19))
      {
        log_err("%s:%d: %s couldn't read checkpoint descriptor block %d @ 0x%llx: %d\n");
      }
      else
      {
        v14 = v7[6];
        if (v14 == -2147483647)
          goto LABEL_12;
        if (v14)
        {
          if (v14 == 1073741836)
          {
LABEL_12:
            if (obj_checksum_verify_phys(v7, *(_DWORD *)(*(_QWORD *)(a1 + 376) + 36), v12, v13))
            {
              log_err("%s:%d: %s invalid checksum for object type 0x%x @ checkpoint descriptor block %d @ 0x%llx\n");
            }
            else if (v7[7])
            {
              log_err("%s:%d: %s found unexpected subtype 0x%x for object type 0x%x @ checkpoint descriptor block %d\n");
            }
            else
            {
              v15 = *((_QWORD *)v7 + 2);
              if (v15)
              {
                if (v15 >= v10)
                {
                  v16 = v7[6];
                  if (v15 == v10 && v18 && v16 != -2147483647)
                  {
                    v18 = 1;
                  }
                  else
                  {
                    v18 = v16 == -2147483647;
                    v10 = *((_QWORD *)v7 + 2);
                    v11 = v9;
                  }
                }
              }
              else
              {
                log_err("%s:%d: %s found unexpected xid %lld @ checkpoint descriptor block %d\n");
              }
            }
            goto LABEL_7;
          }
          log_err("%s:%d: %s found unexpected object type 0x%x @ checkpoint descriptor block %d\n");
        }
      }
LABEL_7:
      ++v9;
      v8 = *(_QWORD *)(a1 + 376);
      if (v9 >= (*(_DWORD *)(v8 + 104) & 0x7FFFFFFFu))
        goto LABEL_27;
    }
  }
  v10 = 0;
  v11 = -1;
LABEL_27:
  _apfs_free(v7, *(unsigned int *)(v8 + 36));
  *a2 = v11;
  *a3 = v10;
  return 2 * (v10 == 0);
}

uint64_t nx_check_checkpoint_map_block(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int8x16_t a5, int8x16_t a6)
{
  int v10;
  unint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  int v24;
  unint64_t v25;
  unint64_t v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  int v34;

  v10 = obj_checksum_verify_phys((_QWORD *)a2, *(_DWORD *)(a1 + 36), a5, a6);
  v11 = *(unsigned int *)(a2 + 36);
  if (!(_DWORD)v11)
    return nx_corruption_detected_int(0);
  if (v10)
    v12 = 2;
  else
    v12 = 1;
  if (*(_DWORD *)(a2 + 24) == 1073741836)
    v13 = v10 != 0;
  else
    v13 = v12;
  if (*(_DWORD *)(a2 + 28))
    ++v13;
  if (*(_QWORD *)(a2 + 16) != *(_QWORD *)(a1 + 16))
    ++v13;
  v14 = *(_QWORD *)(a2 + 8) == a3 ? v13 : v13 + 1;
  v15 = *(unsigned int *)(a1 + 36);
  if (v11 > (v15 - 40) / 0x28uLL || v14 != -(*(_DWORD *)(a2 + 32) & 1 ^ (a4 != 0)))
    return nx_corruption_detected_int(0);
  v18 = 0;
  v19 = *(unsigned int *)(a1 + 108);
  v20 = a2 + 40;
  while (v11 != v18)
  {
    v21 = *(_DWORD *)(v20 + 4);
    if ((*(_DWORD *)v20 & 0xC0000000) == 0x80000000)
      v22 = 1;
    else
      v22 = 2;
    if ((unsigned __int16)*(_DWORD *)v20 > 0x17u || ((1 << *(_DWORD *)v20) & 0xC6002C) == 0)
      v24 = v22;
    else
      v24 = (*(_DWORD *)v20 & 0xC0000000) != 0x80000000;
    if ((v21 & 0xC0000000) != 0)
      ++v24;
    if (((unsigned __int16)*(_DWORD *)(v20 + 4) > 0x24u || ((1 << v21) & 0x100029CA01) == 0)
      && (unsigned __int16)*(_DWORD *)(v20 + 4) != 255)
    {
      ++v24;
    }
    if (!*(_QWORD *)(v20 + 24))
      ++v24;
    if ((v19 & 0x80000000) != 0)
    {
      v30 = v18;
    }
    else
    {
      v25 = *(_QWORD *)(v20 + 32);
      v26 = *(_QWORD *)(a1 + 120);
      if (v25 < v26)
        ++v24;
      if (v25 >= v26 + v19)
        ++v24;
      v27 = v25 - v26;
      v28 = *(_DWORD *)(a1 + 144);
      if (v28 <= v27)
        v29 = 0;
      else
        v29 = *(_DWORD *)(a1 + 108);
      v30 = v29 - v28 + v27;
      if (v30 >= *(_DWORD *)(a1 + 148))
        ++v24;
    }
    v31 = *(_DWORD *)(v20 + 8);
    if (v31)
      v32 = v24;
    else
      v32 = v24 + 1;
    v33 = v31 / v15;
    if (v31 % v15)
      v34 = -1;
    else
      v34 = 0;
    if (v32 == v34)
    {
      ++v18;
      v20 += 40;
      if (v33 <= *(_DWORD *)(a1 + 148) - v30)
        continue;
    }
    return nx_corruption_detected_int(0);
  }
  return 0;
}

BOOL nx_superblock_agrees_with_main_superblock(uint64_t a1, uint64_t a2, const char *a3, int a4)
{
  int v9;
  BOOL v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;

  if (*(_QWORD *)(a1 + 72) == *(_QWORD *)(a2 + 72) && *(_QWORD *)(a1 + 80) == *(_QWORD *)(a2 + 80))
  {
    v9 = 0;
  }
  else
  {
    log_err("%s:%d: %s<->superblock mismatch on uuid\n", "nx_superblock_agrees_with_main_superblock", 263, a3);
    v9 = 1;
  }
  v10 = *(_QWORD *)(a1 + 1280) == *(_QWORD *)(a2 + 1280) && *(_QWORD *)(a1 + 1287) == *(_QWORD *)(a2 + 1287);
  if (!v10 || (*(unsigned __int8 *)(a2 + 1295) ^ *(unsigned __int8 *)(a1 + 1295)) != a4)
  {
    log_err("%s:%d: %s<->superblock mismatch on fusion uuid, tier2=%d\n", "nx_superblock_agrees_with_main_superblock", 268, a3, a4);
    ++v9;
  }
  v11 = *(_QWORD *)(a1 + 16);
  if (v11 > *(_QWORD *)(a2 + 16))
    log_err("%s:%d: the %s superblock has a lower XID %lld than the main superblock %lld\n", "nx_superblock_agrees_with_main_superblock", 273, a3, *(_QWORD *)(a2 + 16), v11);
  v12 = *(_DWORD *)(a2 + 36);
  if (*(_DWORD *)(a1 + 36) != v12)
  {
    log_err("%s:%d: %s<->superblock mismatch on block size: %d %d\n", "nx_superblock_agrees_with_main_superblock", 279, a3, *(_DWORD *)(a1 + 36), v12);
    ++v9;
  }
  v13 = *(_QWORD *)(a2 + 40);
  if (*(_QWORD *)(a1 + 40) != v13)
  {
    log_err("%s:%d: %s<->superblock mismatch on block count: %lld %lld\n", "nx_superblock_agrees_with_main_superblock", 284, a3, *(_QWORD *)(a1 + 40), v13);
    ++v9;
  }
  v14 = *(_DWORD *)(a2 + 104);
  if (*(_DWORD *)(a1 + 104) != v14)
  {
    log_err("%s:%d: %s<->superblock mismatch on checkpoint descriptor block count: %d %d\n", "nx_superblock_agrees_with_main_superblock", 289, a3, *(_DWORD *)(a1 + 104), v14);
    ++v9;
  }
  v15 = *(_DWORD *)(a2 + 108);
  if (*(_DWORD *)(a1 + 108) != v15)
  {
    log_err("%s:%d: %s<->superblock mismatch on checkpoint data block count: %d %d\n", "nx_superblock_agrees_with_main_superblock", 294, a3, *(_DWORD *)(a1 + 108), v15);
    ++v9;
  }
  v16 = *(_QWORD *)(a2 + 112);
  if (*(_QWORD *)(a1 + 112) != v16)
  {
    log_err("%s:%d: %s<->superblock mismatch on checkpoint descriptor base address: %lld %lld\n", "nx_superblock_agrees_with_main_superblock", 299, a3, *(_QWORD *)(a1 + 112), v16);
    ++v9;
  }
  v17 = *(_QWORD *)(a2 + 120);
  if (*(_QWORD *)(a1 + 120) != v17)
  {
    log_err("%s:%d: %s<->superblock mismatch on checkpoint data base address: %lld %lld\n", "nx_superblock_agrees_with_main_superblock", 304, a3, *(_QWORD *)(a1 + 120), v17);
    v9 = 1;
  }
  return v9 == 0;
}

uint64_t nx_checkpoint_find_valid_checkpoint(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned int *a5)
{
  unsigned int v5;
  int v10;
  unsigned int v11;
  unsigned int v12;
  int8x16_t v13;
  int8x16_t v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  uint64_t result;
  unint64_t v19;
  int v20;
  _OWORD *v21;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;

  v24 = 0;
  v25 = 0;
  v23 = 0;
  *a5 = -1;
  v5 = *(_DWORD *)(a2 + 104) & 0x7FFFFFFF;
  if (!v5)
    return 2;
  v10 = 0;
  v11 = 0;
  v21 = (_OWORD *)(a1 + 424);
  while (1)
  {
    if (v10 && (*(_BYTE *)(a2 + 1264) & 2) != 0)
      return 35;
    v12 = (a3 + v5 + v10) % v5;
    v26 = -1;
    if (nx_checkpoint_desc_block_address(a1, v12, &v26)
      || dev_read(*(_QWORD *)(a1 + 384), v26))
    {
      log_err("%s:%d: %s couldn't read checkpoint descriptor block %d @ %lld: %d\n");
      goto LABEL_8;
    }
    if (*(_DWORD *)(a4 + 24) == -2147483647)
    {
      if (nx_check_superblock(a4, *(_DWORD *)(a2 + 36), 1, v13, v14))
      {
        log_err("%s:%d: %s checkpoint superblock %d @ %lld: failed sanity check: %d\n");
        goto LABEL_8;
      }
      if ((*(_QWORD *)(a2 + 64) & 0xFFFFFFFFFFFFFEFDLL) != 0)
      {
        log_err("%s:%d: %s unsupported nx_incompatible_features (0x%llx): unable to mount\n", "nx_checkpoint_find_valid_checkpoint", 505, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 64) & 0xFFFFFFFFFFFFFEFDLL);
        return 75;
      }
      if (nx_superblock_agrees_with_main_superblock(a2, a4, "checkpoint", 0))
        break;
    }
LABEL_8:
    ++v11;
    v5 = *(_DWORD *)(a2 + 104) & 0x7FFFFFFF;
    --v10;
    if (v11 >= v5)
      return 2 * (*a5 == -1);
  }
  v15 = *(_DWORD *)(a4 + 140);
  v16 = *(_DWORD *)(a2 + 104) & 0x7FFFFFFF;
  if (v12 != (*(_DWORD *)(a4 + 136) + v15 - 1) % v16)
  {
    log_err("%s:%d: %s xid %lld checkpoint superblock index %d doesn't match index block was found at: %d\n");
    goto LABEL_8;
  }
  if (v15 > v10 + v16)
  {
    log_err("%s:%d: %s xid %lld checkpoint superblock index %d doesn't fit in blocks remaining: %d > %d\n");
    goto LABEL_8;
  }
  if (nx_metadata_range_add((_QWORD *)a1, 0, 1, 0, 1)
    || (*(_BYTE *)(a4 + 65) & 1) != 0
    && (nx_metadata_range_add((_QWORD *)a1, 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(a1 + 376) + 36))), 1, 0, 1)|| (*(_BYTE *)(a4 + 65) & 1) != 0&& nx_metadata_range_add((_QWORD *)a1, *(_QWORD *)(*(_QWORD *)(a1 + 376) + 1368), *(_QWORD *)(*(_QWORD *)(a1 + 376) + 1376) & 0x7FFFFFFF, (*(_QWORD *)(*(_QWORD *)(a1 + 376) + 1376) & 0x80000000) != 0, 0))|| nx_metadata_range_add((_QWORD *)a1, *(_QWORD *)(a4 + 112), *(_DWORD *)(a4 + 104) & 0x7FFFFFFF, *(int *)(a4 + 104) < 0, 0)|| nx_metadata_range_add(
                       (_QWORD *)a1,
                       *(_QWORD *)(a4 + 120),
                       *(_DWORD *)(a4 + 108) & 0x7FFFFFFF,
                       *(int *)(a4 + 108) < 0,
                       0))
  {
    log_err("%s:%d: %s xid %lld at index %d failed to load checkpoint metadata ranges (overlap?): %d\n");
LABEL_21:
    obj_cache_reset(*(pthread_mutex_t **)(a1 + 392), 0);
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 720) = 0;
    *(_QWORD *)(a1 + 920) = 0;
    *(_QWORD *)(a1 + 1128) = 0;
    *(_QWORD *)(a1 + 1336) = 0;
    *(_BYTE *)(a1 + 635) = 0;
    *v21 = 0u;
    v21[1] = 0u;
    v21[2] = 0u;
    goto LABEL_8;
  }
  if (nx_checkpoint_validate_checkpoint_map_blocks(a1, (unsigned int *)a4))
  {
    log_err("%s:%d: %s xid %lld validation failed for checkpoint at index %d: %d\n");
    goto LABEL_21;
  }
  v17 = nx_checkpoint_load_data(a1, a4, &v25, &v24);
  if (v17)
  {
    log_err("%s:%d: %s xid %lld data for checkpoint at index %d couldn't be loaded: %d\n", "nx_checkpoint_find_valid_checkpoint", 572, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a4 + 16), *(_DWORD *)(a4 + 136), v17);
    nx_obj_cache_reset(a1);
    goto LABEL_8;
  }
  memcpy(*(void **)(a1 + 376), (const void *)a4, *(unsigned int *)(a2 + 36));
  *(_QWORD *)(*(_QWORD *)(a1 + 392) + 400) = *(_QWORD *)(*(_QWORD *)(a1 + 376) + 88);
  if (nx_checkpoint_traverse(a1, 0, 2))
  {
    log_err("%s:%d: %s xid %lld failed to fix up checkpoint data: %d\n");
LABEL_46:
    nx_obj_cache_reset(a1);
    memcpy(*(void **)(a1 + 376), (const void *)a2, *(unsigned int *)(a2 + 36));
    *(_QWORD *)(*(_QWORD *)(a1 + 392) + 400) = *(_QWORD *)(*(_QWORD *)(a1 + 376) + 88);
    goto LABEL_8;
  }
  if (*(_BYTE *)(a1 + 628))
  {
    if (*(_BYTE *)(a1 + 631))
    {
      log_info("%s:%d: %s probe of external device... skipping recent sanity checks.\n", "nx_checkpoint_find_valid_checkpoint", 599, (const char *)(*(_QWORD *)(a1 + 384) + 208));
    }
    else
    {
      log_info("%s:%d: %s sanity checking all recently-changed container state... please be patient.\n", "nx_checkpoint_find_valid_checkpoint", 608, (const char *)(*(_QWORD *)(a1 + 384) + 208));
      if (nx_check_recent_sanity((_QWORD *)a1))
      {
        log_err("%s:%d: %s xid %lld sanity check of recently-changed structures failed: %d\n");
        goto LABEL_46;
      }
    }
  }
  if (spaceman_get((_QWORD *)a1, (uint64_t *)&v23))
  {
    log_err("%s:%d: %s xid %lld failed to get spaceman: %d\n");
    goto LABEL_46;
  }
  if (nx_metadata_range_add((_QWORD *)a1, *(_QWORD *)(v23[47] + 168), *(_DWORD *)(v23[47] + 164) & 0x7FFFFFFF, *(int *)(v23[47] + 164) < 0, 0))
  {
    obj_release(v23);
LABEL_45:
    log_err("%s:%d: %s xid %lld failed to load spaceman metadata ranges (overlap?): %d\n");
    goto LABEL_46;
  }
  v20 = nx_metadata_range_add((_QWORD *)a1, *(_QWORD *)(v23[47] + 176), *(_QWORD *)(v23[47] + 152), *(uint64_t *)(v23[47] + 152) < 0, 0);
  obj_release(v23);
  if (v20)
    goto LABEL_45;
  v19 = *(_QWORD *)(*(_QWORD *)(a1 + 376) + 16);
  if (v19 < v25)
    log_err("%s:%d: %s warning: best valid checkpoint xid %lld is less than max free queue oldest xid %lld seen in checkpoint %lld\n", "nx_checkpoint_find_valid_checkpoint", 646, (const char *)(*(_QWORD *)(a1 + 384) + 208), v19, v25, v24);
  result = 0;
  *a5 = v12;
  return result;
}

uint64_t nx_checkpoint_validate_checkpoint_map_blocks(uint64_t a1, unsigned int *a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int8x16_t v9;
  int8x16_t v10;
  uint64_t v12;

  v4 = _apfs_malloc(a2[9]);
  if (!v4)
    return 12;
  v5 = v4;
  v12 = 0;
  if (a2[35] == 1)
  {
LABEL_3:
    v6 = 0;
  }
  else
  {
    v7 = 0;
    while (1)
    {
      v8 = nx_checkpoint_desc_block_address(a1, (v7 + a2[34]) % (a2[26] & 0x7FFFFFFF), &v12);
      if ((_DWORD)v8)
        break;
      v8 = dev_read(*(_QWORD *)(a1 + 384), v12);
      if ((_DWORD)v8)
        break;
      v8 = nx_check_checkpoint_map_block((uint64_t)a2, (uint64_t)v5, v12, v7 == a2[35] - 2, v9, v10);
      if ((_DWORD)v8)
        break;
      if (++v7 >= a2[35] - 1)
        goto LABEL_3;
    }
    v6 = v8;
  }
  _apfs_free(v5, a2[9]);
  return v6;
}

uint64_t nx_checkpoint_load_data(uint64_t a1, uint64_t a2, unint64_t *a3, _QWORD *a4)
{
  size_t v6;
  _DWORD *v7;
  _DWORD *v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unint64_t v12;
  int8x16_t v13;
  int8x16_t v14;
  unint64_t v15;
  char *v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  int v27;
  _QWORD *v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  int v33;
  char *v34;
  int v35;
  unsigned int v36;
  int v38;
  unint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45[3];

  v6 = *(unsigned int *)(*(_QWORD *)(a1 + 376) + 36);
  v42 = 0;
  v7 = _apfs_malloc(v6);
  if (v7)
  {
    v8 = v7;
    v45[0] = 0;
    v43 = 0;
    v44 = 0;
    v40 = 0;
    v41 = 0;
    if (*(_DWORD *)(a2 + 140) - 1 < 1)
    {
LABEL_28:
      _apfs_free(v8, v6);
      return 0;
    }
    else
    {
      v9 = 0;
      v10 = *(_DWORD *)(a2 + 144);
      v11 = *(_DWORD *)(a2 + 136);
      v38 = v6 - 1;
      v34 = (char *)(v7 + 10);
      v33 = *(_DWORD *)(a2 + 140) - 1;
      while (1)
      {
        v41 = 0;
        v12 = nx_checkpoint_desc_block_address(a1, v11, &v41);
        if ((_DWORD)v12
          || (v12 = dev_read(*(_QWORD *)(a1 + 384), v41), (_DWORD)v12)
          || (v12 = obj_checksum_verify_phys(v8, v6, v13, v14), (_DWORD)v12))
        {
          v31 = v12;
          log_err("%s:%d: %s couldn't read checkpoint descriptor map block %d @ %lld: %d\n");
LABEL_39:
          _apfs_free(v8, v6);
LABEL_40:
          obj_cache_reset(*(pthread_mutex_t **)(a1 + 392), 0);
          *(_QWORD *)(a1 + 408) = 0;
          *(_QWORD *)(a1 + 720) = 0;
          *(_QWORD *)(a1 + 920) = 0;
          *(_QWORD *)(a1 + 1128) = 0;
          *(_QWORD *)(a1 + 1336) = 0;
          *(_BYTE *)(a1 + 635) = 0;
          *(_OWORD *)(a1 + 424) = 0u;
          *(_OWORD *)(a1 + 440) = 0u;
          *(_OWORD *)(a1 + 456) = 0u;
          return v31;
        }
        v36 = v11;
        v35 = v9;
        if (v8[9])
          break;
LABEL_27:
        v11 = (v36 + 1) % (*(_DWORD *)(a2 + 104) & 0x7FFFFFFFu);
        v9 = v35 + 1;
        if (v35 + 1 == v33)
          goto LABEL_28;
      }
      v15 = 0;
      v16 = v34;
      while (1)
      {
        v17 = *((_DWORD *)v16 + 2);
        v41 = 0;
        v18 = nx_checkpoint_data_block_address(a1, v10, &v41, &v40);
        if ((_DWORD)v18)
        {
          v31 = v18;
          log_err("%s:%d: %s couldn't read checkpoint data block %d @ %lld: %d\n", "nx_checkpoint_load_data", 396, (const char *)(*(_QWORD *)(a1 + 384) + 208), v10, v41, v18);
          goto LABEL_39;
        }
        if (v41 != *((_QWORD *)v16 + 4))
          break;
        v19 = *(_DWORD *)(a2 + 144);
        v20 = v10;
        if (v10 < v19)
          v20 = (*(_DWORD *)(a2 + 108) & 0x7FFFFFFF) + v10;
        v21 = v20 - v19;
        v22 = *(_DWORD *)(a2 + 148);
        v23 = (v38 + v17) / v6;
        if (v21 >= v22 || v21 + v23 > v22)
        {
          log_err("%s:%d: %s checkpoint mapping (%d,%d) extends beyond checkpoint data range: %d,%d\n", "nx_checkpoint_load_data", 412, (const char *)(*(_QWORD *)(a1 + 384) + 208), v21, (v38 + v17) / v6, *(_DWORD *)(a2 + 144), v22);
          goto LABEL_34;
        }
        v45[0] = 0x80000000;
        v24 = obj_descriptor_and_flags_for_type(*(_DWORD *)v16, v45, (uint64_t)&v43);
        HIDWORD(v43) = *((_DWORD *)v16 + 1);
        LODWORD(v44) = v17;
        if ((_DWORD)v24)
        {
          v31 = v24;
LABEL_38:
          log_err("%s:%d: %s failed to load checkpoint data of type 0x%x:0x%x @ %lld\n");
          goto LABEL_39;
        }
        v25 = obj_checkpoint_get(*(pthread_mutex_t **)(a1 + 392), v45[0], *((_QWORD *)v16 + 3), (uint64_t)&v43, v41, v10, v40, *(_QWORD *)(a2 + 16), (uint64_t *)&v42);
        if ((_DWORD)v25)
        {
          v31 = v25;
          goto LABEL_38;
        }
        if (a3)
        {
          v26 = v42;
          if (!*a4)
          {
            v27 = obj_type((uint64_t)v42);
            v26 = v42;
            if (v27 == 5)
            {
              v28 = (_QWORD *)v42[7];
              v29 = v28[32];
              if (v29 <= v28[27])
                v29 = v28[27];
              *a3 = v29;
              v30 = v28[37];
              if (v30 <= v29)
                v30 = v29;
              *a3 = v30;
              *a4 = *(_QWORD *)(a2 + 16);
            }
          }
        }
        else
        {
          v26 = v42;
        }
        obj_release(v26);
        v10 = (v23 + v10) % (*(_DWORD *)(a2 + 108) & 0x7FFFFFFFu);
        ++v15;
        v16 += 40;
        if (v15 >= v8[9])
          goto LABEL_27;
      }
      log_err("%s:%d: %s unexpected checkpoint map entry address: 0x%llx, expected 0x%llx\n", "nx_checkpoint_load_data", 401, (const char *)(*(_QWORD *)(a1 + 384) + 208), *((_QWORD *)v16 + 4), v41);
LABEL_34:
      v31 = nx_corruption_detected_int(0);
      _apfs_free(v8, v6);
      if ((_DWORD)v31)
        goto LABEL_40;
    }
  }
  else
  {
    log_err("%s:%d: %s couldn't allocate memory for checkpoint map block\n", "nx_checkpoint_load_data", 367, (const char *)(*(_QWORD *)(a1 + 384) + 208));
    return 12;
  }
  return v31;
}

uint64_t nx_dev_init(int *a1, char *a2, int a3, int a4, char a5, uint64_t a6, char a7, const char **a8, _QWORD *a9)
{
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  unint64_t v16;
  unsigned int *v17;
  uint64_t v18;
  int8x16_t v19;
  int8x16_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v25;
  uint64_t v26;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  const char **v31;
  int *v32;
  const char *v33;

  v32 = 0;
  v33 = 0;
  if (a4)
  {
    v31 = a8;
    v11 = 0;
    v12 = 0;
    v33 = (const char *)a1;
    goto LABEL_3;
  }
  if ((a5 & 1) != 0)
    return 45;
  v25 = dev_init((char *)a1, a3, (int **)&v33);
  if ((_DWORD)v25)
  {
    v21 = v25;
    log_err("%s:%d: device initialization failed: %d\n", "nx_dev_init", 727, v25);
LABEL_43:
    if (v33)
      dev_close((uint64_t)v33);
    if (v32)
      dev_close((uint64_t)v32);
    return v21;
  }
  if (a2)
  {
    v26 = dev_init(a2, a3, &v32);
    if ((_DWORD)v26)
    {
      v21 = v26;
      log_err("%s:%d: tier2 device initialization failed: %d\n", "nx_dev_init", 732, v26);
      goto LABEL_43;
    }
  }
  v31 = a8;
  if (v32)
  {
    v12 = dev_block_size((uint64_t)v32);
    if (v32)
      v11 = dev_block_count((uint64_t)v32);
    else
      v11 = 0;
  }
  else
  {
    v11 = 0;
    v12 = 0;
  }
LABEL_3:
  v13 = dev_block_size((uint64_t)v33);
  v14 = dev_block_count((uint64_t)v33);
  if (v13 <= 0x1000)
    v15 = 4096;
  else
    v15 = v13;
  v16 = v11 * v12 + v14 * v13;
  while (1)
  {
    if (v15 % v13)
    {
      log_err("%s:%d: %s block size %d is not an even multiple of device block size %d\n");
LABEL_42:
      v21 = 22;
      goto LABEL_43;
    }
    if (v15 > v13)
      dev_set_block_size((uint64_t)v33);
    v17 = (unsigned int *)_apfs_malloc(v15);
    if (!v17)
    {
      log_err("%s:%d: %s couldn't allocate memory for superblock of size %d\n", "nx_dev_init", 769, v33 + 208, v15);
      v21 = 12;
      goto LABEL_43;
    }
    v18 = dev_read((uint64_t)v33, 0);
    if ((_DWORD)v18)
    {
      v21 = v18;
      log_err("%s:%d: %s couldn't read superblock of size %d\n");
LABEL_37:
      _apfs_free(v17, v15);
      goto LABEL_43;
    }
    v21 = nx_check_superblock((uint64_t)v17, v15, 0, v19, v20);
    if ((_DWORD)v21)
      goto LABEL_13;
    if (v17[9] % v13)
    {
      log_err("%s:%d: %s superblock block size %d not an even multiple of device block size %d\n", "nx_dev_init", 785, v33 + 208, v17[9], v13);
      v21 = nx_corruption_detected_int(0);
      if ((a7 & 1) != 0)
        goto LABEL_13;
    }
    else
    {
      v21 = 0;
      if ((a7 & 1) != 0)
        goto LABEL_13;
    }
    if (!(_DWORD)v21)
    {
      v22 = v17[9];
      if (*((_QWORD *)v17 + 5) * v22 <= v16)
        goto LABEL_15;
      log_err("%s:%d: %s superblock container size %lld greater than device size(s) %lld\n", "nx_dev_init", 791, v33 + 208, *((_QWORD *)v17 + 5) * v22, v16);
      v21 = nx_corruption_detected_int(0);
    }
LABEL_13:
    if ((_DWORD)v21)
    {
      if ((_DWORD)v21 != 79)
        log_err("%s:%d: %s superblock failed sanity checks: %d\n");
      goto LABEL_37;
    }
    LODWORD(v22) = v17[9];
LABEL_15:
    if ((_DWORD)v22 == v15)
      break;
    _apfs_free(v17, v15);
    dev_set_block_size((uint64_t)v33);
    v15 = v22;
    if (v22 < v13)
    {
      log_err("%s:%d: %s container block size too small for device block size (%d < %d)\n");
      goto LABEL_42;
    }
  }
  if (v32)
  {
    if (v15 < v12)
    {
      log_err("%s:%d: %s container block size too small for tier2 device block size (%d < %d)\n", "nx_dev_init", 816, v33 + 208, v15, v12);
LABEL_41:
      v21 = 22;
      goto LABEL_37;
    }
    if (v15 > dev_block_size((uint64_t)v32))
      dev_set_block_size((uint64_t)v32);
    v28 = dev_set_tier2_device((uint64_t)v33, (uint64_t)v32, 0x4000000000000000uLL >> __clz(__rbit64(v15)));
    if ((_DWORD)v28)
    {
      v21 = v28;
      log_err("%s:%d: %s failed to set tier2 device: %d\n", "nx_dev_init", 824, v33 + 208, v28);
      goto LABEL_37;
    }
    v32 = 0;
  }
  if ((*((_BYTE *)v17 + 65) & 1) != 0 && (a7 & 1) == 0)
  {
    v29 = _apfs_malloc(v15);
    if (!v29)
    {
      log_err("%s:%d: %s couldn't allocate memory for superblock of size %d\n", "nx_dev_init", 842, v33 + 208, v15);
      v21 = 12;
      goto LABEL_37;
    }
    v30 = dev_read((uint64_t)v33, 0x4000000000000000uLL >> __clz(__rbit64(v15)));
    if ((_DWORD)v30)
    {
      v21 = v30;
      log_err("%s:%d: %s couldn't read tier2 device superblock of size %d\n", "nx_dev_init", 848, v33 + 208, v15);
      _apfs_free(v29, v15);
      goto LABEL_37;
    }
    if (!nx_superblock_agrees_with_main_superblock((uint64_t)v17, (uint64_t)v29, "tier2", 1))
    {
      log_err("%s:%d: %s tier2 device superblock doesn't agree with main superblock\n", "nx_dev_init", 853, v33 + 208);
      _apfs_free(v29, v15);
      goto LABEL_41;
    }
    _apfs_free(v29, v15);
  }
  v21 = 0;
  *a9 = v17;
  *v31 = v33;
  return v21;
}

uint64_t nx_mount(int *a1, uint64_t a2, uint64_t **a3)
{
  unsigned int v4;
  uint64_t v5;
  int v6;
  int16x4_t v7;
  int16x4_t v8;
  int v9;
  char *v10;
  char v11;
  _BOOL4 v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  _BOOL4 v17;
  unsigned int v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t *v21;
  _BOOL4 v22;
  int v23;
  uint64_t v24;
  int *v25;
  _BOOL4 v26;
  uint64_t v27;
  const char *v29;
  int v30;
  int is_external;
  unsigned int v32;
  _QWORD *v33;
  size_t v34;
  BOOL v35;
  int v36;
  unsigned int v37;
  int v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  pthread_mutex_t *v44;
  uint64_t bootstrap;
  uint64_t v46;
  uint64_t *v47;
  int64x2_t *v48;
  uint64_t v49;
  int v50;
  int v51;
  __int8 v52;
  uint64_t *v53;
  char v54;
  uint64_t *v55;
  int v56;
  unsigned int v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  const void *v61;
  uint64_t highest_xid;
  const void *v63;
  uint64_t valid_checkpoint;
  uint64_t v65;
  uint64_t *v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  int8x16_t v70;
  int8x16_t v71;
  uint64_t v72;
  int8x16_t v73;
  int8x16_t v74;
  unint64_t v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t *v79;
  uint64_t data;
  uint64_t *v81;
  uint64_t *v82;
  uint64_t v83;
  const char *v84;
  int v85;
  uint64_t *v86;
  uint64_t *v87;
  uint64_t *v88;
  uint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  int8x16_t v92;
  int8x16_t v93;
  int v94;
  int8x16_t v95;
  int8x16_t v96;
  uint64_t *v97;
  uint64_t v98;
  _BYTE *v99;
  uint64_t v100;
  uint64_t v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t *v104;
  _BOOL4 v105;
  __int8 v106;
  int v107;
  char v108;
  uint64_t v109;
  char v110;
  char v111;
  uint64_t **v112;
  int v113;
  int v114;
  int v115;
  int v116;
  int8x8_t __n;
  uint64_t __na;
  uint64_t v119;
  unsigned int v120;
  unint64_t v121;
  unsigned int v122;
  pthread_cond_t **v123;
  unsigned int *v124;
  uint64_t *v125;
  pthread_mutex_t *v126;
  const char *v127;
  _OWORD v128[6];
  uint64_t v129;

  v129 = *MEMORY[0x1E0C80C00];
  v126 = 0;
  v127 = 0;
  memset(v128, 0, sizeof(v128));
  v124 = 0;
  v125 = 0;
  v123 = 0;
  v119 = 0;
  *a3 = 0;
  if (a2)
  {
    v4 = *(unsigned __int16 *)(a2 + 8);
    v5 = *(unsigned int *)(a2 + 4);
    v6 = *(_DWORD *)a2 & 1;
    v7 = vdup_n_s16(v4);
    v8 = (int16x4_t)vand_s8((int8x8_t)v7, (int8x8_t)0x2000100001000004);
    if ((v4 & 8) != 0)
    {
      v10 = *(char **)(a2 + 16);
      v9 = (v4 >> 6) & 1;
    }
    else
    {
      LOBYTE(v9) = 0;
      v10 = 0;
    }
    v17 = (v4 & 0x4000 | v6) != 0;
    if ((vtst_s16(v8, v8).i8[6] & 1) != 0 && (v5 & 0x80000000) == 0)
    {
      log_err("%s:%d: conflicting mount options: load from temporary checkpoint AND checkpoint descriptor index %d\n");
LABEL_11:
      v18 = 0;
      v19 = 0;
      v20 = 22;
      goto LABEL_12;
    }
    if ((v4 & 0xC00) == 0x800)
    {
      log_err("%s:%d: conflicting mount options: is_system_graft but not is_graft\n");
      goto LABEL_11;
    }
    v112 = a3;
    v110 = v4 & 1;
    v13 = (v4 >> 1) & 1;
    __n = (int8x8_t)vtst_s16(v7, (int16x4_t)0x2000100001000004);
    v113 = (v4 >> 5) & 1;
    v14 = (v4 >> 9) & 1;
    v22 = (v4 & 0xC00) != 0;
    v115 = (v4 >> 11) & 1;
    crc32c_init();
    v12 = v22;
    if (v17)
      v23 = 16;
    else
      v23 = 32;
    v15 = (v23 | (2 * v6)) ^ 2;
    v24 = v5;
    v11 = v110;
    v16 = v24;
  }
  else
  {
    v112 = a3;
    crc32c_init();
    v6 = 0;
    v11 = 0;
    v113 = 0;
    v12 = 0;
    v115 = 0;
    v13 = 0;
    LOBYTE(v9) = 0;
    v14 = 0;
    v10 = 0;
    __n = 0;
    v15 = 34;
    v16 = 0xFFFFFFFFLL;
  }
  v122 = 0;
  v121 = 0;
  v120 = 0;
  v25 = a1;
  v26 = v12;
  v27 = nx_dev_init(v25, v10, v15, v13, v12, 0, v9, &v127, &v124);
  if ((_DWORD)v27)
  {
    v20 = v27;
    if ((_DWORD)v27 != 79)
      log_err("%s:%d: device initialization failed: %d\n", "nx_mount", 1104, v27);
    return v20;
  }
  v105 = v26;
  v111 = v11;
  v29 = v127;
  if (dev_is_writable((uint64_t)v127))
    v30 = v6;
  else
    v30 = 1;
  v107 = v30;
  is_external = dev_is_external((uint64_t)v29);
  v32 = dev_real_block_size((uint64_t)v29);
  v33 = v124;
  v34 = v124[9];
  v35 = v14 == 0;
  v36 = 0x8000;
  if (v14)
    v37 = 128;
  else
    v37 = 0x8000;
  v38 = 0x10000;
  if (v35)
    v39 = 0x10000;
  else
    v39 = 128;
  if (!v35)
  {
    v38 = 128;
    v36 = 128;
  }
  log_debug("%s:%d: %s initializing cache w/hash_size %u and cache size %u\n", "nx_mount", 1285, v29 + 208, v36, v38);
  v40 = v39;
  v18 = v34;
  v41 = obj_cache_create(v37, v40, v34, &v126);
  if ((_DWORD)v41)
  {
    v42 = v41;
    log_err("%s:%d: %s object cache initialization failed: %d\n", "nx_mount", 1289, v29 + 208, v41);
    v19 = 0;
    v20 = v42;
    goto LABEL_12;
  }
  v43 = (uint64_t)v33;
  v44 = v126;
  if (v115)
    *(_QWORD *)&v126[14].__opaque[16] = 1;
  memset((char *)&v128[3] + 8, 0, 40);
  *(_OWORD *)((char *)&v128[2] + 8) = 0u;
  memset((char *)v128 + 8, 0, 32);
  *(_QWORD *)&v128[0] = __PAIR64__(v34, v32);
  *((_QWORD *)&v128[0] + 1) = v33[5];
  *((_QWORD *)&v128[1] + 1) = v29;
  *(_QWORD *)&v128[2] = 1;
  DWORD2(v128[2]) = v107;
  HIDWORD(v128[2]) = is_external != 0;
  v128[3] = vmovl_u16((uint16x4_t)vand_s8(__n, (int8x8_t)0x1000100010001));
  bootstrap = obj_create_bootstrap(v44, 0x80000000, 1uLL, (uint64_t)&nx_desc, (uint64_t)v128, v34, 1, (uint64_t *)&v125);
  v46 = v16;
  if ((_DWORD)bootstrap)
  {
    v20 = bootstrap;
    log_err("%s:%d: %s object cache bootstrap failed: %d\n");
LABEL_47:
    v19 = 0;
    goto LABEL_12;
  }
  v47 = v125;
  if (v113)
    *((_BYTE *)v125 + 642) = 1;
  memcpy((void *)v47[47], v33, v34);
  v48 = (int64x2_t *)v126;
  v49 = v125[47];
  *(_QWORD *)v126[6].__opaque = v125;
  v48[25].i64[0] = *(_QWORD *)(v49 + 88);
  __strlcpy_chk();
  obj_mem_mgr_register((int64x2_t *)v126, v105 & (v115 ^ 1));
  v126 = 0;
  v127 = 0;
  v50 = *(_DWORD *)(v49 + 104);
  if (v50 < 0
    && (v20 = nx_metadata_fragmented_sanity_check((uint64_t)v125, *(_QWORD *)(v49 + 112), v50 & 0x7FFFFFFF), (_DWORD)v20)
    || (v51 = *(_DWORD *)(v49 + 108), v51 < 0)
    && (v20 = nx_metadata_fragmented_sanity_check((uint64_t)v125, *(_QWORD *)(v49 + 120), v51 & 0x7FFFFFFF), (_DWORD)v20))
  {
    log_err("%s:%d: %s fragmented checkpoint area failed sanity check: %d\n");
    goto LABEL_47;
  }
  v19 = _apfs_malloc(v34);
  if (!v19)
  {
    log_err("%s:%d: %s failed to allocate buffer for checkpoint superblock\n", "nx_mount", 1394, (const char *)(v125[48] + 208));
    v20 = 12;
    goto LABEL_12;
  }
  v52 = __n.i8[2];
  if ((*(_BYTE *)(v49 + 1264) & 2) == 0)
    goto LABEL_57;
  v53 = v125;
  *((_BYTE *)v125 + 626) = 1;
  if (*((_BYTE *)v53 + 628))
  {
    log_err("%s:%d: %s storage is untrusted. Container cleanly-unmounted flag ignored\n", *(double *)&__n);
  }
  else if (*(_DWORD *)(v49 + 140))
  {
    if (*(_DWORD *)(v49 + 148))
      goto LABEL_57;
    log_err("%s:%d: %s checkpoint data length is bad.  Container cleanly-unmounted flag ignored\n", *(double *)&__n);
  }
  else
  {
    log_err("%s:%d: %s checkpoint descriptor length is bad.  Container cleanly-unmounted flag ignored\n", *(double *)&__n);
  }
  *(_QWORD *)(v49 + 1264) &= ~2uLL;
  v33[158] &= ~2uLL;
  v52 = __n.i8[2];
LABEL_57:
  v116 = 0;
  __na = v34;
  v54 = 0;
  v114 = 0;
  v106 = v52;
  v108 = 0;
  while (1)
  {
    v55 = v125;
    if ((*(_BYTE *)(v49 + 1264) & 2) != 0)
      break;
    if (((*((_BYTE *)v125 + 633) != 0) & v54) != 0)
    {
      v56 = 1;
      goto LABEL_62;
    }
    highest_xid = nx_checkpoint_find_highest_xid((uint64_t)v125, (int *)&v120, &v121);
    if ((_DWORD)highest_xid)
    {
      v20 = highest_xid;
      log_err("%s:%d: %s failed to scan checkpoint descriptor area for largest xid: %d\n");
      goto LABEL_146;
    }
LABEL_66:
    if ((v46 & 0x80000000) == 0)
    {
      v60 = v46;
      v61 = (const void *)v43;
      goto LABEL_75;
    }
    v63 = (const void *)v43;
    valid_checkpoint = nx_checkpoint_find_valid_checkpoint((uint64_t)v125, v43, v120, (uint64_t)v19, &v122);
    v20 = valid_checkpoint;
    if ((_DWORD)valid_checkpoint == 35)
    {
      if ((*(_BYTE *)(v49 + 1264) & 2) == 0)
        goto LABEL_124;
      log_err("%s:%d: %s Couldn't load checkpoint from cleanly-unmounted state.  Falling back to descriptor scan.\n", "nx_mount", 1618, (const char *)(v125[48] + 208));
      *(_QWORD *)(v49 + 1264) &= ~2uLL;
      *(_QWORD *)(v43 + 1264) &= ~2uLL;
    }
    else
    {
      if ((_DWORD)valid_checkpoint)
      {
LABEL_124:
        log_err("%s:%d: %s failed to find valid checkpoint: %d\n", "nx_mount", 1623, (const char *)(v125[48] + 208), valid_checkpoint);
        goto LABEL_146;
      }
      v109 = v19[2];
      log_debug("%s:%d: %s checkpoint search: largest xid %lld, best xid %lld @ %d\n", "nx_mount", 1627, (const char *)(v125[48] + 208), v121, v109, v122);
      v65 = *(_QWORD *)(v43 + 16);
      v66 = v125;
      if (v65 != v19[2])
      {
        log_err("%s:%d: %s reloading after unclean unmount, checkpoint xid %lld, superblock xid %lld\n", "nx_mount", 1629, (const char *)(v125[48] + 208), v19[2], v65);
        v66 = v125;
        if (!*((_BYTE *)v125 + 633))
        {
          v108 = 1;
          *((_BYTE *)v125 + 645) = 1;
        }
      }
LABEL_113:
      v83 = *(_QWORD *)(v66[47] + 56);
      if (v83)
      {
        log_debug("%s:%d: %s unsupported nx_readonly_compatible_features (0x%llx): mount r/o\n", "nx_mount", 1640, (const char *)(v66[48] + 208), v83);
        v66 = v125;
        *((_BYTE *)v125 + 627) = 1;
      }
      obj_checkpoint_check_for_unknown(v66[49]);
      v84 = (const char *)v125;
      if (((*((_BYTE *)v125 + 633) != 0) & v54) != 0)
      {
        v85 = 1;
      }
      else
      {
        v114 = *((_DWORD *)v19 + 36);
        v116 = *((_DWORD *)v19 + 34);
        log_debug("%s:%d: %s stable checkpoint indices: desc %d data %d\n", "nx_mount", 1654, (const char *)(v125[48] + 208), v116, v114);
        v84 = (const char *)v125;
        v85 = *((unsigned __int8 *)v125 + 633);
      }
      if ((v85 == 0) | v54 & 1)
      {
        *(_QWORD *)(v49 + 136) = 0;
        *(_QWORD *)(v49 + 144) = 0;
        *(_QWORD *)(v49 + 1264) &= ~2uLL;
        nx_metadata_range_optimize(v84);
        v87 = v125;
        if (*((_BYTE *)v125 + 629))
        {
          v20 = spaceman_get(v125, (uint64_t *)&v123);
          if ((_DWORD)v20)
          {
LABEL_137:
            log_err("%s:%d: %s failed to set up spaceman for demo mode: %d\n");
            goto LABEL_146;
          }
          obj_cache_lock_write((pthread_mutex_t *)v125[49]);
          v88 = v125 + 52;
          v125[52] = 0;
          v20 = obj_clone(v123, 0, v88, 0);
          obj_cache_unlock_write(v125[49]);
          if ((_DWORD)v20)
          {
            obj_release((uint64_t *)v123);
            goto LABEL_137;
          }
          obj_ephemeral_set_persistent(v125[52], 0);
          obj_release((uint64_t *)v123);
          v87 = v125;
        }
        v89 = v109 + 1;
        v20 = tx_mgr_init((uint64_t)v87, v109 + 1, v87 + 50);
        v90 = v125;
        if ((_DWORD)v20)
        {
          log_err("%s:%d: %s tx manager initialization failed: %d\n");
          goto LABEL_146;
        }
        v91 = v125[50];
        *(_DWORD *)(v91 + 104) = v116;
        *(_DWORD *)(v91 + 108) = v114;
        if ((v111 & 1) == 0)
        {
          log_info("%s:%d: %s sanity checking all container state... please be patient.\n", "nx_mount", 1711, (const char *)(v90[48] + 208));
          v20 = nx_check(v125, 0);
          v90 = v125;
          if ((_DWORD)v20)
          {
            log_err("%s:%d: %s failed nx_check sanity: %d\n");
            goto LABEL_146;
          }
        }
        if (*((_BYTE *)v90 + 627))
        {
LABEL_180:
          _apfs_free(v19, __na);
          v104 = v125;
          if (*(_QWORD *)(v125[47] + 1248))
          {
            if (!*((_BYTE *)v125 + 627))
            {
              v20 = nx_unblock_physical_range(v125);
              v104 = v125;
              if ((_DWORD)v20)
              {
                log_err("%s:%d: %s nx_unblock_physical_range failed with error: %d\n", "nx_mount", 1845, (const char *)(v125[48] + 208), v20);
                v19 = 0;
                goto LABEL_146;
              }
            }
          }
          *v112 = v104;
          if (v124)
            _apfs_free(v124, v124[9]);
          return 0;
        }
        if (*((_BYTE *)v90 + 633)
          || *((_BYTE *)v90 + 632)
          && (log_info("%s:%d: %s Enabling temporary checkpoints starting with xid %lld.\n", "nx_mount", 1723, (const char *)(v90[48] + 208), v89), v90 = v125, *(_QWORD *)(v125[47] + 1408) = v89, *((_BYTE *)v90 + 633)))
        {
          if (!*((_BYTE *)v90 + 632))
          {
            log_info("%s:%d: %s Making temporary checkpoint %lld permanent (start %lld).\n", "nx_mount", 1731, (const char *)(v90[48] + 208), *(_QWORD *)(v90[47] + 16), *(_QWORD *)(v90[47] + 1408));
            v19[176] = 0;
            obj_checksum_set_phys((uint64_t)v125, (uint64_t)v19, v18, v92, v93);
            if (v119)
            {
              v20 = dev_write(v125[48], v119);
              if (!(_DWORD)v20)
              {
                v20 = tx_barrier((uint64_t)v125, 0x10u);
                if (!(_DWORD)v20)
                {
                  v90 = v125;
                  *(_QWORD *)(v125[47] + 1408) = 0;
                  v108 = 1;
                  goto LABEL_169;
                }
              }
            }
            else
            {
              v20 = 22;
            }
            log_err("%s:%d: %s failed to write superblock to block %lld: %d\n");
            goto LABEL_146;
          }
        }
LABEL_169:
        v94 = spaceman_allocation_init(v90);
        if (v94)
          log_err("%s:%d: %s failed to set up sm allocation metadata: %d\n", "nx_mount", 1757, (const char *)(v125[48] + 208), v94);
        v97 = v125;
        if ((v108 & 1) != 0)
        {
          obj_checksum_set((uint64_t)v125, v95, v96);
          v98 = dev_write(v125[48], 0);
          v97 = v125;
          if ((_DWORD)v98)
          {
            v20 = v98;
            log_err("%s:%d: %s failed to write superblock to block 0: %d\n");
            goto LABEL_146;
          }
          v99 = (_BYTE *)v125[47];
          if ((v99[65] & 1) != 0)
          {
            v100 = nx_fusion_superblock_write((uint64_t)v125, v99);
            v97 = v125;
            if ((_DWORD)v100)
            {
              v20 = v100;
              log_err("%s:%d: %s failed to write superblock to fusion tier2 device block 0: %d\n");
              goto LABEL_146;
            }
          }
        }
        v101 = v97[47];
        v102 = *(_QWORD *)(v101 + 1384);
        v103 = apfs_source_version_val_full();
        if (v102 < v103)
          *(_QWORD *)(v101 + 1384) = v103;
        nx_mount_initiate_free_space_trims(v97);
        nx_reaper_check_for_work(v125);
        goto LABEL_180;
      }
      nx_obj_cache_reset((uint64_t)v84);
      memcpy((void *)v125[47], v63, v34);
      v54 = 1;
    }
  }
  log_info("%s:%d: %s container cleanly-unmounted flag set.\n", "nx_mount", 1428, (const char *)(v125[48] + 208));
  v55 = v125;
  v56 = *((unsigned __int8 *)v125 + 633);
LABEL_62:
  v57 = *(_DWORD *)(v49 + 136) + *(_DWORD *)(v49 + 140) - 1;
  v58 = *(_DWORD *)(v49 + 104) & 0x7FFFFFFF;
  v59 = v57 % v58;
  v120 = v57 % v58;
  v121 = *(_QWORD *)(v49 + 16);
  if (v56 == 0 || (v54 & 1) == 0)
    goto LABEL_66;
  log_info("%s:%d: %s Attempting to load from temporary checkpoint (start xid %lld).\n", "nx_mount", 1433, (const char *)(v55[48] + 208), *(_QWORD *)(v49 + 1408));
  v60 = v59;
  v61 = (const void *)v43;
  if (!*(_QWORD *)(v49 + 1408))
  {
    log_err("%s:%d: %s No temporary checkpoint start xid!  Aborting!\n", "nx_mount", 1435, (const char *)(v125[48] + 208));
    v20 = 100;
LABEL_146:
    v18 = __na;
    goto LABEL_12;
  }
LABEL_75:
  v67 = *(_DWORD *)(v49 + 104) & 0x7FFFFFFF;
  if (v60 >= v67)
  {
    log_err("%s:%d: %s checkpoint descriptor index %d out of range [0...%d]\n", "nx_mount", 1453, (const char *)(v125[48] + 208), v60, v67 - 1);
    v86 = v125;
LABEL_145:
    v20 = nx_corruption_detected_int((uint64_t)v86);
    goto LABEL_146;
  }
  v46 = v60;
  v68 = nx_checkpoint_desc_block_address((uint64_t)v125, v60, &v119);
  if ((_DWORD)v68)
  {
    v20 = v68;
LABEL_140:
    log_err("%s:%d: %s couldn't read checkpoint descriptor block %d @ %lld: %d\n");
    goto LABEL_12;
  }
  v69 = dev_read(v125[48], v119);
  v20 = v69;
  if (*((_BYTE *)v125 + 633))
  {
    if (!(_DWORD)v69 && (_DWORD)v34)
    {
      v72 = 0;
      while (!*((_BYTE *)v19 + v72))
      {
        if (v34 == ++v72)
        {
          v20 = 0;
          goto LABEL_85;
        }
      }
      log_err("%s:%d: %s Attempt to load temporary checkpoint found unexpected data (0x%02x @ %d), checkpoint descriptor block %d @ %lld\n", "nx_mount", 1469, (const char *)(v125[48] + 208), *((char *)v19 + v72), v72, v46, v119);
      v20 = 22;
    }
LABEL_85:
    memcpy(v19, v61, v34);
    obj_checksum_set_phys((uint64_t)v125, (uint64_t)v19, v34, v73, v74);
  }
  if ((_DWORD)v20)
    goto LABEL_140;
  if (*((_DWORD *)v19 + 7) || *((_DWORD *)v19 + 6) != -2147483647)
  {
    log_err("%s:%d: %s checkpoint descriptor block %d is not a valid superblock\n", "nx_mount", 1486, (const char *)(v125[48] + 208), v46);
    v86 = v125;
    goto LABEL_145;
  }
  v75 = nx_check_superblock((uint64_t)v19, *(_DWORD *)(v49 + 36), 1, v70, v71);
  if ((_DWORD)v75)
  {
    v20 = v75;
    log_err("%s:%d: %s checkpoint descriptor block %d superblock failed sanity checks: %d\n");
    goto LABEL_146;
  }
  if ((*(_QWORD *)(v49 + 64) & 0xFFFFFFFFFFFFFEFDLL) != 0)
  {
    log_err("%s:%d: %s unsupported nx_incompatible_features (0x%llx): unable to mount\n", "nx_mount", 1496, (const char *)(v125[48] + 208), *(_QWORD *)(v49 + 64) & 0xFFFFFFFFFFFFFEFDLL);
    v20 = 75;
    goto LABEL_146;
  }
  v63 = (const void *)v43;
  if (!nx_superblock_agrees_with_main_superblock(v43, (uint64_t)v19, "checkpoint", 0))
  {
    log_err("%s:%d: %s checkpoint descriptor block %d doesn't agree with main superblock\n", "nx_mount", 1502, (const char *)(v125[48] + 208), v46);
    v20 = 22;
    goto LABEL_146;
  }
  v76 = (*((_DWORD *)v19 + 34) + *((_DWORD *)v19 + 35) - 1) % (*(_DWORD *)(v49 + 104) & 0x7FFFFFFFu);
  if ((_DWORD)v46 != v76)
  {
    log_err("%s:%d: %s checkpoint superblock index %d doesn't match index block was found at: %d\n", "nx_mount", 1509, (const char *)(v125[48] + 208), v76, v46);
    v86 = v125;
    goto LABEL_145;
  }
  v77 = nx_metadata_range_add(v125, 0, 1, 0, 1);
  if ((_DWORD)v77
    || (*((_BYTE *)v19 + 65) & 1) != 0
    && ((v77 = nx_metadata_range_add(v125, 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v125[47] + 36))), 1, 0, 1), (_DWORD)v77)|| (*((_BYTE *)v19 + 65) & 1) != 0&& (v77 = nx_metadata_range_add(v125, *(_QWORD *)(v125[47] + 1368), *(_QWORD *)(v125[47] + 1376) & 0x7FFFFFFF, (*(_QWORD *)(v125[47] + 1376) & 0x80000000) != 0, 0), (_DWORD)v77))|| (v77 = nx_metadata_range_add(v125, v19[14], v19[13] & 0x7FFFFFFF, *((int *)v19 + 26) < 0, 0), (_DWORD)v77)|| (v77 = nx_metadata_range_add(v125, v19[15], *((_DWORD *)v19 + 27) & 0x7FFFFFFF, *((int *)v19 + 27) < 0, 0), (_DWORD)v77))
  {
    v20 = v77;
    log_err("%s:%d: %s xid %lld at index %d failed to load checkpoint metadata ranges (overlap?): %d\n", "nx_mount", 1534, (const char *)(v125[48] + 208), v19[2], *((_DWORD *)v19 + 34), v77);
    goto LABEL_12;
  }
  v78 = nx_checkpoint_validate_checkpoint_map_blocks((uint64_t)v125, (unsigned int *)v19);
  if ((_DWORD)v78)
  {
    v20 = v78;
    log_err("%s:%d: %s validation failed for checkpoint at index %d: %d\n");
    goto LABEL_146;
  }
  v122 = v46;
  v109 = v19[2];
  log_debug("%s:%d: %s checkpoint: largest xid %lld, given checkpoint xid %lld @ %d\n", "nx_mount", 1545, (const char *)(v125[48] + 208), v121, v109, v46);
  v79 = v125;
  if (*(_QWORD *)(v43 + 16) != v19[2])
  {
    log_err("%s:%d: %s loading older checkpoint, checkpoint xid %lld, superblock xid %lld\n", "nx_mount", 1547, (const char *)(v125[48] + 208), v19[2], *(_QWORD *)(v49 + 16));
    v79 = v125;
    v108 = 1;
    *((_BYTE *)v125 + 645) = 1;
  }
  data = nx_checkpoint_load_data((uint64_t)v79, (uint64_t)v19, 0, 0);
  if ((_DWORD)data)
  {
    v20 = data;
    log_err("%s:%d: %s data for checkpoint at index %d couldn't be loaded: %d\n");
    goto LABEL_146;
  }
  memcpy((void *)v125[47], v19, v34);
  v81 = v125;
  *(_QWORD *)(v125[49] + 400) = *(_QWORD *)(v125[47] + 88);
  v20 = nx_checkpoint_traverse((uint64_t)v81, 0, 2);
  v82 = v125;
  if ((_DWORD)v20)
  {
    log_err("%s:%d: %s failed to fix up checkpoint data: %d\n");
    goto LABEL_146;
  }
  if (*((_BYTE *)v125 + 628))
  {
    if ((v106 & 1) != 0)
    {
      log_info("%s:%d: %s probe of external device... skipping recent sanity checks.\n", "nx_mount", 1575, (const char *)(v125[48] + 208));
      v82 = v125;
    }
    else
    {
      log_info("%s:%d: %s sanity checking all recently-changed container state... please be patient.\n", "nx_mount", 1583, (const char *)(v125[48] + 208));
      v20 = nx_check_recent_sanity(v125);
      v82 = v125;
      if ((_DWORD)v20)
      {
        log_err("%s:%d: %s sanity check of recently-changed structures failed: %d\n");
        goto LABEL_146;
      }
    }
  }
  v20 = spaceman_get(v82, (uint64_t *)&v123);
  if ((_DWORD)v20)
  {
    log_err("%s:%d: %s checkpoint xid %lld failed to get spaceman: %d\n");
    goto LABEL_146;
  }
  v20 = nx_metadata_range_add(v125, *(_QWORD *)&v123[47][3].__opaque[16], *(_DWORD *)&v123[47][3].__opaque[12] & 0x7FFFFFFF, *(int *)&v123[47][3].__opaque[12] < 0, 0);
  if (!(_DWORD)v20)
  {
    v20 = nx_metadata_range_add(v125, *(_QWORD *)&v123[47][3].__opaque[24], *(_QWORD *)v123[47][3].__opaque, *(uint64_t *)v123[47][3].__opaque < 0, 0);
    obj_release((uint64_t *)v123);
    if ((_DWORD)v20)
      goto LABEL_152;
    v66 = v125;
    goto LABEL_113;
  }
  obj_release((uint64_t *)v123);
LABEL_152:
  log_err("%s:%d: %s checkpoint xid %lld failed to load spaceman metadata ranges (overlap?): %d\n");
LABEL_12:
  if (v124)
    _apfs_free(v124, v124[9]);
  if (v19)
    _apfs_free(v19, v18);
  v21 = v125;
  if (v125)
  {
    *((_BYTE *)v125 + 627) = 1;
    nx_unmount((uint64_t)v21);
  }
  if (v126)
    obj_cache_destroy((uint64_t)v126);
  if (v127)
    dev_close((uint64_t)v127);
  return v20;
}

void nx_mount_initiate_free_space_trims(_QWORD *a1)
{
  int v2;

  v2 = spaceman_scan_free_blocks(a1, 0, 1);
  if (v2)
    log_err("%s:%d: %s *** trim'ing free blocks returned: %d\n", "nx_mount_initiate_free_space_trims", 964, (const char *)(a1[48] + 208), v2);
  spaceman_free_extent_cache_print_stats(a1);
}

void nx_unmount(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t i;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  nx_reaper_shut_down((_QWORD *)a1);
  v2 = *(_QWORD *)(a1 + 400);
  if (v2)
  {
    if (!*(_BYTE *)(a1 + 627))
    {
      tx_unmount(a1);
      v2 = *(_QWORD *)(a1 + 400);
    }
    tx_mgr_destroy(a1, v2, *(_DWORD *)(*(_QWORD *)(a1 + 376) + 36));
  }
  v3 = *(uint64_t **)(a1 + 408);
  if (v3)
  {
    obj_release(v3);
    *(_QWORD *)(a1 + 408) = 0;
  }
  for (i = 0; i != 32; i += 8)
  {
    v5 = *(uint64_t **)(a1 + 432 + i);
    if (v5)
      obj_release(v5);
  }
  v6 = *(_QWORD *)(a1 + 464);
  if (v6)
  {
    btree_delete(v6, 0, 0);
    obj_release(*(uint64_t **)(a1 + 464));
  }
  v7 = *(_QWORD *)(a1 + 1824);
  if (v7)
  {
    btree_delete(v7, 0, 0);
    obj_release(*(uint64_t **)(a1 + 1824));
    *(_QWORD *)(a1 + 1824) = 0;
  }
  v8 = *(_QWORD *)(a1 + 384);
  if (v8)
    dev_close(v8);
  v9 = *(_QWORD *)(a1 + 392);
  if (v9)
    obj_cache_destroy(v9);
}

uint64_t media_dev_barrier()
{
  return 45;
}

uint64_t media_dev_unmap_flush()
{
  return 45;
}

uint64_t media_dev_unmap()
{
  return 45;
}

uint64_t media_dev_features()
{
  return 45;
}

uint64_t media_dev_is_writable()
{
  return 0;
}

uint64_t media_dev_is_external(uint64_t a1)
{
  return *(unsigned int *)(a1 + 112);
}

uint64_t media_dev_real_block_size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

uint64_t media_dev_block_size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 100);
}

uint64_t media_dev_set_block_size(uint64_t a1, unsigned int a2)
{
  unint64_t v2;

  v2 = *(_QWORD *)(a1 + 128) * (unint64_t)*(unsigned int *)(a1 + 100) / a2;
  *(_DWORD *)(a1 + 100) = a2;
  *(_QWORD *)(a1 + 128) = v2;
  return 0;
}

uint64_t media_dev_block_count(uint64_t a1)
{
  return *(_QWORD *)(a1 + 128);
}

uint64_t media_dev_read(uint64_t a1, unint64_t a2, unint64_t a3)
{
  _QWORD *v3;
  unsigned int (*v4)(void);
  unint64_t v5;
  BOOL v6;
  unint64_t v7;

  v3 = *(_QWORD **)(a1 + 16);
  if (!v3)
    return 6;
  if (!*v3)
    return 6;
  v4 = (unsigned int (*)(void))v3[1];
  if (!v4)
    return 6;
  v5 = *(_QWORD *)(a1 + 128);
  v6 = v5 > a2;
  v7 = v5 - a2;
  if (!v6 || v7 < a3)
    return 6;
  if (v4())
    return 5;
  return 0;
}

uint64_t media_dev_close(void **a1)
{
  _apfs_free(a1[2], 16);
  a1[2] = 0;
  _apfs_free(a1, 216);
  return 0;
}

uint64_t media_dev_write()
{
  return 45;
}

__CFDictionary *APFSContainerGetFreespaceInfo(const __CFString *a1, const __CFString *a2)
{
  int *CStringPtr;
  __CFDictionary *v5;
  CFMutableArrayRef Mutable;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  const __CFString **v11;
  const __CFString **v12;
  int64x2_t *v13;
  int64x2_t v14;
  int64x2_t v15;
  int64x2_t v16;
  const __CFAllocator *v17;
  int64_t v18;
  CFIndex Count;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v21;
  CFNumberRef v22;
  __CFDictionary *v23;
  _OWORD v24[2];
  uint64_t *v25;
  uint64_t v26;
  unint64_t v27;
  int v28;
  void *value[2];
  int64x2_t v30;
  int64_t v31;
  int64_t valuePtr;
  void *v33;
  CFRange v34;

  v28 = 0;
  v26 = 0;
  v27 = 0;
  v25 = 0;
  memset(v24, 0, sizeof(v24));
  parse_nx_mount_options(0, (int *)v24);
  LODWORD(v24[0]) |= 1u;
  WORD4(v24[0]) |= 1u;
  apfs_log_level = 3;
  if (a2)
  {
    if (!a1)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        APFSContainerGetFreespaceInfo_cold_6();
      goto LABEL_12;
    }
    *(_OWORD *)value = 0u;
    v30 = 0u;
    if (((unsigned int (*)(const __CFString *, uint64_t, void **))a2)(a1, 2, value))
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        APFSContainerGetFreespaceInfo_cold_10();
LABEL_12:
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        APFSContainerGetFreespaceInfo_cold_5();
LABEL_14:
      v5 = 0;
      Mutable = 0;
LABEL_15:
      v7 = 0;
      v8 = 0;
      v9 = 0;
      goto LABEL_16;
    }
    v11 = (const __CFString **)_apfs_calloc(1uLL, 0x10uLL);
    if (!v11)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        APFSContainerGetFreespaceInfo_cold_7();
      goto LABEL_12;
    }
    v12 = v11;
    v13 = (int64x2_t *)_apfs_calloc(1uLL, 0xD8uLL);
    if (!v13)
    {
      _apfs_free(v12, 16);
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        APFSContainerGetFreespaceInfo_cold_8();
      goto LABEL_12;
    }
    v13->i64[0] = -1;
    v13[7].i32[1] = 0;
    *v12 = a1;
    v12[1] = a2;
    v13[1].i64[0] = (uint64_t)v12;
    v13[4].i64[1] = (uint64_t)apfs_userio_media;
    v14 = *(int64x2_t *)value;
    v15 = v30;
    v13[8].i64[0] = (uint64_t)value[1];
    v16 = vzip1q_s64(v14, v15);
    v16.i32[1] = v16.i32[0];
    v13[6] = v16;
    v13[7].i32[0] = v30.i32[2] == 0;
    WORD4(v24[0]) |= 2u;
    if (nx_mount(v13->i32, (uint64_t)v24, &v25))
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        APFSContainerGetFreespaceInfo_cold_9();
      goto LABEL_14;
    }
  }
  else
  {
    CStringPtr = (int *)CFStringGetCStringPtr(a1, 0x8000100u);
    if (!CStringPtr)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        APFSContainerGetFreespaceInfo_cold_1();
      goto LABEL_14;
    }
    if (nx_mount(CStringPtr, (uint64_t)v24, &v25))
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        APFSContainerGetFreespaceInfo_cold_4();
      goto LABEL_14;
    }
  }
  v5 = 0;
  Mutable = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  if (!spaceman_size_info(v25, 0, 0, &v28, &v27, 0, 0, 0, 0))
  {
    v17 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    if (!Mutable)
    {
LABEL_62:
      v5 = 0;
      goto LABEL_15;
    }
    if (spaceman_iterate_free_extents((uint64_t)v25, (uint64_t (*)(_QWORD *, unint64_t, int64_t))freeExtentInfoCallback, Mutable))
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        APFSContainerGetFreespaceInfo_cold_3();
      goto LABEL_62;
    }
    v34.length = CFArrayGetCount(Mutable);
    v34.location = 0;
    CFArraySortValues(Mutable, v34, (CFComparatorFunction)freeExtentInfoComparator, 0);
    v18 = v27;
    Count = CFArrayGetCount(Mutable);
    if (Count)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, Count - 1);
      if (!ValueAtIndex
        || (v21 = ValueAtIndex,
            value[0] = 0,
            valuePtr = 0,
            v33 = 0,
            v31 = 0,
            !CFDictionaryGetValueIfPresent(ValueAtIndex, CFSTR("com.apple.apfs.container.extaddr"), (const void **)value))|| !CFDictionaryGetValueIfPresent(v21, CFSTR("com.apple.apfs.container.extlen"), (const void **)&v33)|| !CFNumberGetValue((CFNumberRef)value[0], kCFNumberLongLongType, &valuePtr)|| !CFNumberGetValue((CFNumberRef)v33, kCFNumberLongLongType, &v31))
      {
        v26 = -1;
        goto LABEL_60;
      }
      if ((v18 <= valuePtr || v31 >= v18 - valuePtr) && valuePtr < v18)
        v18 = valuePtr;
    }
    v26 = v18;
    if ((v18 & 0x8000000000000000) == 0)
    {
      v8 = CFNumberCreate(v17, kCFNumberIntType, &v28);
      v7 = CFNumberCreate(v17, kCFNumberLongLongType, &v27);
      v22 = CFNumberCreate(v17, kCFNumberLongLongType, &v26);
      v9 = v22;
      v5 = 0;
      if (v8)
      {
        if (v7)
        {
          if (v22)
          {
            v23 = CFDictionaryCreateMutable(v17, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v5 = v23;
            if (v23)
            {
              CFDictionaryAddValue(v23, CFSTR("com.apple.apfs.container.fstype"), CFSTR("APFS"));
              CFDictionaryAddValue(v5, CFSTR("com.apple.apfs.container.blksize"), v8);
              CFDictionaryAddValue(v5, CFSTR("com.apple.apfs.container.size"), v7);
              CFDictionaryAddValue(v5, CFSTR("com.apple.apfs.container.tidemark"), v9);
              CFDictionaryAddValue(v5, CFSTR("com.apple.apfs.container.extlist"), Mutable);
            }
          }
        }
      }
      goto LABEL_16;
    }
LABEL_60:
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      APFSContainerGetFreespaceInfo_cold_2();
    goto LABEL_62;
  }
LABEL_16:
  if (v25)
    nx_unmount((uint64_t)v25);
  if (Mutable)
    CFRelease(Mutable);
  if (v8)
    CFRelease(v8);
  if (v7)
    CFRelease(v7);
  if (v9)
    CFRelease(v9);
  apfs_log_level = 5;
  return v5;
}

uint64_t freeExtentInfoCallback(__CFArray *a1, uint64_t a2, uint64_t a3)
{
  const __CFAllocator *v4;
  __CFDictionary *Mutable;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  BOOL v9;
  uint64_t v12;
  uint64_t valuePtr;

  v12 = a3;
  valuePtr = a2;
  if (!a1)
    return 0;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
  v6 = CFNumberCreate(v4, kCFNumberLongLongType, &valuePtr);
  v7 = CFNumberCreate(v4, kCFNumberLongLongType, &v12);
  v8 = v7;
  if (Mutable)
    v9 = v6 == 0;
  else
    v9 = 1;
  if (v9 || v7 == 0)
  {
    if (!v6)
    {
      if (!v7)
        goto LABEL_13;
      goto LABEL_12;
    }
  }
  else
  {
    CFDictionaryAddValue(Mutable, CFSTR("com.apple.apfs.container.extaddr"), v6);
    CFDictionaryAddValue(Mutable, CFSTR("com.apple.apfs.container.extlen"), v8);
    CFArrayAppendValue(a1, Mutable);
  }
  CFRelease(v6);
  if (v8)
LABEL_12:
    CFRelease(v8);
LABEL_13:
  if (Mutable)
    CFRelease(Mutable);
  return 0;
}

uint64_t freeExtentInfoComparator(const __CFDictionary *a1, const __CFDictionary *a2)
{
  unint64_t v4;
  unint64_t valuePtr;
  CFNumberRef number;
  void *value;

  number = 0;
  value = 0;
  v4 = 0;
  valuePtr = 0;
  if (!CFDictionaryGetValueIfPresent(a1, CFSTR("com.apple.apfs.container.extaddr"), (const void **)&value)
    || !CFDictionaryGetValueIfPresent(a2, CFSTR("com.apple.apfs.container.extaddr"), (const void **)&number)
    || !CFNumberGetValue((CFNumberRef)value, kCFNumberLongLongType, &valuePtr)
    || !CFNumberGetValue(number, kCFNumberLongLongType, &v4))
  {
    return 0;
  }
  if (valuePtr >= v4)
    return valuePtr != v4;
  return -1;
}

uint64_t APFSContainerGetMinimalSize(char *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  size_t outputStructCnt;
  _QWORD outputStruct[303];
  io_connect_t v9;

  v9 = 0;
  bzero(outputStruct, 0x978uLL);
  outputStructCnt = 8;
  v4 = apfs_container_iouc(a1, 0, &v9, 0, 1);
  if (!(_DWORD)v4)
  {
    LODWORD(outputStruct[0]) = physical_store_get_tier(a1);
    v5 = IOConnectCallStructMethod(v9, 0x22u, outputStruct, 4uLL, outputStruct, &outputStructCnt);
    v4 = v5;
    if (a2 && !(_DWORD)v5)
      *a2 = outputStruct[0];
    IOServiceClose(v9);
  }
  return v4;
}

uint64_t physical_store_get_tier(char *a1)
{
  char *v2;
  const char *v3;
  mach_port_t v4;
  const __CFDictionary *v5;
  io_service_t MatchingService;
  io_object_t v7;
  const __CFString *CFProperty;
  const __CFString *v9;
  uint64_t v10;

  v2 = strrchr(a1, 47);
  if (v2)
    v3 = v2 + 1;
  else
    v3 = a1;
  v4 = *MEMORY[0x1E0CBBAB8];
  v5 = IOBSDNameMatching(*MEMORY[0x1E0CBBAB8], 0, v3);
  MatchingService = IOServiceGetMatchingService(v4, v5);
  if (!MatchingService)
    return 0;
  v7 = MatchingService;
  CFProperty = (const __CFString *)IORegistryEntryCreateCFProperty(MatchingService, CFSTR("TierType"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (CFProperty)
  {
    v9 = CFProperty;
    if (CFStringCompare(CFProperty, CFSTR("Secondary"), 0))
      v10 = 0x8000;
    else
      v10 = 32769;
    CFRelease(v9);
  }
  else
  {
    v10 = 0;
  }
  IOObjectRelease(v7);
  return v10;
}

uint64_t APFSContainerResize(char *a1, uint64_t a2)
{
  return APFSContainerResizeEx(a1, a2, 0);
}

uint64_t APFSContainerResizeEx(char *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  unsigned int v7;
  size_t outputStructCnt;
  uint64_t outputStruct;
  _QWORD v11[302];
  io_connect_t v12;

  v12 = 0;
  bzero(v11, 0x970uLL);
  outputStructCnt = 16;
  v6 = apfs_container_iouc(a1, 0, &v12, 0, 1);
  if (!(_DWORD)v6)
  {
    LODWORD(v11[0]) = physical_store_get_tier(a1);
    outputStruct = a2;
    v7 = IOConnectCallStructMethod(v12, 2u, &outputStruct, 0x10uLL, &outputStruct, &outputStructCnt);
    if (v7)
      v6 = v7;
    else
      v6 = outputStruct;
    if (a3)
      *a3 = v11[0];
    IOServiceClose(v12);
  }
  return v6;
}

uint64_t APFSContainerDefrag(char *a1)
{
  uint64_t v2;
  size_t outputStructCnt;
  _DWORD inputStruct[607];
  io_connect_t v6;

  v6 = 0;
  bzero(inputStruct, 0x978uLL);
  outputStructCnt = 0;
  v2 = apfs_container_iouc(a1, 0, &v6, 0, 1);
  if (!(_DWORD)v2)
  {
    inputStruct[0] = physical_store_get_tier(a1);
    v2 = IOConnectCallStructMethod(v6, 3u, inputStruct, 4uLL, 0, &outputStructCnt);
    IOServiceClose(v6);
  }
  return v2;
}

uint64_t APFSContainerGetResizeProgress(char *a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  size_t outputStructCnt;
  _DWORD outputStruct[607];
  io_connect_t v9;

  v9 = 0;
  bzero(outputStruct, 0x978uLL);
  outputStructCnt = 4;
  v4 = apfs_container_iouc(a1, 0, &v9, 0, 1);
  if (!(_DWORD)v4)
  {
    v5 = IOConnectCallStructMethod(v9, 4u, 0, 0, outputStruct, &outputStructCnt);
    v4 = v5;
    if (a2 && !(_DWORD)v5)
      *a2 = outputStruct[0];
    IOServiceClose(v9);
  }
  return v4;
}

uint64_t APFSCancelContainerResize(char *a1)
{
  uint64_t v1;
  size_t v3;
  mach_port_t connection;

  connection = 0;
  v3 = 0;
  v1 = apfs_container_iouc(a1, 0, &connection, 0, 1);
  if (!(_DWORD)v1)
  {
    v1 = IOConnectCallStructMethod(connection, 0x21u, 0, 0, 0, &v3);
    IOServiceClose(connection);
  }
  return v1;
}

uint64_t APFSContainerWipeVolumeKeys(char *a1)
{
  uint64_t v1;
  size_t v3;
  mach_port_t connection;

  connection = 0;
  v3 = 0;
  v1 = apfs_container_iouc(a1, 0, &connection, 0, 0);
  if (!(_DWORD)v1)
  {
    v1 = IOConnectCallStructMethod(connection, 5u, 0, 0, 0, &v3);
    IOServiceClose(connection);
  }
  return v1;
}

uint64_t APFSContainerGetSpaceInfo(char *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  size_t outputStructCnt;
  _BYTE outputStruct[8];
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  io_connect_t v17;

  v17 = 0;
  bzero(outputStruct, 0x978uLL);
  outputStructCnt = 2424;
  v6 = apfs_container_iouc(a1, 0, &v17, 0, 0);
  if (!(_DWORD)v6)
  {
    v6 = IOConnectCallStructMethod(v17, 6u, 0, 0, outputStruct, &outputStructCnt);
    if (!(_DWORD)v6)
    {
      v7 = v11;
      if (a2)
        *a2 = (v13 + v15) * v11;
      if (a3)
        *a3 = (v14 + v12 + v16) * v7;
    }
    IOServiceClose(v17);
  }
  return v6;
}

uint64_t APFSContainerGetMaxVolumeCount(char *a1, void *a2)
{
  uint64_t v4;
  const __CFAllocator *v5;
  const char *v6;
  CFStringRef v7;
  CFDictionaryRef v8;
  CFStringRef v9;
  const __CFDictionary *Value;
  const __CFNumber *v11;
  const __CFNumber *v12;
  CFTypeID v13;
  CFDictionaryRef theDict;

  if (!a2)
    return 49174;
  theDict = 0;
  v4 = APFSExtendedSpaceInfo(a1, &theDict);
  if (!(_DWORD)v4)
  {
    v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v6 = device_basename(a1);
    v7 = CFStringCreateWithCString(v5, v6, 0x8000100u);
    v8 = theDict;
    if (v7)
    {
      v9 = v7;
      Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, v7);
      if (Value && (v11 = (const __CFNumber *)CFDictionaryGetValue(Value, CFSTR("Max volume count"))) != 0)
      {
        v12 = v11;
        v13 = CFGetTypeID(v11);
        v4 = 49154;
        if (v13 == CFNumberGetTypeID())
        {
          if (CFNumberGetValue(v12, kCFNumberSInt32Type, a2))
            v4 = 0;
          else
            v4 = 49154;
        }
      }
      else
      {
        v4 = 49154;
      }
      CFRelease(v9);
    }
    else
    {
      v4 = 49154;
    }
    CFRelease(v8);
  }
  return v4;
}

uint64_t APFSExtendedSpaceInfo(char *a1, _QWORD *a2)
{
  uint64_t v4;
  mach_port_t v5;
  _DWORD *v6;
  uint32_t v7;
  size_t v8;
  io_connect_t v9;
  CFTypeRef v10;
  _DWORD v12[606];
  size_t outputStructCnt;
  const char *outputStruct;
  io_connect_t v15;

  v15 = 0;
  outputStructCnt = -3;
  outputStruct = 0;
  if (device_is_volume(a1))
  {
    bzero(v12, 0x978uLL);
    v4 = apfs_container_iouc(a1, v12, &v15, 0, 0);
    if ((_DWORD)v4)
      goto LABEL_7;
    v5 = v15;
    v6 = v12;
    v7 = 65;
    v8 = 4;
  }
  else
  {
    v4 = apfs_container_iouc(a1, 0, &v15, 0, 0);
    if ((_DWORD)v4)
      goto LABEL_7;
    v5 = v15;
    v7 = 8;
    v6 = 0;
    v8 = 0;
  }
  v4 = IOConnectCallStructMethod(v5, v7, v6, v8, &outputStruct, &outputStructCnt);
LABEL_7:
  v9 = v15;
  if (v15)
  {
    if (!(_DWORD)v4)
    {
      v10 = IOCFUnserialize(outputStruct, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
      *a2 = v10;
      if (v10)
        v4 = 0;
      else
        v4 = 3758097097;
      MEMORY[0x1E0BFD23C](*MEMORY[0x1E0C83DA0], outputStruct, outputStructCnt);
      v9 = v15;
    }
    IOServiceClose(v9);
  }
  return v4;
}

uint64_t APFSVolumeCreate(char *a1, const __CFDictionary *a2)
{
  const __CFNumber *Value;
  const __CFNumber *v4;
  const __CFString *v5;
  const __CFNumber *v6;
  const __CFBoolean *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const __CFNumber *v12;
  __int16 v13;
  unsigned int v14;
  uint64_t v15;
  CFTypeID v16;
  Boolean v17;
  CFTypeID v18;
  const __CFBoolean *v19;
  const __CFBoolean *v20;
  CFTypeID v21;
  const __CFNumber *v22;
  const __CFBoolean *v23;
  const __CFBoolean *v24;
  CFTypeID v25;
  Boolean v26;
  const __CFBoolean *v27;
  const __CFBoolean *v28;
  CFTypeID v29;
  int v31;
  CFNumberRef v32;
  CFNumberRef v33;
  _BYTE inputStruct[16];
  size_t v36;
  size_t v37;
  int v38;
  __int16 v39;
  unsigned __int16 v40;
  char v41[396];
  int v42;
  int v43;
  uint64_t outputStruct;
  int v45;
  size_t valuePtr[2];

  outputStruct = 0;
  bzero(inputStruct, 0x978uLL);
  parse_apfs_format_options(0, (uint64_t)inputStruct);
  Value = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("com.apple.apfs.volume.reserve_size"));
  v4 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("com.apple.apfs.volume.quota_size"));
  v5 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("com.apple.apfs.volume.name"));
  v6 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("com.apple.apfs.volume.role"));
  v7 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("com.apple.apfs.volume.case_sensitive"));
  v8 = CFDictionaryGetValue(a2, CFSTR("com.apple.apfs.volume.encrypted"));
  v9 = CFDictionaryGetValue(a2, CFSTR("com.apple.apfs.volume.encrypted.acm"));
  v10 = CFDictionaryGetValue(a2, CFSTR("com.apple.apfs.volume.cprotect"));
  v11 = CFDictionaryGetValue(a2, CFSTR("com.apple.apfs.volume.create_synchronous"));
  valuePtr[0] = 0;
  v45 = 0;
  v43 = 0;
  if (Value && CFNumberGetValue(Value, kCFNumberSInt64Type, valuePtr))
    v36 = valuePtr[0];
  if (v4 && CFNumberGetValue(v4, kCFNumberSInt64Type, valuePtr))
    v37 = valuePtr[0];
  if (v5 && !CFStringGetCString(v5, v41, 256, 0x8000100u))
    return 49244;
  if (v6 && CFNumberGetValue(v6, kCFNumberIntType, &v45))
    v40 = v45;
  v12 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("com.apple.apfs.volume.fs_index"));
  if (v12 && CFNumberGetValue(v12, kCFNumberSInt32Type, &v45))
  {
    if (v45 < 0)
      return 49186;
    v38 = v45;
  }
  if (v7)
  {
    if (CFBooleanGetValue(v7))
      v13 = 8;
    else
      v13 = 4;
    v39 = v39 & 0xFFF3 | v13;
  }
  v14 = v8 != 0;
  if (v9)
    ++v14;
  if (v14 > 1)
    return 49174;
  if (v10)
  {
    if (!v14)
      return 49174;
    v39 |= 0x200u;
  }
  if (v9)
    return 49174;
  if (v8)
  {
    v16 = CFGetTypeID(v8);
    if (v16 != CFBooleanGetTypeID())
      return 49231;
    v17 = CFBooleanGetValue((CFBooleanRef)v8);
    v39 = v39 & 0xFFFE | v17 & 1;
  }
  if (v11)
  {
    v18 = CFGetTypeID(v11);
    if (v18 != CFBooleanGetTypeID())
      return 49174;
    if (CFBooleanGetValue((CFBooleanRef)v11))
      v43 |= 0x10u;
  }
  v19 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("com.apple.apfs.volume.skip_eapfs"));
  if (v19)
  {
    v20 = v19;
    v21 = CFGetTypeID(v19);
    if (v21 != CFBooleanGetTypeID())
      return 49174;
    if (CFBooleanGetValue(v20))
      v43 |= 0x200u;
  }
  v22 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("com.apple.apfs.volume.group_sibling_fsindex"));
  if (v22 && CFNumberGetValue(v22, kCFNumberSInt32Type, &v45))
  {
    if (v45 >= 1)
    {
      v42 = v45;
      goto LABEL_45;
    }
    return 49186;
  }
LABEL_45:
  v23 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("com.apple.apfs.volume.allow_unwritten"));
  if (v23)
  {
    v24 = v23;
    v25 = CFGetTypeID(v23);
    if (v25 != CFBooleanGetTypeID())
      return 49174;
    v26 = CFBooleanGetValue(v24);
    v39 = v39 & 0xFBFF | ((v26 & 1) << 10);
  }
  v27 = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("com.apple.apfs.volume.noautomount_at_create"));
  if (v27)
  {
    v28 = v27;
    v29 = CFGetTypeID(v27);
    if (v29 != CFBooleanGetTypeID())
      return 49174;
    if (CFBooleanGetValue(v28))
      v43 |= 8u;
  }
  v15 = apfs_container_iouc(a1, 0, (io_connect_t *)&outputStruct + 1, 0, 0);
  if ((_DWORD)v15)
    return v15;
  if (v40 > 0xFFu)
  {
    if (v40 > 0x27Fu)
    {
      if (v40 != 704 && v40 != 640)
        goto LABEL_74;
    }
    else if (v40 != 256 && v40 != 320)
    {
      goto LABEL_74;
    }
LABEL_67:
    if ((v39 & 1) != 0)
      return 49174;
    v31 = 1;
    goto LABEL_69;
  }
  if (v40 <= 0x20u && ((1 << v40) & 0x100010110) != 0 || v40 == 192)
    goto LABEL_67;
LABEL_74:
  if (v42 >= 1)
  {
    if (v40 != 64 && v40 != 1)
      return 49174;
    v31 = v43 | 2;
LABEL_69:
    v43 = v31;
  }
  valuePtr[0] = 4;
  v15 = IOConnectCallStructMethod(HIDWORD(outputStruct), 0, inputStruct, 0x1F8uLL, &outputStruct, valuePtr);
  if (!(_DWORD)v15)
  {
    v32 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &outputStruct);
    if (v32)
    {
      v33 = v32;
      CFDictionarySetValue(a2, CFSTR("com.apple.apfs.volume.fs_index"), v32);
      CFRelease(v33);
    }
  }
  IOServiceClose(HIDWORD(outputStruct));
  return v15;
}

uint64_t APFSVolumeDelete(char *a1)
{
  return _APFSVolumeOperation(a1, 1u);
}

uint64_t _APFSVolumeOperation(char *a1, uint32_t a2)
{
  uint64_t v4;
  size_t outputStructCnt;
  _DWORD inputStruct[607];
  io_connect_t v8;

  outputStructCnt = 0;
  if (!a1 || (a2 - 27 > 0x28 || ((1 << (a2 - 27)) & 0x18A00000001) == 0) && a2 != 1)
    return 49174;
  v8 = 0;
  bzero(inputStruct, 0x978uLL);
  v4 = apfs_container_iouc(a1, inputStruct, &v8, 0, 0);
  if (!(_DWORD)v4)
  {
    v4 = IOConnectCallStructMethod(v8, a2, inputStruct, 4uLL, 0, &outputStructCnt);
    IOServiceClose(v8);
  }
  return v4;
}

uint64_t APFSVolumeLock()
{
  return 45;
}

uint64_t APFSVolumeUpdateBounds(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  size_t outputStructCnt;
  int inputStruct;
  uint64_t v10;
  uint64_t v11;
  io_connect_t v12;

  v12 = 0;
  bzero(&inputStruct, 0x978uLL);
  outputStructCnt = 0;
  v6 = apfs_container_iouc(a1, &inputStruct, &v12, 0, 0);
  if (!(_DWORD)v6)
  {
    v10 = a2;
    v11 = a3;
    v6 = IOConnectCallStructMethod(v12, 0x36u, &inputStruct, 0x18uLL, 0, &outputStructCnt);
    IOServiceClose(v12);
  }
  return v6;
}

uint64_t APFSVolumeGetSpaceInfo(char *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v6;
  size_t outputStructCnt;
  _QWORD outputStruct[303];
  io_connect_t v10;

  v10 = 0;
  bzero(outputStruct, 0x978uLL);
  outputStructCnt = 16;
  v6 = apfs_container_iouc(a1, outputStruct, &v10, 0, 0);
  if (!(_DWORD)v6)
  {
    v6 = IOConnectCallStructMethod(v10, 7u, outputStruct, 4uLL, outputStruct, &outputStructCnt);
    if (!(_DWORD)v6)
    {
      if (a2)
        *a2 = outputStruct[0];
      if (a3)
        *a3 = outputStruct[1];
    }
    IOServiceClose(v10);
  }
  return v6;
}

uint64_t APFSVolumeRoleFind(char *a1, int a2, __CFArray **a3)
{
  uint64_t v6;
  io_object_t v7;
  io_object_t v8;
  const __CFAllocator *v9;
  const __CFString *CFProperty;
  const __CFString *v11;
  __CFString *MutableCopy;
  __CFString *v13;
  __CFArray *Mutable;
  size_t v16;
  _DWORD outputStruct[607];
  io_registry_entry_t v18;
  uint64_t v19;
  io_name_t location;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v19 = 0;
  v18 = 0;
  memset(location, 0, sizeof(location));
  bzero(outputStruct, 0x978uLL);
  v16 = 2;
  *a3 = 0;
  if (!apfs_container_iouc(a1, 0, (io_connect_t *)&v19 + 1, &v18, 0)
    || (v6 = apfs_container_iouc(a1, outputStruct, (io_connect_t *)&v19 + 1, &v18, 0), !(_DWORD)v6))
  {
    v6 = MEMORY[0x1E0BFCCC0](v18, "IOService", &v19);
    if (!(_DWORD)v6)
    {
      v7 = IOIteratorNext(v19);
      if (v7)
      {
        v8 = v7;
        v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        do
        {
          if (IOObjectConformsTo(v8, "AppleAPFSVolume"))
          {
            if (!IORegistryEntryGetLocationInPlane(v8, "IOService", location))
            {
              outputStruct[0] = strtol(location, 0, 0) - 1;
              outputStruct[1] = 0;
              if (!IOConnectCallStructMethod(HIDWORD(v19), 9u, outputStruct, 8uLL, outputStruct, &v16)
                && LOWORD(outputStruct[0]) == a2)
              {
                CFProperty = (const __CFString *)IORegistryEntryCreateCFProperty(v8, CFSTR("BSD Name"), v9, 0);
                if (CFProperty)
                {
                  v11 = CFProperty;
                  MutableCopy = CFStringCreateMutableCopy(v9, 0, CFProperty);
                  if (MutableCopy)
                  {
                    v13 = MutableCopy;
                    CFStringInsert(MutableCopy, 0, CFSTR("/dev/"));
                    Mutable = *a3;
                    if (*a3 || (Mutable = CFArrayCreateMutable(v9, 0, MEMORY[0x1E0C9B378]), (*a3 = Mutable) != 0))
                      CFArrayAppendValue(Mutable, v13);
                    CFRelease(v13);
                  }
                  CFRelease(v11);
                }
              }
            }
          }
          IOObjectRelease(v8);
          v8 = IOIteratorNext(v19);
        }
        while (v8);
      }
      IOObjectRelease(v19);
      if (*a3)
        v6 = 0;
      else
        v6 = 49245;
    }
    IOObjectRelease(v18);
    IOServiceClose(HIDWORD(v19));
  }
  return v6;
}

uint64_t APFSVolumePayloadGet()
{
  uint64_t v0;
  __int16 v1;
  void *v2;
  size_t *v3;
  size_t *v4;
  void *v5;
  __int16 v6;
  char *v7;
  uint64_t v8;
  size_t v9;
  size_t v10;
  size_t v12;
  mach_port_t connection;
  unsigned int outputStruct;
  _WORD v15[2];
  int v16;
  uint64_t v17;

  v0 = MEMORY[0x1E0C80A78]();
  v17 = *MEMORY[0x1E0C80C00];
  v12 = 2052;
  if (!v3)
    return 49174;
  v4 = v3;
  v5 = v2;
  v6 = v1;
  v7 = (char *)v0;
  connection = 0;
  bzero(&outputStruct, 0x1178uLL);
  v8 = apfs_container_iouc(v7, &outputStruct, &connection, 0, 0);
  if (!(_DWORD)v8)
  {
    v15[0] = v6;
    v15[1] = 1;
    v16 = 2048;
    v8 = IOConnectCallStructMethod(connection, 0xAu, &outputStruct, 0xCuLL, &outputStruct, &v12);
    if (!(_DWORD)v8)
    {
      v9 = outputStruct;
      if (v5)
      {
        if (*v4 >= outputStruct)
          v10 = outputStruct;
        else
          v10 = *v4;
        memcpy(v5, v15, v10);
      }
      *v4 = v9;
    }
    IOServiceClose(connection);
  }
  return v8;
}

uint64_t APFSVolumePayloadSet()
{
  uint64_t v0;
  unint64_t v1;
  unint64_t v2;
  __int16 v3;
  __int16 v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  size_t v9;
  mach_port_t connection;
  int outputStruct;
  __int16 v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v0 = MEMORY[0x1E0C80A78]();
  v2 = v1;
  v4 = v3;
  v5 = (char *)v0;
  v15 = *MEMORY[0x1E0C80C00];
  v9 = 4;
  if (v6)
  {
    if (v1 <= 0x800)
      goto LABEL_3;
    return 49174;
  }
  if (v1)
    return 49174;
LABEL_3:
  connection = 0;
  bzero(&outputStruct, 0x1178uLL);
  v7 = apfs_container_iouc(v5, &outputStruct, &connection, 0, 0);
  if (!(_DWORD)v7)
  {
    v12 = v4;
    v13 = 2;
    v14 = v2;
    __memcpy_chk();
    v7 = IOConnectCallStructMethod(connection, 0xAu, &outputStruct, v2 + 12, &outputStruct, &v9);
    IOServiceClose(connection);
  }
  return v7;
}

uint64_t APFSVolumeGetVEKState(char *a1, _BYTE *a2, _BYTE *a3)
{
  uint64_t result;
  uint64_t v7;
  _DWORD outputStruct[607];
  io_connect_t v9;
  size_t outputStructCnt;

  result = 22;
  if (a1 && a2 && a3)
  {
    v9 = 0;
    bzero(outputStruct, 0x978uLL);
    outputStructCnt = 2;
    v7 = apfs_container_iouc(a1, outputStruct, &v9, 0, 0);
    if (!(_DWORD)v7)
    {
      v7 = IOConnectCallStructMethod(v9, 0x13u, outputStruct, 4uLL, outputStruct, &outputStructCnt);
      IOServiceClose(v9);
      if (!(_DWORD)v7)
      {
        *a2 = outputStruct[0];
        *a3 = BYTE1(outputStruct[0]);
      }
    }
    return rc_to_errno(v7);
  }
  return result;
}

uint64_t APFSVolumeGetSiDPState(char *a1, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  uint64_t result;
  uint64_t v9;
  _DWORD outputStruct[607];
  io_connect_t v11;
  size_t outputStructCnt;

  result = 22;
  if (a1 && a2 && a3 && a4)
  {
    v11 = 0;
    bzero(outputStruct, 0x978uLL);
    outputStructCnt = 3;
    v9 = apfs_container_iouc(a1, outputStruct, &v11, 0, 0);
    if (!(_DWORD)v9)
    {
      v9 = IOConnectCallStructMethod(v11, 0x38u, outputStruct, 4uLL, outputStruct, &outputStructCnt);
      IOServiceClose(v11);
      if (!(_DWORD)v9)
      {
        *a2 = outputStruct[0];
        *a3 = BYTE1(outputStruct[0]);
        *a4 = BYTE2(outputStruct[0]);
      }
    }
    return rc_to_errno(v9);
  }
  return result;
}

uint64_t APFSVolumeGetWVEK(char *a1, CFDataRef *a2)
{
  uint64_t result;
  int v5;
  size_t v6;
  mach_port_t connection;
  CFIndex outputStruct;
  UInt8 v9[2928];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v6 = 520;
  result = 22;
  if (a1 && a2)
  {
    connection = 0;
    bzero(&outputStruct, 0xB78uLL);
    v5 = apfs_container_iouc(a1, &outputStruct, &connection, 0, 0);
    LOWORD(a1) = v5;
    if (!v5)
    {
      LODWORD(a1) = IOConnectCallStructMethod(connection, 0x39u, &outputStruct, 4uLL, &outputStruct, &v6);
      IOServiceClose(connection);
      if (!(_DWORD)a1)
        *a2 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9, outputStruct);
    }
    return (unsigned __int16)a1 & 0x3FFF;
  }
  return result;
}

uint64_t APFSVolumeEnableUserProtectionWithOptions(char *a1, unsigned __int8 *uu, const __CFData *a3, uint64_t a4)
{
  int is_null;
  uint64_t result;
  uint64_t v10;
  int inputStruct;
  unsigned __int8 v12[20];
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v15;
  io_connect_t v16;
  size_t outputStructCnt;

  if (!a1)
    return 22;
  is_null = uuid_is_null(uu);
  result = 22;
  if (a3 && !is_null)
  {
    v16 = 0;
    bzero(&inputStruct, 0x978uLL);
    outputStructCnt = 0;
    v10 = apfs_container_iouc(a1, &inputStruct, &v16, 0, 0);
    if (!(_DWORD)v10)
    {
      uuid_copy(v12, uu);
      BytePtr = CFDataGetBytePtr(a3);
      Length = CFDataGetLength(a3);
      v15 = a4;
      v10 = IOConnectCallStructMethod(v16, 0x14u, &inputStruct, 0x30uLL, 0, &outputStructCnt);
      IOServiceClose(v16);
    }
    return rc_to_errno(v10);
  }
  return result;
}

uint64_t APFSVolumeGetUnlockRecord(char *a1, unsigned __int8 *a2, CFDataRef *a3)
{
  return _APFSVolumeGetUnlockRecordOrHint(a1, a2, 3, a3);
}

uint64_t _APFSVolumeGetUnlockRecordOrHint(char *a1, unsigned __int8 *uu, int a3, CFDataRef *a4)
{
  int is_null;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  mach_port_t connection;
  CFIndex outputStruct;
  UInt8 v15[12];
  __int16 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v12 = 520;
  if (!a1)
    return 22;
  is_null = uuid_is_null(uu);
  result = 22;
  if ((a3 - 5) >= 0xFFFFFFFE && !is_null)
  {
    connection = 0;
    bzero(&outputStruct, 0xB78uLL);
    v10 = apfs_container_iouc(a1, &outputStruct, &connection, 0, 0);
    if (!(_DWORD)v10)
    {
      uuid_copy((unsigned __int8 *)&outputStruct + 4, uu);
      v16 = a3;
      v11 = IOConnectCallStructMethod(connection, 0xDu, &outputStruct, 0x18uLL, &outputStruct, &v12);
      v10 = v11;
      if (a4)
      {
        if (!(_DWORD)v11)
          *a4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v15, outputStruct);
      }
      IOServiceClose(connection);
    }
    return rc_to_errno(v10);
  }
  return result;
}

uint64_t APFSVolumeGetHint(char *a1, unsigned __int8 *a2, CFDataRef *a3)
{
  return _APFSVolumeGetUnlockRecordOrHint(a1, a2, 4, a3);
}

uint64_t APFSVolumeListUUIDsOfUnlockRecords(char *a1, __CFArray **a2)
{
  CFTypeID TypeID;

  TypeID = CFStringGetTypeID();
  return _APFSVolumeGetUUIDsOfUnlockRecords(a1, a2, TypeID);
}

uint64_t _APFSVolumeGetUUIDsOfUnlockRecords(char *a1, __CFArray **a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  const __CFAllocator *v11;
  CFMutableArrayRef Mutable;
  CFUUIDBytes *v13;
  void *v14;
  const void *v15;
  __CFArray *v16;
  size_t v17;
  int v18;
  _QWORD outputStruct[303];
  io_connect_t v20;
  char out[40];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  result = 22;
  if (a1 && a2)
  {
    if (CFStringGetTypeID() == a3 || CFUUIDGetTypeID() == a3)
    {
      v20 = 0;
      bzero(outputStruct, 0x978uLL);
      v18 = 0;
      *a2 = 0;
      v7 = apfs_container_iouc(a1, &v18, &v20, 0, 0);
      if ((_DWORD)v7)
        return rc_to_errno(v7);
      LODWORD(outputStruct[0]) = v18;
      v17 = 8;
      v7 = IOConnectCallStructMethod(v20, 0x37u, outputStruct, 4uLL, outputStruct, &v17);
      if ((_DWORD)v7)
      {
LABEL_7:
        IOServiceClose(v20);
        return rc_to_errno(v7);
      }
      if (outputStruct[0])
      {
        v8 = (16 * outputStruct[0]) | 8;
        v9 = (uint64_t *)_apfs_malloc(v8);
        if (!v9)
        {
          v7 = 12;
          goto LABEL_7;
        }
        v10 = v9;
        *(_DWORD *)v9 = v18;
        *((_DWORD *)v9 + 1) = outputStruct[0];
        v17 = (16 * outputStruct[0]) | 8;
        v7 = IOConnectCallStructMethod(v20, 0xEu, v10, 8uLL, v10, &v17);
        if (!(_DWORD)v7)
        {
          v7 = *v10;
          v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *v10, MEMORY[0x1E0C9B378]);
          *a2 = Mutable;
          if (!Mutable)
          {
LABEL_28:
            v7 = 12;
            goto LABEL_29;
          }
          if (v7)
          {
            v13 = (CFUUIDBytes *)(v10 + 1);
            while (1)
            {
              memset(out, 0, 37);
              if (CFStringGetTypeID() == a3)
              {
                uuid_unparse(&v13->byte0, out);
                v14 = (void *)CFStringCreateWithCString(v11, out, 0x8000100u);
              }
              else
              {
                v14 = CFUUIDCreateFromUUIDBytes(v11, *v13);
              }
              v15 = v14;
              v16 = *a2;
              if (!v15)
                break;
              CFArrayAppendValue(v16, v15);
              CFRelease(v15);
              ++v13;
              if (!--v7)
                goto LABEL_29;
            }
            CFRelease(v16);
            *a2 = 0;
            goto LABEL_28;
          }
        }
LABEL_29:
        _apfs_free(v10, v8);
        goto LABEL_7;
      }
      *a2 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
      IOServiceClose(v20);
      if (*a2)
        return 0;
      else
        return 12;
    }
    else
    {
      return 22;
    }
  }
  return result;
}

uint64_t APFSVolumeListCFUUIDsOfUnlockRecords(char *a1, __CFArray **a2)
{
  CFTypeID v4;

  v4 = CFUUIDGetTypeID();
  return _APFSVolumeGetUUIDsOfUnlockRecords(a1, a2, v4);
}

uint64_t APFSVolumeUnlockUnlockRecord(char *a1, unsigned __int8 *a2, const void *a3)
{
  return _APFSVolumeUnlockVerifyUnlockRecord(a1, a2, a3, 0, 0, 0);
}

uint64_t _APFSVolumeUnlockVerifyUnlockRecord(char *a1, unsigned __int8 *uu, const void *a3, unsigned __int8 *a4, uint64_t a5, char a6)
{
  int v12;
  int is_null;
  uint64_t result;
  CFTypeID v15;
  int *p_inputStruct;
  uint64_t v17;
  CFIndex Length;
  size_t outputStructCnt;
  int inputStruct;
  char v21;
  unsigned __int8 v22[19];
  const UInt8 *BytePtr;
  CFIndex v24;
  uint64_t v25;
  io_connect_t v26;

  outputStructCnt = 0;
  if (!a1)
    return 22;
  v12 = a4 == 0;
  is_null = uuid_is_null(uu);
  result = 22;
  if (!a3 || is_null == v12)
    return result;
  v15 = CFGetTypeID(a3);
  if (v15 != CFDataGetTypeID())
    return 22;
  if (a4)
  {
    outputStructCnt = 16;
    p_inputStruct = &inputStruct;
  }
  else
  {
    p_inputStruct = 0;
  }
  v26 = 0;
  bzero(&inputStruct, 0x978uLL);
  v17 = apfs_container_iouc(a1, &inputStruct, &v26, 0, 0);
  if (!(_DWORD)v17)
  {
    uuid_copy(v22, uu);
    BytePtr = CFDataGetBytePtr((CFDataRef)a3);
    Length = CFDataGetLength((CFDataRef)a3);
    v21 = a6;
    v24 = Length;
    v25 = a5;
    v17 = IOConnectCallStructMethod(v26, 0xFu, &inputStruct, 0x30uLL, p_inputStruct, &outputStructCnt);
    IOServiceClose(v26);
    if (a4)
    {
      if (!(_DWORD)v17)
        uuid_copy(a4, (const unsigned __int8 *)&inputStruct);
    }
  }
  return rc_to_errno(v17);
}

uint64_t APFSVolumeUnlockUnlockRecordWithOptions(char *a1, unsigned __int8 *a2, const void *a3, uint64_t a4)
{
  return _APFSVolumeUnlockVerifyUnlockRecord(a1, a2, a3, 0, a4, 0);
}

uint64_t APFSVolumeUnlockAnyUnlockRecord(char *a1, const void *a2, unsigned __int8 *a3)
{
  uuid_t uu;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  memset(uu, 0, sizeof(uu));
  uuid_clear(uu);
  return _APFSVolumeUnlockVerifyUnlockRecord(a1, uu, a2, a3, 0, 0);
}

uint64_t APFSVolumeUnlockAnyUnlockRecordWithOptions(char *a1, const void *a2, unsigned __int8 *a3, uint64_t a4)
{
  uuid_t uu;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  memset(uu, 0, sizeof(uu));
  uuid_clear(uu);
  return _APFSVolumeUnlockVerifyUnlockRecord(a1, uu, a2, a3, a4, 0);
}

uint64_t APFSVolumeVerifyUnlockRecord(char *a1, unsigned __int8 *a2, const void *a3)
{
  return _APFSVolumeUnlockVerifyUnlockRecord(a1, a2, a3, 0, 0, 1);
}

uint64_t APFSVolumeVerifyUnlockRecordWithOptions(char *a1, unsigned __int8 *a2, const void *a3, uint64_t a4)
{
  return _APFSVolumeUnlockVerifyUnlockRecord(a1, a2, a3, 0, a4, 1);
}

uint64_t APFSVolumeUnlockGetUnlockRecordState(char *a1, unsigned __int8 *uu, __CFDictionary **a3)
{
  int is_null;
  uint64_t result;
  uint64_t v8;
  const __CFAllocator *v9;
  CFNumberRef v10;
  CFNumberRef v11;
  int v12;
  __CFDictionary *Mutable;
  __CFDictionary *v14;
  const void *v15;
  uint64_t v16;
  size_t outputStructCnt;
  unsigned int outputStruct;
  unsigned __int8 v19[2424];
  io_connect_t v20;

  outputStructCnt = 8;
  if (!a1)
    return 22;
  is_null = uuid_is_null(uu);
  result = 22;
  if (a3 && !is_null)
  {
    v20 = 0;
    bzero(&outputStruct, 0x978uLL);
    v8 = apfs_container_iouc(a1, &outputStruct, &v20, 0, 0);
    if (!(_DWORD)v8)
    {
      uuid_copy(v19, uu);
      v8 = IOConnectCallStructMethod(v20, 0x20u, &outputStruct, 0x14uLL, &outputStruct, &outputStructCnt);
      IOServiceClose(v20);
      if (!(_DWORD)v8)
      {
        v16 = outputStruct;
        v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v10 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberLongType, &v16);
        if (v10)
        {
          v11 = v10;
          v12 = v19[0];
          Mutable = CFDictionaryCreateMutable(v9, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          if (Mutable)
          {
            v14 = Mutable;
            if (v12)
              v15 = (const void *)*MEMORY[0x1E0C9AE50];
            else
              v15 = (const void *)*MEMORY[0x1E0C9AE40];
            CFDictionaryAddValue(Mutable, CFSTR("Backoff"), v11);
            CFDictionaryAddValue(v14, CFSTR("LockedOut"), v15);
            v8 = 0;
            *a3 = v14;
          }
          else
          {
            v8 = 12;
          }
          CFRelease(v11);
        }
        else
        {
          v8 = 12;
        }
      }
    }
    return rc_to_errno(v8);
  }
  return result;
}

uint64_t APFSVolumeAddUnlockRecords(char *a1, unsigned __int8 *a2, const void *a3, const void *a4)
{
  return _APFSVolumeAddUnlockRecordsOrHints(a1, a2, a3, a4, 3, 0);
}

uint64_t _APFSVolumeAddUnlockRecordsOrHints(char *a1, unsigned __int8 *uu, const void *a3, const void *a4, int a5, uint64_t a6)
{
  uint64_t result;
  CFTypeID v13;
  CFTypeID v14;
  CFIndex Count;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  unint64_t v21;
  NSObject *v22;
  int v23;
  int v24;
  void *v25;
  unint64_t v26;
  unint64_t v27;
  void *v28;
  unsigned int v29;
  size_t outputStructCnt;
  _DWORD context[2];
  unsigned __int8 v32[16];
  const UInt8 *BytePtr;
  CFIndex Length;
  unsigned int v35;
  unsigned __int8 *v36;
  _QWORD *v37;
  uint64_t v38;
  mach_port_t connection;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;
  __int16 v46;
  char *v47;
  __int16 v48;
  char *v49;
  __int16 v50;
  char *v51;
  __int16 v52;
  int v53;
  char v54[48];
  char out[40];
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  outputStructCnt = 0;
  if (!a1)
    return 22;
  if (uuid_is_null(uu))
    return 22;
  if (a4)
  {
    v13 = CFGetTypeID(a4);
    if (v13 != CFDictionaryGetTypeID())
      return 22;
  }
  v14 = CFGetTypeID(a3);
  if (v14 != CFDataGetTypeID())
    return 22;
  if (a5 != 5 || (result = _APFSVolumeUnlockVerifyUnlockRecord(a1, uu, a3, 0, a6, 1), !(_DWORD)result))
  {
    connection = 0;
    bzero(context, 0x978uLL);
    memset(out, 0, 37);
    memset(v54, 0, 37);
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v29 = apfs_container_iouc(a1, context, &connection, 0, 0);
    if (!v29)
    {
      context[1] = a5;
      uuid_copy(v32, uu);
      BytePtr = CFDataGetBytePtr((CFDataRef)a3);
      Length = CFDataGetLength((CFDataRef)a3);
      v38 = a6;
      if (a4)
      {
        Count = CFDictionaryGetCount((CFDictionaryRef)a4);
        v36 = (unsigned __int8 *)_apfs_malloc(16 * Count);
        if (!v36 || (v16 = CFDictionaryGetCount((CFDictionaryRef)a4), (v37 = _apfs_calloc(v16, 8uLL)) == 0))
        {
LABEL_20:
          v19 = 12;
LABEL_21:
          v29 = v19;
          goto LABEL_22;
        }
        if (CFDictionaryGetCount((CFDictionaryRef)a4) >= 1)
        {
          v17 = 0;
          do
          {
            v37[v17] = _apfs_malloc(0x10uLL);
            if (!v37[v17])
              goto LABEL_20;
          }
          while (CFDictionaryGetCount((CFDictionaryRef)a4) > ++v17);
        }
        CFDictionaryApplyFunction((CFDictionaryRef)a4, (CFDictionaryApplierFunction)records_callback, context);
        v18 = v35;
        if (CFDictionaryGetCount((CFDictionaryRef)a4) != v18)
        {
          v19 = 22;
          goto LABEL_21;
        }
      }
      v29 = IOConnectCallStructMethod(connection, 0x10u, context, 0x48uLL, 0, &outputStructCnt);
      IOServiceClose(connection);
    }
LABEL_22:
    uuid_unparse(uu, out);
    if (v35)
    {
      v20 = 0;
      v21 = 0;
      v22 = MEMORY[0x1E0C81028];
      do
      {
        uuid_unparse(&v36[v20], v54);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          v23 = rc_to_errno(v29);
          *(_DWORD *)buf = 136316674;
          v41 = "_APFSVolumeAddUnlockRecordsOrHints";
          v42 = 1024;
          v43 = 1777;
          v44 = 1024;
          v45 = a5;
          v46 = 2080;
          v47 = out;
          v48 = 2080;
          v49 = v54;
          v50 = 2080;
          v51 = a1;
          v52 = 1024;
          v53 = v23;
          _os_log_impl(&dword_1DF291000, v22, OS_LOG_TYPE_DEFAULT, "%s:%d: UR_ADD_UPDATE_SET [ OP = %u, SRC UUID = %s, DST UUID = %s, VOLUME = %s, ret = %d ]\n", buf, 0x3Cu);
        }
        ++v21;
        v20 += 16;
      }
      while (v21 < v35);
    }
    else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v24 = rc_to_errno(v29);
      *(_DWORD *)buf = 136316418;
      v41 = "_APFSVolumeAddUnlockRecordsOrHints";
      v42 = 1024;
      v43 = 1773;
      v44 = 1024;
      v45 = a5;
      v46 = 2080;
      v47 = out;
      v48 = 2080;
      v49 = a1;
      v50 = 1024;
      LODWORD(v51) = v24;
      _os_log_impl(&dword_1DF291000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%s:%d: UR_ADD_UPDATE_SET [ OP = %u, UUID = %s, VOLUME = %s, ret = %d ]\n", buf, 0x32u);
    }
    if (v36)
      _apfs_free(v36, 16 * v35);
    v25 = v37;
    if (v37)
    {
      v26 = v35;
      if (v35)
      {
        v27 = 0;
        do
        {
          v28 = (void *)v37[v27];
          if (v28)
          {
            _apfs_free(v28, 16);
            v26 = v35;
          }
          ++v27;
        }
        while (v27 < v26);
        v25 = v37;
      }
      else
      {
        v26 = 0;
      }
      _apfs_free(v25, 8 * v26);
    }
    return rc_to_errno(v29);
  }
  return result;
}

uint64_t APFSVolumeAddUnlockRecordsWithOptions(char *a1, unsigned __int8 *a2, const void *a3, const void *a4, uint64_t a5)
{
  return _APFSVolumeAddUnlockRecordsOrHints(a1, a2, a3, a4, 3, a5);
}

uint64_t APFSVolumeAddHints(char *a1, unsigned __int8 *a2, const void *a3, const void *a4)
{
  return _APFSVolumeAddUnlockRecordsOrHints(a1, a2, a3, a4, 5, 0);
}

uint64_t APFSVolumeAddHintsWithOptions(char *a1, unsigned __int8 *a2, const void *a3, const void *a4, uint64_t a5)
{
  return _APFSVolumeAddUnlockRecordsOrHints(a1, a2, a3, a4, 5, a5);
}

uint64_t APFSVolumeSetHint(char *a1, unsigned __int8 *uu, const void *a3)
{
  int is_null;

  if (a1 && (is_null = uuid_is_null(uu), a3) && !is_null && CFDataGetLength((CFDataRef)a3))
    return _APFSVolumeAddUnlockRecordsOrHints(a1, uu, a3, 0, 4, 0);
  else
    return 22;
}

uint64_t APFSVolumeSetUnlockRecord(char *a1, unsigned __int8 *uu, const void *a3)
{
  int is_null;

  if (a1 && (is_null = uuid_is_null(uu), a3) && !is_null && CFDataGetLength((CFDataRef)a3))
    return _APFSVolumeAddUnlockRecordsOrHints(a1, uu, a3, 0, 1, 0);
  else
    return 22;
}

uint64_t APFSVolumeResetUnlockRecord(char *a1, unsigned __int8 *a2, const __CFData *a3, const unsigned __int8 *a4, const __CFData *a5)
{
  return APFSVolumeResetUnlockRecordWithOptions(a1, a2, a3, a4, a5, 0);
}

uint64_t APFSVolumeResetUnlockRecordWithOptions(char *a1, unsigned __int8 *uu, const __CFData *a3, const unsigned __int8 *a4, const __CFData *a5, uint64_t a6)
{
  uint64_t result;
  int is_null;
  CFTypeID v14;
  CFTypeID v15;
  uint64_t v16;
  int v17;
  const UInt8 *v18;
  CFIndex v19;
  size_t outputStructCnt;
  _DWORD inputStruct[2];
  unsigned __int8 v22[16];
  const UInt8 *BytePtr;
  CFIndex Length;
  int v25;
  unsigned __int8 *v26;
  _QWORD *v27;
  uint64_t v28;
  io_connect_t v29;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  char *v37;
  __int16 v38;
  char *v39;
  __int16 v40;
  char *v41;
  __int16 v42;
  int v43;
  char v44[48];
  char out[40];
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  outputStructCnt = 0;
  if (!a1 || uuid_is_null(uu))
    return 22;
  is_null = uuid_is_null(a4);
  result = 22;
  if (a5 && a3 && !is_null)
  {
    if (!CFDataGetLength(a3))
      return 22;
    if (!CFDataGetLength(a5))
      return 22;
    v14 = CFGetTypeID(a3);
    if (v14 != CFDataGetTypeID())
      return 22;
    v15 = CFGetTypeID(a5);
    if (v15 != CFDataGetTypeID())
      return 22;
    v29 = 0;
    bzero(inputStruct, 0x978uLL);
    v18 = 0;
    v19 = 0;
    memset(out, 0, 37);
    memset(v44, 0, 37);
    v16 = apfs_container_iouc(a1, inputStruct, &v29, 0, 0);
    if (!(_DWORD)v16)
    {
      inputStruct[1] = 3;
      uuid_copy(v22, uu);
      BytePtr = CFDataGetBytePtr(a3);
      Length = CFDataGetLength(a3);
      v25 = 1;
      v26 = (unsigned __int8 *)_apfs_malloc(0x10uLL);
      uuid_copy(v26, a4);
      v18 = CFDataGetBytePtr(a5);
      v19 = CFDataGetLength(a5);
      v27 = _apfs_malloc(8uLL);
      *v27 = &v18;
      v28 = a6;
      v16 = IOConnectCallStructMethod(v29, 0x10u, inputStruct, 0x48uLL, 0, &outputStructCnt);
      _apfs_free(v27, 8);
      _apfs_free(v26, 16);
      IOServiceClose(v29);
    }
    uuid_unparse(uu, out);
    uuid_unparse(a4, v44);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v17 = rc_to_errno(v16);
      *(_DWORD *)buf = 136316674;
      v31 = "APFSVolumeResetUnlockRecordWithOptions";
      v32 = 1024;
      v33 = 1880;
      v34 = 1024;
      v35 = 3;
      v36 = 2080;
      v37 = out;
      v38 = 2080;
      v39 = v44;
      v40 = 2080;
      v41 = a1;
      v42 = 1024;
      v43 = v17;
      _os_log_impl(&dword_1DF291000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%s:%d: UR_RESET_UPDATE [ OP = %u, SRC UUID = %s, DST UUID = %s, VOLUME = %s, ret = %d ]\n", buf, 0x3Cu);
    }
    return rc_to_errno(v16);
  }
  return result;
}

uint64_t APFSVolumeUpdateUnlockRecord(char *a1, unsigned __int8 *a2, const __CFData *a3, const __CFData *a4)
{
  return APFSVolumeResetUnlockRecordWithOptions(a1, a2, a3, a2, a4, 0);
}

uint64_t APFSVolumeUpdateUnlockRecordWithOptions(char *a1, unsigned __int8 *a2, const __CFData *a3, const __CFData *a4, uint64_t a5)
{
  return APFSVolumeResetUnlockRecordWithOptions(a1, a2, a3, a2, a4, a5);
}

uint64_t APFSVolumeRemoveHint(char *a1, unsigned __int8 *uu)
{
  if (a1 && !uuid_is_null(uu))
    return _APFSVolumeRemoveUnlockRecordsOrHint(a1, uu, 4);
  else
    return 22;
}

uint64_t _APFSVolumeRemoveUnlockRecordsOrHint(char *a1, const unsigned __int8 *a2, int a3)
{
  uint64_t v6;
  int v7;
  NSObject *v8;
  const char *v9;
  uint32_t v10;
  int v11;
  size_t outputStructCnt;
  int inputStruct;
  unsigned __int8 v15[16];
  __int16 v16;
  io_connect_t v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  char *v27;
  __int16 v28;
  int v29;
  char out[40];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v17 = 0;
  bzero(&inputStruct, 0x978uLL);
  outputStructCnt = 0;
  v16 = a3;
  v6 = apfs_container_iouc(a1, &inputStruct, &v17, 0, 0);
  if (!(_DWORD)v6)
  {
    if (uuid_is_null(a2))
      uuid_clear(v15);
    else
      uuid_copy(v15, a2);
    v6 = IOConnectCallStructMethod(v17, 0x11u, &inputStruct, 0x18uLL, 0, &outputStructCnt);
    IOServiceClose(v17);
  }
  if (uuid_is_null(a2))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v7 = rc_to_errno(v6);
      *(_DWORD *)buf = 136315906;
      v19 = "_APFSVolumeRemoveUnlockRecordsOrHint";
      v20 = 1024;
      v21 = 1919;
      v22 = 2080;
      v23 = a1;
      v24 = 1024;
      v25 = v7;
      v8 = MEMORY[0x1E0C81028];
      v9 = "%s:%d: UR_WIPE [ VOLUME = %s, ret = %d ]\n";
      v10 = 34;
LABEL_11:
      _os_log_impl(&dword_1DF291000, v8, OS_LOG_TYPE_DEFAULT, v9, buf, v10);
    }
  }
  else
  {
    memset(out, 0, 37);
    uuid_unparse(a2, out);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v11 = rc_to_errno(v6);
      *(_DWORD *)buf = 136316418;
      v19 = "_APFSVolumeRemoveUnlockRecordsOrHint";
      v20 = 1024;
      v21 = 1923;
      v22 = 2080;
      v23 = out;
      v24 = 1024;
      v25 = a3;
      v26 = 2080;
      v27 = a1;
      v28 = 1024;
      v29 = v11;
      v8 = MEMORY[0x1E0C81028];
      v9 = "%s:%d: UR_REMOVE [ UUID = %s, tag = %d, VOLUME = %s, ret = %d ]\n";
      v10 = 50;
      goto LABEL_11;
    }
  }
  return rc_to_errno(v6);
}

uint64_t APFSVolumeRemoveUnlockRecord(char *a1, unsigned __int8 *uu)
{
  uint64_t result;

  if (!a1 || uuid_is_null(uu))
    return 22;
  result = _APFSVolumeRemoveUnlockRecordsOrHint(a1, uu, 3);
  if (!(_DWORD)result)
  {
    result = _APFSVolumeGetUnlockRecordOrHint(a1, uu, 4, 0);
    if ((_DWORD)result == 2)
    {
      return 0;
    }
    else if (!(_DWORD)result)
    {
      return _APFSVolumeRemoveUnlockRecordsOrHint(a1, uu, 4);
    }
  }
  return result;
}

uint64_t APFSVolumeGeneratePersonalRecoveryKey()
{
  return 0;
}

uint64_t APFSVolumeEscrowVEK()
{
  return 45;
}

uint64_t APFSVolumeQueryCryptoProgress()
{
  return 45;
}

uint64_t APFSVolumeResumeCrypto()
{
  return 45;
}

uint64_t APFSVolumePauseCrypto()
{
  return 45;
}

uint64_t APFSVolumeEnableFilevaultWithOptions(char *a1)
{
  if (mounted_device(a1, 0))
    return 45;
  else
    return 22;
}

uint64_t APFSVolumeEnableFilevault(char *a1)
{
  if (mounted_device(a1, 0))
    return 45;
  else
    return 22;
}

uint64_t APFSVolumeDisableFileVaultWithOptions(char *a1)
{
  uint64_t v2;
  unsigned __int16 v4;

  if (!mounted_device(a1, 0))
    return 22;
  v4 = 0;
  v2 = APFSVolumeRole(a1, &v4, 0);
  if ((_DWORD)v2)
    return rc_to_errno(v2);
  if (v4 == 576)
    return 1;
  return 45;
}

uint64_t APFSVolumeEnableUserProtection(char *a1, unsigned __int8 *a2, const __CFData *a3)
{
  return APFSVolumeEnableUserProtectionWithOptions(a1, a2, a3, 0);
}

uint64_t APFSVolumeBindNewKEKToVEKWithOptions(char *a1, unsigned __int8 *uu, const __CFData *a3, const __CFData *a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v11;
  size_t outputStructCnt;
  int inputStruct;
  unsigned __int8 v14[20];
  const UInt8 *BytePtr;
  CFIndex Length;
  const UInt8 *v17;
  CFIndex v18;
  uint64_t v19;
  io_connect_t v20;

  result = 22;
  if (a1 && a3 && a4)
  {
    if (uuid_is_null(uu))
    {
      return 22;
    }
    else
    {
      v20 = 0;
      bzero(&inputStruct, 0x978uLL);
      v11 = apfs_container_iouc(a1, &inputStruct, &v20, 0, 0);
      if (!(_DWORD)v11)
      {
        outputStructCnt = 0;
        uuid_copy(v14, uu);
        BytePtr = CFDataGetBytePtr(a3);
        Length = CFDataGetLength(a3);
        v17 = CFDataGetBytePtr(a4);
        v18 = CFDataGetLength(a4);
        v19 = a5;
        v11 = IOConnectCallStructMethod(v20, 0x16u, &inputStruct, 0x40uLL, 0, &outputStructCnt);
        IOServiceClose(v20);
      }
      return rc_to_errno(v11);
    }
  }
  return result;
}

uint64_t APFSVolumeBindNewKEKToVEK(char *a1, unsigned __int8 *a2, const __CFData *a3, const __CFData *a4)
{
  return APFSVolumeBindNewKEKToVEKWithOptions(a1, a2, a3, a4, 0);
}

uint64_t APFSContainerGetDefrag()
{
  return 45;
}

uint64_t APFSContainerSetDefrag()
{
  return 45;
}

uint64_t APFSVolumeGetDefrag()
{
  return 45;
}

uint64_t APFSVolumeSetDefrag()
{
  return 45;
}

uint64_t APFSVolumeInfoForUnmountedDisk()
{
  return 45;
}

uint64_t APFSContainerEFIEmbed()
{
  return 45;
}

uint64_t APFSContainerEFIGetVersion()
{
  return 45;
}

uint64_t APFSContainerGetBootDevice(_QWORD *a1)
{
  const __CFDictionary *v2;
  uint64_t MatchingServices;
  uint64_t v4;
  io_object_t v5;
  io_object_t v6;
  const __CFAllocator *v7;
  NSObject *v8;
  const __CFArray *CFProperty;
  const __CFArray *v10;
  CFTypeID v11;
  uint64_t ParentEntry;
  io_object_t v13;
  CFTypeRef v15;
  char context;
  uint64_t v17;
  uint64_t entryID;
  io_registry_entry_t entry;
  io_registry_entry_t parent;
  io_iterator_t existing;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;
  CFRange v29;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 49174;
  existing = 0;
  v2 = IOServiceMatching("AppleAPFSVolume");
  if (v2)
  {
    MatchingServices = IOServiceGetMatchingServices(*MEMORY[0x1E0CBBAB8], v2, &existing);
    if (!(_DWORD)MatchingServices)
    {
      v5 = IOIteratorNext(existing);
      if (v5)
      {
        v6 = v5;
        v4 = 0;
        v15 = 0;
        v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v8 = MEMORY[0x1E0C81028];
        do
        {
          entry = 0;
          parent = 0;
          v17 = 0;
          entryID = 0;
          IORegistryEntryGetRegistryEntryID(v6, &entryID);
          CFProperty = (const __CFArray *)IORegistryEntryCreateCFProperty(v6, CFSTR("Role"), v7, 0);
          if (CFProperty)
          {
            v10 = CFProperty;
            v11 = CFGetTypeID(CFProperty);
            if (v11 == CFArrayGetTypeID())
            {
              context = 0;
              v29.length = CFArrayGetCount(v10);
              v29.location = 0;
              CFArrayApplyFunction(v10, v29, (CFArrayApplierFunction)is_system_role, &context);
              if (context)
              {
                ParentEntry = IORegistryEntryGetParentEntry(v6, "IOService", &parent);
                if ((_DWORD)ParentEntry)
                {
                  v4 = ParentEntry;
                  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136315650;
                    v23 = "APFSContainerGetBootDevice";
                    v24 = 1024;
                    v25 = 2799;
                    v26 = 2048;
                    v27 = entryID;
                    _os_log_error_impl(&dword_1DF291000, v8, OS_LOG_TYPE_ERROR, "%s:%d: failed to get parent for volume 0x%llx\n", buf, 0x1Cu);
                  }
                }
                else
                {
                  IORegistryEntryGetRegistryEntryID(parent, &v17);
                  v4 = IORegistryEntryGetParentEntry(parent, "IOService", &entry);
                  if ((_DWORD)v4)
                  {
                    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136315650;
                      v23 = "APFSContainerGetBootDevice";
                      v24 = 1024;
                      v25 = 2806;
                      v26 = 2048;
                      v27 = v17;
                      _os_log_error_impl(&dword_1DF291000, v8, OS_LOG_TYPE_ERROR, "%s:%d: failed to get parent for container 0x%llx\n", buf, 0x1Cu);
                    }
                    v13 = parent;
                  }
                  else
                  {
                    v15 = IORegistryEntryCreateCFProperty(entry, CFSTR("BSD Name"), v7, 0);
                    if (!v15)
                    {
                      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 136315650;
                        v23 = "APFSContainerGetBootDevice";
                        v24 = 1024;
                        v25 = 2813;
                        v26 = 2048;
                        v27 = v17;
                        _os_log_error_impl(&dword_1DF291000, v8, OS_LOG_TYPE_ERROR, "%s:%d: failed to create bsd name for container: %llx\n", buf, 0x1Cu);
                      }
                      v4 = 49164;
                    }
                    IOObjectRelease(parent);
                    v13 = entry;
                  }
                  IOObjectRelease(v13);
                }
              }
            }
            else
            {
              if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136315394;
                v23 = "APFSContainerGetBootDevice";
                v24 = 1024;
                v25 = 2783;
                _os_log_error_impl(&dword_1DF291000, v8, OS_LOG_TYPE_ERROR, "%s:%d: volume roles property isnt of correct type. Expected CFArray\n", buf, 0x12u);
              }
              v4 = 49174;
            }
            CFRelease(v10);
          }
          IOObjectRelease(v6);
          v6 = IOIteratorNext(existing);
        }
        while (v6);
        IOObjectRelease(existing);
        if (v15)
        {
          *a1 = v15;
          return v4;
        }
        if ((_DWORD)v4)
          return v4;
      }
      else
      {
        IOObjectRelease(existing);
      }
      return 49154;
    }
    v4 = MatchingServices;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      APFSContainerGetBootDevice_cold_2(v4);
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      APFSContainerGetBootDevice_cold_1();
    return 49164;
  }
  return v4;
}

CFTypeID is_system_role(const __CFString *a1, _BYTE *a2)
{
  CFTypeID v4;
  CFTypeID result;

  v4 = CFGetTypeID(a1);
  result = CFStringGetTypeID();
  if (v4 == result)
  {
    result = CFStringCompare(a1, CFSTR("System"), 0);
    if (!result)
      *a2 = 1;
  }
  return result;
}

uint64_t APFSSetupMetadataRollingMediaKey(char *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  CFArrayRef v6;
  const __CFString *ValueAtIndex;
  uint64_t v8;
  CFArrayRef theArray;
  char buffer[16];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  _BYTE v24[31];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  theArray = 0;
  if (!a1)
    return 22;
  v2 = 0;
  if (keygen_nvram_prop(0))
  {
    v23 = 0u;
    memset(v24, 0, sizeof(v24));
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v18 = 0u;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    v12 = 0u;
    v13 = 0u;
    *(_OWORD *)buffer = 0u;
    v11 = 0u;
    v3 = APFSVolumeRoleFind(a1, 64, &theArray);
    if ((_DWORD)v3)
    {
      v4 = v3;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        APFSSetupMetadataRollingMediaKey_cold_3(v4);
      return rc_to_errno(v4);
    }
    v6 = theArray;
    if (CFArrayGetCount(theArray) >= 2)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        APFSSetupMetadataRollingMediaKey_cold_1();
        if (!v6)
          return 45;
      }
      else if (!v6)
      {
        return 45;
      }
      CFRelease(v6);
      return 45;
    }
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, 0);
    CFStringGetCString(ValueAtIndex, buffer, 32, 0x8000100u);
    if (v6)
      CFRelease(v6);
    v8 = _APFSVolumeOperation(buffer, 0x3Cu);
    v2 = rc_to_errno(v8);
    if ((_DWORD)v2)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        APFSSetupMetadataRollingMediaKey_cold_2();
    }
    else
    {
      keygen_nvram_prop(1);
    }
  }
  return v2;
}

uint64_t APFSContainerMigrateMediaKeys(char *a1)
{
  uint64_t v2;
  size_t v4;
  mach_port_t connection;

  connection = 0;
  v4 = 0;
  v2 = apfs_container_iouc(a1, 0, &connection, 0, 0);
  if (!(_DWORD)v2)
  {
    v2 = IOConnectCallStructMethod(connection, 0x30u, 0, 0, 0, &v4);
    IOServiceClose(connection);
  }
  APFSSetupMetadataRollingMediaKey(a1);
  return v2;
}

uint64_t APFSMakeCompatibleName(const char *a1, _QWORD *a2)
{
  size_t v3;
  unint64_t v4;
  uint64_t result;
  _BYTE *v6;
  _BYTE *v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  void *v12;
  void *v13;

  v3 = strlen(a1);
  if (!a2)
    return 22;
  v4 = v3;
  if (v3 > 0x2FD)
    return 63;
  if (!v3)
    return 22;
  v6 = malloc_type_malloc(0x2FEuLL, 0x309D8387uLL);
  if (!v6)
    return 12;
  v7 = v6;
  __memcpy_chk();
  if (!utf8_normalizeOptCaseFoldAndHash((unint64_t)v7, v4, 0, (void (*)(_OWORD *, uint64_t, uint64_t))nop_hash_func, 0))
  {
LABEL_17:
    v7[v4] = 0;
    v12 = malloc_type_realloc(v7, v4 + 1, 0x346EA987uLL);
    if (v12)
    {
      v13 = v12;
      result = 0;
      *a2 = v13;
      return result;
    }
    free(v7);
    return 12;
  }
  v8 = 0;
  while (1)
  {
    v9 = (char)v7[v8];
    if ((v9 & 0x80000000) == 0)
    {
      v10 = 1;
      goto LABEL_13;
    }
    v10 = 0;
    do
    {
      LOBYTE(v9) = 2 * v9;
      ++v10;
    }
    while ((v9 & 0x80) != 0);
    if (v10 >= 5)
      break;
LABEL_13:
    v11 = v10 + v8;
    if (utf8_normalizeOptCaseFoldAndHash((unint64_t)v7, v10 + v8, 0, (void (*)(_OWORD *, uint64_t, uint64_t))nop_hash_func, 0))
    {
      v7[v8++] = 63;
      memmove(&v7[v8], &v7[v11], v4 - v11);
      v4 = v4 - v10 + 1;
    }
    else
    {
      v8 += v10;
    }
    if (v8 >= v4)
      goto LABEL_17;
  }
  free(v7);
  return 92;
}

uint64_t APFSUniquifyName(char *a1, char **a2, unint64_t a3)
{
  size_t v6;
  uint64_t result;
  size_t v8;
  char *v9;
  const char *v10;
  int64_t v11;
  size_t v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;
  unint64_t v16;
  size_t v17;
  size_t v18;
  char *v19;
  char *v20;

  if (!a2)
    return 22;
  v6 = strlen(a1);
  if (v6 > 0x2FD)
    return 63;
  v8 = v6;
  if (!v6)
    return 22;
  if (utf8_normalizeOptCaseFoldAndHash((unint64_t)a1, v6, 0, (void (*)(_OWORD *, uint64_t, uint64_t))nop_hash_func, 0))return 92;
  v9 = strrchr(a1, 46);
  if (!v9 || (v10 = v9, v11 = v9 - a1, v9 == a1) || (v12 = v8 - v11, v8 - v11 - 746 <= 0xFFFFFFFFFFFFFD01))
  {
    v12 = 0;
    v10 = "";
  }
  else
  {
    v8 = v9 - a1;
  }
  v13 = 0;
  if (a3)
  {
    v14 = a3;
    do
    {
      ++v13;
      v15 = v14 > 9;
      v14 /= 0xAuLL;
    }
    while (v15);
  }
  if (v13 <= 1)
    v13 = 1;
  v16 = v13 + v12;
  v17 = v16 + v8;
  if (v16 + v8 >= 0x2FE)
  {
    result = 92;
    while (v8)
    {
      if (a1[--v8] < 0)
      {
        while ((a1[v8] & 0xC0) == 0x80)
        {
          if (--v8 >= 0xFFFFFFFFFFFFFFFELL)
            return result;
        }
      }
      v17 = v16 + v8;
      if (v16 + v8 <= 0x2FD)
        goto LABEL_28;
    }
    return 92;
  }
LABEL_28:
  v18 = v17 + 1;
  v19 = (char *)malloc_type_malloc(v17 + 1, 0x5599769BuLL);
  if (!v19)
    return 12;
  v20 = v19;
  memcpy(v19, a1, v8);
  snprintf(&v20[v8], v18 - v8, "%llu%s", a3, v10);
  result = 0;
  *a2 = v20;
  return result;
}

uint64_t APFSContainerGetFreeExtentHistogram(io_service_t a1, __CFDictionary *a2)
{
  uint64_t free_extent_hist;
  io_connect_t connect;

  free_extent_hist = 49174;
  if (a1)
  {
    if (a2)
    {
      if (IOObjectConformsTo(a1, "AppleAPFSContainer"))
      {
        connect = 0;
        free_extent_hist = IOServiceOpen(a1, *MEMORY[0x1E0C83DA0], 0, &connect);
        if (!(_DWORD)free_extent_hist)
        {
          free_extent_hist = get_free_extent_hist(connect, a2);
          IOServiceClose(connect);
        }
      }
    }
  }
  return free_extent_hist;
}

uint64_t get_free_extent_hist(mach_port_t a1, __CFDictionary *a2)
{
  uint64_t result;
  CFMutableArrayRef Mutable;
  __CFArray *v6;
  CFIndex i;
  CFNumberRef v8;
  CFNumberRef v9;
  size_t v10;
  _BYTE outputStruct[272];
  uint64_t v12;

  bzero(outputStruct, 0x978uLL);
  v10 = 280;
  outputStruct[0] = 1;
  result = IOConnectCallStructMethod(a1, 0x1Fu, outputStruct, 1uLL, outputStruct, &v10);
  if (!(_DWORD)result)
  {
    Mutable = CFArrayCreateMutable(0, 32, 0);
    if (Mutable)
    {
      v6 = Mutable;
      for (i = 0; i != 32; ++i)
        CFArraySetValueAtIndex(v6, i, *(const void **)&outputStruct[8 * i + 16]);
      CFDictionaryAddValue(a2, CFSTR("Histogram for free extents sizes, number of buckets is"), v6);
      CFRelease(v6);
      v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &v12);
      if (v8)
      {
        v9 = v8;
        CFDictionaryAddValue(a2, CFSTR("Small free extents count"), v8);
        CFRelease(v9);
        return 0;
      }
      CFDictionaryRemoveValue(a2, CFSTR("Histogram for free extents sizes, number of buckets is"));
    }
    return 49164;
  }
  return result;
}

uint64_t APFSStatisticsProcessContainer(uint64_t a1, int a2, __CFDictionary *a3, CFTypeRef *a4)
{
  uint64_t free_extent_hist;
  mach_port_t v9;
  io_object_t v10;
  io_object_t v11;
  int v12;
  const __CFAllocator *v13;
  uint64_t v14;
  const __CFString *CFProperty;
  const __CFString *v16;
  CFStringEncoding SystemEncoding;
  kern_return_t v18;
  mach_error_t v19;
  char *v20;
  __CFDictionary *Mutable;
  __CFDictionary *v22;
  char *v23;
  FTS *v24;
  FTS *v25;
  FTSENT *v26;
  unsigned __int16 fts_info;
  uint64_t st_blocks;
  unsigned int v29;
  FTSENT *v30;
  unint64_t i;
  _QWORD *v32;
  unsigned int v33;
  int v34;
  CFMutableArrayRef v35;
  __CFArray *v36;
  CFIndex j;
  CFMutableArrayRef v38;
  __CFArray *v39;
  CFIndex k;
  mach_port_t v42;
  CFIndex capacity;
  io_registry_entry_t parent[2];
  size_t outputStructCnt;
  int outputStruct;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  io_iterator_t iterator[2];
  _OWORD v55[8];
  _QWORD buf[6];
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  char buffer[16];
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  char *v70[5];

  v70[2] = *(char **)MEMORY[0x1E0C80C00];
  free_extent_hist = 49174;
  if (!(_DWORD)a1 || !a3 || !IOObjectConformsTo(a1, "AppleAPFSContainer"))
    return free_extent_hist;
  *(_QWORD *)parent = 0;
  if (a4 && !IORegistryEntryGetParentEntry(a1, "IOService", &parent[1]))
  {
    *a4 = IORegistryEntryCreateCFProperty(parent[1], CFSTR("BSD Name"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    IOObjectRelease(parent[1]);
  }
  free_extent_hist = IOServiceOpen(a1, *MEMORY[0x1E0C83DA0], 0, parent);
  if ((_DWORD)free_extent_hist)
    return free_extent_hist;
  if (a2)
  {
    free_extent_hist = get_free_extent_hist(parent[0], a3);
    if ((_DWORD)free_extent_hist)
      goto LABEL_66;
  }
  v9 = parent[0];
  *(_QWORD *)iterator = 0;
  if (MEMORY[0x1E0BFCCC0](a1, "IOService", &iterator[1]))
    goto LABEL_65;
  v10 = IOIteratorNext(iterator[1]);
  if (!v10)
    goto LABEL_64;
  v11 = v10;
  v12 = 0;
  v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (a2)
    v14 = 8;
  else
    v14 = 6;
  capacity = v14;
  do
  {
    CFProperty = (const __CFString *)IORegistryEntryCreateCFProperty(v11, CFSTR("BSD Name"), v13, 0);
    if (!CFProperty)
      goto LABEL_62;
    v16 = CFProperty;
    v68 = 0u;
    v69 = 0u;
    v66 = 0u;
    v67 = 0u;
    v64 = 0u;
    v65 = 0u;
    *(_OWORD *)buffer = 0u;
    v63 = 0u;
    bzero(&outputStruct, 0x978uLL);
    outputStructCnt = 64;
    SystemEncoding = CFStringGetSystemEncoding();
    if (!CFStringGetCString(v16, buffer, 128, SystemEncoding))
      goto LABEL_24;
    outputStruct = fsindex_parse(buffer, 0);
    if (outputStruct == -1)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf[0]) = 136315650;
        *(_QWORD *)((char *)buf + 4) = "process_volumes";
        WORD2(buf[1]) = 1024;
        *(_DWORD *)((char *)&buf[1] + 6) = 3334;
        WORD1(buf[2]) = 2080;
        *(_QWORD *)((char *)&buf[2] + 4) = buffer;
        _os_log_error_impl(&dword_1DF291000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s:%d: Cannot get index of volume '%s'\n", (uint8_t *)buf, 0x1Cu);
      }
LABEL_24:
      IOObjectRelease(v11);
      CFRelease(v16);
      goto LABEL_63;
    }
    iterator[0] = ++v12;
    v18 = IOConnectCallStructMethod(v9, 0x1Eu, &outputStruct, 4uLL, &outputStruct, &outputStructCnt);
    if (v18)
    {
      v19 = v18;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v20 = mach_error_string(v19);
        LODWORD(buf[0]) = 136315906;
        *(_QWORD *)((char *)buf + 4) = "process_volumes";
        WORD2(buf[1]) = 1024;
        *(_DWORD *)((char *)&buf[1] + 6) = 3344;
        WORD1(buf[2]) = 2080;
        *(_QWORD *)((char *)&buf[2] + 4) = buffer;
        WORD2(buf[3]) = 2080;
        *(_QWORD *)((char *)&buf[3] + 6) = v20;
        _os_log_error_impl(&dword_1DF291000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s:%d: Cannot fetch information about volume '%s' - %s\n", (uint8_t *)buf, 0x26u);
      }
      goto LABEL_61;
    }
    Mutable = CFDictionaryCreateMutable(v13, capacity, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (!Mutable)
      goto LABEL_61;
    v22 = Mutable;
    add_number(Mutable, CFSTR("Number of files"), kCFNumberSInt64Type, &v47);
    add_number(v22, CFSTR("Number of directories"), kCFNumberSInt64Type, &v48);
    add_number(v22, CFSTR("Number of snapshots"), kCFNumberSInt64Type, &v49);
    add_number(v22, CFSTR("Object mapping tree node count"), kCFNumberSInt64Type, &v50);
    add_number(v22, CFSTR("Root tree node count"), kCFNumberSInt64Type, &v52);
    add_number(v22, CFSTR("Extentref tree node count"), kCFNumberSInt64Type, &v51);
    add_number(v22, CFSTR("Number of extents"), kCFNumberSInt64Type, &v53);
    if (!a2)
      goto LABEL_60;
    v23 = mounted_device(buffer, 0);
    if (!v23)
      goto LABEL_60;
    v61 = 0u;
    v60 = 0u;
    v59 = 0u;
    v58 = 0u;
    v57 = 0u;
    memset(buf, 0, sizeof(buf));
    memset(v55, 0, sizeof(v55));
    v70[1] = 0;
    v70[0] = strndup(v23, 0x400uLL);
    v24 = fts_open(v70, 80, 0);
    v42 = v9;
    if (!v24)
    {
      free(v70[0]);
LABEL_50:
      __error();
      goto LABEL_51;
    }
    v25 = v24;
    while (1)
    {
      v26 = fts_read(v25);
      if (!v26)
        break;
      fts_info = v26->fts_info;
      if ((fts_info & 1) != 0)
      {
        v30 = fts_children(v25, 0);
        for (i = 0; v30; v30 = v30->fts_link)
          i += ((unint64_t)v30->fts_info >> 3) & 1;
        v29 = ilog10(i);
        v32 = v55;
LABEL_43:
        if (v29 >= 0xF)
          v33 = 15;
        else
          v33 = v29;
        ++v32[v33];
      }
      else if ((fts_info & 8) != 0)
      {
        st_blocks = v26->fts_statp->st_blocks;
        if (st_blocks)
        {
          if ((unint64_t)st_blocks >= 3)
          {
            if (st_blocks >= 1)
              --st_blocks;
            v29 = (63 - __clz(st_blocks >> 1)) >> 1;
          }
          else
          {
            v29 = 0;
          }
          v32 = buf;
          goto LABEL_43;
        }
      }
    }
    v34 = *__error();
    free(v70[0]);
    fts_close(v25);
    if (v34)
      goto LABEL_50;
LABEL_51:
    v35 = CFArrayCreateMutable(0, 16, 0);
    if (v35)
    {
      v36 = v35;
      for (j = 0; j != 16; ++j)
        CFArraySetValueAtIndex(v36, j, (const void *)buf[j]);
      CFDictionaryAddValue(v22, CFSTR("Histogram for number of files of sizes in a specific range, number of buckets is"), v36);
      CFRelease(v36);
    }
    v38 = CFArrayCreateMutable(0, 16, 0);
    if (v38)
    {
      v39 = v38;
      for (k = 0; k != 16; ++k)
        CFArraySetValueAtIndex(v39, k, *((const void **)v55 + k));
      CFDictionaryAddValue(v22, CFSTR("Histogram for number of files per directory, number of buckets is"), v39);
      CFRelease(v39);
    }
    v9 = v42;
LABEL_60:
    CFDictionaryAddValue(a3, v16, v22);
    CFRelease(v22);
LABEL_61:
    CFRelease(v16);
LABEL_62:
    IOObjectRelease(v11);
LABEL_63:
    v11 = IOIteratorNext(iterator[1]);
  }
  while (v11);
LABEL_64:
  IOObjectRelease(iterator[1]);
  add_number(a3, CFSTR("Number of volumes"), kCFNumberIntType, iterator);
LABEL_65:
  free_extent_hist = 0;
LABEL_66:
  IOServiceClose(parent[0]);
  return free_extent_hist;
}

uint64_t APFSStatistics(int a1, __CFDictionary *a2)
{
  mach_port_t v4;
  const __CFDictionary *v5;
  uint64_t MatchingServices;
  const __CFAllocator *v7;
  const CFDictionaryKeyCallBacks *v8;
  const CFDictionaryValueCallBacks *v9;
  uint64_t v10;
  uint64_t v11;
  __CFDictionary *Mutable;
  __CFDictionary *v13;
  void *key;
  io_iterator_t existing;

  if (!a2)
    return 49174;
  existing = 0;
  v4 = *MEMORY[0x1E0CBBAB8];
  v5 = IOServiceMatching("AppleAPFSContainer");
  MatchingServices = IOServiceGetMatchingServices(v4, v5, &existing);
  if (!(_DWORD)MatchingServices)
  {
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v8 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    v9 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    while (1)
    {
      v10 = IOIteratorNext(existing);
      if (!(_DWORD)v10)
      {
        IOObjectRelease(existing);
        return 0;
      }
      v11 = v10;
      key = 0;
      Mutable = CFDictionaryCreateMutable(v7, 0, v8, v9);
      if (!Mutable)
        break;
      v13 = Mutable;
      MatchingServices = APFSStatisticsProcessContainer(v11, a1, Mutable, (CFTypeRef *)&key);
      if (!(_DWORD)MatchingServices)
        CFDictionaryAddValue(a2, key, v13);
      if (key)
        CFRelease(key);
      IOObjectRelease(v11);
      CFRelease(v13);
      if ((_DWORD)MatchingServices)
        return MatchingServices;
    }
    IOObjectRelease(v11);
    IOObjectRelease(existing);
    return 49164;
  }
  return MatchingServices;
}

uint64_t APFSStreamCreatePrepare(char *a1, const unsigned __int8 *a2, const unsigned __int8 *a3, const __CFDictionary *a4, pthread_mutex_t **a5)
{
  uint64_t v5;
  pthread_mutex_t *v11;
  pthread_mutex_t *v12;
  int v13;
  int v14;
  void *v15;
  const __CFNumber *Value;
  void *sig;
  io_connect_t v18;
  int valuePtr;
  size_t outputStructCnt;
  uint64_t outputStruct;
  int v23;
  int v24;
  unsigned __int8 v25[16];
  unsigned __int8 v26[2392];

  v5 = 3758097090;
  outputStructCnt = 16;
  if (!a1 || !a5)
    return v5;
  v11 = (pthread_mutex_t *)malloc_type_calloc(1uLL, 0xD0uLL, 0x1080040B25F983CuLL);
  if (!v11)
    return 49164;
  v12 = v11;
  v13 = new_lock(v11);
  if (v13)
  {
    v14 = v13;
    free(v12);
    return v14 | 0xC000u;
  }
  bzero(&outputStruct, 0x978uLL);
  *(_DWORD *)v12[1].__opaque = 2097194;
  v15 = malloc_type_valloc(0x20002AuLL, 0xD195D7D9uLL);
  v12[1].__sig = (uint64_t)v15;
  if (v15)
  {
    crc32c_init();
    v12[1].__opaque[11] = 1;
    *(_QWORD *)&v12[1].__opaque[24] = 0x1FFFFFFFFLL;
    uuid_copy((unsigned __int8 *)&v12[1].__opaque[32], a2);
    uuid_copy((unsigned __int8 *)&v12[1].__opaque[48], a3);
    if (a4)
    {
      valuePtr = 0;
      Value = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("com.apple.apfs.stream.create.read.alignment"));
      if (Value && CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr))
      {
        if ((valuePtr - 16777217) >> 24 != 255)
        {
LABEL_16:
          sig = (void *)v12[1].__sig;
          if (sig)
            free(sig);
          goto LABEL_19;
        }
        *(_DWORD *)&v12[1].__opaque[28] = valuePtr;
      }
      v12[1].__opaque[11] = CFDictionaryGetValue(a4, CFSTR("com.apple.apfs.stream.create.embed.crc")) != (const void *)*MEMORY[0x1E0C9AE40];
    }
    v5 = apfs_container_iouc(a1, &v24, (io_connect_t *)&v12[1].__opaque[12], 0, 0);
    if (!(_DWORD)v5)
    {
      uuid_copy(v25, (const unsigned __int8 *)&v12[1].__opaque[32]);
      uuid_copy(v26, (const unsigned __int8 *)&v12[1].__opaque[48]);
      outputStruct = v12[1].__sig;
      v23 = *(_DWORD *)v12[1].__opaque;
      v5 = IOConnectCallStructMethod(*(_DWORD *)&v12[1].__opaque[12], 0x24u, &outputStruct, 0x30uLL, &outputStruct, &outputStructCnt);
      if (!(_DWORD)v5)
      {
        v12[1].__opaque[10] = 1;
        *a5 = v12;
        return v5;
      }
    }
    goto LABEL_16;
  }
  v5 = 49164;
LABEL_19:
  v18 = *(_DWORD *)&v12[1].__opaque[12];
  if (v18)
    IOServiceClose(v18);
  free_lock(v12);
  free(v12);
  return v5;
}

uint64_t APFSStreamCreateRead(uint64_t a1, char *a2, unint64_t a3, size_t *a4)
{
  uint64_t v4;
  unint64_t v9;
  unint64_t v10;
  size_t Flush;
  unsigned int v12;
  size_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  __int128 v22;
  uint64_t v23;
  int v24;
  _OWORD v25[3];
  unsigned int v26;
  unsigned __int8 v27;
  int8x16_t v28;
  size_t outputStructCnt;

  v4 = 3758097090;
  if (a1 && a2 && a4)
  {
    pthread_mutex_lock((pthread_mutex_t *)a1);
    if (*(_BYTE *)(a1 + 82))
    {
      v9 = *(unsigned int *)(a1 + 100);
      v10 = a3 / v9 * v9;
      if (v10 >= v9 && v10 >= 0x20000)
      {
        Flush = _APFSStreamCreateReadFlush(a1, a2, v10);
        *a4 = Flush;
        v12 = *(_DWORD *)(a1 + 76);
        if (v12 > *(_DWORD *)(a1 + 72) >> 1)
        {
          v4 = 0;
LABEL_11:
          pthread_mutex_unlock((pthread_mutex_t *)a1);
          return v4;
        }
        v14 = Flush;
        if (*(_BYTE *)(a1 + 80))
          goto LABEL_14;
        outputStructCnt = 72;
        bzero(v25, 0x978uLL);
        LODWORD(v25[0]) = v12;
        v19 = IOConnectCallStructMethod(*(_DWORD *)(a1 + 84), 0x25u, v25, 4uLL, v25, &outputStructCnt);
        if (!(_DWORD)v19)
        {
          v20 = *(_QWORD *)(a1 + 88);
          v21 = *(unsigned __int8 *)(a1 + 83);
          if (!v20)
            *(_QWORD *)(*(_QWORD *)(a1 + 64) + 13) |= *(_BYTE *)(a1 + 83) == 0;
          if (v21)
          {
            *(_DWORD *)(a1 + 96) = crc32c(*(unsigned int *)(a1 + 96), *(_QWORD *)(a1 + 64) + *(unsigned int *)(a1 + 76), v26);
            v20 = *(_QWORD *)(a1 + 88);
          }
          v22 = v25[1];
          *(_OWORD *)(a1 + 136) = v25[0];
          *(int8x16_t *)(a1 + 152) = vextq_s8(v28, v28, 8uLL);
          v23 = v26;
          v12 = *(_DWORD *)(a1 + 76) + v26;
          *(_DWORD *)(a1 + 76) = v12;
          *(_QWORD *)(a1 + 88) = v20 + v23;
          v24 = v27;
          *(_BYTE *)(a1 + 80) = v27 != 0;
          *(_OWORD *)(a1 + 168) = v22;
          *(_OWORD *)(a1 + 184) = v25[2];
          if (!v24)
          {
            if (!*(_BYTE *)(a1 + 81))
              goto LABEL_22;
            goto LABEL_19;
          }
LABEL_14:
          if (!*(_BYTE *)(a1 + 81))
          {
            if (*(_DWORD *)(a1 + 72) - v12 >= 0x8D)
            {
              v15 = *(_QWORD *)(a1 + 64) + v12;
              *(_OWORD *)(v15 + 125) = 0u;
              *(_OWORD *)(v15 + 96) = 0u;
              *(_OWORD *)(v15 + 112) = 0u;
              *(_OWORD *)(v15 + 64) = 0u;
              *(_OWORD *)(v15 + 80) = 0u;
              *(_OWORD *)(v15 + 32) = 0u;
              *(_OWORD *)(v15 + 48) = 0u;
              *(_OWORD *)v15 = 0u;
              *(_OWORD *)(v15 + 16) = 0u;
              *(_BYTE *)v15 = 6;
              *(_QWORD *)(v15 + 129) = *(_QWORD *)(a1 + 88) + 141;
              v16 = *(unsigned __int8 *)(a1 + 83);
              if (*(_BYTE *)(a1 + 83))
                v16 = ~crc32c(*(unsigned int *)(a1 + 96), v15, 137);
              *(_DWORD *)(v15 + 137) = v16;
              v12 = *(_DWORD *)(a1 + 76) + 141;
              *(_DWORD *)(a1 + 76) = v12;
              *(_BYTE *)(a1 + 81) = 1;
              goto LABEL_19;
            }
LABEL_22:
            v4 = 0;
            *a4 += _APFSStreamCreateReadFlush(a1, &a2[v14], v10 - v14);
            goto LABEL_11;
          }
LABEL_19:
          v17 = *(_DWORD *)(a1 + 100);
          if (v12 % v17)
          {
            v18 = v17 - v12 % v17;
            if (v18 + v12 <= *(unsigned int *)(a1 + 72))
            {
              bzero((void *)(*(_QWORD *)(a1 + 64) + v12), v18);
              *(_DWORD *)(a1 + 76) += v18;
            }
          }
          goto LABEL_22;
        }
        v4 = v19;
      }
    }
    else
    {
      v4 = 4294895648;
    }
    *(_BYTE *)(a1 + 82) = 0;
    goto LABEL_11;
  }
  return v4;
}

size_t _APFSStreamCreateReadFlush(uint64_t a1, void *__dst, unint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v6;
  size_t v7;

  v3 = *(unsigned int *)(a1 + 100);
  v4 = a3 / v3 * v3;
  if (v4 < v3)
    return 0;
  v6 = *(unsigned int *)(a1 + 76);
  if (v6 < v3)
    return 0;
  if (v4 >= v6)
    v4 = *(unsigned int *)(a1 + 76);
  v7 = v4 - v4 % v3;
  memcpy(__dst, *(const void **)(a1 + 64), v7);
  memmove(*(void **)(a1 + 64), (const void *)(*(_QWORD *)(a1 + 64) + v7), *(unsigned int *)(a1 + 76) - v7);
  *(_DWORD *)(a1 + 76) -= v7;
  return v7;
}

uint64_t APFSStreamCreateEstimateProgress(uint64_t a1, double *a2)
{
  uint64_t v2;
  uint64_t v3;
  double v4;
  unint64_t v5;
  unint64_t v6;
  double v7;
  double v8;
  double v9;

  v2 = 49174;
  if (!a1 || !a2)
    return v2;
  if (!*(_BYTE *)(a1 + 82))
    return 4294895648;
  v3 = *(_QWORD *)(a1 + 144);
  if (!v3)
  {
    v5 = *(_QWORD *)(a1 + 192);
    v6 = *(_QWORD *)(a1 + 176);
    if (v5)
    {
      v7 = 100.0;
      if (v6)
        v7 = 10.0;
      v4 = v7 * (double)*(unint64_t *)(a1 + 184) / (double)v5;
      if (!v6)
        goto LABEL_14;
    }
    else
    {
      v4 = 0.0;
      if (!v6)
        goto LABEL_14;
    }
    v8 = 90.0;
    if (!v5)
      v8 = 100.0;
    v4 = v4 + v8 * (double)*(unint64_t *)(a1 + 168) / (double)v6;
    goto LABEL_14;
  }
  v4 = (double)(unint64_t)(*(_QWORD *)(a1 + 160) + *(_QWORD *)(a1 + 136))
     * 100.0
     / (double)(unint64_t)(*(_QWORD *)(a1 + 152) + v3);
LABEL_14:
  v2 = 0;
  if (*(double *)(a1 + 200) > v4)
    v4 = *(double *)(a1 + 200);
  v9 = fmin(v4, 100.0);
  *(double *)(a1 + 200) = v9;
  *a2 = v9;
  return v2;
}

void APFSStreamCreateFinish(uint64_t a1)
{
  if (a1)
  {
    IOConnectCallStructMethod(*(_DWORD *)(a1 + 84), 0x31u, 0, 0, 0, 0);
    IOServiceClose(*(_DWORD *)(a1 + 84));
    free_lock((pthread_mutex_t *)a1);
    free(*(void **)(a1 + 64));
    *(_OWORD *)(a1 + 176) = 0u;
    *(_OWORD *)(a1 + 192) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)a1 = 0u;
    free((void *)a1);
  }
}

uint64_t APFSStreamRestorePrepare(char *a1, _BYTE *a2, unint64_t a3, _BOOL8 a4, pthread_mutex_t **a5)
{
  uint64_t v5;
  pthread_mutex_t *v11;
  pthread_mutex_t *v12;
  int v13;
  int v14;
  const __CFBoolean *Value;
  void *v16;
  io_connect_t sig_high;
  void *v18;
  size_t outputStructCnt;
  uint64_t v21;
  uint64_t outputStruct;
  int v23;
  int v24;
  int v25;
  _BOOL8 v26;

  v5 = 3758097090;
  outputStructCnt = 4;
  if (a1 && a2 && a5)
  {
    v11 = (pthread_mutex_t *)malloc_type_calloc(1uLL, 0x478uLL, 0x1010040C1F840FBuLL);
    if (v11)
    {
      v12 = v11;
      v13 = new_lock(v11);
      if (v13)
      {
        v14 = v13;
        free(v12);
        return v14 | 0xC000u;
      }
      else
      {
        if (a4)
        {
          Value = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a4, CFSTR("com.apple.apfs.stream.restore.skip.snapshot"));
          if (Value)
            a4 = CFBooleanGetValue(Value) != 0;
          else
            a4 = 0;
        }
        bzero(&outputStruct, 0x978uLL);
        v21 = 0;
        *(_DWORD *)&v12[1].__opaque[24] = 2097194;
        v16 = malloc_type_valloc(0x20002AuLL, 0xE2111514uLL);
        *(_QWORD *)&v12[1].__opaque[16] = v16;
        if (v16)
        {
          if (!delta_validate_op(a2, a3, (_DWORD *)&v21 + 1))
          {
            if (*a2 == 5)
            {
              v5 = apfs_container_iouc(a1, &v21, (io_connect_t *)&v12[1].__sig + 1, 0, 0);
              if (!(_DWORD)v5)
              {
                crc32c_init();
                *(_DWORD *)&v12[1].__opaque[8] = -1;
                BYTE2(v12[1].__sig) = (*(_QWORD *)(a2 + 13) & 1) == 0;
                memcpy(&v12[1].__opaque[44], a2, 0x400uLL);
                memcpy(*(void **)&v12[1].__opaque[16], a2, 0x400uLL);
                outputStruct = *(_QWORD *)&v12[1].__opaque[16];
                v23 = *(_DWORD *)&v12[1].__opaque[24];
                v24 = 1024;
                v25 = v21;
                v26 = a4;
                v5 = IOConnectCallStructMethod(HIDWORD(v12[1].__sig), 0x26u, &outputStruct, 0x20uLL, &outputStruct, &outputStructCnt);
                if (!(_DWORD)v5)
                {
                  *(_DWORD *)&v12[1].__opaque[36] = outputStruct;
                  BYTE1(v12[1].__sig) = 1;
                  *a5 = v12;
                  return v5;
                }
              }
            }
            else
            {
              v5 = 4294895649;
            }
          }
        }
        else
        {
          v5 = 49164;
        }
        sig_high = HIDWORD(v12[1].__sig);
        if (sig_high)
          IOServiceClose(sig_high);
        v18 = *(void **)&v12[1].__opaque[16];
        if (v18)
          free(v18);
        free_lock(v12);
        free(v12);
      }
    }
    else
    {
      return 49164;
    }
  }
  return v5;
}

uint64_t APFSStreamRestoreWrite(uint64_t a1, char *a2, unint64_t a3, _BYTE *a4)
{
  uint64_t v4;
  char *v5;
  char v9;
  unsigned int v10;
  size_t v11;
  int v12;
  uint64_t v13;
  unsigned __int8 *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  int v21;
  uint64_t v22;
  size_t outputStructCnt;
  _DWORD outputStruct[2];
  uint64_t v26;

  v4 = 3758097090;
  if (a1)
  {
    v5 = a2;
    if (a2)
    {
      if (a4)
      {
        v4 = 4294895651;
        pthread_mutex_lock((pthread_mutex_t *)a1);
        if (*(_BYTE *)(a1 + 65))
        {
          v9 = *(_BYTE *)(a1 + 64);
          if (a3 && !*(_BYTE *)(a1 + 64))
          {
            v10 = *(_DWORD *)(a1 + 100);
            while (2)
            {
              if (a3 >= *(_DWORD *)(a1 + 96) - v10)
                v11 = *(_DWORD *)(a1 + 96) - v10;
              else
                v11 = a3;
              memcpy((void *)(*(_QWORD *)(a1 + 88) + v10), v5, v11);
              *(_DWORD *)(a1 + 100) += v11;
              while (!*(_BYTE *)(a1 + 64))
              {
                outputStruct[0] = 0;
                v12 = delta_validate_op((unsigned __int8 *)(*(_QWORD *)(a1 + 88) + *(unsigned int *)(a1 + 104)), (*(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 104)), outputStruct);
                if (v12)
                {
                  if (v12 == 92)
                  {
LABEL_39:
                    v4 = 4294895649;
                    goto LABEL_40;
                  }
                  break;
                }
                v13 = *(unsigned int *)(a1 + 104);
                v14 = (unsigned __int8 *)(*(_QWORD *)(a1 + 88) + v13);
                v15 = *(_QWORD *)(a1 + 72);
                v16 = *v14;
                if ((v15 == 0) != (v16 == 5))
                  goto LABEL_39;
                if (v16 == 9)
                  *(_DWORD *)(a1 + 112) += *(_DWORD *)(v14 + 17) / *(_DWORD *)(a1 + 108);
                v17 = outputStruct[0];
                *(_DWORD *)(a1 + 104) = outputStruct[0] + v13;
                v18 = v15 + v17;
                *(_QWORD *)(a1 + 72) = v15 + v17;
                if (*(_BYTE *)(a1 + 66))
                {
                  if (*v14 == 6)
                    goto LABEL_22;
                  *(_DWORD *)(a1 + 80) = crc32c(*(unsigned int *)(a1 + 80), v14, v17);
                }
                if (*v14 == 6)
                {
                  v18 = *(_QWORD *)(a1 + 72);
LABEL_22:
                  if (v18 != *(_QWORD *)(v14 + 129))
                  {
                    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                      APFSStreamRestoreWrite_cold_2();
                    goto LABEL_40;
                  }
                  if (*(_BYTE *)(a1 + 66))
                    v19 = ~crc32c(*(unsigned int *)(a1 + 80), v14, 137);
                  else
                    v19 = 0;
                  if (v19 != *(_DWORD *)(v14 + 137))
                  {
                    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                      APFSStreamRestoreWrite_cold_1();
                    goto LABEL_40;
                  }
                  *(_BYTE *)(a1 + 64) = 1;
                  break;
                }
              }
              v10 = *(_DWORD *)(a1 + 100);
              if (v10 >= *(_DWORD *)(a1 + 96) || *(_BYTE *)(a1 + 64))
              {
                outputStructCnt = 4;
                v20 = *(_DWORD *)(a1 + 104);
                if (v20)
                {
                  bzero(&v26, 0x970uLL);
                  v21 = *(_DWORD *)(a1 + 112);
                  outputStruct[0] = v20;
                  outputStruct[1] = v21;
                  v22 = IOConnectCallStructMethod(*(_DWORD *)(a1 + 68), 0x27u, outputStruct, 8uLL, outputStruct, &outputStructCnt);
                  if ((_DWORD)v22)
                  {
                    v4 = v22;
                    goto LABEL_40;
                  }
                  memmove(*(void **)(a1 + 88), (const void *)(*(_QWORD *)(a1 + 88) + *(unsigned int *)(a1 + 104)), (*(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 104)));
                  v10 = *(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 104);
                  *(_QWORD *)(a1 + 100) = v10;
                  *(_DWORD *)(a1 + 112) = 0;
                }
              }
              v5 += v11;
              a3 -= v11;
              if (a3)
                continue;
              break;
            }
            v9 = *(_BYTE *)(a1 + 64);
          }
          v4 = 0;
          *a4 = v9;
        }
        else
        {
          v4 = 4294895648;
LABEL_40:
          *(_BYTE *)(a1 + 65) = 0;
        }
        pthread_mutex_unlock((pthread_mutex_t *)a1);
      }
    }
  }
  return v4;
}

uint64_t APFSStreamRestoreFinish(uint64_t a1, char a2)
{
  uint64_t v3;
  size_t v5;
  _BYTE outputStruct[2424];

  if (!a1)
    return 3758097090;
  v3 = 0;
  if (*(_BYTE *)(a1 + 65) && (a2 & 1) == 0)
  {
    bzero(outputStruct, 0x978uLL);
    v5 = 8;
    if (*(_BYTE *)(a1 + 64))
      v3 = IOConnectCallStructMethod(*(_DWORD *)(a1 + 68), 0x28u, outputStruct, 4uLL, outputStruct, &v5);
    else
      v3 = 4294895650;
  }
  free(*(void **)(a1 + 88));
  free_lock((pthread_mutex_t *)a1);
  IOServiceClose(*(_DWORD *)(a1 + 68));
  bzero((void *)a1, 0x478uLL);
  free((void *)a1);
  return v3;
}

uint64_t APFSStreamFingerprintPrepare(uint64_t a1, pthread_mutex_t **a2)
{
  pthread_mutex_t *v3;
  pthread_mutex_t *v4;
  int v5;
  int v6;
  uint64_t result;

  v3 = (pthread_mutex_t *)malloc_type_calloc(1uLL, 0x200600uLL, 0x1000040840781ABuLL);
  if (!v3)
    return 49164;
  v4 = v3;
  v5 = new_lock(v3);
  if (v5)
  {
    v6 = v5;
    free(v4);
    return v6 | 0xC000u;
  }
  else
  {
    CC_SHA512_Init((CC_SHA512_CTX *)&v4[32788].__opaque[40]);
    crc32c_init();
    result = 0;
    *(_DWORD *)&v4[1].__opaque[16] = -1;
    *(_WORD *)((char *)&v4[1].__sig + 1) = 257;
    *a2 = v4;
  }
  return result;
}

uint64_t APFSStreamFingerprintWrite(uint64_t a1, char *a2, unint64_t a3, char *a4)
{
  uint64_t v4;
  char *v5;
  char v9;
  uint64_t v10;
  size_t v11;
  unint64_t v12;
  unsigned __int8 *v13;
  int v14;
  unint64_t v15;
  unint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unint64_t v20;

  v4 = 3758097090;
  if (a1)
  {
    v5 = a2;
    if (a2)
    {
      if (a4)
      {
        v4 = 4294895651;
        pthread_mutex_lock((pthread_mutex_t *)a1);
        if (*(_BYTE *)(a1 + 65))
        {
          v9 = *(_BYTE *)(a1 + 64);
          if (!a3 || *(_BYTE *)(a1 + 64))
          {
LABEL_21:
            v4 = 0;
            *a4 = v9;
LABEL_24:
            pthread_mutex_unlock((pthread_mutex_t *)a1);
            return v4;
          }
          v10 = *(_QWORD *)(a1 + 96);
          while (1)
          {
            v20 = 0;
            if (v10)
            {
              if (1048597 - v10 >= a3)
                v11 = a3;
              else
                v11 = 1048597 - v10;
              memcpy((void *)(a1 + 104 + v10), v5, v11);
              v12 = a3 - v11;
              a3 = *(_QWORD *)(a1 + 96) + v11;
              *(_QWORD *)(a1 + 96) = a3;
              v5 += v11;
              v13 = (unsigned __int8 *)(a1 + 104);
            }
            else
            {
              v12 = 0;
              v13 = (unsigned __int8 *)v5;
            }
            v20 = a3;
            v14 = delta_canonicalize((unsigned int *)(a1 + 1048704), v13, &v20, (void (*)(unsigned __int8 *, size_t, uint64_t))_APFSStreamFingerprintCallback, a1);
            if (*(_DWORD *)(a1 + 92))
            {
              v4 = *(unsigned int *)(a1 + 92);
              goto LABEL_23;
            }
            if (v14 == 89)
              break;
            if (v14 == 92)
            {
              v4 = 4294895649;
              if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
                APFSStreamFingerprintWrite_cold_1();
              goto LABEL_23;
            }
            v15 = v20;
            *(_QWORD *)(a1 + 72) += v20;
            if (*(_BYTE *)(a1 + 66))
            {
              *(_DWORD *)(a1 + 88) = crc32c(*(unsigned int *)(a1 + 88), v13, v15);
              v15 = v20;
            }
            memmove((void *)(a1 + 104), &v13[v15], a3 - v15);
            v10 = a3 - v20;
            *(_QWORD *)(a1 + 96) = a3 - v20;
            a3 = v12;
            if (!v12)
            {
              v9 = *(_BYTE *)(a1 + 64);
              goto LABEL_21;
            }
          }
          v17 = v20;
          v18 = *(_QWORD *)(a1 + 72) + v20;
          *(_QWORD *)(a1 + 72) = v18;
          if (*(_QWORD *)(a1 + 2098465) == v18)
          {
            if (*(_BYTE *)(a1 + 66))
              v19 = ~crc32c(*(unsigned int *)(a1 + 88), v13, v17 - 4);
            else
              v19 = 0;
            *(_DWORD *)(a1 + 88) = v19;
            if (*(_DWORD *)(a1 + 2098473) == v19)
            {
              v9 = 1;
              *(_BYTE *)(a1 + 64) = 1;
              goto LABEL_21;
            }
            if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
              APFSStreamFingerprintWrite_cold_2();
          }
          else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          {
            APFSStreamFingerprintWrite_cold_3();
          }
        }
        else
        {
          v4 = 4294895648;
        }
LABEL_23:
        *(_BYTE *)(a1 + 65) = 0;
        goto LABEL_24;
      }
    }
  }
  return v4;
}

uint64_t _APFSStreamFingerprintCallback(uint64_t __src, CC_LONG len, uint64_t a3)
{
  uint64_t v4;
  int v5;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;

  v4 = *(_QWORD *)(a3 + 80);
  v5 = *(unsigned __int8 *)__src;
  if ((v4 == 0) == (v5 == 5))
  {
    if (!*(_DWORD *)(a3 + 92))
    {
      v7 = __src;
      if ((v5 - 7) >= 6)
      {
        if (v5 == 5)
        {
          __src = (uint64_t)memcpy((void *)(a3 + 2097312), (const void *)__src, 0x400uLL);
          *(_BYTE *)(a3 + 66) = (*(_QWORD *)(v7 + 13) & 1) == 0;
          if ((*(_BYTE *)(v7 + 13) & 2) == 0)
            *(_DWORD *)(a3 + 92) = -71644;
        }
        else if (v5 == 6)
        {
          *(_OWORD *)(a3 + 2098336) = *(_OWORD *)__src;
          v8 = *(_OWORD *)(__src + 16);
          v9 = *(_OWORD *)(__src + 32);
          v10 = *(_OWORD *)(__src + 64);
          *(_OWORD *)(a3 + 2098384) = *(_OWORD *)(__src + 48);
          *(_OWORD *)(a3 + 2098400) = v10;
          *(_OWORD *)(a3 + 2098352) = v8;
          *(_OWORD *)(a3 + 2098368) = v9;
          v11 = *(_OWORD *)(__src + 80);
          v12 = *(_OWORD *)(__src + 96);
          v13 = *(_OWORD *)(__src + 112);
          *(_OWORD *)(a3 + 2098461) = *(_OWORD *)(__src + 125);
          *(_OWORD *)(a3 + 2098432) = v12;
          *(_OWORD *)(a3 + 2098448) = v13;
          *(_OWORD *)(a3 + 2098416) = v11;
        }
      }
      else
      {
        __src = CC_SHA512_Update((CC_SHA512_CTX *)(a3 + 2098480), (const void *)__src, len);
        v4 = *(_QWORD *)(a3 + 80);
      }
      *(_QWORD *)(a3 + 80) = v4 + len;
    }
  }
  else
  {
    *(_DWORD *)(a3 + 92) = -71647;
  }
  return __src;
}

uint64_t APFSStreamFingerprintFinish(pthread_mutex_t *a1, char **a2)
{
  uint64_t v4;
  __int128 v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned int v10;
  char *v11;
  unsigned __int8 md[16];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uuid_t dst;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v24 = 0;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  *(_OWORD *)dst = 0u;
  v14 = 0u;
  v15 = 0u;
  *(_OWORD *)md = 0u;
  if (a1 && a2)
  {
    v4 = 4294895648;
    if (BYTE1(a1[1].__sig))
    {
      if (LOBYTE(a1[1].__sig))
      {
        v24 = 0;
        v22 = 0uLL;
        v23 = 0uLL;
        v20 = 0uLL;
        v21 = 0uLL;
        v18 = 0uLL;
        v19 = 0uLL;
        *(_OWORD *)dst = 0uLL;
        uuid_copy(dst, (const unsigned __int8 *)&a1[32771].__opaque[1]);
        v5 = *(_OWORD *)&a1[32780].__opaque[12];
        v18 = *(_OWORD *)((char *)&a1[32780].__sig + 4);
        v19 = v5;
        *(_QWORD *)&v20 = *(_QWORD *)&a1[32779].__opaque[44] & 9;
        CC_SHA512_Update((CC_SHA512_CTX *)&a1[32788].__opaque[40], dst, 0x78u);
        CC_SHA512_Final(md, (CC_SHA512_CTX *)&a1[32788].__opaque[40]);
        v6 = (char *)malloc_type_malloc(0x81uLL, 0xF5C33870uLL);
        if (v6)
        {
          v7 = v6;
          v8 = 0;
          v9 = md;
          do
          {
            v10 = *v9++;
            v11 = &v6[v8];
            *v11 = a0123456789abcd[(unint64_t)v10 >> 4];
            v11[1] = a0123456789abcd[v10 & 0xF];
            v8 += 2;
          }
          while (v8 != 128);
          v6[128] = 0;
          asprintf(a2, "%s:%s", "v0,sha512", v6);
          if (*a2)
            v4 = 0;
          else
            v4 = 49164;
          free(v7);
        }
        else
        {
          v4 = 49164;
        }
      }
      else
      {
        v4 = 4294895650;
      }
    }
  }
  else
  {
    v4 = 3758097090;
    if (!a1)
      return v4;
  }
  free_lock(a1);
  bzero(a1, 0x200600uLL);
  free(a1);
  return v4;
}

uint64_t APFSContainerVolumeGroupAdd()
{
  return 49197;
}

uint64_t APFSContainerVolumeGroupRemove()
{
  return 49197;
}

uint64_t APFSGetVolumeGroupID()
{
  return 49197;
}

uint64_t APFSContainerVolumeGroupGet()
{
  return 49197;
}

uint64_t APFSContainerVolumeGroupGetVolumes()
{
  return 49197;
}

uint64_t APFSContainerVolumeGroupGetSystemAndDataVolumes()
{
  return 49197;
}

uint64_t APFSContainerVolumeGroupGetFirmlinks()
{
  return 49197;
}

uint64_t APFSContainerVolumeGroupSyncUnlockRecords()
{
  return 45;
}

uint64_t APFSGetFragmentationHistogram(char *a1, __CFArray **a2)
{
  uint64_t result;
  char v5;
  uint64_t v6;
  const __CFAllocator *v7;
  CFMutableArrayRef Mutable;
  __CFArray *v9;
  CFIndex v10;
  int *i;
  CFNumberRef v12;
  CFNumberRef v13;
  size_t outputStructCnt;
  int outputStruct;
  char v16;
  io_connect_t v17;

  outputStructCnt = 408;
  result = 49174;
  if (a1 && a2)
  {
    v17 = 0;
    bzero(&outputStruct, 0x978uLL);
    if (apfs_container_iouc(a1, 0, &v17, 0, 0))
    {
      result = apfs_container_iouc(a1, &outputStruct, &v17, 0, 0);
      if ((_DWORD)result)
        return result;
      v5 = 0;
    }
    else
    {
      v5 = 1;
    }
    v16 = v5;
    v6 = IOConnectCallStructMethod(v17, 0x2Eu, &outputStruct, 8uLL, &outputStruct, &outputStructCnt);
    IOServiceClose(v17);
    if ((_DWORD)v6)
    {
      if (rc_to_errno(v6) == 4)
        return 49187;
      else
        return v6;
    }
    else
    {
      v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 51, MEMORY[0x1E0C9B378]);
      if (Mutable)
      {
        v9 = Mutable;
        v10 = 0;
        for (i = &outputStruct; ; i += 2)
        {
          v12 = CFNumberCreate(v7, kCFNumberIntType, i);
          if (!v12)
            break;
          v13 = v12;
          CFArraySetValueAtIndex(v9, v10, v12);
          CFRelease(v13);
          if (++v10 == 51)
          {
            result = 0;
            *a2 = v9;
            return result;
          }
        }
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          APFSGetFragmentationHistogram_cold_2();
        CFRelease(v9);
      }
      else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        APFSGetFragmentationHistogram_cold_1();
      }
      return 49164;
    }
  }
  return result;
}

uint64_t APFSContainerWriteBurstStats(char *a1, __CFDictionary **a2)
{
  uint64_t v2;
  io_registry_entry_t container_io_object;
  io_object_t v5;
  const __CFAllocator *v6;
  const __CFDictionary *CFProperty;
  const __CFDictionary *v8;
  uint64_t number;
  __CFDictionary *v10;
  __CFDictionary *Mutable;
  unint64_t v13;
  unint64_t v14;
  double v15;
  double v16;
  uint64_t v17;
  unint64_t valuePtr;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;

  valuePtr = 0;
  v19 = 0;
  v16 = 0.0;
  v17 = 45000000;
  v2 = 49174;
  v15 = 0.0;
  if (!a1 || !a2)
    return v2;
  *a2 = 0;
  container_io_object = get_container_io_object(a1);
  if (!container_io_object)
    return 49154;
  v5 = container_io_object;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  CFProperty = (const __CFDictionary *)IORegistryEntryCreateCFProperty(container_io_object, CFSTR("Statistics"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (!CFProperty)
  {
    IOObjectRelease(v5);
    return 49154;
  }
  v8 = CFProperty;
  v24 = 0;
  v22 = 0;
  v23 = 0;
  v20 = 0;
  v21 = 0;
  number = get_number(CFProperty, CFSTR("Write burst: Burst count"), &v24);
  if ((_DWORD)number
    || (number = get_number(v8, CFSTR("Write burst: Total time"), &v23), (_DWORD)number)
    || (number = get_number(v8, CFSTR("Write burst: Total number of bytes written"), &v22), (_DWORD)number)
    || (number = get_number(v8, CFSTR("Write burst: Total number of I/Os"), &v21), (_DWORD)number)
    || (number = get_number(v8, CFSTR("Write burst: Total time between bursts"), &v20), (_DWORD)number))
  {
    v2 = number;
LABEL_11:
    v10 = 0;
    goto LABEL_12;
  }
  Mutable = CFDictionaryCreateMutable(v6, 5, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v10 = Mutable;
  if (Mutable)
  {
    v17 = 45;
    v13 = v23 / 0xF4240;
    v23 /= 0xF4240uLL;
    v14 = v20 / 0xF4240;
    v20 /= 0xF4240uLL;
    if (v24)
    {
      v16 = (double)v13 / (double)v24;
      valuePtr = v21 / v24;
      v19 = v22 / v24;
      if (v24 != 1)
        v15 = (double)v14 / (double)(v24 - 1);
    }
    if (add_number(Mutable, CFSTR("wb_average_io_count"), kCFNumberSInt64Type, &valuePtr)
      && add_number(v10, CFSTR("wb_average_time"), kCFNumberDoubleType, &v16)
      && add_number(v10, CFSTR("wb_average_capacity"), kCFNumberSInt64Type, &v19)
      && add_number(v10, CFSTR("wb_average_time_between"), kCFNumberDoubleType, &v15)
      && add_number(v10, CFSTR("wb_period_threshold"), kCFNumberSInt64Type, &v17))
    {
      v2 = 0;
      *a2 = v10;
      goto LABEL_11;
    }
  }
  v2 = 49164;
LABEL_12:
  IOObjectRelease(v5);
  CFRelease(v8);
  if (v10)
    CFRelease(v10);
  return v2;
}

uint64_t get_number(const __CFDictionary *a1, const void *a2, void *a3)
{
  const __CFNumber *Value;

  Value = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  if (!Value)
    return 49154;
  if (CFNumberGetValue(Value, kCFNumberSInt64Type, a3))
    return 0;
  return 49174;
}

BOOL add_number(__CFDictionary *a1, const void *a2, CFNumberType theType, void *valuePtr)
{
  CFNumberRef v6;

  v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theType, valuePtr);
  if (v6)
  {
    CFDictionaryAddValue(a1, a2, v6);
    CFRelease(v6);
  }
  return v6 != 0;
}

uint64_t APFSContainerStitchVolumeGroup()
{
  return 45;
}

uint64_t APFSVolumeCreateForMSU()
{
  return 45;
}

uint64_t APFSVolumeTranscribePFK(char *a1)
{
  uint64_t v1;

  v1 = _APFSVolumeOperation(a1, 0x42u);
  return rc_to_errno(v1);
}

uint64_t APFSVolumeMigrateMediaKey(char *a1)
{
  uint64_t v1;

  v1 = _APFSVolumeOperation(a1, 0x43u);
  return rc_to_errno(v1);
}

uint64_t volumeNeedsCryptoMigrationHelper(char *a1, char a2, _BYTE *a3)
{
  uint64_t result;
  int v7;
  __int16 v8;
  kern_return_t v9;
  size_t outputStructCnt;
  int outputStruct;
  char v12;
  io_connect_t v13;

  outputStructCnt = 1;
  result = 22;
  if (a1 && a3)
  {
    v13 = 0;
    bzero(&outputStruct, 0x978uLL);
    v7 = apfs_container_iouc(a1, &outputStruct, &v13, 0, 0);
    v8 = v7;
    if (!v7)
    {
      v12 = a2;
      v9 = IOConnectCallStructMethod(v13, 0x44u, &outputStruct, 8uLL, &outputStruct, &outputStructCnt);
      v8 = v9;
      if (!v9)
        *a3 = outputStruct;
      IOServiceClose(v13);
    }
    return v8 & 0x3FFF;
  }
  return result;
}

uint64_t APFSVolumeNeedsCryptoMigration(char *a1, _BYTE *a2)
{
  return volumeNeedsCryptoMigrationHelper(a1, 0, a2);
}

uint64_t APFSPersonaVolumeNeedsCryptoMigration(char *a1, _BYTE *a2)
{
  return volumeNeedsCryptoMigrationHelper(a1, 1, a2);
}

uint64_t APFSVolumeGetPurgeableSpace(char *a1, char a2, unint64_t a3, unint64_t a4)
{
  uint64_t v8;
  size_t outputStructCnt;
  uint64_t outputStruct;
  uint64_t v12;
  io_connect_t v13;

  outputStructCnt = 16;
  if (!a1 || !(a3 | a4))
    return 22;
  v13 = 0;
  bzero(&outputStruct, 0x978uLL);
  v8 = apfs_container_iouc(a1, &outputStruct, &v13, 0, 0);
  if (!(_DWORD)v8)
  {
    v12 = a2 & 7;
    v8 = IOConnectCallStructMethod(v13, 0x47u, &outputStruct, 0x10uLL, &outputStruct, &outputStructCnt);
    if (!(_DWORD)v8)
    {
      if (a3)
        *(_QWORD *)a3 = outputStruct;
      if (a4)
        *(_QWORD *)a4 = v12;
    }
    IOServiceClose(v13);
  }
  return rc_to_errno(v8);
}

uint64_t APFSVolumePerformOfflinePurge(char *a1, __int128 *a2, uint64_t a3)
{
  uint64_t result;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  size_t outputStructCnt;
  _BYTE outputStruct[24];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  io_connect_t v22;

  outputStructCnt = 24;
  result = 22;
  if (a1 && a2 && a3)
  {
    v22 = 0;
    bzero(outputStruct, 0x978uLL);
    v7 = a2[4];
    v18 = a2[5];
    v8 = a2[7];
    v19 = a2[6];
    v20 = v8;
    v21 = a2[8];
    v9 = *a2;
    v14 = a2[1];
    v10 = a2[3];
    v15 = a2[2];
    v16 = v10;
    v17 = v7;
    *(_OWORD *)&outputStruct[8] = v9;
    v11 = apfs_container_iouc(a1, outputStruct, &v22, 0, 0);
    if (!(_DWORD)v11)
    {
      v11 = IOConnectCallStructMethod(v22, 0x49u, outputStruct, 0x98uLL, outputStruct, &outputStructCnt);
      if (!(_DWORD)v11)
      {
        *(_OWORD *)a3 = *(_OWORD *)outputStruct;
        *(_QWORD *)(a3 + 16) = *(_QWORD *)&outputStruct[16];
      }
      IOServiceClose(v22);
    }
    return rc_to_errno(v11);
  }
  return result;
}

uint64_t APFSVolumeCancelOfflinePurge(char *a1)
{
  uint64_t v2;
  size_t outputStructCnt;
  _DWORD inputStruct[607];
  io_connect_t v6;

  outputStructCnt = 0;
  if (!a1)
    return 22;
  v6 = 0;
  bzero(inputStruct, 0x978uLL);
  v2 = apfs_container_iouc(a1, inputStruct, &v6, 0, 0);
  if (!(_DWORD)v2)
  {
    v2 = IOConnectCallStructMethod(v6, 0x4Au, inputStruct, 0x10uLL, 0, &outputStructCnt);
    IOServiceClose(v6);
  }
  return rc_to_errno(v2);
}

uint64_t APFSCaptureCreatePreallocFile(const char *a1, uint64_t a2)
{
  char *v4;
  int v5;
  int v6;
  uint64_t v7;
  char *v8;
  stat v10;
  __int128 v11;
  __int128 v12;

  v11 = 0u;
  v12 = 0u;
  memset(&v10, 0, sizeof(v10));
  *__error() = 0;
  if (lstat(a1, &v10) < 0 && *__error() != 2)
    return *__error() | 0xC000u;
  if (*__error())
  {
LABEL_4:
    v4 = 0;
    goto LABEL_5;
  }
  if ((v10.st_mode & 0xF000) != 0xA000)
  {
    if ((unlink(a1) & 0x80000000) == 0)
      goto LABEL_4;
    return *__error() | 0xC000u;
  }
  v8 = realpath_DARWIN_EXTSN(a1, 0);
  if (!v8)
  {
    if (*__error() == 2)
      goto LABEL_4;
    return *__error() | 0xC000u;
  }
  v4 = v8;
  if (unlink(v8) < 0)
  {
    v7 = *__error() | 0xC000u;
    goto LABEL_16;
  }
LABEL_5:
  v5 = open(a1, 514, 384);
  if (v5 < 0)
  {
    v7 = *__error() | 0xC000u;
    if (!v4)
      return v7;
    goto LABEL_16;
  }
  v6 = v5;
  v11 = 0x30000000CuLL;
  *(_QWORD *)&v12 = a2;
  if (fcntl(v5, 42, &v11) < 0)
    v7 = *__error() | 0xC000u;
  else
    v7 = 0;
  close(v6);
  if (v4)
LABEL_16:
    free(v4);
  return v7;
}

uint64_t APFSCaptureStartCaptureInFile()
{
  return 0;
}

uint64_t APFSCaptureFinishCaptureForFile(const char *a1, const std::__fs::filesystem::path *a2)
{
  const std::__fs::filesystem::path *v3;
  std::error_code *v4;
  mode_t st_mode;
  char *v6;
  std::__fs::filesystem::path *v7;
  uint64_t v8;
  std::__fs::filesystem::path *v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  char v14;
  int v15;
  char *v16;
  int *v17;
  char v18;
  stat v20;

  v3 = (const std::__fs::filesystem::path *)a1;
  memset(&v20, 0, sizeof(v20));
  if (lstat(a1, &v20) < 0)
    return *__error() | 0xC000u;
  st_mode = v20.st_mode;
  if ((v20.st_mode & 0xF000) != 0xA000)
  {
    v7 = 0;
    goto LABEL_8;
  }
  v6 = realpath_DARWIN_EXTSN((const char *)v3, 0);
  if (!v6)
    return *__error() | 0xC000u;
  v7 = (std::__fs::filesystem::path *)v6;
  if (stat(v6, &v20) < 0)
  {
    v9 = 0;
    v14 = 0;
    v8 = *__error() | 0xC000u;
    v13 = -1;
    v11 = -1;
LABEL_41:
    free(v7);
    goto LABEL_42;
  }
  st_mode = v20.st_mode;
  v3 = v7;
LABEL_8:
  if ((st_mode & 0xF000) != 0x8000)
  {
    v14 = 0;
    v9 = 0;
    goto LABEL_19;
  }
  *__error() = 0;
  if (lstat((const char *)a2, &v20) < 0 && *__error() != 2)
    goto LABEL_37;
  if (*__error())
  {
LABEL_12:
    v9 = 0;
    goto LABEL_13;
  }
  v9 = 0;
  v15 = v20.st_mode & 0xF000;
  if (v15 != 0x8000)
  {
    if (v15 == 40960)
    {
      v16 = realpath_DARWIN_EXTSN((const char *)a2, 0);
      if (v16)
      {
        v9 = (std::__fs::filesystem::path *)v16;
        if ((stat(v16, &v20) & 0x80000000) == 0)
        {
          a2 = v9;
          goto LABEL_13;
        }
        v17 = __error();
        v14 = 0;
LABEL_38:
        v8 = *v17 | 0xC000u;
LABEL_39:
        v11 = -1;
        goto LABEL_40;
      }
      if (*__error() == 2)
        goto LABEL_12;
LABEL_37:
      v17 = __error();
      v14 = 0;
      v9 = 0;
      goto LABEL_38;
    }
    v14 = 0;
LABEL_19:
    v11 = -1;
    v8 = 49231;
    goto LABEL_40;
  }
LABEL_13:
  rename(v3, a2, v4);
  if (v10 < 0)
  {
    v8 = *__error() | 0xC000u;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      APFSCaptureFinishCaptureForFile_cold_1();
    v14 = 0;
    goto LABEL_39;
  }
  v11 = open((const char *)a2, 2);
  if ((v11 & 0x80000000) == 0)
  {
    v12 = open((const char *)v3, 1538, 384);
    v13 = v12;
    if ((v12 & 0x80000000) != 0)
    {
      v8 = *__error() | 0xC000u;
    }
    else if (fcntl(v11, 110, v12) < 0)
    {
      v8 = *__error() | 0xC000u;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        APFSCaptureFinishCaptureForFile_cold_2();
    }
    else
    {
      v8 = 0;
    }
    v14 = 1;
    if (!v7)
      goto LABEL_42;
    goto LABEL_41;
  }
  v8 = *__error() | 0xC000u;
  v14 = 1;
LABEL_40:
  v13 = -1;
  if (v7)
    goto LABEL_41;
LABEL_42:
  if (v9)
    free(v9);
  if ((v11 & 0x80000000) == 0)
    close(v11);
  if ((v13 & 0x80000000) == 0)
    close(v13);
  v18 = v14 ^ 1;
  if (!(_DWORD)v8)
    v18 = 1;
  if ((v18 & 1) == 0)
    rename(a2, v3, v4);
  return v8;
}

uint64_t APFSCaptureExtendPreallocSizeForFile(const char *a1, uint64_t a2)
{
  int v3;
  int v4;
  uint64_t v5;
  _QWORD v7[4];

  v7[3] = 0;
  v3 = open(a1, 2);
  if (v3 < 0)
    return *__error() | 0xC000u;
  v4 = v3;
  v7[0] = 0x300000004;
  v7[1] = 0;
  v7[2] = a2;
  if (fcntl(v3, 42, v7) < 0)
    v5 = *__error() | 0xC000u;
  else
    v5 = 0;
  close(v4);
  return v5;
}

uint64_t APFSCaptureDeletePreallocFile(const char *a1)
{
  if (unlink(a1) < 0)
    return *__error() | 0xC000u;
  else
    return 0;
}

uint64_t APFSContainerCommitTemporaryCheckpoint(int *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  _OWORD v7[2];
  uint64_t *v8;

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  parse_nx_mount_options(0, (int *)v7);
  WORD4(v7[0]) = WORD4(v7[0]) & 0xEFFE | 1;
  if (enhanced_apfs_enabled())
    WORD4(v7[0]) |= 0x2000u;
  v2 = nx_mount(a1, (uint64_t)v7, &v8);
  if ((_DWORD)v2)
  {
    v3 = v2;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      APFSContainerCommitTemporaryCheckpoint_cold_3();
  }
  else
  {
    v6 = 0;
    v4 = tx_enter((uint64_t)v8, &v6);
    if ((_DWORD)v4)
    {
      v3 = v4;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        APFSContainerCommitTemporaryCheckpoint_cold_2();
    }
    else
    {
      v3 = tx_leave((uint64_t)v8, v6, 5);
      if ((_DWORD)v3 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        APFSContainerCommitTemporaryCheckpoint_cold_1();
    }
    nx_unmount((uint64_t)v8);
  }
  return v3;
}

uint64_t APFSVolumeConvertToUserCrypto(char *a1, const char *a2)
{
  time_t v4;
  int v5;
  uint64_t v6;
  FILE *v7;
  _QWORD v9[3];
  int v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  int v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  int v20;
  int v21;
  _OWORD v22[9];
  size_t outputStructCnt;
  _OWORD outputStruct[151];
  io_connect_t v25;

  outputStructCnt = 144;
  if (!a1)
    return 22;
  v25 = 0;
  bzero(outputStruct, 0x978uLL);
  memset(v22, 0, sizeof(v22));
  v4 = time(0);
  v5 = apfs_container_iouc(a1, outputStruct, &v25, 0, 0);
  if (v5)
  {
    v6 = v5 & 0x3FFF;
    record_failure(v22, 1126051, v6);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      APFSVolumeConvertToUserCrypto_cold_3((uint64_t)a1, v6);
      if (!a2)
        return v6;
      goto LABEL_10;
    }
LABEL_9:
    if (!a2)
      return v6;
    goto LABEL_10;
  }
  v6 = IOConnectCallStructMethod(v25, 0x45u, outputStruct, 4uLL, outputStruct, &outputStructCnt);
  v22[6] = outputStruct[6];
  v22[7] = outputStruct[7];
  v22[8] = outputStruct[8];
  v22[2] = outputStruct[2];
  v22[3] = outputStruct[3];
  v22[4] = outputStruct[4];
  v22[5] = outputStruct[5];
  v22[0] = outputStruct[0];
  v22[1] = outputStruct[1];
  IOServiceClose(v25);
  if (!(_DWORD)v6)
    goto LABEL_9;
  v6 &= 0x3FFFu;
  record_failure(v22, 1126052, v6);
  if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    goto LABEL_9;
  APFSVolumeConvertToUserCrypto_cold_2((uint64_t)a1, v6);
  if (!a2)
    return v6;
LABEL_10:
  bzero(v9, 0x2E8uLL);
  v9[2] = *(_QWORD *)&v22[0];
  v10 = DWORD2(v22[0]);
  v13 = *(_QWORD *)((char *)&v22[2] + 12);
  v11 = *(_OWORD *)((char *)v22 + 12);
  v12 = *(_OWORD *)((char *)&v22[1] + 12);
  v14 = DWORD1(v22[3]);
  v16 = *(_OWORD *)((char *)&v22[4] + 8);
  v17 = *(_OWORD *)((char *)&v22[5] + 8);
  v18 = *(_OWORD *)((char *)&v22[6] + 8);
  v19 = *(_OWORD *)((char *)&v22[7] + 8);
  v15 = *(_OWORD *)((char *)&v22[3] + 8);
  v21 = HIDWORD(v22[8]);
  v20 = DWORD2(v22[8]);
  set_metric_path((uint64_t)v9, a1);
  set_metric_start_time((uint64_t)v9, v4);
  if (!strcmp(a2, "-"))
  {
    v7 = (FILE *)*MEMORY[0x1E0C80C20];
    if (*MEMORY[0x1E0C80C20])
      goto LABEL_12;
  }
  else
  {
    v7 = fopen(a2, "w");
    if (v7)
    {
LABEL_12:
      set_metrics_file(v9, (uint64_t)v7);
      print_metrics_to_file((uint64_t)v9, 2);
      return v6;
    }
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    APFSVolumeConvertToUserCrypto_cold_1();
  return v6;
}

uint64_t APFSDecodeMetricsString(char *a1)
{
  uint64_t v2;
  _BYTE v4[8];
  uint64_t v5;

  bzero(v4, 0x2E8uLL);
  set_metric_default_values((uint64_t)v4);
  if (MetricsCompactor_Import(a1, (uint64_t)v4))
  {
    print_metrics((uint64_t)v4, 1);
    v2 = v5;
    v5 = 0;
  }
  else
  {
    v2 = 0;
  }
  cleanup_metrics((uint64_t)v4);
  return v2;
}

uint64_t APFSOverProvModel()
{
  return 2;
}

CFTypeID records_callback(const __CFString *a1, const void *a2, uint64_t a3)
{
  uint64_t v6;
  CFTypeID v7;
  CFTypeID result;
  CFTypeID v9;
  const char *CStringPtr;

  v6 = *(unsigned int *)(a3 + 40);
  v7 = CFGetTypeID(a1);
  result = CFStringGetTypeID();
  if (v7 == result)
  {
    v9 = CFGetTypeID(a2);
    result = CFDataGetTypeID();
    if (v9 == result)
    {
      CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
      uuid_parse(CStringPtr, (unsigned __int8 *)(*(_QWORD *)(a3 + 48) + 16 * v6));
      **(_QWORD **)(*(_QWORD *)(a3 + 56) + 8 * v6) = CFDataGetBytePtr((CFDataRef)a2);
      result = CFDataGetLength((CFDataRef)a2);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 56) + 8 * v6) + 8) = result;
      ++*(_DWORD *)(a3 + 40);
    }
  }
  return result;
}

uint64_t keygen_nvram_prop(int a1)
{
  CFStringRef v2;
  const __CFString *v3;
  io_registry_entry_t v4;
  io_object_t v5;
  kern_return_t v6;
  mach_error_t v7;
  uint64_t v8;
  CFTypeRef CFProperty;
  const void *v10;

  v2 = CFStringCreateWithCString(0, "apfs_roll_keygen", 0x8000100u);
  if (v2)
  {
    v3 = v2;
    v4 = IORegistryEntryFromPath(*MEMORY[0x1E0CBBAB8], "IODeviceTree:/options");
    if (v4)
    {
      v5 = v4;
      if (a1)
      {
        v6 = IORegistryEntrySetCFProperty(v4, CFSTR("IONVRAM-DELETE-PROPERTY"), v3);
        if (!v6)
        {
          v8 = 1;
LABEL_19:
          CFRelease(v3);
          goto LABEL_20;
        }
        v7 = v6;
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          keygen_nvram_prop_cold_3(v7);
      }
      else
      {
        CFProperty = IORegistryEntryCreateCFProperty(v4, v3, 0, 0);
        if (CFProperty)
        {
          v10 = CFProperty;
          CFRelease(v3);
          CFRelease(v10);
          v8 = 1;
LABEL_20:
          IOObjectRelease(v5);
          return v8;
        }
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
          keygen_nvram_prop_cold_4();
      }
      v8 = 0;
      goto LABEL_19;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      keygen_nvram_prop_cold_2();
    CFRelease(v3);
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    keygen_nvram_prop_cold_1();
  }
  return 0;
}

void OUTLINED_FUNCTION_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

void OUTLINED_FUNCTION_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x26u);
}

void OUTLINED_FUNCTION_4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x1Cu);
}

void OUTLINED_FUNCTION_6(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x18u);
}

void OUTLINED_FUNCTION_9(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x2Cu);
}

void OUTLINED_FUNCTION_16(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x1Eu);
}

int *OUTLINED_FUNCTION_18@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 24) = a1;
  return __error();
}

char *OUTLINED_FUNCTION_19@<X0>(int __errnum@<W1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return strerror(__errnum);
}

void *tree_key_compare_function_for_type(unsigned __int16 a1)
{
  int v1;
  void *result;

  v1 = a1;
  result = spaceman_free_queue_key_cmp;
  switch(v1)
  {
    case 9:
      return result;
    case 10:
      result = extent_list_key_cmp;
      break;
    case 11:
      result = omap_key_cmp;
      break;
    case 12:
    case 13:
    case 17:
    case 18:
    case 20:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 35:
      goto LABEL_5;
    case 14:
    case 15:
    case 16:
    case 36:
      result = apfs_key_compare;
      break;
    case 19:
      result = omap_snapshot_key_cmp;
      break;
    case 21:
      result = fusion_mt_key_cmp;
      break;
    case 31:
      result = fext_tree_key_cmp;
      break;
    case 32:
      result = pfkur_tree_key_cmp;
      break;
    case 33:
      result = evict_mapping_key_compare;
      break;
    case 34:
      result = doc_id_tree_key_cmp;
      break;
    default:
      if (v1 == 255)
        result = (void *)test_key_compare_function;
      else
LABEL_5:
        result = 0;
      break;
  }
  return result;
}

uint64_t default_test_key_compare()
{
  return 22;
}

uint64_t parse_str_to_role(const char *a1)
{
  uint64_t result;
  int v3;

  if (strnlen(a1, 2uLL) > 1)
    return -1;
  v3 = *a1;
  switch(*a1)
  {
    case 'S':
      return 448;
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z':
    case '[':
    case '\\':
    case ']':
    case '^':
    case '_':
    case 'c':
    case 'f':
    case 'g':
    case 'j':
    case 'l':
    case 'm':
    case 'q':
    case 't':
    case 'w':
      return -1;
    case 'a':
      return 128;
    case 'b':
      return 16;
    case 'd':
      return 64;
    case 'e':
      return 576;
    case 'h':
      return 320;
    case 'i':
      return 32;
    case 'k':
      return 384;
    case 'n':
      return 512;
    case 'o':
      return 704;
    case 'p':
      return 192;
    case 'r':
      return 4;
    case 's':
      return 1;
    case 'u':
      return 2;
    case 'v':
      return 8;
    case 'x':
      return 256;
    default:
      if (v3 == 48)
      {
        result = 0;
      }
      else
      {
        if (v3 != 68)
          return -1;
        result = 640;
      }
      break;
  }
  return result;
}

unint64_t calc_overlap_range(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t *a5)
{
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  BOOL v8;
  BOOL v9;
  unint64_t v11;

  v5 = a2 + a1;
  v6 = a4 + a3;
  if (a2 + a1 > a3)
  {
    v7 = v6 >= a1;
    v8 = v6 == a1;
  }
  else
  {
    v7 = 0;
    v8 = 0;
  }
  v9 = !v8 && v7 && v5 >= a1;
  if (!v9 || v6 < a3)
    return 0;
  if (a1 <= a3)
    v11 = a3;
  else
    v11 = a1;
  if (v5 >= v6)
    v5 = a4 + a3;
  if (a5)
    *a5 = v11;
  return v5 - v11;
}

uint64_t ilog10(unint64_t a1)
{
  if (a1 > 0x8AC7230489E7FFFFLL)
    return 19;
  if (a1 > 0xDE0B6B3A763FFFFLL)
    return 18;
  if (a1 > 0x16345785D89FFFFLL)
    return 17;
  if (a1 > 0x2386F26FC0FFFFLL)
    return 16;
  if (a1 > 0x38D7EA4C67FFFLL)
    return 15;
  if (a1 > 0x5AF3107A3FFFLL)
    return 14;
  if (a1 > 0x9184E729FFFLL)
    return 13;
  if (a1 > 0xE8D4A50FFFLL)
    return 12;
  if (a1 > 0x174876E7FFLL)
    return 11;
  if (a1 > 0x2540BE3FFLL)
    return 10;
  if (a1 > 0x3B9AC9FF)
    return 9;
  if (a1 > 0x5F5E0FF)
    return 8;
  if (a1 > 0x98967F)
    return 7;
  if (a1 > 0xF423F)
    return 6;
  if (a1 >> 5 > 0xC34)
    return 5;
  if (a1 >> 4 > 0x270)
    return 4;
  if (a1 > 0x3E7)
    return 3;
  if (a1 <= 0x63)
    return a1 > 9;
  return 2;
}

uint64_t rc_to_errno(uint64_t result)
{
  int v1;

  if ((_DWORD)result)
  {
    v1 = result;
    if ((result & 0x3FFF | 0xC000) == (_DWORD)result)
    {
      return result & 0x3FFF;
    }
    else if (result >= 0x6B)
    {
      result = 6;
      if (v1 <= -536870175)
      {
        switch(v1)
        {
          case -536870195:
LABEL_14:
            result = 13;
            break;
          case -536870194:
          case -536870192:
          case -536870191:
          case -536870189:
          case -536870188:
          case -536870186:
          case -536870185:
          case -536870184:
          case -536870182:
            return 94;
          case -536870193:
            result = 30;
            break;
          case -536870190:
          case -536870187:
            result = 16;
            break;
          case -536870183:
            return result;
          case -536870181:
            result = 28;
            break;
          default:
            switch(v1)
            {
              case -536870211:
                result = 12;
                break;
              case -536870210:
              case -536870209:
                return 94;
              case -536870208:
                return result;
              case -536870207:
                goto LABEL_14;
              case -536870206:
                result = 22;
                break;
              default:
                if (v1 != -536870198)
                  return 94;
                result = 5;
                break;
            }
            break;
        }
      }
      else if (v1 != -536870167 && v1 != -536870172)
      {
        if (v1 == -536870174)
          return 1;
        else
          return 94;
      }
    }
  }
  return result;
}

uint64_t doc_id_tree_key_cmp(uint64_t a1, _DWORD *a2, int a3, _DWORD *a4, int a5, int *a6)
{
  uint64_t result;
  int v7;

  result = 22;
  if (a3 == 4 && a5 == 4)
  {
    result = 0;
    v7 = *a2 > *a4;
    if (*a2 < *a4)
      v7 = -1;
    *a6 = v7;
  }
  return result;
}

uint64_t gbitmap_key_compare(uint64_t a1, _QWORD *a2, int a3, _QWORD *a4, int a5, int *a6)
{
  uint64_t result;
  int v7;

  result = 22;
  if (a3 == 8 && a5 == 8)
  {
    result = 0;
    v7 = *a2 > *a4;
    if (*a2 < *a4)
      v7 = -1;
    *a6 = v7;
  }
  return result;
}

uint64_t gbitmap_block_init(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[7];
  a1[47] = v1;
  a1[48] = v1 + 32;
  return 0;
}

uint64_t gbitmap_init_phys(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t v5;

  if (!a3)
    return 22;
  result = 0;
  v5 = *a3;
  a1[4] = a3[2];
  a1[5] = v5;
  a1[6] = 0;
  return result;
}

uint64_t gbitmap_init(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 376) = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 408) = 8 * *(unsigned int *)(a1 + 48) - 256;
  if (a2)
    *(_QWORD *)(a1 + 384) = *(_QWORD *)(a2 + 24);
  return 0;
}

uint64_t gbitmap_reap(_QWORD *a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  const char *v13;
  uint64_t v14;
  int tree;
  int v16;
  const char *v17;
  unint64_t v18;
  int v19;
  int v20;
  int v21;
  unint64_t v22;
  int v23;
  unint64_t v24;
  uint64_t v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  const char *v35;
  _OWORD v37[4];
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t *v41;

  v7 = (_QWORD *)a1[1];
  v8 = *(_QWORD *)(*a1 + 392);
  if (v7)
    v9 = a1[1];
  else
    v9 = *(_QWORD *)(*a1 + 392);
  v10 = a1[2];
  v41 = 0;
  if (v7)
  {
    v11 = obj_modify(v7, 0, a5);
    if (v11)
    {
      v12 = v11;
      if (obj_type((uint64_t)v7) == 13)
        v13 = (const char *)(v7 + 485);
      else
        v13 = (const char *)(v7[48] + 208);
      v14 = obj_oid((uint64_t)v7);
      log_err("%s:%d: %s obj_modify(fs %lld) failed: %d\n", "gbitmap_reap", 160, v13, v14, v12);
    }
  }
  tree = gbitmap_get_tree(a1, 0, 0, (uint64_t *)&v41);
  if (tree)
  {
    v16 = tree;
    if (obj_type(v9) == 13)
      v17 = (const char *)(v9 + 3880);
    else
      v17 = (const char *)(*(_QWORD *)(v9 + 384) + 208);
    log_err("%s:%d: %s Can't get tree: %d\n", "gbitmap_reap", 166, v17, v16);
  }
  if (v41)
  {
    v18 = *a3;
    v39 = 0;
    v40 = v18;
    v38 = 0;
    memset(v37, 0, sizeof(v37));
    bt_iterator_init((uint64_t)v37, (uint64_t)v41, 0, 0, &v40, 8, 8u, &v39, 8u);
    v20 = v19;
    v35 = (const char *)(v9 + 3880);
    v21 = 1023;
    if (v19)
    {
LABEL_31:
      if (v20 != 2)
      {
        if (obj_type(v9) == 13)
          log_err("%s:%d: %s Tree iteration threw %d at cursor %llu\n", "gbitmap_reap", 203, v35, v20, v40);
        else
          log_err("%s:%d: %s Tree iteration threw %d at cursor %llu\n", "gbitmap_reap", 203, (const char *)(*(_QWORD *)(v9 + 384) + 208), v20, v40);
      }
    }
    else
    {
      while (!bt_iterator_ended((uint64_t)v37))
      {
        if ((v10 & 0x40000000) != 0 && (v22 = v39, (v39 & 0x8000000000000000) != 0))
        {
          v39 &= ~0x8000000000000000;
          spaceman_free((const char *)v9, 0, v22 & 0x7FFFFFFFFFFFFFFFLL, 1, a5);
        }
        else
        {
          v23 = *((_DWORD *)a1 + 4);
          if (v7)
            v24 = obj_oid((uint64_t)v7);
          else
            v24 = 0;
          v25 = *(_QWORD *)(v8 + 392);
          v26 = v23 & 0xD8000000 | 0x1B;
          v27 = obj_size_phys((uint64_t)a1);
          v28 = obj_delete_and_free_by_oid(v25, v26, v27, v24, v39, a5);
          if (v28)
          {
            v29 = v28;
            if (obj_type(v9) == 13)
              log_err("%s:%d: %s deletion threw %d for cursor %llu, oid %llu, oflags 0x%x\n", "gbitmap_reap", 188, v35, v29, v40, v39, v26);
            else
              log_err("%s:%d: %s deletion threw %d for cursor %llu, oid %llu, oflags 0x%x\n", "gbitmap_reap", 188, (const char *)(*(_QWORD *)(v9 + 384) + 208), v29, v40, v39, v26);
          }
        }
        *a3 = v40 + 1;
        if (!v21)
        {
          v30 = 36;
          goto LABEL_41;
        }
        v20 = bt_iterator_next((uint64_t)v37);
        --v21;
        if (v20)
          goto LABEL_31;
      }
    }
    v31 = btree_delete((uint64_t)v41, a5, 0);
    if (v31)
    {
      v32 = v31;
      if (obj_type(v9) != 13)
        v35 = (const char *)(*(_QWORD *)(v9 + 384) + 208);
      v33 = obj_oid((uint64_t)v41);
      log_err("%s:%d: %s Tree delete oid %llu threw %d\n", "gbitmap_reap", 208, v35, v33, v32);
    }
  }
  obj_delete_and_free(a1, a5);
  v30 = 0;
LABEL_41:
  if (v41)
    obj_release(v41);
  return v30;
}

uint64_t gbitmap_get_tree(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  unsigned int v9;

  if (a1[1])
    v8 = a1[1];
  else
    v8 = *(_QWORD *)(*a1 + 392);
  *a4 = 0;
  v9 = obj_flags((uint64_t)a1) & 0xFFFFFC00;
  return btree_get(v8, v9, *(_QWORD *)(a1[47] + 32), a2, 3, a3 != 0, 26, (uint64_t)gbitmap_key_compare, a3, a4);
}

const char *log_debug(const char *result, ...)
{
  va_list va;

  va_start(va, result);
  if (apfs_log_level >= 5)
    return (const char *)vfprintf((FILE *)*MEMORY[0x1E0C80C10], result, va);
  return result;
}

const char *log_info(const char *result, ...)
{
  va_list va;

  va_start(va, result);
  if (apfs_log_level >= 4)
    return (const char *)vfprintf((FILE *)*MEMORY[0x1E0C80C10], result, va);
  return result;
}

const char *log_warn(const char *result, ...)
{
  va_list va;

  va_start(va, result);
  if (apfs_log_level >= 3)
    return (const char *)vfprintf((FILE *)*MEMORY[0x1E0C80C10], result, va);
  return result;
}

const char *log_err(const char *result, ...)
{
  va_list va;

  va_start(va, result);
  if (apfs_log_level >= 2)
    return (const char *)vfprintf((FILE *)*MEMORY[0x1E0C80C10], result, va);
  return result;
}

uint64_t log_corrupt(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t result;

  if (apfs_log_level >= 1)
    return vfprintf((FILE *)*MEMORY[0x1E0C80C10], a2, &a9);
  return result;
}

void jobj_release(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3;
  unsigned __int8 *v4;
  void *v5;
  int v6;

  if (a2)
  {
    switch(*a2)
    {
      case 1u:
        _apfs_free(*((void **)a2 + 9), *((unsigned __int16 *)a2 + 32));
        goto LABEL_20;
      case 2u:
        v4 = a2;
        v3 = 40;
        goto LABEL_26;
      case 3u:
        if ((*((_WORD *)a2 + 48) & 0xF000) == 0xA000)
        {
          v5 = (void *)*((_QWORD *)a2 + 44);
          if (v5)
          {
            _apfs_free(v5, *((int *)a2 + 90));
            *((_QWORD *)a2 + 44) = 0;
          }
        }
        xf_release((uint64_t)(a2 + 408));
        if ((a2[117] & 0x10) != 0)
        {
          free_rwlock((pthread_rwlock_t *)(a2 + 448));
          free_rwlock((pthread_rwlock_t *)(a2 + 120));
          *((_QWORD *)a2 + 14) &= ~0x100000000000uLL;
        }
        _apfs_zfree(a2, 2u);
        return;
      case 4u:
      case 5u:
      case 7u:
      case 0xBu:
        goto LABEL_3;
      case 6u:
      case 0xCu:
        v4 = a2;
        v3 = 24;
        goto LABEL_26;
      case 8u:
        v4 = a2;
        v3 = 56;
        goto LABEL_26;
      case 9u:
        xf_release((uint64_t)(a2 + 32));
        _apfs_free(*((void **)a2 + 8), *((unsigned __int16 *)a2 + 31));
        goto LABEL_25;
      case 0xAu:
      case 0x12u:
        xf_release((uint64_t)(a2 + 64));
        v4 = a2;
        v3 = 96;
        goto LABEL_26;
      case 0xDu:
        v6 = a2[16];
        if (v6 == 2)
          goto LABEL_19;
        if (v6 != 1)
          return;
LABEL_3:
        v3 = *((unsigned __int16 *)a2 + 1);
        v4 = a2;
LABEL_26:
        _apfs_free(v4, v3);
        break;
      case 0x10u:
LABEL_19:
        xf_release((uint64_t)(a2 + 56));
LABEL_20:
        v4 = a2;
        v3 = 80;
        goto LABEL_26;
      case 0x11u:
        v4 = a2;
        v3 = 32;
        goto LABEL_26;
      case 0x13u:
        xf_release((uint64_t)(a2 + 48));
LABEL_25:
        v4 = a2;
        v3 = 72;
        goto LABEL_26;
      default:
        log_err("%s:%d: *** Can't release unknown obj type %d\n", "jobj_release", 2826, *a2);
        return;
    }
  }
}

uint64_t make_jkey_from_jobj(uint64_t result, unsigned __int8 *a2, uint64_t a3, int *a4)
{
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  _BOOL8 is_panic_on_corruption_enabled;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _BOOL8 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  size_t v28;
  int v29;
  unsigned int v30;
  void *v31;
  int v32;
  size_t v33;
  _BOOL8 v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;

  v7 = result;
  v8 = *a2;
  v9 = *a2;
  v10 = v8 << 60;
  v11 = (v8 & 0xF0) == 0;
  v12 = 0xE000000000000000;
  if (v11)
    v12 = v10;
  *(_QWORD *)a3 = v12 & 0xF000000000000000 | *((_QWORD *)a2 + 1) & 0xFFFFFFFFFFFFFFFLL;
  if (v9 >= 0x10)
  {
    if ((*(_BYTE *)(*(_QWORD *)(result + 376) + 57) & 2) == 0)
    {
      is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(*(_QWORD *)(result + 392));
      result = log_corrupt(is_panic_on_corruption_enabled, "%s:%d: %s ***: expanded obj type %d (obj_id %llu) found on unsupported volume\n", v14, v15, v16, v17, v18, v19, (char)"make_jkey_from_jobj");
      *a4 = 0;
      return result;
    }
    if ((v9 & 0xFC) == 0x10)
    {
      *(_DWORD *)(a3 + 8) = v9;
    }
    else
    {
      v20 = nx_is_panic_on_corruption_enabled(*(_QWORD *)(result + 392));
      result = log_corrupt(v20, "%s:%d: %s Cannot make large jkey from unknown type %d (obj_id %llu)\n", v21, v22, v23, v24, v25, v26, (char)"make_large_jkey_header_from_jobj");
      v9 = *a2;
    }
  }
  switch(v9)
  {
    case 4u:
      v28 = *((unsigned __int16 *)a2 + 10);
      *(_WORD *)(a3 + 8) = v28;
      result = (uint64_t)memcpy((void *)(a3 + 10), a2 + 24, v28);
      v29 = *((unsigned __int16 *)a2 + 10);
      goto LABEL_19;
    case 5u:
    case 8u:
      *(_QWORD *)(a3 + 8) = *((_QWORD *)a2 + 2);
      v27 = 16;
      goto LABEL_26;
    case 9u:
      v30 = *((unsigned __int16 *)a2 + 31);
      if ((*(_BYTE *)(*(_QWORD *)(v7 + 376) + 56) & 9) != 0)
      {
        *(_DWORD *)(a3 + 8) = *((_WORD *)a2 + 31) & 0x3FF | (*((_DWORD *)a2 + 14) << 10);
        v31 = (void *)(a3 + 12);
        v32 = 12;
      }
      else
      {
        *(_WORD *)(a3 + 8) = v30;
        v31 = (void *)(a3 + 10);
        v32 = 10;
      }
      result = (uint64_t)memcpy(v31, *((const void **)a2 + 8), v30);
      v27 = v32 + *((unsigned __int16 *)a2 + 31);
      goto LABEL_26;
    case 0xAu:
      v27 = 96;
      goto LABEL_26;
    case 0xBu:
      v33 = *((unsigned __int16 *)a2 + 12);
      *(_WORD *)(a3 + 8) = v33;
      result = (uint64_t)memcpy((void *)(a3 + 10), a2 + 26, v33);
      v29 = *((unsigned __int16 *)a2 + 12);
LABEL_19:
      v27 = v29 + 10;
      goto LABEL_26;
    case 0xDu:
      *a4 = 16;
      *(_QWORD *)(a3 + 8) = __ROR8__(*((_QWORD *)a2 + 2), 8);
      return result;
    case 0xEu:
      *a4 = 0;
      v34 = nx_is_panic_on_corruption_enabled(*(_QWORD *)(v7 + 392));
      return log_corrupt(v34, "%s:%d: %s ***: expanded type seen on in-memory obj!\n", v35, v36, v37, v38, v39, v40, (char)"make_jkey_from_jobj");
    case 0x10u:
    case 0x13u:
      *(_OWORD *)(a3 + 12) = *((_OWORD *)a2 + 1);
      v27 = 28;
      goto LABEL_26;
    case 0x11u:
      *(_QWORD *)(a3 + 12) = *((_QWORD *)a2 + 2);
      v27 = 20;
      goto LABEL_26;
    case 0x12u:
      v27 = 12;
      goto LABEL_26;
    default:
      v27 = 8;
LABEL_26:
      *a4 = v27;
      break;
  }
  return result;
}

uint64_t jobj_validate_key_val(uint64_t a1, uint64_t a2)
{
  if (a2)
    __asm { BR              X11 }
  return 22;
}

uint64_t jobj_validate_large_key_val(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t result;

  if ((*(_BYTE *)(*(_QWORD *)(a1 + 376) + 57) & 2) != 0)
  {
    switch(*(_BYTE *)(a2 + 8))
    {
      case 0x10:
        if (a3 <= 0x1B)
        {
          log_err("%s:%d: %s key size (%zu) on purgeable record (%llu) is too small\n");
          return 22;
        }
        result = 0;
        if (a4 && a5 <= 0x17)
        {
          log_err("%s:%d: %s value size (%zu) on purgeable record (%llu) is too small\n");
          return 22;
        }
        break;
      case 0x11:
        if (a3 <= 0x13)
        {
          log_err("%s:%d: %s key size (%zu) on purgeable tombstone (%llu) is too small\n");
          return 22;
        }
        result = 0;
        if (a4 && a5 <= 7)
        {
          log_err("%s:%d: %s value size (%zu) on purgeable tombstone (%llu) is too small\n");
          return 22;
        }
        break;
      case 0x12:
        result = 0;
        if (a4 && a5 <= 0x33)
        {
          log_err("%s:%d: %s value size (%zu) on dir stats (%llu) is too small\n");
          return 22;
        }
        break;
      case 0x13:
        if (a3 <= 0x1B)
        {
          log_err("%s:%d: %s key size (%zu) on clone mapping (%llu) is too small\n");
          return 22;
        }
        result = 0;
        if (a4 && a5 <= 7)
        {
          log_err("%s:%d: %s value size (%zu) on clone mapping (%llu) is too small\n");
          return 22;
        }
        break;
      default:
        result = 0;
        if (a4 && a5 <= 3)
        {
          log_err("%s:%d: %s value size (%zu) on unknown record (%llu) is too small\n");
          return 22;
        }
        break;
    }
  }
  else
  {
    log_err("%s:%d: %s ***: expanded obj type found on unsupported volume\n");
    return 22;
  }
  return result;
}

uint64_t apfs_key_compare(uint64_t a1, _QWORD *a2, unsigned int a3, _QWORD *a4, unsigned int a5, int *a6)
{
  uint64_t v6;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v16;
  BOOL v17;
  unsigned __int8 *v19;
  unsigned __int8 *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  BOOL v25;
  _BOOL4 v26;
  unint64_t v27;
  unint64_t v28;
  BOOL v29;
  unsigned int v30;
  unsigned int v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  BOOL v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;

  v6 = 22;
  if (a3 >= 8 && a5 >= 8)
  {
    v10 = *a2 & 0xFFFFFFFFFFFFFFFLL;
    v11 = *a4 & 0xFFFFFFFFFFFFFFFLL;
    if (v10 < v11)
    {
LABEL_4:
      v12 = -1;
LABEL_24:
      v6 = 0;
      *a6 = v12;
      return v6;
    }
    if (v10 > v11)
      goto LABEL_6;
    v13 = *a2 >> 60;
    v14 = *a4 >> 60;
    if (!(_DWORD)v13)
    {
      v17 = (_DWORD)v14 == 0;
LABEL_21:
      if (v17)
        v12 = 0;
      else
        v12 = -1;
      goto LABEL_24;
    }
    if (!(_DWORD)v14)
      goto LABEL_6;
    if (v13 < v14)
      goto LABEL_4;
    if (v13 > v14)
      goto LABEL_6;
    if ((_DWORD)v13 != 14)
    {
LABEL_16:
      if (obj_type(a1) != 13)
        return 22;
      if (jobj_validate_key_val(a1, (uint64_t)a2))
        return 22;
      v12 = jobj_validate_key_val(a1, (uint64_t)a4);
      if (v12)
        return 22;
      switch((int)v13)
      {
        case 4:
        case 11:
          goto LABEL_27;
        case 5:
          v23 = a2[1];
          v24 = a4[1];
          if (!v23)
            goto LABEL_60;
          if (!v24)
            break;
          v25 = v23 >= v24;
          v26 = v23 > v24;
          goto LABEL_57;
        case 8:
          v27 = a2[1];
          v28 = a4[1];
          if (v27 == -1)
          {
            v17 = v28 == -1;
            goto LABEL_21;
          }
          if (v28 == -1)
            break;
          v29 = v27 > v28;
          if (v27 >= v28)
            goto LABEL_73;
          goto LABEL_4;
        case 9:
          if ((*(_BYTE *)(*(_QWORD *)(a1 + 376) + 56) & 9) == 0)
          {
LABEL_27:
            v19 = (unsigned __int8 *)a2 + 10;
            v20 = (unsigned __int8 *)a4 + 10;
            v21 = *((unsigned __int16 *)a2 + 4);
            v22 = *((unsigned __int16 *)a4 + 4);
LABEL_28:
            v12 = apfs_cstrncmp(v19, v20, v21, v22);
            goto LABEL_24;
          }
          v30 = *((_DWORD *)a2 + 2);
          v31 = *((_DWORD *)a4 + 2);
          if (v30 >> 10 < v31 >> 10)
            goto LABEL_4;
          if (v30 >> 10 <= v31 >> 10)
          {
            v21 = v30 & 0x3FF;
            v22 = v31 & 0x3FF;
            v19 = (unsigned __int8 *)a2 + 12;
            v20 = (unsigned __int8 *)a4 + 12;
            goto LABEL_28;
          }
          break;
        case 13:
          v32 = a2[1];
          v33 = HIBYTE(v32);
          v34 = a4[1];
          v35 = HIBYTE(v34);
          if (!HIBYTE(v32))
          {
            v17 = v35 == 0;
            goto LABEL_21;
          }
          if (!v35)
            break;
          if (v33 != v35)
          {
            if (v33 < v35)
              v12 = -1;
            else
              v12 = 1;
            goto LABEL_24;
          }
          v44 = v32 & 0xFFFFFFFFFFFFFFLL;
          v45 = v34 & 0xFFFFFFFFFFFFFFLL;
          if (v44 == 0xFFFFFFFFFFFFFFLL)
          {
            v17 = v45 == 0xFFFFFFFFFFFFFFLL;
            goto LABEL_21;
          }
          if (v45 == 0xFFFFFFFFFFFFFFLL)
            break;
          v25 = v44 >= v45;
          v39 = v44 == v45;
LABEL_54:
          v26 = !v39;
LABEL_57:
          if (v25)
            v12 = v26;
          else
            v12 = -1;
          goto LABEL_24;
        case 16:
          v36 = *(_QWORD *)((char *)a2 + 12);
          v24 = *(_QWORD *)((char *)a4 + 12);
          if (!v36)
            goto LABEL_60;
          if (!v24)
            break;
          if (v36 < v24)
            goto LABEL_4;
          if (v36 != v24)
          {
            v29 = v36 > v24;
LABEL_73:
            v12 = v29;
            goto LABEL_24;
          }
          v37 = *(_QWORD *)((char *)a2 + 20);
          v24 = *(_QWORD *)((char *)a4 + 20);
          if (!v37)
          {
LABEL_60:
            v17 = v24 == 0;
            goto LABEL_21;
          }
          if (!v24)
            break;
          if (v37 >= v24)
          {
            v12 = v37 != v24;
            goto LABEL_24;
          }
          goto LABEL_4;
        case 17:
          v38 = *(_QWORD *)((char *)a2 + 12);
          v24 = *(_QWORD *)((char *)a4 + 12);
          if (!v38)
            goto LABEL_60;
          if (!v24)
            break;
          v25 = v38 >= v24;
          v39 = v38 == v24;
          goto LABEL_54;
        case 19:
          v40 = *(_QWORD *)((char *)a2 + 12);
          v41 = *(_QWORD *)((char *)a4 + 12);
          if (v40 < v41)
            goto LABEL_4;
          if (v40 > v41)
            break;
          v42 = *(_QWORD *)((char *)a2 + 20);
          v43 = *(_QWORD *)((char *)a4 + 20);
          v29 = v42 > v43;
          if (v42 < v43)
            goto LABEL_4;
          goto LABEL_73;
        default:
          goto LABEL_24;
      }
LABEL_6:
      v12 = 1;
      goto LABEL_24;
    }
    v6 = 22;
    if (a3 >= 0xC && a5 >= 0xC)
    {
      LODWORD(v13) = *((unsigned __int8 *)a2 + 8);
      v16 = *((unsigned __int8 *)a4 + 8);
      if (v13 < v16)
        goto LABEL_4;
      if (v13 > v16)
        goto LABEL_6;
      goto LABEL_16;
    }
  }
  return v6;
}

uint64_t jfs_get_tree(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  return jfs_get_tree_in_snap(a1, a2, a3, *(_QWORD *)(a1 + 432), a4);
}

uint64_t jfs_get_tree_in_snap(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t extentref_tree;
  pthread_mutex_t *v10;
  char *v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  pthread_mutex_t *v17;
  uint64_t *v18;
  char *v20;
  uint64_t v22;
  BOOL v23;
  char *v25;
  char *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v32;
  BOOL v33;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  pthread_mutex_t *v45;
  int v46;
  uint64_t extended;
  char *v48;
  char *v49;
  uint64_t (*v51)(uint64_t, _QWORD *, int, _QWORD *, int, int *);
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  extentref_tree = 0;
  switch(a2)
  {
    case 1:
      goto LABEL_59;
    case 2:
      v10 = (pthread_mutex_t *)(a1 + 1400);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1400));
      v11 = *(char **)(a1 + 3456);
      if (v11)
      {
        obj_retain(v11);
        if (a3)
        {
          extentref_tree = obj_modify(*(_QWORD **)(a1 + 3456), 2, a3);
          v12 = *(uint64_t **)(a1 + 3456);
          if ((_DWORD)extentref_tree)
          {
            obj_release(v12);
            goto LABEL_93;
          }
          *(_QWORD *)(*(_QWORD *)(a1 + 376) + 144) = obj_oid((uint64_t)v12);
        }
        extentref_tree = 0;
        *a5 = *(_QWORD *)(a1 + 3456);
      }
      else
      {
        extentref_tree = apfs_get_extentref_tree(a1, *(_QWORD *)(*(_QWORD *)(a1 + 376) + 144), a3, a5);
        if (!(_DWORD)extentref_tree)
        {
          if (a3)
            *(_QWORD *)(*(_QWORD *)(a1 + 376) + 144) = obj_oid(*a5);
          v30 = (char *)*a5;
          *(_QWORD *)(a1 + 3456) = *a5;
          obj_retain(v30);
          extentref_tree = 0;
        }
      }
LABEL_93:
      v45 = v10;
      goto LABEL_114;
    case 3:
      v10 = (pthread_mutex_t *)(a1 + 1464);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1464));
      extentref_tree = apfs_get_snap_meta_tree(a1, a3, a5);
      if (!(_DWORD)extentref_tree)
        *(_QWORD *)(*(_QWORD *)(a1 + 376) + 152) = obj_oid(*a5);
      goto LABEL_93;
    case 4:
      v13 = *(uint64_t **)(a1 + 3448);
      if (v13)
      {
        obj_retain(*(char **)(a1 + 3448));
        if (!a3)
          goto LABEL_78;
        v14 = obj_modify(v13, 0, a3);
        if (!(_DWORD)v14)
          goto LABEL_78;
        extentref_tree = v14;
        obj_release(v13);
      }
      else
      {
        extentref_tree = 0;
      }
LABEL_59:
      v13 = *(uint64_t **)(a1 + 3432);
      if (*(_QWORD *)(a1 + 432) != a4 || v13 == 0)
      {
        extentref_tree = apfs_get_fsroot_tree(a1, a4, a3, a5);
        if ((_DWORD)extentref_tree)
          return extentref_tree;
        v32 = *(_QWORD *)(a1 + 432);
        if (v32)
          v33 = *(_QWORD *)(a1 + 496) == 0;
        else
          v33 = 0;
        if (!v33 && v32 == a4)
        {
          v44 = (char *)*a5;
          obj_retain(v44);
          extentref_tree = 0;
          *(_QWORD *)(a1 + 3432) = v44;
          return extentref_tree;
        }
        return 0;
      }
      obj_retain(*(char **)(a1 + 3432));
      if (a3)
        goto LABEL_74;
      if ((_DWORD)extentref_tree)
        return extentref_tree;
      goto LABEL_78;
    case 5:
      v15 = *(_QWORD *)(a1 + 376);
      if ((*(_BYTE *)(v15 + 56) & 0x20) == 0)
        return 45;
      v16 = *(_DWORD *)(v15 + 1040);
      if (a3 && *(_QWORD *)(a1 + 440))
        return 30;
      v17 = (pthread_mutex_t *)(a1 + 1528);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1528));
      v36 = *(char **)(a1 + 3464);
      if (!v36)
        goto LABEL_100;
      if ((v16 & 0xC0000000) == 0)
      {
        if (*(_QWORD *)(a1 + 432) == a4)
          goto LABEL_96;
LABEL_100:
        v37 = *(_QWORD *)(a1 + 440);
        v38 = *(_QWORD *)(a1 + 376);
        if (!v37)
          v37 = *(_QWORD *)(v38 + 1032);
        goto LABEL_102;
      }
      if ((v16 & 0xC0000000) != 0x40000000)
        goto LABEL_100;
      v37 = *(_QWORD *)(a1 + 440);
      if (!v37)
      {
LABEL_96:
        obj_retain(v36);
        if (a3)
        {
          extentref_tree = obj_modify(*(_QWORD **)(a1 + 3464), 2, a3);
          v27 = *(uint64_t **)(a1 + 3464);
          if ((_DWORD)extentref_tree)
            goto LABEL_51;
          *(_QWORD *)(*(_QWORD *)(a1 + 376) + 1032) = obj_oid((uint64_t)v27);
        }
        extentref_tree = 0;
        v28 = *(_QWORD *)(a1 + 3464);
        goto LABEL_47;
      }
      v38 = *(_QWORD *)(a1 + 376);
LABEL_102:
      v46 = *(_DWORD *)(v38 + 1040);
      *(_QWORD *)&v52 = 0;
      v53 = 0u;
      v57 = 0;
      v55 = 0u;
      v56 = 0u;
      v54 = 0u;
      v51 = fext_tree_key_cmp;
      *((_QWORD *)&v52 + 1) = 0x20000001FLL;
      if ((unsigned __int16)v46 != 2)
      {
        extentref_tree = 22;
LABEL_108:
        v48 = strerror(extentref_tree);
        log_err("%s:%d: %s Failed to get fext tree w/oid %llu (modify_xid %llu): %d (%s)\n", "jfs_get_tree_in_snap", 3890, (const char *)(a1 + 3880), v37, a3, extentref_tree, v48);
        goto LABEL_113;
      }
      extended = btree_get_extended(a1, v46 & 0xFFFF0000, v37, a4, a3 != 0, (uint64_t)&v51, a3, a5);
      extentref_tree = extended;
      if (a3 && !(_DWORD)extended)
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 376) + 1032) = obj_oid(*a5);
        goto LABEL_113;
      }
      if ((_DWORD)extended)
        goto LABEL_108;
LABEL_113:
      v45 = v17;
LABEL_114:
      pthread_mutex_unlock(v45);
      return extentref_tree;
    case 6:
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 376) + 56) & 0x40) == 0)
        return 45;
      v17 = (pthread_mutex_t *)(a1 + 1592);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1592));
      v26 = *(char **)(a1 + 3472);
      if (!v26)
      {
        v39 = *(_QWORD *)(a1 + 384);
        if (!v39)
          v39 = *(_QWORD *)(a1 + 376);
        v40 = *(_DWORD *)(v39 + 1044);
        v41 = *(_QWORD *)(v39 + 1048);
        v52 = 0u;
        v57 = 0;
        v55 = 0u;
        v56 = 0u;
        v54 = 0u;
        v53 = 0u;
        v51 = pfkur_tree_key_cmp;
        DWORD2(v52) = 32;
        if ((unsigned __int16)v40 == 2)
        {
          v42 = btree_get_extended(a1, v40 & 0xFFFF0000, v41, a4, a3 != 0, (uint64_t)&v51, a3, a5);
          v43 = v42;
          if (a3 && !(_DWORD)v42)
          {
            extentref_tree = 0;
            *(_QWORD *)(*(_QWORD *)(a1 + 376) + 1048) = obj_oid(*a5);
            goto LABEL_113;
          }
          if (!(_DWORD)v42)
          {
LABEL_112:
            extentref_tree = 0;
            goto LABEL_113;
          }
          v41 = *(_QWORD *)(v39 + 1048);
        }
        else
        {
          v43 = 22;
        }
        v49 = strerror(v43);
        log_err("%s:%d: %s Failed to get pfkur tree w/oid %llu (modify_xid %llu): %d (%s)\n", "jfs_get_tree_in_snap", 3938, (const char *)(a1 + 3880), v41, a3, v43, v49);
        extentref_tree = v43;
        goto LABEL_113;
      }
      obj_retain(v26);
      if (a3)
      {
        extentref_tree = obj_modify(*(_QWORD **)(a1 + 3472), 2, a3);
        v27 = *(uint64_t **)(a1 + 3472);
        if ((_DWORD)extentref_tree)
          goto LABEL_51;
        *(_QWORD *)(*(_QWORD *)(a1 + 376) + 1048) = obj_oid((uint64_t)v27);
      }
      extentref_tree = 0;
      v28 = *(_QWORD *)(a1 + 3472);
LABEL_47:
      *a5 = v28;
      goto LABEL_113;
    case 7:
      v17 = (pthread_mutex_t *)(a1 + 1656);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1656));
      v18 = *(uint64_t **)(a1 + 3480);
      if (*(_QWORD *)(a1 + 432) == a4 && v18 != 0)
      {
        obj_retain(*(char **)(a1 + 3480));
        if (a3 && (v29 = obj_modify(v18, 0, a3), (_DWORD)v29))
        {
          extentref_tree = v29;
          v27 = v18;
LABEL_51:
          obj_release(v27);
        }
        else
        {
          extentref_tree = 0;
          *a5 = (uint64_t)v18;
        }
        goto LABEL_113;
      }
      extentref_tree = apfs_get_doc_id_tree(a1, 0, a4, a3, a5);
      if ((_DWORD)extentref_tree)
        goto LABEL_113;
      if (*(_QWORD *)(a1 + 432) == a4)
      {
        v20 = (char *)*a5;
        obj_retain(v20);
        extentref_tree = 0;
        *(_QWORD *)(a1 + 3480) = v20;
        goto LABEL_113;
      }
      goto LABEL_112;
    case 8:
      v13 = *(uint64_t **)(a1 + 3440);
      if (*(_QWORD *)(a1 + 432) != a4 || v13 == 0)
      {
        extentref_tree = apfs_get_secondary_fsroot_tree(a1, a4, a3, a5);
        if (!(_DWORD)extentref_tree)
        {
          v22 = *(_QWORD *)(a1 + 432);
          if (v22)
            v23 = *(_QWORD *)(a1 + 496) == 0;
          else
            v23 = 0;
          if (!v23 && v22 == a4)
          {
            v25 = (char *)*a5;
            obj_retain(v25);
            extentref_tree = 0;
            *(_QWORD *)(a1 + 3440) = v25;
          }
          else
          {
            return 0;
          }
        }
      }
      else
      {
        obj_retain(*(char **)(a1 + 3440));
        if (a3)
        {
LABEL_74:
          v35 = obj_modify(v13, 0, a3);
          if ((_DWORD)v35)
          {
            extentref_tree = v35;
            obj_release(v13);
            return extentref_tree;
          }
        }
LABEL_78:
        extentref_tree = 0;
        *a5 = (uint64_t)v13;
      }
      return extentref_tree;
    default:
      return 22;
  }
}

uint64_t match_jobj_type_to_tree_type(uint64_t a1, unsigned int a2, int a3)
{
  unsigned __int8 v4;

  if (a2 < 0x10)
  {
    v4 = 3;
    switch(a2)
    {
      case 1u:
      case 0xBu:
        return v4;
      case 2u:
        return 2;
      case 6u:
      case 7u:
        goto LABEL_5;
      case 8u:
        if ((*(_BYTE *)(*(_QWORD *)(a1 + 376) + 56) & 0x20) == 0)
        {
LABEL_5:
          if (a3 == 100)
            return 1;
          if (a3 == 101)
          {
            if ((*(_BYTE *)(*(_QWORD *)(a1 + 376) + 57) & 1) == 0)
              panic("Requested forced secondary_fs_root but the tree is missing\n");
          }
          else
          {
            if (!apfs_has_secondary_fsroot(a1))
              return a3;
            if (a3 != 1)
              panic("type = %u, req_tree != fs_root\n", a2);
          }
          return 8;
        }
        if (a3 != 1)
          panic("sealed, fext, req_tree != fs_root");
        v4 = 5;
        break;
      default:
        return a3;
    }
  }
  else if ((*(_BYTE *)(*(_QWORD *)(a1 + 376) + 57) & 2) != 0)
  {
    if ((a2 & 0xFC) == 0x10)
    {
      if (apfs_has_secondary_fsroot(a1))
        return 8;
      else
        return 1;
    }
    else
    {
      log_warn("%s:%d: %s Warning: attempting to place unknown expanded type %hhu into fsroot.\n", "match_jobj_expanded_type_to_tree_type", 4217, (const char *)(a1 + 3880), a2);
      return 1;
    }
  }
  else
  {
    log_err("%s:%d: %s expanded obj type %hhu found on unsupported volume\n", "match_jobj_expanded_type_to_tree_type", 4196, (const char *)(a1 + 3880), a2);
    return 0;
  }
  return v4;
}

unsigned __int16 *key_val_to_jobj(uint64_t a1, uint64_t a2, unint64_t a3, unsigned __int16 *a4, unint64_t a5)
{
  unsigned __int16 *v10;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  _BOOL8 is_panic_on_corruption_enabled;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  BOOL v26;
  uint64_t v27;
  unsigned __int16 *v28;
  size_t v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  size_t v37;
  char *v38;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  size_t v42;
  size_t v43;
  char *v44;
  unsigned __int16 *v45;
  uint64_t v46;
  uint64_t v47;
  unsigned __int16 *v48;
  int v49;
  uint64_t v50;
  unsigned int v51;
  char *v52;
  const char *v53;
  size_t v54;
  size_t v55;
  unint64_t v56;
  __int128 v57;
  const char *v58;
  unsigned __int16 *v59;
  int v60;
  uint64_t v61;
  int v62;
  _WORD *v63;
  int v64;
  uint64_t v65;
  int v66;
  unsigned __int16 *i;
  int v68;

  if (jobj_validate_key_val(a1, a2))
    return 0;
  v12 = *(_QWORD *)a2 >> 60;
  LODWORD(v13) = 40;
  switch((int)v12)
  {
    case 1:
      if (!a4)
        return 0;
      v14 = a4[24];
      v15 = 80;
      goto LABEL_32;
    case 2:
      goto LABEL_36;
    case 3:
      LODWORD(v13) = 648;
      goto LABEL_36;
    case 4:
      if (!a4)
        return 0;
      v14 = *(unsigned __int16 *)(a2 + 8) + 24;
      v15 = a4[1];
      goto LABEL_32;
    case 5:
      if (!a4)
        return 0;
      v14 = a4[4];
      goto LABEL_18;
    case 6:
    case 12:
      LODWORD(v13) = 24;
      goto LABEL_36;
    case 7:
      if (!a4)
        return 0;
      if (a4[2] == 6)
        v14 = HIBYTE(a4[11]) + a4[11];
      else
        v14 = a4[11];
LABEL_18:
      v15 = 40;
      goto LABEL_32;
    case 8:
      LODWORD(v13) = 56;
      goto LABEL_36;
    case 9:
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 376) + 56) & 9) != 0)
      {
        LODWORD(v13) = (*(_DWORD *)(a2 + 8) & 0x3FF) + 72;
        goto LABEL_36;
      }
      v14 = *(unsigned __int16 *)(a2 + 8);
      v15 = 72;
LABEL_32:
      v25 = v14 + v15;
      LODWORD(v13) = (unsigned __int16)v25;
      if (v25 >> 16)
        v26 = 1;
      else
        v26 = (unsigned __int16)v25 == 0;
      if (!v26)
        goto LABEL_36;
      return 0;
    case 10:
      LODWORD(v13) = 96;
      goto LABEL_36;
    case 11:
      v14 = *(unsigned __int16 *)(a2 + 8);
      v15 = 32;
      goto LABEL_32;
    case 13:
      if (!a4)
        return 0;
      v16 = *(unsigned __int8 *)(a2 + 15);
      if (v16 == 2)
      {
        LODWORD(v13) = 80;
      }
      else
      {
        if (v16 != 1)
          return 0;
        LODWORD(v13) = *((unsigned __int8 *)a4 + 2) + 32;
      }
      goto LABEL_36;
    case 14:
      v17 = *(_DWORD *)(a2 + 8);
      if ((v17 - 16) >= 4u)
      {
        is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(*(_QWORD *)(a1 + 392));
        log_corrupt(is_panic_on_corruption_enabled, "%s:%d: %s *** unknown expanded obj type %hhu\n", v19, v20, v21, v22, v23, v24, (char)"jobj_size_for_large_key_val");
        return 0;
      }
      v13 = (0x48006000200050uLL >> (16 * (v17 - 16))) & 0x78;
LABEL_36:
      if (v12 == 14)
      {
        LODWORD(v27) = *(unsigned __int8 *)(a2 + 8);
        if (v27 <= 0xF)
        {
          log_err("%s:%d: unknown expanded type (%hhu) on record (%u)\n");
          return 0;
        }
      }
      else
      {
        v27 = *(_QWORD *)a2 >> 60;
      }
      switch((int)v27)
      {
        case 1:
          v10 = (unsigned __int16 *)_apfs_calloc(1uLL, 0x50uLL);
          if (!v10)
            return v10;
          v30 = _apfs_calloc(1uLL, v13 - 80);
          *((_QWORD *)v10 + 9) = v30;
          if (v30)
            goto LABEL_64;
          v31 = v10;
          v32 = 80;
          goto LABEL_54;
        case 2:
          v29 = 40;
          goto LABEL_62;
        case 3:
          v28 = (unsigned __int16 *)_apfs_zalloc(2u);
          goto LABEL_63;
        case 4:
        case 5:
        case 7:
        case 11:
          goto LABEL_42;
        case 6:
        case 12:
          v29 = 24;
          goto LABEL_62;
        case 8:
          v29 = 56;
          goto LABEL_62;
        case 9:
          v10 = (unsigned __int16 *)_apfs_calloc(1uLL, 0x48uLL);
          if (!v10)
            return v10;
          v33 = _apfs_malloc(v13 - 72);
          *((_QWORD *)v10 + 8) = v33;
          if (v33)
            goto LABEL_64;
          v31 = v10;
          v32 = 72;
LABEL_54:
          _apfs_free(v31, v32);
          return 0;
        case 10:
        case 18:
          v29 = 96;
          goto LABEL_62;
        case 13:
          v34 = HIBYTE(*(_QWORD *)(a2 + 8));
          if ((_DWORD)v34 == 2)
            goto LABEL_58;
          if ((_DWORD)v34 != 1)
          {
            log_err("%s:%d: *** Unknown file info type %llu\n");
            return 0;
          }
LABEL_42:
          v28 = (unsigned __int16 *)_apfs_malloc(v13);
LABEL_63:
          v10 = v28;
          if (!v28)
            return v10;
LABEL_64:
          v35 = *(_QWORD *)a2;
          v36 = *(_QWORD *)a2 & 0xFFFFFFFFFFFFFFFLL;
          *((_QWORD *)v10 + 1) = v36;
          v35 >>= 60;
          *(_BYTE *)v10 = v35;
          *((_BYTE *)v10 + 1) = 1;
          v10[1] = v13;
          switch((int)v35)
          {
            case 1:
              *((_OWORD *)v10 + 1) = *(_OWORD *)a4;
              *((_OWORD *)v10 + 2) = *((_OWORD *)a4 + 1);
              *((_QWORD *)v10 + 6) = *((_QWORD *)a4 + 4);
              *((_QWORD *)v10 + 7) = *((_QWORD *)a4 + 5);
              v37 = a4[24];
              v10[32] = v37;
              v38 = (char *)*((_QWORD *)v10 + 9);
              v39 = (const char *)(a4 + 25);
              goto LABEL_72;
            case 2:
              v40 = *((_QWORD *)a4 + 1);
              v41 = *(_QWORD *)a4 & 0xFFFFFFFFFFFFFFFLL;
              *((_BYTE *)v10 + 1) = *(_QWORD *)a4 >> 60;
              *((_DWORD *)v10 + 8) = *((_DWORD *)a4 + 4);
              *((_QWORD *)v10 + 2) = v41;
              *((_QWORD *)v10 + 3) = v40;
              return v10;
            case 3:
              *((_QWORD *)v10 + 2) = *(_QWORD *)a4;
              *((_QWORD *)v10 + 3) = *((_QWORD *)a4 + 1);
              *((_QWORD *)v10 + 4) = *((_QWORD *)a4 + 2);
              *((_QWORD *)v10 + 5) = *((_QWORD *)a4 + 3);
              *((_QWORD *)v10 + 6) = *((_QWORD *)a4 + 4);
              *((_QWORD *)v10 + 7) = *((_QWORD *)a4 + 5);
              *((_DWORD *)v10 + 18) = *((_DWORD *)a4 + 14);
              *((_QWORD *)v10 + 8) = *((_QWORD *)a4 + 6);
              *((_DWORD *)v10 + 19) = *((_DWORD *)a4 + 15);
              *((_DWORD *)v10 + 20) = *((_DWORD *)a4 + 16);
              *((_DWORD *)v10 + 21) = *((_DWORD *)a4 + 17);
              *((_DWORD *)v10 + 22) = *((_DWORD *)a4 + 18);
              *((_DWORD *)v10 + 23) = *((_DWORD *)a4 + 19);
              v10[48] = a4[40];
              v10[49] = a4[41];
              *((_QWORD *)v10 + 13) = *(_QWORD *)(a4 + 42);
              if (a5 < 0x5D)
                return v10;
              if (xf_init_with_blob(v10 + 204, a4 + 46, a5 - 92))
              {
                log_debug("%s:%d: failed to init extended fields on inode %lld from blob (xfret %d).\n");
                return v10;
              }
              v61 = v10[204];
              if (!v10[204])
                return v10;
              v62 = 0;
              v63 = (_WORD *)(*((_QWORD *)v10 + 52) + 2);
              break;
            case 4:
              v42 = *(unsigned __int16 *)(a2 + 8);
              v10[10] = v42;
              strlcpy((char *)v10 + 24, (const char *)(a2 + 10), v42);
              *((_DWORD *)v10 + 4) = *a4;
              v43 = a4[1];
              v10[11] = v43;
              v44 = (char *)v10 + v10[10] + 24;
              v45 = a4 + 2;
              goto LABEL_87;
            case 5:
              v46 = *(_QWORD *)a4;
              *((_QWORD *)v10 + 2) = *(_QWORD *)(a2 + 8);
              *((_QWORD *)v10 + 3) = v46;
              v37 = a4[4];
              v10[16] = v37;
              v38 = (char *)(v10 + 17);
              v39 = (const char *)(a4 + 5);
LABEL_72:
              strlcpy(v38, v39, v37);
              return v10;
            case 6:
              *((_DWORD *)v10 + 4) = *(_DWORD *)a4;
              return v10;
            case 7:
              *((_DWORD *)v10 + 4) = *(_DWORD *)a4;
              LODWORD(v47) = a4[11];
              v49 = a4[2];
              v48 = a4 + 2;
              v44 = (char *)(v10 + 10);
              if (v49 == 6)
                v47 = (v47 >> 8) + v47;
              else
                v47 = v47;
              v43 = v47 + 20;
              v45 = v48;
              goto LABEL_87;
            case 8:
              *((_QWORD *)v10 + 2) = *(_QWORD *)(a2 + 8);
              v50 = *(_QWORD *)a4;
              *((_QWORD *)v10 + 5) = *(_QWORD *)a4 & 0xFFFFFFFFFFFFFFLL;
              *(_OWORD *)(v10 + 12) = *(_OWORD *)(a4 + 4);
              *((_BYTE *)v10 + 48) = HIBYTE(v50);
              return v10;
            case 9:
              if ((*(_BYTE *)(*(_QWORD *)(a1 + 376) + 56) & 9) != 0)
              {
                v51 = *(_DWORD *)(a2 + 8);
                *((_DWORD *)v10 + 14) = v51 >> 10;
                v10[31] = v51 & 0x3FF;
                v52 = (char *)*((_QWORD *)v10 + 8);
                v53 = (const char *)(a2 + 12);
                v54 = v51 & 0x3FF;
              }
              else
              {
                *((_DWORD *)v10 + 14) = 0;
                v54 = *(unsigned __int16 *)(a2 + 8);
                v10[31] = v54;
                v52 = (char *)*((_QWORD *)v10 + 8);
                v53 = (const char *)(a2 + 10);
              }
              strlcpy(v52, v53, v54);
              *((_QWORD *)v10 + 2) = *(_QWORD *)a4;
              *((_QWORD *)v10 + 3) = *((_QWORD *)a4 + 1);
              v10[30] = a4[8];
              v59 = v10 + 16;
              if (a5 < 0x13)
              {
                xf_init((uint64_t)v59, 0);
              }
              else if (xf_init_with_blob(v59, a4 + 9, a5 - 18))
              {
                log_debug("%s:%d: failed to init extended fields on drec %lld from blob.\n");
              }
              return v10;
            case 10:
              *(_OWORD *)(v10 + 12) = *(_OWORD *)a4;
              *((int8x16_t *)v10 + 3) = vextq_s8(*((int8x16_t *)a4 + 1), *((int8x16_t *)a4 + 1), 8uLL);
              return v10;
            case 11:
              v55 = *(unsigned __int16 *)(a2 + 8);
              v10[12] = v55;
              strlcpy((char *)v10 + 26, (const char *)(a2 + 10), v55);
              goto LABEL_83;
            case 12:
LABEL_83:
              *((_QWORD *)v10 + 2) = *(_QWORD *)a4;
              return v10;
            case 13:
              v56 = *(_QWORD *)(a2 + 8);
              *((_BYTE *)v10 + 16) = HIBYTE(v56);
              *((_QWORD *)&v57 + 1) = *(_QWORD *)(a2 + 8);
              *(_QWORD *)&v57 = v56;
              *((_QWORD *)v10 + 2) = v57 >> 56;
              if (HIBYTE(v56) == 2)
              {
                *((_QWORD *)v10 + 3) = *(_QWORD *)a4;
                *((_QWORD *)v10 + 4) = *((_QWORD *)a4 + 1);
                *((_QWORD *)v10 + 5) = *((_QWORD *)a4 + 2);
                v10[24] = a4[12];
                if (a5 < 0x1B)
                {
                  log_err("%s:%d: %s s_hash <%llu> finfo attribution tag value <%zu> is less than sizeof(j_file_attribution_tag_val_t) <%lu\n");
                  return v10;
                }
                v60 = xf_init_with_blob(v10 + 28, a4 + 13, a5 - 26);
                if (v60)
                {
                  strerror(v60);
                  log_debug("%s:%d: failed to init extended fields on attribution tag record with objid <%lld> from blob due to error <%d> %s\n");
                  return v10;
                }
                v65 = v10[28];
                if (v10[28])
                {
                  v66 = 0;
                  for (i = (unsigned __int16 *)(*((_QWORD *)v10 + 8) + 2); ; i += 2)
                  {
                    v68 = *i;
                    if (*((_BYTE *)i - 2) == 1)
                      break;
                    v66 += (v68 + 7) & 0x1FFF8;
                    if (!--v65)
                      return v10;
                  }
                  if ((__int16)*i <= 0)
                    log_err("%s:%d: %s size (%d) of FILE_INFO_TAG_EXT_TYPE_SIGNING_ID in attribution tag record with s_hash <%llu> <= 0 \n");
                  else
                    *(_BYTE *)(*((_QWORD *)v10 + 9) + v66 + v68 - 1) = 0;
                }
              }
              else if (HIBYTE(v56) == 1)
              {
                v10[12] = *a4;
                v43 = *((unsigned __int8 *)a4 + 2);
                *((_BYTE *)v10 + 26) = v43;
                v44 = (char *)v10 + 27;
                v45 = (unsigned __int16 *)((char *)a4 + 3);
LABEL_87:
                memcpy(v44, v45, v43);
              }
              return v10;
            case 14:
              if (a3 < 0xC)
                goto LABEL_91;
              if (large_key_val_to_jobj(a1, (uint64_t)v10, a2, (uint64_t *)a4, a5))
                return v10;
              v36 = *((_QWORD *)v10 + 1);
LABEL_91:
              v58 = log_err("%s:%d: %s cannot translate key-val (%llu) into valid jobj\n", "key_val_to_jobj", 4926, (const char *)(a1 + 3880), v36);
              jobj_release((uint64_t)v58, (unsigned __int8 *)v10);
              return 0;
            default:
              return v10;
          }
          break;
        case 16:
LABEL_58:
          v29 = 80;
          goto LABEL_62;
        case 17:
          v29 = 32;
          goto LABEL_62;
        case 19:
          v29 = 72;
LABEL_62:
          v28 = (unsigned __int16 *)_apfs_calloc(1uLL, v29);
          goto LABEL_63;
        default:
          log_err("%s:%d: *** Can't allocate unknown obj type %d\n");
          return 0;
      }
      break;
    default:
      log_err("%s:%d: *** unknown obj type %d\n");
      return 0;
  }
  while (1)
  {
    v64 = (unsigned __int16)*v63;
    if (*((_BYTE *)v63 - 2) == 4)
    {
      if (*v63)
        break;
    }
    v63 += 2;
    v62 += (v64 + 7) & 0x1FFF8;
    if (!--v61)
      return v10;
  }
  *(_BYTE *)(*((_QWORD *)v10 + 53) + v62 + v64 - 1) = 0;
  return v10;
}

uint64_t large_key_val_to_jobj(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unint64_t a5)
{
  unsigned int v5;
  uint64_t v6;
  unsigned __int16 *v7;
  uint64_t v8;

  v5 = *(unsigned __int8 *)(a3 + 8);
  if (v5 > 0xF)
  {
    v6 = a2;
    *(_BYTE *)a2 = v5;
    switch(v5)
    {
      case 0x10u:
        *(_OWORD *)(a2 + 16) = *(_OWORD *)(a3 + 12);
        *(_QWORD *)(a2 + 32) = *a4;
        *(_QWORD *)(a2 + 40) = a4[1];
        *(_DWORD *)(a2 + 48) = *((_DWORD *)a4 + 4);
        *(_DWORD *)(a2 + 52) = *((_DWORD *)a4 + 5);
        v7 = (unsigned __int16 *)(a2 + 56);
        if (a5 < 0x19)
          goto LABEL_15;
        if (xf_init_with_blob(v7, (unsigned __int16 *)a4 + 12, a5 - 24))
          log_err("%s:%d: %s failed to init extended fields on purgeable %llu from blob\n");
        break;
      case 0x11u:
        v8 = *a4;
        *(_QWORD *)(a2 + 16) = *(_QWORD *)(a3 + 12);
        *(_QWORD *)(a2 + 24) = v8;
        break;
      case 0x12u:
        *(_QWORD *)(a2 + 16) = a4[3];
        *(_QWORD *)(a2 + 24) = *a4;
        *(_QWORD *)(a2 + 32) = a4[1];
        *(_QWORD *)(a2 + 40) = a4[2];
        *(_QWORD *)(a2 + 56) = a4[4];
        *(_QWORD *)(a2 + 48) = a4[5];
        *(_DWORD *)(a2 + 92) = *((_DWORD *)a4 + 12);
        v7 = (unsigned __int16 *)(a2 + 64);
        if (a5 < 0x35)
          goto LABEL_15;
        if (xf_init_with_blob(v7, (unsigned __int16 *)a4 + 26, a5 - 52))
          log_err("%s:%d: %s failed to init extended fields on dir-stats %llu from blob\n");
        break;
      case 0x13u:
        *(_OWORD *)(a2 + 16) = *(_OWORD *)(a3 + 12);
        *(_QWORD *)(a2 + 32) = *a4 & 0xFFFFFFFFFFFFFFLL;
        *(_DWORD *)(a2 + 40) = *((unsigned __int8 *)a4 + 7);
        v7 = (unsigned __int16 *)(a2 + 48);
        if (a5 < 9)
        {
LABEL_15:
          xf_init((uint64_t)v7, 0);
        }
        else if (xf_init_with_blob(v7, (unsigned __int16 *)a4 + 4, a5 - 8))
        {
          log_err("%s:%d: %s failed to init extended fields on clone mapping <%llu/%llu> from blob\n");
        }
        break;
      default:
        return v6;
    }
  }
  else
  {
    log_err("%s:%d: %s unknown expanded type (%hhu) on record (%u)\n", "large_key_val_to_jobj", 4497, (const char *)(a1 + 3880), *(unsigned __int8 *)(a3 + 8), *(_QWORD *)a3 >> 60);
    return 0;
  }
  return v6;
}

uint64_t lookup_jobj(uint64_t a1, int a2, uint64_t *a3, unsigned __int8 *a4, unsigned __int16 **a5)
{
  return lookup_jobj_in_snap(a1, a2, a3, a4, *(_QWORD *)(a1 + 432), a5);
}

uint64_t lookup_jobj_in_snap(uint64_t a1, int a2, uint64_t *a3, unsigned __int8 *a4, uint64_t a5, unsigned __int16 **a6)
{
  int matched;
  void *v12;
  uint64_t v13;
  uint64_t tree_in_snap;
  uint64_t v15;
  uint64_t *v17;
  unsigned int v18;
  unsigned int v19;

  matched = match_jobj_type_to_tree_type(a1, *a4, a2);
  v12 = _apfs_zalloc(3u);
  if (!v12)
    return 12;
  v13 = (uint64_t)v12;
  v18 = 832;
  v19 = 3808;
  make_jkey_from_jobj(a1, a4, (uint64_t)v12, (int *)&v18);
  v17 = 0;
  tree_in_snap = jfs_get_tree_in_snap(a1, matched, 0, a5, (uint64_t *)&v17);
  if ((_DWORD)tree_in_snap)
  {
    v15 = tree_in_snap;
LABEL_6:
    _apfs_zfree((void *)v13, 3u);
    return v15;
  }
  v15 = bt_lookup_variant((uint64_t)v17, a5, (unint64_t *)v13, &v18, 0x340u, (void *)(v13 + 832), &v19, 0, 0, a3);
  obj_release(v17);
  if ((_DWORD)v15)
    goto LABEL_6;
  *a6 = key_val_to_jobj(a1, v13, v18, (unsigned __int16 *)(v13 + 832), v19);
  _apfs_zfree((void *)v13, 3u);
  if (*a6)
    return 0;
  else
    return nx_corruption_detected_int(*(_QWORD *)(a1 + 392));
}

uint64_t initialize_phys_range_lock_state(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  void *v5;
  size_t v6;
  void *v7;
  void *v8;
  void *v10;
  uint64_t v11;

  *(_QWORD *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  v4 = a2;
  *(_DWORD *)(a1 + 92) = a2;
  v5 = _apfs_calloc(a2, 0x10uLL);
  *(_QWORD *)a1 = v5;
  if (v5)
  {
    v6 = (a2 + 63) >> 6;
    *(_DWORD *)(a1 + 88) = v6;
    v7 = _apfs_calloc(v6, 8uLL);
    *(_QWORD *)(a1 + 72) = v7;
    if (v7)
    {
      v8 = _apfs_calloc(*(unsigned int *)(a1 + 88), 8uLL);
      *(_QWORD *)(a1 + 80) = v8;
      if (v8)
      {
        new_lock((pthread_mutex_t *)(a1 + 8));
        return 0;
      }
      _apfs_free(*(void **)a1, 16 * v4);
      v10 = *(void **)(a1 + 72);
      v11 = 8 * *(unsigned int *)(a1 + 88);
    }
    else
    {
      v10 = *(void **)a1;
      v11 = 16 * v4;
    }
    _apfs_free(v10, v11);
  }
  return 12;
}

uint64_t release_phys_range_lock_state(uint64_t a1)
{
  _apfs_free(*(void **)a1, 16 * *(unsigned int *)(a1 + 92));
  _apfs_free(*(void **)(a1 + 72), 8 * *(unsigned int *)(a1 + 88));
  _apfs_free(*(void **)(a1 + 80), 8 * *(unsigned int *)(a1 + 88));
  return free_lock((pthread_mutex_t *)(a1 + 8));
}

uint64_t apfs_cstrncmp(unsigned __int8 *a1, unsigned __int8 *a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  int v6;
  uint64_t v7;
  BOOL v8;

  if (a3 >= a4)
    v4 = a4;
  else
    v4 = a3;
  v5 = v4 - 2;
  if (v4 < 2)
  {
LABEL_11:
    if (a3 < a4)
      LODWORD(v7) = -1;
    else
      LODWORD(v7) = 1;
    if (a3 == a4)
      return 0;
    else
      return v7;
  }
  else
  {
    while (1)
    {
      v6 = *a1;
      v7 = v6 - *a2;
      if ((_DWORD)v7)
        break;
      ++a1;
      ++a2;
      if (v6)
        v8 = v5 == 0;
      else
        v8 = 1;
      --v5;
      if (v8)
        goto LABEL_11;
    }
  }
  return v7;
}

uint64_t apfs_check_for_spillover()
{
  return 0;
}

void fs_sb_dirty(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  if ((*(_BYTE *)(a1 + 476) & 4) != 0)
  {
    v4 = *(_QWORD *)(a1 + 376);
    if ((*(_BYTE *)(v4 + 264) & 4) == 0)
    {
      v5 = (unint64_t *)(v4 + 264);
      do
        v6 = __ldxr(v5);
      while (__stxr(v6 | 4, v5));
    }
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1272));
    *(_QWORD *)(a1 + 472) &= ~0x400000000uLL;
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1272));
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 376) + 1056) = a2;
  if (apfs_doc_id_index_supported(a1))
    *(_DWORD *)(*(_QWORD *)(a1 + 376) + 1064) |= 0x10u;
  obj_dirty(a1, a2, 0);
}

uint64_t evict_mapping_key_compare(uint64_t a1, _QWORD *a2, uint64_t a3, _QWORD *a4, uint64_t a5, int *a6)
{
  int v6;

  v6 = *a2 > *a4;
  if (*a2 < *a4)
    v6 = -1;
  *a6 = v6;
  return 0;
}

uint64_t apfs_free_data_blocks(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  unint64_t *v11;
  unint64_t v12;

  if (*(_QWORD *)(a1 + 496))
    v7 = *(_QWORD *)(a1 + 496);
  else
    v7 = a1;
  v8 = spaceman_free((const char *)v7, 0, a3, a4, a2);
  v9 = v8;
  if ((_DWORD)v8)
  {
    v10 = strerror(v8);
    log_err("%s:%d: %s spaceman_free failed for LBA %llx, size %llu : %d %s\n", "apfs_free_data_blocks", 32000, (const char *)(v7 + 3880), a3, a4, v9, v10);
  }
  else
  {
    v11 = (unint64_t *)(*(_QWORD *)(v7 + 376) + 232);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + a4, v11));
    fs_sb_dirty(v7, a2);
  }
  return v9;
}

BOOL fs_is_fully_unencrypted(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 496);
  if (!v1)
    v1 = a1;
  return (*(_BYTE *)(*(_QWORD *)(v1 + 376) + 264) & 1) != 0 && *(_QWORD *)(*(_QWORD *)(a1 + 376) + 976) == 0;
}

uint64_t xf_init(uint64_t a1, uint64_t a2)
{
  __int16 v2;
  void *v4;
  void *v5;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  if (a2)
  {
    v2 = a2;
    *(_WORD *)(a1 + 2) = 4;
    v4 = _apfs_malloc(0x10uLL);
    *(_QWORD *)(a1 + 8) = v4;
    if (!v4)
      *(_WORD *)(a1 + 2) = 0;
    *(_WORD *)(a1 + 6) = (v2 + 7) & 0xFFF8;
    v5 = _apfs_malloc((unsigned __int16)(v2 + 7) & 0xFFF8);
    *(_QWORD *)(a1 + 16) = v5;
    if (!v5)
      *(_WORD *)(a1 + 6) = 0;
  }
  return 0;
}

uint64_t xf_init_with_blob(unsigned __int16 *a1, unsigned __int16 *a2, unint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned __int16 *v9;
  uint64_t v10;
  signed int v11;
  unsigned int v12;
  uint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;

  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = 0;
  if (a3 < 4)
    return 28;
  v6 = *a2;
  *a1 = v6;
  v7 = a2[1];
  a1[2] = v7;
  a1[1] = v6;
  if (v7 + 4 * v6 + 4 > a3)
    goto LABEL_10;
  if ((_DWORD)v6)
  {
    v8 = 0;
    v9 = a2 + 3;
    v10 = v6;
    while (v7 > v8)
    {
      v11 = *v9;
      if ((int)(v7 - v8) < v11)
        break;
      v8 += (v11 + 7) & 0x1FFF8;
      v9 += 2;
      if (!--v10)
        goto LABEL_9;
    }
    goto LABEL_10;
  }
LABEL_9:
  v12 = ((_WORD)v7 + 7) & 0xFFF8;
  a1[3] = v12;
  if (v12 < v7)
  {
LABEL_10:
    result = 22;
LABEL_11:
    *(_QWORD *)a1 = 0;
    *((_QWORD *)a1 + 1) = 0;
    *((_QWORD *)a1 + 2) = 0;
    return result;
  }
  v13 = 2 * v6;
  *((_QWORD *)a1 + 1) = _apfs_malloc(4 * v6);
  v14 = _apfs_malloc(a1[3]);
  *((_QWORD *)a1 + 2) = v14;
  v15 = (void *)*((_QWORD *)a1 + 1);
  v16 = *a1;
  if (!v15 || !v14)
  {
    _apfs_free(v15, 4 * v16);
    _apfs_free(*((void **)a1 + 2), a1[3]);
    result = 12;
    goto LABEL_11;
  }
  memcpy(v15, a2 + 2, 4 * v16);
  memcpy(*((void **)a1 + 2), &a2[v13 + 2], a1[2]);
  bzero((void *)(*((_QWORD *)a1 + 2) + a1[2]), a1[3] - (unint64_t)a1[2]);
  return 0;
}

uint64_t xf_get_from_blob(unsigned __int16 *a1, unint64_t a2, int a3, _DWORD *a4, _QWORD *a5, _DWORD *a6)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  unsigned __int16 *i;
  int v12;

  if (a2 < 4)
    return 28;
  v7 = *a1;
  v8 = a1[1];
  if (v8 + 4 * v7 + 4 > a2)
    return 22;
  if (*a1)
  {
    v9 = 0;
    v10 = (uint64_t)&a1[2 * v7 + 2];
    for (i = a1 + 3; ; i += 2)
    {
      v12 = *i;
      if (v9 + v12 > v8)
        break;
      if (*((unsigned __int8 *)i - 2) == a3)
      {
        if (a4)
          *a4 = *((unsigned __int8 *)i - 1);
        if (a6)
          *a6 = v12;
        result = 0;
        *a5 = v10 + v9;
        return result;
      }
      v9 += (v12 + 7) & 0x1FFF8;
      if (!--v7)
        return 2;
    }
    return 22;
  }
  return 2;
}

uint64_t xf_release(uint64_t a1)
{
  _apfs_free(*(void **)(a1 + 8), 4 * *(unsigned __int16 *)(a1 + 2));
  _apfs_free(*(void **)(a1 + 16), *(unsigned __int16 *)(a1 + 6));
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  return 0;
}

uint64_t new_lock(pthread_mutex_t *a1)
{
  return pthread_mutex_init(a1, 0);
}

uint64_t new_rwlock(pthread_rwlock_t *a1)
{
  return pthread_rwlock_init(a1, 0);
}

uint64_t new_cv(pthread_cond_t *a1)
{
  return pthread_cond_init(a1, 0);
}

pthread_cond_t *free_cv(pthread_cond_t *result)
{
  if (result)
    return (pthread_cond_t *)pthread_cond_destroy(result);
  return result;
}

uint64_t cv_wait(pthread_cond_t *a1, pthread_mutex_t *a2, uint64_t a3, uint64_t a4, timespec *a5)
{
  BOOL v8;
  __darwin_time_t v9;
  uint64_t result;
  uint64_t tv_nsec;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  timespec v15;

  if (!a5)
    return pthread_cond_wait(a1, a2);
  v15.tv_sec = 0;
  v15.tv_nsec = 0;
  clock_gettime(_CLOCK_REALTIME, &v15);
  v8 = __OFADD__(a5->tv_sec, v15.tv_sec);
  v9 = a5->tv_sec + v15.tv_sec;
  a5->tv_sec = v9;
  if (v8)
    return 35;
  tv_nsec = a5->tv_nsec;
  v8 = __OFADD__(tv_nsec, v15.tv_nsec);
  v12 = tv_nsec + v15.tv_nsec;
  if (v8)
    v12 = 999999999;
  a5->tv_nsec = v12;
  if (v12 > 0x3B9ACA00)
  {
    v13 = v12 - 1000000000;
    v14 = (v13 - 1) / 0x3B9ACA00;
    a5->tv_sec = v9 + v14 + 1;
    a5->tv_nsec = v13 - 1000000000 * v14;
  }
  LODWORD(result) = pthread_cond_timedwait(a1, a2, a5);
  if ((_DWORD)result == 60)
    return 35;
  else
    return result;
}

uint64_t cv_wait_rw(pthread_cond_t *a1, pthread_mutex_t *a2, uint64_t a3, timespec *a4)
{
  return cv_wait(a1, a2, a3, (uint64_t)a4, a4);
}

uint64_t btree_node_space_stats(_QWORD *a1, _DWORD *a2, _DWORD *a3, int *a4)
{
  unsigned __int16 *v5;
  BOOL v6;
  int v7;
  uint64_t v11;
  const char *v12;
  uint64_t result;
  uint64_t v14;

  v5 = (unsigned __int16 *)a1[7];
  *a2 = (a1[50] >> 27) & 0x1F000;
  LODWORD(v5) = v5[25] + v5[23] + v5[27];
  *a3 = (_DWORD)v5;
  v6 = *a2 >= v5;
  v7 = *a2 - (_DWORD)v5;
  if (v6)
  {
    result = 0;
  }
  else
  {
    v11 = a1[1];
    if (v11)
      v12 = (const char *)(v11 + 3880);
    else
      v12 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 384) + 208);
    v14 = obj_oid((uint64_t)a1);
    log_err("%s:%d: %s oid 0x%llx (level %d): freespace %u larger than nodespace %u\n", "btree_node_space_stats", 52, v12, v14, *(unsigned __int16 *)(a1[7] + 34), *a3, *a2);
    v7 = 0;
    result = 22;
  }
  *a4 = v7;
  return result;
}

uint64_t btree_node_debug_stats(uint64_t a1, _QWORD *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  unsigned int v26;
  _DWORD *v27;
  unsigned int v28;
  _DWORD *v29;
  unsigned int v31;
  int v32;
  unsigned int v33;

  v7 = a2[7];
  if ((*(_WORD *)(v7 + 32) & 2) != 0)
  {
    ++*(_DWORD *)(a4 + 4);
    *(_DWORD *)(a4 + 16) += *(_DWORD *)(v7 + 36);
  }
  else
  {
    ++*(_DWORD *)a4;
    *(_DWORD *)(a4 + 12) += *(_DWORD *)(v7 + 36);
  }
  if (*(_DWORD *)(a4 + 8) < a3)
    *(_DWORD *)(a4 + 8) = a3;
  v8 = *(unsigned __int16 *)(v7 + 34);
  if (v8 <= 0xF)
    ++*(_DWORD *)(a4 + 4 * v8 + 216);
  v9 = btree_node_sanity_check(a2, 0);
  if (!(_DWORD)v9)
  {
    v33 = 0;
    v31 = 0;
    v32 = 0;
    v9 = btree_node_space_stats(a2, &v33, &v32, (int *)&v31);
    v10 = v31;
    v11 = v33;
    v12 = 5 * v31 / v33;
    ++*(_DWORD *)(a4 + 4 * v12 + 20);
    v13 = *(_QWORD *)(a4 + 56) + v10;
    *(_QWORD *)(a4 + 48) += v11;
    *(_QWORD *)(a4 + 56) = v13;
    if ((*(_BYTE *)(a2[7] + 32) & 2) != 0)
    {
      ++*(_DWORD *)(a4 + 4 * v12 + 104);
      v15 = *(_QWORD *)(a4 + 136);
      *(_QWORD *)(a4 + 128) += v11;
      *(_QWORD *)(a4 + 136) = v15 + v10;
      if (*(_DWORD *)(v7 + 36))
      {
        v16 = 0;
        do
        {
          v17 = btree_node_key_len((uint64_t)a2, (unsigned __int16)v16);
          v18 = btree_node_val_len((uint64_t)a2, (unsigned __int16)v16);
          v19 = *(_QWORD *)(a1 + 392);
          if (*(_DWORD *)(v19 + 16) < v17)
          {
            if ((_DWORD)v9)
              v9 = v9;
            else
              v9 = 22;
            v20 = a2[1];
            if (v20)
              v21 = (const char *)(v20 + 3880);
            else
              v21 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a2 + 392) + 384) + 208);
            v22 = obj_oid((uint64_t)a2);
            log_err("%s:%d: %s oid 0x%llx (level %d): index %d key length %d longer than tree longest %d\n", "btree_node_debug_stats", 110, v21, v22, *(unsigned __int16 *)(a2[7] + 34), v16, v17, *(_DWORD *)(*(_QWORD *)(a1 + 392) + 16));
            v19 = *(_QWORD *)(a1 + 392);
            v17 = *(unsigned __int16 *)(v19 + 16);
          }
          if (v18 == 65534
            || *(_DWORD *)(v19 + 20) < v18
            && ((_DWORD)v9 ? (v9 = v9) : (v9 = 22),
                (v23 = a2[1]) == 0
              ? (v24 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a2 + 392) + 384) + 208))
              : (v24 = (const char *)(v23 + 3880)),
                v25 = obj_oid((uint64_t)a2),
                log_err("%s:%d: %s oid 0x%llx (level %d): index %d val length %d longer than tree longest %d\n", "btree_node_debug_stats", 115, v24, v25, *(unsigned __int16 *)(a2[7] + 34), v16, v18, *(_DWORD *)(*(_QWORD *)(a1 + 392) + 20)), v19 = *(_QWORD *)(a1 + 392), v18 = (unsigned __int16)*(_DWORD *)(v19 + 20), v18 == 65534))
          {
            v18 = 0;
          }
          if (*(_DWORD *)(a4 + 208) < v17)
            *(_DWORD *)(a4 + 208) = v17;
          if (*(_DWORD *)(a4 + 212) < v18)
            *(_DWORD *)(a4 + 212) = v18;
          *(_QWORD *)(a4 + 144) += v17;
          v26 = *(_DWORD *)(v19 + 16);
          v27 = (_DWORD *)(a4 + 180);
          if (v26)
            v27 = (_DWORD *)(a4 + 4 * (5 * v17 / v26) + 160);
          ++*v27;
          *(_QWORD *)(a4 + 152) += v18;
          v28 = *(_DWORD *)(v19 + 20);
          v29 = (_DWORD *)(a4 + 204);
          if (v28)
            v29 = (_DWORD *)(a4 + 4 * (5 * v18 / v28) + 184);
          ++*v29;
          ++v16;
        }
        while (v16 < *(_DWORD *)(v7 + 36));
      }
    }
    else
    {
      ++*(_DWORD *)(a4 + 4 * v12 + 64);
      v14 = *(_QWORD *)(a4 + 96) + v10;
      *(_QWORD *)(a4 + 88) += v11;
      *(_QWORD *)(a4 + 96) = v14;
    }
  }
  return v9;
}

uint64_t btree_node_check(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned int a4, _QWORD *a5, unsigned int a6, uint64_t a7, int a8, uint64_t a9, char a10, unsigned __int8 a11)
{
  uint64_t v12;
  unsigned int v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  __int16 v42;
  unsigned __int16 v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  const char *v48;
  uint64_t v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  const char *v61;
  uint64_t v62;
  unsigned int v63;
  uint64_t v64;
  const char *v65;
  uint64_t v66;
  unsigned int v67;
  unsigned int v68;
  uint64_t v69;
  const char *v70;
  uint64_t v71;
  uint64_t v72;
  const char *v73;
  uint64_t v74;
  uint64_t v75;
  const char *v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  const char *v80;
  int v81;
  unsigned int v82;
  unsigned int i;
  unsigned int v84;
  int v85;
  uint64_t v86;
  const char *v87;
  uint64_t v88;
  unsigned int v89;
  int v90;
  uint64_t v91;
  const char *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  const char *v96;
  uint64_t v97;
  uint64_t v98;
  const char *v99;
  uint64_t v100;
  int v101;
  int v102;
  uint64_t v103;
  const char *v104;
  uint64_t v105;
  uint64_t v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  _QWORD *v112;
  size_t v113;
  __int16 v114;
  unsigned int v115;
  int v116;
  int v117;
  uint64_t v118;
  const char *v119;
  uint64_t v120;
  uint64_t v121;
  int v122;
  uint64_t v123;
  BOOL v124;
  unsigned int v125;
  BOOL v126;
  uint64_t v127;
  const char *v128;
  uint64_t v129;
  uint64_t v130;
  int v131;
  unint64_t v132;
  uint64_t v133;
  const char *v134;
  uint64_t v135;
  uint64_t v136;
  const char *v137;
  uint64_t v138;
  unsigned int v139;
  uint64_t v140;
  const char *v141;
  int v142;
  uint64_t v143;
  const char *v144;
  uint64_t v145;
  void *v146;
  void *v147;
  unsigned __int16 v148;
  int v149;
  void *v150;
  uint64_t v151;
  unsigned __int16 *v152;
  uint64_t v153;
  unsigned int v154;
  uint64_t v155;
  const char *v156;
  uint64_t v157;
  uint64_t v158;
  const char *v159;
  uint64_t v160;
  uint64_t v161;
  unsigned __int16 v162;
  int v163;
  unsigned int v164;
  uint64_t v165;
  const char *v166;
  uint64_t v167;
  unsigned __int16 *v168;
  unint64_t v169;
  unsigned int v170;
  uint64_t v171;
  const char *v172;
  uint64_t v173;
  uint64_t v174;
  const char *v175;
  uint64_t v176;
  const char *v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  const char *v181;
  uint64_t v182;
  uint64_t v183;
  __int16 v184;
  uint64_t v185;
  uint64_t v186;
  unint64_t v187;
  unsigned __int16 *v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  __int16 v192;
  uint64_t v193;
  const char *v194;
  uint64_t v195;
  uint64_t v196;
  const char *v197;
  uint64_t v198;
  uint64_t v199;
  const char *v200;
  uint64_t v201;
  uint64_t v202;
  const char *v203;
  uint64_t v204;
  uint64_t v205;
  const char *v206;
  uint64_t v207;
  uint64_t v208;
  __int16 v209;
  uint64_t v210;
  const char *v211;
  uint64_t v212;
  uint64_t v213;
  const char *v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  const char *v218;
  uint64_t v219;
  uint64_t v220;
  const char *v221;
  uint64_t v222;
  uint64_t v223;
  unint64_t v224;
  uint64_t v225;
  unint64_t v226;
  unsigned __int16 *v227;
  uint64_t v228;
  __int16 v229;
  uint64_t v230;
  const char *v231;
  uint64_t v232;
  uint64_t v233;
  const char *v234;
  uint64_t v235;
  uint64_t v236;
  const char *v237;
  uint64_t v238;
  uint64_t v239;
  const char *v240;
  uint64_t v241;
  uint64_t v242;
  const char *v243;
  uint64_t v244;
  uint64_t v245;
  __int16 v246;
  uint64_t v247;
  const char *v248;
  uint64_t v249;
  uint64_t v250;
  const char *v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  const char *v255;
  uint64_t v256;
  uint64_t v257;
  const char *v258;
  uint64_t v259;
  uint64_t v260;
  _BYTE v261[12];
  unsigned int v262;
  uint64_t v263;
  unint64_t v264;
  int v265;
  size_t v266;
  void *v267;
  unint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  int v272;
  int v273;
  uint64_t v274;
  unsigned int v275;
  uint64_t v276;
  unsigned int v277;
  uint64_t v278;
  _BYTE *v279;
  __int16 v280;
  uint64_t v281;
  uint64_t *v282;
  int v283;
  int v284;
  uint64_t v285;
  _QWORD v286[3];

  v286[1] = *MEMORY[0x1E0C80C00];
  if (!a5 || (v12 = a5[7]) == 0)
  {
    v19 = a5[1];
    if (v19)
      v20 = (const char *)(v19 + 3880);
    else
      v20 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    log_err("%s:%d: %s btree_node is null\n", "btree_node_check", 152, v20);
    return 22;
  }
  v15 = a6;
  v277 = a4;
  v279 = (_BYTE *)a3;
  v276 = a2;
  v17 = a5[1];
  if (!v17)
    v17 = *(_QWORD *)(*a5 + 392);
  v278 = v17;
  if (a9)
  {
    v18 = btree_node_debug_stats((uint64_t)a1, a5, a6, a9);
    if ((_DWORD)v18)
      return v18;
  }
  if (!a1 && (a5[4] & 1) == 0)
    return 0;
  v274 = a9;
  v273 = a11;
  v275 = v15;
  if ((a11 & 1) != 0)
  {
LABEL_17:
    v285 = 0;
    v286[0] = 0;
    v283 = 0;
    v284 = 0;
    v22 = a5[7];
    v23 = (uint64_t)v279;
    v24 = v277;
    if (v279 && *(_DWORD *)(v22 + 36))
    {
      v25 = btree_node_key_ptr((uint64_t)v279, v277, v286, (_WORD *)&v284 + 1);
      if ((_DWORD)v25)
      {
        v18 = v25;
        obj_oid((uint64_t)v279);
LABEL_249:
        log_err("%s:%d: %s oid 0x%llx (level %d): can't get key %d: %d\n");
        return v18;
      }
      v33 = btree_node_key_ptr((uint64_t)a5, 0, &v285, &v284);
      if ((_DWORD)v33)
      {
        v18 = v33;
        obj_oid((uint64_t)a5);
        goto LABEL_249;
      }
      v54 = ((uint64_t (*)(uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, int *))a5[52])(v278, v286[0], HIWORD(v284), v285, (unsigned __int16)v284, &v283);
      if ((_DWORD)v54)
      {
        v18 = v54;
        obj_oid((uint64_t)a5);
        log_err("%s:%d: %s oid 0x%llx (level %d): minkey compare error: %d\n");
        return v18;
      }
      if (v283 >= 1)
      {
        obj_oid((uint64_t)a5);
        log_err("%s:%d: %s oid 0x%llx (level %d): minkey not correct\n");
        return 22;
      }
      if (v283)
      {
        obj_oid((uint64_t)a5);
        log_err("%s:%d: %s oid 0x%llx (level %d): minkey not in sync\n");
        return 22;
      }
      v22 = a5[7];
      v23 = (uint64_t)v279;
      v24 = v277;
    }
    v82 = *(_DWORD *)(v22 + 36);
    if (v82 >= 2)
    {
      v271 = a7;
      v272 = a8;
      v18 = 0;
      for (i = 1; i < v82; ++i)
      {
        if (btree_node_key_off((uint64_t)a5, (unsigned __int16)(i - 1)) != 0xFFFF
          && btree_node_key_off((uint64_t)a5, (unsigned __int16)i) != 0xFFFF)
        {
          v84 = btree_node_key_ptr((uint64_t)a5, (unsigned __int16)(i - 1), v286, (_WORD *)&v284 + 1);
          if (v84)
          {
            v85 = v84;
            if ((_DWORD)v18)
              v18 = v18;
            else
              v18 = v84;
            v86 = a5[1];
            if (v86)
              v87 = (const char *)(v86 + 3880);
            else
              v87 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
            v88 = obj_oid((uint64_t)a5);
            log_err("%s:%d: %s oid 0x%llx (level %d): can't get key %d: %d\n", "btree_node_check", 536, v87, v88, *(unsigned __int16 *)(a5[7] + 34), i - 1, v85);
          }
          else
          {
            v89 = btree_node_key_ptr((uint64_t)a5, (unsigned __int16)i, &v285, &v284);
            if (v89)
            {
              v90 = v89;
              if ((_DWORD)v18)
                v18 = v18;
              else
                v18 = v89;
              v91 = a5[1];
              if (v91)
                v92 = (const char *)(v91 + 3880);
              else
                v92 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
              v93 = obj_oid((uint64_t)a5);
              log_err("%s:%d: %s oid 0x%llx (level %d): can't get key %d: %d\n", "btree_node_check", 543, v92, v93, *(unsigned __int16 *)(a5[7] + 34), i, v90);
            }
          }
          if (!(_DWORD)v18)
          {
            v94 = ((uint64_t (*)(uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, int *))a5[52])(v278, v286[0], HIWORD(v284), v285, (unsigned __int16)v284, &v283);
            if ((_DWORD)v94)
            {
              v18 = v94;
              v95 = a5[1];
              if (v95)
                v96 = (const char *)(v95 + 3880);
              else
                v96 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
              v97 = obj_oid((uint64_t)a5);
              log_err("%s:%d: %s oid 0x%llx (level %d): key %d compare error: %d\n", "btree_node_check", 547, v96, v97, *(unsigned __int16 *)(a5[7] + 34), i, v18);
            }
            else if (v283 < 0)
            {
              v18 = 0;
            }
            else
            {
              v98 = a5[1];
              if (v98)
                v99 = (const char *)(v98 + 3880);
              else
                v99 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
              v100 = obj_oid((uint64_t)a5);
              log_err("%s:%d: %s oid 0x%llx (level %d): keys out of order: %d\n", "btree_node_check", 550, v99, v100, *(unsigned __int16 *)(a5[7] + 34), i);
              v18 = 22;
            }
          }
        }
        v82 = *(_DWORD *)(a5[7] + 36);
      }
      a8 = v272;
      a7 = v271;
      LOWORD(v15) = v275;
      if ((_DWORD)v18)
        return v18;
      v23 = (uint64_t)v279;
      v24 = v277;
    }
    if (!v23)
      goto LABEL_203;
    v101 = btree_node_key_ptr((uint64_t)a5, (unsigned __int16)(v82 - 1), v286, (_WORD *)&v284 + 1);
    if (v101)
    {
      v102 = v101;
      v103 = a5[1];
      if (v103)
        v104 = (const char *)(v103 + 3880);
      else
        v104 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
      v105 = obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): can't get key %d: %d\n", "btree_node_check", 559, v104, v105, *(unsigned __int16 *)(a5[7] + 34), *(_DWORD *)(a5[7] + 36) - 1, v102);
      return 22;
    }
    if (*(_DWORD *)(*(_QWORD *)(v23 + 56) + 36) - 1 <= v24)
    {
      v285 = a7;
      LOWORD(v284) = a8;
      v107 = a8;
      v108 = a7;
    }
    else
    {
      v106 = btree_node_key_ptr(v23, (unsigned __int16)(v24 + 1), &v285, &v284);
      if ((_DWORD)v106)
      {
        v18 = v106;
        obj_oid((uint64_t)v279);
        goto LABEL_249;
      }
      v108 = v285;
      v107 = (unsigned __int16)v284;
    }
    if (!v108 || !v107 || !HIWORD(v284))
      goto LABEL_203;
    v109 = ((uint64_t (*)(uint64_t, _QWORD))a5[52])(v278, v286[0]);
    if ((_DWORD)v109)
    {
      v18 = v109;
      obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): key %d compare error: %d\n");
      return v18;
    }
    if (v283 < 0)
    {
LABEL_203:
      if (a1)
      {
        v110 = a5[7];
        if ((*(_WORD *)(v110 + 32) & 2) != 0 || *(_DWORD *)(v110 + 36))
        {
          v18 = 0;
        }
        else
        {
          v127 = a5[1];
          if (v127)
            v128 = (const char *)(v127 + 3880);
          else
            v128 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
          v129 = obj_oid((uint64_t)a5);
          log_err("%s:%d: %s oid 0x%llx (level %d): non-leaf node has no children?\n", "btree_node_check", 595, v128, v129, *(unsigned __int16 *)(a5[7] + 34));
          v18 = 22;
        }
        if ((*(_WORD *)(a5[7] + 32) & 2) == 0 && (a10 & 1) == 0)
        {
          v279 = v261;
          MEMORY[0x1E0C80A78]();
          v112 = &v261[-v111];
          bzero(&v261[-v111], v113);
          if (*(_DWORD *)(a5[7] + 36))
          {
            v271 = a7;
            v272 = a8;
            v114 = v15;
            v115 = 0;
            LODWORD(v278) = (unsigned __int16)(v114 + 1);
            while (1)
            {
              if (btree_node_key_off((uint64_t)a5, (unsigned __int16)v115) != 0xFFFF
                && btree_node_val_off((uint64_t)a5, (unsigned __int16)v115) != 0xFFFF)
              {
                v116 = btree_node_child_val((uint64_t)a5, (unsigned __int16)v115, v112);
                if (v116)
                {
                  v117 = v116;
                  if ((_DWORD)v18)
                    v18 = v18;
                  else
                    v18 = 22;
                  v118 = a5[1];
                  if (v118)
                    v119 = (const char *)(v118 + 3880);
                  else
                    v119 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
                  v120 = obj_oid((uint64_t)a5);
                  log_err("%s:%d: %s oid 0x%llx (level %d): can't get child %d oid: %d\n", "btree_node_check", 606, v119, v120, *(unsigned __int16 *)(a5[7] + 34), v115, v117);
                }
                else if (*v112)
                {
                  v281 = v271;
                  v282 = 0;
                  v280 = v272;
                  v121 = a5[7];
                  if (v115 < *(_DWORD *)(v121 + 36) - 1)
                  {
                    v122 = btree_node_key_ptr((uint64_t)a5, (unsigned __int16)(v115 + 1), &v281, &v280);
                    if (v122)
                    {
                      v142 = v122;
                      if ((_DWORD)v18)
                        v18 = v18;
                      else
                        v18 = 22;
                      v143 = a5[1];
                      if (v143)
                        v144 = (const char *)(v143 + 3880);
                      else
                        v144 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
                      v161 = obj_oid((uint64_t)a5);
                      log_err("%s:%d: %s oid 0x%llx (level %d): can't get key %d: %d\n", "btree_node_check", 625, v144, v161, *(unsigned __int16 *)(a5[7] + 34), v115 + 1, v142);
                      return v18;
                    }
                    v121 = a5[7];
                  }
                  v123 = v276;
                  if (btree_node_get(a1, v112, v276, 2, *(_WORD *)(v121 + 34) - 1, 0, (uint64_t *)&v282))
                    v124 = 1;
                  else
                    v124 = v282 == 0;
                  if (v124)
                  {
                    if ((_DWORD)v18)
                      v18 = v18;
                    else
                      v18 = 22;
                    obj_oid((uint64_t)a5);
                    log_err("%s:%d: %s oid 0x%llx (level %d): can't get child: 0x%llx\n");
                  }
                  else
                  {
                    v125 = btree_node_check(a1, v123, a5, (unsigned __int16)v115);
                    if ((_DWORD)v18)
                      v126 = 1;
                    else
                      v126 = v125 == 0;
                    if (v126)
                      v18 = v18;
                    else
                      v18 = v125;
                    obj_unlock((uint64_t)v282, 1);
                    obj_release(v282);
                  }
                }
                else
                {
                  if ((_DWORD)v18)
                    v18 = v18;
                  else
                    v18 = 22;
                  obj_oid((uint64_t)a5);
                  log_err("%s:%d: %s oid 0x%llx (level %d): invalid child oid: 0x%llx\n");
                }
              }
              if (++v115 >= *(_DWORD *)(a5[7] + 36))
                return v18;
            }
          }
        }
        return v18;
      }
      return 0;
    }
    obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): node's max key is not less than next sibling's entry in parent\n");
    return 22;
  }
  v18 = 0;
  if (v279 && (*(_WORD *)(v12 + 32) & 1) != 0)
  {
    v26 = a5[1];
    if (v26)
      v27 = (const char *)(v26 + 3880);
    else
      v27 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v28 = obj_oid((uint64_t)a5);
    v29 = *(unsigned __int16 *)(a5[7] + 34);
    v30 = obj_oid((uint64_t)v279);
    log_err("%s:%d: %s oid 0x%llx (level %d): root node has a parent 0x%llx (level %d)\n", "btree_node_check", 183, v27, v28, v29, v30, *(unsigned __int16 *)(*((_QWORD *)v279 + 7) + 34));
    v18 = 22;
    v15 = v275;
  }
  if ((*(_WORD *)(v12 + 32) & 2) != 0 && *(_WORD *)(v12 + 34))
  {
    v31 = a5[1];
    if (v31)
      v32 = (const char *)(v31 + 3880);
    else
      v32 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v34 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): leaf node has non-zero level\n", "btree_node_check", 186, v32, v34, *(unsigned __int16 *)(v12 + 34));
    v18 = 22;
  }
  if (a1)
  {
    if (*(unsigned __int16 *)(a5[7] + 34) > *(unsigned __int16 *)(a1[7] + 34))
    {
      if ((_DWORD)v18)
        v18 = v18;
      else
        v18 = 22;
      v35 = a5[1];
      if (v35)
        v36 = (const char *)(v35 + 3880);
      else
        v36 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
      v37 = obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): node level greater than root level %d\n", "btree_node_check", 189, v36, v37, *(unsigned __int16 *)(v12 + 34), *(unsigned __int16 *)(a1[7] + 34));
    }
    v38 = v15 - 1;
    if (*(unsigned __int16 *)(a1[7] + 34) - (v15 - 1) != *(unsigned __int16 *)(a5[7] + 34))
    {
      if ((_DWORD)v18)
        v18 = v18;
      else
        v18 = 22;
      v39 = a5[1];
      if (v39)
        v40 = (const char *)(v39 + 3880);
      else
        v40 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
      v41 = obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): node level should be %d\n", "btree_node_check", 192, v40, v41, *(unsigned __int16 *)(v12 + 34), *(unsigned __int16 *)(a1[7] + 34) - v38);
    }
  }
  if ((*(_WORD *)(v12 + 32) & 1) != 0)
    v42 = -96;
  else
    v42 = -56;
  v43 = v42 + ((a5[50] >> 27) & 0xF000);
  if (*(_WORD *)(v12 + 40))
  {
    if ((_DWORD)v18)
      v18 = v18;
    else
      v18 = 22;
    v44 = a5[1];
    if (v44)
      v45 = (const char *)(v44 + 3880);
    else
      v45 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v46 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): invalid table space offset\n", "btree_node_check", 203, v45, v46, *(unsigned __int16 *)(a5[7] + 34));
  }
  if (*(unsigned __int16 *)(v12 + 42) > v43)
  {
    if ((_DWORD)v18)
      v18 = v18;
    else
      v18 = 22;
    v47 = a5[1];
    if (v47)
      v48 = (const char *)(v47 + 3880);
    else
      v48 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v49 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): table space length larger than available data space\n", "btree_node_check", 206, v48, v49, *(unsigned __int16 *)(a5[7] + 34));
  }
  if ((*(_WORD *)(v12 + 32) & 4) == 0)
  {
    v50 = *(unsigned __int16 *)(v12 + 42);
    if (v50 < 8 * btree_node_toc_entry_size((uint64_t)a5))
    {
      if ((_DWORD)v18)
        v18 = v18;
      else
        v18 = 22;
      obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): table space length smaller than minimum\n");
      return v18;
    }
  }
  if ((_DWORD)v18)
    return v18;
  v51 = (unsigned __int16)(v43 - *(_WORD *)(v12 + 42));
  if (*(unsigned __int16 *)(v12 + 44) <= (unsigned __int16)(v43 - *(_WORD *)(v12 + 42)))
  {
    v18 = 0;
  }
  else
  {
    v52 = a5[1];
    if (v52)
      v53 = (const char *)(v52 + 3880);
    else
      v53 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v55 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): free space offset too large\n", "btree_node_check", 218, v53, v55, *(unsigned __int16 *)(a5[7] + 34));
    v18 = 22;
  }
  if (*(unsigned __int16 *)(v12 + 46) + *(unsigned __int16 *)(v12 + 44) > v51)
  {
    v56 = a5[1];
    if (v56)
      v57 = (const char *)(v56 + 3880);
    else
      v57 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v58 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): free space extends beyond end of node\n", "btree_node_check", 221, v57, v58, *(unsigned __int16 *)(a5[7] + 34));
    v18 = 22;
  }
  v270 = *(unsigned __int16 *)(v12 + 44);
  v59 = *(unsigned __int16 *)(v12 + 46);
  if (*(_DWORD *)(v12 + 36) > v51)
  {
    if ((_DWORD)v18)
      v18 = v18;
    else
      v18 = 22;
    v60 = a5[1];
    if (v60)
      v61 = (const char *)(v60 + 3880);
    else
      v61 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v62 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): key count larger than possible\n", "btree_node_check", 228, v61, v62, *(unsigned __int16 *)(a5[7] + 34));
  }
  v63 = *(_DWORD *)(v12 + 36);
  v269 = v51;
  if (v63 > v270 && (*(__int16 *)(v12 + 32) & 0x80000000) == 0)
  {
    if ((_DWORD)v18)
      v18 = v18;
    else
      v18 = 22;
    v64 = a5[1];
    if (v64)
      v65 = (const char *)(v64 + 3880);
    else
      v65 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v66 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): key count larger than gross key space\n", "btree_node_check", 231, v65, v66, *(unsigned __int16 *)(a5[7] + 34));
  }
  v67 = *(_DWORD *)(v12 + 36);
  v68 = *(unsigned __int16 *)(v12 + 42);
  if (v67 > v68 / btree_node_toc_entry_size((uint64_t)a5))
  {
    if ((_DWORD)v18)
      v18 = v18;
    else
      v18 = 22;
    obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): key count larger than TOC space\n");
    return v18;
  }
  if ((_DWORD)v18)
    return v18;
  if (a5[47] == v12 + 56)
  {
    v18 = 0;
  }
  else
  {
    v69 = a5[1];
    if (v69)
      v70 = (const char *)(v69 + 3880);
    else
      v70 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v71 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): invalid TOC[] pointer\n", "btree_node_check", 242, v70, v71, *(unsigned __int16 *)(a5[7] + 34));
    v18 = 22;
  }
  if (a5[48] != v12 + 56 + *(unsigned __int16 *)(v12 + 42))
  {
    v72 = a5[1];
    if (v72)
      v73 = (const char *)(v72 + 3880);
    else
      v73 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v74 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): invalid keys[] pointer\n", "btree_node_check", 245, v73, v74, *(unsigned __int16 *)(a5[7] + 34));
    v18 = 22;
  }
  if ((*(_WORD *)(v12 + 32) & 1) != 0 && a5[49] != v12 + ((a5[50] >> 27) & 0x1F000) - 40)
  {
    if ((_DWORD)v18)
      v18 = v18;
    else
      v18 = 22;
    v75 = a5[1];
    if (v75)
      v76 = (const char *)(v75 + 3880);
    else
      v76 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v77 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): invalid vals[] pointer\n", "btree_node_check", 248, v76, v77, *(unsigned __int16 *)(a5[7] + 34));
  }
  if ((*(_WORD *)(v12 + 32) & 1) == 0 && a5[49] != v12 + ((a5[50] >> 27) & 0x1F000))
  {
    if ((_DWORD)v18)
      v18 = v18;
    else
      v18 = 22;
    obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): invalid vals[] pointer\n");
    return v18;
  }
  if ((_DWORD)v18)
    return v18;
  v78 = v270 + v59;
  if (*(unsigned __int16 *)(v12 + 50) <= v270)
  {
    v18 = 0;
    v81 = v269;
  }
  else
  {
    v79 = a5[1];
    if (v79)
      v80 = (const char *)(v79 + 3880);
    else
      v80 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v81 = v269;
    v130 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): key free list space larger than key space available\n", "btree_node_check", 259, v80, v130, *(unsigned __int16 *)(a5[7] + 34));
    v18 = 22;
  }
  v131 = v81 - v78;
  v132 = *(unsigned __int16 *)(v12 + 48);
  if (v132 != 0xFFFF && v270 - 4 < v132)
  {
    v133 = a5[1];
    if (v133)
      v134 = (const char *)(v133 + 3880);
    else
      v134 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v135 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): key free list head beyond key space available\n", "btree_node_check", 263, v134, v135, *(unsigned __int16 *)(a5[7] + 34));
    v18 = 22;
  }
  if (*(unsigned __int16 *)(v12 + 54) > (unsigned __int16)v131)
  {
    if ((_DWORD)v18)
      v18 = v18;
    else
      v18 = 22;
    v136 = a5[1];
    if (v136)
      v137 = (const char *)(v136 + 3880);
    else
      v137 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v138 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): val free list space larger than val space available\n", "btree_node_check", 266, v137, v138, *(unsigned __int16 *)(a5[7] + 34));
  }
  v139 = *(unsigned __int16 *)(v12 + 52);
  if (v139 != 0xFFFF)
  {
    if (v139 > (unsigned __int16)v131)
    {
      if ((_DWORD)v18)
        v18 = v18;
      else
        v18 = 22;
      v140 = a5[1];
      if (v140)
        v141 = (const char *)(v140 + 3880);
      else
        v141 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
      v145 = obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): val free list head beyond val space available\n", "btree_node_check", 270, v141, v145, *(unsigned __int16 *)(a5[7] + 34));
      v139 = *(unsigned __int16 *)(v12 + 52);
    }
    if (v139 <= 3)
    {
      if ((_DWORD)v18)
        v18 = v18;
      else
        v18 = 22;
      obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): val free list head beyond end of node\n");
      return v18;
    }
  }
  if ((_DWORD)v18)
    return v18;
  v268 = v270 - 4;
  v146 = _apfs_calloc((v269 + 63) >> 6, 8uLL);
  v266 = (v269 + 63) >> 6;
  v147 = _apfs_calloc(v266, 8uLL);
  v267 = v147;
  if (!v146 || !v147)
  {
    v158 = a5[1];
    if (v158)
      v159 = (const char *)(v158 + 3880);
    else
      v159 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v160 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): couldn't allocate bitmap to check btree node space usage\n", "btree_node_check", 286, v159, v160, *(unsigned __int16 *)(a5[7] + 34));
    v18 = 12;
    goto LABEL_343;
  }
  v265 = v131;
  v271 = a7;
  v272 = a8;
  bitmap_set_range((uint64_t)v146, *(unsigned __int16 *)(v12 + 44), *(unsigned __int16 *)(v12 + 46));
  v148 = 0;
  LOWORD(v149) = *(_WORD *)(v12 + 48);
  v150 = v146;
  while (1)
  {
    v151 = (unsigned __int16)v149;
    if ((unsigned __int16)v149 == 0xFFFF)
      break;
    if ((unsigned __int16)v149 >= v270 || v268 < (unsigned __int16)v149)
    {
      obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): key free list entry starts beyond key space available\n");
LABEL_341:
      v18 = 22;
      goto LABEL_342;
    }
    v152 = (unsigned __int16 *)(a5[48] + (unsigned __int16)v149);
    v153 = v152[1];
    if (v153 <= 3)
    {
LABEL_339:
      obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): key free list entry len value too small\n");
      goto LABEL_341;
    }
    if (v153 + (unsigned __int16)v149 > v270)
    {
      obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): key free list entry extends beyond key space available\n");
      goto LABEL_341;
    }
    if (!bitmap_range_is_clear((uint64_t)v146, (unsigned __int16)v149, v153))
    {
      obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): key free list entry overlaps with other free space\n");
      goto LABEL_341;
    }
    bitmap_set_range((uint64_t)v146, v151, v152[1]);
    v148 += v152[1];
    v154 = *(unsigned __int16 *)(v12 + 50);
    if (v148 <= v154)
    {
      v18 = 0;
    }
    else
    {
      v155 = a5[1];
      if (v155)
        v156 = (const char *)(v155 + 3880);
      else
        v156 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
      v157 = obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): key free list entries total space exceeds free list space\n", "btree_node_check", 326, v156, v157, *(unsigned __int16 *)(a5[7] + 34));
      v18 = 22;
    }
    v149 = *v152;
    if ((_DWORD)v151 == v149)
    {
LABEL_340:
      obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): key free list entry points to itself\n");
      goto LABEL_341;
    }
    v146 = v150;
    if (v148 > v154)
      goto LABEL_343;
  }
  v162 = 0;
  LOWORD(v163) = *(_WORD *)(v12 + 52);
  while (1)
  {
    v164 = (unsigned __int16)v163;
    if ((unsigned __int16)v163 == 0xFFFF)
      break;
    if ((unsigned __int16)v163 <= 3u)
    {
      v165 = a5[1];
      if (v165)
        v166 = (const char *)(v165 + 3880);
      else
        v166 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
      v167 = obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): val free list entry beyond end of node\n", "btree_node_check", 342, v166, v167, *(unsigned __int16 *)(a5[7] + 34));
      v18 = 22;
    }
    else
    {
      v18 = 0;
    }
    if (v164 > (unsigned __int16)v265)
    {
      obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): val free list entry starts beyond val space available\n");
      goto LABEL_341;
    }
    v146 = v150;
    if (v164 < 4)
      goto LABEL_343;
    v168 = (unsigned __int16 *)(a5[49] - v164);
    v169 = v168[1];
    if (v169 <= 3)
      goto LABEL_339;
    if (v164 < v169)
    {
      obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): val free list entry extends beyond val space available\n");
      goto LABEL_341;
    }
    if (!bitmap_range_is_clear((uint64_t)v150, (int)(v269 - v164), v169))
    {
      obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): val free list entry overlaps with other free space\n");
      goto LABEL_341;
    }
    bitmap_set_range((uint64_t)v150, (int)(v269 - v164), v168[1]);
    v162 += v168[1];
    v170 = *(unsigned __int16 *)(v12 + 54);
    if (v162 <= v170)
    {
      v18 = 0;
    }
    else
    {
      v171 = a5[1];
      if (v171)
        v172 = (const char *)(v171 + 3880);
      else
        v172 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
      v173 = obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): val free list entries total space exceeds free list space\n", "btree_node_check", 372, v172, v173, *(unsigned __int16 *)(a5[7] + 34));
      v18 = 22;
    }
    v163 = *v168;
    if (v164 == v163)
      goto LABEL_340;
    v146 = v150;
    if (v162 > v170)
      goto LABEL_343;
  }
  if ((*(_WORD *)(v12 + 32) & 4) != 0 && (a5[50] & 0x7FFE00) == 0)
  {
    v176 = a5[1];
    if (v176)
      v177 = (const char *)(v176 + 3880);
    else
      v177 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v178 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): node says kv size is fixed, but tree says key size is variable\n", "btree_node_check", 387, v177, v178, *(unsigned __int16 *)(a5[7] + 34));
    v18 = 22;
  }
  else
  {
    v18 = 0;
  }
  if ((*(_WORD *)(a5[7] + 32) & 2) == 0 && (a5[50] & 0x7FFE00) != 0 && (*(_WORD *)(v12 + 32) & 4) == 0)
  {
    v174 = a5[1];
    if (v174)
      v175 = (const char *)(v174 + 3880);
    else
      v175 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v179 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): tree says key size is fixed, but node says kv size is variable\n", "btree_node_check", 390, v175, v179, *(unsigned __int16 *)(a5[7] + 34));
    v18 = 22;
  }
  if ((*(_WORD *)(v12 + 32) & 4) != 0 && (*(_WORD *)(a5[7] + 32) & 2) != 0 && (a5[50] & 0x7FFF800000) == 0)
  {
    if ((_DWORD)v18)
      v18 = v18;
    else
      v18 = 22;
    v180 = a5[1];
    if (v180)
      v181 = (const char *)(v180 + 3880);
    else
      v181 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v182 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): node says kv size is fixed, but tree says val size is variable\n", "btree_node_check", 393, v181, v182, *(unsigned __int16 *)(a5[7] + 34));
  }
  v183 = a5[7];
  v184 = *(_WORD *)(v183 + 32);
  if ((v184 & 2) != 0)
  {
    v185 = a5[50];
    if ((v185 & 0x7FFF800000) != 0 && (v185 & 4) == 0 && (v185 & 0x7FFE00) != 0 && (*(_WORD *)(v12 + 32) & 4) == 0)
    {
      if ((_DWORD)v18)
        v18 = v18;
      else
        v18 = 22;
      obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): tree says kv sizes are fixed, but leaf says kv size is variable\n");
      goto LABEL_342;
    }
  }
  v146 = v150;
  if ((_DWORD)v18)
    goto LABEL_343;
  v186 = a5[47];
  if ((*(_WORD *)(v12 + 32) & 4) == 0)
  {
    if (*(_DWORD *)(v183 + 36))
    {
      v187 = 0;
      v188 = (unsigned __int16 *)(v186 + 4);
      while (1)
      {
        v189 = *(v188 - 2);
        v268 = *v188;
        v190 = v188[1];
        if ((_DWORD)v189 == 0xFFFF)
        {
          if ((*(__int16 *)(v12 + 32) & 0x80000000) == 0)
            goto LABEL_576;
          v18 = 0;
        }
        else
        {
          v191 = *(v188 - 1);
          v192 = *(_WORD *)(v183 + 32);
          if ((v192 & 2) != 0
            && (a1 && *(_DWORD *)(a1[49] + 16) < v191
             || (v192 & 1) != 0 && *(_DWORD *)(a5[49] + 16) < v191))
          {
            v193 = a5[1];
            if (v193)
              v194 = (const char *)(v193 + 3880);
            else
              v194 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
            v195 = obj_oid((uint64_t)a5);
            log_err("%s:%d: %s oid 0x%llx (level %d): key size greater than longest recorded for tree\n", "btree_node_check", 475, v194, v195, *(unsigned __int16 *)(a5[7] + 34));
            v18 = 22;
          }
          else
          {
            v18 = 0;
          }
          if (v189 >= v270)
          {
            v196 = a5[1];
            if (v196)
              v197 = (const char *)(v196 + 3880);
            else
              v197 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
            v198 = obj_oid((uint64_t)a5);
            log_err("%s:%d: %s oid 0x%llx (level %d): key location not within key space\n", "btree_node_check", 475, v197, v198, *(unsigned __int16 *)(a5[7] + 34));
            v18 = 22;
          }
          if ((int)v191 + (int)v189 <= v270)
          {
            if (!(_DWORD)v18)
            {
              if (bitmap_range_is_clear((uint64_t)v150, v189, v191))
              {
                v18 = 0;
              }
              else
              {
                v202 = a5[1];
                if (v202)
                  v203 = (const char *)(v202 + 3880);
                else
                  v203 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
                v204 = obj_oid((uint64_t)a5);
                log_err("%s:%d: %s oid 0x%llx (level %d): key entry overlaps with free space\n", "btree_node_check", 475, v203, v204, *(unsigned __int16 *)(a5[7] + 34));
                v18 = 22;
              }
              if (!bitmap_range_is_clear((uint64_t)v267, v189, v191))
              {
                v205 = a5[1];
                if (v205)
                  v206 = (const char *)(v205 + 3880);
                else
                  v206 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
                v207 = obj_oid((uint64_t)a5);
                log_err("%s:%d: %s oid 0x%llx (level %d): key entry overlaps with other entries\n", "btree_node_check", 475, v206, v207, *(unsigned __int16 *)(a5[7] + 34));
                v18 = 22;
              }
              if ((a5[50] & 0x40) != 0)
                v208 = v191;
              else
                v208 = ((_DWORD)v191 + 7) & 0x1FFF8;
              bitmap_set_range((uint64_t)v267, v189, v208);
            }
          }
          else
          {
            if ((_DWORD)v18)
              v18 = v18;
            else
              v18 = 22;
            v199 = a5[1];
            if (v199)
              v200 = (const char *)(v199 + 3880);
            else
              v200 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
            v201 = obj_oid((uint64_t)a5);
            log_err("%s:%d: %s oid 0x%llx (level %d): key location extends beyond key space\n", "btree_node_check", 475, v200, v201, *(unsigned __int16 *)(a5[7] + 34));
          }
        }
        if (v268 > 0xFFFD)
        {
          if ((_DWORD)v190 && (_DWORD)v190 != 65534)
          {
            if ((_DWORD)v18)
              v18 = v18;
            else
              v18 = 22;
            obj_oid((uint64_t)a5);
            log_err("%s:%d: %s oid 0x%llx (level %d): invalid val offset has non-zero length\n");
            goto LABEL_342;
          }
        }
        else
        {
          v209 = *(_WORD *)(a5[7] + 32);
          if ((v209 & 2) != 0
            && (a1 && *(_DWORD *)(a1[49] + 20) < v190
             || (v209 & 1) != 0 && *(_DWORD *)(a5[49] + 20) < v190))
          {
            if ((_DWORD)v18)
              v18 = v18;
            else
              v18 = 22;
            v210 = a5[1];
            if (v210)
              v211 = (const char *)(v210 + 3880);
            else
              v211 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
            v212 = obj_oid((uint64_t)a5);
            log_err("%s:%d: %s oid 0x%llx (level %d): val size greater than longest recorded for tree\n", "btree_node_check", 478, v211, v212, *(unsigned __int16 *)(a5[7] + 34));
          }
          if (v268 > (unsigned __int16)v265)
          {
            if ((_DWORD)v18)
              v18 = v18;
            else
              v18 = 22;
            v213 = a5[1];
            if (v213)
              v214 = (const char *)(v213 + 3880);
            else
              v214 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
            v215 = obj_oid((uint64_t)a5);
            log_err("%s:%d: %s oid 0x%llx (level %d): val location not within val space\n", "btree_node_check", 478, v214, v215, *(unsigned __int16 *)(a5[7] + 34));
          }
          if (v268 < v190)
          {
            if ((_DWORD)v18)
              v18 = v18;
            else
              v18 = 22;
            goto LABEL_575;
          }
          v146 = v150;
          if ((_DWORD)v18)
            goto LABEL_343;
          v216 = v269 - v268;
          if (bitmap_range_is_clear((uint64_t)v150, v269 - v268, v190))
          {
            v18 = 0;
          }
          else
          {
            v217 = a5[1];
            if (v217)
              v218 = (const char *)(v217 + 3880);
            else
              v218 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
            v219 = obj_oid((uint64_t)a5);
            log_err("%s:%d: %s oid 0x%llx (level %d): val entry overlaps with free space\n", "btree_node_check", 478, v218, v219, *(unsigned __int16 *)(a5[7] + 34));
            v18 = 22;
          }
          if (!bitmap_range_is_clear((uint64_t)v267, v216, v190))
          {
            v220 = a5[1];
            if (v220)
              v221 = (const char *)(v220 + 3880);
            else
              v221 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
            v222 = obj_oid((uint64_t)a5);
            log_err("%s:%d: %s oid 0x%llx (level %d): val entry overlaps with other entries\n", "btree_node_check", 478, v221, v222, *(unsigned __int16 *)(a5[7] + 34));
            v18 = 22;
          }
          if ((a5[50] & 0x40) != 0)
            v223 = v190;
          else
            v223 = ((_DWORD)v190 + 7) & 0x1FFF8;
          bitmap_set_range((uint64_t)v267, v216, v223);
        }
        v146 = v150;
        if ((_DWORD)v18)
          goto LABEL_343;
        v188 += 4;
        ++v187;
        v183 = a5[7];
        if (v187 >= *(unsigned int *)(v183 + 36))
          goto LABEL_561;
      }
    }
    goto LABEL_561;
  }
  v224 = a5[50];
  if ((v184 & 2) != 0)
    v225 = (unsigned __int16)(v224 >> 23);
  else
    v225 = 8;
  if (!*(_DWORD *)(v183 + 36))
  {
LABEL_561:
    _apfs_free(v150, 8 * v266);
    _apfs_free(v267, 8 * v266);
    a8 = v272;
    a7 = v271;
    LOWORD(v15) = v275;
    goto LABEL_17;
  }
  v226 = 0;
  v264 = (v224 >> 9) & 0x3FFF;
  v262 = ((_WORD)v264 + 7) & 0x7FF8;
  v263 = ((_DWORD)v225 + 7) & 0x1FFF8;
  v227 = (unsigned __int16 *)(v186 + 2);
  while (1)
  {
    v228 = *(v227 - 1);
    v268 = *v227;
    if ((_DWORD)v228 == 0xFFFF)
    {
      if ((*(__int16 *)(v12 + 32) & 0x80000000) == 0)
      {
LABEL_576:
        obj_oid((uint64_t)a5);
        log_err("%s:%d: %s oid 0x%llx (level %d): invalid key offset\n");
        goto LABEL_341;
      }
      v18 = 0;
    }
    else
    {
      v229 = *(_WORD *)(v183 + 32);
      if ((v229 & 2) != 0
        && (a1 && *(_DWORD *)(a1[49] + 16) < v264
         || (v229 & 1) != 0 && *(_DWORD *)(a5[49] + 16) < v264))
      {
        v230 = a5[1];
        if (v230)
          v231 = (const char *)(v230 + 3880);
        else
          v231 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
        v232 = obj_oid((uint64_t)a5);
        log_err("%s:%d: %s oid 0x%llx (level %d): key size greater than longest recorded for tree\n", "btree_node_check", 452, v231, v232, *(unsigned __int16 *)(a5[7] + 34));
        v18 = 22;
      }
      else
      {
        v18 = 0;
      }
      if (v228 >= v270)
      {
        v233 = a5[1];
        if (v233)
          v234 = (const char *)(v233 + 3880);
        else
          v234 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
        v235 = obj_oid((uint64_t)a5);
        log_err("%s:%d: %s oid 0x%llx (level %d): key location not within key space\n", "btree_node_check", 452, v234, v235, *(unsigned __int16 *)(a5[7] + 34));
        v18 = 22;
      }
      if ((int)v264 + (int)v228 <= v270)
      {
        if (!(_DWORD)v18)
        {
          if (bitmap_range_is_clear((uint64_t)v150, v228, v264))
          {
            v18 = 0;
          }
          else
          {
            v239 = a5[1];
            if (v239)
              v240 = (const char *)(v239 + 3880);
            else
              v240 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
            v241 = obj_oid((uint64_t)a5);
            log_err("%s:%d: %s oid 0x%llx (level %d): key entry overlaps with free space\n", "btree_node_check", 452, v240, v241, *(unsigned __int16 *)(a5[7] + 34));
            v18 = 22;
          }
          if (!bitmap_range_is_clear((uint64_t)v267, v228, v264))
          {
            v242 = a5[1];
            if (v242)
              v243 = (const char *)(v242 + 3880);
            else
              v243 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
            v244 = obj_oid((uint64_t)a5);
            log_err("%s:%d: %s oid 0x%llx (level %d): key entry overlaps with other entries\n", "btree_node_check", 452, v243, v244, *(unsigned __int16 *)(a5[7] + 34));
            v18 = 22;
          }
          if ((a5[50] & 0x40) != 0)
            v245 = v264;
          else
            v245 = v262;
          bitmap_set_range((uint64_t)v267, v228, v245);
        }
      }
      else
      {
        v18 = (_DWORD)v18 ? v18 : 22;
        v236 = a5[1];
        v237 = (const char *)(v236 ? v236 + 3880 : *(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
        v238 = obj_oid((uint64_t)a5);
        log_err("%s:%d: %s oid 0x%llx (level %d): key location extends beyond key space\n", "btree_node_check", 452, v237, v238, *(unsigned __int16 *)(a5[7] + 34));
      }
    }
    if (v268 <= 0xFFFD)
      break;
LABEL_559:
    v146 = v150;
    if ((_DWORD)v18)
      goto LABEL_343;
    v227 += 2;
    ++v226;
    v183 = a5[7];
    if (v226 >= *(unsigned int *)(v183 + 36))
      goto LABEL_561;
  }
  v246 = *(_WORD *)(a5[7] + 32);
  if ((v246 & 2) != 0
    && (a1 && *(_DWORD *)(a1[49] + 20) < v225
     || (v246 & 1) != 0 && *(_DWORD *)(a5[49] + 20) < v225))
  {
    if ((_DWORD)v18)
      v18 = v18;
    else
      v18 = 22;
    v247 = a5[1];
    if (v247)
      v248 = (const char *)(v247 + 3880);
    else
      v248 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v249 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): val size greater than longest recorded for tree\n", "btree_node_check", 455, v248, v249, *(unsigned __int16 *)(a5[7] + 34));
  }
  if (v268 > (unsigned __int16)v265)
  {
    if ((_DWORD)v18)
      v18 = v18;
    else
      v18 = 22;
    v250 = a5[1];
    if (v250)
      v251 = (const char *)(v250 + 3880);
    else
      v251 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
    v252 = obj_oid((uint64_t)a5);
    log_err("%s:%d: %s oid 0x%llx (level %d): val location not within val space\n", "btree_node_check", 455, v251, v252, *(unsigned __int16 *)(a5[7] + 34));
  }
  if (v268 >= v225)
  {
    v146 = v150;
    if ((_DWORD)v18)
      goto LABEL_343;
    v253 = v269 - v268;
    if (bitmap_range_is_clear((uint64_t)v150, v269 - v268, v225))
    {
      v18 = 0;
    }
    else
    {
      v254 = a5[1];
      if (v254)
        v255 = (const char *)(v254 + 3880);
      else
        v255 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
      v256 = obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): val entry overlaps with free space\n", "btree_node_check", 455, v255, v256, *(unsigned __int16 *)(a5[7] + 34));
      v18 = 22;
    }
    if (!bitmap_range_is_clear((uint64_t)v267, v253, v225))
    {
      v257 = a5[1];
      if (v257)
        v258 = (const char *)(v257 + 3880);
      else
        v258 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a5 + 392) + 384) + 208);
      v259 = obj_oid((uint64_t)a5);
      log_err("%s:%d: %s oid 0x%llx (level %d): val entry overlaps with other entries\n", "btree_node_check", 455, v258, v259, *(unsigned __int16 *)(a5[7] + 34));
      v18 = 22;
    }
    if ((a5[50] & 0x40) != 0)
      v260 = v225;
    else
      v260 = v263;
    bitmap_set_range((uint64_t)v267, v253, v260);
    goto LABEL_559;
  }
  if ((_DWORD)v18)
    v18 = v18;
  else
    v18 = 22;
LABEL_575:
  obj_oid((uint64_t)a5);
  log_err("%s:%d: %s oid 0x%llx (level %d): val location extends beyond val space\n");
LABEL_342:
  v146 = v150;
LABEL_343:
  if (v146)
    _apfs_free(v146, (8 * v266));
  if (v267)
    _apfs_free(v267, (8 * v266));
  return v18;
}

uint64_t btree_check_ext(FILE *a1, _QWORD *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  FILE *v15;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  if (obj_type((uint64_t)a2) == 2)
  {
    v34 = 0;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v17 = 0u;
    v10 = btree_node_check(a2, a3, 0, 0, a2, 1u, 0, 0, (uint64_t)&v17, 0, 0);
    v11 = v10;
    if (*(_QWORD *)(a2[49] + 24) != v18)
    {
      if ((_DWORD)v10)
        v11 = v10;
      else
        v11 = 22;
      v12 = a2[1];
      if (v12)
        v13 = (const char *)(v12 + 3880);
      else
        v13 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a2 + 392) + 384) + 208);
      v14 = obj_oid((uint64_t)a2);
      log_err("%s:%d: %s oid 0x%llx: btree key count (%llu) doesn't match # leaf entries (%u)\n", "btree_check_ext", 681, v13, v14, *(_QWORD *)(a2[49] + 24), (_DWORD)v18);
    }
    if (*(_QWORD *)(a2[49] + 32) == DWORD1(v17) + (_DWORD)v17)
    {
      if (a5 && a4 && !(_DWORD)v11)
      {
        if (a1)
          v15 = a1;
        else
          v15 = (FILE *)*MEMORY[0x1E0C80C20];
        btree_debug_stats_print(v15, (uint64_t)a2, &v17, a5);
      }
    }
    else
    {
      if ((_DWORD)v11)
        v11 = v11;
      else
        v11 = 22;
      obj_oid((uint64_t)a2);
      log_err("%s:%d: %s oid 0x%llx: btree node count (%llu) doesn't match # nodes traversed (%u)\n");
    }
  }
  else
  {
    v11 = 22;
    if (a2[1])
      log_err("%s:%d: %s btree check called with non-root btree node: %d\n");
    else
      log_err("%s:%d: %s btree check called with non-root btree node: %d\n", "btree_check_ext", 672, (const char *)(*(_QWORD *)(*(_QWORD *)(*a2 + 392) + 384) + 208), 22);
  }
  return v11;
}

uint64_t btree_debug_stats_print(FILE *a1, uint64_t a2, _DWORD *a3, int a4)
{
  FILE *v7;
  _DWORD *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unint64_t v16;
  double v17;
  unint64_t v18;
  uint64_t result;
  uint64_t v20;
  int v21;
  _DWORD *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  double v30;
  unsigned int v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  double v38;
  unsigned int v39;
  unsigned int v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  unint64_t v46;
  unint64_t v47;
  unsigned int v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  double v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  char __str[16];
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  if (a1)
    a4 = 5;
  if (a1)
    v7 = a1;
  else
    v7 = (FILE *)*MEMORY[0x1E0C80C20];
  if (a4 >= 2)
  {
    v8 = *(_DWORD **)(a2 + 392);
    v9 = v8[1];
    v10 = v8[2];
    v11 = v8[3];
    if (v10)
      v12 = v10;
    else
      v12 = 8;
    if (v11)
      v13 = v11;
    else
      v13 = 8;
    v14 = *a3;
    if (*a3 <= 1u)
      v14 = 1;
    fprintf(v7, "nodesize: %d  dataspace: %d  key size: %d  val size: %d  max keys: node %d leaf %d  avg keys: node %d leaf %d\n", v9, v9 - 56, v10, v11, (v9 - 56) / (v12 + 8), (v9 - 56) / (v13 + v12), a3[3] / v14, a3[4] / a3[1]);
  }
  v16 = *((_QWORD *)a3 + 11);
  if (v16 <= 1)
    v16 = 1;
  v17 = (double)*((unint64_t *)a3 + 12) * 100.0 / (double)v16;
  v18 = *((_QWORD *)a3 + 16);
  if (v18 <= 1)
    v18 = 1;
  v15 = a3[1];
  result = fprintf(v7, "levels: %d  keys: %lld  nodes: total %d  internal: %d (%.2f%%)  leaves: %d (%.2f%%)  usage: %.2f%% (%.2f%% %.2f%%)\n", a3[2], *(_QWORD *)(*(_QWORD *)(a2 + 392) + 24), v15 + *a3, *a3, (double)*a3 * 100.0 / (double)(v15 + *a3), v15, (double)v15 * 100.0 / (double)(v15 + *a3), (double)*((unint64_t *)a3 + 7) * 100.0 / (double)*((unint64_t *)a3 + 6), v17, (double)*((unint64_t *)a3 + 17) * 100.0 / (double)v18);
  if (a4 > 2)
  {
    v20 = 0;
    v21 = 0;
    v22 = a3 + 54;
    do
    {
      if (v22[v20])
      {
        if (v20)
          result = fprintf(v7, "level %d: %d nodes %.2f average descendents\n");
        else
          result = fprintf(v7, "level %d: %d nodes\n");
        v21 += v22[v20];
      }
      ++v20;
    }
    while (v20 != 16);
  }
  if (a4 >= 2)
  {
    LODWORD(v23) = a3[4];
    v23 = v23 <= 1 ? 1 : v23;
    result = fprintf(v7, "key/val sizes:  tree max k:%d v:%d  max k:%d v:%d  avg k:%llu v:%llu\n", *(_DWORD *)(*(_QWORD *)(a2 + 392) + 16), *(_DWORD *)(*(_QWORD *)(a2 + 392) + 20), a3[52], a3[53], *((_QWORD *)a3 + 18) / v23, *((_QWORD *)a3 + 19) / v23);
    if (a4 >= 4)
    {
      v65 = 0u;
      v66 = 0u;
      v63 = 0u;
      v64 = 0u;
      *(_OWORD *)__str = 0u;
      v62 = 0u;
      snprintf(__str, 0x10uLL, "<%d", *(_DWORD *)(*(_QWORD *)(a2 + 392) + 16) / 5u);
      snprintf((char *)&v62, 0x10uLL, "<%d", 2 * *(_DWORD *)(*(_QWORD *)(a2 + 392) + 16) / 5u);
      snprintf((char *)&v63, 0x10uLL, "<%d", 3 * *(_DWORD *)(*(_QWORD *)(a2 + 392) + 16) / 5u);
      snprintf((char *)&v64, 0x10uLL, "<%d", 4 * *(_DWORD *)(*(_QWORD *)(a2 + 392) + 16) / 5u);
      snprintf((char *)&v65, 0x10uLL, "<%d", *(_DWORD *)(*(_QWORD *)(a2 + 392) + 16));
      snprintf((char *)&v66, 0x10uLL, "=%d", *(_DWORD *)(*(_QWORD *)(a2 + 392) + 16));
      fprintf(v7, "    keys: %9s %9s %9s %9s %9s %9s\n", __str, (const char *)&v62, (const char *)&v63, (const char *)&v64, (const char *)&v65, (const char *)&v66);
      fprintf(v7, "    keys: %9d %9d %9d %9d %9d %9d\n", a3[40], a3[41], a3[42], a3[43], a3[44], a3[45]);
      LODWORD(v29) = a3[40];
      v30 = (double)v29 * 100.0;
      v31 = a3[4];
      if (v31 <= 1)
        v31 = 1;
      LODWORD(v24) = a3[41];
      LODWORD(v25) = a3[42];
      LODWORD(v26) = a3[43];
      LODWORD(v27) = a3[44];
      LODWORD(v28) = a3[45];
      fprintf(v7, "    keys: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n", v30 / (double)v31, (double)v24 * 100.0 / (double)v31, (double)v25 * 100.0 / (double)v31, (double)v26 * 100.0 / (double)v31, (double)v27 * 100.0 / (double)v31, (double)v28 * 100.0 / (double)v31);
      snprintf(__str, 0x10uLL, "<%d", *(_DWORD *)(*(_QWORD *)(a2 + 392) + 20) / 5u);
      snprintf((char *)&v62, 0x10uLL, "<%d", 2 * *(_DWORD *)(*(_QWORD *)(a2 + 392) + 20) / 5u);
      snprintf((char *)&v63, 0x10uLL, "<%d", 3 * *(_DWORD *)(*(_QWORD *)(a2 + 392) + 20) / 5u);
      snprintf((char *)&v64, 0x10uLL, "<%d", 4 * *(_DWORD *)(*(_QWORD *)(a2 + 392) + 20) / 5u);
      snprintf((char *)&v65, 0x10uLL, "<%d", *(_DWORD *)(*(_QWORD *)(a2 + 392) + 20));
      snprintf((char *)&v66, 0x10uLL, "=%d", *(_DWORD *)(*(_QWORD *)(a2 + 392) + 20));
      fprintf(v7, "  values: %9s %9s %9s %9s %9s %9s\n", __str, (const char *)&v62, (const char *)&v63, (const char *)&v64, (const char *)&v65, (const char *)&v66);
      fprintf(v7, "  values: %9d %9d %9d %9d %9d %9d\n", a3[46], a3[47], a3[48], a3[49], a3[50], a3[51]);
      LODWORD(v37) = a3[46];
      v38 = (double)v37 * 100.0;
      v39 = a3[4];
      if (v39 <= 1)
        v40 = 1;
      else
        v40 = a3[4];
      v41 = v38 / (double)v40;
      LODWORD(v32) = a3[47];
      v42 = (double)v32 * 100.0 / (double)v40;
      LODWORD(v33) = a3[48];
      LODWORD(v34) = a3[49];
      v43 = (double)v33 * 100.0 / (double)v40;
      v44 = (double)v34 * 100.0;
      v45 = (double)v39;
      if (!v39)
        v45 = 1.0;
      LODWORD(v35) = a3[50];
      LODWORD(v36) = a3[51];
      fprintf(v7, "  values: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n", v41, v42, v43, v44 / v45, (double)v35 * 100.0 / v45, (double)v36 * 100.0 / v45);
      fprintf(v7, "capacity: all    %llu / %llu => %.2f %% used\n", *((_QWORD *)a3 + 7), *((_QWORD *)a3 + 6), (double)*((unint64_t *)a3 + 7) * 100.0 / (double)*((unint64_t *)a3 + 6));
      if (a4 == 4)
      {
        fprintf(v7, "capacity: nodes  %llu / %llu => %.2f %% used\n");
      }
      else
      {
        fprintf(v7, "capacity: %9s %9s %9s %9s %9s %9s\n", "<20", "<40", "<60", "<80", "<100", "FULL");
        fprintf(v7, "capacity: %9d %9d %9d %9d %9d %9d\n", a3[5], a3[6], a3[7], a3[8], a3[9], a3[10]);
        LODWORD(v46) = a3[5];
        LODWORD(v47) = a3[6];
        v48 = a3[1] + *a3;
        LODWORD(v49) = a3[7];
        LODWORD(v50) = a3[8];
        LODWORD(v51) = a3[9];
        LODWORD(v52) = a3[10];
        fprintf(v7, "capacity: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n", (double)v46 * 100.0 / (double)v48, (double)v47 * 100.0 / (double)v48, (double)v49 * 100.0 / (double)v48, (double)v50 * 100.0 / (double)v48, (double)v51 * 100.0 / (double)v48, (double)v52 * 100.0 / (double)v48);
        fprintf(v7, "capacity: nodes  %llu / %llu => %.2f %% used\n", *((_QWORD *)a3 + 12), *((_QWORD *)a3 + 11), (double)*((unint64_t *)a3 + 12) * 100.0 / (double)*((unint64_t *)a3 + 11));
        fprintf(v7, "capacity: %9s %9s %9s %9s %9s %9s\n", "<20", "<40", "<60", "<80", "<100", "FULL");
        fprintf(v7, "capacity: %9d %9d %9d %9d %9d %9d\n", a3[16], a3[17], a3[18], a3[19], a3[20], a3[21]);
        fprintf(v7, "capacity: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n");
      }
      result = fprintf(v7, "capacity: leaves %llu / %llu => %.2f %% used\n", *((_QWORD *)a3 + 17), *((_QWORD *)a3 + 16), (double)*((unint64_t *)a3 + 17) * 100.0 / (double)*((unint64_t *)a3 + 16));
      if (a4 != 4)
      {
        fprintf(v7, "capacity: %9s %9s %9s %9s %9s %9s\n", "<20", "<40", "<60", "<80", "<100", "FULL");
        fprintf(v7, "capacity: %9d %9d %9d %9d %9d %9d\n", a3[26], a3[27], a3[28], a3[29], a3[30], a3[31]);
        LODWORD(v53) = a3[26];
        LODWORD(v54) = a3[27];
        LODWORD(v55) = a3[1];
        v56 = (double)v55;
        LODWORD(v57) = a3[28];
        LODWORD(v58) = a3[29];
        LODWORD(v59) = a3[30];
        LODWORD(v60) = a3[31];
        return fprintf(v7, "capacity: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n", (double)v53 * 100.0 / v56, (double)v54 * 100.0 / v56, (double)v57 * 100.0 / v56, (double)v58 * 100.0 / v56, (double)v59 * 100.0 / v56, (double)v60 * 100.0 / v56);
      }
    }
  }
  return result;
}

uint64_t btree_check(_QWORD *a1, uint64_t a2, int a3, int a4)
{
  return btree_check_ext(0, a1, a2, a3, a4);
}

uint64_t btree_check_recent_sanity(char *a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t, _QWORD, _QWORD, uint64_t, _QWORD), uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unsigned __int16 v14;
  uint64_t v15;
  uint64_t *v16;
  char *v17;
  unsigned int v18;
  _WORD *v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int16 v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unsigned __int16 v32;
  uint64_t v33;
  int v34;
  uint64_t v36;
  const char *v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t (*v41)(uint64_t, uint64_t, unint64_t, _QWORD, _QWORD, uint64_t, _QWORD);
  int v42;
  unsigned int v43;
  uint64_t v44;
  _QWORD v45[2];

  v40 = a4;
  v41 = a3;
  v45[1] = *MEMORY[0x1E0C80C00];
  v6 = *((_QWORD *)a1 + 1);
  if (!v6)
    v6 = *(_QWORD *)(*(_QWORD *)a1 + 392);
  MEMORY[0x1E0C80A78]();
  v8 = (uint64_t *)((char *)&v40 - v7);
  bzero((char *)&v40 - v7, v9);
  v44 = 0;
  v45[0] = 0;
  v42 = 0;
  v43 = 0;
  obj_lock((uint64_t)a1, 1);
  v10 = btree_level_count((uint64_t)a1, &v43);
  if ((_DWORD)v10)
  {
    v11 = v10;
    obj_unlock((uint64_t)a1, 1);
    return v11;
  }
  v12 = _apfs_calloc(v43, 0x10uLL);
  if (!v12)
  {
    obj_unlock((uint64_t)a1, 1);
    return 12;
  }
  v13 = v12;
  *v12 = a1;
  *((_WORD *)v12 + 4) = 0;
  obj_retain(a1);
  v14 = 0;
  while (1)
  {
    while (1)
    {
      v15 = v14;
      v16 = &v13[2 * v14];
      if (obj_xid(*v16) <= a2)
      {
        v21 = *v16;
        goto LABEL_16;
      }
      v17 = (char *)&v13[2 * v15];
      v20 = *((unsigned __int16 *)v17 + 4);
      v19 = v17 + 8;
      v18 = v20;
      v21 = *v16;
      v22 = *(_QWORD *)(*v16 + 56);
      if (*(_DWORD *)(v22 + 36) > v20)
        break;
LABEL_16:
      btree_node_release(v21, 1);
      *v16 = 0;
      v14 = v15 - 1;
      if ((((_WORD)v15 - 1) & 0x8000) != 0)
      {
LABEL_27:
        v11 = 0;
        goto LABEL_29;
      }
    }
    if ((*(_WORD *)(v22 + 32) & 2) != 0)
      break;
    v23 = btree_node_child_val(v21, v18, v8);
    if ((_DWORD)v23)
    {
      v11 = v23;
      obj_oid(*v16);
      log_err("%s:%d: %s node 0x%llx (level %d): error getting index %d child oid: %d\n");
      goto LABEL_29;
    }
    ++*v19;
    v24 = v15 + 1;
    if (v43 <= (__int16)v24)
    {
      v36 = *((_QWORD *)a1 + 1);
      if (v36)
        v37 = (const char *)(v36 + 3880);
      else
        v37 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
      v38 = (char *)&v13[2 * (__int16)v24];
      v39 = obj_oid(*((_QWORD *)v38 - 2));
      log_err("%s:%d: %s node 0x%llx (level %d) index %d: more levels than expected\n", "btree_check_recent_sanity", 769, v37, v39, *(unsigned __int16 *)(*(_QWORD *)(*((_QWORD *)v38 - 2) + 56) + 34), *((unsigned __int16 *)v38 - 4));
      v11 = 22;
      goto LABEL_29;
    }
    v25 = (char *)&v13[2 * (__int16)v24];
    *((_WORD *)v25 + 4) = 0;
    v26 = (__int16)v24 - 1;
    v27 = btree_node_get(a1, v8, 0, 2, *(_WORD *)(*(_QWORD *)(v13[2 * v26] + 56) + 34) - 1, 0, (uint64_t *)v25);
    v14 = v24;
    if ((_DWORD)v27)
    {
      v11 = v27;
      obj_oid(v13[2 * v26]);
      log_err("%s:%d: %s node 0x%llx (level %d): error getting index %d child: %d\n");
      goto LABEL_29;
    }
    if ((v24 & 0x8000) != 0)
      goto LABEL_27;
  }
  if (!v41)
    goto LABEL_16;
  v28 = 0;
  while (1)
  {
    v29 = btree_node_key_ptr(v21, (unsigned __int16)v28, v45, (_WORD *)&v42 + 1);
    if ((_DWORD)v29
      || (v29 = btree_node_val_ptr((_QWORD *)*v16, (unsigned __int16)v28, &v44, (__int16 *)&v42), (_DWORD)v29))
    {
      v11 = v29;
      obj_oid(*v16);
      log_err("%s:%d: %s node 0x%llx (level %d): error getting index %d key/val: %d\n");
      goto LABEL_29;
    }
    v30 = v41(v6, v40, a2, v45[0], HIWORD(v42), v44, (unsigned __int16)v42);
    if ((_DWORD)v30)
      break;
    ++v28;
    v21 = *v16;
    if (v28 >= *(_DWORD *)(*(_QWORD *)(*v16 + 56) + 36))
      goto LABEL_16;
  }
  v11 = v30;
LABEL_29:
  v31 = v43;
  if ((((_WORD)v43 - 1) & 0x8000) == 0)
  {
    v32 = v43 - 1;
    do
    {
      v33 = v13[2 * v32];
      if (v33)
        btree_node_release(v33, 1);
      v34 = (__int16)v32--;
    }
    while (v34 > 0);
    v31 = v43;
  }
  _apfs_free(v13, 16 * v31);
  return v11;
}

uint64_t nx_check(_QWORD *a1, char a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint32x2_t *v7;
  unint64_t v8;
  __int32 v9;
  int v10;
  __int32 v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  __int32 v15;
  unint64_t v16;
  __int32 v17;
  unint64_t v18;
  uint32x2_t v19;
  uint64_t v20;
  uint64_t v21;
  uint32x2_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  __int32 v29;
  uint32x2_t v30;
  uint32x2_t v31;
  uint32x2_t v32;
  uint32x2_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  __int32 v39;
  uint32x2_t v40;
  uint32x2_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  unsigned int v46;
  unsigned __int32 v47;
  unsigned int v48;
  unsigned __int32 v49;
  unsigned int v50;
  uint32x2_t v51;
  uint32x2_t v52;
  uint32x2_t v53;
  unint64_t v54;
  uint64_t *v55;
  unint64_t v56;
  unsigned int v57;
  int v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unsigned int v62;
  __int32 v63;
  unint64_t v64;
  unsigned int v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unsigned int v69;
  BOOL v70;
  uint32x2_t *v71;
  unsigned int v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  uint64_t v76;
  unint64_t v78;
  unint64_t v79;
  int v80;
  uint64_t v81;
  uint32x2_t v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  char v86;
  unint64_t v87;
  uint32x2_t *v88;
  uint32x2_t *v89;
  __int32 v90;
  unint64_t v91;
  uint32x2_t *v92;
  uint64_t v93;
  unint64_t v95;
  unint64_t v96;
  int v97;
  uint64_t *v98;
  unint64_t *v99;
  uint64_t v100;
  unint64_t v101;
  const char *v102;
  uint64_t v103;
  int v104;
  int v105;
  int v106;
  unint64_t v107;
  int v108;
  int v109;
  const char *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  unsigned int v115;
  unint64_t v116;
  unsigned int v117;
  unint64_t v118;
  unint64_t v119;
  unint64_t *v120;
  unint64_t v121;
  const char *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  int v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  char v132;
  unint64_t v133;
  unint64_t v134;
  uint32x2_t *v135;
  uint64_t v136;
  uint32x2_t *v137;
  uint32x2_t v138;
  uint64_t v139;
  uint32x2_t v140;
  uint32x2_t v141;
  int v142;
  uint64_t v143;
  uint32x2_t v144;
  uint32x2_t v145;
  uint32x2_t v146;
  int v147;
  uint64_t v148;
  uint32x2_t v149;
  uint64_t v150;
  int v151;
  int v152;
  int v153;
  int v154;
  int v155;
  int v156;
  uint64_t v157;
  unint64_t v158;
  int v159;
  int v160;
  unint64_t v161;
  int v162;
  uint64_t v163;
  uint64_t v164;
  int v165;
  const char *v166;
  int v167;
  unsigned int v168;
  unsigned int v169;
  unsigned int v170;
  unsigned int v171;
  unsigned int v172;
  unsigned int v173;
  unsigned int v174;
  unsigned int v175;
  unint64_t v176;
  uint64_t v177;
  unint64_t v178;
  uint64_t i;
  uint64_t v180;
  unint64_t v181;
  unint64_t v182;
  int v183;
  int v184;
  unint64_t v185;
  uint64_t j;
  uint64_t v187;
  unint64_t v188;
  uint64_t v189;
  unint64_t v190;
  unint64_t v191;
  unint64_t v192;
  uint64_t k;
  uint64_t v194;
  unint64_t v195;
  uint64_t v196;
  uint64_t v197;
  unint64_t v198;
  unint64_t v199;
  uint64_t v200;
  unint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  unint64_t v206;
  int v207;
  uint64_t *v208;
  uint64_t v209;
  unint64_t v210;
  int v211;
  int v212;
  int fsroot_tree;
  uint64_t *v214;
  uint64_t v215;
  int v216;
  uint64_t v217;
  int extentref_tree;
  uint64_t *v219;
  uint64_t v220;
  int v221;
  int snap_meta_tree;
  uint64_t *v223;
  uint64_t v224;
  int v225;
  int doc_id_tree;
  uint64_t *v227;
  uint64_t v228;
  int v229;
  int v230;
  uint64_t *v231;
  uint64_t v232;
  int v233;
  const char *v235;
  const char *v236;
  const char *v237;
  const char *v238;
  const char *v239;
  const char *v240;
  uint64_t v241;
  char v242;
  uint64_t v243;
  unint64_t v244;
  uint64_t v245;
  char v246;
  uint32x2_t *v247;
  uint32x2_t *v248;
  unint64_t v249;
  unsigned int v250;
  unint64_t v251;
  uint64_t v252;
  unint64_t v253;
  _DWORD *v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  _QWORD *v259;
  unint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t *v264;
  uint64_t v265;
  uint64_t v266;
  unint64_t v267;
  uint64_t *v268;
  __int128 v269;
  unint64_t v270;
  uint64_t *v271;
  uint64_t *v272;
  uint64_t *v273;
  uint64_t *v274;
  int v275;
  char *v276;
  uint64_t *v277;
  uint64_t *v278[2];

  v3 = a1;
  v276 = 0;
  v277 = 0;
  v275 = 0;
  v273 = 0;
  v274 = 0;
  v271 = 0;
  v272 = 0;
  v269 = 0uLL;
  v270 = 0;
  v267 = 0;
  v268 = 0;
  v265 = 0;
  v266 = 0;
  v4 = a1[47];
  v5 = spaceman_get(a1, (uint64_t *)&v277);
  if ((_DWORD)v5)
  {
    v6 = v5;
    log_err("%s:%d: %s unable to get spaceman: %d\n", "nx_check", 70, (const char *)(v3[48] + 208), v5);
    return v6;
  }
  v7 = (uint32x2_t *)v277[47];
  v8 = obj_xid((uint64_t)v277);
  v9 = v7[4].i32[0];
  v256 = v4;
  v10 = *(_DWORD *)(v4 + 36);
  if (v9 != v10)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman block size %d doesn't match nx superblock block size %d\n", "nx_check", 78, (const char *)(v3[48] + 208), v9, v10);
    v9 = v7[4].i32[0];
  }
  v242 = a2;
  v11 = v7[4].i32[1];
  LODWORD(v12) = v9;
  if (v11 != 8 * v9)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman blocks per chunk is bad: %d\n", "nx_check", 82, (const char *)(v3[48] + 208), v11);
    LODWORD(v12) = v7[4].i32[0];
  }
  v13 = v12 + 0x1FFFFFFFD8;
  v14 = v13 >> 5;
  v15 = v7[5].i32[0];
  if (v15 == (v13 >> 5))
  {
    v12 = v12;
  }
  else
  {
    ++v275;
    log_warn("%s:%d: %s spaceman chunks per cib is bad: %d\n", "nx_check", 86, (const char *)(v3[48] + 208), v15);
    v12 = v7[4].u32[0];
  }
  v260 = v12 + 0x7FFFFFFD8;
  v16 = (unint64_t)(v12 + 0x7FFFFFFD8) >> 3;
  v17 = v7[5].i32[1];
  v250 = v16;
  if (v17 != (_DWORD)v16)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman cibs per cab is bad: %d\n", "nx_check", 90, (const char *)(v3[48] + 208), v17);
  }
  v18 = (8 * v9);
  v19 = v7[6];
  v20 = *(_QWORD *)&v7[12] + *(_QWORD *)&v19;
  v21 = *(_QWORD *)(v256 + 40);
  if (v20 != v21)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman block count %lld doesn't match nx superblock block count %lld\n", "nx_check", 94, (const char *)(v3[48] + 208), v20, v21);
    v19 = v7[6];
  }
  v22 = v7[7];
  if (*(_QWORD *)&v19 % v18)
    v23 = *(_QWORD *)&v19 / v18 + 1;
  else
    v23 = *(_QWORD *)&v19 / v18;
  if (*(_QWORD *)&v22 != v23)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman chunk count is bad: %lld\n", "nx_check", 97, (const char *)(v3[48] + 208), *(_QWORD *)&v22);
    v22 = v7[7];
  }
  v24 = v7[8].u32[0];
  v25 = (v13 >> 5);
  v249 = v25;
  if (*(_QWORD *)&v22 % v25)
    v26 = *(_QWORD *)&v22 / v25 + 1;
  else
    v26 = *(_QWORD *)&v22 / v25;
  if (v26 != v24)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman cib count is bad: %d\n", "nx_check", 100, (const char *)(v3[48] + 208), v24);
    LODWORD(v24) = v7[8].i32[0];
  }
  v27 = v24 / v250;
  if (v24 % v250)
    ++v27;
  if (v27 == 1)
    v28 = 0;
  else
    v28 = v27;
  v29 = v7[8].i32[1];
  if (v29 != v28)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman cab count is bad: %d\n", "nx_check", 109, (const char *)(v3[48] + 208), v29);
  }
  v30 = v7[9];
  v31 = v7[6];
  if (*(_QWORD *)&v30 > *(_QWORD *)&v31)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman free count is too large: %lld > %lld\n", "nx_check", 112, (const char *)(v3[48] + 208), *(_QWORD *)&v30, *(_QWORD *)&v31);
  }
  v33 = v7[12];
  v32 = v7[13];
  if (*(_QWORD *)&v33 % v18)
    v34 = *(_QWORD *)&v33 / v18 + 1;
  else
    v34 = *(_QWORD *)&v33 / v18;
  if (*(_QWORD *)&v32 != v34)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman tier2 chunk count is bad: %lld\n", "nx_check", 116, (const char *)(v3[48] + 208), *(_QWORD *)&v32);
    v32 = v7[13];
  }
  v35 = v7[14].u32[0];
  if (*(_QWORD *)&v32 % v249)
    v36 = *(_QWORD *)&v32 / v249 + 1;
  else
    v36 = *(_QWORD *)&v32 / v249;
  if (v36 != v35)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman tier2 cib count is bad: %d\n", "nx_check", 119, (const char *)(v3[48] + 208), v35);
    LODWORD(v35) = v7[14].i32[0];
  }
  v37 = v35 / v250;
  if (v35 % v250)
    ++v37;
  if (v37 == 1)
    v38 = 0;
  else
    v38 = v37;
  v39 = v7[14].i32[1];
  if (v39 != v38)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman tier2 cab count is bad: %d\n", "nx_check", 128, (const char *)(v3[48] + 208), v39);
  }
  v40 = v7[15];
  v41 = v7[12];
  if (*(_QWORD *)&v40 > *(_QWORD *)&v41)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman tier2 free count is too large: %lld > %lld\n", "nx_check", 131, (const char *)(v3[48] + 208), *(_QWORD *)&v40, *(_QWORD *)&v41);
  }
  v42 = vaddvq_s64((int64x2_t)vaddl_u32(v7[8], v7[14])) + *(_QWORD *)&v7[7] + *(_QWORD *)&v7[13];
  v43 = *(_QWORD *)&v7[19] & 0x7FFFFFFFFFFFFFFFLL;
  if (v43 != 3 * v42)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman IP block count is bad: %lld\n", "nx_check", 137, (const char *)(v3[48] + 208), v43);
    v43 = *(_QWORD *)&v7[19] & 0x7FFFFFFFFFFFFFFFLL;
  }
  v44 = v7[20].u32[0];
  if ((v7[4].u32[0] + 8 * ((unint64_t)(v43 + 63) >> 6) - 1) / v7[4].u32[0] != v44)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman IP bm block count is bad: %d\n", "nx_check", 140, (const char *)(v3[48] + 208), v44);
  }
  v45 = v7[20].i32[1] & 0x7FFFFFFF;
  if (v45 >= 0xFFFF)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman IP bitmap block count is too large: %d\n", "nx_check", 143, (const char *)(v3[48] + 208), v45);
  }
  v46 = v7[18].u32[1];
  if (v46 <= 3)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman IP bitmap tx multiplier is too small: %d\n", "nx_check", 146, (const char *)(v3[48] + 208), v46);
  }
  v47 = v7[20].u32[0];
  v48 = v7[20].i32[1] & 0x7FFFFFFF;
  if (v48 / v47 <= 3)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman IP bitmap block count per tx is too small: %d\n", "nx_check", 149, (const char *)(v3[48] + 208), v48 / v47);
    v47 = v7[20].u32[0];
    v48 = v7[20].i32[1] & 0x7FFFFFFF;
  }
  v49 = v7[18].u32[1];
  if (v48 != v49 * v47)
  {
    v50 = 65534;
    if (v48 != 65534)
    {
      ++v275;
      log_warn("%s:%d: %s spaceman IP bitmap block count is bad: %d\n", "nx_check", 156, (const char *)(v3[48] + 208), v48);
      v47 = v7[20].u32[0];
      v49 = v7[18].u32[1];
      v50 = v7[20].i32[1] & 0x7FFFFFFF;
    }
    if (v50 / v47 < v49 >> 1)
    {
      ++v275;
      log_warn("%s:%d: %s spaceman IP bitmap block count is too low: %d\n", "nx_check", 159, (const char *)(v3[48] + 208), v50);
    }
  }
  v51 = v7[6];
  v52 = v7[21];
  if (!*(_QWORD *)&v52 || *(_QWORD *)&v52 >= *(_QWORD *)&v51)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman IP bm base address is bad: %lld\n", "nx_check", 166, (const char *)(v3[48] + 208), *(_QWORD *)&v52);
  }
  v53 = v7[22];
  if (!*(_QWORD *)&v53 || *(_QWORD *)&v53 >= *(_QWORD *)&v51)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman IP base address is bad: %lld\n", "nx_check", 169, (const char *)(v3[48] + 208), *(_QWORD *)&v53);
  }
  v262 = v42;
  v253 = v8;
  v247 = v7;
  if (v7[20].i32[0])
  {
    v54 = 0;
    v244 = 0;
    do
    {
      v55 = v277;
      v56 = *(_QWORD *)(v277[108] + 8 * v54);
      if (v56 > v8)
      {
        ++v275;
        log_warn("%s:%d: %s spaceman IP bitmap block %d xid %lld > spaceman xid %lld\n", "nx_check", 176, (const char *)(v3[48] + 208), v54, v56, v8);
        v55 = v277;
      }
      v57 = *(unsigned __int16 *)(v55[109] + 2 * v54);
      if ((v7[20].i32[1] & 0x7FFFFFFFu) <= v57)
      {
        ++v275;
        log_warn("%s:%d: %s spaceman IP bitmap block %d index %d out of range\n", "nx_check", 179, (const char *)(v3[48] + 208), v54, v57);
        v57 = *(unsigned __int16 *)(v277[109] + 2 * v54);
      }
      v58 = spaceman_ip_bm_block_address((uint64_t)v3, (uint64_t)v7, v57, &v267);
      if (v58
        || (v58 = obj_get(v3[49], 0x40000000u, v267, (int *)&sm_bm_desc, 0, 0, 0, 0, (uint64_t *)&v272)) != 0)
      {
        ++v275;
        log_warn("%s:%d: %s spaceman IP bitmap unable to get bitmap block %d @ %lld: %d\n", "nx_check", 187, (const char *)(v3[48] + 208), v54, v267, v58);
      }
      else
      {
        if (v54 == v7[20].i32[0] - 1)
          v59 = (*(_QWORD *)&v7[19] & 0x7FFFFFFFFFFFFFFFuLL) % (8 * v7[4].i32[0]);
        else
          v59 = (8 * v7[4].i32[0]);
        v244 += bitmap_count_bits(v272[7], 0, 0, v59);
        obj_release(v272);
      }
      ++v54;
    }
    while (v54 < v7[20].u32[0]);
  }
  else
  {
    v244 = 0;
  }
  v60 = v42;
  v61 = *(_QWORD *)&v7[7] + 2 * v42 + *(_QWORD *)&v7[13] - 1;
  if (v244 > v61)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman IP bitmap has too many free blocks %lld > %lld\n", "nx_check", 196, (const char *)(v3[48] + 208), v244, v61);
  }
  v62 = v7[40].u16[0];
  v63 = v7[20].i32[1];
  LODWORD(v64) = v63 & 0x7FFFFFFF;
  if ((v63 & 0x7FFFFFFFu) <= v62)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman IP bitmap free head %d out of range\n", "nx_check", 201, (const char *)(v3[48] + 208), v62);
    v63 = v7[20].i32[1];
    LODWORD(v64) = v63 & 0x7FFFFFFF;
  }
  v65 = v7[40].u16[1];
  if (v64 > v65
    || (++v275,
        log_warn("%s:%d: %s spaceman IP bitmap free head %d out of range\n", "nx_check", 204, (const char *)(v3[48] + 208), v65), v63 = v7[20].i32[1], LODWORD(v64) = v63 & 0x7FFFFFFF, (v63 & 0x7FFFFFFF) != 0))
  {
    v66 = 0;
    v67 = 0;
    v68 = v277[110];
    do
    {
      v69 = *(unsigned __int16 *)(v68 + 2 * v66);
      v70 = v69 == 0xFFFF || v64 > v69;
      if (!v70)
      {
        ++v275;
        log_warn("%s:%d: %s spaceman IP bitmap free next %d, value %d invalid\n", "nx_check", 209, (const char *)(v3[48] + 208), v66, v69);
        v63 = v7[20].i32[1];
        v68 = v277[110];
        v69 = *(unsigned __int16 *)(v68 + 2 * v66);
      }
      v64 = v63 & 0x7FFFFFFF;
      if (v64 > v69)
        ++v67;
      ++v66;
    }
    while (v66 < v64);
  }
  else
  {
    v67 = 0;
  }
  v71 = v7;
  v72 = v7[40].u16[0];
  if (v72 == 0xFFFF)
    v73 = v67;
  else
    v73 = v67 + 1;
  v74 = (v64 - v7[20].i32[0]);
  if (v73 != v74)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman IP bitmap next array free count is wrong, %lld != %d\n", "nx_check", 224, (const char *)(v3[48] + 208), v73, v74);
    v63 = v7[20].i32[1];
    v72 = v7[40].u16[0];
  }
  v75 = v63 & 0x7FFFFFFF;
  if (v75 && v75 > v72)
  {
    v76 = 0;
    do
    {
      ++v76;
      v72 = *(unsigned __int16 *)(v277[110] + 2 * v72);
    }
    while (v76 < v75 && v75 > v72);
    v73 -= v76;
  }
  if (v73 < 0)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman IP bitmap free list corrupted, too long, count %lld\n");
  }
  else if (v73)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman IP bitmap free list corrupted, too short, count %lld\n");
  }
  v78 = (unint64_t)v7[25];
  v79 = *(_QWORD *)&v7[19] & 0x7FFFFFFFFFFFFFFFLL;
  if (v78 > v79)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman IP free queue count is too large: %lld > %lld\n", "nx_check", 244, (const char *)(v3[48] + 208), v78, v79);
  }
  if (v7[26])
  {
    v80 = spaceman_fq_tree_get((uint64_t)v3, (uint64_t)v277, 0, 0, 0, (uint64_t *)&v271);
    if (v80)
    {
      ++v275;
      log_warn("%s:%d: %s unable to get spaceman IP free queue tree: %d\n", "nx_check", 252, (const char *)(v3[48] + 208), v80);
    }
    else if (v271)
    {
      v151 = btree_check(v271, 0, 0, 0);
      if (v151)
      {
        v152 = v151;
        ++v275;
        log_warn("%s:%d: %s spaceman IP free queue tree sanity check failed: %d\n", "nx_check", 256, (const char *)(v3[48] + 208), v151);
        v266 = 0x1000000008;
      }
      else
      {
        v266 = 0x1000000008;
        v152 = bt_lookup_first((uint64_t)v271, 0, &v269, (_DWORD *)&v266 + 1, &v270, (unsigned int *)&v266);
      }
      v178 = 0;
      v81 = 0;
      for (i = 0;
            !v152;
            v152 = bt_lookup_variant((uint64_t)v271, 0, (unint64_t *)&v269, (unsigned int *)&v266 + 1, HIDWORD(v266), &v270, (unsigned int *)&v266, 4u, 0, 0))
      {
        if ((_DWORD)v266)
        {
          v180 = v270;
        }
        else
        {
          v270 = 1;
          v180 = 1;
        }
        v181 = v269;
        if ((unint64_t)v269 > v253)
        {
          ++v275;
          log_warn("%s:%d: %s spaceman IP free queue tree entry %lld:%lld xid larger than spaceman xid %lld\n", "nx_check", 269, (const char *)(v3[48] + 208), (_QWORD)v269, *((_QWORD *)&v269 + 1), v253);
          v181 = v269;
        }
        if (v181 >= v178)
        {
          v182 = *((_QWORD *)&v269 + 1);
          if (v181 == v178)
          {
            if (*((uint64_t *)&v269 + 1) < i)
            {
              ++v275;
              log_warn("%s:%d: %s spaceman IP free queue tree entries out of order: addr %lld < %lld\n", "nx_check", 277, (const char *)(v3[48] + 208), *((_QWORD *)&v269 + 1), i);
              v182 = *((_QWORD *)&v269 + 1);
            }
            i = v270 + v182;
          }
          else
          {
            i = 0;
            v178 = v181;
          }
        }
        else
        {
          ++v275;
          log_warn("%s:%d: %s spaceman IP free queue tree entries out of order: xid %lld < %lld\n", "nx_check", 272, (const char *)(v3[48] + 208), v181, v178);
          i = 0;
          v182 = *((_QWORD *)&v269 + 1);
          v178 = v269;
        }
        v183 = spaceman_ip_block_index((uint64_t)v3, (uint64_t)v277, v182, &v265);
        if (v183)
        {
          ++v275;
          if (v183 == 2)
            log_warn("%s:%d: %s spaceman IP free queue tree entry %lld:%lld %lld addr is bad\n");
          else
            log_warn("%s:%d: %s error getting IP block index for spaceman IP free queue tree entry %lld:%lld %lld\n");
        }
        if (v270 >= 2)
        {
          v184 = spaceman_ip_block_index((uint64_t)v3, (uint64_t)v277, v270 + *((_QWORD *)&v269 + 1) - 1, &v265);
          if (v184)
          {
            ++v275;
            if (v184 == 2)
              log_warn("%s:%d: %s spaceman IP free queue tree entry %lld:%lld %lld end addr is bad\n");
            else
              log_warn("%s:%d: %s error getting end block index for spaceman IP free queue tree entry %lld:%lld %lld\n");
          }
        }
        v81 += v180;
        LODWORD(v266) = 8;
      }
      if (v152 != 2)
      {
        ++v275;
        log_warn("%s:%d: %s spaceman IP free queue tree iteration aborted with error %d\n", "nx_check", 304, (const char *)(v3[48] + 208), v152);
      }
      obj_release(v271);
      v71 = v247;
      v60 = v262;
      goto LABEL_127;
    }
  }
  v81 = 0;
LABEL_127:
  v82 = v71[25];
  if (v81 != *(_QWORD *)&v82)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman IP free queue count %lld doesn't match count in the free queue: %lld\n", "nx_check", 310, (const char *)(v3[48] + 208), *(_QWORD *)&v82, v81);
  }
  v83 = 0;
  v84 = 0;
  v258 = 0;
  v259 = v3;
  v243 = 2 * v60;
  v85 = (v260 >> 3);
  v86 = 1;
  v245 = v81;
  v87 = v253;
  v251 = v85;
  do
  {
    v88 = &v71[6 * v83];
    v90 = v88[8].i32[0];
    v89 = v88 + 8;
    v246 = v86;
    if (v90)
    {
      v91 = 0;
      v261 = 0;
      v263 = 0;
      v255 = v83;
      v92 = &v71[6 * v83];
      v254 = (_DWORD *)&v92[8] + 1;
      v248 = v92 + 7;
      v93 = 0xFFFFFFFFLL;
      while (1)
      {
        if (!*v254)
        {
          v257 = v93;
          v98 = v277;
          v99 = (unint64_t *)(v277[v83 + 111] + 8 * v91);
          goto LABEL_157;
        }
        if (v91 / v85 == v93 && v84 != 0)
          goto LABEL_156;
        v95 = v91 / v85;
        v96 = *(_QWORD *)(v277[v83 + 111] + 8 * v95);
        if (v274)
        {
          obj_release(v274);
          v274 = 0;
        }
        v97 = obj_get(v3[49], 0x40000000u, v96, (int *)&sm_cab_desc, 0, 0, 0, 0, (uint64_t *)&v274);
        if (v97)
        {
          ++v275;
          log_warn("%s:%d: %s unable to read cab %d @ %lld: %d\n", "nx_check", 332, (const char *)(v3[48] + 208), v95, v96, v97);
          v93 = v95;
          v87 = v253;
          v85 = v251;
        }
        else
        {
          v100 = v274[7];
          v101 = *(unsigned int *)(v100 + 36);
          if (v101 <= ((unint64_t)obj_size_phys((uint64_t)v274) - 40) >> 3)
          {
            if (obj_xid((uint64_t)v274) > v253)
            {
              ++v275;
              v102 = (const char *)(v3[48] + 208);
              v103 = obj_xid((uint64_t)v274);
              log_warn("%s:%d: %s cab %d xid %lld > spaceman xid %lld\n", "nx_check", 344, v102, v95, v103, v253);
            }
            v104 = *(_DWORD *)(v100 + 32);
            v93 = v95;
            if (v104 != (_DWORD)v95)
            {
              ++v275;
              log_warn("%s:%d: %s cab %d index %d should be %d\n", "nx_check", 347, (const char *)(v3[48] + 208), v95, v104, v95);
              v93 = v95;
            }
            v105 = *(_DWORD *)(v100 + 36);
            v83 = v255;
            if (v105 != v250 && (*v254 - 1 != (_DWORD)v93 || v105 != v89->i32[0] % v250))
            {
              ++v275;
              v106 = v250;
              if (*v254 - 1 == (_DWORD)v93)
                v106 = v89->i32[0] % v250;
              log_warn("%s:%d: %s cab %d cib count %d should be %d\n", "nx_check", 352, (const char *)(v3[48] + 208), v93, v105, v106);
              v93 = v95;
            }
            v84 = v100;
            v87 = v253;
            v85 = v251;
LABEL_156:
            v257 = v93;
            v99 = (unint64_t *)(v84 + 8 * (v91 - v93 * v250) + 40);
            v98 = v277;
LABEL_157:
            v107 = *v99;
            v108 = spaceman_ip_block_index((uint64_t)v3, (uint64_t)v98, *v99, &v265);
            if (v108)
            {
              ++v275;
              if (v108 == 2)
                log_warn("%s:%d: %s spaceman chunk info block %lld addr %lld not within IP block range\n");
              else
                log_warn("%s:%d: %s error getting IP block index for spaceman chunk info block %lld addr %lld\n");
            }
            v109 = obj_get(v3[49], 0x40000000u, v107, (int *)&sm_cib_desc, 0, 0, 0, 0, (uint64_t *)&v273);
            if (v109)
            {
              ++v275;
              log_warn("%s:%d: %s unable to read cib %lld @ %lld: %d\n", "nx_check", 369, (const char *)(v3[48] + 208), v91, v107, v109);
LABEL_216:
              v93 = v257;
              goto LABEL_217;
            }
            if (obj_xid((uint64_t)v273) > v87)
            {
              ++v275;
              v110 = (const char *)(v3[48] + 208);
              v111 = obj_xid((uint64_t)v273);
              log_warn("%s:%d: %s cib %lld xid %lld > spaceman xid %lld\n", "nx_check", 374, v110, v91, v111, v87);
            }
            v112 = v273[7];
            v113 = *(unsigned int *)(v112 + 32);
            if (v91 != v113)
            {
              ++v275;
              log_warn("%s:%d: %s cib %lld index %d should be %lld\n", "nx_check", 378, (const char *)(v3[48] + 208), v91, v113, v91);
            }
            v114 = *(unsigned int *)(v112 + 36);
            v115 = v14;
            if ((_DWORD)v114 != (_DWORD)v14)
            {
              if (v91 != v89->i32[0] - 1 || (v115 = *(_DWORD *)(v112 + 36), *(_QWORD *)v248 % v249 != v114))
              {
                ++v275;
                v116 = v249;
                if (v91 == v89->i32[0] - 1)
                  v116 = *(_QWORD *)v248 % v249;
                log_warn("%s:%d: %s cib %lld chunk info count %d should be %lld\n", "nx_check", 383, (const char *)(v3[48] + 208), v91, v114, v116);
                v115 = *(_DWORD *)(v112 + 36);
              }
              if (v115 > v14)
              {
                ++v275;
                log_warn("%s:%d: %s cib %lld cib_chunk_info_count %d invalid\n", "nx_check", 387, (const char *)(v3[48] + 208), v107, v115);
                v115 = *(_DWORD *)(v112 + 36);
              }
            }
            v252 = v84;
            if (v115 >= v14)
              v117 = v14;
            else
              v117 = v115;
            if (!v117)
            {
LABEL_215:
              obj_release(v273);
              v84 = v252;
              v87 = v253;
              v85 = v251;
              v83 = v255;
              goto LABEL_216;
            }
            v118 = 0;
            v119 = v18 * (unint64_t)v249 * v91;
            v120 = (unint64_t *)(v112 + 64);
            while (2)
            {
              v121 = *(v120 - 3);
              if (v121 > obj_xid((uint64_t)v273))
              {
                ++v275;
                v122 = (const char *)(v3[48] + 208);
                v123 = *(v120 - 3);
                v124 = obj_xid((uint64_t)v273);
                v241 = v123;
                v3 = v259;
                log_warn("%s:%d: %s cib %lld chunk info %d xid %lld > cib xid %lld\n", "nx_check", 392, v122, v91, v118, v241, v124);
              }
              v125 = *(v120 - 2);
              if (v119 != v125)
              {
                ++v275;
                log_warn("%s:%d: %s cib %lld chunk info %d addr %lld should be %lld\n", "nx_check", 396, (const char *)(v3[48] + 208), v91, v118, v125, v119);
              }
              v126 = *(_DWORD *)(v120 - 1) & 0xFFFFF;
              if ((_DWORD)v126 != (_DWORD)v18
                && (v91 != v89->i32[0] - 1 || v118 != *(_DWORD *)(v112 + 36) - 1 || *(_QWORD *)&v89[-2] % v18 != v126))
              {
                ++v275;
                log_warn("%s:%d: %s cib %lld chunk info %d block count %d should be %d\n");
                goto LABEL_209;
              }
              if ((*((_DWORD *)v120 - 1) & 0xFFFFFu) > v126)
              {
                ++v275;
                log_warn("%s:%d: %s cib %lld chunk info %d free count %d > chunk block count %d\n", "nx_check", 407, (const char *)(v3[48] + 208), v91, v118, *((_DWORD *)v120 - 1) & 0xFFFFF, *(_DWORD *)(v120 - 1) & 0xFFFFF);
              }
              if (*v120)
              {
                v127 = spaceman_ip_block_index((uint64_t)v3, (uint64_t)v277, *v120, &v265);
                if (v127)
                {
                  ++v275;
                  if (v127 == 2)
                    log_warn("%s:%d: %s cib %lld ci %d bm addr %lld not within IP block range\n");
                  else
                    log_warn("%s:%d: %s error getting IP block index for cib %lld ci %d bm addr %lld\n");
                  goto LABEL_209;
                }
                if (obj_get(v3[49], 0x40000000u, *v120, (int *)&sm_bm_desc, 0, 0, 0, 0, (uint64_t *)&v272))
                {
                  ++v275;
                  log_warn("%s:%d: %s cib %lld chunk %d unable to get bitmap block @ %lld: %d\n");
                  goto LABEL_209;
                }
                v128 = bitmap_count_bits(v272[7], 0, 0, *(_DWORD *)(v120 - 1) & 0xFFFFF);
              }
              else
              {
                ++v258;
                v128 = *(_DWORD *)(v120 - 1) & 0xFFFFFLL;
              }
              v129 = *((_DWORD *)v120 - 1) & 0xFFFFF;
              if (v128 != v129)
              {
                ++v275;
                log_warn("%s:%d: %s cib %lld ci %d free count %d doesn't match free bits in bitmap block %lld\n", "nx_check", 429, (const char *)(v3[48] + 208), v91, v118, *((_DWORD *)v120 - 1) & 0xFFFFF, v128);
                v129 = *((_DWORD *)v120 - 1) & 0xFFFFF;
              }
              v261 += v128;
              v263 += v129;
              v130 = *(_QWORD *)(v256 + 1248);
              if (v130)
              {
                v131 = *(_QWORD *)(v256 + 1240);
                v132 = __clz(__rbit64(*(unsigned int *)(v3[47] + 36)));
                if (v255 == ((v131 << v132) & 0x4000000000000000uLL) >> 62)
                {
                  v278[0] = 0;
                  v133 = calc_overlap_range(*(v120 - 2), *(_DWORD *)(v120 - 1) & 0xFFFFF, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v132) & v131, v130, (unint64_t *)v278);
                  if (v133)
                  {
                    if (*v120)
                      v133 = bitmap_count_bits(v272[7], 0, (uint64_t)v278[0] - *(v120 - 2), (uint64_t)v278[0] + v133 - *(v120 - 2));
                    v261 -= v133;
                    v263 -= v133;
                  }
                }
              }
              if (*v120)
                obj_release(v272);
LABEL_209:
              ++v118;
              LODWORD(v134) = *(_DWORD *)(v112 + 36);
              if (v134 >= v14)
                v134 = v14;
              else
                v134 = v134;
              v119 += v18;
              v120 += 4;
              if (v118 >= v134)
                goto LABEL_215;
              continue;
            }
          }
          ++v275;
          log_warn("%s:%d: %s cab %d @ %lld cab_cib_count %d invalid\n", "nx_check", 337, (const char *)(v3[48] + 208), v95, v96, *(_DWORD *)(v100 + 36));
          v93 = v95;
          v85 = v251;
          v91 = v91 + v251 - 1 + ~((v91 + v251 - 1) % v251);
          v83 = v255;
          v84 = v100;
          v87 = v253;
        }
LABEL_217:
        if (++v91 >= v89->u32[0])
          goto LABEL_220;
      }
    }
    v261 = 0;
    v263 = 0;
LABEL_220:
    if (v274)
    {
      obj_release(v274);
      v274 = 0;
    }
    v71 = v247;
    v135 = &v247[6 * v83];
    v138 = v135[9];
    v137 = v135 + 9;
    v136 = (uint64_t)v138;
    v139 = v263;
    if (v263 != *(_QWORD *)&v138)
    {
      ++v275;
      log_warn("%s:%d: %s spaceman free count %lld doesn't match free count in chunks %lld\n", "nx_check", 469, (const char *)(v3[48] + 208), v136, v263);
      v139 = (uint64_t)*v137;
    }
    if (v261 != v139)
    {
      ++v275;
      log_warn("%s:%d: %s spaceman free count %lld doesn't match free count in bitmap %lld\n", "nx_check", 472, (const char *)(v3[48] + 208), v139, v261);
    }
    v86 = 0;
    v83 = 1;
  }
  while ((v246 & 1) != 0);
  if (v245 + v244 != v258 + v243)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman IP free block count is wrong %lld != %lld\n", "nx_check", 477, (const char *)(v3[48] + 208), v245 + v244, v258 + v243);
  }
  v140 = v247[30];
  v141 = v247[6];
  if (*(_QWORD *)&v140 > *(_QWORD *)&v141)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman free queue count is too large: %lld > %lld\n", "nx_check", 482, (const char *)(v3[48] + 208), *(_QWORD *)&v140, *(_QWORD *)&v141);
  }
  if (!*(_QWORD *)&v247[31])
    goto LABEL_234;
  v142 = spaceman_fq_tree_get((uint64_t)v3, (uint64_t)v277, 1u, 0, 0, (uint64_t *)&v271);
  if (v142)
  {
    ++v275;
    log_warn("%s:%d: %s unable to get spaceman free queue tree: %d\n", "nx_check", 490, (const char *)(v3[48] + 208), v142);
    goto LABEL_234;
  }
  if (v271)
  {
    v153 = btree_check(v271, 0, 0, 0);
    if (v153)
    {
      v154 = v153;
      ++v275;
      log_warn("%s:%d: %s spaceman free queue tree sanity check failed: %d\n", "nx_check", 494, (const char *)(v3[48] + 208), v153);
      v266 = 0x1000000008;
    }
    else
    {
      v266 = 0x1000000008;
      v154 = bt_lookup_first((uint64_t)v271, 0, &v269, (_DWORD *)&v266 + 1, &v270, (unsigned int *)&v266);
    }
    v185 = 0;
    v143 = 0;
    for (j = 0;
          !v154;
          v154 = bt_lookup_variant((uint64_t)v271, 0, (unint64_t *)&v269, (unsigned int *)&v266 + 1, HIDWORD(v266), &v270, (unsigned int *)&v266, 4u, 0, 0))
    {
      if ((_DWORD)v266)
      {
        v187 = v270;
      }
      else
      {
        v270 = 1;
        v187 = 1;
      }
      v188 = v269;
      if ((unint64_t)v269 > v253)
      {
        ++v275;
        log_warn("%s:%d: %s spaceman free queue tree entry %lld:%lld xid larger than spaceman xid %lld\n", "nx_check", 507, (const char *)(v3[48] + 208), (_QWORD)v269, *((_QWORD *)&v269 + 1), v253);
        v188 = v269;
      }
      if (v188 >= v185)
      {
        v189 = *((_QWORD *)&v269 + 1);
        if (v188 == v185)
        {
          if (*((uint64_t *)&v269 + 1) < j)
          {
            ++v275;
            log_warn("%s:%d: %s spaceman free queue tree entries out of order: addr %lld < %lld\n", "nx_check", 515, (const char *)(v3[48] + 208), *((_QWORD *)&v269 + 1), j);
            v189 = *((_QWORD *)&v269 + 1);
          }
          j = v270 + v189;
        }
        else
        {
          j = 0;
          v185 = v188;
        }
      }
      else
      {
        ++v275;
        log_warn("%s:%d: %s spaceman free queue tree entries out of order: xid %lld < %lld\n", "nx_check", 510, (const char *)(v3[48] + 208), v188, v185);
        j = 0;
        v189 = *((_QWORD *)&v269 + 1);
        v185 = v269;
      }
      if (v189 < 1 || (v190 = (unint64_t)v247[6], v189 >= v190))
      {
        ++v275;
        log_warn("%s:%d: %s spaceman free queue tree entry %lld:%lld %lld addr is bad\n", "nx_check", 524, (const char *)(v3[48] + 208), (_QWORD)v269, v189, v270);
        v190 = (unint64_t)v247[6];
        v189 = *((_QWORD *)&v269 + 1);
      }
      v70 = v190 > v270;
      v191 = v190 - v270;
      if (!v70 || v189 > v191)
      {
        ++v275;
        log_warn("%s:%d: %s spaceman free queue tree entry %lld:%lld %lld range is bad\n", "nx_check", 527, (const char *)(v3[48] + 208), (_QWORD)v269, v189, v270);
      }
      v143 += v187;
      LODWORD(v266) = 8;
    }
    if (v154 != 2)
    {
      ++v275;
      log_warn("%s:%d: %s spaceman free queue tree iteration aborted with error %d\n", "nx_check", 534, (const char *)(v3[48] + 208), v154);
    }
    obj_release(v271);
    v87 = v253;
    v71 = v247;
  }
  else
  {
LABEL_234:
    v143 = 0;
  }
  v144 = v71[30];
  if (v143 != *(_QWORD *)&v144)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman free queue count %lld doesn't match count in the free queue: %lld\n", "nx_check", 540, (const char *)(v3[48] + 208), *(_QWORD *)&v144, v143);
  }
  v145 = v71[35];
  v146 = v71[12];
  if (*(_QWORD *)&v145 > *(_QWORD *)&v146)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman free queue count is too large: %lld > %lld\n", "nx_check", 544, (const char *)(v3[48] + 208), *(_QWORD *)&v145, *(_QWORD *)&v146);
  }
  if (!*(_QWORD *)&v71[36])
    goto LABEL_242;
  v147 = spaceman_fq_tree_get((uint64_t)v3, (uint64_t)v277, 2u, 0, 0, (uint64_t *)&v271);
  if (v147)
  {
    ++v275;
    log_warn("%s:%d: %s unable to get spaceman free queue tree: %d\n", "nx_check", 552, (const char *)(v3[48] + 208), v147);
    goto LABEL_242;
  }
  if (v271)
  {
    v155 = btree_check(v271, 0, 0, 0);
    if (v155)
    {
      v156 = v155;
      ++v275;
      log_warn("%s:%d: %s spaceman free queue tree sanity check failed: %d\n", "nx_check", 556, (const char *)(v3[48] + 208), v155);
      v266 = 0x1000000008;
    }
    else
    {
      v266 = 0x1000000008;
      v156 = bt_lookup_first((uint64_t)v271, 0, &v269, (_DWORD *)&v266 + 1, &v270, (unsigned int *)&v266);
    }
    v192 = 0;
    v148 = 0;
    for (k = 0;
          !v156;
          v156 = bt_lookup_variant((uint64_t)v271, 0, (unint64_t *)&v269, (unsigned int *)&v266 + 1, HIDWORD(v266), &v270, (unsigned int *)&v266, 4u, 0, 0))
    {
      if ((_DWORD)v266)
      {
        v194 = v270;
      }
      else
      {
        v270 = 1;
        v194 = 1;
      }
      v195 = v269;
      if ((unint64_t)v269 > v253)
      {
        ++v275;
        log_warn("%s:%d: %s spaceman free queue tree entry %lld:%lld xid larger than spaceman xid %lld\n", "nx_check", 569, (const char *)(v3[48] + 208), (_QWORD)v269, *((_QWORD *)&v269 + 1), v253);
        v195 = v269;
      }
      if (v195 >= v192)
      {
        v196 = *((_QWORD *)&v269 + 1);
        if (v195 == v192)
        {
          if (*((uint64_t *)&v269 + 1) < k)
          {
            ++v275;
            log_warn("%s:%d: %s spaceman free queue tree entries out of order: addr %lld < %lld\n", "nx_check", 577, (const char *)(v3[48] + 208), *((_QWORD *)&v269 + 1), k);
            v196 = *((_QWORD *)&v269 + 1);
          }
          k = v270 + v196;
        }
        else
        {
          k = 0;
          v192 = v195;
        }
      }
      else
      {
        ++v275;
        log_warn("%s:%d: %s spaceman free queue tree entries out of order: xid %lld < %lld\n", "nx_check", 572, (const char *)(v3[48] + 208), v195, v192);
        k = 0;
        v196 = *((_QWORD *)&v269 + 1);
        v192 = v269;
      }
      v197 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(v3[47] + 36)))) & v196;
      if (v197 < 1 || (v198 = (unint64_t)v247[12], v197 >= v198))
      {
        ++v275;
        log_warn("%s:%d: %s spaceman free queue tree entry %lld:%lld %lld addr is bad\n", "nx_check", 587, (const char *)(v3[48] + 208), (_QWORD)v269, v196, v270);
        v198 = (unint64_t)v247[12];
      }
      v70 = v198 > v270;
      v199 = v198 - v270;
      if (!v70 || v197 > v199)
      {
        ++v275;
        log_warn("%s:%d: %s spaceman free queue tree entry %lld:%lld %lld range is bad\n", "nx_check", 590, (const char *)(v3[48] + 208), (_QWORD)v269, *((_QWORD *)&v269 + 1), v270);
      }
      v148 += v194;
      LODWORD(v266) = 8;
    }
    if (v156 != 2)
    {
      ++v275;
      log_warn("%s:%d: %s spaceman free queue tree iteration aborted with error %d\n", "nx_check", 597, (const char *)(v3[48] + 208), v156);
    }
    obj_release(v271);
    v87 = v253;
    v71 = v247;
  }
  else
  {
LABEL_242:
    v148 = 0;
  }
  v149 = v71[35];
  if (v148 != *(_QWORD *)&v149)
  {
    ++v275;
    log_warn("%s:%d: %s spaceman free queue count %lld doesn't match count in the free queue: %lld\n", "nx_check", 603, (const char *)(v3[48] + 208), *(_QWORD *)&v149, v148);
  }
  if (*(_QWORD *)(v256 + 168))
  {
    v150 = nx_reaper_get(v3, &v276);
    if ((_DWORD)v150)
    {
      v6 = v150;
      log_err("%s:%d: %s unable to get reaper: %d\n");
      goto LABEL_386;
    }
    v157 = *((_QWORD *)v276 + 47);
    v158 = *(_QWORD *)(v157 + 32);
    if (*(_QWORD *)(v157 + 40) >= v158)
    {
      log_warn("%s:%d: %s reaper completed ID 0x%llx not less than next reap ID 0x%llx\n", "nx_check_reaper", 958, (const char *)(v3[48] + 208), *(_QWORD *)(v157 + 40), v158);
      v159 = 1;
    }
    else
    {
      v159 = 0;
    }
    v160 = *(_DWORD *)(v157 + 64);
    if ((v160 & 1) == 0)
    {
      ++v159;
      log_warn("%s:%d: %s reaper needs more cowbell, flags 0x%x\n", "nx_check_reaper", 961, (const char *)(v3[48] + 208), v160);
    }
    v161 = *(_QWORD *)(v157 + 48);
    if (!v161)
    {
      if (!*(_QWORD *)(v157 + 56)
        || (++v159,
            log_warn("%s:%d: %s reaper has tail with no head\n", "nx_check_reaper", 965, (const char *)(v3[48] + 208)),
            (v161 = *(_QWORD *)(v157 + 48)) == 0))
      {
LABEL_378:
        v275 += v159;
        obj_release((uint64_t *)v276);
        v87 = v253;
        goto LABEL_379;
      }
    }
    v278[0] = 0;
    v162 = *(_DWORD *)(v157 + 68);
    while (2)
    {
      v163 = obj_get(v3[49], 0x80000000, v161, (int *)&nx_reap_list_desc, 0, 0, 0, 0, (uint64_t *)v278);
      if ((_DWORD)v163)
      {
        v6 = v163;
        log_err("%s:%d: %s failed to get reap list head: %d\n", "nx_check_reaper", 974, (const char *)(v3[48] + 208), v163);
        obj_release((uint64_t *)v276);
        log_err("%s:%d: %s reaper check failed with error: %d\n");
        goto LABEL_386;
      }
      v164 = v278[0][47];
      v165 = *(_DWORD *)(v164 + 44);
      if (v165 != (((unint64_t)obj_size_phys((uint64_t)v278[0]) - 64) / 0x28))
      {
        ++v159;
        v166 = (const char *)(v259[48] + 208);
        v167 = *(_DWORD *)(v164 + 44);
        v168 = obj_size_phys((uint64_t)v278[0]);
        log_warn("%s:%d: %s reap list object 0x%llx max record count %u not expected value %u\n", "nx_check_reaper", 981, v166, v161, v167, ((unint64_t)v168 - 64) / 0x28);
      }
      v169 = *(_DWORD *)(v164 + 44);
      if (*(_DWORD *)(v164 + 48) <= v169)
      {
        v3 = v259;
      }
      else
      {
        ++v159;
        v3 = v259;
        log_warn("%s:%d: %s reap list object 0x%llx record count %d larger than max %d\n", "nx_check_reaper", 984, (const char *)(v259[48] + 208), v161, *(_DWORD *)(v164 + 48), v169);
      }
      v170 = *(_DWORD *)(v164 + 52);
      if (v170 != -1)
      {
        v171 = *(_DWORD *)(v164 + 44);
        if (v170 > v171)
        {
          ++v159;
          log_warn("%s:%d: %s reap list object 0x%llx first index %u larger than max %u\n", "nx_check_reaper", 987, (const char *)(v3[48] + 208), v161, *(_DWORD *)(v164 + 52), v171);
        }
      }
      v172 = *(_DWORD *)(v164 + 56);
      if (v172 != -1)
      {
        v173 = *(_DWORD *)(v164 + 44);
        if (v172 > v173)
        {
          ++v159;
          log_warn("%s:%d: %s reap list object 0x%llx last index %u larger than max %u\n", "nx_check_reaper", 990, (const char *)(v3[48] + 208), v161, *(_DWORD *)(v164 + 52), v173);
        }
      }
      v174 = *(_DWORD *)(v164 + 60);
      if (v174 != -1)
      {
        v175 = *(_DWORD *)(v164 + 44);
        if (v174 > v175)
        {
          ++v159;
          log_warn("%s:%d: %s reap list object 0x%llx free index %u larger than max %u\n", "nx_check_reaper", 993, (const char *)(v3[48] + 208), v161, *(_DWORD *)(v164 + 60), v175);
        }
      }
      v176 = *(_QWORD *)(v164 + 32);
      v177 = *(_QWORD *)(v157 + 56);
      if (v176)
      {
LABEL_283:
        if (v177 == v161)
        {
          if (!v176)
            goto LABEL_287;
          ++v159;
          log_warn("%s:%d: %s reap list tail 0x%llx is not last reap list object, next 0x%llx\n", "nx_check_reaper", 1005, (const char *)(v3[48] + 208), v161, v176);
          v161 = *(_QWORD *)(v164 + 32);
        }
        else
        {
          v161 = v176;
        }
      }
      else
      {
        if (v177 != v161)
        {
          ++v159;
          log_warn("%s:%d: %s last reap list object 0x%llx doesn't match tail 0x%llx\n", "nx_check_reaper", 1002, (const char *)(v3[48] + 208), v161, v177);
          v177 = *(_QWORD *)(v157 + 56);
          v176 = *(_QWORD *)(v164 + 32);
          goto LABEL_283;
        }
LABEL_287:
        v161 = 0;
      }
      obj_release(v278[0]);
      if (*(_DWORD *)(v157 + 68))
      {
        --v162;
        if (v161 && !v162)
        {
          ++v159;
          log_warn("%s:%d: %s reap list expected %u objects, but haven't seen last reap list object yet\n");
          goto LABEL_378;
        }
        if (!v161 && v162)
        {
          ++v159;
          log_warn("%s:%d: %s reap list expected %u objects, but got last reap list object with %u more objects left\n");
          goto LABEL_378;
        }
      }
      if (!v161)
        goto LABEL_378;
      continue;
    }
  }
LABEL_379:
  v200 = v256;
  v201 = *(_QWORD *)(v256 + 160);
  if (!v201)
    goto LABEL_387;
  v202 = obj_get(v3[49], 0x40000000u, v201, (int *)&om_desc, 0, 0, 0, 0, (uint64_t *)&v268);
  if ((_DWORD)v202)
  {
    v6 = v202;
    log_err("%s:%d: %s unable to get omap: %d\n");
    goto LABEL_386;
  }
  if (obj_xid((uint64_t)v268) > v87)
  {
    ++v275;
    v203 = v3[48] + 208;
    v204 = obj_xid((uint64_t)v268);
    v235 = (const char *)v203;
    v3 = v259;
    log_warn("%s:%d: %s omap xid %lld > spaceman xid %lld\n", "nx_check", 633, v235, v204, v87);
  }
  v6 = nx_check_omap((uint64_t)v3, (uint64_t)v268, v87, &v275);
  obj_release(v268);
  v200 = v256;
  if (!(_DWORD)v6)
  {
LABEL_387:
    v278[0] = 0;
    v264 = 0;
    if (!*(_DWORD *)(v200 + 180))
    {
LABEL_448:
      obj_release(v277);
      if (v275)
        return 22;
      else
        return 0;
    }
    v205 = 0;
    while (1)
    {
      v206 = *(_QWORD *)(v256 + 184 + 8 * v205);
      if (v206)
      {
        v207 = obj_get(v3[49], 0, v206, (int *)&apfs_desc, 0, 0, 0, 0, (uint64_t *)v278);
        if (v207)
        {
          log_err("%s:%d: %s unable to get fs[%d] oid %lld, %d\n", "nx_check", 654, (const char *)(v3[48] + 208), v205, v206, v207);
        }
        else
        {
          v208 = v278[0];
          v209 = v278[0][47];
          v210 = *(_QWORD *)(v209 + 128);
          if (!v210)
            goto LABEL_398;
          v211 = obj_get(v3[49], 0x40000000u, v210, (int *)&om_desc, 0, (uint64_t)v278[0], 0, 0, (uint64_t *)&v268);
          if (v211)
          {
            log_err("%s:%d: %s unable to get omap %lld: %d\n", "nx_check", 661, (const char *)v278[0] + 3880, *(_QWORD *)(v278[0][47] + 128), v211);
            goto LABEL_446;
          }
          v212 = nx_check_omap((uint64_t)v278[0], (uint64_t)v268, v253, &v275);
          obj_release(v268);
          v208 = v278[0];
          if (!v212)
          {
            v209 = v278[0][47];
LABEL_398:
            if (*(_QWORD *)(v209 + 136))
            {
              if ((*(_BYTE *)(v209 + 264) & 1) != 0 || (v242 & 1) != 0)
              {
                v264 = 0;
                fsroot_tree = apfs_get_fsroot_tree((uint64_t)v208, 0, 0, (uint64_t *)&v264);
                if (fsroot_tree)
                {
                  log_err("%s:%d: %s unable to get fs root tree: %d\n", "nx_check", 680, (const char *)v278[0] + 3880, fsroot_tree);
                }
                else
                {
                  if (obj_xid((uint64_t)v264) > v253)
                  {
                    ++v275;
                    v214 = v278[0] + 485;
                    v215 = obj_xid((uint64_t)v264);
                    v236 = (const char *)v214;
                    v3 = v259;
                    log_warn("%s:%d: %s fs root tree xid %lld > spaceman xid %lld\n", "nx_check", 683, v236, v215, v253);
                  }
                  v216 = btree_check(v264, 0, 0, 0);
                  if (v216)
                  {
                    ++v275;
                    log_warn("%s:%d: %s fs root tree sanity check failed: %d\n", "nx_check", 688, (const char *)v278[0] + 3880, v216);
                  }
                }
                if (v264)
                  obj_release(v264);
              }
              else
              {
                log_err("%s:%d: %s skipping check of fs[%d] oid %lld fs root tree because it's encrypted\n", "nx_check", 675, (const char *)v208 + 3880, v205, v206);
              }
            }
            v217 = *(_QWORD *)(v278[0][47] + 144);
            if (v217)
            {
              v264 = 0;
              extentref_tree = apfs_get_extentref_tree((uint64_t)v278[0], v217, 0, (uint64_t *)&v264);
              if (extentref_tree)
              {
                log_err("%s:%d: %s unable to get fs extentref tree: %d\n", "nx_check", 700, (const char *)v278[0] + 3880, extentref_tree);
              }
              else
              {
                if (obj_xid((uint64_t)v264) > v253)
                {
                  ++v275;
                  v219 = v278[0] + 485;
                  v220 = obj_xid((uint64_t)v264);
                  v237 = (const char *)v219;
                  v3 = v259;
                  log_warn("%s:%d: %s fs extentref tree xid %lld > spaceman xid %lld\n", "nx_check", 703, v237, v220, v253);
                }
                v221 = btree_check(v264, 0, 0, 0);
                if (v221)
                {
                  ++v275;
                  log_warn("%s:%d: %s fs extentref tree sanity check failed: %d\n", "nx_check", 708, (const char *)v278[0] + 3880, v221);
                }
              }
              if (v264)
                obj_release(v264);
            }
            if (*(_QWORD *)(v278[0][47] + 152))
            {
              v264 = 0;
              snap_meta_tree = apfs_get_snap_meta_tree((uint64_t)v278[0], 0, (uint64_t *)&v264);
              if (snap_meta_tree)
              {
                log_err("%s:%d: %s unable to get fs snap meta tree: %d\n", "nx_check", 719, (const char *)v278[0] + 3880, snap_meta_tree);
              }
              else
              {
                if (obj_xid((uint64_t)v264) > v253)
                {
                  ++v275;
                  v223 = v278[0] + 485;
                  v224 = obj_xid((uint64_t)v264);
                  v238 = (const char *)v223;
                  v3 = v259;
                  log_warn("%s:%d: %s fs snap meta tree xid %lld > spaceman xid %lld\n", "nx_check", 722, v238, v224, v253);
                }
                v225 = btree_check(v264, 0, 0, 0);
                if (v225)
                {
                  ++v275;
                  log_warn("%s:%d: %s fs snap meta tree sanity check failed: %d\n", "nx_check", 727, (const char *)v278[0] + 3880, v225);
                }
              }
              if (v264)
                obj_release(v264);
            }
            if (*(_QWORD *)(v278[0][47] + 1072))
            {
              v264 = 0;
              doc_id_tree = apfs_get_doc_id_tree((uint64_t)v278[0], 0, 0, 0, (uint64_t *)&v264);
              if (doc_id_tree)
              {
                log_err("%s:%d: %s unable to get doc-id tree: %d\n", "nx_check", 738, (const char *)v278[0] + 3880, doc_id_tree);
              }
              else
              {
                if (obj_xid((uint64_t)v264) > v253)
                {
                  ++v275;
                  v227 = v278[0] + 485;
                  v228 = obj_xid((uint64_t)v264);
                  v239 = (const char *)v227;
                  v3 = v259;
                  log_warn("%s:%d: %s doc-id tree xid %lld > spaceman xid %lld\n", "nx_check", 741, v239, v228, v253);
                }
                v229 = btree_check(v264, 0, 0, 0);
                if (v229)
                {
                  ++v275;
                  log_warn("%s:%d: %s doc-id tree sanity check failed: %d\n", "nx_check", 746, (const char *)v278[0] + 3880, v229);
                }
              }
              if (v264)
                obj_release(v264);
            }
            if (*(_QWORD *)(v278[0][47] + 1080))
            {
              v264 = 0;
              v230 = apfs_get_doc_id_tree((uint64_t)v278[0], 1, 0, 0, (uint64_t *)&v264);
              if (v230)
              {
                log_err("%s:%d: %s unable to get prev doc-id tree: %d\n", "nx_check", 757, (const char *)v278[0] + 3880, v230);
              }
              else
              {
                if (obj_xid((uint64_t)v264) > v253)
                {
                  ++v275;
                  v231 = v278[0] + 485;
                  v232 = obj_xid((uint64_t)v264);
                  v240 = (const char *)v231;
                  v3 = v259;
                  log_warn("%s:%d: %s prev doc-id tree xid %lld > spaceman xid %lld\n", "nx_check", 760, v240, v232, v253);
                }
                v233 = btree_check(v264, 0, 0, 0);
                if (v233)
                {
                  ++v275;
                  log_warn("%s:%d: %s prev doc-id tree sanity check failed: %d\n", "nx_check", 765, (const char *)v278[0] + 3880, v233);
                }
              }
              if (v264)
                obj_release(v264);
            }
LABEL_446:
            obj_release(v278[0]);
            goto LABEL_447;
          }
          log_err("%s:%d: %s omap check failed for omap %lld: %d\n", "nx_check", 668, (const char *)v278[0] + 3880, *(_QWORD *)(v278[0][47] + 128), v212);
          obj_release(v278[0]);
        }
      }
LABEL_447:
      if (++v205 >= (unint64_t)*(unsigned int *)(v256 + 180))
        goto LABEL_448;
    }
  }
  log_err("%s:%d: %s omap check failed with error: %d\n");
LABEL_386:
  obj_release(v277);
  return v6;
}

uint64_t nx_check_omap(uint64_t a1, uint64_t a2, unint64_t a3, int *a4)
{
  _QWORD *v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t extended;
  const char *v13;
  const char *v14;
  uint64_t v15;
  int v16;
  uint64_t v18;
  const char *v19;
  int v20;
  const char *v21;
  const char *v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  const char *v28;
  uint64_t (*v29)(uint64_t, _QWORD *, int, _QWORD *, int, int *);
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  const char *v36;
  const char *v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  _BYTE v42[12];
  const char *v43;
  unint64_t v44;
  uint64_t v45;
  _OWORD v46[4];
  uint64_t v47;
  uint64_t *v48;
  uint64_t *v49;
  uint64_t (*v50)(uint64_t, _QWORD *, int, _QWORD *, int, int *);
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v49 = 0;
  v8 = (_QWORD *)a1;
  if (obj_type(a1) == 13)
    v8 = *(_QWORD **)(a1 + 392);
  v47 = 0;
  v48 = 0;
  memset(v46, 0, sizeof(v46));
  v9 = v8[47];
  v10 = *(_DWORD *)(v9 + 36);
  if ((*(_BYTE *)(v9 + 65) & 1) != 0)
  {
    v11 = spaceman_get(v8, (uint64_t *)&v49);
    if ((_DWORD)v11)
    {
      extended = v11;
      if (obj_type(a1) == 13)
        v13 = (const char *)(a1 + 3880);
      else
        v13 = (const char *)(*(_QWORD *)(a1 + 384) + 208);
      log_err("%s:%d: %s unable to get spaceman: %d\n", "nx_check_omap", 805, v13, extended);
      return extended;
    }
  }
  if (*(_DWORD *)(*(_QWORD *)(a2 + 376) + 36) >= 0x400u)
  {
    if (obj_type(a1) == 13)
      v14 = (const char *)(a1 + 3880);
    else
      v14 = (const char *)(*(_QWORD *)(a1 + 384) + 208);
    log_warn("%s:%d: %s omap snapshot count %d seems excessive\n", "nx_check_omap", 811, v14, *(_DWORD *)(*(_QWORD *)(a2 + 376) + 36));
  }
  v15 = *(_QWORD *)(a2 + 376);
  v16 = *(_DWORD *)(v15 + 40);
  if (v16 == 1073741826 || v16 == -2147483646)
  {
    v18 = *(_QWORD *)(v15 + 48);
    v51 = 0u;
    v56 = 0;
    v55 = 0u;
    v54 = 0u;
    v53 = 0u;
    v52 = 0u;
    v50 = omap_key_cmp;
    DWORD2(v51) = 11;
    if ((unsigned __int16)v16 == 2)
    {
      extended = btree_get_extended(a1, v16 & 0xFFFF0000, v18, 0, 0, (uint64_t)&v50, 0, (uint64_t *)&v48);
      if (!(_DWORD)extended)
      {
        if (obj_xid((uint64_t)v48) <= a3)
        {
          v24 = 0;
        }
        else
        {
          if (obj_type(a1) == 13)
            v19 = (const char *)(a1 + 3880);
          else
            v19 = (const char *)(*(_QWORD *)(a1 + 384) + 208);
          v25 = obj_xid((uint64_t)v48);
          log_warn("%s:%d: %s omap tree xid %lld > spaceman xid %lld\n", "nx_check_omap", 829, v19, v25, a3);
          v24 = 1;
        }
        v26 = btree_check(v48, 0, 0, 0);
        if (v26)
        {
          v27 = v26;
          ++v24;
          if (obj_type(a1) == 13)
            v28 = (const char *)(a1 + 3880);
          else
            v28 = (const char *)(*(_QWORD *)(a1 + 384) + 208);
          log_warn("%s:%d: %s omap tree sanity check failed: %d\n", "nx_check_omap", 834, v28, v27);
          goto LABEL_92;
        }
        v44 = 0;
        v45 = 0;
        v50 = 0;
        *(_QWORD *)&v51 = 0;
        bt_iterator_init_with_hint((uint64_t)v46, (uint64_t)v48, 0, 0, (unint64_t *)&v50, 16, 0x10u, &v44, 0x10u, 0);
        if (bt_iterator_ended((uint64_t)v46))
        {
LABEL_92:
          obj_release(v48);
          goto LABEL_93;
        }
        v29 = 0;
        *(_DWORD *)&v42[8] = 0;
        v43 = (const char *)(a1 + 3880);
        *(_QWORD *)v42 = v10 - 1;
        v30 = -1;
        while (1)
        {
          if ((unint64_t)v50 >= (unint64_t)v29)
          {
            v31 = v51;
            if (v50 != v29)
            {
              *(_QWORD *)&v42[4] = 0;
              v30 = -1;
              v29 = v50;
              goto LABEL_53;
            }
            if ((unint64_t)v51 <= *(_QWORD *)&v42[4])
            {
              ++v24;
              if (obj_type(a1) == 13)
                log_warn("%s:%d: %s omap tree entries out of order: oid %lld xid %lld <= lastxid %lld\n", "nx_check_omap", 853, v43, v50, (_QWORD)v51, *(_QWORD *)&v42[4]);
              else
                log_warn("%s:%d: %s omap tree entries out of order: oid %lld xid %lld <= lastxid %lld\n", "nx_check_omap", 853, (const char *)(*(_QWORD *)(a1 + 384) + 208), v50, (_QWORD)v51, *(_QWORD *)&v42[4]);
            }
          }
          else
          {
            if (obj_type(a1) == 13)
              log_warn("%s:%d: %s omap tree entries out of order: oid %lld < %lld\n", "nx_check_omap", 847, v43, v50, v29);
            else
              log_warn("%s:%d: %s omap tree entries out of order: oid %lld < %lld\n", "nx_check_omap", 847, (const char *)(*(_QWORD *)(a1 + 384) + 208), v50, v29);
            ++v24;
            v30 = -1;
            v29 = v50;
          }
          v31 = v51;
          *(_QWORD *)&v42[4] = v51;
LABEL_53:
          if (v31 > a3)
          {
            ++v24;
            if (obj_type(a1) == 13)
              log_warn("%s:%d: %s omap entry %lld:%lld xid > spaceman xid %lld\n", "nx_check_omap", 862, v43, v50, (_QWORD)v51, a3);
            else
              log_warn("%s:%d: %s omap entry %lld:%lld xid > spaceman xid %lld\n", "nx_check_omap", 862, (const char *)(*(_QWORD *)(a1 + 384) + 208), v50, (_QWORD)v51, a3);
          }
          if (v44 >= 0x800)
          {
            ++v24;
            if (obj_type(a1) == 13)
              log_warn("%s:%d: %s omap entry %lld:%lld unknown flags are set: 0x%x\n", "nx_check_omap", 865, v43, v50, (_QWORD)v51, v44 & 0xFFFFFFFE);
            else
              log_warn("%s:%d: %s omap entry %lld:%lld unknown flags are set: 0x%x\n", "nx_check_omap", 865, (const char *)(*(_QWORD *)(a1 + 384) + 208), v50, (_QWORD)v51, v44 & 0xFFFFFFFE);
          }
          if ((v44 & 1) != 0 && v30 == -1)
          {
            ++v24;
            if (obj_type(a1) == 13)
              log_warn("%s:%d: %s omap entry %lld:%lld marks deletion of object with no earlier mappings\n", "nx_check_omap", 868, v43, v50, (_QWORD)v51);
            else
              log_warn("%s:%d: %s omap entry %lld:%lld marks deletion of object with no earlier mappings\n", "nx_check_omap", 868, (const char *)(*(_QWORD *)(a1 + 384) + 208), v50, (_QWORD)v51);
          }
          else if (v30 != -1)
          {
            if (v30)
            {
              ++v24;
              if (obj_type(a1) == 13)
                log_warn("%s:%d: %s omap entry %lld:%lld beyond deletion entry @ xid %lld\n", "nx_check_omap", 873, v43, v50, (_QWORD)v51, v30);
              else
                log_warn("%s:%d: %s omap entry %lld:%lld beyond deletion entry @ xid %lld\n", "nx_check_omap", 873, (const char *)(*(_QWORD *)(a1 + 384) + 208), v50, (_QWORD)v51, v30);
            }
            else if ((v44 & 1) != 0)
            {
              v30 = v51;
            }
            else
            {
              v30 = 0;
            }
            goto LABEL_77;
          }
          if ((v44 & 1) != 0)
            v30 = v51;
          else
            v30 = 0;
LABEL_77:
          if (HIDWORD(v44) >= 0x100000)
          {
            ++v24;
            if (obj_type(a1) == 13)
              log_warn("%s:%d: %s omap entry %lld:%lld size %d seems excessive\n", "nx_check_omap", 878, v43, v50, (_QWORD)v51, HIDWORD(v44));
            else
              log_warn("%s:%d: %s omap entry %lld:%lld size %d seems excessive\n", "nx_check_omap", 878, (const char *)(*(_QWORD *)(a1 + 384) + 208), v50, (_QWORD)v51, HIDWORD(v44));
          }
          if (v49)
            v32 = v49[47];
          else
            v32 = 0;
          if (nx_superblock_sanity_check_extent(v8[47], v32, v45, (*(_DWORD *)v42 + HIDWORD(v44)) / v10, 0))
          {
            ++v24;
            if (obj_type(a1) == 13)
              log_warn("%s:%d: %s omap entry %lld:%lld addr %lld size %d is bad\n", "nx_check_omap", 883, v43, v50, (_QWORD)v51, v45, HIDWORD(v44));
            else
              log_warn("%s:%d: %s omap entry %lld:%lld addr %lld size %d is bad\n", "nx_check_omap", 883, (const char *)(*(_QWORD *)(a1 + 384) + 208), v50, (_QWORD)v51, v45, HIDWORD(v44));
          }
          bt_iterator_next((uint64_t)v46);
          if (bt_iterator_ended((uint64_t)v46))
            goto LABEL_92;
        }
      }
    }
    else
    {
      extended = 22;
    }
    if (obj_type(a1) == 13)
      v22 = (const char *)(a1 + 3880);
    else
      v22 = (const char *)(*(_QWORD *)(a1 + 384) + 208);
    log_warn("%s:%d: %s unable to get omap tree: %d\n", "nx_check_omap", 821, v22, extended);
    v23 = *a4 + 1;
    goto LABEL_106;
  }
  v20 = obj_type(a1);
  if (v20 == 13)
    v21 = (const char *)(a1 + 3880);
  else
    v21 = (const char *)(*(_QWORD *)(a1 + 384) + 208);
  log_warn("%s:%d: %s omap tree type 0x%x is bad\n", "nx_check_omap", 893, v21, *(_DWORD *)(*(_QWORD *)(a2 + 376) + 40));
  v24 = 1;
LABEL_93:
  v33 = *(_QWORD *)(a2 + 376);
  v34 = *(_QWORD *)(v33 + 56);
  if (!v34)
  {
LABEL_120:
    *a4 += v24;
    if (v49)
      obj_release(v49);
    return 0;
  }
  v35 = *(_DWORD *)(v33 + 44);
  if (v35 != 1073741826 && v35 != -2147483646)
  {
    ++v24;
    if (obj_type(a1) == 13)
      v37 = (const char *)(a1 + 3880);
    else
      v37 = (const char *)(*(_QWORD *)(a1 + 384) + 208);
    log_warn("%s:%d: %s omap snapshot tree type 0x%x is bad\n", "nx_check_omap", 935, v37, *(_DWORD *)(*(_QWORD *)(a2 + 376) + 40));
    goto LABEL_120;
  }
  v51 = 0u;
  v56 = 0;
  v55 = 0u;
  v54 = 0u;
  v53 = 0u;
  v52 = 0u;
  v50 = omap_snapshot_key_cmp;
  DWORD2(v51) = 19;
  extended = btree_get_extended(a1, v35 & 0xFFFF0000, v34, 0, 0, (uint64_t)&v50, 0, (uint64_t *)&v48);
  if (!(_DWORD)extended)
  {
    if (obj_xid((uint64_t)v48) > a3)
    {
      ++v24;
      if (obj_type(a1) == 13)
        v36 = (const char *)(a1 + 3880);
      else
        v36 = (const char *)(*(_QWORD *)(a1 + 384) + 208);
      v39 = obj_xid((uint64_t)v48);
      log_warn("%s:%d: %s omap snapshot tree xid %lld > spaceman xid %lld\n", "nx_check_omap", 911, v36, v39, a3);
    }
    if (btree_check(v48, 0, 0, 0))
    {
      ++v24;
      obj_type(a1);
      log_warn("%s:%d: %s omap snapshot tree sanity check failed: %d\n");
    }
    else
    {
      v50 = 0;
      *(_QWORD *)&v51 = 0;
      v44 = 0;
      bt_iterator_init_with_hint((uint64_t)v46, (uint64_t)v48, 0, 0, &v44, 8, 8u, &v50, 0x10u, 0);
      v40 = 0;
      if (!bt_iterator_ended((uint64_t)v46))
      {
        v40 = 0;
        do
        {
          ++v40;
          bt_iterator_next((uint64_t)v46);
        }
        while (!bt_iterator_ended((uint64_t)v46));
      }
      if (v40 != *(_DWORD *)(*(_QWORD *)(a2 + 376) + 36))
      {
        ++v24;
        obj_type(a1);
        log_warn("%s:%d: %s omap snapshot count %d doesn't match snapshot tree record count %lld\n");
      }
    }
    obj_release(v48);
    goto LABEL_120;
  }
  if (obj_type(a1) == 13)
    v38 = (const char *)(a1 + 3880);
  else
    v38 = (const char *)(*(_QWORD *)(a1 + 384) + 208);
  log_warn("%s:%d: %s unable to get omap snapshot tree: %d\n", "nx_check_omap", 903, v38, extended);
  v23 = v24 + 1 + *a4;
LABEL_106:
  *a4 = v23;
  if (v49)
    obj_release(v49);
  return extended;
}

uint64_t omap_recent_sanity_callback(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t *a4, int a5, _DWORD *a6, int a7)
{
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;

  v21 = 0;
  v22 = 0;
  v13 = obj_type(a1);
  v14 = 0;
  v15 = a1;
  if (v13 == 13)
  {
    v15 = *(_QWORD *)(a1 + 392);
    v14 = a1;
  }
  v16 = 22;
  if (a5 == 16 && a7 == 16)
  {
    v17 = a4[1];
    if (v17 <= a3)
      return 0;
    v18 = *a6;
    if ((*a6 & 5) != 0)
    {
      return 0;
    }
    else
    {
      v23 = 0;
      if ((v18 & 8) != 0)
        v20 = 536870936;
      else
        v20 = 24;
      LODWORD(v22) = a6[1];
      v16 = obj_get(*(_QWORD *)(v15 + 392), v20, *a4, (int *)&v21, 0, v14, v17, 0, (uint64_t *)&v23);
      if ((_DWORD)v16)
      {
        if (obj_type(a1) == 13)
          log_err("%s:%d: %s check of oid:xid %lld:%lld  size %d paddr 0x%llx flags 0x%x failed: %d\n", "omap_recent_sanity_callback", 1089, (const char *)(a1 + 3880), *a4, a4[1], a6[1], *((_QWORD *)a6 + 1), *a6, v16);
        else
          log_err("%s:%d: %s check of oid:xid %lld:%lld  size %d paddr 0x%llx flags 0x%x failed: %d\n", "omap_recent_sanity_callback", 1089, (const char *)(*(_QWORD *)(a1 + 384) + 208), *a4, a4[1], a6[1], *((_QWORD *)a6 + 1), *a6, v16);
      }
      else
      {
        obj_release(v23);
      }
    }
  }
  return v16;
}

uint64_t nx_check_recent_sanity(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t extentref_tree;
  uint64_t v39;
  uint64_t snap_meta_tree;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t *v49;
  uint64_t *v50;
  char *v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t *v54;

  v53 = 0;
  v54 = 0;
  v52 = 0;
  v51 = 0;
  v2 = spaceman_get(a1, (uint64_t *)&v54);
  if ((_DWORD)v2)
  {
    v3 = v2;
    log_err("%s:%d: %s unable to get spaceman: %d\n");
    return v3;
  }
  v4 = v54[47];
  v5 = obj_xid((uint64_t)v54);
  v6 = 0;
  v7 = 0;
  v8 = v5 - 3;
  if (v5 < 3)
    v8 = 0;
  v44 = v8;
  v45 = 0;
  v49 = 0;
  v50 = 0;
  v47 = 0;
  v48 = 0;
  v46 = 0;
  do
  {
    v9 = v4 + 48 * v6;
    v11 = *(_DWORD *)(v9 + 64);
    v10 = (unsigned int *)(v9 + 64);
    if (!v11)
    {
      v3 = 0;
      goto LABEL_30;
    }
    v12 = 0;
    LODWORD(v13) = -1;
    while (1)
    {
      if (!*(_DWORD *)(v4 + 48 * v6 + 68))
      {
        v18 = (unint64_t *)(v54[v6 + 111] + 8 * v12);
        goto LABEL_22;
      }
      v14 = *(unsigned int *)(v4 + 44);
      if (v12 / v14 != v13 || v7 == 0)
        break;
LABEL_20:
      v18 = (unint64_t *)(v7 + 8 * (v12 - (v14 * v13)) + 40);
LABEL_22:
      v19 = *v18;
      v45 = v4;
      v46 = __PAIR64__(v12, v6);
      v20 = obj_get(a1[49], 0x40000000u, v19, (int *)&sm_cib_desc, &v45, 0, 0, 0, (uint64_t *)&v49);
      if ((_DWORD)v20)
      {
        v22 = v20;
        log_err("%s:%d: %s unable to read cib %lld @ %lld: %d\n", "nx_check_recent_sanity", 1170, (const char *)(a1[48] + 208), v12, v19, v20);
        v3 = v22;
        goto LABEL_30;
      }
      obj_release(v49);
      v21 = 1;
LABEL_24:
      v12 += v21;
      if (v12 >= *v10)
      {
        v3 = 0;
        goto LABEL_30;
      }
    }
    v13 = v12 / v14;
    v16 = *(_QWORD *)(v54[v6 + 111] + 8 * (v12 / v14));
    if (v50)
    {
      obj_release(v50);
      v50 = 0;
    }
    v47 = v4;
    v48 = __PAIR64__(v13, v6);
    v17 = obj_get(a1[49], 0x40000000u, v16, (int *)&sm_cab_desc, &v47, 0, 0, 0, (uint64_t *)&v50);
    if (!(_DWORD)v17)
    {
      v7 = v50[7];
      if (obj_xid((uint64_t)v50) <= v44)
      {
        v21 = *(unsigned int *)(v7 + 36);
        goto LABEL_24;
      }
      LODWORD(v14) = *(_DWORD *)(v4 + 44);
      goto LABEL_20;
    }
    v3 = v17;
    log_err("%s:%d: %s unable to read cab %d @ %lld: %d\n", "nx_check_recent_sanity", 1143, (const char *)(a1[48] + 208), v13, v16, v17);
LABEL_30:
    if (v50)
    {
      obj_release(v50);
      v50 = 0;
    }
  }
  while (!(v3 | v6++));
  obj_release(v54);
  if ((_DWORD)v3)
    return v3;
  v25 = *(_QWORD *)(a1[47] + 160);
  if (v25)
  {
    v26 = obj_get(a1[49], 0x40000000u, v25, (int *)&om_desc, 0, 0, 0, 0, (uint64_t *)&v53);
    if ((_DWORD)v26)
    {
      v3 = v26;
      log_err("%s:%d: %s unable to get omap: %d\n");
      return v3;
    }
    if (obj_xid((uint64_t)v53) <= v44)
    {
      obj_release(v53);
    }
    else
    {
      v3 = nx_check_recent_sanity_omap((uint64_t)a1, (uint64_t)v53, v44);
      obj_release(v53);
      if ((_DWORD)v3)
      {
        log_err("%s:%d: %s omap check failed with error: %d\n");
        return v3;
      }
    }
  }
  v27 = a1[47];
  if (!*(_DWORD *)(v27 + 180))
    return 0;
  v28 = 0;
  while (2)
  {
    v29 = *(_QWORD *)(v27 + 8 * v28 + 184);
    if (!v29)
      goto LABEL_75;
    v30 = obj_get(a1[49], 0, v29, (int *)&apfs_desc, 0, 0, 0, 0, &v52);
    if ((_DWORD)v30)
    {
      v42 = v30;
      log_err("%s:%d: %s unable to get fs[%d] oid %lld, %d\n", "nx_check_recent_sanity", 1212, (const char *)(a1[48] + 208), v28, v29, v30);
      return v42;
    }
    v31 = obj_xid(v52);
    v32 = (uint64_t *)v52;
    if (v31 <= v44)
      goto LABEL_74;
    v33 = *(_QWORD *)(*(_QWORD *)(v52 + 376) + 128);
    if (!v33)
      goto LABEL_53;
    v34 = obj_get(a1[49], 0x40000000u, v33, (int *)&om_desc, 0, v52, 0, 0, (uint64_t *)&v53);
    if (!(_DWORD)v34)
    {
      if (obj_xid((uint64_t)v53) <= v44)
      {
        obj_release(v53);
        v32 = (uint64_t *)v52;
      }
      else
      {
        v35 = nx_check_recent_sanity_omap(v52, (uint64_t)v53, v44);
        obj_release(v53);
        v32 = (uint64_t *)v52;
        if ((_DWORD)v35)
        {
          log_err("%s:%d: %s omap check failed for omap %lld: %d\n");
          goto LABEL_80;
        }
      }
LABEL_53:
      v36 = v32[47];
      v37 = *(_QWORD *)(v36 + 144);
      if (v37)
      {
        v51 = 0;
        extentref_tree = apfs_get_extentref_tree((uint64_t)v32, v37, 0, (uint64_t *)&v51);
        if ((_DWORD)extentref_tree)
        {
          v35 = extentref_tree;
          log_err("%s:%d: %s unable to get extentref tree %lld: %d\n", "nx_check_recent_sanity", 1246, (const char *)(v52 + 3880), *(_QWORD *)(*(_QWORD *)(v52 + 376) + 144), extentref_tree);
        }
        else if (obj_xid((uint64_t)v51) <= v44)
        {
          v35 = 0;
        }
        else
        {
          v39 = btree_check_recent_sanity(v51, v44, 0, 0);
          v35 = v39;
          if ((_DWORD)v39)
            log_err("%s:%d: %s extentref tree %lld: %d\n", "nx_check_recent_sanity", 1251, (const char *)(v52 + 3880), *(_QWORD *)(*(_QWORD *)(v52 + 376) + 144), v39);
        }
        if (v51)
          obj_release((uint64_t *)v51);
        v32 = (uint64_t *)v52;
        if ((_DWORD)v35)
        {
LABEL_78:
          v43 = v32;
          goto LABEL_81;
        }
        v36 = *(_QWORD *)(v52 + 376);
      }
      if (*(_QWORD *)(v36 + 152))
      {
        v51 = 0;
        snap_meta_tree = apfs_get_snap_meta_tree((uint64_t)v32, 0, (uint64_t *)&v51);
        if ((_DWORD)snap_meta_tree)
        {
          v35 = snap_meta_tree;
          log_err("%s:%d: %s unable to get snap meta tree %lld: %d\n", "nx_check_recent_sanity", 1268, (const char *)(v52 + 3880), *(_QWORD *)(*(_QWORD *)(v52 + 376) + 152), snap_meta_tree);
        }
        else if (obj_xid((uint64_t)v51) <= v44)
        {
          v35 = 0;
        }
        else
        {
          v41 = btree_check_recent_sanity(v51, v44, 0, 0);
          v35 = v41;
          if ((_DWORD)v41)
            log_err("%s:%d: %s snap meta tree %lld: %d\n", "nx_check_recent_sanity", 1273, (const char *)(v52 + 3880), *(_QWORD *)(*(_QWORD *)(v52 + 376) + 144), v41);
        }
        if (v51)
          obj_release((uint64_t *)v51);
        v32 = (uint64_t *)v52;
        if ((_DWORD)v35)
          goto LABEL_78;
      }
LABEL_74:
      obj_release(v32);
LABEL_75:
      ++v28;
      v27 = a1[47];
      if (v28 >= *(unsigned int *)(v27 + 180))
        return 0;
      continue;
    }
    break;
  }
  v35 = v34;
  log_err("%s:%d: %s unable to get omap %lld: %d\n");
LABEL_80:
  v43 = (uint64_t *)v52;
LABEL_81:
  obj_release(v43);
  return v35;
}

uint64_t nx_check_recent_sanity_omap(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t extended;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t *v14;
  uint64_t (*v15)(uint64_t, _QWORD *, int, _QWORD *, int, int *);
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v14 = 0;
  v6 = *(_QWORD *)(a2 + 376);
  v7 = *(_QWORD *)(v6 + 48);
  if (!v7)
    goto LABEL_10;
  v8 = *(_DWORD *)(v6 + 40);
  v16 = 0u;
  v21 = 0;
  v19 = 0u;
  v20 = 0u;
  v18 = 0u;
  v17 = 0u;
  v15 = omap_key_cmp;
  DWORD2(v16) = 11;
  if ((unsigned __int16)v8 != 2)
  {
    extended = 22;
    goto LABEL_8;
  }
  extended = btree_get_extended(a1, v8 & 0xFFFF0000, v7, 0, 0, (uint64_t)&v15, 0, (uint64_t *)&v14);
  if ((_DWORD)extended)
  {
LABEL_8:
    obj_type(a1);
    log_err("%s:%d: %s unable to get omap tree: %d\n");
    return extended;
  }
  if (obj_xid((uint64_t)v14) <= a3)
  {
    obj_release(v14);
  }
  else
  {
    extended = btree_check_recent_sanity((char *)v14, a3, (uint64_t (*)(uint64_t, uint64_t, unint64_t, _QWORD, _QWORD, uint64_t, _QWORD))omap_recent_sanity_callback, 0);
    obj_release(v14);
    if ((_DWORD)extended)
      return extended;
  }
LABEL_10:
  v10 = *(_QWORD *)(a2 + 376);
  v11 = *(_QWORD *)(v10 + 56);
  if (!v11)
    return 0;
  v12 = *(_DWORD *)(v10 + 44);
  v16 = 0u;
  v21 = 0;
  v19 = 0u;
  v20 = 0u;
  v18 = 0u;
  v17 = 0u;
  v15 = omap_snapshot_key_cmp;
  DWORD2(v16) = 19;
  if ((unsigned __int16)v12 != 2)
  {
    extended = 22;
    goto LABEL_17;
  }
  extended = btree_get_extended(a1, v12 & 0xFFFF0000, v11, 0, 0, (uint64_t)&v15, 0, (uint64_t *)&v14);
  if ((_DWORD)extended)
  {
LABEL_17:
    obj_type(a1);
    log_err("%s:%d: %s unable to get omap snapshot tree: %d\n");
    return extended;
  }
  if (obj_xid((uint64_t)v14) <= a3)
    extended = 0;
  else
    extended = btree_check_recent_sanity((char *)v14, a3, 0, 0);
  obj_release(v14);
  return extended;
}

BOOL MetricsCompactor::Import(uint64_t a1, char *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v8;
  unsigned __int8 *v9;
  const char *v10;
  unint64_t *v11;
  int v12;
  _BOOL8 result;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  _DWORD *v34;
  uint64_t v35;
  int v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  unint64_t v41;
  char __str[16];
  __int128 v43;
  __int128 v44;
  int v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)(a1 + 16) = 0u;
  v8 = (uint64_t *)(a1 + 16);
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  v9 = (unsigned __int8 *)(a1 + 32);
  *(_OWORD *)a1 = xmmword_1DF2E8F20;
  *(_BYTE *)(a1 + 288) = 0;
  set_metric_default_values(a3);
  v10 = (const char *)strlen(a2);
  *(_QWORD *)(a3 + 336) = v10;
  *(_BYTE *)(a1 + 288) = Base85::Decode((Base85 *)a2, v10, (uint64_t)v9, (unsigned __int8 *)0x100, (uint64_t *)(a1 + 24), v11) ^ 1;
  v12 = MetricsCompactor::Read((MetricsCompactor *)a1);
  result = 0;
  *(_DWORD *)(a3 + 68) = v12;
  if (v12 > 11)
    return result;
  if (v12)
  {
    v14 = MetricsCompactor::Read((MetricsCompactor *)a1);
    v15 = v14 >> 1;
    if ((v14 & 1) != 0)
      v15 = -(uint64_t)v15;
    v16 = v15 + *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v16;
    *(_DWORD *)(a3 + 168) = MetricsCompactor::Read((MetricsCompactor *)a1);
    *(_DWORD *)(a3 + 152) = v16;
    if (*(int *)(a3 + 68) >= 2)
    {
      v17 = 0;
      v18 = (_DWORD *)(a3 + 72);
      do
      {
        MetricsCompactor::Read((MetricsCompactor *)a1, v18, 0);
        ++v17;
        v18 += 2;
      }
      while (v17 < *(int *)(a3 + 68) - 1);
    }
  }
  v19 = 0;
  v20 = 0;
  v21 = 0;
  *(_QWORD *)a1 = MetricsCompactor::Read((MetricsCompactor *)a1);
  do
  {
    switch((int)v19)
    {
      case 0:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 400) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 1:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 376) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 2:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 392) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 3:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 344) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 4:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 360) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 5:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 384) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 6:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 352) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 7:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 368) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 8:
        if ((*(_QWORD *)a1 & (1 << v19)) != 0)
        {
          *(_QWORD *)(a3 + 264) = MetricsCompactor::Read((MetricsCompactor *)a1);
          if ((*(_QWORD *)a1 & (1 << v19)) != 0)
            *(_QWORD *)(a3 + 256) = MetricsCompactor::Read((MetricsCompactor *)a1);
        }
        break;
      case 9:
        if ((*(_QWORD *)a1 & (1 << v19)) != 0)
        {
          *(_QWORD *)(a3 + 280) = MetricsCompactor::Read((MetricsCompactor *)a1);
          if ((*(_QWORD *)a1 & (1 << v19)) != 0)
            *(_QWORD *)(a3 + 272) = MetricsCompactor::Read((MetricsCompactor *)a1);
        }
        break;
      case 10:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 320) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 11:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 312) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 12:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 288) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 13:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
        {
          v25 = MetricsCompactor::Read((MetricsCompactor *)a1);
          v26 = v25 >> 1;
          if ((v25 & 1) != 0)
            v26 = -(uint64_t)v26;
          *(_QWORD *)(a3 + 408) = v26;
        }
        break;
      case 14:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 416) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 15:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
        {
          v27 = MetricsCompactor::Read((MetricsCompactor *)a1);
          v28 = v27 >> 1;
          if ((v27 & 1) != 0)
            v28 = -(uint64_t)v28;
          *(_QWORD *)(a3 + 424) = v28;
        }
        break;
      case 16:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
        {
          v29 = MetricsCompactor::Read((MetricsCompactor *)a1);
          v30 = v29 >> 1;
          if ((v29 & 1) != 0)
            v30 = -(uint64_t)v30;
          *(_QWORD *)(a3 + 432) = v30;
        }
        break;
      case 17:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 440) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 18:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 448) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 19:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 328) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 20:
        if ((*(_QWORD *)a1 & (1 << v19)) != 0)
        {
          v20 = MetricsCompactor::Read((MetricsCompactor *)a1);
          if ((*(_QWORD *)a1 & (1 << v19)) != 0)
            v21 = MetricsCompactor::Read((MetricsCompactor *)a1);
        }
        break;
      case 21:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 456) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 22:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 464) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 23:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 472) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 24:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 488) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 25:
        if ((*(_QWORD *)a1 & (1 << v19)) != 0)
        {
          *(_QWORD *)(a3 + 536) = MetricsCompactor::Read((MetricsCompactor *)a1);
          if ((*(_QWORD *)a1 & (1 << v19)) != 0)
            *(_QWORD *)(a3 + 560) = MetricsCompactor::Read((MetricsCompactor *)a1);
        }
        break;
      case 26:
        if ((*(_QWORD *)a1 & (1 << v19)) != 0)
        {
          *(_QWORD *)(a3 + 544) = MetricsCompactor::Read((MetricsCompactor *)a1);
          if ((*(_QWORD *)a1 & (1 << v19)) != 0)
            *(_QWORD *)(a3 + 568) = MetricsCompactor::Read((MetricsCompactor *)a1);
        }
        break;
      case 27:
        if ((*(_QWORD *)a1 & (1 << v19)) != 0)
        {
          *(_QWORD *)(a3 + 552) = MetricsCompactor::Read((MetricsCompactor *)a1);
          if ((*(_QWORD *)a1 & (1 << v19)) != 0)
            *(_QWORD *)(a3 + 576) = MetricsCompactor::Read((MetricsCompactor *)a1);
        }
        break;
      case 28:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 504) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 29:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 512) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 30:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 520) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 31:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 528) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 32:
        v22 = 1 << v19;
        if ((*(_QWORD *)a1 & (1 << v19)) != 0)
        {
          *(_QWORD *)(a3 + 584) = MetricsCompactor::Read((MetricsCompactor *)a1);
          if ((*(_QWORD *)a1 & v22) != 0)
          {
            *(_QWORD *)(a3 + 600) = MetricsCompactor::Read((MetricsCompactor *)a1);
            if ((*(_QWORD *)a1 & v22) != 0)
              *(_QWORD *)(a3 + 616) = MetricsCompactor::Read((MetricsCompactor *)a1);
          }
        }
        break;
      case 33:
        v31 = 1 << v19;
        if ((*(_QWORD *)a1 & (1 << v19)) != 0)
        {
          *(_QWORD *)(a3 + 592) = MetricsCompactor::Read((MetricsCompactor *)a1);
          if ((*(_QWORD *)a1 & v31) != 0)
          {
            *(_QWORD *)(a3 + 608) = MetricsCompactor::Read((MetricsCompactor *)a1);
            if ((*(_QWORD *)a1 & v31) != 0)
              *(_QWORD *)(a3 + 624) = MetricsCompactor::Read((MetricsCompactor *)a1);
          }
        }
        break;
      case 34:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 496) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 35:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 680) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 36:
        v23 = 1 << v19;
        if ((*(_QWORD *)a1 & (1 << v19)) != 0)
        {
          *(_QWORD *)(a3 + 688) = MetricsCompactor::Read((MetricsCompactor *)a1);
          if ((*(_QWORD *)a1 & v23) != 0)
          {
            *(_QWORD *)(a3 + 704) = MetricsCompactor::Read((MetricsCompactor *)a1);
            if ((*(_QWORD *)a1 & v23) != 0)
              *(_QWORD *)(a3 + 712) = MetricsCompactor::Read((MetricsCompactor *)a1);
          }
        }
        break;
      case 37:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 696) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 38:
        if ((*(_QWORD *)a1 & (1 << v19)) != 0)
        {
          *(_QWORD *)(a3 + 632) = MetricsCompactor::Read((MetricsCompactor *)a1);
          if ((*(_QWORD *)a1 & (1 << v19)) != 0)
            *(_QWORD *)(a3 + 640) = MetricsCompactor::Read((MetricsCompactor *)a1);
        }
        break;
      case 39:
        if ((*(_QWORD *)a1 & (1 << v19)) != 0)
        {
          *(_QWORD *)(a3 + 648) = MetricsCompactor::Read((MetricsCompactor *)a1);
          if ((*(_QWORD *)a1 & (1 << v19)) != 0)
            *(_QWORD *)(a3 + 656) = MetricsCompactor::Read((MetricsCompactor *)a1);
        }
        break;
      case 40:
        if ((*(_QWORD *)a1 & (1 << v19)) != 0)
        {
          *(_QWORD *)(a3 + 664) = MetricsCompactor::Read((MetricsCompactor *)a1);
          if ((*(_QWORD *)a1 & (1 << v19)) != 0)
            *(_QWORD *)(a3 + 672) = MetricsCompactor::Read((MetricsCompactor *)a1);
        }
        break;
      case 41:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 304) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 42:
        if (((*(_QWORD *)a1 >> v19) & 1) != 0)
          *(_QWORD *)(a3 + 296) = MetricsCompactor::Read((MetricsCompactor *)a1);
        break;
      case 44:
        v24 = 1 << v19;
        if ((*(_QWORD *)a1 & (1 << v19)) != 0)
        {
          *(_QWORD *)(a3 + 720) = MetricsCompactor::Read((MetricsCompactor *)a1);
          if ((*(_QWORD *)a1 & v24) != 0)
          {
            *(_QWORD *)(a3 + 728) = MetricsCompactor::Read((MetricsCompactor *)a1);
            if ((*(_QWORD *)a1 & v24) != 0)
              *(_QWORD *)(a3 + 736) = MetricsCompactor::Read((MetricsCompactor *)a1);
          }
        }
        break;
      default:
        break;
    }
    ++v19;
  }
  while (v19 != 46);
  if ((*(_BYTE *)(a1 + 5) & 0x20) != 0)
  {
    if (!a4)
      return 0;
    MetricsCompactor::Read((MetricsCompactor *)a1, a4);
  }
  v32 = MetricsCompactor::Read((MetricsCompactor *)a1);
  *(_DWORD *)(a3 + 24) = v32;
  if (v32 > 5)
    return 0;
  if (v32 >= 1)
  {
    v33 = 0;
    v34 = (_DWORD *)(a3 + 28);
    do
    {
      MetricsCompactor::Read((MetricsCompactor *)a1, v34, 1);
      ++v33;
      v34 += 2;
    }
    while (v33 < *(int *)(a3 + 24));
  }
  if ((*(_BYTE *)(a1 + 2) & 0x10) != 0)
  {
    v45 = 0;
    v43 = 0u;
    v44 = 0u;
    *(_OWORD *)__str = 0u;
    snprintf(__str, 0x34uLL, "/dev/rdisk%llus%llu", v20, v21);
LABEL_136:
    *(_QWORD *)(a3 + 160) = strdup(__str);
    goto LABEL_137;
  }
  memset(__str, 0, sizeof(__str));
  *(_QWORD *)&v43 = 0;
  if ((MetricsCompactor::Read(a1, (uint64_t)__str) & 1) == 0)
  {
    if (SBYTE7(v43) < 0)
      operator delete(*(void **)__str);
    return 0;
  }
  if (SBYTE7(v43) < 0)
  {
    if (*(_QWORD *)&__str[8])
      *(_QWORD *)(a3 + 160) = strdup(*(const char **)__str);
    operator delete(*(void **)__str);
    goto LABEL_137;
  }
  if (BYTE7(v43))
    goto LABEL_136;
LABEL_137:
  if ((*(_BYTE *)(a1 + 5) & 8) == 0)
    return *(_BYTE *)(a1 + 288) == 0;
  v35 = *v8;
  if (*v8)
  {
    v36 = 0;
    do
    {
      v36 ^= *v9;
      v37 = 8;
      do
      {
        v38 = (char)v36;
        v39 = 2 * v36;
        v36 = (2 * v36) ^ 0x12;
        if (v38 >= 0)
          v36 = v39;
        --v37;
      }
      while (v37);
      ++v9;
      --v35;
    }
    while (v35);
    v40 = v36 >> 1;
  }
  else
  {
    v40 = 0;
  }
  v41 = MetricsCompactor::Read((MetricsCompactor *)a1);
  result = 0;
  if (v41 <= 0x7F && v41 == v40)
    return *(_BYTE *)(a1 + 288) == 0;
  return result;
}

void sub_1DF2C8768(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MetricsCompactor::Read(MetricsCompactor *this)
{
  uint64_t v2;
  uint64_t result;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v2 = 0;
  result = 0;
  v5 = *((_QWORD *)this + 2);
  v4 = *((_QWORD *)this + 3);
  if (v5 > v4)
    v4 = *((_QWORD *)this + 2);
  while (1)
  {
    if (v4 == v5)
    {
      *((_BYTE *)this + 288) = 1;
      return result;
    }
    *((_QWORD *)this + 2) = v5 + 1;
    v6 = *((unsigned __int8 *)this + v5 + 32);
    if (v2 == 56)
      break;
    result |= (v6 & 0x7F) << v2;
    v2 += 7;
    ++v5;
    if ((v6 & 0x80) == 0)
      return result;
  }
  return result | (v6 << 56);
}

unint64_t MetricsCompactor::Read(MetricsCompactor *a1, _DWORD *a2, int a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t result;
  unint64_t v10;

  v6 = MetricsCompactor::Read(a1);
  v7 = v6 >> 1;
  if ((v6 & 1) != 0)
    v7 = -(uint64_t)v7;
  v8 = v7 + *((_QWORD *)a1 + 1);
  *((_QWORD *)a1 + 1) = v8;
  *a2 = v8;
  result = MetricsCompactor::Read(a1);
  v10 = result >> 1;
  if ((result & 1) != 0)
    v10 = -(uint64_t)v10;
  if (!a3)
    LODWORD(v10) = result;
  a2[1] = v10;
  return result;
}

uint64_t MetricsCompactor::Read(MetricsCompactor *a1, _QWORD *a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  unsigned int v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = MetricsCompactor::Read(a1);
  v5 = 0;
  v16 = 0;
  v15 = 0;
  do
  {
    *((_BYTE *)&v15 + v5++) = v4 % 0x54;
    v4 /= 0x54uLL;
  }
  while (v5 != 10);
  v6 = 0;
  v7 = 0;
  for (i = 0; i != 10; ++i)
  {
    v9 = *((unsigned __int8 *)&v15 + i);
    if (*((_BYTE *)&v15 + i))
    {
      v10 = MetricsCompactor::Read(a1);
      v11 = v10 >> 1;
      if ((v10 & 1) != 0)
        v11 = -(uint64_t)v11;
      v7 += v11;
      v6 += MetricsCompactor::Read(a1);
      if (v9 <= 0x53)
      {
        v12 = &a2[3 * v9 - 3];
        *v12 = v7;
        v12[1] = v6;
      }
    }
  }
  v13 = MetricsCompactor::Read(a1);
  a2[255] = v13;
  if (v13)
  {
    a2[256] = MetricsCompactor::Read(a1) << 20;
    a2[257] = 1000000000 * MetricsCompactor::Read(a1);
  }
  result = MetricsCompactor::Read(a1);
  a2[258] = result;
  if (result)
  {
    a2[259] = MetricsCompactor::Read(a1) << 20;
    result = MetricsCompactor::Read(a1);
    a2[260] = 1000000000 * result;
  }
  return result;
}

uint64_t MetricsCompactor::Read(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t result;
  unint64_t v7;
  char *v8;
  unint64_t v9;
  int v10;

  v4 = MetricsCompactor::Read((MetricsCompactor *)a1);
  v5 = *(_QWORD *)(a1 + 16);
  if (v4 > *(_QWORD *)(a1 + 24) - v5)
  {
LABEL_2:
    result = 0;
    *(_BYTE *)(a1 + 288) = 1;
    return result;
  }
  v7 = v4;
  if (v4)
  {
    v8 = (char *)(v5 + a1 + 32);
    v9 = v4;
    do
    {
      v10 = *v8++;
      if (v10 <= 31)
        goto LABEL_2;
    }
    while (--v9);
  }
  MEMORY[0x1E0BFCD5C](a2, a1 + v5 + 32, v4);
  *(_QWORD *)(a1 + 16) += v7;
  return 1;
}

BOOL MetricsCompactor_Import(char *a1, uint64_t a2)
{
  _OWORD v3[18];
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v4 = 0;
  memset(v3, 0, sizeof(v3));
  return MetricsCompactor::Import((uint64_t)v3, a1, a2, 0);
}

uint64_t io_get_device_block_size(int a1)
{
  int *v2;
  char *v3;
  stat v5;
  unsigned int v6;
  statfs v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  memset(&v5, 0, sizeof(v5));
  bzero(&v7, 0x878uLL);
  if (!ioctl(a1, 0x40046418uLL, &v6))
    return v6;
  if (!fstatfs(a1, &v7))
    return v7.f_bsize;
  if (!fstat(a1, &v5))
    return v5.st_blksize;
  v2 = __error();
  v3 = strerror(*v2);
  log_err("%s:%d: can't get the device block size (%s). assuming 512\n", "io_get_device_block_size", 56, v3);
  return 512;
}

uint64_t dev_block_size(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 72))();
}

uint64_t dev_block_count(uint64_t a1)
{
  uint64_t v2;

  if (*(_QWORD *)(a1 + 80))
    v2 = dev_block_count();
  else
    v2 = 0;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 72) + 8))(a1) + v2;
}

uint64_t dev_barrier(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 80);
  if (v4)
    v5 = dev_barrier(v4, a2);
  else
    v5 = 0;
  LODWORD(result) = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 72) + 80))(a1, a2);
  if ((_DWORD)result)
    return result;
  else
    return v5;
}

uint64_t dev_unmap(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    while (1)
    {
      v4 = v3;
      v5 = *(_QWORD *)(v2 + 88);
      if ((v5 & a2) == 0)
        break;
      a2 &= ~v5;
      v3 = *(_QWORD *)(v4 + 80);
      v2 = v4;
      if (!v3)
        return (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 72) + 88))();
    }
  }
  v4 = v2;
  return (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 72) + 88))();
}

uint64_t dev_unmap_flush(uint64_t a1)
{
  unsigned int v2;
  uint64_t result;

  if (*(_QWORD *)(a1 + 80))
    v2 = dev_unmap_flush();
  else
    v2 = 0;
  LODWORD(result) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 72) + 104))(a1);
  if ((_DWORD)result)
    return result;
  else
    return v2;
}

uint64_t dev_close(uint64_t a1)
{
  unsigned int v2;
  uint64_t result;

  if (*(_QWORD *)(a1 + 80))
    v2 = dev_close();
  else
    v2 = 0;
  LODWORD(result) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 72) + 112))(a1);
  if ((_DWORD)result)
    return result;
  else
    return v2;
}

uint64_t dev_real_block_size(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 72) + 120))();
}

uint64_t dev_set_block_size(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 72) + 128))();
}

uint64_t dev_is_writable(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 72) + 136))();
}

uint64_t dev_is_external(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 72) + 144))();
}

BOOL dev_is_solidstate(uint64_t a1)
{
  return *(_DWORD *)(a1 + 116) != 0;
}

uint64_t dev_read(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    while (1)
    {
      v4 = v3;
      v5 = *(_QWORD *)(v2 + 88);
      if ((v5 & a2) == 0)
        break;
      a2 &= ~v5;
      v3 = *(_QWORD *)(v4 + 80);
      v2 = v4;
      if (!v3)
        return (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 72) + 24))();
    }
  }
  v4 = v2;
  return (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 72) + 24))();
}

uint64_t dev_read_async(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(void);
  uint64_t v14;
  uint64_t v15;
  void (*v16)(uint64_t);

  v7 = a1;
  v8 = *(_QWORD *)(a1 + 80);
  if (v8)
  {
    while (1)
    {
      v9 = v8;
      v10 = *(_QWORD *)(v7 + 88);
      if ((v10 & a2) == 0)
        break;
      a2 &= ~v10;
      v8 = *(_QWORD *)(v9 + 80);
      v7 = v9;
      if (!v8)
        goto LABEL_6;
    }
  }
  v9 = v7;
LABEL_6:
  v11 = *(_QWORD *)(v9 + 72);
  v12 = *(uint64_t (**)(void))(v11 + 32);
  if (v12)
    return v12();
  v14 = (*(uint64_t (**)(void))(v11 + 24))();
  v15 = v14;
  v16 = *(void (**)(uint64_t))a6;
  if (*(_QWORD *)a6)
  {
    *(_DWORD *)(a6 + 96) = v14;
    v16(a6);
  }
  return v15;
}

uint64_t dev_read_extended(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(void);

  v9 = a1;
  v10 = *(_QWORD *)(a1 + 80);
  if (v10)
  {
    while (1)
    {
      v11 = v10;
      v12 = *(_QWORD *)(v9 + 88);
      if ((v12 & a2) == 0)
        break;
      a2 &= ~v12;
      v10 = *(_QWORD *)(v11 + 80);
      v9 = v11;
      if (!v10)
      {
        if (!a9)
          goto LABEL_8;
        goto LABEL_5;
      }
    }
  }
  v11 = v9;
  if (a9)
  {
LABEL_5:
    v13 = *(uint64_t (**)(void))(*(_QWORD *)(v11 + 72) + 40);
    if (v13)
      return v13();
    else
      return 45;
  }
  else
  {
LABEL_8:
    if (a6)
      return dev_read_async(v11, a2, a3, a4, a5, a7);
    else
      return (*(uint64_t (**)(void))(*(_QWORD *)(v11 + 72) + 24))();
  }
}

uint64_t dev_read_finish(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 72) + 48))();
}

uint64_t dev_read_poll(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 72) + 56);
  if (v1)
    return v1();
  else
    return 45;
}

uint64_t dev_write(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    while (1)
    {
      v4 = v3;
      v5 = *(_QWORD *)(v2 + 88);
      if ((v5 & a2) == 0)
        break;
      a2 &= ~v5;
      v3 = *(_QWORD *)(v4 + 80);
      v2 = v4;
      if (!v3)
        return (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 72) + 64))();
    }
  }
  v4 = v2;
  return (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 72) + 64))();
}

uint64_t dev_write_extended(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(void);

  v7 = a1;
  v8 = *(_QWORD *)(a1 + 80);
  if (v8)
  {
    while (1)
    {
      v9 = v8;
      v10 = *(_QWORD *)(v7 + 88);
      if ((v10 & a2) == 0)
        break;
      a2 &= ~v10;
      v8 = *(_QWORD *)(v9 + 80);
      v7 = v9;
      if (!v8)
        goto LABEL_6;
    }
  }
  v9 = v7;
LABEL_6:
  v11 = *(_QWORD *)(v9 + 72);
  if (!a7)
    return (*(uint64_t (**)(void))(v11 + 64))();
  v12 = *(uint64_t (**)(void))(v11 + 72);
  if (v12)
    return v12();
  else
    return 45;
}

uint64_t dev_features(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 72) + 16))();
}

uint64_t fd_dev_read_poll(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = aio_error((const aiocb *)(a2 + 8));
  if ((_DWORD)result == -1)
    return *__error();
  return result;
}

uint64_t fd_dev_block_size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 100);
}

uint64_t fd_dev_block_count(uint64_t a1)
{
  return *(_QWORD *)(a1 + 128);
}

uint64_t fd_dev_features(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  if (a2)
    *a2 = a1[26];
  if (a3)
    *a3 = a1[27];
  if (a4)
    *a4 = a1[28];
  if (a5)
    *a5 = a1[29];
  return 0;
}

uint64_t fd_dev_read_async(int *a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return fd_dev_read_async_helper(a1, a2, a3, a4, a5, a7);
}

uint64_t fd_dev_read_extended(uint64_t a1, unint64_t a2, unint64_t a3, void *a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  uint64_t v9;

  if ((a9 & 0xFFFFFFFA) != 0)
  {
    v9 = 45;
LABEL_7:
    log_err("%s:%d: failed to read blknum 0x%llx size %zu flags 0x%x error %d dev_name = %s\n", "fd_dev_read_extended", 622, a2, a3, a9, v9, (const char *)(a1 + 208));
    return v9;
  }
  if (((a9 >> 2) ^ 1) != (a8 == 0))
  {
    v9 = 22;
    goto LABEL_7;
  }
  if (a6)
    return fd_dev_read_async_helper((int *)a1, a2, a3, (uint64_t)a4, a5, a7);
  else
    return fd_dev_read_helper(a1, a2, a3, a4, a5);
}

uint64_t fd_dev_read_finish(uint64_t a1, uint64_t a2)
{
  aiocb *v3;
  uint64_t v4;
  unint64_t v5;
  void (*v6)(uint64_t);
  aiocb *aiocblist;

  v3 = (aiocb *)(a2 + 8);
  aiocblist = (aiocb *)(a2 + 8);
  if (aio_suspend((const aiocb *const *)&aiocblist, 1, 0) || (v5 = aio_return(v3), v5 == -1))
  {
    v4 = *__error();
  }
  else if (v5 >= *(_QWORD *)(a2 + 32))
  {
    v4 = 0;
  }
  else
  {
    v4 = 5;
  }
  v6 = *(void (**)(uint64_t))a2;
  if (*(_QWORD *)a2)
  {
    *(_DWORD *)(a2 + 96) = v4;
    v6(a2);
  }
  return v4;
}

uint64_t fd_dev_write_extended(uint64_t a1, unint64_t a2, unint64_t a3, char *a4, uint64_t a5, uint64_t a6, unsigned int a7)
{
  uint64_t v7;

  if ((a7 & 0xFFFFFFFA) != 0)
  {
    v7 = 45;
  }
  else
  {
    if (((a7 >> 2) ^ 1) == (a6 == 0))
      return fd_dev_write_helper(a1, a2, a3, a4, a5, a7);
    v7 = 22;
  }
  log_err("%s:%d: failed to write blknum 0x%llx size %zu flags 0x%x error %d dev_name = %s\n", "fd_dev_write_extended", 866, a2, a3, a7, v7, (const char *)(a1 + 208));
  return v7;
}

uint64_t fd_dev_barrier(uint64_t a1, int a2)
{
  void *v4;
  unint64_t v5;
  uint64_t result;
  int v7;
  int v8;
  int v9;
  __int128 v10;
  uint64_t v11;

  v4 = *(void **)(a1 + 24);
  if (v4)
  {
    v5 = *(unsigned int *)(a1 + 36);
    if ((_DWORD)v5)
    {
      result = _fd_dev_write(a1, *(_QWORD *)(a1 + 40), v5, v4, *(_QWORD *)(a1 + 48));
      if ((_DWORD)result)
        return result;
      *(_DWORD *)(a1 + 36) = 0;
    }
  }
  fsync(*(_DWORD *)a1);
  v7 = *(_DWORD *)(a1 + 4);
  if ((v7 & 0x80000000) == 0)
    fsync(v7);
  if (!a2 && (*(_BYTE *)(a1 + 104) & 2) != 0)
  {
    v10 = xmmword_1DF2E8F90;
    v11 = 2;
    v9 = ioctl(*(_DWORD *)a1, 0x80186416uLL, &v10);
  }
  else
  {
    v8 = *(_DWORD *)a1;
    if ((*(_WORD *)(a1 + 64) & 0xF000) == 0x8000)
      v9 = fcntl(v8, 51, 0);
    else
      v9 = ioctl(v8, 0x20006416uLL, 0);
  }
  if (v9 == -1)
    return *__error();
  else
    return 0;
}

uint64_t fd_dev_unmap()
{
  return 0;
}

uint64_t fd_dev_unmap_flush()
{
  return 0;
}

uint64_t fd_dev_close(uint64_t a1)
{
  const char *v2;
  size_t v3;
  void *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;

  v2 = (const char *)(a1 + 208);
  v3 = strlen((const char *)(a1 + 208));
  v4 = *(void **)(a1 + 24);
  if (!v4)
  {
    v7 = 0;
    goto LABEL_10;
  }
  v5 = *(unsigned int *)(a1 + 36);
  if (!(_DWORD)v5)
  {
    v7 = 0;
LABEL_9:
    _apfs_free(v4, (*(_DWORD *)(a1 + 100) * *(_DWORD *)(a1 + 32)));
    *(_QWORD *)(a1 + 24) = 0;
    goto LABEL_10;
  }
  v6 = _fd_dev_write(a1, *(_QWORD *)(a1 + 40), v5, v4, *(_QWORD *)(a1 + 48));
  v7 = v6;
  if ((_DWORD)v6)
    log_err("%s:%d: Hit an error flushing the cache, %d dev_name = %s\n", "fd_dev_close", 370, v6, v2);
  *(_DWORD *)(a1 + 36) = 0;
  v4 = *(void **)(a1 + 24);
  if (v4)
    goto LABEL_9;
LABEL_10:
  if (close(*(_DWORD *)a1))
    v7 = *__error();
  v8 = *(_DWORD *)(a1 + 4);
  if ((v8 & 0x80000000) == 0 && close(v8))
    v7 = *__error();
  v9 = *(_DWORD *)(a1 + 8);
  if ((v9 & 0x80000000) == 0 && close(v9))
    v7 = *__error();
  _apfs_free((void *)a1, v3 + 216);
  return v7;
}

uint64_t fd_dev_real_block_size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

uint64_t fd_dev_set_block_size(uint64_t a1, unsigned int a2)
{
  unint64_t v2;

  v2 = *(_QWORD *)(a1 + 128) * (unint64_t)*(unsigned int *)(a1 + 100) / a2;
  *(_DWORD *)(a1 + 100) = a2;
  *(_QWORD *)(a1 + 128) = v2;
  return 0;
}

BOOL fd_dev_is_writable(uint64_t a1)
{
  return *(_DWORD *)(a1 + 108) != 0;
}

BOOL fd_dev_is_external(uint64_t a1)
{
  return *(_DWORD *)(a1 + 112) != 0;
}

uint64_t fd_dev_crypto_type(uint64_t a1)
{
  return *(unsigned int *)(a1 + 120);
}

uint64_t dev_init_common(uint64_t a1)
{
  int *v2;
  uint64_t v3;
  int device_block_size;
  int v5;
  int *v6;
  char *v7;
  off_t v8;
  off_t st_size;
  int v10;
  int v11;
  stat v13;
  uint64_t v14;
  int v15;
  dev_t v16;
  stat v17;
  off_t v18;

  v16 = 0;
  v15 = 0;
  v14 = 0;
  memset(&v13, 0, sizeof(v13));
  if (fstat(*(_DWORD *)a1, &v13))
  {
    v2 = __error();
    v3 = *v2;
    log_err("%s:%d: Couldn't fstat dev_fd (%d), err %d dev_name = %s\n", "dev_init_common", 983, *(_DWORD *)a1, *v2, (const char *)(a1 + 208));
  }
  else
  {
    *(_QWORD *)(a1 + 72) = apfs_userspace_io;
    device_block_size = io_get_device_block_size(*(_DWORD *)a1);
    *(_DWORD *)(a1 + 96) = device_block_size;
    *(_DWORD *)(a1 + 100) = device_block_size;
    v5 = *(_DWORD *)a1;
    v18 = 0;
    memset(&v17, 0, sizeof(v17));
    if (ioctl(v5, 0x40086419uLL, &v18))
    {
      if (fstat(v5, &v17))
      {
        v6 = __error();
        v7 = strerror(*v6);
        log_err("%s:%d: can't get block count (%s)\n", "io_get_num_device_blocks", 77, v7);
        v8 = 0;
      }
      else
      {
        st_size = v17.st_size;
        v8 = st_size / (int)io_get_device_block_size(v5);
      }
    }
    else
    {
      v8 = v18;
    }
    *(_QWORD *)(a1 + 128) = v8;
    io_get_device_features(*(_DWORD *)a1, &v16, &v15, (int *)&v14 + 1, (dev_t *)&v14);
    v3 = 0;
    v10 = v15;
    *(_DWORD *)(a1 + 104) = v16;
    *(_DWORD *)(a1 + 108) = v10;
    v11 = v14;
    *(_DWORD *)(a1 + 112) = HIDWORD(v14);
    *(_DWORD *)(a1 + 116) = v11;
    *(_WORD *)(a1 + 64) = v13.st_mode;
    *(_DWORD *)(a1 + 120) = 0;
  }
  return v3;
}

uint64_t dev_init(char *a1, int a2, int **a3)
{
  uint64_t v6;
  const char *v7;
  size_t v8;
  int *v9;
  int *v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  unsigned int v15;
  int v16;
  int v17;
  int *v18;
  char *v19;
  int v20;
  int v21;
  int v23;
  int *v24;
  char *v25;
  int v26;
  int v27;
  int v28;
  int v29;
  uint64_t inited;
  int v31;
  char *v32;
  int **v34;
  stat v35;
  char v36[1024];
  char v37[1024];
  char __str[1024];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (!strncmp(a1, "/dev/", 5uLL))
    v6 = 5;
  else
    v6 = 0;
  v7 = &a1[v6];
  v8 = strlen(&a1[v6]);
  *a3 = 0;
  v9 = (int *)_apfs_calloc(1uLL, v8 + 216);
  if (v9)
  {
    v10 = v9;
    memset(&v35, 0, sizeof(v35));
    v9[17] = 0;
    if (stat(a1, &v35) || (v35.st_mode & 0xF000) != 0x4000)
    {
      v13 = device_container_path(a1, 0);
      if (v13)
      {
        v14 = (char *)v13;
        v15 = a2 & 0xFFFFFFCF | 0x10;
        v10[2] = -1;
        v16 = open(a1, v15);
        v10[1] = v16;
        if (v16 < 0)
        {
          v24 = __error();
          v12 = *v24;
          v25 = strerror(*v24);
          log_err("%s:%d: failed to open volume device %s: %s\n", "dev_init", 1107, a1, v25);
        }
        else
        {
          v17 = open(v14, v15);
          *v10 = v17;
          if ((v17 & 0x80000000) == 0)
          {
LABEL_30:
            inited = dev_init_common((uint64_t)v10);
            if ((_DWORD)inited)
            {
              v12 = inited;
              free(v14);
LABEL_38:
              _apfs_free(v10, v8 + 216);
              return v12;
            }
            strlcpy((char *)v10 + 208, v7, v8 + 1);
            free(v14);
LABEL_39:
            v12 = 0;
            *a3 = v10;
            return v12;
          }
          v18 = __error();
          v12 = *v18;
          v19 = strerror(*v18);
          log_err("%s:%d: failed to open container device %s: %s\n", "dev_init", 1113, v14, v19);
          close(v10[1]);
        }
      }
      else
      {
        *(_QWORD *)(v10 + 1) = -1;
        v20 = open(a1, a2);
        *v10 = v20;
        if ((v20 & 0x80000000) == 0)
        {
LABEL_29:
          v14 = 0;
          goto LABEL_30;
        }
        v34 = a3;
        v21 = 30;
        while (*__error() == 16 && v21 != 0)
        {
          log_err("%s:%d: open %s hit EBUSY, attempts remaining: %u dev_name = %s\n", "dev_init", 1133, a1, v21, v7);
          sleep(1u);
          v23 = open(a1, a2);
          *v10 = v23;
          --v21;
          if ((v23 & 0x80000000) == 0)
          {
            v14 = 0;
            a3 = v34;
            goto LABEL_30;
          }
        }
        v14 = 0;
        v12 = *__error();
        a3 = v34;
      }
    }
    else
    {
      bzero(__str, 0x400uLL);
      bzero(v37, 0x400uLL);
      bzero(v36, 0x400uLL);
      snprintf(__str, 0x400uLL, "%s/apfs", a1);
      snprintf(v36, 0x400uLL, "%s/apfs_data", a1);
      snprintf(v37, 0x400uLL, "%s/nx", a1);
      v11 = open(__str, a2);
      v10[1] = v11;
      if (v11 < 0)
        v12 = *__error();
      else
        v12 = 0;
      v26 = open(v36, a2);
      v10[2] = v26;
      if (v26 < 0)
        v12 = *__error();
      v27 = open(v37, a2);
      v28 = v27;
      *v10 = v27;
      v29 = v10[1];
      if ((v29 & 0x80000000) == 0 && (v10[2] & 0x80000000) == 0 && (v27 & 0x80000000) == 0)
        goto LABEL_29;
      if (!(_DWORD)v12)
      {
        v12 = *__error();
        v28 = *v10;
        v29 = v10[1];
      }
      v31 = v10[2];
      v32 = strerror(v12);
      log_err("%s:%d: failed to open apfs/nx special devices ['%s'(%d) / '%s'(%d) / '%s'(%d)] - err %d (%s) dev_name = '%s'\n", "dev_init", 1094, __str, v29, v36, v31, v37, v28, v12, v32, v7);
      close(*v10);
      close(v10[1]);
      close(v10[2]);
      v14 = 0;
    }
    free(v14);
    if ((_DWORD)v12)
      goto LABEL_38;
    goto LABEL_39;
  }
  return 12;
}

uint64_t dev_set_tier2_device(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  if (a2 == a1)
    return 22;
  result = 0;
  *(_QWORD *)(a1 + 80) = a2;
  *(_QWORD *)(a1 + 88) = a3;
  return result;
}

uint64_t fd_dev_read_helper(uint64_t a1, unint64_t a2, unint64_t a3, void *a4, uint64_t a5)
{
  uint64_t common;
  unint64_t v11;
  unint64_t v13;
  int v14;
  ssize_t v15;
  int *v16;

  common = fd_dev_read_common(a1, a2, a3);
  if (!(_DWORD)common)
  {
    v11 = *(unsigned int *)(a1 + 100);
    if ((a2 & 0x8000000000000000) == 0
      && is_mul_ok(a2, v11)
      && ((a2 * v11) & 0x8000000000000000) == 0
      && is_mul_ok(a3, v11))
    {
      v13 = a3 * v11;
      if (!a5 || (v14 = *(_DWORD *)(a1 + 4), v14 < 0))
        v14 = *(_DWORD *)a1;
      v15 = pread(v14, a4, a3 * v11, a2 * v11);
      if (v15 < 0)
      {
        v16 = __error();
        common = *v16;
        log_err("%s:%d: blknum 0x%llx size %zu, error %d dev_name = %s\n", "fd_dev_read_helper", 510, a2, a3, *v16, (const char *)(a1 + 208));
      }
      else if (v15 == v13)
      {
        return 0;
      }
      else
      {
        return 5;
      }
    }
    else
    {
      log_err("%s:%d: blknum %lld size %zu blksize %u invalid, dev_name = %s\n", "fd_dev_read_helper", 476, a2, a3, *(_DWORD *)(a1 + 100), (const char *)(a1 + 208));
      return 22;
    }
  }
  return common;
}

uint64_t fd_dev_read_common(uint64_t a1, unint64_t a2, unint64_t a3)
{
  void *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v10;
  uint64_t result;

  v6 = *(void **)(a1 + 24);
  if (v6)
  {
    v7 = *(unsigned int *)(a1 + 36);
    if ((_DWORD)v7)
    {
      v8 = *(_QWORD *)(a1 + 40);
      if (a3 + a2 > v8 && v8 + v7 > a2)
      {
        result = _fd_dev_write(a1, v8, v7, v6, *(_QWORD *)(a1 + 48));
        if ((_DWORD)result)
          return result;
        *(_DWORD *)(a1 + 36) = 0;
      }
    }
  }
  v10 = *(_QWORD *)(a1 + 128);
  if (v10 - a2 >= a3 && v10 > a2)
    return 0;
  else
    return 6;
}

uint64_t _fd_dev_write(uint64_t a1, unint64_t a2, unint64_t a3, void *__buf, uint64_t a5)
{
  unint64_t v5;
  BOOL v6;
  unint64_t v7;
  unint64_t v10;
  off_t v11;
  size_t v12;
  int v13;
  ssize_t v14;

  v5 = *(_QWORD *)(a1 + 128);
  v6 = v5 > a2;
  v7 = v5 - a2;
  if (!v6 || v7 < a3)
    return 6;
  v10 = *(unsigned int *)(a1 + 100);
  if ((a2 & 0x8000000000000000) == 0
    && is_mul_ok(a2, v10)
    && (v11 = a2 * v10, ((a2 * v10) & 0x8000000000000000) == 0)
    && is_mul_ok(a3, v10))
  {
    v12 = a3 * v10;
    if (!a5 || (v13 = *(_DWORD *)(a1 + 4), v13 < 0))
      v13 = *(_DWORD *)a1;
    v14 = pwrite(v13, __buf, v12, v11);
    if (v14 < 0)
    {
      return *__error();
    }
    else if (v14 == v12)
    {
      return 0;
    }
    else
    {
      return 5;
    }
  }
  else
  {
    log_err("%s:%d: blknum %lld size %zu blksize %u invalid, dev_name = %s\n", "_fd_dev_write", 725, a2, a3, *(_DWORD *)(a1 + 100), (const char *)(a1 + 208));
    return 22;
  }
}

uint64_t fd_dev_read_async_helper(int *a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t common;
  void (*v13)(uint64_t);
  aiocb *v14;
  uint64_t v15;
  int v16;

  common = fd_dev_read_common((uint64_t)a1, a2, a3);
  if (!(_DWORD)common)
  {
    *(_OWORD *)(a6 + 8) = 0u;
    v14 = (aiocb *)(a6 + 8);
    *(_QWORD *)(a6 + 88) = a5;
    *(_OWORD *)(a6 + 24) = 0u;
    *(_OWORD *)(a6 + 40) = 0u;
    *(_OWORD *)(a6 + 56) = 0u;
    *(_OWORD *)(a6 + 72) = 0u;
    v15 = a1[25];
    *(_QWORD *)(a6 + 16) = v15 * a2;
    *(_QWORD *)(a6 + 24) = a4;
    *(_QWORD *)(a6 + 32) = v15 * a3;
    if (!a5 || (v16 = a1[1], v16 < 0))
      v16 = *a1;
    v14->aio_fildes = v16;
    if (!aio_read(v14))
      return 0;
    if (*__error() == 35)
    {
      common = 16;
    }
    else
    {
      common = *__error();
      if (!(_DWORD)common)
        return common;
    }
  }
  v13 = *(void (**)(uint64_t))a6;
  if (*(_QWORD *)a6)
  {
    *(_DWORD *)(a6 + 96) = common;
    v13(a6);
  }
  return common;
}

uint64_t fd_dev_write_helper(uint64_t a1, unint64_t a2, unint64_t a3, char *__buf, uint64_t a5, int a6)
{
  char *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t result;
  void *v16;
  unsigned int v17;
  unint64_t v18;

  v8 = __buf;
  v9 = a3;
  v10 = a2;
  v12 = *(_QWORD *)(a1 + 24);
  if (*(_DWORD *)(a1 + 60))
  {
    if (!v12)
    {
      v13 = *(_DWORD *)(a1 + 100);
      v14 = v13 <= 0x100000 ? 0x100000 / v13 : 1;
      *(_DWORD *)(a1 + 32) = v14;
      v16 = _apfs_malloc(v14 * v13);
      *(_QWORD *)(a1 + 24) = v16;
      *(_DWORD *)(a1 + 36) = 0;
      if (!v16)
        return 12;
    }
  }
  else if (!v12)
  {
    return _fd_dev_write(a1, a2, a3, __buf, a5);
  }
  if (!v9)
    return 0;
  v17 = *(_DWORD *)(a1 + 36);
  while (1)
  {
    while (1)
    {
      v18 = v9 >= *(_DWORD *)(a1 + 32) - v17 ? *(_DWORD *)(a1 + 32) - v17 : v9;
      if ((a6 & 4) != 0 || ((*(_DWORD *)(a1 + 56) ^ a6) & 1) != 0 || v10 != *(_QWORD *)(a1 + 40) + v17)
        break;
      if (!(_DWORD)v18 || *(_QWORD *)(a1 + 48) != a5)
        break;
      memcpy((void *)(*(_QWORD *)(a1 + 24) + *(_DWORD *)(a1 + 100) * v17), v8, (*(_DWORD *)(a1 + 100) * v18));
      v17 = *(_DWORD *)(a1 + 36) + v18;
      *(_DWORD *)(a1 + 36) = v17;
      v10 += v18;
      v9 -= v18;
      v8 += (*(_DWORD *)(a1 + 100) * v18);
      if (!v9)
        return 0;
    }
    if (v17)
    {
      result = _fd_dev_write(a1, *(_QWORD *)(a1 + 40), v17, *(void **)(a1 + 24), *(_QWORD *)(a1 + 48));
      if ((_DWORD)result)
        break;
    }
    v17 = 0;
    *(_DWORD *)(a1 + 36) = 0;
    *(_QWORD *)(a1 + 40) = v10;
    *(_QWORD *)(a1 + 48) = a5;
    *(_DWORD *)(a1 + 56) = a6;
  }
  return result;
}

uint64_t fext_tree_key_cmp(uint64_t a1, _QWORD *a2, int a3, _QWORD *a4, int a5, int *a6)
{
  uint64_t result;
  int v7;
  unint64_t v8;
  unint64_t v9;
  BOOL v10;

  result = 22;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        v7 = 1;
      }
      else
      {
        v8 = a2[1];
        v9 = a4[1];
        v10 = v8 >= v9;
        v7 = v8 > v9;
        if (!v10)
          v7 = -1;
      }
    }
    else
    {
      v7 = -1;
    }
    result = 0;
    *a6 = v7;
  }
  return result;
}

unint64_t *fs_obj_zfree_oc(void *a1, uint64_t a2, int a3, uint64_t a4)
{
  _apfs_obj_zfree(a1, a2, *(_QWORD *)(a4 + 920));
  obj_cache_stats_update_zfree((unint64_t *)(a4 + 944), a3, a2);
  return obj_cache_stats_update_zfree((unint64_t *)(omm + 136), a3, a2);
}

unint64_t *obj_cache_stats_update_zfree(unint64_t *result, int a2, uint64_t a3)
{
  char v3;
  unsigned int v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;

  v4 = a2 & 0xC8000000;
  if (a2 < 0 != v3)
  {
    if (v4 == 0x80000000)
    {
      v18 = result + 29;
      do
        v19 = __ldxr(v18);
      while (__stxr(v19 - a3, v18));
      v20 = result + 31;
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + a3, v20));
      v22 = result + 33;
      do
        v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }
    else
    {
      if (v4 != -2013265920)
        goto LABEL_24;
      v5 = result + 35;
      do
        v6 = __ldxr(v5);
      while (__stxr(v6 - a3, v5));
      v7 = result + 37;
      do
        v8 = __ldxr(v7);
      while (__stxr(v8 + a3, v7));
      v9 = result + 39;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
  }
  else
  {
    if (v4 != 0x40000000 && v4 != 0)
LABEL_24:
      panic("unexpected storagetype: 0x%x\n", a2 & 0xC8000000);
    v12 = result + 23;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 - a3, v12));
    v14 = result + 25;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + a3, v14));
    v16 = result + 27;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  return result;
}

uint64_t obj_cache_create(unsigned int a1, unsigned int a2, unsigned int a3, _QWORD *a4)
{
  uint64_t v8;
  char *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  unsigned int v16;
  void *v17;

  v8 = obj_mem_mgr_init();
  if (!(_DWORD)v8)
  {
    v9 = (char *)_apfs_calloc(1uLL, 0x550uLL);
    if (v9)
    {
      v10 = v9;
      bzero(v9, 0x550uLL);
      v11 = new_lock((pthread_mutex_t *)v10);
      if ((_DWORD)v11)
      {
        v8 = v11;
LABEL_13:
        _apfs_free(v10, 1360);
        return v8;
      }
      v12 = new_rwlock((pthread_rwlock_t *)(v10 + 128));
      if ((_DWORD)v12)
      {
        v8 = v12;
LABEL_12:
        free_lock((pthread_mutex_t *)v10);
        goto LABEL_13;
      }
      v13 = new_lock((pthread_mutex_t *)(v10 + 328));
      if ((_DWORD)v13)
      {
        v8 = v13;
LABEL_11:
        free_rwlock((pthread_rwlock_t *)(v10 + 128));
        goto LABEL_12;
      }
      v14 = new_cv((pthread_cond_t *)v10 + 27);
      if ((_DWORD)v14)
      {
        v8 = v14;
        free_lock((pthread_mutex_t *)(v10 + 328));
        goto LABEL_11;
      }
      if (!a1)
        a1 = 4096;
      v15 = _apfs_malloc(8 * a1);
      *((_QWORD *)v10 + 88) = v15;
      if (v15)
      {
        bzero(v15, 8 * a1);
        *((_DWORD *)v10 + 174) = a1;
        *((_DWORD *)v10 + 175) = a1 - 1;
        if (a2)
          v16 = a2;
        else
          v16 = 4096;
        *((_DWORD *)v10 + 169) = 128;
        *((_DWORD *)v10 + 170) = v16;
        *((_DWORD *)v10 + 171) = 0;
        *((_QWORD *)v10 + 86) = 0;
        *((_DWORD *)v10 + 168) = a3;
        obj_cache_stats_init((uint64_t)(v10 + 944), 0x80u, v16, a3);
        v17 = _apfs_calloc(0x100uLL, 8uLL);
        *((_QWORD *)v10 + 109) = v17;
        if (v17)
        {
          v8 = 0;
          *((_QWORD *)v10 + 93) = v10 + 736;
          *((_QWORD *)v10 + 95) = v10 + 752;
          *((_QWORD *)v10 + 97) = v10 + 768;
          *((_QWORD *)v10 + 99) = v10 + 784;
          *((_QWORD *)v10 + 101) = v10 + 800;
          *((_QWORD *)v10 + 103) = v10 + 816;
          *((_QWORD *)v10 + 169) = v10 + 1344;
          *((_QWORD *)v10 + 107) = v10 + 848;
          *((_QWORD *)v10 + 105) = v10 + 832;
          *(_OWORD *)(v10 + 712) = 0u;
          *((_QWORD *)v10 + 94) = 0;
          *((_QWORD *)v10 + 96) = 0;
          *((_QWORD *)v10 + 98) = 0;
          *((_QWORD *)v10 + 100) = 0;
          *((_QWORD *)v10 + 102) = 0;
          *((_QWORD *)v10 + 168) = 0;
          *((_QWORD *)v10 + 106) = 0;
          *((_QWORD *)v10 + 104) = 0;
          *((_QWORD *)v10 + 92) = 0;
          *((_QWORD *)v10 + 91) = 0;
          *((int64x2_t *)v10 + 25) = vdupq_n_s64(0x400uLL);
          *a4 = v10;
          return v8;
        }
        _apfs_free(*((void **)v10 + 88), 8 * a1);
      }
      free_cv((pthread_cond_t *)v10 + 27);
      free_lock((pthread_mutex_t *)(v10 + 328));
      free_rwlock((pthread_rwlock_t *)(v10 + 128));
      free_lock((pthread_mutex_t *)v10);
      _apfs_free(v10, 1360);
    }
    return 12;
  }
  return v8;
}

uint64_t obj_mem_mgr_init()
{
  uint64_t v1;
  char *v3;
  unint64_t v4;
  pthread_mutex_t *v5;
  uint64_t v6;
  __darwin_time_t tv_sec;
  timespec __tp;

  if (!atomic_load((unint64_t *)&omm))
  {
    v3 = (char *)_apfs_calloc(1uLL, 0x1E0uLL);
    if (!v3)
      return 12;
    v4 = (unint64_t)v3;
    v5 = (pthread_mutex_t *)(v3 + 8);
    *((_OWORD *)v3 + 28) = 0u;
    *((_OWORD *)v3 + 29) = 0u;
    *((_OWORD *)v3 + 26) = 0u;
    *((_OWORD *)v3 + 27) = 0u;
    *((_OWORD *)v3 + 24) = 0u;
    *((_OWORD *)v3 + 25) = 0u;
    *((_OWORD *)v3 + 22) = 0u;
    *((_OWORD *)v3 + 23) = 0u;
    *((_OWORD *)v3 + 20) = 0u;
    *((_OWORD *)v3 + 21) = 0u;
    *((_OWORD *)v3 + 18) = 0u;
    *((_OWORD *)v3 + 19) = 0u;
    *((_OWORD *)v3 + 16) = 0u;
    *((_OWORD *)v3 + 17) = 0u;
    *((_OWORD *)v3 + 14) = 0u;
    *((_OWORD *)v3 + 15) = 0u;
    *((_OWORD *)v3 + 12) = 0u;
    *((_OWORD *)v3 + 13) = 0u;
    *((_OWORD *)v3 + 10) = 0u;
    *((_OWORD *)v3 + 11) = 0u;
    *((_OWORD *)v3 + 8) = 0u;
    *((_OWORD *)v3 + 9) = 0u;
    *((_OWORD *)v3 + 6) = 0u;
    *((_OWORD *)v3 + 7) = 0u;
    *((_OWORD *)v3 + 4) = 0u;
    *((_OWORD *)v3 + 5) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    *((_OWORD *)v3 + 3) = 0u;
    *(_OWORD *)v3 = 0u;
    *((_OWORD *)v3 + 1) = 0u;
    v6 = new_lock((pthread_mutex_t *)(v3 + 8));
    if ((_DWORD)v6)
    {
      v1 = v6;
      log_err("%s:%d: object memory manager failed to create lock, error: %d\n", "obj_mem_mgr_init", 7149, v6);
      _apfs_free((void *)v4, 480);
      return v1;
    }
    *(_QWORD *)(v4 + 72) = 0;
    __tp.tv_sec = 0;
    __tp.tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    tv_sec = __tp.tv_sec;
    *(_OWORD *)(v4 + 136) = 0u;
    *(_OWORD *)(v4 + 440) = 0u;
    *(_OWORD *)(v4 + 456) = 0u;
    *(_OWORD *)(v4 + 408) = 0u;
    *(_OWORD *)(v4 + 424) = 0u;
    *(_OWORD *)(v4 + 376) = 0u;
    *(_OWORD *)(v4 + 392) = 0u;
    *(_OWORD *)(v4 + 344) = 0u;
    *(_OWORD *)(v4 + 360) = 0u;
    *(_OWORD *)(v4 + 312) = 0u;
    *(_OWORD *)(v4 + 328) = 0u;
    *(_OWORD *)(v4 + 280) = 0u;
    *(_OWORD *)(v4 + 296) = 0u;
    *(_OWORD *)(v4 + 248) = 0u;
    *(_OWORD *)(v4 + 264) = 0u;
    *(_OWORD *)(v4 + 216) = 0u;
    *(_OWORD *)(v4 + 232) = 0u;
    *(_OWORD *)(v4 + 184) = 0u;
    *(_OWORD *)(v4 + 200) = 0u;
    *(_OWORD *)(v4 + 152) = 0u;
    *(_OWORD *)(v4 + 168) = 0u;
    *(_QWORD *)(v4 + 464) = tv_sec;
    *(_QWORD *)(v4 + 472) = 0;
    do
    {
      if (__ldxr((unint64_t *)&omm))
      {
        __clrex();
        atomic_load((unint64_t *)&omm);
        free_lock(v5);
        _apfs_free((void *)v4, 480);
        return 0;
      }
    }
    while (__stlxr(v4, (unint64_t *)&omm));
    if ((*(_DWORD *)omm & 4) != 0)
      log_debug("%s:%d: object memory manager initialized with feature flags: 0x%x, apfs_mem_max: %lld\n", "obj_mem_mgr_init", 7170, *(_DWORD *)omm, *(_QWORD *)(omm + 96));
  }
  return 0;
}

double obj_cache_stats_init(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  __darwin_time_t tv_sec;
  double result;
  unint64_t v10;
  timespec v11;

  v11.tv_sec = 0;
  v11.tv_nsec = 0;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v11);
  tv_sec = v11.tv_sec;
  result = 0.0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  v10 = a4 * (unint64_t)a3;
  *(_QWORD *)(a1 + 8) = a4 * (unint64_t)a2;
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)a1 = v10;
  *(_QWORD *)(a1 + 328) = tv_sec;
  *(_QWORD *)(a1 + 336) = 0;
  return result;
}

uint64_t obj_cache_ephemeral_adjust(uint64_t result, int a2, int a3, int a4)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  int v7;

  if ((a2 & 0x8000000) != 0)
  {
    *(_DWORD *)(result + 692) += a4;
  }
  else
  {
    *(_DWORD *)(result + 688) += a4;
    v4 = *(_QWORD *)(result + 392);
    if (v4)
    {
      v5 = (a3 + *(_DWORD *)(*(_QWORD *)(v4 + 376) + 36) - 1)
         / *(_DWORD *)(*(_QWORD *)(v4 + 376) + 36);
      v6 = *(_DWORD *)(result + 900);
      if (a4 < 0)
        v7 = v6 - v5;
      else
        v7 = v6 + v5;
    }
    else
    {
      v7 = *(_DWORD *)(result + 900) + a4;
    }
    *(_DWORD *)(result + 900) = v7;
  }
  return result;
}

void obj_cache_unlock_write(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(a1 + 720);
  if (v1)
  {
    *(_QWORD *)(a1 + 720) = 0;
    *(_QWORD *)(a1 + 728) = 0;
    pthread_mutex_unlock((pthread_mutex_t *)a1);
    do
    {
      v2 = *(_QWORD *)(v1 + 72);
      obj_destroy_complete(v1, 0);
      v1 = v2;
    }
    while (v2);
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)a1);
  }
}

uint64_t obj_cache_lock_by_state(pthread_mutex_t *a1, int a2)
{
  if (a2 != 2 && a2 != 1)
    panic("obj_cache_lock_by_state, invalid oc_lock_state %d\n", a2);
  return pthread_mutex_lock(a1);
}

void obj_cache_unlock_by_state(pthread_mutex_t *a1, int a2)
{
  if (a2 == 2)
  {
    obj_cache_unlock_write((uint64_t)a1);
  }
  else
  {
    if (a2 != 1)
      panic("obj_cache_unlock_by_state, invalid oc_lock_state %d\n", a2);
    pthread_mutex_unlock(a1);
  }
}

void obj_cache_reset(pthread_mutex_t *a1, int a2)
{
  unsigned int *v4;
  unsigned int v5;
  unsigned int *v6;
  unsigned int v7;
  uint64_t sig;
  unsigned int v9;
  unint64_t v10;
  unint64_t i;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int v22;
  char v23;

  if (!a2)
  {
    pthread_mutex_lock(a1);
    v4 = (unsigned int *)&a1[14].__opaque[8];
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = (unsigned int *)&a1[14].__opaque[12];
  do
    v7 = __ldxr(v6);
  while (__stxr(v7, v6));
  if (v7)
  {
    do
    {
      v23 = 1;
      sig = a1[21].__sig;
      if (sig)
      {
        if ((*(_BYTE *)(*(_QWORD *)(sig + 136) + 20) & 0x80) == 0)
        {
          obj_async_finish(sig, &v23);
          if (!v23)
            pthread_mutex_lock(a1);
        }
      }
      do
        v9 = __ldxr(v6);
      while (__stxr(v9, v6));
    }
    while (v9);
  }
  if (a1[11].__sig)
  {
    v10 = *(unsigned int *)&a1[10].__opaque[48];
    if ((_DWORD)v10)
    {
      for (i = 0; i < v10; ++i)
      {
        v12 = *(_QWORD *)(a1[11].__sig + 8 * i);
        if (v12)
        {
          do
          {
            v13 = *(_QWORD *)(v12 + 72);
            if (v12 != *(_QWORD *)a1[6].__opaque)
            {
              v14 = *(_QWORD *)(v12 + 16);
              if ((v14 & 0x80000000) != 0)
                obj_cache_ephemeral_adjust((uint64_t)a1, v14, *(_DWORD *)(v12 + 48), -1);
              else
                --*(_DWORD *)&a1[10].__opaque[36];
              obj_destroy_internal(v12, 0);
            }
            v12 = v13;
          }
          while (v13);
          v10 = *(unsigned int *)&a1[10].__opaque[48];
        }
      }
    }
  }
  v15 = *(_QWORD *)a1[11].__opaque;
  if (v15)
  {
    do
    {
      v16 = *(_QWORD *)(v15 + 72);
      --*(_DWORD *)&a1[10].__opaque[36];
      obj_destroy_internal(v15, 0);
      v15 = v16;
    }
    while (v16);
  }
  v17 = *(_QWORD *)&a1[11].__opaque[24];
  if (v17)
  {
    do
    {
      v18 = *(_QWORD *)(v17 + 88);
      if (v17 != *(_QWORD *)a1[6].__opaque)
        obj_destroy_internal(v17, 0);
      v17 = v18;
    }
    while (v18);
  }
  v19 = *(_QWORD *)&a1[11].__opaque[40];
  if (v19)
  {
    do
    {
      v20 = *(_QWORD *)(v19 + 88);
      obj_destroy_internal(v19, 0);
      v19 = v20;
    }
    while (v20);
  }
  if (!a2)
  {
    obj_cache_unlock_write((uint64_t)a1);
    v21 = (unsigned int *)&a1[14].__opaque[8];
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 - 1, v21));
  }
}

void obj_cache_destroy(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  void *v8;
  void *v9;

  pthread_mutex_lock((pthread_mutex_t *)(omm + 8));
  v2 = *(_QWORD *)(a1 + 1288);
  if ((v2 & 1) == 0)
    goto LABEL_7;
  *(_QWORD *)(a1 + 1288) = v2 & 0xFFFFFFFFFFFFFFFELL;
  v3 = *(_QWORD *)(a1 + 928);
  if (v3)
    *(_QWORD *)(v3 + 936) = *(_QWORD *)(a1 + 936);
  **(_QWORD **)(a1 + 936) = v3;
  if ((v2 & 2) != 0)
  {
    *(_QWORD *)(a1 + 1288) = v2 & 0xFFFFFFFFFFFFFFFCLL;
LABEL_7:
    v4 = omm;
    goto LABEL_8;
  }
  v4 = omm;
  --*(_QWORD *)(omm + 104);
  *(int64x2_t *)(v4 + 136) = vsubq_s64(*(int64x2_t *)(v4 + 136), *(int64x2_t *)(a1 + 944));
  *(_QWORD *)(v4 + 152) -= *(_QWORD *)(a1 + 960);
LABEL_8:
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
  pthread_mutex_lock((pthread_mutex_t *)a1);
  v5 = (unsigned int *)(a1 + 912);
  do
    v6 = __ldxr(v5);
  while (__stxr(v6 + 1, v5));
  obj_cache_reset((pthread_mutex_t *)a1, 1);
  v7 = *(_QWORD *)(a1 + 392);
  if (v7)
  {
    obj_cache_ephemeral_adjust(a1, *(_QWORD *)(v7 + 16), *(_DWORD *)(v7 + 48), -1);
    obj_destroy_internal(*(_QWORD *)(a1 + 392), 0);
  }
  v8 = *(void **)(a1 + 704);
  if (v8)
    _apfs_free(v8, 8 * *(unsigned int *)(a1 + 696));
  obj_cache_unlock_write(a1);
  v9 = *(void **)(a1 + 872);
  if (v9)
    _apfs_free(v9, 2048);
  free_cv((pthread_cond_t *)(a1 + 1296));
  free_lock((pthread_mutex_t *)(a1 + 328));
  free_rwlock((pthread_rwlock_t *)(a1 + 128));
  free_lock((pthread_mutex_t *)a1);
  _apfs_free((void *)a1, 1360);
}

uint64_t obj_cache_flush_prepare(uint64_t a1, unsigned int a2, char a3, uint64_t a4)
{
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t **v13;
  int v14;
  uint64_t v15;
  int v16;
  unsigned int *v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  const void *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  _QWORD *v27;
  unsigned int v28;
  int v29;
  int8x16_t v30;
  int8x16_t v31;
  uint64_t **v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t *v35;
  int v36;
  uint64_t *v37;
  _QWORD *v38;
  BOOL v39;
  char v40;
  int v41;
  int v42;
  unsigned int *v43;
  const void *v44;
  _QWORD *v45;
  unint64_t v46;
  uint64_t v47;
  const char *v48;
  uint64_t v49;
  _QWORD *v50;
  unsigned int v51;
  BOOL v52;
  int v53;
  int v54;
  int8x16_t v55;
  int8x16_t v56;
  uint64_t **v57;
  uint64_t *v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  _QWORD *v62;
  _QWORD *v63;
  int i;
  _QWORD *v65;
  char v66;
  _QWORD *v67;
  int v68;
  _QWORD *v69;
  _QWORD *v70;
  int v71;
  _QWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  _QWORD *v76;
  BOOL v77;
  _QWORD *v78;
  _QWORD *v79;
  _QWORD *v80;
  _QWORD *v81;
  uint64_t v82;
  uint64_t v83;
  _QWORD *v84;
  BOOL v85;
  _QWORD *v86;
  uint64_t v88;
  uint64_t v89;
  pthread_rwlock_t *v90;
  int v91;
  uint64_t v92;
  int v93;
  unsigned int v94;

  v94 = 0;
  if ((a2 & 0x80000000) != 0)
    return 22;
  pthread_mutex_lock((pthread_mutex_t *)a1);
  if (*(_DWORD *)(a1 + 908))
  {
    if (a2)
    {
      obj_cache_unlock_write(a1);
      return 0;
    }
    do
    {
      *(_DWORD *)(a1 + 908) = 2;
      cv_wait_rw((pthread_cond_t *)(a1 + 1296), (pthread_mutex_t *)a1, 2, 0);
    }
    while (*(_DWORD *)(a1 + 908));
  }
  *(_DWORD *)(a1 + 908) = 1;
  v90 = (pthread_rwlock_t *)(a1 + 128);
  v9 = pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 128));
  if (v9)
    panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 1094, v9);
  v89 = a4;
  if (!a2)
  {
    v11 = 0;
    if ((a3 & 1) == 0)
    {
      v10 = 0;
      goto LABEL_17;
    }
    v13 = 0;
LABEL_95:
    v38 = *(_QWORD **)(a1 + 816);
    if (a2)
      v39 = v11 < 1;
    else
      v39 = 0;
    v40 = v39;
    if (v38 && (v40 & 1) == 0)
    {
      if (a2)
        v41 = -1;
      else
        v41 = 0;
      v93 = v41;
      do
      {
        if (*((_DWORD *)v38 + 9) >> 30 != 1)
          panic("non-physical object on physical object dirty list: oid %lld flags 0x%llx 0x%x\n", v38[14], v38[2], *((_DWORD *)v38 + 8));
        v43 = (unsigned int *)(v38 + 4);
        v42 = *((_DWORD *)v38 + 8);
        if ((v42 & 1) == 0)
          panic("physical object on dirty list not dirty: oid %lld flags 0x%llx 0x%x\n", v38[14], v38[2], v42);
        v45 = v38 + 13;
        v44 = (const void *)v38[13];
        v46 = v38[2];
        if ((v44 == (const void *)3735928559) == ((v46 >> 41) & 1))
          panic("dirty object flush state inconsistent: oid %lld flags 0x%llx 0x%x fl %p\n", v38[14], v46, *((_DWORD *)v38 + 8), v44);
        if ((v46 & 0x20000000000) == 0 || *v45 == 3735928559)
        {
          v94 = 16000;
          if (obj_reference_release_wait(v38, (int *)&v94, 1, 2))
          {
            do
            {
              if (v94 > 0x773593FF)
              {
                v47 = v38[1];
                if (!v47)
                  v47 = *(_QWORD *)(*v38 + 392);
                if (nx_ratelimit_log_allowed(*(_QWORD *)(*(_QWORD *)v47 + 392)))
                {
                  if (*(_WORD *)(v47 + 36) == 13)
                    v48 = (const char *)(v47 + 3880);
                  else
                    v48 = (const char *)(*(_QWORD *)(v47 + 384) + 208);
                  log_debug("%s:%d: %s oid %lld flags 0x%llx 0x%x refs 0x%llx taking too long to get reference!\n", "obj_cache_flush_prepare", 1273, v48, v38[14], v38[2], *((_DWORD *)v38 + 8), v38[3]);
                }
              }
            }
            while ((obj_reference_release_wait(v38, (int *)&v94, 1, 2) & 1) != 0);
          }
        }
        if (!*(_DWORD *)(a1 + 888))
          panic("physical object dirty count underflow\n");
        v49 = v38[11];
        v50 = (_QWORD *)v38[12];
        if (v49)
        {
          *(_QWORD *)(v49 + 96) = v50;
          v50 = (_QWORD *)v38[12];
        }
        else
        {
          *(_QWORD *)(a1 + 824) = v50;
        }
        *v50 = v49;
        --*(_DWORD *)(a1 + 888);
        v38[11] = 3735928559;
        do
          v51 = __ldxr(v43);
        while (__stxr(v51 & 0xFFFFFFFE, v43));
        v38[2] |= 0x20000000000uLL;
        if ((a3 & 2) != 0)
          v38[8] = v38[7];
        if (*v45 == 3735928559)
        {
          v38[13] = 0;
          **(_QWORD **)(a1 + 840) = v38;
          *(_QWORD *)(a1 + 840) = v45;
          ++*(_DWORD *)(a1 + 904);
        }
        v11 += v93;
        v38 = *(_QWORD **)(a1 + 816);
        if (a2)
          v52 = v11 < 1;
        else
          v52 = 0;
        v53 = v52;
      }
      while (v38 && !v53);
    }
    v54 = pthread_rwlock_unlock(v90);
    if (v54)
      panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 1302, v54);
    obj_cache_unlock_write(a1);
    v57 = v13 + 13;
    if (!v13)
      v57 = (uint64_t **)(a1 + 832);
    v58 = *v57;
    if (*v57)
    {
      while (1)
      {
        v59 = obj_write_prepare(v58, 0, v89, v55, v56);
        if ((_DWORD)v59)
          break;
        if ((a3 & 2) != 0)
        {
          v60 = v58[19];
          if (!v60)
            v60 = v58[16];
          v58[17] = v60;
        }
        v58 = (uint64_t *)v58[13];
        if (!v58)
          goto LABEL_155;
      }
      v8 = v59;
      if (!*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 392) + 400) + 76))
      {
        v88 = v58[1];
        if (!v88)
          v88 = *(_QWORD *)(*v58 + 392);
        if (nx_ratelimit_log_allowed(*(_QWORD *)(*(_QWORD *)v88 + 392)))
          goto LABEL_216;
      }
      return v8;
    }
LABEL_155:
    v61 = *(_DWORD *)(a1 + 904);
    if (v61 >= 2)
    {
      v62 = 0;
      v63 = *(_QWORD **)(a1 + 832);
      for (i = 1; i < v61; i *= 2)
      {
        if (v63)
        {
          v65 = 0;
          v66 = 1;
          v67 = v63;
          while (1)
          {
            v68 = i;
            v69 = v67;
            if (i >= 2)
              break;
            v70 = (_QWORD *)v67[13];
            v69 = v67;
            v72 = v70;
            if (!v70)
              goto LABEL_205;
LABEL_167:
            v74 = v67[19];
            if (!v74)
              v74 = v67[16];
            v75 = v70[19];
            if (!v75)
              v75 = v70[16];
            v76 = (_QWORD *)v72[13];
            v77 = v74 <= v75;
            if (v74 > v75)
              v78 = v70;
            else
              v78 = (_QWORD *)v72[13];
            if (v74 > v75)
              v79 = v67;
            else
              v79 = v70;
            if (v77)
              v62 = v72;
            else
              v62 = v69;
            if (!v77)
            {
              v69 = v72;
              v67 = v70;
            }
            if (v67 == v69 || v79 == v78)
            {
              v81 = v67;
            }
            else
            {
              v80 = v67;
              do
              {
                v81 = (_QWORD *)v80[13];
                v82 = v81[19];
                if (!v82)
                  v82 = v81[16];
                v83 = v79[19];
                if (!v83)
                  v83 = v79[16];
                if (v82 > v83)
                {
                  v84 = (_QWORD *)v79[13];
                  v79[13] = v81;
                  v80[13] = v79;
                  v81 = v79;
                  v79 = v84;
                }
                v85 = v81 == v69 || v79 == v78;
                v80 = v81;
              }
              while (!v85);
            }
            if (v81 == v69)
              v69[13] = v79;
            else
              v62 = v69;
            v86 = v65 + 13;
            if ((v66 & 1) != 0)
            {
              v86 = (_QWORD *)(a1 + 832);
              v63 = v67;
            }
            *v86 = v67;
            v65 = v62;
            v67 = v76;
            v66 = 0;
            if (!v76)
            {
              v65 = v62;
              goto LABEL_205;
            }
          }
          while (1)
          {
            v69 = (_QWORD *)v69[13];
            if (!v69)
              break;
            if (--v68 < 2)
            {
              v70 = (_QWORD *)v69[13];
              v71 = i;
              v72 = v70;
              if (!v70)
                break;
              while (1)
              {
                v73 = (_QWORD *)v72[13];
                if (!v73)
                  goto LABEL_167;
                --v71;
                v72 = (_QWORD *)v72[13];
                if (v71 < 2)
                {
                  v72 = v73;
                  goto LABEL_167;
                }
              }
            }
          }
LABEL_205:
          if (v65)
            v65[13] = v67;
        }
      }
      if (v62)
      {
        v8 = 0;
        *(_QWORD *)(a1 + 840) = v62 + 13;
        return v8;
      }
    }
    return 0;
  }
  if ((a3 & 1) != 0)
  {
    v13 = 0;
    v11 = a2;
    goto LABEL_95;
  }
  if (*(_DWORD *)(a1 + 884) >= a2)
    v10 = a2;
  else
    v10 = *(_DWORD *)(a1 + 884);
  v11 = a2 - v10;
LABEL_17:
  v12 = 0;
  v13 = 0;
  v92 = 0;
  if (a2)
    v14 = -1;
  else
    v14 = 0;
  v91 = v14;
  while (2)
  {
    v15 = *(_QWORD *)(a1 + 800);
    if (!v15)
      goto LABEL_73;
    while (!a2 || v10 >= 1)
    {
      if (*(_DWORD *)(v15 + 36) >> 30)
        panic("non-virtual object on virtual object dirty list: oid %lld flags 0x%llx 0x%x\n", *(_QWORD *)(v15 + 112), *(_QWORD *)(v15 + 16), *(_DWORD *)(v15 + 32));
      v17 = (unsigned int *)(v15 + 32);
      v16 = *(_DWORD *)(v15 + 32);
      if ((v16 & 1) == 0)
        panic("virtual object on dirty list not dirty: oid %lld flags 0x%llx 0x%x\n", *(_QWORD *)(v15 + 112), *(_QWORD *)(v15 + 16), v16);
      if (v12)
      {
        if (v12 > 1)
          goto LABEL_36;
      }
      else
      {
        v18 = *(_QWORD *)(v15 + 8);
        if (!v18)
          goto LABEL_53;
        if (*(_QWORD *)(v18 + 496))
          v18 = *(_QWORD *)(v18 + 496);
        if ((*(_BYTE *)(*(_QWORD *)(v18 + 376) + 264) & 1) != 0)
          goto LABEL_53;
      }
      if (*(_WORD *)(v15 + 36) == 13)
      {
LABEL_53:
        v15 = *(_QWORD *)(v15 + 88);
        *(_QWORD *)(a1 + 864) = v15;
        if (!v15)
          goto LABEL_73;
      }
      else
      {
LABEL_36:
        if (a2)
        {
          v19 = (unint64_t *)(v15 + 24);
          do
            v20 = __ldxr(v19);
          while (__stxr(v20, v19));
          if ((v20 & 0xFFFFFF) != ((v20 >> 24) & 0xFFFFF))
            goto LABEL_53;
        }
        v22 = (_QWORD *)(v15 + 104);
        v21 = *(const void **)(v15 + 104);
        v23 = *(_QWORD *)(v15 + 16);
        if ((v21 == (const void *)3735928559) == ((v23 >> 41) & 1))
          panic("dirty object flush state inconsistent: oid %lld flags 0x%llx 0x%x fl %p\n", *(_QWORD *)(v15 + 112), v23, *(_DWORD *)(v15 + 32), v21);
        if ((v23 & 0x20000000000) != 0 && *v22 != 3735928559)
          goto LABEL_55;
        if (v15 != v92)
          v94 = 16000;
        *(_QWORD *)(a1 + 864) = v15;
        v92 = v15;
        if (obj_reference_release_wait((_QWORD *)v15, (int *)&v94, 1, 2))
        {
          if (v94 > 0x773593FF)
          {
            v24 = *(_QWORD *)(v15 + 8);
            if (!v24)
              v24 = *(_QWORD *)(*(_QWORD *)v15 + 392);
            if (nx_ratelimit_log_allowed(*(_QWORD *)(*(_QWORD *)v24 + 392)))
            {
              if (*(_WORD *)(v24 + 36) == 13)
                v25 = (const char *)(v24 + 3880);
              else
                v25 = (const char *)(*(_QWORD *)(v24 + 384) + 208);
              log_debug("%s:%d: %s oid %lld flags 0x%llx 0x%x refs 0x%llx taking too long to get reference!\n", "obj_cache_flush_prepare", 1184, v25, *(_QWORD *)(v15 + 112), *(_QWORD *)(v15 + 16), *(_DWORD *)(v15 + 32), *(_QWORD *)(v15 + 24));
            }
          }
          v92 = v15;
        }
        else
        {
LABEL_55:
          v26 = *(_QWORD *)(v15 + 88);
          *(_QWORD *)(a1 + 864) = v26;
          if (!*(_DWORD *)(a1 + 884))
            panic("virtual object dirty count underflow\n");
          v27 = *(_QWORD **)(v15 + 96);
          if (v26)
          {
            *(_QWORD *)(v26 + 96) = v27;
            v27 = *(_QWORD **)(v15 + 96);
          }
          else
          {
            *(_QWORD *)(a1 + 808) = v27;
          }
          *v27 = v26;
          --*(_DWORD *)(a1 + 884);
          *(_QWORD *)(v15 + 88) = 3735928559;
          do
            v28 = __ldxr(v17);
          while (__stxr(v28 & 0xFFFFFFFE, v17));
          *(_QWORD *)(v15 + 16) |= 0x20000000000uLL;
          if ((a3 & 2) != 0)
            *(_QWORD *)(v15 + 64) = *(_QWORD *)(v15 + 56);
          if (*v22 == 3735928559)
          {
            *(_QWORD *)(v15 + 104) = 0;
            **(_QWORD **)(a1 + 840) = v15;
            *(_QWORD *)(a1 + 840) = v22;
            ++*(_DWORD *)(a1 + 904);
          }
          v10 += v91;
        }
        v15 = *(_QWORD *)(a1 + 864);
        if (!v15)
          goto LABEL_73;
      }
    }
    v12 = 3;
LABEL_73:
    v29 = pthread_rwlock_unlock(v90);
    if (v29)
      panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 1214, v29);
    obj_cache_unlock_write(a1);
    v32 = v13 + 13;
    if (!v13)
      v32 = (uint64_t **)(a1 + 832);
    v33 = *v32;
    if (!v33)
    {
LABEL_84:
      pthread_mutex_lock((pthread_mutex_t *)a1);
      v36 = pthread_rwlock_wrlock(v90);
      if (v36)
        panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 1241, v36);
      v39 = v12++ < 2;
      if (!v39)
        goto LABEL_95;
      continue;
    }
    break;
  }
  while (1)
  {
    v13 = (uint64_t **)v33;
    v34 = obj_write_prepare(v33, 0, v89, v30, v31);
    if ((_DWORD)v34)
      break;
    if ((a3 & 2) != 0)
    {
      v35 = v13[19];
      if (!v35)
        v35 = v13[16];
      v13[17] = v35;
    }
    v33 = v13[13];
    if (!v33)
      goto LABEL_84;
  }
  v8 = v34;
  if (!*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 392) + 400) + 76))
  {
    v37 = v13[1];
    if (!v37)
      v37 = (uint64_t *)(*v13)[49];
    if (nx_ratelimit_log_allowed(*(_QWORD *)(*v37 + 392)))
LABEL_216:
      log_err("%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error preparing for write: %d\n", "obj_cache_flush_prepare");
  }
  return v8;
}

uint64_t obj_type_and_flags(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t obj_type(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 36);
}

uint64_t obj_reference_release_wait(_QWORD *a1, int *a2, int a3, int a4)
{
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  unint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  unint64_t v22;
  timespec v23;

  v8 = a1 + 3;
  v7 = *a1;
  do
    v9 = __ldxr(v8);
  while (__stxr(v9 + 16777217, v8));
  if ((v9 & 0xFFFFFF) == 0xFFFFFF)
    panic("Reference count overflowed for object %p!\n", a1);
  v10 = (v9 >> 24) & 0xFFFFF;
  if (v10 == 0xFFFFF)
    panic("Get count overflowed for object %p!\n", a1);
  if ((-(v9 >> 44) & 0xFFFFF) == 0 || (v9 & 0xFFFFFF) != v10)
    goto LABEL_37;
  do
    v12 = __ldxr(v8);
  while (__stxr(v12, v8));
  if ((-(v12 >> 44) & 0xFFFFF) != 0)
  {
    v13 = (unsigned int *)(a1 + 4);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 | 2, v13));
    do
      v15 = __ldxr(v8);
    while (__stxr(v15 - 16777217, v8));
    if (a3)
    {
      v16 = pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 128));
      if (v16)
        panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 3963, v16);
    }
    v17 = *a2 % 0x3B9ACA00u;
    v23.tv_sec = *a2 / 0x3B9ACA00uLL;
    v23.tv_nsec = v17;
    if (a4 == 1)
      v18 = 1;
    else
      v18 = 2;
    if (cv_wait_rw((pthread_cond_t *)(v7 + 1296), (pthread_mutex_t *)v7, v18, &v23) == 35
      && *a2 != 2000000000)
    {
      if ((4 * *a2) >= 0x77359400)
        v19 = 2000000000;
      else
        v19 = 4 * *a2;
      *a2 = v19;
    }
    if (a3)
    {
      v20 = pthread_rwlock_wrlock((pthread_rwlock_t *)(v7 + 128));
      if (v20)
        panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 3980, v20);
    }
    return 1;
  }
  else
  {
LABEL_37:
    do
      v22 = __ldxr(v8);
    while (__stxr(v22 - 0x1000000, v8));
    return 0;
  }
}

uint64_t obj_write_prepare(uint64_t *a1, int a2, uint64_t a3, int8x16_t a4, int8x16_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int *v27;
  unsigned int v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  _BOOL4 v34;
  uint64_t v35;
  _BOOL4 v36;
  int v37;
  int v38;
  unint64_t v39;
  uint64_t v40;
  const char *v41;
  uint64_t v42;
  unsigned int v43;
  unint64_t v44;
  uint64_t v45;
  const char *v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;

  v5 = *(_QWORD *)(*a1 + 392);
  if (a1[1])
    v6 = a1[1];
  else
    v6 = *(_QWORD *)(*a1 + 392);
  if (*(_BYTE *)(v5 + 627))
    return 30;
  v12 = (*(_DWORD *)(*(_QWORD *)(v5 + 376) + 36) + *((_DWORD *)a1 + 12) - 1)
      / *(_DWORD *)(*(_QWORD *)(v5 + 376) + 36);
  v14 = a1 + 18;
  v13 = a1[18];
  v15 = a1[2];
  v16 = a1[15];
  v48 = v16;
  if (a1[19])
  {
    v49 = a1[19];
    goto LABEL_10;
  }
  v49 = a1[16];
  if (v49)
  {
LABEL_10:
    if ((v15 & 0xC0000000) != 0)
    {
      v47 = v12;
      v17 = 0;
      v18 = 0;
      v19 = 0;
      goto LABEL_12;
    }
LABEL_51:
    v47 = v12;
    if (v13 == v16)
    {
      v17 = v49;
    }
    else
    {
      v17 = v49;
      if (a2 || v13)
        goto LABEL_60;
    }
    v32 = v17;
    v17 = 0;
    if (v32)
    {
      v19 = 0;
      goto LABEL_57;
    }
LABEL_60:
    v34 = a2 == 0;
    v35 = a1[2];
    v36 = (v35 & 0xC00000000) != 0;
    if ((v35 & 0x800000000) != 0)
      v37 = 113;
    else
      v37 = 105;
    v19 = v34 && v36;
    if (v34 && v36)
      v38 = v37;
    else
      v38 = 72;
    if ((v35 & 0x10000000) != 0)
    {
      v49 = 0;
    }
    else
    {
      if (*((_WORD *)a1 + 18) == 11 || *((_WORD *)a1 + 20) == 11)
        v39 = 2;
      else
        v39 = 1;
      v49 = v39;
    }
    v40 = spaceman_alloc((_QWORD *)v6, v38, v12, a3, (unint64_t *)&v49, 0);
    if ((_DWORD)v40)
    {
      v7 = v40;
      if (nx_ratelimit_log_allowed(*(_QWORD *)(*(_QWORD *)v6 + 392)))
      {
        if (*(_WORD *)(v6 + 36) == 13)
          v41 = (const char *)(v6 + 3880);
        else
          v41 = (const char *)(*(_QWORD *)(v6 + 384) + 208);
        log_err("%s:%d: %s oid %lld flags 0x%llx 0x%x type 0x%x/0x%x xid %lld (cur xid %lld) error allocating space to write %d; blkcount %d (o_size_phys %d) paddr %lld\n",
          "obj_write_prepare",
          6430,
          v41,
          a1[14],
          a1[2],
          *((_DWORD *)a1 + 8),
          *((_DWORD *)a1 + 9),
          *((_DWORD *)a1 + 10),
          a1[18],
          a3,
          v7,
          v47,
          *((_DWORD *)a1 + 12),
          v49);
      }
      v18 = 0;
      v19 = 0;
      goto LABEL_100;
    }
    if (a1[1])
      apfs_check_for_spillover();
    v16 = v48;
    v18 = v49;
    v33 = v49;
    if (v49)
    {
LABEL_81:
      v49 = v33;
      v42 = a1[2];
      v43 = (v42 >> 2) & 0x700 | (v42 >> 8) & 0xE0 | 4;
      if ((v42 & 0x10000000) == 0)
        v43 = 0;
      if (v13)
        v44 = v13;
      else
        v44 = v16;
      v45 = omap_set(v6, a1[14], v44, v33, *((_DWORD *)a1 + 12), v43 | (v42 >> 26) & 8, a3);
      if (!(_DWORD)v45)
      {
        v16 = v48;
        goto LABEL_12;
      }
      v7 = v45;
      if (nx_ratelimit_log_allowed(*(_QWORD *)(*(_QWORD *)v6 + 392)))
      {
        if (*(_WORD *)(v6 + 36) == 13)
          v46 = (const char *)(v6 + 3880);
        else
          v46 = (const char *)(*(_QWORD *)(v6 + 384) + 208);
        log_err("%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error setting mapping for write %d\n", "obj_write_prepare", 6461, v46, a1[14], a1[2], *((_DWORD *)a1 + 8), *((_DWORD *)a1 + 9), *((_DWORD *)a1 + 10), v7);
      }
      if (!a2)
      {
LABEL_20:
        pthread_mutex_lock((pthread_mutex_t *)*a1);
        if (v18)
          a1[19] = v18;
        if (!v19)
          goto LABEL_24;
LABEL_23:
        a1[2] &= 0xFFFFFFF3FFFFFFFFLL;
LABEL_24:
        if (!(_DWORD)v7)
        {
          v25 = a1[2];
          if ((v25 & 0x40) != 0)
            a1[2] = v25 & 0xFFFFFFFFFFFFFFBFLL;
          if (v13)
            a1[15] = v13;
          v26 = a1[19];
          if (v26)
            a1[16] = v26;
          v27 = (unsigned int *)(a1 + 4);
          do
            v28 = __ldxr(v27);
          while (__stxr(v28, v27));
          if ((v28 & 1) == 0)
          {
            *v14 = 0;
            v14[1] = 0;
          }
        }
        obj_cache_unlock_write(*a1);
        if (v17)
        {
          if (v13)
          {
            if (omap_delete(v6, a1[14], v48, v17, *((_DWORD *)a1 + 12), 0, a3)
              && nx_ratelimit_log_allowed(*(_QWORD *)(*(_QWORD *)v6 + 392)))
            {
              log_err("%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error deleting old mapping %d\n", "obj_write_prepare");
            }
          }
          else if (spaceman_free((const char *)v6, 0, v17, v47, a3)
                 && nx_ratelimit_log_allowed(*(_QWORD *)(*(_QWORD *)v6 + 392)))
          {
            log_err("%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error freeing old location %d\n", "obj_write_prepare");
          }
        }
        return v7;
      }
LABEL_100:
      pthread_mutex_lock((pthread_mutex_t *)*a1);
      v17 = v18;
      if (!v19)
        goto LABEL_24;
      goto LABEL_23;
    }
LABEL_57:
    v33 = a1[19];
    if (!v33)
    {
      v18 = 0;
      goto LABEL_12;
    }
    v18 = 0;
    if (v33 == a1[16])
    {
LABEL_12:
      if ((a1[2] & 0x80020000000) == 0)
      {
        v20 = a1[7];
        a4.i64[0] = *(uint64_t *)((char *)a1 + 36);
        *(_QWORD *)(v20 + 24) = a4.i64[0];
        *(_QWORD *)(v20 + 8) = a1[14];
        if (v13)
          v21 = v13;
        else
          v21 = v16;
        *(_QWORD *)(v20 + 16) = v21;
        v22 = *((_DWORD *)a1 + 12);
        v23 = (unint64_t *)(*(_QWORD *)(*(_QWORD *)(*a1 + 392) + 376) + 984);
        do
          v24 = __ldxr(v23);
        while (__stxr(v24 + 1, v23));
        fletcher64_set_cksum((unint64_t *)v20, (uint32x4_t *)(v20 + 8), (v22 - 8), 0, a4, a5);
      }
      v7 = 0;
      goto LABEL_20;
    }
    goto LABEL_81;
  }
  if ((v15 & 0xC0000000) != 0)
  {
    if (nx_ratelimit_log_allowed(*(_QWORD *)(*(_QWORD *)v6 + 392)))
    {
      if (*(_WORD *)(v6 + 36) == 13)
        v29 = (const char *)(v6 + 3880);
      else
        v29 = (const char *)(*(_QWORD *)(v6 + 384) + 208);
      log_err("%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x non-virtual object missing paddr!\n", "obj_write_prepare", 6383, v29, a1[14], a1[2], *((_DWORD *)a1 + 8), *((_DWORD *)a1 + 9), *((_DWORD *)a1 + 10));
    }
    return 22;
  }
  else
  {
    if ((v15 & 0x40) != 0)
      goto LABEL_51;
    v30 = v12;
    v31 = omap_get(v6, a1[14], v16, &v49, 0, 0, 0);
    v16 = v48;
    v12 = v30;
    if ((v31 & 0xFFFFFFFD) == 0)
      goto LABEL_51;
    v7 = v31;
    if (nx_ratelimit_log_allowed(*(_QWORD *)(*(_QWORD *)v6 + 392)))
      log_err("%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error getting mapping to write %d\n", "obj_write_prepare");
  }
  return v7;
}

void obj_cache_flush_unprepare(uint64_t a1)
{
  int v2;
  uint64_t i;
  unsigned int *v4;
  unsigned int v5;
  int v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  void *v14;

  pthread_mutex_lock((pthread_mutex_t *)a1);
  v2 = pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 128));
  if (v2)
    panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 1351, v2);
  for (i = *(_QWORD *)(a1 + 832); i; i = *(_QWORD *)(i + 104))
  {
    v4 = (unsigned int *)(i + 32);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 | 1, v4));
    if ((v5 & 1) == 0)
    {
      v6 = *(_DWORD *)(i + 36) >> 30;
      if (v6)
      {
        if (v6 != 1)
          panic("bad object type in flush list: oid %lld flags 0x%llx 0x%x\n", *(_QWORD *)(i + 112), *(_QWORD *)(i + 16), *(_DWORD *)(i + 32));
        *(_QWORD *)(i + 88) = 0;
        v8 = *(_QWORD **)(a1 + 824);
        *(_QWORD *)(i + 96) = v8;
        *v8 = i;
        *(_QWORD *)(a1 + 824) = i + 88;
        ++*(_DWORD *)(a1 + 888);
      }
      else
      {
        *(_QWORD *)(i + 88) = 0;
        v7 = *(_QWORD **)(a1 + 808);
        *(_QWORD *)(i + 96) = v7;
        *v7 = i;
        *(_QWORD *)(a1 + 808) = i + 88;
        ++*(_DWORD *)(a1 + 884);
      }
    }
    v9 = *(_QWORD *)(i + 16);
    *(_QWORD *)(i + 16) = v9 & 0xFFFFFDFFFFFFFFFFLL;
    if ((v9 & 0x80) != 0)
    {
      *(_QWORD *)(i + 16) = v9 & 0xFFFFFDFFFFFFFF7FLL;
      cv_wakeup((pthread_cond_t *)(a1 + 1296));
    }
  }
  v10 = pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 128));
  if (v10)
    panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 1371, v10);
  obj_cache_unlock_write(a1);
  v11 = *(_QWORD *)(a1 + 832);
  if (v11)
  {
    v12 = (uint64_t *)(a1 + 832);
    do
    {
      v13 = *(_QWORD *)(v11 + 104);
      *v12 = v13;
      if (!v13)
        *(_QWORD *)(a1 + 840) = v12;
      *(_QWORD *)(v11 + 104) = 3735928559;
      --*(_DWORD *)(a1 + 904);
      v14 = *(void **)(v11 + 64);
      if (v14)
      {
        if (v14 != *(void **)(v11 + 56))
          fs_obj_zfree_oc(v14, *(unsigned int *)(v11 + 48), *(_QWORD *)(v11 + 16), a1);
        *(_QWORD *)(v11 + 64) = 0;
        *(_QWORD *)(v11 + 136) = 0;
      }
      obj_release((uint64_t *)v11);
      v11 = *v12;
    }
    while (*v12);
  }
  pthread_mutex_lock((pthread_mutex_t *)a1);
  if (*(_DWORD *)(a1 + 908) >= 2u)
    cv_wakeup((pthread_cond_t *)(a1 + 1296));
  *(_DWORD *)(a1 + 908) = 0;
  obj_cache_unlock_write(a1);
}

void obj_release(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  char v10;
  unint64_t v11;
  unint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t *v20;
  unsigned int v21;
  unsigned int v22;
  unint64_t v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int *v26;
  unsigned int v27;
  unint64_t v28;
  unsigned int v29;
  unint64_t v30;
  unsigned int *v31;
  unsigned int v32;
  int v33;
  const char *v34;
  int v35;
  __int128 v36;

  v3 = *a1;
  v2 = a1[1];
  if (!v2)
    v2 = *(_QWORD *)(v3 + 392);
  v4 = (unint64_t *)(a1 + 3);
  do
    v5 = __ldxr(v4);
  while (__stxr(v5 - 0x100000000001, v4));
  v6 = v5 & 0xFFFFFF;
  if ((v5 & 0xFFFFFF) == 0)
    panic("Reference count underflowed for object %p!\n", a1);
  v7 = -(uint64_t)(v5 >> 44) & 0xFFFFF;
  if (v7 == 0x80000)
    panic("Release count overflowed for object %p!\n", a1);
  if (v6 >= 2)
  {
    do
      v8 = __ldxr(v4);
    while (__stxr(v8 + 0x100000000000, v4));
    if ((v8 & 0xFFFFFF) == 0 && (-(v8 >> 44) & 0xFFFFF) == 1)
      cv_wakeup((pthread_cond_t *)(v3 + 1296));
    return;
  }
  v9 = a1[2];
  if ((v9 & 0xC) != 0)
    goto LABEL_15;
  if ((v9 & 0xC00000000) == 0)
    goto LABEL_27;
  v13 = (unsigned int *)(a1 + 4);
  do
    v14 = __ldxr(v13);
  while (__stxr(v14, v13));
  if ((v14 & 1) == 0)
  {
LABEL_15:
    pthread_mutex_lock((pthread_mutex_t *)v3);
    v10 = 0;
    v9 = a1[2];
    if (v7 && (v9 & 8) != 0)
    {
      do
        v11 = __ldxr(v4);
      while (__stxr(v11, v4));
      if ((-(v11 >> 44) & 0xFFFFE) != 0)
      {
        do
        {
          v36 = xmmword_1DF2E9010;
          cv_wait_rw((pthread_cond_t *)(v3 + 1296), (pthread_mutex_t *)v3, 2, (timespec *)&v36);
          do
            v12 = __ldxr(v4);
          while (__stxr(v12, v4));
        }
        while ((-(v12 >> 44) & 0xFFFFE) != 0);
        v10 = 0;
        v9 = a1[2];
      }
      else
      {
        v10 = 0;
      }
    }
  }
  else
  {
LABEL_27:
    v10 = 1;
  }
  if ((v9 & 0x80000008) == 0 && *((_WORD *)a1 + 18) != 13 && (a1[4] & 1) == 0)
  {
    v15 = pthread_rwlock_rdlock((pthread_rwlock_t *)(v3 + 128));
    if (v15)
      panic("%s:%d: rdlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 5009, v15);
    obj_cache_enqueue_deferred_update(v3, (uint64_t)a1);
    v16 = pthread_rwlock_unlock((pthread_rwlock_t *)(v3 + 128));
    if (v16)
      panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 5011, v16);
  }
  v17 = a1[14];
  v18 = *((_DWORD *)a1 + 9);
  v19 = a1[2];
  v35 = *((_DWORD *)a1 + 10);
  if ((v10 & 1) != 0)
  {
    v20 = 0;
    v21 = 0;
    v22 = 0;
LABEL_48:
    v26 = (unsigned int *)(a1 + 4);
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 & 0xFFFFFFFD, v26));
    if ((v27 & 2) != 0)
      v20 = a1;
    do
      v28 = __ldxr(v4);
    while (__stxr(v28 + 0x100000000000, v4));
    if ((v28 & 0xFFFFFF) != 0)
      goto LABEL_67;
    goto LABEL_66;
  }
  if ((v19 & 4) != 0)
  {
    v23 = v19 & 0xFFFFFFFFFFFFFFFBLL;
    a1[2] = v19 & 0xFFFFFFFFFFFFFFFBLL;
    v20 = a1;
  }
  else
  {
    v20 = 0;
    v23 = a1[2];
  }
  if ((v23 & 0xC00000000) == 0)
    goto LABEL_46;
  v24 = (unsigned int *)(a1 + 4);
  do
    v25 = __ldxr(v24);
  while (__stxr(v25, v24));
  if ((v23 & 8) != 0 || (v25 & 1) == 0)
  {
    v29 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 392) + 376) + 36);
    v22 = (v29 + *((_DWORD *)a1 + 12) - 1) / v29;
    if ((v23 & 0x800000000) != 0)
      v21 = 80;
    else
      v21 = 72;
    v23 &= 0xFFFFFFF3FFFFFFFFLL;
    a1[2] = v23;
    if ((v23 & 8) == 0)
      goto LABEL_47;
  }
  else
  {
LABEL_46:
    v22 = 0;
    v21 = 0;
    if ((v23 & 8) == 0)
    {
LABEL_47:
      obj_cache_unlock_write(v3);
      goto LABEL_48;
    }
  }
  if ((v23 & 0x80000000) != 0)
    obj_cache_ephemeral_adjust(v3, v23, *((_DWORD *)a1 + 12), -1);
  else
    --*(_DWORD *)(v3 + 684);
  do
    v30 = __ldxr(v4);
  while (__stxr(v30 + 0x100000000000, v4));
  v31 = (unsigned int *)(a1 + 4);
  do
    v32 = __ldxr(v31);
  while (__stxr(v32 & 0xFFFFFFFD, v31));
  obj_destroy_internal((uint64_t)a1, 0);
  obj_cache_unlock_write(v3);
  if ((v32 & 2) != 0)
    goto LABEL_67;
LABEL_66:
  if (v20)
LABEL_67:
    cv_wakeup((pthread_cond_t *)(v3 + 1296));
  if (v22)
  {
    v33 = spaceman_unreserve(v2, v21, v22);
    if (v33)
    {
      if (*(_WORD *)(v2 + 36) == 13)
        v34 = (const char *)(v2 + 3880);
      else
        v34 = (const char *)(*(_QWORD *)(v2 + 384) + 208);
      log_err("%s:%d: %s oid 0x%llx flags 0x%llx type 0x%x/0x%x error unreserving space on non-dirty release: %d\n", "obj_release", 5106, v34, v17, v19, v18, v35, v33);
    }
  }
}

void obj_was_being_written_wakeup(uint64_t a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;

  v2 = *(pthread_mutex_t **)a1;
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  v3 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = (v3 & 0x80 ^ 0xFFFFFDFFFFFFFFFFLL) & v3;
  obj_cache_unlock_write((uint64_t)v2);
  if ((v3 & 0x80) != 0)
    cv_wakeup((pthread_cond_t *)&v2[20].__opaque[8]);
}

uint64_t obj_cache_flush_write(pthread_mutex_t *a1, unsigned int a2)
{
  uint64_t sig;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  const char *v14;
  void *v15;
  void *v16;
  unsigned int v17;
  pthread_mutex_t *v18;
  uint64_t v19;
  uint64_t v20;
  pthread_mutex_t *v22;

  sig = a1[13].__sig;
  if (!sig)
  {
LABEL_37:
    pthread_mutex_lock(a1);
    if (*(_DWORD *)&a1[14].__opaque[4] >= 2u)
      cv_wakeup((pthread_cond_t *)&a1[20].__opaque[8]);
    *(_DWORD *)&a1[14].__opaque[4] = 0;
    obj_cache_unlock_write((uint64_t)a1);
    return 0;
  }
  v4 = 0;
  v5 = 0;
  v22 = a1 + 13;
  v6 = (a2 >> 1) & 1;
  do
  {
    while (1)
    {
      v7 = sig;
      sig = *(_QWORD *)(sig + 104);
      pthread_mutex_lock((pthread_mutex_t *)((char *)a1 + 328));
      v8 = (unsigned int *)(v7 + 32);
      do
        v9 = __ldaxr(v8);
      while (__stxr(v9 | 8, v8));
      while ((v9 & 8) != 0)
      {
        pthread_mutex_unlock((pthread_mutex_t *)((char *)a1 + 328));
        pthread_mutex_lock((pthread_mutex_t *)((char *)a1 + 328));
        do
          v9 = __ldaxr(v8);
        while (__stxr(v9 | 8, v8));
      }
      v10 = obj_write_internal(v7, v6);
      if (v10)
        break;
      v16 = *(void **)(v7 + 56);
      v15 = *(void **)(v7 + 64);
      *(_QWORD *)(v7 + 64) = 0;
      *(_QWORD *)(v7 + 136) = 0;
      do
        v17 = __ldxr(v8);
      while (__stlxr(v17 & 0xFFFFFFF7, v8));
      pthread_mutex_unlock((pthread_mutex_t *)((char *)a1 + 328));
      if (v15 && v15 != v16)
        fs_obj_zfree_oc(v15, *(unsigned int *)(v7 + 48), *(_QWORD *)(v7 + 16), (uint64_t)a1);
      if (!v4)
      {
        v20 = *(_QWORD *)(v22->__sig + 104);
        v22->__sig = v20;
        v18 = v22;
        if (v20)
          goto LABEL_25;
LABEL_24:
        *(_QWORD *)a1[13].__opaque = v18;
        goto LABEL_25;
      }
      v18 = (pthread_mutex_t *)(v4 + 104);
      v19 = *(_QWORD *)(*(_QWORD *)(v4 + 104) + 104);
      *(_QWORD *)(v4 + 104) = v19;
      if (!v19)
        goto LABEL_24;
LABEL_25:
      *(_QWORD *)(v7 + 104) = 3735928559;
      --*(_DWORD *)a1[14].__opaque;
      obj_was_being_written_wakeup(v7);
      obj_release((uint64_t *)v7);
      if (!sig)
        goto LABEL_36;
    }
    v11 = v10;
    do
      v12 = __ldxr(v8);
    while (__stlxr(v12 & 0xFFFFFFF7, v8));
    pthread_mutex_unlock((pthread_mutex_t *)((char *)a1 + 328));
    v13 = *(_QWORD *)(v7 + 8);
    if (!v13)
      v13 = *(_QWORD *)(*(_QWORD *)v7 + 392);
    if (nx_ratelimit_log_allowed(*(_QWORD *)(*(_QWORD *)v13 + 392)))
    {
      if (*(_WORD *)(v13 + 36) == 13)
        v14 = (const char *)(v13 + 3880);
      else
        v14 = (const char *)(*(_QWORD *)(v13 + 384) + 208);
      log_err("%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error writing: %d\n", "obj_cache_flush_write", 1469, v14, *(_QWORD *)(v7 + 112), *(_QWORD *)(v7 + 16), *(_DWORD *)(v7 + 32), *(_DWORD *)(v7 + 36), *(_DWORD *)(v7 + 40), v11);
    }
    if ((_DWORD)v5)
      v5 = v5;
    else
      v5 = v11;
    v4 = v7;
  }
  while (sig);
LABEL_36:
  if (!(_DWORD)v5)
    goto LABEL_37;
  return v5;
}

uint64_t obj_write_internal(uint64_t a1, int a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v2 = *(_QWORD *)(*(_QWORD *)a1 + 392);
  v3 = *(_DWORD *)(a1 + 48);
  if (!a2)
  {
    v4 = *(_QWORD *)(a1 + 56);
LABEL_7:
    v5 = *(_QWORD *)(a1 + 152);
    if (!v5)
    {
      v5 = *(_QWORD *)(a1 + 128);
      if (!v5)
        panic("Object has no address: o %p oid %llu flags 0x%llx 0x%x paddr %llu naddr %llu\n", (const void *)a1, *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 32), 0, 0);
    }
    goto LABEL_10;
  }
  v4 = *(_QWORD *)(a1 + 64);
  if (!v4)
    v4 = *(_QWORD *)(a1 + 56);
  v5 = *(_QWORD *)(a1 + 136);
  if (!v5)
    goto LABEL_7;
LABEL_10:
  if (*(_BYTE *)(v2 + 627))
    return 30;
  v7 = *(_QWORD *)(a1 + 16);
  if ((v7 & 0x10000000) != 0 && (v7 & 0x80000000000) == 0 && (v12 = *(_QWORD *)(a1 + 8)) != 0)
  {
    if ((unsigned __int16)v7 >> 13 == 1)
    {
      v9 = v12 + 624;
    }
    else
    {
      if ((unsigned __int16)v7 >> 13)
        panic("invalid crypto index %d\n");
      v9 = v12 + 528;
    }
    v10 = (v7 >> 10) & 7;
    if ((_DWORD)v10)
    {
      if ((_DWORD)v10 != 1)
        panic("invalid tweak type %d\n");
      v8 = *(_QWORD *)(a1 + 112) ^ HIDWORD(*(_QWORD *)(a1 + 120)) | *(_QWORD *)(a1 + 112) & 0xFFFFFFFF00000000 ^ (*(_QWORD *)(a1 + 120) << 32);
      LODWORD(v10) = 4;
    }
    else
    {
      v8 = (v7 >> 10) & 7;
    }
    v13 = *(_QWORD *)(v12 + 1136);
    if (v13)
      v11 = v13;
    else
      v11 = *(_QWORD *)(v2 + 384);
  }
  else
  {
    v8 = 0;
    v9 = 0;
    LODWORD(v10) = 0;
    v11 = *(_QWORD *)(v2 + 384);
  }
  return dev_write_extended(v11, v5, (*(_DWORD *)(*(_QWORD *)(v2 + 376) + 36) + v3 - 1)/ *(_DWORD *)(*(_QWORD *)(v2 + 376) + 36), v4, v9, v8, v10);
}

BOOL obj_cache_tx_start_closing(uint64_t a1)
{
  unsigned int v1;
  unsigned int v2;

  v1 = *(_DWORD *)(a1 + 888) + *(_DWORD *)(a1 + 884);
  if (dev_is_solidstate(*(_QWORD *)(*(_QWORD *)(a1 + 392) + 384)))
    v2 = 1024;
  else
    v2 = 256;
  return v1 >= v2;
}

void obj_cache_remove(pthread_mutex_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t *opaque;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  const char *v23;
  int v24;
  const char *v25;

  v8 = a2;
  if (!a2)
    v8 = *(_QWORD *)a1[6].__opaque;
  pthread_mutex_lock(a1);
  v9 = *(_QWORD *)(a1[11].__sig + 8 * (*(_DWORD *)&a1[10].__opaque[52] & a3));
  if (!v9)
  {
    obj_cache_unlock_write((uint64_t)a1);
    return;
  }
  v10 = 0;
  v11 = 0;
  opaque = (uint64_t *)a1[11].__opaque;
  do
  {
    while (1)
    {
      v13 = v9;
      v14 = (uint64_t *)(v9 + 72);
      v9 = *(_QWORD *)(v9 + 72);
      if (v13 != a2 && *(_QWORD *)(v13 + 8) == a2)
      {
        v15 = *(_QWORD *)(v13 + 16);
        if ((v15 & 0xC0000000) == 0 && *(_QWORD *)(v13 + 112) == a3 && *(_QWORD *)(v13 + 120) == a4)
          break;
      }
LABEL_19:
      if (!v9)
        goto LABEL_28;
    }
    v16 = (unint64_t *)(v13 + 24);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17, v16));
    if ((v17 & 0xFFFFFF) == ((v17 >> 24) & 0xFFFFF))
    {
      if ((v15 & 0xC00000000) != 0)
      {
        v18 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1[6].__opaque + 376) + 36);
        v19 = (v18 + *(_DWORD *)(v13 + 48) - 1) / v18;
        if ((v15 & 0x800000000) != 0)
          v20 = 0;
        else
          v20 = v19;
        v11 += v20;
        v10 += v19 & (v15 << 28 >> 63);
        *(_QWORD *)(v13 + 16) = v15 & 0xFFFFFFF3FFFFFFFFLL;
      }
      --*(_DWORD *)&a1[10].__opaque[36];
      obj_destroy_internal(v13, 0);
      goto LABEL_19;
    }
    if ((v15 & 1) != 0)
    {
      if (v9)
        *(_QWORD *)(v9 + 80) = *(_QWORD *)(v13 + 80);
      **(_QWORD **)(v13 + 80) = v9;
    }
    v21 = *opaque;
    *v14 = *opaque;
    if (v21)
      *(_QWORD *)(v21 + 80) = v14;
    *opaque = v13;
    *(_QWORD *)(v13 + 80) = opaque;
    *(_QWORD *)(v13 + 16) = v15 | 9;
  }
  while (v9);
LABEL_28:
  obj_cache_unlock_write((uint64_t)a1);
  if (v11)
  {
    v22 = spaceman_unreserve(v8, 0x48u, v11);
    if (v22)
    {
      if (*(_WORD *)(v8 + 36) == 13)
        v23 = (const char *)(v8 + 3880);
      else
        v23 = (const char *)(*(_QWORD *)(v8 + 384) + 208);
      log_err("%s:%d: %s error unreserving space, %lld blocks: %d\n", "obj_cache_remove", 1758, v23, v11, v22);
    }
  }
  if (v10)
  {
    v24 = spaceman_unreserve(v8, 0x50u, v10);
    if (v24)
    {
      if (*(_WORD *)(v8 + 36) == 13)
        v25 = (const char *)(v8 + 3880);
      else
        v25 = (const char *)(*(_QWORD *)(v8 + 384) + 208);
      log_err("%s:%d: %s error unreserving tier2 space, %lld blocks: %d\n", "obj_cache_remove", 1764, v25, v10, v24);
    }
  }
}

void obj_cache_remove_reverted_fs_objects(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  int v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  unint64_t v30;
  unint64_t v31;

  pthread_mutex_lock((pthread_mutex_t *)a1);
  log_debug("%s:%d: %s removing reverted fs objects for fs %lld: %lld - %lld\n", "obj_cache_remove_reverted_fs_objects", 1781, (const char *)(a2 + 3880), *(_QWORD *)(a2 + 112), a3, a4);
  v8 = *(unsigned int *)(a1 + 696);
  if (!(_DWORD)v8)
  {
    obj_cache_unlock_write(a1);
    return;
  }
  v9 = 0;
  v30 = 0;
  v31 = 0;
  v10 = (uint64_t *)(a1 + 712);
  do
  {
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 704) + 8 * v9);
    if (!v11)
      goto LABEL_36;
    do
    {
      while (1)
      {
        v12 = v11;
        v13 = (uint64_t *)(v11 + 72);
        v11 = *(_QWORD *)(v11 + 72);
        if (v12 == a2)
          goto LABEL_24;
        if (*(_QWORD *)(v12 + 8) != a2)
          goto LABEL_24;
        v14 = *(_QWORD *)(v12 + 16);
        if ((v14 & 0xC0000000) != 0)
          goto LABEL_24;
        v15 = *(_QWORD *)(v12 + 120);
        if (v15 <= *(_QWORD *)(v12 + 144))
          v15 = *(_QWORD *)(v12 + 144);
        if (v15 < a3 || v15 > a4)
          goto LABEL_24;
        v17 = *(_DWORD *)(v12 + 32);
        if ((v17 & 1) != 0)
          log_debug("%s:%d: %s danger: oid %lld type 0x%x/0x%x flags 0x%llx 0x%x xid %lld refs 0x%llx - is dirty\n", "obj_cache_remove_reverted_fs_objects", 1798, (const char *)(a2 + 3880), *(_QWORD *)(v12 + 112), *(_DWORD *)(v12 + 36), *(_DWORD *)(v12 + 40), v14, v17, v15, *(_QWORD *)(v12 + 24));
        v18 = (unint64_t *)(v12 + 24);
        do
          v19 = __ldxr(v18);
        while (__stxr(v19, v18));
        if ((v19 & 0xFFFFFF) != ((v19 >> 24) & 0xFFFFF))
          break;
        v20 = *(_QWORD *)(v12 + 16);
        if ((v20 & 0xC00000000) != 0)
        {
          v21 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 392) + 376) + 36);
          v22 = (v21 + *(_DWORD *)(v12 + 48) - 1) / v21;
          if ((v20 & 0x800000000) != 0)
            v23 = 0;
          else
            v23 = v22;
          v30 += v23;
          v31 += v22 & (v20 << 28 >> 63);
          *(_QWORD *)(v12 + 16) = v20 & 0xFFFFFFF3FFFFFFFFLL;
        }
        --*(_DWORD *)(a1 + 684);
        obj_destroy_internal(v12, 0);
LABEL_24:
        if (!v11)
          goto LABEL_35;
      }
      v24 = *(_QWORD *)(v12 + 120);
      if (v24 <= *(_QWORD *)(v12 + 144))
        v24 = *(_QWORD *)(v12 + 144);
      log_debug("%s:%d: %s danger: oid %lld type 0x%x/0x%x flags 0x%llx 0x%x xid %lld refs 0x%llx - has refs\n", "obj_cache_remove_reverted_fs_objects", 1802, (const char *)(a2 + 3880), *(_QWORD *)(v12 + 112), *(_DWORD *)(v12 + 36), *(_DWORD *)(v12 + 40), *(_QWORD *)(v12 + 16), *(_DWORD *)(v12 + 32), v24, *(_QWORD *)(v12 + 24));
      v25 = *(_QWORD *)(v12 + 16);
      if ((v25 & 1) != 0)
      {
        v26 = *v13;
        if (*v13)
          *(_QWORD *)(v26 + 80) = *(_QWORD *)(v12 + 80);
        **(_QWORD **)(v12 + 80) = v26;
      }
      v27 = *v10;
      *v13 = *v10;
      if (v27)
        *(_QWORD *)(v27 + 80) = v13;
      *v10 = v12;
      *(_QWORD *)(v12 + 80) = v10;
      *(_QWORD *)(v12 + 16) = v25 | 9;
    }
    while (v11);
LABEL_35:
    v8 = *(unsigned int *)(a1 + 696);
LABEL_36:
    ++v9;
  }
  while (v9 < v8);
  obj_cache_unlock_write(a1);
  if (v30)
  {
    log_debug("%s:%d: %s unreserving %lld blocks for reverted fs objects\n", "obj_cache_remove_reverted_fs_objects", 1830, (const char *)(a2 + 3880), v30);
    v28 = spaceman_unreserve(a2, 0x48u, v30);
    if (v28)
      log_err("%s:%d: %s error unreserving space, %lld blocks: %d\n", "obj_cache_remove_reverted_fs_objects", 1833, (const char *)(a2 + 3880), v30, v28);
  }
  if (v31)
  {
    log_debug("%s:%d: %s unreserving %lld blocks for reverted fs objects\n", "obj_cache_remove_reverted_fs_objects", 1837, (const char *)(a2 + 3880), v31);
    v29 = spaceman_unreserve(a2, 0x50u, v31);
    if (v29)
      log_err("%s:%d: %s error unreserving tier2 space, %lld blocks: %d\n", "obj_cache_remove_reverted_fs_objects", 1840, (const char *)(a2 + 3880), v31, v29);
  }
}

uint64_t obj_oid(uint64_t a1)
{
  return *(_QWORD *)(a1 + 112);
}

uint64_t obj_xid(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 120) <= *(_QWORD *)(a1 + 144))
    return *(_QWORD *)(a1 + 144);
  else
    return *(_QWORD *)(a1 + 120);
}

void obj_cache_remove_new_fs_objects(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t i;
  uint64_t v6;
  uint64_t *v7;
  _QWORD *v8;
  uint64_t *v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t *v23;

  v22 = 0;
  v23 = &v22;
  pthread_mutex_lock((pthread_mutex_t *)a1);
  v4 = pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 128));
  if (v4)
    panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 1970, v4);
  for (i = *(_QWORD *)(a1 + 800); i; v23 = v7)
  {
    while (1)
    {
      v6 = i;
      v7 = (uint64_t *)(i + 88);
      i = *(_QWORD *)(i + 88);
      if (*(v7 - 10) == a2 && (*(_BYTE *)(v6 + 19) & 0xC0) == 0 && !*(_QWORD *)(v6 + 128))
        break;
      if (!i)
        goto LABEL_13;
    }
    v8 = *(_QWORD **)(v6 + 96);
    if (i)
    {
      *(_QWORD *)(i + 96) = v8;
      v8 = *(_QWORD **)(v6 + 96);
    }
    else
    {
      *(_QWORD *)(a1 + 808) = v8;
    }
    *v8 = i;
    --*(_DWORD *)(a1 + 884);
    v9 = v23;
    *(_QWORD *)(v6 + 88) = 0;
    *(_QWORD *)(v6 + 96) = v9;
    *v9 = v6;
  }
LABEL_13:
  v10 = pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 128));
  if (v10)
    panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 1982, v10);
  v11 = v22;
  if (v22)
  {
    v12 = 0;
    v13 = 0;
    do
    {
      v15 = *(_QWORD *)(v11 + 88);
      v14 = *(uint64_t **)(v11 + 96);
      if (v15)
      {
        *(_QWORD *)(v15 + 96) = v14;
        v14 = *(uint64_t **)(v11 + 96);
      }
      else
      {
        v23 = *(uint64_t **)(v11 + 96);
      }
      *v14 = v15;
      *(_QWORD *)(v11 + 88) = 3735928559;
      v16 = *(_QWORD *)(v11 + 16);
      if ((v16 & 0xC00000000) != 0)
      {
        v17 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 392) + 376) + 36);
        v18 = (v17 + *(_DWORD *)(v11 + 48) - 1) / v17;
        if ((v16 & 0x800000000) != 0)
          v19 = 0;
        else
          v19 = v18;
        v13 += v19;
        v12 += v18 & (v16 << 28 >> 63);
        *(_QWORD *)(v11 + 16) = v16 & 0xFFFFFFF3FFFFFFFFLL;
      }
      --*(_DWORD *)(a1 + 684);
      obj_destroy_internal(v11, 0);
      v11 = v15;
    }
    while (v15);
    obj_cache_unlock_write(a1);
    if (v13)
    {
      v20 = spaceman_unreserve(a2, 0x48u, v13);
      if (v20)
        log_err("%s:%d: %s error unreserving space, %lld blocks: %d\n", "obj_cache_remove_new_fs_objects", 2007, (const char *)(a2 + 3880), v13, v20);
    }
    if (v12)
    {
      v21 = spaceman_unreserve(a2, 0x50u, v12);
      if (v21)
        log_err("%s:%d: %s error unreserving tier2 space, %lld blocks: %d\n", "obj_cache_remove_new_fs_objects", 2013, (const char *)(a2 + 3880), v12, v21);
    }
  }
  else
  {
    obj_cache_unlock_write(a1);
  }
}

uint64_t obj_subtype(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 40);
}

uint64_t obj_flags(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t obj_size_phys(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t obj_type_is_or_contains_ephemeral(int a1)
{
  char v1;
  uint64_t result;

  if (a1 < 0)
    return 1;
  v1 = a1;
  if ((unsigned __int16)a1 > 0xDu)
    return 0;
  result = 1;
  if (((1 << v1) & 0x2832) == 0)
    return 0;
  return result;
}

uint64_t obj_create_bootstrap(pthread_mutex_t *a1, int a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  if (a6 >= 0x1000)
    return obj_create_internal(a1, a2, a3, a4, a5, a6, 0, 0, a7, 1, a8);
  else
    return 22;
}

uint64_t obj_create_internal(pthread_mutex_t *a1, int a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9, char a10, uint64_t *a11)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v16;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v25;
  unsigned int v27;
  uint64_t v28;
  int v29;
  _BOOL4 has_secondary_fsroot;
  int v31;
  unint64_t v32;
  uint64_t v33;
  _BOOL4 is_current_tx;
  unint64_t v35;
  char v36;
  char v37;
  const char *v38;
  unint64_t v39;
  uint64_t v40;
  const char *v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  uint64_t v55;
  const char *v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  unsigned int v61;
  _QWORD *v62;
  uint64_t (*v63)(uint64_t, uint64_t);
  uint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  char v69;
  unint64_t v70;
  unint64_t v71;
  int v72;
  uint64_t v73;
  unsigned int v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  const char *v78;
  unsigned int v79;
  unsigned int v80;
  unint64_t v81;
  unsigned int v82;
  _QWORD *v83;
  uint64_t v84;

  v11 = *(_QWORD *)a1[6].__opaque;
  if (a7)
    v12 = a7;
  else
    v12 = *(_QWORD *)a1[6].__opaque;
  v83 = 0;
  v82 = 0;
  if (!a4)
    return 22;
  if (*(_DWORD *)(a4 + 12) < 0x178u)
    return 22;
  v16 = a6;
  if (!(_DWORD)a6)
  {
    v16 = *(unsigned int *)(a4 + 8);
    if (!(_DWORD)v16)
    {
      if (!v11)
        return 22;
      v16 = *(unsigned int *)(*(_QWORD *)(v11 + 376) + 36);
      if (!(_DWORD)v16)
        return 22;
    }
  }
  if ((a10 & 1) == 0 && v16 % *(_DWORD *)(*(_QWORD *)(v11 + 376) + 36))
    return 22;
  v20 = a2 | (*(unsigned __int16 *)(a4 + 2) << 16);
  v21 = v20 >> 31;
  v22 = v20 >> 30;
  if (!(v20 >> 30))
    ++v21;
  v23 = v21 + ((v20 & 0x40000000) >> 30);
  if ((v20 & 0x88000000) == 0x8000000 || v23 != 1)
    return 22;
  v27 = a2 | (*(unsigned __int16 *)(a4 + 2) << 16);
  if (a7)
  {
    v27 = a2 | (*(unsigned __int16 *)(a4 + 2) << 16);
    if (!v22)
    {
      v28 = *(_QWORD *)(a7 + 496);
      if (!v28)
        v28 = a7;
      if ((*(_BYTE *)(*(_QWORD *)(v28 + 376) + 264) & 1) != 0)
      {
        v27 = v20 & 0xEFFF03FF;
      }
      else
      {
        if (*(_DWORD *)(a4 + 4) == 36)
          v29 = 268443648;
        else
          v29 = 0x10000000;
        v72 = v29;
        v76 = v12;
        has_secondary_fsroot = apfs_has_secondary_fsroot(a7);
        v22 = 0;
        v12 = v76;
        if (has_secondary_fsroot)
          v31 = 1024;
        else
          v31 = 0;
        v27 = v72 | v31 | v20 & 0xEFFF03FF;
      }
    }
  }
  v32 = a9;
  if ((v27 & 0x10000000) != 0)
  {
    v81 = 0;
    if ((v27 & 0x8000000) != 0)
      goto LABEL_46;
  }
  else
  {
    if (*(_DWORD *)a4 == 11 || *(_DWORD *)(a4 + 4) == 11)
      v33 = 2;
    else
      v33 = 1;
    v81 = v33;
    if ((v27 & 0x8000000) != 0)
      goto LABEL_46;
  }
  if ((a10 & 1) == 0)
  {
    if (*(_BYTE *)(v11 + 627))
      return 30;
    v74 = v27;
    v77 = v12;
    v79 = v22;
    is_current_tx = xid_is_current_tx(v11, a9);
    v32 = a9;
    v27 = v74;
    v22 = v79;
    v12 = v77;
    if (!is_current_tx)
      return 22;
  }
LABEL_46:
  v35 = v32;
  if (a8)
  {
    v35 = a8;
    if (a8 > v32)
      return 22;
  }
  if (a3)
    v36 = 1;
  else
    v36 = a10;
  v84 = 0;
  if ((v20 & 0x40000000) != 0)
    v37 = v36;
  else
    v37 = 1;
  v75 = v27;
  v80 = v22;
  v70 = v35;
  if ((v37 & 1) != 0)
  {
    if (v22)
    {
      LODWORD(v71) = 0;
      v73 = v32;
      v78 = (const char *)v12;
      goto LABEL_65;
    }
    v69 = v37;
    v38 = (const char *)v12;
    v71 = (v16 + *(_DWORD *)(*(_QWORD *)(v11 + 376) + 36) - 1)
        / *(_DWORD *)(*(_QWORD *)(v11 + 376) + 36);
    v39 = v32;
    v40 = spaceman_reserve(v12, 72, v71, v32, (int *)&v82);
    if ((_DWORD)v40)
    {
      v25 = v40;
      log_err("%s:%d: %s flags 0x%x type 0x%x/0x%x error reserving %d blocks of space: %d\n", "obj_create_internal");
      return v25;
    }
    v78 = v38;
    v73 = v39;
  }
  else
  {
    v69 = v37;
    v41 = (const char *)v12;
    LODWORD(v71) = (v16 + *(_DWORD *)(*(_QWORD *)(v11 + 376) + 36) - 1)
                 / *(_DWORD *)(*(_QWORD *)(v11 + 376) + 36);
    v42 = v32;
    v43 = spaceman_alloc(v12, 72);
    if ((_DWORD)v43)
    {
      v25 = v43;
      log_err("%s:%d: %s flags 0x%x type 0x%x/0x%x error allocating new physical location %d\n");
      return v25;
    }
    v73 = v42;
    v78 = v41;
    if (a7)
      apfs_check_for_spillover();
  }
  v37 = v69;
LABEL_65:
  pthread_mutex_lock(a1);
  v44 = obj_alloc((uint64_t)a1, *(_DWORD *)(a4 + 12), *(_DWORD *)a4, v16, v75, 0, &v84);
  if ((_DWORD)v44)
  {
    v25 = v44;
    obj_cache_unlock_write((uint64_t)a1);
    if ((v37 & 1) != 0)
    {
      if (v80)
        return v25;
      v45 = v82;
      v46 = v71;
LABEL_117:
      spaceman_unreserve(v78, v45, v46);
      return v25;
    }
    goto LABEL_118;
  }
  v47 = v84;
  v48 = *(_QWORD *)(v84 + 16) | v75 & 0xFFFFFC00;
  *(_QWORD *)(v84 + 16) = v48 | 0x42;
  v49 = *(_DWORD *)a4 | v75 & 0xFFFF0000;
  *(_DWORD *)(v47 + 36) = v49;
  v50 = *(unsigned int *)(a4 + 4);
  v51 = v47;
  *(_DWORD *)(v47 + 40) = v50;
  if (!a7 || (v52 = *(_QWORD *)(a7 + 496)) == 0)
    v52 = a7;
  *(_QWORD *)(v51 + 8) = v52;
  *(_QWORD *)(v51 + 120) = v70;
  *(_QWORD *)(v51 + 144) = 0;
  v53 = v80;
  if ((v20 & 0x80000000) == 0)
  {
    if ((v20 & 0x40000000) != 0)
    {
      if (a3)
        v81 = a3;
      else
        a3 = v81;
      *(_QWORD *)(v51 + 128) = a3;
    }
    else
    {
      if (v80)
        goto LABEL_92;
      v54 = 0x800000162;
      if ((v82 & 0x10) == 0)
        v54 = 0x400000162;
      *(_QWORD *)(v51 + 16) = v48 | v54;
      if (!a3)
      {
        v55 = *(_QWORD *)&a1[6].__opaque[8];
        *(_QWORD *)(v51 + 112) = v55;
        *(_QWORD *)&a1[6].__opaque[8] = v55 + 1;
        if (trace_obj_alloc && (obj_type_expected != v49 || obj_subtype_expected != v50))
        {
          v56 = "virtual";
LABEL_86:
          report_obj_alloc(v51, v56);
          v53 = v80;
          goto LABEL_92;
        }
        goto LABEL_92;
      }
    }
LABEL_91:
    *(_QWORD *)(v51 + 112) = a3;
    goto LABEL_92;
  }
  if (a3)
    goto LABEL_91;
  if ((v75 & 0x8000000) == 0)
  {
    v57 = *(_QWORD *)&a1[6].__opaque[8];
    *(_QWORD *)(v51 + 112) = v57;
    *(_QWORD *)&a1[6].__opaque[8] = v57 + 1;
    if (!trace_obj_alloc)
      goto LABEL_92;
    v56 = "ephemeral";
    goto LABEL_86;
  }
  v68 = *(_QWORD *)&a1[6].__opaque[16];
  *(_QWORD *)(v51 + 112) = v68;
  *(_QWORD *)&a1[6].__opaque[16] = v68 + 1;
LABEL_92:
  if ((*(_BYTE *)(v51 + 19) & 0x20) == 0)
  {
    v58 = *(_QWORD *)(v51 + 56);
    *(_QWORD *)(v58 + 24) = *(_QWORD *)(v51 + 36);
    *(_OWORD *)(v58 + 8) = *(_OWORD *)(v51 + 112);
  }
  v59 = (unint64_t *)(v51 + 24);
  do
    v60 = __ldxr(v59);
  while (__stxr(v60 + 1, v59));
  v61 = v53;
  if ((~(_DWORD)v60 & 0xFFFFFFLL) == 0)
    panic("Reference count overflowed for object %p!\n", (const void *)v51);
  v25 = obj_descriptor_funcs_for_type(*(_DWORD *)(v51 + 36), &v83);
  if ((_DWORD)v25
    || (v62 = v83, *v83)
    && (v25 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))*v83)(*(_QWORD *)(v51 + 56), v16, a5), (_DWORD)v25)
    || (v63 = (uint64_t (*)(uint64_t, uint64_t))v62[1]) != 0 && (v25 = v63(v51, a5), (_DWORD)v25))
  {
    if (v75 < 0)
      obj_cache_ephemeral_adjust((uint64_t)a1, v75, v16, -1);
    else
      --*(_DWORD *)&a1[10].__opaque[36];
    obj_destroy_internal(v51, 0);
    obj_cache_unlock_write((uint64_t)a1);
    if ((v37 & 1) != 0)
    {
      v46 = v71;
      if (v61)
        return v25;
      v45 = v82;
      goto LABEL_117;
    }
LABEL_118:
    spaceman_free(v78, 0, v81, v71, v73);
    return v25;
  }
  obj_init_wakeup(v51, v75);
  v64 = (uint64_t *)(a1[11].__sig + 8 * (*(_QWORD *)(v51 + 112) & *(unsigned int *)&a1[10].__opaque[52]));
  v65 = *v64;
  *(_QWORD *)(v51 + 72) = *v64;
  if (v65)
    *(_QWORD *)(v65 + 80) = v51 + 72;
  *v64 = v51;
  *(_QWORD *)(v51 + 80) = v64;
  *(_QWORD *)(v51 + 16) |= 1uLL;
  if (v75 < 0)
  {
    *(_QWORD *)(v51 + 88) = 0;
    v66 = 760;
    if ((v75 & 0x8000000) == 0)
      v66 = 744;
    v67 = *(uint64_t **)((char *)&a1->__sig + v66);
    *(_QWORD *)(v51 + 96) = v67;
    *v67 = v51;
    *(uint64_t *)((char *)&a1->__sig + v66) = v51 + 88;
  }
  obj_cache_unlock_write((uint64_t)a1);
  if ((v75 & 4) != 0)
    obj_lock(v51, 2);
  v25 = 0;
  *a11 = v51;
  return v25;
}

uint64_t obj_create(pthread_mutex_t *a1, int a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  return obj_create_internal(a1, a2, a3, a4, a5, 0, a6, 0, a7, 0, a8);
}

uint64_t obj_clone(pthread_cond_t **a1, __int16 a2, uint64_t *a3, _BYTE *a4)
{
  pthread_cond_t *v8;
  pthread_cond_t *v9;
  int v10;
  pthread_cond_t *v11;
  uint64_t v12;
  pthread_cond_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  pthread_cond_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t *v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, _QWORD);
  uint64_t v31;
  unsigned int v32;
  _QWORD v33[2];
  uint64_t v34;

  v8 = a1[7];
  v9 = *a1;
  v33[0] = 0;
  v33[1] = 0;
  v32 = 0;
  if (a4)
    *a4 = 0;
  v10 = a2 & 0x210;
  if ((a2 & 0x210) != 0
    || (v26 = obj_descriptor_and_flags_for_type(*((_DWORD *)a1 + 9), &v32, (uint64_t)v33), !(_DWORD)v26))
  {
    v11 = a1[2];
    if ((v11 & 2) != 0)
      return 22;
    v34 = 0;
    v12 = (unint64_t)v11 | 2;
    a1[2] = (pthread_cond_t *)((unint64_t)v11 | 2);
    if (*a3)
    {
      v34 = *a3;
    }
    else
    {
      v26 = obj_alloc((uint64_t)v9, *((_DWORD *)a1 + 11), *((_DWORD *)a1 + 9), *((_DWORD *)a1 + 12), v11 & 0xC0000000, a4, &v34);
      if ((_DWORD)v26)
        return v26;
      v12 = (uint64_t)a1[2];
    }
    LODWORD(v13) = v12 & 0xFFFFFFFB;
    a1[2] = (pthread_cond_t *)(v12 & 0xFFFFFE7FFFFFFFFBLL);
    if (!*((_DWORD *)a1 + 13))
    {
      LODWORD(v13) = v12 & 0xFFFFFFF9;
      a1[2] = (pthread_cond_t *)(v12 & 0xFFFFFE7FFFFFFFF9);
    }
    if ((v12 & 4) != 0)
    {
      cv_wakeup(*a1 + 27);
      v13 = a1[2];
    }
    v14 = v34;
    *(_QWORD *)(v34 + 36) = *(pthread_cond_t **)((char *)a1 + 36);
    *(_QWORD *)(v14 + 8) = a1[1];
    *(_OWORD *)(v14 + 112) = *((_OWORD *)a1 + 7);
    *(_QWORD *)(v14 + 128) = a1[16];
    v15 = v13 & 0xFFFFFC00 | *(_QWORD *)(v14 + 16);
    v16 = v15 | 0x40000000002;
    *(_QWORD *)(v14 + 16) = v15 | 0x40000000002;
    if ((a2 & 0x50) != 0)
    {
      v16 = v15 | 0x4000000000ALL;
      *(_QWORD *)(v14 + 16) = v15 | 0x4000000000ALL;
      if ((a2 & 0x40) != 0)
      {
        v16 = v15 | 0x4100000000ALL;
        *(_QWORD *)(v14 + 16) = v15 | 0x4100000000ALL;
      }
    }
    if ((a2 & 0x200) != 0)
      *(_QWORD *)(v14 + 16) = v16 | 0x80000000000;
    memcpy(*(void **)(v14 + 56), v8, *((unsigned int *)a1 + 12));
    if (v10)
      goto LABEL_17;
    v31 = 0;
    memcpy((void *)(v14 + 376), a1 + 47, *((unsigned int *)a1 + 11) - 376);
    v27 = obj_descriptor_funcs_for_type(*((_DWORD *)a1 + 9), &v31);
    if ((_DWORD)v27)
    {
      v26 = v27;
    }
    else
    {
      v29 = *(uint64_t (**)(uint64_t, _QWORD))(v31 + 8);
      if (!v29 || (v26 = v29(v14, 0), !(_DWORD)v26))
      {
LABEL_17:
        v17 = (uint64_t *)(*(_QWORD *)&v9[14].__opaque[24]
                        + 8 * (*(_QWORD *)(v14 + 112) & *(unsigned int *)&v9[14].__opaque[20]));
        v18 = *v17;
        *(_QWORD *)(v14 + 72) = *v17;
        if (v18)
          *(_QWORD *)(v18 + 80) = v14 + 72;
        *v17 = v14;
        *(_QWORD *)(v14 + 80) = v17;
        v19 = *(_QWORD *)(v14 + 16);
        *(_QWORD *)(v14 + 16) = v19 | 1;
        v20 = a1[2];
        if ((v20 & 0x80000000) != 0)
        {
          *(_QWORD *)(v14 + 88) = 0;
          v21 = (v20 & 0x8000000) == 0;
          v22 = 760;
          if (v21)
            v22 = 744;
          v23 = *(uint64_t **)((char *)&v9->__sig + v22);
          *(_QWORD *)(v14 + 96) = v23;
          *v23 = v14;
          *(uint64_t *)((char *)&v9->__sig + v22) = v14 + 88;
        }
        *(_QWORD *)(v14 + 16) = v19 & 0xFFFFFA7FFFFFFFFALL | 1;
        if (!(*(_DWORD *)(v14 + 52) | a2 & 0x10))
          *(_QWORD *)(v14 + 16) = v19 & 0xFFFFFA7FFFFFFFF8 | 1;
        if ((v19 & 4) != 0)
          cv_wakeup((pthread_cond_t *)(*(_QWORD *)v14 + 1296));
        v24 = (unint64_t *)(v14 + 24);
        do
          v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
        if ((~(_DWORD)v25 & 0xFFFFFFLL) == 0)
          panic("Reference count overflowed for object %p!\n", (const void *)v14);
        v26 = 0;
        *a3 = v14;
        return v26;
      }
    }
    v28 = *(_QWORD *)(v14 + 16);
    if ((v28 & 0x80000000) != 0)
      obj_cache_ephemeral_adjust((uint64_t)v9, v28, *(_DWORD *)(v14 + 48), -1);
    else
      --*(_DWORD *)&v9[14].__opaque[4];
    if (*a3)
      *(_QWORD *)(v14 + 16) &= ~0x40000000000uLL;
    else
      obj_destroy_internal(v14, 0);
  }
  return v26;
}

uint64_t obj_descriptor_and_flags_for_type(int a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v3;
  __int128 *v4;
  unsigned int v5;

  v3 = 22;
  switch((__int16)a1)
  {
    case 1:
      v4 = &nx_desc;
      goto LABEL_17;
    case 2:
      *(_OWORD *)a3 = btree_node_desc;
      *(_DWORD *)a3 = 2;
      goto LABEL_18;
    case 3:
      v4 = &btree_node_desc;
      goto LABEL_17;
    case 5:
      v4 = &sm_desc;
      goto LABEL_17;
    case 6:
      v4 = &sm_cab_desc;
      goto LABEL_17;
    case 7:
      v4 = &sm_cib_desc;
      goto LABEL_17;
    case 8:
      v4 = &sm_bm_desc;
      goto LABEL_17;
    case 11:
      v4 = &om_desc;
      goto LABEL_17;
    case 13:
      v4 = &apfs_desc;
      goto LABEL_17;
    case 17:
      v4 = &nx_reaper_desc;
      goto LABEL_17;
    case 18:
      v4 = &nx_reap_list_desc;
      goto LABEL_17;
    case 25:
      v4 = &gbitmap_desc;
      goto LABEL_17;
    case 27:
      v4 = &gbitmap_block_desc;
      goto LABEL_17;
    case 29:
      v4 = &snap_meta_ext_desc;
      goto LABEL_17;
    case 30:
      v4 = &integrity_meta_desc;
LABEL_17:
      *(_OWORD *)a3 = *v4;
LABEL_18:
      v3 = 0;
      v5 = *a2 | a1 & 0xFFFF0000;
      *a2 = v5;
      *a2 = v5 | (*(unsigned __int16 *)(a3 + 2) << 16);
      break;
    default:
      return v3;
  }
  return v3;
}

uint64_t obj_alloc(uint64_t a1, unsigned int a2, int a3, unsigned int a4, int a5, _BYTE *a6, uint64_t *a7)
{
  _BYTE *v7;
  unsigned int v8;
  int v9;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  char v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  BOOL v28;
  unsigned int v29;
  unsigned int v30;
  BOOL v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  int v35;
  void *v36;
  void *v37;
  size_t v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t (*v42)(uint64_t);
  int v43;
  uint64_t v44;
  const char *v45;
  void *v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  unint64_t *v59;
  unint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  unint64_t *v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t *v66;
  unint64_t v67;
  unint64_t *v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t *v71;
  unint64_t v72;
  unint64_t *v73;
  unint64_t v74;
  unint64_t *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t *v78;
  unint64_t v79;
  unint64_t *v80;
  unint64_t v81;
  char v82;
  char v84;
  unsigned int v85;
  size_t v87;
  void *v89;
  timespec __tp;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  uint64_t v103;
  uint64_t v104;

  v7 = a6;
  v8 = a4;
  v9 = a3;
  v104 = *MEMORY[0x1E0C80C00];
  if (a6)
    *a6 = 0;
  if (a2)
    v11 = a2;
  else
    v11 = 376;
  if (a4)
  {
    v12 = 0;
LABEL_10:
    LOBYTE(v13) = 1;
    goto LABEL_11;
  }
  v13 = *(_QWORD *)(a1 + 392);
  if (v13)
  {
    v12 = 0;
    v8 = *(_DWORD *)(*(_QWORD *)(v13 + 376) + 36);
    goto LABEL_10;
  }
  v8 = 0;
  v12 = 22;
LABEL_11:
  v14 = *(_QWORD *)(a1 + 392);
  if (v11 < 0x178)
  {
    v12 = 22;
    if (!v14)
      goto LABEL_23;
LABEL_19:
    log_err("%s:%d: %s invalid object size: %d size_phys %d\n");
    return v12;
  }
  if (v14)
  {
    if (v8 % *(_DWORD *)(*(_QWORD *)(v14 + 376) + 36))
    {
      LOBYTE(v13) = 0;
      v12 = 22;
    }
    else
    {
      v12 = v12;
    }
    if ((v13 & 1) == 0)
      goto LABEL_19;
  }
  else if ((v13 & 1) == 0)
  {
LABEL_23:
    log_err("%s:%d: invalid object size: %d size_phys %d\n");
    return v12;
  }
  v87 = v11;
  v85 = v8;
  if (a5 < 0)
  {
    v84 = 0;
    v19 = 0;
    v82 = 0;
LABEL_84:
    obj_cache_unlock_write(a1);
    if (v7)
      *v7 = 1;
    v36 = _apfs_obj_zalloc(v8, *(_QWORD *)(a1 + 920));
    obj_cache_stats_update_zalloc((unint64_t *)(a1 + 944), a5, (uint64_t)v36, v8);
    v89 = v36;
    obj_cache_stats_update_zalloc((unint64_t *)(omm + 136), a5, (uint64_t)v36, v8);
    switch((__int16)v9)
    {
      case 1:
        v38 = 1928;
        goto LABEL_97;
      case 2:
      case 3:
      case 6:
      case 7:
      case 8:
        v37 = _apfs_zalloc(4u);
        goto LABEL_98;
      case 5:
        v38 = 1608;
        goto LABEL_97;
      case 11:
        v38 = 496;
        goto LABEL_97;
      case 13:
        v38 = 3912;
        goto LABEL_97;
      case 17:
      case 30:
        v38 = 400;
        goto LABEL_97;
      case 18:
        v38 = 384;
        goto LABEL_97;
      case 25:
        v38 = 416;
        goto LABEL_97;
      case 27:
      case 29:
        v38 = 392;
        goto LABEL_97;
      default:
        v38 = 376;
LABEL_97:
        v37 = _apfs_calloc(1uLL, v38);
LABEL_98:
        v20 = (uint64_t)v37;
        v39 = v89;
        if (v89 && v20)
        {
          *(_QWORD *)(v20 + 24) = 0;
          v40 = new_rwlock((pthread_rwlock_t *)(v20 + 176));
          if (!(_DWORD)v40)
          {
            pthread_mutex_lock((pthread_mutex_t *)a1);
            if (a5 < 0)
            {
              v16 = 1;
              obj_cache_ephemeral_adjust(a1, a5, v8, 1);
              goto LABEL_125;
            }
            v17 = *(_DWORD *)(a1 + 684);
            v16 = 1;
            if (*(_DWORD *)(a1 + 680) - 1 >= v17)
            {
              *(_DWORD *)(a1 + 684) = v17 + 1;
              goto LABEL_125;
            }
            v15 = v20;
            goto LABEL_27;
          }
          v12 = v40;
          v39 = v89;
        }
        else
        {
          v12 = 12;
          if (!v89)
            goto LABEL_115;
        }
        fs_obj_zfree_oc(v39, v8, a5, a1);
LABEL_115:
        if (v20)
          obj_type_free((void *)v20, v9, v11);
        pthread_mutex_lock((pthread_mutex_t *)a1);
        return v12;
    }
  }
  v89 = 0;
  v15 = 0;
  v84 = 0;
  v16 = 0;
  v82 = 0;
  v17 = *(_DWORD *)(a1 + 684);
LABEL_27:
  if (v17 < *(_DWORD *)(a1 + 676))
  {
    v20 = 0;
    goto LABEL_82;
  }
  if ((a5 & 0x40000000) != 0)
    v21 = (uint64_t *)(a1 + 784);
  else
    v21 = (uint64_t *)(a1 + 768);
  if ((a5 & 0x40000000) != 0)
    v22 = (uint64_t *)(a1 + 768);
  else
    v22 = (uint64_t *)(a1 + 784);
  while (1)
  {
    v23 = pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 128));
    if (v23)
      panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 2169, v23);
    v24 = *v21;
    if (!*v21)
    {
      v25 = *v22;
      if (!*v22)
      {
        v20 = 0;
        v24 = 0;
        v11 = v87;
        v9 = a3;
        v8 = v85;
        goto LABEL_78;
      }
      goto LABEL_42;
    }
    if ((*(_BYTE *)(v24 + 32) & 0x10) == 0)
      break;
LABEL_43:
    obj_cache_perform_deferred_updates(a1);
    v26 = pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 128));
    if (v26)
      panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 2206, v26);
    if (*(_DWORD *)(a1 + 684) < *(_DWORD *)(a1 + 676))
    {
      v20 = 0;
      v11 = v87;
      v9 = a3;
      v8 = v85;
      goto LABEL_82;
    }
  }
  v25 = *v22;
  if (!*v22)
    goto LABEL_47;
LABEL_42:
  if ((*(_BYTE *)(v25 + 32) & 0x10) != 0)
    goto LABEL_43;
LABEL_47:
  __tp.tv_sec = 0;
  __tp.tv_nsec = 0;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
  v9 = a3;
  if (v24 && __tp.tv_sec - *(unsigned int *)(v24 + 160) > 599)
  {
    v11 = v87;
    v8 = v85;
    goto LABEL_64;
  }
  v11 = v87;
  v8 = v85;
  if (!v25)
  {
    v28 = *(_DWORD *)(a1 + 684) < *(_DWORD *)(a1 + 680);
LABEL_62:
    v20 = 0;
    if (!v28 && v24)
      goto LABEL_64;
    goto LABEL_72;
  }
  v27 = *(unsigned int *)(v25 + 160);
  if (__tp.tv_sec - v27 > 599)
  {
    v24 = v25;
    goto LABEL_64;
  }
  v29 = *(_DWORD *)(a1 + 684);
  v30 = *(_DWORD *)(a1 + 680);
  v31 = v29 >= v30;
  v28 = v29 < v30;
  if (!v24 || !v31)
  {
    v24 = v25;
    goto LABEL_62;
  }
  if (v27 < *(_DWORD *)(v24 + 160))
    v24 = v25;
LABEL_64:
  if (*(_DWORD *)(v24 + 44) != (_DWORD)v11 || *(_DWORD *)(v24 + 48) != v8)
  {
    v33 = *(_DWORD *)(a1 + 684);
    v84 = 1;
    if (v33 >= *(_DWORD *)(a1 + 680))
    {
      v20 = 0;
      *(_DWORD *)(a1 + 684) = v33 - 1;
      v84 = 1;
      goto LABEL_78;
    }
    v20 = 0;
LABEL_72:
    v24 = 0;
    goto LABEL_78;
  }
  obj_free_list_remove((uint64_t *)v24);
  if (v15)
  {
    fs_obj_zfree_oc(v89, v8, a5, a1);
    free_rwlock((pthread_rwlock_t *)(v15 + 176));
    obj_type_free((void *)v15, a3, v11);
    v89 = 0;
    v82 = 1;
  }
  v32 = *(_QWORD *)(v24 + 16);
  v84 = 1;
  if ((v32 & 1) != 0)
  {
    v34 = *(_QWORD *)(v24 + 72);
    if (v34)
      *(_QWORD *)(v34 + 80) = *(_QWORD *)(v24 + 80);
    v15 = 0;
    **(_QWORD **)(v24 + 80) = v34;
    *(_QWORD *)(v24 + 16) = v32 & 0xFFFFFFFFFFFFFFFELL;
    v84 = 1;
  }
  else
  {
    v15 = 0;
  }
  v20 = v24;
  v24 = 0;
LABEL_78:
  v35 = pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 128));
  if (v35)
    panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 2264, v35);
  if (v24)
    obj_destroy_internal(v24, 0);
LABEL_82:
  if (!(v20 | v15))
  {
    v19 = v16;
    v7 = a6;
    goto LABEL_84;
  }
  if (v20)
  {
    v103 = 0;
    v101 = 0u;
    v102 = 0u;
    v99 = 0u;
    v100 = 0u;
    v97 = 0u;
    v98 = 0u;
    v95 = 0u;
    v96 = 0u;
    v93 = 0u;
    v94 = 0u;
    __tp = (timespec)0;
    v92 = 0u;
    v41 = obj_destroy_for_obj(v20);
    if (v41)
    {
      v42 = (uint64_t (*)(uint64_t))v41;
      obj_cache_unlock_write(a1);
      if (a6)
        *a6 = 1;
      v43 = v42(v20);
      if (v43)
      {
        v44 = *(_QWORD *)(v20 + 8);
        if (v44)
          v45 = (const char *)(v44 + 3880);
        else
          v45 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v20 + 392) + 384) + 208);
        log_err("%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error destroying: %d\n", "obj_alloc", 2360, v45, *(_QWORD *)(v20 + 112), *(_QWORD *)(v20 + 16), *(_DWORD *)(v20 + 32), *(_DWORD *)(v20 + 36), *(_DWORD *)(v20 + 40), v43);
      }
      pthread_mutex_lock((pthread_mutex_t *)a1);
    }
    v46 = *(void **)(v20 + 56);
    v47 = *(_OWORD *)(v20 + 352);
    v101 = *(_OWORD *)(v20 + 336);
    v102 = v47;
    v103 = *(_QWORD *)(v20 + 368);
    v48 = *(_OWORD *)(v20 + 288);
    v97 = *(_OWORD *)(v20 + 272);
    v98 = v48;
    v49 = *(_OWORD *)(v20 + 320);
    v99 = *(_OWORD *)(v20 + 304);
    v100 = v49;
    v50 = *(_OWORD *)(v20 + 224);
    v93 = *(_OWORD *)(v20 + 208);
    v94 = v50;
    v51 = *(_OWORD *)(v20 + 256);
    v95 = *(_OWORD *)(v20 + 240);
    v96 = v51;
    v52 = *(_OWORD *)(v20 + 192);
    __tp = *(timespec *)(v20 + 176);
    v92 = v52;
    v89 = v46;
    bzero(v46, v8);
    bzero((void *)v20, v11);
    v53 = v102;
    *(_OWORD *)(v20 + 336) = v101;
    *(_OWORD *)(v20 + 352) = v53;
    *(_QWORD *)(v20 + 368) = v103;
    v54 = v98;
    *(_OWORD *)(v20 + 272) = v97;
    *(_OWORD *)(v20 + 288) = v54;
    v55 = v100;
    *(_OWORD *)(v20 + 304) = v99;
    *(_OWORD *)(v20 + 320) = v55;
    v56 = v94;
    *(_OWORD *)(v20 + 208) = v93;
    *(_OWORD *)(v20 + 224) = v56;
    v57 = v96;
    *(_OWORD *)(v20 + 240) = v95;
    *(_OWORD *)(v20 + 256) = v57;
    v58 = v92;
    v19 = v16;
    *(timespec *)(v20 + 176) = __tp;
    *(_OWORD *)(v20 + 192) = v58;
  }
  else
  {
    ++*(_DWORD *)(a1 + 684);
    v20 = v15;
    v19 = v16;
  }
LABEL_125:
  *(_QWORD *)v20 = a1;
  *(_DWORD *)(v20 + 36) = v9;
  *(_DWORD *)(v20 + 44) = v11;
  *(_DWORD *)(v20 + 48) = v8;
  *(_QWORD *)(v20 + 56) = v89;
  *(_QWORD *)(v20 + 88) = 3735928559;
  *(_QWORD *)(v20 + 104) = 3735928559;
  *(_DWORD *)(v20 + 160) = -1;
  if ((a5 & 0x80000000) == 0)
  {
    v59 = (unint64_t *)(a1 + 1024);
    do
      v60 = __ldxr(v59);
    while (__stxr(v60 + 1, v59));
    if (v16)
    {
      v61 = (unint64_t *)(a1 + 1032);
      do
        v62 = __ldxr(v61);
      while (__stxr(v62 + 1, v61));
      if ((v19 & 1) != 0)
      {
        v63 = (unint64_t *)(a1 + 1040);
        do
          v64 = __ldxr(v63);
        while (__stxr(v64 + 1, v63));
      }
      v65 = 104;
      if ((v82 & 1) != 0)
        v65 = 112;
      v66 = (unint64_t *)(a1 + v65 + 944);
      do
        v67 = __ldxr(v66);
      while (__stxr(v67 + 1, v66));
    }
    if ((v84 & 1) != 0)
    {
      v68 = (unint64_t *)(a1 + 1064);
      do
        v69 = __ldxr(v68);
      while (__stxr(v69 + 1, v68));
    }
    v70 = omm;
    v71 = (unint64_t *)(omm + 216);
    do
      v72 = __ldxr(v71);
    while (__stxr(v72 + 1, v71));
    if (v16)
    {
      v73 = (unint64_t *)(v70 + 224);
      do
        v74 = __ldxr(v73);
      while (__stxr(v74 + 1, v73));
      if ((v19 & 1) != 0)
      {
        v75 = (unint64_t *)(v70 + 232);
        do
          v76 = __ldxr(v75);
        while (__stxr(v76 + 1, v75));
      }
      v77 = 104;
      if ((v82 & 1) != 0)
        v77 = 112;
      v78 = (unint64_t *)(v70 + v77 + 136);
      do
        v79 = __ldxr(v78);
      while (__stxr(v79 + 1, v78));
    }
    if ((v84 & 1) != 0)
    {
      v80 = (unint64_t *)(v70 + 256);
      do
        v81 = __ldxr(v80);
      while (__stxr(v81 + 1, v80));
    }
  }
  v12 = 0;
  *a7 = v20;
  return v12;
}

uint64_t obj_init_wakeup(uint64_t result, char a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = v2 & 0xFFFFFE7FFFFFFFFBLL;
  if (*(_DWORD *)(result + 52) | a2 & 0x10)
  {
    if ((v2 & 4) == 0)
      return result;
    return cv_wakeup((pthread_cond_t *)(*(_QWORD *)result + 1296));
  }
  *(_QWORD *)(result + 16) = v2 & 0xFFFFFE7FFFFFFFF9;
  if ((v2 & 4) != 0)
    return cv_wakeup((pthread_cond_t *)(*(_QWORD *)result + 1296));
  return result;
}

uint64_t obj_descriptor_funcs_for_type(__int16 a1, _QWORD *a2)
{
  __int16 v2;
  uint64_t result;

  v2 = a1 - 1;
  if ((unsigned __int16)(a1 - 1) > 0x1Du || ((0x350314F7u >> v2) & 1) == 0)
    return 22;
  result = 0;
  *a2 = off_1EA984790[v2];
  return result;
}

void obj_delete_internal(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t i;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  uint64_t *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  const char *v24;
  unsigned int v25;
  uint64_t v26;

  v6 = *a1;
  if ((*((_BYTE *)a1 + 19) & 8) == 0 && !xid_is_current_tx(*(_QWORD *)(v6 + 392), a2))
    panic("can not delete an object w/a non-current xid %lld o == %p\n", a2, a1);
  pthread_mutex_lock((pthread_mutex_t *)v6);
  for (i = a1[2]; (i & 0x20000000000) != 0; i = a1[2])
  {
    a1[2] = i | 0x80;
    cv_wait_rw((pthread_cond_t *)(v6 + 1296), (pthread_mutex_t *)v6, 2, 0);
  }
  a1[2] = i | 0x10;
  a1[18] = a2;
  if ((i & 0x80000000) != 0)
  {
    if (a3)
      a1[2] = i & 0xFFFFFFEFFFFFFFE7 | 0x18;
    obj_cache_unlock_write(v6);
  }
  else
  {
    v8 = a1[19];
    if (!v8)
      v8 = a1[16];
    v26 = v8;
    a1[16] = 0;
    v9 = (unsigned int *)(a1 + 4);
    a1[19] = 0;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 & 0xFFFFFFFE, v9));
    if ((v10 & 1) != 0)
    {
      v11 = pthread_rwlock_wrlock((pthread_rwlock_t *)(v6 + 128));
      if (v11)
        panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 3011, v11);
      v12 = a1[11];
      if (v12 != 3735928559)
      {
        if (*(uint64_t **)(v6 + 864) == a1)
          *(_QWORD *)(v6 + 864) = v12;
        v13 = (uint64_t *)a1[12];
        if ((*((_BYTE *)a1 + 19) & 0x40) != 0)
        {
          if (v12)
          {
            *(_QWORD *)(v12 + 96) = v13;
            v13 = (uint64_t *)a1[12];
          }
          else
          {
            *(_QWORD *)(v6 + 824) = v13;
          }
          *v13 = v12;
          --*(_DWORD *)(v6 + 888);
        }
        else
        {
          if (v12)
          {
            *(_QWORD *)(v12 + 96) = v13;
            v13 = (uint64_t *)a1[12];
          }
          else
          {
            *(_QWORD *)(v6 + 808) = v13;
          }
          *v13 = v12;
          --*(_DWORD *)(v6 + 884);
        }
        a1[11] = 3735928559;
      }
      v14 = pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 128));
      if (v14)
        panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 3025, v14);
    }
    v15 = a1[1];
    if (!v15)
      v15 = *(_QWORD *)(v6 + 392);
    v16 = a1[2];
    v17 = a1[15];
    if (a3)
      a1[2] = v16 & 0xFFFFFFEFFFFFFFF7 | 8;
    v18 = a1[18];
    v19 = *((_DWORD *)a1 + 12);
    v20 = a1[14];
    v22 = *((_DWORD *)a1 + 9);
    v21 = *((_DWORD *)a1 + 10);
    obj_cache_unlock_write(v6);
    if (!(v8 | v16 & 0x40))
    {
      v23 = omap_get(v15, v20, v17, &v26, 0, 0, 0);
      if (v23)
      {
        if (*(_WORD *)(v15 + 36) == 13)
          v24 = (const char *)(v15 + 3880);
        else
          v24 = (const char *)(*(_QWORD *)(v15 + 384) + 208);
        log_err("%s:%d: %s oid 0x%llx flags 0x%llx type 0x%x/0x%x error getting mapping to free %d\n", "obj_delete_internal", 3047, v24, v20, v16, v22, v21, v23);
      }
      v8 = v26;
    }
    if (v8)
    {
      if ((v16 & 0x40000000) != 0)
      {
        v25 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 392) + 376) + 36);
        if (spaceman_free(v15, 0, v8, (v19 + v25 - 1) / v25, v18))
          log_err("%s:%d: %s oid 0x%llx flags 0x%llx type 0x%x/0x%x error freeing space %d\n", "obj_delete_internal");
      }
      else if (omap_delete(v15, v20, v17, v8, v19, 1, v18))
      {
        log_err("%s:%d: %s oid 0x%llx flags 0x%llx type 0x%x/0x%x error deleting mapping %d\n", "obj_delete_internal");
      }
    }
  }
}

void obj_delete_and_free(uint64_t *a1, uint64_t a2)
{
  obj_delete_internal(a1, a2, 1);
}

void obj_free(uint64_t a1)
{
  pthread_mutex_t *v2;

  v2 = *(pthread_mutex_t **)a1;
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 16) & 0xFFFFFFEFFFFFFFF7 | 8;
  obj_cache_unlock_write((uint64_t)v2);
}

uint64_t obj_delete_and_free_by_oid(uint64_t a1, int a2, int a3, unint64_t a4, unint64_t a5, uint64_t a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  unint64_t v23;
  int v24;
  uint64_t v25;
  _QWORD v26[2];
  unsigned int v27;
  uint64_t *v28;
  uint64_t *v29;

  v12 = *(_QWORD *)(a1 + 392);
  v28 = 0;
  v29 = 0;
  v27 = 0;
  v26[0] = 0;
  v26[1] = 0;
  v13 = obj_descriptor_and_flags_for_type(a2, &v27, (uint64_t)v26);
  if (!(_DWORD)v13)
  {
    v25 = 0;
    if (a4)
    {
      v15 = obj_get(a1, 0, a4, (int *)&apfs_desc, 0, 0, 0, 0, (uint64_t *)&v29);
      if ((_DWORD)v15)
      {
        v13 = v15;
        log_err("%s:%d: %s unable to get fs object 0x%llx: %d\n", "obj_delete_and_free_by_oid", 3135, (const char *)(*(_QWORD *)(v12 + 384) + 208), a4, v15);
        return v13;
      }
      v16 = v29;
    }
    else
    {
      v16 = 0;
    }
    if (v16)
      v17 = (uint64_t)v16;
    else
      v17 = v12;
    v18 = v27;
    v19 = obj_get(a1, v27, a5, 0, 0, (uint64_t)v16, 0, 0, (uint64_t *)&v28);
    if ((_DWORD)v19)
    {
      if ((v18 & 0x80000000) != 0)
      {
        v13 = v19;
      }
      else if ((v18 & 0x40000000) != 0)
      {
        v22 = spaceman_free((const char *)v17, 0, a5, (a3 + *(_DWORD *)(*(_QWORD *)(v12 + 376) + 36) - 1)/ *(_DWORD *)(*(_QWORD *)(v12 + 376) + 36), a6);
        v13 = v22;
        if ((_DWORD)v22)
        {
          if (*(_WORD *)(v17 + 36) == 13)
            log_err("%s:%d: %s oid 0x%llx flags 0x%x type 0x%x error freeing space %d\n", "obj_delete_and_free_by_oid", 3157, (const char *)(v17 + 3880), a5, v18, a2, v22);
          else
            log_err("%s:%d: %s oid 0x%llx flags 0x%x type 0x%x error freeing space %d\n", "obj_delete_and_free_by_oid", 3157, (const char *)(*(_QWORD *)(v17 + 384) + 208), a5, v18, a2, v22);
        }
      }
      else
      {
        v24 = 0;
        v23 = 0;
        v20 = omap_get(v17, a5, 0, &v25, &v24, 0, &v23);
        if ((_DWORD)v20)
        {
          v13 = v20;
          log_err("%s:%d: %s oid 0x%llx flags 0x%x type 0x%x error getting mapping to free %d\n");
        }
        else
        {
          v13 = omap_delete(v17, a5, v23, v25, a3, 1, a6);
          if ((_DWORD)v13)
            log_err("%s:%d: %s oid 0x%llx flags 0x%x type 0x%x error deleting mapping %d\n");
        }
        v16 = v29;
      }
    }
    else
    {
      v21 = v28;
      obj_delete_internal(v28, a6, 1);
      obj_release(v21);
      v13 = 0;
    }
    if (v16)
      obj_release(v16);
  }
  return v13;
}

uint64_t obj_get(uint64_t a1, unsigned int a2, unint64_t a3, int *a4, _WORD *a5, uint64_t a6, unint64_t a7, uint64_t a8, uint64_t *a9)
{
  unint64_t v9;
  unint64_t v11;
  unsigned int v16;
  _BOOL4 is_current_tx;
  uint64_t finish;
  unsigned int v21;
  int v22;
  unsigned int v23;
  unint64_t v24;
  int v25;
  int v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  uint64_t v48;
  int v49;
  unsigned int v50;
  char v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t *v62;
  unint64_t v63;
  int v64;
  unint64_t v65;
  uint64_t v66;
  char v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unsigned int v72;
  char v73;
  unint64_t *v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  char v81;
  unsigned int v82;
  uint64_t v83;
  unsigned int v84;
  unint64_t *v85;
  unint64_t v86;
  uint64_t v87;
  uint64_t v88;
  char v89;
  char v90;
  char v91;
  char v92;
  uint64_t v93;
  char v94;
  unint64_t *v95;
  unint64_t v96;
  unint64_t *v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t *v100;
  unint64_t v101;
  unint64_t *v102;
  unint64_t *v103;
  unint64_t v104;
  uint64_t v105;
  BOOL v106;
  uint64_t v107;
  pthread_cond_t *v108;
  uint64_t v109;
  _WORD *v110;
  _QWORD *v111;
  int v112;
  unsigned int v113;
  int v114;
  uint64_t v115;
  unsigned int v116;
  int v117;
  __int16 v118;
  char v119;
  unsigned __int8 v120;
  unsigned int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  uint64_t v125;
  int v126;

  v126 = a2;
  if ((a2 & 8) != 0)
    v9 = a7;
  else
    v9 = 0;
  v123 = v9;
  v124 = 0;
  v121 = 0;
  v122 = 16000;
  v118 = 0;
  *a9 = 0;
  if (a2 >> 30 == 3)
    return 22;
  v11 = a7;
  v16 = a2;
  if ((a2 & 0x8000001) == 1)
  {
    is_current_tx = xid_is_current_tx(*(_QWORD *)(a1 + 392), a8);
    finish = 22;
    if ((~v16 & 0x180) == 0 || !is_current_tx)
      return finish;
  }
  else if ((~a2 & 0x180) == 0)
  {
    return 22;
  }
  if ((~v16 & 0x81) == 0 || (v16 & 0x100) != 0 && (v16 & 0x15) != 0)
    return 22;
  finish = 22;
  if ((v16 & 0x210) == 0x200 || !a3)
    return finish;
  if (*(_QWORD *)(a1 + 1344))
  {
    pthread_mutex_lock((pthread_mutex_t *)a1);
    v120 = 2;
    oc_poll_async_prefetch_objects(a1, &v118);
    if ((_BYTE)v118)
      obj_cache_unlock_write(a1);
  }
  if (a4)
  {
    v16 |= *((unsigned __int16 *)a4 + 1) << 16;
    v126 = v16;
  }
  v21 = v16 >> 30;
  if ((v16 & 0x40000000) == 0 && v16 >> 30 < 2)
    v22 = 4;
  else
    v22 = 0;
  v23 = (v16 & 0x40000000) >> 30;
  if (v21 > 1)
    ++v23;
  if (v23 + ((v16 & 0x40000000) == 0 && v16 >> 30 < 2) != 1
    || (((v16 & 0x40000000) != 0 || v16 >> 30 >= 2) & ((unsigned __int16)(v16 & 0x200) >> 9)) != 0)
  {
    return 22;
  }
  if ((v16 & 0x40000000) != 0 || v16 >> 30 >= 2)
  {
    v11 = 0;
    v123 = 0;
  }
  if ((v16 & 0x8000000) != 0)
  {
    if (v21 >= 2)
    {
      v24 = *(_QWORD *)(a1 + 408);
      if (v24 <= *(_QWORD *)(a1 + 400))
        v24 = *(_QWORD *)(a1 + 400);
      goto LABEL_41;
    }
    return 22;
  }
  if ((v16 & 1) != 0 && *(_BYTE *)(*(_QWORD *)(a1 + 392) + 627))
    return 30;
  if ((v16 & 0x48000000) != 0)
    goto LABEL_42;
  v24 = *(_QWORD *)(a1 + 400);
LABEL_41:
  if (v24 <= a3)
    return 22;
LABEL_42:
  if (a4)
  {
    v114 = *a4;
    v117 = a4[1];
  }
  else
  {
    v114 = 0;
    v117 = 0;
  }
  v110 = a5;
  v25 = v16;
  v26 = v117;
  if (a6 != 0 && (v16 & 0x40000000) == 0 && v16 >> 30 < 2)
  {
    apfs_encryption_state_for_object(a6, v117, (unsigned int *)&v126);
    v25 = v126;
  }
  v116 = v25 & 0xFFFF0000 | v114;
  v125 = 0;
  v27 = v22 | (v16 >> 30) | 0x20;
  v28 = v25;
  pthread_mutex_lock((pthread_mutex_t *)a1);
  v29 = v27;
  v30 = v28;
  finish = 0;
  v120 = 1;
  v31 = (unsigned __int16)v114;
  v108 = (pthread_cond_t *)(a1 + 1296);
  v32 = 512;
  if (!v11)
    v32 = 288;
  v109 = v32;
  v112 = (unsigned __int16)v114;
  while (1)
  {
    v33 = (v29 & 0xFFFFFFBF | (((v30 >> 8) & 1) << 6)) ^ 0x40;
    v119 = 0;
    v34 = *(_QWORD *)(*(_QWORD *)(a1 + 704) + 8 * (*(_DWORD *)(a1 + 700) & a3));
    if (!v34)
    {
      if ((v29 & 2) != 0)
        goto LABEL_241;
LABEL_107:
      if (a4)
      {
        v43 = v125;
        if (!v125)
        {
          v113 = v33;
          v44 = v120;
          if (v120 == 1)
            v44 = 2;
          v120 = v44;
          v46 = a4[2];
          v45 = a4[3];
LABEL_172:
          v26 = v117;
          v47 = v126;
          v68 = obj_alloc(a1, v45, v116, v46, v126, &v119, &v125);
          if ((_DWORD)v68)
          {
            finish = v68;
            v34 = 0;
LABEL_249:
            v107 = 0;
            goto LABEL_250;
          }
          v33 = v113;
          finish = 0;
          if (v119)
            goto LABEL_189;
          v43 = v125;
LABEL_115:
          v125 = 0;
          v48 = v47 & 0xFFFF0000;
          if (a4)
          {
            v49 = a4[1];
            v50 = *a4 | v48;
          }
          else
          {
            v49 = 0;
            v50 = v47 & 0xFFFF0000;
          }
          *(_DWORD *)(v43 + 36) = v50;
          *(_DWORD *)(v43 + 40) = v49;
          *(_QWORD *)(v43 + 112) = a3;
          if (!a6 || (v52 = *(_QWORD *)(a6 + 496)) == 0)
            v52 = a6;
          v53 = (uint64_t *)(*(_QWORD *)(a1 + 704) + 8 * (*(_DWORD *)(a1 + 700) & a3));
          v54 = *v53;
          *(_QWORD *)(v43 + 72) = *v53;
          *(_QWORD *)(v43 + 8) = v52;
          v55 = v123;
          if ((v33 & 8) == 0)
            v55 = v11;
          *(_QWORD *)(v43 + 120) = v55;
          if ((v33 & 1) != 0)
            v56 = a3;
          else
            v56 = 0;
          *(_QWORD *)(v43 + 128) = v56;
          v111 = (_QWORD *)(v43 + 128);
          v57 = *(_QWORD *)(v43 + 16);
          v58 = (unsigned __int16)v47 & 0xFC00;
          if ((v33 & 4) != 0)
            v58 = 0;
          if (v54)
            *(_QWORD *)(v54 + 80) = v43 + 72;
          v59 = v57 | v48 | v58;
          *v53 = v43;
          *(_QWORD *)(v43 + 80) = v53;
          v60 = v59 | 0x10000000003;
          *(_QWORD *)(v43 + 16) = v59 | 0x10000000003;
          if ((v47 & 0x50) != 0)
          {
            v60 = v59 | 0x1000000000BLL;
            *(_QWORD *)(v43 + 16) = v59 | 0x1000000000BLL;
            if ((v47 & 0x40) != 0)
            {
              v60 = v59 | 0x1100000000BLL;
              *(_QWORD *)(v43 + 16) = v59 | 0x1100000000BLL;
            }
          }
          if ((v47 & 0x180) != 0)
            v60 |= 0x8000000000uLL;
          v61 = v60 | ((unint64_t)(v47 & 0x200) << 34);
          if ((v33 & 4) != 0)
            v61 |= v109;
          if ((v47 & 0x380) != 0 || (v33 & 4) != 0)
            *(_QWORD *)(v43 + 16) = v61;
          v62 = (unint64_t *)(v43 + 24);
          do
            v63 = __ldxr(v62);
          while (__stxr(v63 + 1, v62));
          v115 = v43;
          if ((~(_DWORD)v63 & 0xFFFFFF) == 0)
            panic("Reference count overflowed for object %p!\n", (const void *)v43);
          if ((v47 & 0x180) != 0)
            v64 = v33;
          else
            v64 = v33 | 0x10;
          obj_cache_unlock_write(a1);
          v120 = 0;
          LOBYTE(v113) = v64 & 0x9F;
          if ((v64 & 4) != 0)
          {
            v66 = *(_QWORD *)(v115 + 8);
            if (!v66)
              v66 = *(_QWORD *)(a1 + 392);
            finish = omap_get(v66, a3, v11, v111, 0, &v121, &v124);
            if ((_DWORD)finish)
              goto LABEL_179;
            if ((v47 & 8) != 0 && v124 != v11)
            {
              finish = 2;
              goto LABEL_179;
            }
          }
          else if ((_DWORD)finish)
          {
            goto LABEL_179;
          }
          if ((v47 & 0x180) != 0)
          {
            v65 = obj_get_async_read(a1, v47, a4, v110, a6, v115, v124, v121, (_BYTE *)&v118 + 1);
            finish = v65;
            if (HIBYTE(v118))
            {
              if ((_DWORD)v65)
              {
                v107 = v115;
                obj_free(v115);
                v34 = v115;
              }
              else
              {
                v106 = (v47 & 0x100) == 0;
                v34 = v115;
                if (v106)
                  v107 = 0;
                else
                  v107 = v115;
              }
LABEL_250:
              LOBYTE(v33) = v113;
              goto LABEL_251;
            }
          }
          else
          {
            finish = obj_read(v115, v124, v121, 0);
          }
LABEL_179:
          pthread_mutex_lock((pthread_mutex_t *)a1);
          v120 = 2;
          v69 = v121;
          v70 = v115;
          if ((v121 & 0xE0) != 0)
            *(_QWORD *)(v115 + 16) = *(_QWORD *)(v115 + 16) & 0xFFFFFFFFFFFF1FFFLL | ((unint64_t)(v121 >> 5) << 13);
          if ((v69 & 0x700) != 0)
            *(_QWORD *)(v115 + 16) = *(_QWORD *)(v115 + 16) & 0xFFFFFFFFFFFFE3FFLL | (((v69 >> 8) & 7) << 10);
          if ((_DWORD)finish)
            goto LABEL_243;
          v71 = obj_init((pthread_cond_t **)v115, v47, a3, a4, (uint64_t)v110, v11, v116, v117);
          if ((_DWORD)v71)
          {
            finish = v71;
            v70 = v115;
LABEL_243:
            *(_DWORD *)(v70 + 52) = finish;
            obj_init_wakeup(v115, v47);
            v107 = v115;
            v34 = 0;
            if ((v64 & 0x10) != 0)
              LOBYTE(v33) = v64 & 0x8F;
            else
              LOBYTE(v33) = v64 & 0x9F;
            *(_QWORD *)(v115 + 16) = *(_QWORD *)(v115 + 16) & 0xFFFFFFEFFFFFFFF7 | 8;
LABEL_251:
            v87 = v125;
            if (v125)
              goto LABEL_252;
            goto LABEL_253;
          }
          v33 = v64 & 0xFFFFFF9F;
          v35 = v115;
          goto LABEL_186;
        }
      }
      else
      {
        if ((v126 & 0x10) == 0)
        {
          v34 = 0;
          v107 = 0;
          goto LABEL_251;
        }
        v43 = v125;
        if (!v125)
        {
          v113 = v33;
          v45 = 0;
          v46 = 0;
          v67 = v120;
          if (v120 == 1)
            v67 = 2;
          v120 = v67;
          goto LABEL_172;
        }
      }
      v47 = v126;
      goto LABEL_115;
    }
    v35 = 0;
LABEL_52:
    v36 = *(_QWORD *)(v34 + 8);
    if (v36 != a6 && (!a6 || v36 != *(_QWORD *)(a6 + 496)))
      goto LABEL_97;
    v37 = *(_QWORD *)(v34 + 16);
    if ((v37 & 0xC8000000) != (v30 & 0xC8000000) || *(_QWORD *)(v34 + 112) != a3)
      goto LABEL_97;
    if ((v37 & 2) == 0)
      break;
    if ((v30 & 0x180) == 0)
    {
      v81 = v120;
      if (v120 == 1)
        v81 = 2;
      v120 = v81;
      *(_QWORD *)(v34 + 16) = v37 | 4;
      v82 = (v29 & 0xFFFFFFBF | (((v30 >> 8) & 1) << 6)) ^ 0x40;
      obj_initting_wait((uint64_t *)v34);
      v31 = v112;
      v33 = v82;
LABEL_231:
      v26 = v117;
      goto LABEL_190;
    }
    if (*(_DWORD *)(v34 + 52))
    {
      v107 = 0;
      finish = *(unsigned int *)(v34 + 52);
      goto LABEL_251;
    }
    if ((~(_BYTE)v37 & 0xA) == 0)
    {
      v107 = 0;
      finish = 16;
      goto LABEL_251;
    }
    if ((v30 & 0x100) != 0)
    {
      v107 = 0;
      finish = 0;
      goto LABEL_251;
    }
    v113 = (v29 & 0xFFFFFFBF | (((v30 >> 8) & 1) << 6)) ^ 0x40;
    if ((v37 & 0x8000000000) != 0)
    {
      *(_QWORD *)(v34 + 16) = v37 | 4;
      cv_wait_rw(v108, (pthread_mutex_t *)a1, 2, 0);
    }
    else if ((obj_reference_release_wait((_QWORD *)v34, &v122, 0, v120) & 1) == 0)
    {
      v107 = 0;
      finish = 0;
      goto LABEL_250;
    }
    v33 = v113;
LABEL_189:
    v31 = v112;
LABEL_190:
    v30 = v126;
    v29 = v33;
  }
  if (v31 && (unsigned __int16)*(_DWORD *)(v34 + 36) && ((*(_DWORD *)(v34 + 36) ^ v116) & 0xEFFFFFFF) != 0
    || v26 && *(_DWORD *)(v34 + 40) != v26)
  {
    goto LABEL_97;
  }
  if ((v29 & 3) != 0)
  {
    v35 = v34;
    if ((v29 & 2) == 0)
      goto LABEL_99;
LABEL_176:
    if (v35)
      goto LABEL_186;
LABEL_241:
    v34 = 0;
    v107 = 0;
    finish = 2;
    goto LABEL_251;
  }
  if (v123)
  {
    v38 = *(_QWORD *)(v34 + 120);
    if (v38 <= *(_QWORD *)(v34 + 144))
      v38 = *(_QWORD *)(v34 + 144);
    if (!v11)
    {
      if (v38 < v123)
        goto LABEL_97;
LABEL_76:
      v39 = 1;
      goto LABEL_77;
    }
    if (v38 != v123)
      goto LABEL_97;
  }
  else
  {
    if (!v11)
      goto LABEL_76;
    v38 = *(_QWORD *)(v34 + 120);
    if (v38 <= *(_QWORD *)(v34 + 144))
      v38 = *(_QWORD *)(v34 + 144);
  }
  if (v38 > v11)
    goto LABEL_97;
  v39 = 0;
LABEL_77:
  if (!v35)
    goto LABEL_96;
  v40 = *(_QWORD *)(v34 + 120);
  if (v40 <= *(_QWORD *)(v34 + 144))
    v40 = *(_QWORD *)(v34 + 144);
  v41 = *(_QWORD *)(v35 + 120);
  if (v41 <= *(_QWORD *)(v35 + 144))
    v41 = *(_QWORD *)(v35 + 144);
  if (v40 >= v41)
  {
    if (v40 == v41)
    {
      if ((v39 & 1) != 0)
      {
        if ((v37 & 0x200) != 0 && (*(_BYTE *)(v35 + 17) & 2) == 0)
          goto LABEL_97;
      }
      else if ((v37 & 0x200) == 0 && (*(_BYTE *)(v35 + 17) & 2) != 0)
      {
        goto LABEL_97;
      }
    }
    if ((v30 & 0x200) != 0)
    {
      if ((v37 & 0x80000000000) != 0 || (*(_BYTE *)(v35 + 21) & 8) == 0)
LABEL_96:
        v35 = v34;
    }
    else if ((v37 & 0x80000000000) == 0 || (*(_BYTE *)(v35 + 21) & 8) != 0)
    {
      goto LABEL_96;
    }
  }
LABEL_97:
  v34 = *(_QWORD *)(v34 + 72);
  if (v34)
    goto LABEL_52;
  if ((v29 & 2) != 0)
    goto LABEL_176;
LABEL_99:
  if (!v35 || (v29 & 4) == 0)
  {
    if (!v35)
      goto LABEL_107;
    if ((v29 & 4) != 0)
      goto LABEL_119;
LABEL_186:
    v72 = v33;
    v34 = v35;
    finish = obj_get_finish(v35, v126, v11, (v33 >> 6) & 1, &v122, &v120);
    if ((_DWORD)finish != 35)
    {
      v107 = 0;
      LOBYTE(v33) = v72;
      goto LABEL_251;
    }
    v33 = v72;
LABEL_188:
    v26 = v117;
    goto LABEL_189;
  }
  v42 = *(_QWORD *)(v35 + 16);
  if ((v42 & 0x40) != 0)
  {
LABEL_119:
    v42 = *(_QWORD *)(v35 + 16);
    if (v11)
      goto LABEL_120;
    goto LABEL_192;
  }
  if (!v11)
  {
    if (!(*(_QWORD *)(v35 + 16) & 0x20 | v123))
      goto LABEL_210;
LABEL_192:
    if ((v42 & 0x100) != 0)
      goto LABEL_186;
    v51 = 1;
LABEL_194:
    v73 = v120;
    if (v120 == 1)
      v73 = 2;
    v120 = v73;
    v74 = (unint64_t *)(v35 + 24);
    do
      v75 = __ldxr(v74);
    while (__stxr(v75, v74));
    if ((v75 & 0xFFFFFF) == ((v75 >> 24) & 0xFFFFF))
    {
      if ((v51 & 1) != 0)
      {
        v76 = v42 & 0xFFFFFFFFFFFFFCDFLL | 0x120;
LABEL_223:
        *(_QWORD *)(v35 + 16) = v76;
LABEL_227:
        if ((v33 & 8) == 0)
          goto LABEL_186;
        v83 = *(_QWORD *)(v35 + 16);
        if ((v83 & 0x20000000000) == 0)
        {
          v123 = *(_QWORD *)(v35 + 120);
          goto LABEL_107;
        }
        *(_QWORD *)(v35 + 16) = v83 | 0x80;
        v84 = v33;
        cv_wait_rw(v108, (pthread_mutex_t *)a1, 2, 0);
        v31 = v112;
        v33 = v84 & 0xFFFFFFF7;
        goto LABEL_231;
      }
      if ((v30 & 0x200) == 0 || (v42 & 0x80000000000) != 0)
      {
        v76 = v42 & 0xFFFFFFFFFFFFFCFFLL | 0x200;
        goto LABEL_223;
      }
    }
    else
    {
      if ((v51 & 1) != 0)
      {
        if ((v42 & 0x200) != 0)
        {
          v113 = (v29 & 0xFFFFFFBF | (((v30 >> 8) & 1) << 6)) ^ 0x40;
          if (!v125)
          {
            v34 = v35;
            finish = obj_alloc(a1, *(_DWORD *)(v35 + 44), *(_DWORD *)(v35 + 36), *(_DWORD *)(v35 + 48), v30, &v119, &v125);
            if ((_DWORD)finish)
              goto LABEL_249;
            if (v125 == v34 || v119)
              goto LABEL_214;
            v35 = v34;
            v42 = *(_QWORD *)(v34 + 16);
          }
          *(_QWORD *)(v35 + 16) = v42 & 0xFFFFFFFFFFFFFFDFLL;
          v77 = v35;
          if (obj_clone((pthread_cond_t **)v35, 0, &v125, &v119))
          {
            finish = 0;
            v33 = v113 | 8;
            v35 = v77;
          }
          else
          {
            v35 = v125;
            v125 = 0;
            *(_QWORD *)(v35 + 16) |= 0x120uLL;
            v85 = (unint64_t *)(v35 + 24);
            do
              v86 = __ldxr(v85);
            while (__stxr(v86 - 1, v85));
            finish = 0;
            v33 = v113;
          }
        }
        goto LABEL_227;
      }
      if ((v42 & 0x100) == 0 || (v30 & 8) != 0)
      {
        if ((v30 & 0x200) != 0 && (v42 & 0x80000000000) == 0)
          v33 |= 8u;
        goto LABEL_227;
      }
    }
    v33 |= 8u;
    goto LABEL_227;
  }
  if (v11 <= *(_QWORD *)(v35 + 168) || v123)
  {
LABEL_120:
    if ((v42 & 0x200) != 0)
      goto LABEL_186;
    v51 = 0;
    goto LABEL_194;
  }
LABEL_210:
  v78 = v35;
  v113 = (v29 & 0xFFFFFFBF | (((v30 >> 8) & 1) << 6)) ^ 0x40;
  v79 = v120;
  obj_cache_unlock_by_state((pthread_mutex_t *)a1, v120);
  v120 = 0;
  v80 = a6;
  if (!a6)
    v80 = *(_QWORD *)(a1 + 392);
  finish = omap_get(v80, a3, v11, 0, 0, 0, &v123);
  if (!(_DWORD)finish)
  {
    obj_cache_lock_by_state((pthread_mutex_t *)a1, v79);
    v120 = v79;
LABEL_214:
    v33 = v113;
    goto LABEL_188;
  }
  v87 = v125;
  if (v125)
  {
    pthread_mutex_lock((pthread_mutex_t *)a1);
    v107 = 0;
    v120 = 2;
    LOBYTE(v33) = v113;
    v34 = v78;
LABEL_252:
    --*(_DWORD *)(a1 + 684);
    v88 = v87;
    v89 = v33;
    obj_destroy_internal(v88, 1);
    LOBYTE(v33) = v89;
  }
  else
  {
    v107 = 0;
    LOBYTE(v33) = v113;
    v34 = v78;
  }
LABEL_253:
  v90 = v33;
  if (v120)
    obj_cache_unlock_by_state((pthread_mutex_t *)a1, v120);
  if (v107)
    obj_release(v107);
  if (!(_DWORD)finish)
  {
    if (v34)
    {
      v91 = v126;
      if ((v126 & 4) != 0)
      {
        if ((v126 & 1) != 0)
          v92 = 2;
        else
          v92 = 1;
        obj_lock(v34, v92);
        v91 = v126;
      }
      if ((v91 & 1) != 0 && (v93 = obj_modify((_QWORD *)v34, v91 & 3, a8), (_DWORD)v93))
      {
        finish = v93;
        if ((v126 & 4) != 0)
        {
          if ((v126 & 1) != 0)
            v94 = 2;
          else
            v94 = 1;
          obj_unlock(v34, v94);
        }
        obj_release(v34);
      }
      else
      {
        if ((v90 & 2) == 0)
        {
          v95 = (unint64_t *)(a1 + 1072);
          do
            v96 = __ldxr(v95);
          while (__stxr(v96 + 1, v95));
          v97 = (unint64_t *)(a1 + 1088);
          if ((v90 & 0x20) != 0)
            v97 = (unint64_t *)(a1 + 1080);
          do
            v98 = __ldxr(v97);
          while (__stxr(v98 + 1, v97));
          v99 = omm;
          v100 = (unint64_t *)(omm + 264);
          do
            v101 = __ldxr(v100);
          while (__stxr(v101 + 1, v100));
          v102 = (unint64_t *)(v99 + 280);
          v103 = (unint64_t *)(v99 + 272);
          if ((v90 & 0x20) == 0)
            v103 = v102;
          do
            v104 = __ldxr(v103);
          while (__stxr(v104 + 1, v103));
        }
        finish = 0;
        if ((v126 & 0x100) != 0)
          v105 = 0;
        else
          v105 = v34;
        *a9 = v105;
      }
    }
    else
    {
      return 2;
    }
  }
  return finish;
}

uint64_t oc_poll_async_prefetch_objects(uint64_t result, _BYTE *a2)
{
  uint64_t v2;
  uint64_t v4;

  *a2 = 1;
  v2 = *(_QWORD *)(result + 1344);
  if (v2)
  {
    v4 = result;
    while (1)
    {
      if ((*(_BYTE *)(*(_QWORD *)(v2 + 136) + 20) & 0x80) == 0)
      {
        result = dev_read_poll(*(_QWORD *)(*(_QWORD *)(v4 + 392) + 384));
        if ((_DWORD)result != 36)
          break;
      }
      v2 = *(_QWORD *)(v2 + 104);
      if (!v2)
        return result;
    }
    return obj_async_finish(v2, a2);
  }
  return result;
}

uint64_t apfs_encryption_state_for_object(uint64_t result, int a2, unsigned int *a3)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  int v9;
  unsigned int v10;

  v4 = *(_QWORD *)(result + 496);
  if (!v4)
    v4 = result;
  v5 = *(_QWORD *)(v4 + 376);
  v6 = *a3;
  if ((*(_BYTE *)(v5 + 264) & 1) != 0)
  {
    v10 = v6 & 0xEFFF03FF;
  }
  else
  {
    v7 = v6 & 0xFFFF1FFF;
    if (a2 == 36)
      v8 = 268443648;
    else
      v8 = 0x10000000;
    *a3 = v7 | v8;
    result = apfs_has_secondary_fsroot(result);
    if ((_DWORD)result)
      v9 = 1024;
    else
      v9 = 0;
    v10 = *a3 & 0xFFFFE3FF | v9;
  }
  *a3 = v10;
  return result;
}

uint64_t obj_initting_wait(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  char v4;
  __int128 v5;

  v1 = *a1;
  v5 = xmmword_1DF2E9010;
  v2 = a1[2];
  result = cv_wait_rw((pthread_cond_t *)(v1 + 1296), (pthread_mutex_t *)v1, 2, (timespec *)((unint64_t)&v5 & (v2 << 23 >> 63)));
  if ((v2 & 0x10000000000) != 0 && *(_QWORD *)(v1 + 1344))
  {
    v4 = 0;
    result = oc_poll_async_prefetch_objects(v1, &v4);
    if (!v4)
      return pthread_mutex_lock((pthread_mutex_t *)v1);
  }
  return result;
}

unint64_t obj_get_async_read(uint64_t a1, int a2, _OWORD *a3, _WORD *a4, uint64_t a5, uint64_t a6, unint64_t a7, unsigned int a8, _BYTE *a9)
{
  void (**v17)(uint64_t, int8x16_t, int8x16_t);
  void (**v18)(uint64_t, int8x16_t, int8x16_t);
  void (*v19)(uint64_t, int8x16_t, int8x16_t);
  size_t v20;
  unint64_t v21;
  const char *v22;
  void (***v23)(uint64_t, int8x16_t, int8x16_t);
  unint64_t *v24;
  unint64_t v25;
  unsigned int *v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;

  *a9 = 0;
  v17 = (void (**)(uint64_t, int8x16_t, int8x16_t))_apfs_calloc(1uLL, 0xA0uLL);
  if (!v17)
  {
    v21 = 12;
LABEL_15:
    *a9 = 1;
    return v21;
  }
  v18 = v17;
  if (!a4)
    goto LABEL_18;
  if (*a4 != 25987)
  {
    if (!a5)
      a5 = *(_QWORD *)(a1 + 392);
    if (*(_WORD *)(a5 + 36) == 13)
      v22 = (const char *)(a5 + 3880);
    else
      v22 = (const char *)(*(_QWORD *)(a5 + 384) + 208);
    log_err("%s:%d: %s oid 0x%llx flags 0x%x type 0x%x/0x%x: attempt to perform async fetch without proper init args\n", "obj_get_async_read", 3585, v22, *(_QWORD *)(a6 + 112), a2, *(_DWORD *)(a6 + 36), *(_DWORD *)(a6 + 40));
    v21 = 22;
    goto LABEL_14;
  }
  if (!a4[1])
  {
    v20 = 0;
    v19 = v17[19];
    goto LABEL_17;
  }
  v19 = (void (*)(uint64_t, int8x16_t, int8x16_t))_apfs_malloc((unsigned __int16)a4[1]);
  bzero(v19, (unsigned __int16)a4[1]);
  v18[19] = v19;
  if (!v19)
  {
    v21 = 12;
LABEL_14:
    _apfs_free(v18, 160);
    goto LABEL_15;
  }
  v20 = (unsigned __int16)a4[1];
LABEL_17:
  memcpy(v19, a4, v20);
  *((_BYTE *)v18 + 148) = 1;
LABEL_18:
  pthread_mutex_lock((pthread_mutex_t *)a1);
  v18[13] = 0;
  v23 = *(void (****)(uint64_t, int8x16_t, int8x16_t))(a1 + 1352);
  v18[14] = (void (*)(uint64_t, int8x16_t, int8x16_t))v23;
  *v23 = v18;
  *(_QWORD *)(a1 + 1352) = v18 + 13;
  obj_cache_unlock_write(a1);
  *v18 = obj_get_callback;
  v18[17] = (void (*)(uint64_t, int8x16_t, int8x16_t))a6;
  *(_OWORD *)(v18 + 15) = *a3;
  *((_DWORD *)v18 + 36) = a2;
  v24 = (unint64_t *)(a6 + 24);
  do
    v25 = __ldxr(v24);
  while (__stxr(v25 + 1, v24));
  if ((~(_DWORD)v25 & 0xFFFFFFLL) == 0)
    panic("Reference count overflowed for object %p!\n", (const void *)a6);
  v26 = (unsigned int *)(a1 + 916);
  do
    v27 = __ldxr(v26);
  while (__stxr(v27 + 1, v26));
  v21 = obj_read(a6, a7, a8, (uint64_t)v18);
  if (!(_DWORD)v21)
  {
    *a9 = 1;
    pthread_mutex_lock((pthread_mutex_t *)a1);
    v28 = *(_QWORD *)(a6 + 16);
    v29 = (v28 & 4 ^ 0xFFFFFF7FFFFFFFFFLL) & v28;
    if ((a8 & 0xE0) != 0)
      v29 = v29 & 0xFFFFFFFFFFFF1FFFLL | (a8 << 8) & 0xE000;
    if ((a8 & 0x700) != 0)
      v29 = v29 & 0xFFFFFFFFFFFFE3FFLL | (4 * a8) & 0x1C00;
    *(_QWORD *)(a6 + 16) = v29;
    obj_cache_unlock_write(a1);
    if ((v28 & 4) != 0)
      cv_wakeup((pthread_cond_t *)(a1 + 1296));
    return 0;
  }
  return v21;
}

unint64_t obj_read(uint64_t a1, unint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t extended;
  int8x16_t v20;
  int8x16_t v21;
  uint64_t v22;
  const char *v23;

  v7 = *(_QWORD *)(a1 + 128);
  v8 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v9 = *(_DWORD *)(a1 + 36);
    if ((a3 & 4) != 0 && v8)
    {
      *(_DWORD *)(a1 + 36) = v9 | 0x10000000;
      if ((*(_BYTE *)(a1 + 21) & 8) != 0)
      {
        v13 = 0;
        v14 = 0;
        v15 = 0;
        if ((a3 & 8) != 0)
          goto LABEL_27;
      }
      else
      {
        if (a3 >> 5 == 1)
        {
          v10 = v8 + 624;
          v11 = v8 + 816;
        }
        else
        {
          if (a3 >> 5)
            panic("invalid crypto index %d\n");
          v10 = v8 + 528;
          v11 = v8 + 720;
        }
        if ((a3 & 0x10) != 0)
          v14 = v11;
        else
          v14 = v10;
        v13 = (a3 >> 8) & 7;
        if (v13)
        {
          if (v13 != 1)
            panic("invalid tweak type %d\n");
          v15 = *(_QWORD *)(a1 + 112) ^ HIDWORD(a2) | *(_QWORD *)(a1 + 112) & 0xFFFFFFFF00000000 ^ (a2 << 32);
          v13 = 4;
          if ((a3 & 8) != 0)
            goto LABEL_27;
        }
        else
        {
          v15 = (a3 >> 8) & 7;
          if ((a3 & 8) != 0)
            goto LABEL_27;
        }
      }
    }
    else
    {
      v13 = 0;
      v14 = 0;
      v15 = 0;
      *(_DWORD *)(a1 + 36) = v9 & 0xEFFFFFFF;
      if ((a3 & 8) != 0)
        goto LABEL_27;
    }
    if ((*(_BYTE *)(a1 + 21) & 8) == 0)
    {
LABEL_28:
      if (v14 && (v17 = *(_QWORD *)(v8 + 1136)) != 0)
      {
        v18 = *(_QWORD *)(*(_QWORD *)a1 + 392);
      }
      else
      {
        v18 = *(_QWORD *)(*(_QWORD *)a1 + 392);
        v17 = *(_QWORD *)(v18 + 384);
      }
      extended = dev_read_extended(v17, v7, (*(_DWORD *)(a1 + 48) + *(_DWORD *)(*(_QWORD *)(v18 + 376) + 36) - 1)/ *(_DWORD *)(*(_QWORD *)(v18 + 376) + 36), *(_QWORD *)(a1 + 56), v14, a4 != 0, a4, v15, v13);
      v16 = extended;
      if (!a4 && !(_DWORD)extended)
      {
        if ((*(_QWORD *)(a1 + 16) & 0x80020000000) != 0)
        {
          return 0;
        }
        else
        {
          v16 = obj_checksum_verify(a1, v20, v21);
          if ((_DWORD)v16)
          {
            v22 = *(_QWORD *)(a1 + 8);
            if (v22)
              v23 = (const char *)(v22 + 3880);
            else
              v23 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
            log_err("%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x paddr 0x%llx error verifying checksum\n", "obj_read", 6342, v23, *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 40), *(_QWORD *)(a1 + 128));
          }
        }
      }
      return v16;
    }
LABEL_27:
    *(_QWORD *)(a1 + 120) = a2;
    goto LABEL_28;
  }
  if (v8)
    v12 = (const char *)(v8 + 3880);
  else
    v12 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
  log_err("%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x object missing paddr!\n", "obj_read", 6299, v12, *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 40));
  v16 = 22;
  if (a4)
  {
    *(_DWORD *)(a4 + 96) = 22;
    (*(void (**)(uint64_t))a4)(a4);
  }
  return v16;
}

uint64_t obj_init(pthread_cond_t **a1, __int16 a2, uint64_t a3, _DWORD *a4, uint64_t a5, unint64_t a6, int a7, int a8)
{
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  pthread_cond_t *v15;
  pthread_cond_t *v16;
  pthread_cond_t *v17;
  const char *v18;
  uint64_t (*v19)(pthread_cond_t **, uint64_t);
  int v20;
  pthread_cond_t *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v25;

  v12 = (unint64_t)a1[2];
  if ((v12 & 0x80020000000) != 0)
  {
LABEL_2:
    v13 = 0;
    if ((a2 & 0x210) == 0 && a4)
    {
      v25 = 0;
      v14 = obj_descriptor_funcs_for_type(*((_DWORD *)a1 + 9), &v25);
      if ((_DWORD)v14)
      {
        v13 = v14;
      }
      else
      {
        v19 = *(uint64_t (**)(pthread_cond_t **, uint64_t))(v25 + 8);
        if (v19)
        {
          v13 = v19(a1, a5);
          v12 = (unint64_t)a1[2];
        }
        else
        {
          v13 = 0;
        }
      }
    }
    goto LABEL_33;
  }
  v15 = a1[7];
  v16 = *(pthread_cond_t **)&v15->__opaque[8];
  a1[15] = v16;
  if (!a8)
    *((_DWORD *)a1 + 10) = *(_DWORD *)&v15->__opaque[20];
  if ((!(_WORD)a7 || ((*(_DWORD *)&v15->__opaque[16] ^ a7) & 0xEFFFFFFF) == 0)
    && (!a8 || *(_DWORD *)&v15->__opaque[20] == a8)
    && *(_QWORD *)v15->__opaque == a3)
  {
    v13 = 0;
    if (!a6 || (unint64_t)v16 <= a6)
    {
LABEL_19:
      if (!a4)
        goto LABEL_27;
      goto LABEL_25;
    }
  }
  if ((a2 & 0x20) != 0)
  {
    v13 = 2;
    goto LABEL_19;
  }
  v17 = a1[1];
  if (v17)
    v18 = &v17[80].__opaque[32];
  else
    v18 = (const char *)(*(_QWORD *)(*(_QWORD *)(*a1)[8].__opaque + 384) + 208);
  log_err("%s:%d: %s wrong object at 0x%llx - wanted oid 0x%llx type 0x%x:0x%x xid %lld - got oid 0x%llx type 0x%x:0x%x xid %lld\n", "obj_init", 3217, v18, a1[16], a3, a7, a8, a6, *(_QWORD *)v15->__opaque, *(_DWORD *)&v15->__opaque[16], *(_DWORD *)&v15->__opaque[20], v16);
  v13 = nx_corruption_detected_int(*(_QWORD *)(*a1)[8].__opaque);
  if (!a4)
    goto LABEL_27;
LABEL_25:
  if (*a4)
  {
    v20 = *((_DWORD *)a1 + 9);
    goto LABEL_28;
  }
LABEL_27:
  v21 = a1[7];
  v20 = *(unsigned __int16 *)&v21->__opaque[16] | (*((unsigned __int16 *)a1 + 19) << 16);
  LODWORD(v21) = *(_DWORD *)&v21->__opaque[20];
  *((_DWORD *)a1 + 9) = v20;
  *((_DWORD *)a1 + 10) = (_DWORD)v21;
LABEL_28:
  v12 = (unint64_t)a1[2];
  v22 = v20 & 0x10000000;
  if ((v12 & 0x10000000) != v22)
  {
    v12 = v12 & 0xFFFFFFFFEFFFFFFFLL | v22;
    a1[2] = (pthread_cond_t *)v12;
  }
  if (!(_DWORD)v13)
    goto LABEL_2;
LABEL_33:
  *((_DWORD *)a1 + 13) = v13;
  if (v13 | a2 & 0x10)
    v23 = 0xFFFFFE7FFFFFFFFBLL;
  else
    v23 = 0xFFFFFE7FFFFFFFF9;
  a1[2] = (pthread_cond_t *)(v12 & v23);
  if ((v12 & 4) != 0)
    cv_wakeup(*a1 + 27);
  return v13;
}

uint64_t obj_get_finish(uint64_t a1, int a2, unint64_t a3, int a4, int *a5, _BYTE *a6)
{
  uint64_t v6;
  uint64_t v10;
  uint64_t result;
  unsigned int v12;
  unsigned int *v13;
  unsigned int v14;
  int v15;
  int v16;
  unint64_t v17;

  v6 = *(_QWORD *)(a1 + 16);
  if ((v6 & 0x10) != 0)
    return 2;
  v10 = *(_QWORD *)a1;
  if ((a2 & 0x40) == 0 && (v6 & 0x1000000008) == 0x1000000008)
  {
    if (*a6 == 1)
    {
      *a6 = 2;
      v6 = *(_QWORD *)(a1 + 16);
    }
    *(_QWORD *)(a1 + 16) = v6 & 0xFFFFFFEFFFFFFFF7;
  }
  if (a4 && (obj_reference_release_wait((_QWORD *)a1, a5, 0, *a6) & 1) != 0)
    return 35;
  v12 = a2 & 0xC8000000;
  v13 = (unsigned int *)(a1 + 32);
  do
    v14 = __ldxr(v13);
  while (__stxr(v14 & 0xFFFFFFFD, v13));
  if ((v14 & 2) != 0)
    cv_wakeup((pthread_cond_t *)(v10 + 1296));
  if ((*(_BYTE *)v13 & 1) == 0 && (*(_BYTE *)(a1 + 19) & 0x80) == 0)
  {
    v15 = pthread_rwlock_rdlock((pthread_rwlock_t *)(v10 + 128));
    if (v15)
      panic("%s:%d: rdlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 3300, v15);
    if (*(_QWORD *)(a1 + 88) != 3735928559)
      obj_cache_enqueue_deferred_update(v10, a1);
    v16 = pthread_rwlock_unlock((pthread_rwlock_t *)(v10 + 128));
    if (v16)
      panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 3304, v16);
  }
  result = 0;
  if (!v12 && a3)
  {
    result = 0;
    v17 = *(_QWORD *)(a1 + 168);
    if (v17 <= a3)
      v17 = a3;
    *(_QWORD *)(a1 + 168) = v17;
  }
  return result;
}

void obj_destroy_internal(uint64_t a1, char a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  char v8;
  int v9;
  int v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v4 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(a1 + 16);
  if ((v5 & 1) != 0)
  {
    v6 = *(_QWORD *)(a1 + 72);
    if (v6)
      *(_QWORD *)(v6 + 80) = *(_QWORD *)(a1 + 80);
    **(_QWORD **)(a1 + 80) = v6;
    *(_QWORD *)(a1 + 16) = v5 & 0xFFFFFFFFFFFFFFFELL;
  }
  v7 = (unsigned int *)(a1 + 32);
  v8 = atomic_load((unsigned int *)(a1 + 32));
  v9 = v8 & 0x10;
  if (*(_QWORD *)(a1 + 88) != 3735928559 || v9 != 0)
  {
    v11 = pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 128));
    if (v11)
      panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 2905, v11);
    v12 = *(_QWORD *)(a1 + 88);
    if (v12 == 3735928559)
      goto LABEL_30;
    v13 = *(_QWORD *)(a1 + 16);
    if ((v13 & 0x80000000) == 0)
    {
      if ((*(_BYTE *)v7 & 1) == 0)
      {
        obj_free_list_remove((uint64_t *)a1);
        do
LABEL_30:
          v16 = __ldxr(v7);
        while (__stxr(v16 & 0xFFFFEF, v7));
        if ((v16 & 0x10) != 0)
          *(_QWORD *)(*(_QWORD *)(v4 + 872) + 8 * HIBYTE(v16)) = 0;
        v17 = pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 128));
        if (v17)
          panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 2933, v17);
        goto LABEL_35;
      }
      if (*(_QWORD *)(v4 + 864) == a1)
        *(_QWORD *)(v4 + 864) = v12;
      v15 = *(_QWORD **)(a1 + 96);
      if ((v13 & 0x40000000) != 0)
      {
        if (v12)
        {
          *(_QWORD *)(v12 + 96) = v15;
          v15 = *(_QWORD **)(a1 + 96);
        }
        else
        {
          *(_QWORD *)(v4 + 824) = v15;
        }
        *v15 = v12;
        --*(_DWORD *)(v4 + 888);
      }
      else
      {
        if (v12)
        {
          *(_QWORD *)(v12 + 96) = v15;
          v15 = *(_QWORD **)(a1 + 96);
        }
        else
        {
          *(_QWORD *)(v4 + 808) = v15;
        }
        *v15 = v12;
        --*(_DWORD *)(v4 + 884);
      }
LABEL_29:
      *(_QWORD *)(a1 + 88) = 3735928559;
      goto LABEL_30;
    }
    v14 = *(_QWORD **)(a1 + 96);
    if ((v13 & 0x8000000) != 0)
    {
      if (!v12)
      {
        *(_QWORD *)(v4 + 760) = v14;
        goto LABEL_28;
      }
    }
    else if (!v12)
    {
      *(_QWORD *)(v4 + 744) = v14;
LABEL_28:
      *v14 = v12;
      goto LABEL_29;
    }
    *(_QWORD *)(v12 + 96) = v14;
    v14 = *(_QWORD **)(a1 + 96);
    goto LABEL_28;
  }
LABEL_35:
  if ((a2 & 1) != 0 || !obj_destroy_for_obj(a1))
  {
    obj_destroy_complete(a1, 1);
  }
  else
  {
    if (*(_QWORD *)(v4 + 720))
    {
      v18 = *(_QWORD *)(v4 + 728);
      v20 = *(_QWORD *)(v18 + 72);
      v19 = v18 + 72;
      *(_QWORD *)(a1 + 72) = v20;
      if (v20)
        *(_QWORD *)(*(_QWORD *)v19 + 80) = a1 + 72;
    }
    else
    {
      v19 = v4 + 720;
      *(_QWORD *)(a1 + 72) = 0;
    }
    *(_QWORD *)v19 = a1;
    *(_QWORD *)(a1 + 80) = v19;
    *(_QWORD *)(v4 + 728) = a1;
  }
}

uint64_t obj_lock(uint64_t a1, char a2)
{
  if ((a2 & 1) != 0)
  {
    if (pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 176)))
      panic("%s:%d: rdlock == 0 failed %d\n");
  }
  else
  {
    if ((a2 & 2) == 0)
      panic("invalid lock flags: 0x%x\n");
    if (pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 176)))
      panic("%s:%d: wrlock == 0 failed %d\n");
  }
  return 0;
}

uint64_t obj_modify(_QWORD *a1, char a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  void *v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  const void *v17;
  unsigned int v18;
  const char *v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int *v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v26;
  int v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  unint64_t v37;
  unsigned int v38;
  uint64_t v39;
  const char *v40;
  unsigned int v41;
  unint64_t v42;
  int v43;

  v6 = *a1;
  v7 = *(_QWORD *)(*a1 + 392);
  if (a1[1])
    v8 = a1[1];
  else
    v8 = *(_QWORD *)(*a1 + 392);
  v9 = a1[2];
  if ((v9 & 0x8000000) == 0)
  {
    if (*(_BYTE *)(v7 + 627))
      return 30;
    if (!xid_is_current_tx(*(_QWORD *)(*a1 + 392), a3))
      return 22;
    v9 = a1[2];
  }
  if ((v9 & 0x10000000000) != 0)
  {
    if (*(_WORD *)(v8 + 36) == 13)
      v19 = (const char *)(v8 + 3880);
    else
      v19 = (const char *)(*(_QWORD *)(v8 + 384) + 208);
    log_err("%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x can't modify object before read completes\n", "obj_modify", 5429, v19, a1[14], v9, *((_DWORD *)a1 + 8), *((_DWORD *)a1 + 9), *((_DWORD *)a1 + 10));
    return 22;
  }
  v11 = a1[8];
  if (v11 && v11 == a1[7])
  {
    v12 = *((unsigned int *)a1 + 12);
    v13 = _apfs_obj_zalloc(v12, *(_QWORD *)(v6 + 920));
    obj_cache_stats_update_zalloc((unint64_t *)(v6 + 944), v9, (uint64_t)v13, v12);
    obj_cache_stats_update_zalloc((unint64_t *)(omm + 136), v9, (uint64_t)v13, v12);
    if (!v13)
      return 12;
    v14 = (unsigned int *)(a1 + 4);
    do
      v15 = __ldaxr(v14);
    while (__stxr(v15 | 8, v14));
    if ((v15 & 8) != 0)
    {
      do
      {
        pthread_mutex_lock((pthread_mutex_t *)(v6 + 328));
        pthread_mutex_unlock((pthread_mutex_t *)(v6 + 328));
        do
          v16 = __ldaxr(v14);
        while (__stxr(v16 | 8, v14));
      }
      while ((v16 & 8) != 0);
    }
    v17 = (const void *)a1[8];
    if (v17 && v17 == (const void *)a1[7])
    {
      memcpy(v13, v17, v12);
      a1[8] = v13;
      do
        v20 = __ldxr(v14);
      while (__stlxr(v20 & 0xFFFFFFF7, v14));
    }
    else
    {
      do
        v18 = __ldxr(v14);
      while (__stlxr(v18 & 0xFFFFFFF7, v14));
      fs_obj_zfree_oc(v13, v12, a1[2], v6);
    }
  }
  v21 = a1[2];
  if ((v21 & 0x80000000) != 0)
    return 0;
  if ((v21 & 0xC0000000) == 0)
  {
    if ((v21 & 0xC00000000) != 0 || a1[15] == a3)
      return 0;
    pthread_mutex_lock((pthread_mutex_t *)v6);
    v24 = a1[2];
    if ((v24 & 0xC00000000) == 0)
    {
      while (a1[15] != a3)
      {
        v26 = *(_DWORD *)(*(_QWORD *)(v7 + 376) + 36);
        v27 = *((_DWORD *)a1 + 12);
        v43 = 0;
        if ((v24 & 0x100000000) == 0)
        {
          a1[2] = v24 | 0x100000000;
          v31 = (v26 + v27 - 1) / v26;
          obj_cache_unlock_write(v6);
          v10 = spaceman_reserve(v8, 72, v31, a3, &v43);
          pthread_mutex_lock((pthread_mutex_t *)v6);
          v32 = a1[2];
          a1[2] = v32 & 0xFFFFFFFCFFFFFFFFLL;
          if ((_DWORD)v10)
          {
            if (*(_WORD *)(v8 + 36) == 13)
              v33 = (const char *)(v8 + 3880);
            else
              v33 = (const char *)(*(_QWORD *)(v8 + 384) + 208);
            log_err("%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error reserving %d blocks of space: %d\n", "obj_modify", 5545, v33, a1[14], v32 & 0xFFFFFFFCFFFFFFFFLL, *((_DWORD *)a1 + 8), *((_DWORD *)a1 + 9), *((_DWORD *)a1 + 10), v31, v10);
          }
          else
          {
            v34 = 0x800000000;
            if ((v43 & 0x10) == 0)
              v34 = 0x400000000;
            a1[2] = v34 | v32 & 0xFFFFFFFCFFFFFFFFLL;
          }
          obj_cache_unlock_write(v6);
          if ((v32 & 0x200000000) != 0)
            cv_wakeup((pthread_cond_t *)(v6 + 1296));
          return v10;
        }
        a1[2] = v24 | 0x200000000;
        cv_wait_rw((pthread_cond_t *)(v6 + 1296), (pthread_mutex_t *)v6, 2, 0);
        v24 = a1[2];
        if ((v24 & 0xC00000000) != 0)
          goto LABEL_43;
      }
    }
    goto LABEL_43;
  }
  if ((a2 & 2) == 0)
    return 0;
  v22 = (unsigned int *)(a1 + 4);
  if ((a1[4] & 1) != 0)
    return 0;
  pthread_mutex_lock((pthread_mutex_t *)v6);
  if ((*(_BYTE *)v22 & 1) != 0)
    goto LABEL_43;
  v23 = a1[19];
  if (v23)
  {
LABEL_39:
    obj_dirty_locked(a1, a3, v23);
LABEL_43:
    obj_cache_unlock_write(v6);
    return 0;
  }
  if (a1[15] == a3)
  {
    v23 = a1[16];
    goto LABEL_39;
  }
  v28 = (*(_DWORD *)(*(_QWORD *)(v7 + 376) + 36) + *((_DWORD *)a1 + 12) - 1)
      / *(_DWORD *)(*(_QWORD *)(v7 + 376) + 36);
  do
    v29 = __ldxr(v22);
  while (__stxr(v29 | 1, v22));
  obj_cache_unlock_write(v6);
  if ((*((_BYTE *)a1 + 19) & 0x10) != 0)
  {
    v42 = 0;
  }
  else
  {
    if (*((_WORD *)a1 + 18) == 11 || *((_WORD *)a1 + 20) == 11)
      v30 = 2;
    else
      v30 = 1;
    v42 = v30;
  }
  v35 = spaceman_alloc((_QWORD *)v8, 72, v28, a3, &v42, 0);
  if ((_DWORD)v35)
  {
    v10 = v35;
    if (*(_WORD *)(v8 + 36) == 13)
      v36 = (const char *)(v8 + 3880);
    else
      v36 = (const char *)(*(_QWORD *)(v8 + 384) + 208);
    log_err("%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error allocating new location %d\n", "obj_modify", 5602, v36, a1[14], a1[2], *((_DWORD *)a1 + 8), *((_DWORD *)a1 + 9), *((_DWORD *)a1 + 10), v35);
    pthread_mutex_lock((pthread_mutex_t *)v6);
    do
      v41 = __ldxr(v22);
    while (__stxr(v41 & 0xFFFFFFFE, v22));
    obj_cache_unlock_write(v6);
  }
  else
  {
    if (a1[1])
      apfs_check_for_spillover();
    pthread_mutex_lock((pthread_mutex_t *)v6);
    v37 = a1[16];
    do
      v38 = __ldxr(v22);
    while (__stxr(v38 & 0xFFFFFFFE, v22));
    obj_dirty_locked(a1, a3, v42);
    obj_cache_unlock_write(v6);
    v39 = spaceman_free((const char *)v8, 0, v37, v28, a3);
    v10 = v39;
    if ((_DWORD)v39)
    {
      if (*(_WORD *)(v8 + 36) == 13)
        v40 = (const char *)(v8 + 3880);
      else
        v40 = (const char *)(*(_QWORD *)(v8 + 384) + 208);
      log_err("%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error freeing old space @ 0x%llx: %d\n", "obj_modify", 5624, v40, a1[14], a1[2], *((_DWORD *)a1 + 8), *((_DWORD *)a1 + 9), *((_DWORD *)a1 + 10), v37, v39);
    }
  }
  return v10;
}

uint64_t obj_unlock(uint64_t a1, char a2)
{
  if ((a2 & 1) != 0)
  {
    if (pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 176)))
      goto LABEL_7;
  }
  else
  {
    if ((a2 & 2) == 0)
      panic("invalid unlock flags: 0x%x\n");
    if (pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 176)))
LABEL_7:
      panic("%s:%d: unlock == 0 failed %d\n");
  }
  return 0;
}

uint64_t obj_checkpoint_get(pthread_mutex_t *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unint64_t a7, uint64_t a8, uint64_t *a9)
{
  unsigned int v10;
  unsigned int v12;
  uint64_t v13;
  unint64_t v16;
  __int16 v19;
  int v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  int v27;
  unint64_t v28;
  uint64_t v29;
  int8x16_t v30;
  int8x16_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t (*v44)(uint64_t, _QWORD);
  uint64_t v45;
  unint64_t v46;
  int v47;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;

  v51 = a7;
  v52 = a5;
  v49 = 0;
  if (!a4)
    return 22;
  if (*(_DWORD *)(a4 + 12) < 0x178u)
    return 22;
  v10 = *(_DWORD *)(a4 + 8);
  if (!v10)
    return 22;
  v12 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1[6].__opaque + 376) + 36);
  if (v10 % v12)
    return 22;
  LODWORD(v16) = a6;
  v19 = a2;
  v50 = 0;
  v20 = a2 | (*(unsigned __int16 *)(a4 + 2) << 16);
  pthread_mutex_lock(a1);
  v47 = v20;
  v21 = obj_alloc((uint64_t)a1, *(_DWORD *)(a4 + 12), *(_DWORD *)a4, *(_DWORD *)(a4 + 8), v20, 0, &v50);
  if ((_DWORD)v21)
  {
    v13 = v21;
    goto LABEL_56;
  }
  v22 = (v10 + v12 - 1) / v12;
  v23 = v50;
  *(_DWORD *)(v50 + 36) = *(_DWORD *)a4 | v47 & 0xFFFF0000;
  *(_DWORD *)(v23 + 40) = *(_DWORD *)(a4 + 4);
  *(_QWORD *)(v23 + 112) = a3;
  *(_QWORD *)(v23 + 120) = a8;
  *(_QWORD *)(v23 + 16) |= v47 & 0xA000FC00 | ((unint64_t)(v19 & 0x200) << 34) | 0x2000000002;
  *(_QWORD *)(v23 + 128) = a5;
  v24 = (unint64_t *)(v23 + 24);
  do
    v25 = __ldxr(v24);
  while (__stxr(v25 + 1, v24));
  if ((~(_DWORD)v25 & 0xFFFFFFLL) == 0)
    panic("Reference count overflowed for object %p!\n", (const void *)v23);
  obj_cache_unlock_write((uint64_t)a1);
  if (v22 <= a7)
  {
    v36 = obj_read(v23, 0, 0, 0);
    goto LABEL_30;
  }
  v26 = *(_QWORD *)(v23 + 56);
  v27 = v22;
  do
  {
    if (v51 >= v27)
      v28 = v27;
    else
      v28 = v51;
    v29 = dev_read(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v23 + 392) + 384), v52);
    if ((_DWORD)v29)
    {
      v13 = v29;
      goto LABEL_40;
    }
    v27 -= v28;
    if (!v27)
      goto LABEL_27;
    v32 = *(_QWORD *)a1[6].__opaque;
    v33 = *(_QWORD *)(v32 + 376);
    if ((int)v16 + (int)v28 >= (*(_DWORD *)(v33 + 108) & 0x7FFFFFFFu))
      v16 = 0;
    else
      v16 = (v16 + v28);
    v26 += v28 * *(unsigned int *)(v33 + 36);
    v34 = nx_checkpoint_data_block_address(v32, v16, &v52, &v51);
  }
  while (v27 >= 1 && (_DWORD)v34 == 0);
  v13 = v34;
  if ((_DWORD)v34)
  {
LABEL_40:
    pthread_mutex_lock(a1);
    goto LABEL_53;
  }
LABEL_27:
  if ((*(_QWORD *)(v23 + 16) & 0x80020000000) != 0)
  {
    pthread_mutex_lock(a1);
    goto LABEL_31;
  }
  v36 = obj_checksum_verify(v23, v30, v31);
LABEL_30:
  v13 = v36;
  pthread_mutex_lock(a1);
  if ((_DWORD)v13)
  {
LABEL_53:
    obj_cache_ephemeral_adjust((uint64_t)a1, *(_QWORD *)(v23 + 16), *(_DWORD *)(v23 + 48), -1);
    do
      v46 = __ldxr(v24);
    while (__stxr(v46 - 1, v24));
    goto LABEL_55;
  }
LABEL_31:
  if ((*(_QWORD *)(v23 + 16) & 0x80020000000) == 0)
  {
    v43 = *(_QWORD *)(v23 + 56);
    if (*(_DWORD *)(v43 + 24) != *(_DWORD *)(v23 + 36)
      || *(_DWORD *)(v43 + 28) != *(_DWORD *)(v23 + 40)
      || *(_QWORD *)(v43 + 8) != a3
      || *(_QWORD *)(v43 + 16) != a8)
    {
      v13 = nx_corruption_detected_int(*(_QWORD *)a1[6].__opaque);
      if ((_DWORD)v13)
        goto LABEL_53;
    }
  }
  v37 = (uint64_t *)(a1[11].__sig + 8 * (*(_QWORD *)(v23 + 112) & *(unsigned int *)&a1[10].__opaque[52]));
  v38 = *v37;
  *(_QWORD *)(v23 + 72) = *v37;
  if (v38)
    *(_QWORD *)(v38 + 80) = v23 + 72;
  *v37 = v23;
  *(_QWORD *)(v23 + 80) = v37;
  v39 = *(_QWORD *)(v23 + 16) | 1;
  *(_QWORD *)(v23 + 88) = 0;
  *(_QWORD *)(v23 + 16) = v39;
  v40 = *(uint64_t **)&a1[11].__opaque[32];
  *(_QWORD *)(v23 + 96) = v40;
  *v40 = v23;
  *(_QWORD *)&a1[11].__opaque[32] = v23 + 88;
  v41 = obj_descriptor_funcs_for_type(*(_DWORD *)(v23 + 36), &v49);
  if ((_DWORD)v41)
  {
    v13 = v41;
LABEL_36:
    obj_cache_ephemeral_adjust((uint64_t)a1, v39, *(_DWORD *)(v23 + 48), -1);
    do
      v42 = __ldxr(v24);
    while (__stxr(v42 - 1, v24));
LABEL_55:
    obj_destroy_internal(v23, 0);
LABEL_56:
    obj_cache_unlock_write((uint64_t)a1);
  }
  else
  {
    v44 = *(uint64_t (**)(uint64_t, _QWORD))(v49 + 8);
    if (v44)
    {
      v45 = v44(v23, 0);
      if ((_DWORD)v45)
      {
        v13 = v45;
        v39 = *(_QWORD *)(v23 + 16);
        goto LABEL_36;
      }
    }
    obj_init_wakeup(v23, v47);
    obj_cache_unlock_write((uint64_t)a1);
    v13 = 0;
    *a9 = v23;
  }
  return v13;
}

unint64_t obj_checksum_verify(uint64_t a1, int8x16_t a2, int8x16_t a3)
{
  uint64_t v4;
  _QWORD *v5;
  int v6;
  unint64_t result;
  uint64_t v8;
  const char *v9;
  unint64_t *v10;
  unint64_t v11;
  void (*v12)(uint64_t);

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 392);
  v5 = *(_QWORD **)(a1 + 56);
  v6 = *(_DWORD *)(a1 + 48);
  result = fletcher64_verify_cksum(v5, (uint32x4_t *)(v5 + 1), (v6 - 8), 0, a2, a3);
  if (result)
  {
    v8 = *(_QWORD *)(a1 + 8);
    if (v8)
      v9 = (const char *)(v8 + 3880);
    else
      v9 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
    log_err("%s:%d: %s failed: cksum 0x%016llx, oid 0x%llx, o_xid 0x%llx, o_type 0x%x, o_subtype 0x%x, size %d\n", "obj_checksum_verify", 6756, v9, *v5, v5[1], v5[2], *((_DWORD *)v5 + 6), *((_DWORD *)v5 + 7), v6);
    v10 = (unint64_t *)(*(_QWORD *)(v4 + 376) + 992);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    if (*(_BYTE *)(v4 + 625))
    {
      v12 = *(void (**)(uint64_t))(v4 + 616);
      if (v12)
        v12(a1);
    }
    return nx_corruption_detected_int(v4);
  }
  return result;
}

uint64_t obj_async_finish(uint64_t result, _BYTE *a2)
{
  pthread_mutex_t **v2;
  pthread_mutex_t *v3;
  pthread_mutex_t *v5;
  pthread_cond_t *v6;

  v2 = *(pthread_mutex_t ***)(result + 136);
  v3 = v2[2];
  if (((unint64_t)v3 & 0x10000000000) != 0)
  {
    v5 = *v2;
    v6 = (pthread_cond_t *)&(*v2)[20].__opaque[8];
    while (((unint64_t)v3 & 0x8000000000) != 0)
    {
      v2[2] = (pthread_mutex_t *)((unint64_t)v3 | 4);
      *a2 = 1;
      result = cv_wait_rw(v6, v5, 2, 0);
      v3 = v2[2];
      if (((unint64_t)v3 & 0x10000000000) == 0)
        return result;
    }
    v2[2] = (pthread_mutex_t *)((unint64_t)v3 | 0x8000000000);
    obj_cache_unlock_write((uint64_t)v5);
    *a2 = 0;
    return dev_read_finish(*(_QWORD *)(*(_QWORD *)(*v2)[6].__opaque + 384));
  }
  return result;
}

uint64_t obj_async_wait(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v7;

  v2 = *(_QWORD *)a1;
  v7 = 0;
  pthread_mutex_lock((pthread_mutex_t *)v2);
  v3 = *(_QWORD *)(v2 + 1344);
  if (v3)
  {
    while (1)
    {
      while (*(_QWORD *)(v3 + 136) != a1)
      {
        v3 = *(_QWORD *)(v3 + 104);
        if (!v3)
          goto LABEL_7;
      }
      v4 = *(_QWORD *)(a1 + 16);
      if ((v4 & 0x8000000000) == 0)
        break;
      *(_QWORD *)(a1 + 16) = v4 | 4;
      cv_wait_rw((pthread_cond_t *)(v2 + 1296), (pthread_mutex_t *)v2, 2, 0);
      v3 = *(_QWORD *)(v2 + 1344);
      if (!v3)
        goto LABEL_7;
    }
    obj_async_finish(v3, &v7);
    if (v7)
      obj_cache_unlock_write(v2);
    return *(unsigned int *)(a1 + 52);
  }
  else
  {
LABEL_7:
    if ((*(_BYTE *)(a1 + 21) & 1) != 0)
      v5 = 2;
    else
      v5 = *(unsigned int *)(a1 + 52);
    obj_cache_unlock_write(v2);
  }
  return v5;
}

char *obj_retain(char *result)
{
  unint64_t *v1;
  unint64_t v2;

  v1 = (unint64_t *)(result + 24);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  if ((~(_DWORD)v2 & 0xFFFFFFLL) == 0)
    panic("Reference count overflowed for object %p!\n", result);
  return result;
}

uint64_t obj_retain_ephemeral_no_ref(uint64_t result)
{
  uint64_t v1;
  unint64_t *v2;
  unint64_t v3;

  v1 = *(_QWORD *)(result + 16);
  if ((v1 & 0x80000000) == 0)
    panic("obj %p oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x refs 0x%llx is not ephemeral\n", (const void *)result, *(_QWORD *)(result + 112), v1, *(_DWORD *)(result + 32), *(_DWORD *)(result + 36), *(_DWORD *)(result + 40), *(_QWORD *)(result + 24));
  v2 = (unint64_t *)(result + 24);
  do
    v3 = __ldxr(v2);
  while (__stxr(v3 + 1, v2));
  if ((~(_DWORD)v3 & 0xFFFFFFLL) == 0)
    panic("Reference count overflowed for object %p!\n", (const void *)result);
  return result;
}

uint64_t obj_cache_enqueue_deferred_update(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;

  v2 = result;
  v3 = (unsigned int *)(a2 + 32);
  do
    v4 = __ldxr(v3);
  while (__stxr(v4 | 0x10, v3));
  if ((v4 & 0x10) == 0)
  {
    v5 = (unsigned int *)(result + 880);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
    v7 = v6;
    if (v6 >= 0x100)
    {
      do
      {
        do
          v8 = __ldxr(v5);
        while (__stxr(v8 - 1, v5));
        v9 = pthread_rwlock_unlock((pthread_rwlock_t *)(v2 + 128));
        if (v9)
          panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 480, v9);
        v10 = pthread_rwlock_wrlock((pthread_rwlock_t *)(v2 + 128));
        if (v10)
          panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 481, v10);
        obj_cache_perform_deferred_updates(v2);
        v11 = pthread_rwlock_unlock((pthread_rwlock_t *)(v2 + 128));
        if (v11)
          panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 487, v11);
        result = pthread_rwlock_rdlock((pthread_rwlock_t *)(v2 + 128));
        if ((_DWORD)result)
          panic("%s:%d: rdlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 490, result);
        do
          v7 = __ldxr(v5);
        while (__stxr(v7 + 1, v5));
      }
      while (v7 > 0xFF);
    }
    *(_QWORD *)(*(_QWORD *)(v2 + 872) + 8 * v7) = a2;
    v12 = v7 << 24;
    do
      v13 = __ldxr(v3);
    while (__stxr(v13 | v12, v3));
  }
  return result;
}

uint64_t obj_ephemeral_set_persistent(uint64_t a1, int a2)
{
  pthread_mutex_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t *opaque;
  uint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t *v39;
  uint64_t v40;
  _QWORD *v41;
  unint64_t *v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t *v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  unint64_t *v55;
  unint64_t v56;
  unint64_t *v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t *v60;
  unint64_t v61;
  unint64_t *v62;
  unint64_t v63;
  unint64_t *v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t *v67;
  unint64_t v68;
  unint64_t v69;

  if ((*(_BYTE *)(a1 + 19) & 0x80) == 0)
    return 22;
  v5 = *(pthread_mutex_t **)a1;
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  v6 = *(_QWORD *)(a1 + 16);
  if ((a2 != 0) != ((v6 & 0x8000000) == 0))
  {
    obj_cache_ephemeral_adjust((uint64_t)v5, v6, *(_DWORD *)(a1 + 48), -1);
    v8 = *(_QWORD *)(a1 + 88);
    v9 = *(_QWORD **)(a1 + 96);
    v7 = a1 + 88;
    if (a2)
    {
      if (v8)
      {
        *(_QWORD *)(v8 + 96) = v9;
        v9 = *(_QWORD **)(a1 + 96);
      }
      else
      {
        *(_QWORD *)&v5[11].__opaque[48] = v9;
      }
      *v9 = v8;
      v10 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v10 & 0xFFFFFFFFF7FFFFFFLL;
      *(_DWORD *)(a1 + 36) &= ~0x8000000u;
      if ((v10 & 0x80020000000) == 0)
        *(_DWORD *)(*(_QWORD *)(a1 + 56) + 24) &= ~0x8000000u;
      v11 = *(_QWORD **)&v5[11].__opaque[32];
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = v11;
      *v11 = a1;
      *(_QWORD *)&v5[11].__opaque[32] = v7;
      opaque = (unint64_t *)v5[19].__opaque;
      v13 = *(unsigned int *)(a1 + 48);
      do
        v14 = __ldxr(opaque);
      while (__stxr(v14 - v13, opaque));
      v15 = (unint64_t *)&v5[19].__opaque[16];
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + v13, v15));
      v17 = (unint64_t *)&v5[19].__opaque[32];
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
      v19 = omm;
      v20 = (unint64_t *)(omm + 416);
      v21 = *(unsigned int *)(a1 + 48);
      do
        v22 = __ldxr(v20);
      while (__stxr(v22 - v21, v20));
      v23 = (unint64_t *)(v19 + 432);
      do
        v24 = __ldxr(v23);
      while (__stxr(v24 + v21, v23));
      v25 = (unint64_t *)(v19 + 448);
      do
        v26 = __ldxr(v25);
      while (__stxr(v26 + 1, v25));
      if (*(_QWORD *)(a1 + 56))
      {
        v27 = (unint64_t *)&v5[18].__opaque[16];
        v28 = *(unsigned int *)(a1 + 48);
        do
          v29 = __ldxr(v27);
        while (__stxr(v29 + v28, v27));
        v30 = (unint64_t *)&v5[18].__opaque[24];
        do
          v31 = __ldxr(v30);
        while (__stxr(v31 + v28, v30));
        v32 = (unint64_t *)&v5[18].__opaque[40];
      }
      else
      {
        v32 = (unint64_t *)&v5[19];
      }
      do
        v33 = __ldxr(v32);
      while (__stxr(v33 + 1, v32));
      if (*(_QWORD *)(a1 + 56))
      {
        v34 = (unint64_t *)(v19 + 368);
        v35 = *(unsigned int *)(a1 + 48);
        do
          v36 = __ldxr(v34);
        while (__stxr(v36 + v35, v34));
        v37 = (unint64_t *)(v19 + 376);
        do
          v38 = __ldxr(v37);
        while (__stxr(v38 + v35, v37));
        v39 = (unint64_t *)(v19 + 392);
      }
      else
      {
        v39 = (unint64_t *)(v19 + 408);
      }
    }
    else
    {
      if (v8)
      {
        *(_QWORD *)(v8 + 96) = v9;
        v9 = *(_QWORD **)(a1 + 96);
      }
      else
      {
        *(_QWORD *)&v5[11].__opaque[32] = v9;
      }
      *v9 = v8;
      v40 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v40 | 0x8000000;
      *(_DWORD *)(a1 + 36) |= 0x8000000u;
      if ((v40 & 0x80020000000) == 0)
        *(_DWORD *)(*(_QWORD *)(a1 + 56) + 24) |= 0x8000000u;
      v41 = *(_QWORD **)&v5[11].__opaque[48];
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = v41;
      *v41 = a1;
      *(_QWORD *)&v5[11].__opaque[48] = v7;
      v42 = (unint64_t *)&v5[18].__opaque[16];
      v43 = *(unsigned int *)(a1 + 48);
      do
        v44 = __ldxr(v42);
      while (__stxr(v44 - v43, v42));
      v45 = (unint64_t *)&v5[18].__opaque[32];
      do
        v46 = __ldxr(v45);
      while (__stxr(v46 + v43, v45));
      v47 = (unint64_t *)&v5[18].__opaque[48];
      do
        v48 = __ldxr(v47);
      while (__stxr(v48 + 1, v47));
      v49 = omm;
      v50 = (unint64_t *)(omm + 368);
      v51 = *(unsigned int *)(a1 + 48);
      do
        v52 = __ldxr(v50);
      while (__stxr(v52 - v51, v50));
      v53 = (unint64_t *)(v49 + 384);
      do
        v54 = __ldxr(v53);
      while (__stxr(v54 + v51, v53));
      v55 = (unint64_t *)(v49 + 400);
      do
        v56 = __ldxr(v55);
      while (__stxr(v56 + 1, v55));
      if (*(_QWORD *)(a1 + 56))
      {
        v57 = (unint64_t *)v5[19].__opaque;
        v58 = *(unsigned int *)(a1 + 48);
        do
          v59 = __ldxr(v57);
        while (__stxr(v59 + v58, v57));
        v60 = (unint64_t *)&v5[19].__opaque[8];
        do
          v61 = __ldxr(v60);
        while (__stxr(v61 + v58, v60));
        v62 = (unint64_t *)&v5[19].__opaque[24];
      }
      else
      {
        v62 = (unint64_t *)&v5[19].__opaque[40];
      }
      do
        v63 = __ldxr(v62);
      while (__stxr(v63 + 1, v62));
      if (*(_QWORD *)(a1 + 56))
      {
        v64 = (unint64_t *)(v49 + 416);
        v65 = *(unsigned int *)(a1 + 48);
        do
          v66 = __ldxr(v64);
        while (__stxr(v66 + v65, v64));
        v67 = (unint64_t *)(v49 + 424);
        do
          v68 = __ldxr(v67);
        while (__stxr(v68 + v65, v67));
        v39 = (unint64_t *)(v49 + 440);
      }
      else
      {
        v39 = (unint64_t *)(v49 + 456);
      }
    }
    do
      v69 = __ldxr(v39);
    while (__stxr(v69 + 1, v39));
    obj_cache_ephemeral_adjust((uint64_t)v5, *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 48), 1);
  }
  obj_cache_unlock_write((uint64_t)v5);
  return 0;
}

uint64_t obj_set_skip_checkpoint_traverse(uint64_t a1, int a2)
{
  BOOL v3;
  pthread_mutex_t *v4;

  v3 = a2 != 0;
  v4 = *(pthread_mutex_t **)a1;
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 16) & 0xFFFFFFBFFFFFFFFFLL | ((unint64_t)v3 << 38);
  obj_cache_unlock_write((uint64_t)v4);
  return 0;
}

_QWORD *obj_dirty_locked(_QWORD *result, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  int v22;
  _QWORD *v23;
  unsigned int v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;

  v5 = result;
  v6 = *result;
  v7 = result[2];
  if ((v7 & 0x10) != 0)
    panic("deleted object @ %p can not be dirtied!! (flags: 0x%llx)\n", result, v7);
  if ((v7 & 0x80000000000) != 0)
    panic("ciphertext object @ %p can not be dirtied!! (flags: 0x%llx)\n", result, v7);
  if ((v7 & 0x8000000) == 0)
  {
    result = (_QWORD *)xid_is_current_tx(*(_QWORD *)(v6 + 392), a2);
    if (!(_DWORD)result)
      panic("oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x bad dirty xid: 0x%llx\n", v5[14], v5[2], *((_DWORD *)v5 + 8), *((_DWORD *)v5 + 9), *((_DWORD *)v5 + 10), a2);
  }
  v8 = v5[8];
  if (v8 && v8 == v5[7])
    panic("oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x object not prepared before dirtying\n", v5[14], v5[2], *((_DWORD *)v5 + 8), *((_DWORD *)v5 + 9), *((_DWORD *)v5 + 10));
  v9 = v5[2];
  if ((v9 & 0x80000000) != 0)
  {
    v5[18] = a2;
  }
  else
  {
    v10 = (unsigned int *)(v5 + 4);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 | 1, v10));
    if ((v11 & 1) != 0)
    {
      if (a3 && v5[19] != a3)
        panic("new address mismatch on redirty 0x%llx 0x%llx\n");
    }
    else
    {
      v12 = *((_DWORD *)v5 + 9);
      if ((v9 & 0xC00000000) == 0 && !(v12 >> 30))
      {
        v13 = v5[15];
        if (v13 != a2 && v5[18] != a2)
          panic("virtual object not prepared before dirtying: oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x xid 0x%llx 0x%llx 0x%llx\n", v5[14], v9, *((_DWORD *)v5 + 8), v12, *((_DWORD *)v5 + 10), v13, v5[18], a2);
      }
      v5[21] = 0;
      if (v12 >> 30 == 1)
      {
        v14 = v5[2];
        if ((v14 & 0x40) == 0)
        {
          v15 = v5[15];
          if (v15 != a2)
          {
            v16 = v5[18];
            if (v15 != v16 && !(v5[19] | a3))
              panic("physical object not prepared before dirtying: oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x xid 0x%llx 0x%llx 0x%llx naddr 0x%llx 0x%llx\n", v5[14], v14, *((_DWORD *)v5 + 8), v12, *((_DWORD *)v5 + 10), v15, v16, a2, 0, 0);
          }
        }
      }
      v17 = v5[19];
      if (v17)
      {
        if (v17 != a3)
        {
          if (a3)
          {
            v18 = *((_DWORD *)v5 + 9);
            if ((v18 & 0xC0000000) == 0x40000000)
              panic("physical object new address mismatch: oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x xid 0x%llx 0x%llx 0x%llx naddr 0x%llx 0x%llx\n", v5[14], v5[2], *((_DWORD *)v5 + 8), v18, *((_DWORD *)v5 + 10), v5[15], v5[18], a2, v5[19], a3);
          }
        }
      }
      else
      {
        v5[19] = a3;
        if (a3 && (v5[2] & 0x40000000) != 0 && v5[14] != a3)
        {
          v19 = v5[9];
          if (v19)
            *(_QWORD *)(v19 + 80) = v5[10];
          *(_QWORD *)v5[10] = v19;
          v5[14] = a3;
          v20 = (uint64_t *)(*(_QWORD *)(v6 + 704) + 8 * (*(_DWORD *)(v6 + 700) & a3));
          v21 = *v20;
          v5[9] = *v20;
          if (v21)
            *(_QWORD *)(v21 + 80) = v5 + 9;
          *v20 = (uint64_t)v5;
          v5[10] = v20;
        }
      }
      v5[18] = a2;
      v22 = pthread_rwlock_wrlock((pthread_rwlock_t *)(v6 + 128));
      if (v22)
        panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_framework/nx/obj.c", 5730, v22);
      v23 = v5 + 11;
      if (v5[11] != 3735928559)
        obj_free_list_remove(v5);
      do
        v24 = __ldxr(v10);
      while (__stxr(v24 & 0xFFFFEF, v10));
      if ((v24 & 0x10) != 0)
        *(_QWORD *)(*(_QWORD *)(v6 + 872) + 8 * HIBYTE(v24)) = 0;
      if (*v23 != 3735928559)
        panic("obj %p oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x dirty object on the free list?!\n", v5, v5[14], v5[2], *((_DWORD *)v5 + 8), *((_DWORD *)v5 + 9), *((_DWORD *)v5 + 10));
      v25 = v5[2];
      v5[11] = 0;
      if ((v25 & 0x40000000) != 0)
      {
        v27 = *(_QWORD **)(v6 + 824);
        v5[12] = v27;
        *v27 = v5;
        *(_QWORD *)(v6 + 824) = v23;
        ++*(_DWORD *)(v6 + 888);
      }
      else
      {
        v26 = *(_QWORD **)(v6 + 808);
        v5[12] = v26;
        *v26 = v5;
        *(_QWORD *)(v6 + 808) = v23;
        ++*(_DWORD *)(v6 + 884);
      }
      result = (_QWORD *)pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 128));
      if ((_DWORD)result)
        panic("%s:%d: unlock == 0 failed %d\n");
    }
  }
  return result;
}

void obj_dirty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  pthread_mutex_t *v6;
  unsigned int *v7;
  unsigned int v8;

  if ((*(_BYTE *)(a1 + 19) & 0x80) != 0)
  {
    *(_QWORD *)(a1 + 144) = a2;
  }
  else
  {
    v6 = *(pthread_mutex_t **)a1;
    v7 = (unsigned int *)(a1 + 32);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8, v7));
    if ((v8 & 1) == 0)
    {
      pthread_mutex_lock(v6);
      obj_dirty_locked((_QWORD *)a1, a2, a3);
      obj_cache_unlock_write((uint64_t)v6);
    }
  }
}

uint64_t obj_exchange_phys(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v4 = *(pthread_mutex_t **)a1;
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  v5 = *(_QWORD *)(a1 + 16);
  if ((v5 & 0x20000000000) != 0)
  {
    do
    {
      *(_QWORD *)(a1 + 16) = v5 | 0x80;
      v7 = cv_wait_rw((pthread_cond_t *)&v4[20].__opaque[8], v4, 2, 0);
      v5 = *(_QWORD *)(a1 + 16);
    }
    while ((v5 & 0x20000000000) != 0);
    v6 = v7;
  }
  else
  {
    v6 = 0;
  }
  v8 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v8;
  obj_cache_unlock_write((uint64_t)v4);
  return v6;
}

uint64_t obj_checkpoint_start(unsigned int *a1)
{
  unsigned int *v2;
  unsigned int v3;

  if ((*((_BYTE *)a1 + 19) & 0x80) == 0)
    return nx_corruption_detected_int(*(_QWORD *)(*(_QWORD *)a1 + 392));
  v2 = a1 + 8;
  do
    v3 = __ldxr(v2);
  while (__stxr(v3 | 4, v2));
  return (4 * v3) & 0x10;
}

uint64_t obj_checkpoint_done(unsigned int *a1)
{
  unsigned int *v2;
  unsigned int v3;

  if ((*((_BYTE *)a1 + 19) & 0x80) == 0)
    return nx_corruption_detected_int(*(_QWORD *)(*(_QWORD *)a1 + 392));
  v2 = a1 + 8;
  do
    v3 = __ldxr(v2);
  while (__stxr(v3 & 0xFFFFFFFB, v2));
  if ((v3 & 4) != 0)
    return 0;
  else
    return 22;
}

uint64_t obj_checkpoint_known(uint64_t a1)
{
  pthread_mutex_t *v1;
  uint64_t v4;

  v1 = *(pthread_mutex_t **)a1;
  if ((*(_BYTE *)(a1 + 19) & 0x80) == 0)
    return nx_corruption_detected_int(*(_QWORD *)v1[6].__opaque);
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  v4 = *(_QWORD *)(a1 + 16);
  if ((v4 & 0x2000000000) != 0)
  {
    *(_QWORD *)(a1 + 16) = v4 & 0xFFFFFFDFFFFFFFFFLL;
    obj_cache_unlock_write((uint64_t)v1);
    return 0;
  }
  else
  {
    obj_cache_unlock_write((uint64_t)v1);
    return 22;
  }
}

uint64_t obj_checkpoint_traverse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v4;

  v4 = *(unsigned __int16 *)(a3 + 36);
  if (v4 > 0xA)
  {
    if (v4 != 11)
    {
      if (v4 == 13)
        return apfs_checkpoint_traverse(a1, a2, a3, a4);
      return 22;
    }
    return omap_checkpoint_traverse(a1, a2, a3, a4);
  }
  else
  {
    if (v4 != 2)
    {
      if (v4 == 3)
        return btree_node_checkpoint_traverse(a1, a2, 0, a3, a4);
      return 22;
    }
    return btree_checkpoint_traverse(a1, a2, a3, a4);
  }
}

void obj_checkpoint_check_for_unknown(uint64_t a1)
{
  uint64_t i;

  pthread_mutex_lock((pthread_mutex_t *)a1);
  for (i = *(_QWORD *)(a1 + 736); i; i = *(_QWORD *)(i + 88))
  {
    if ((*(_BYTE *)(i + 20) & 0x20) != 0)
      log_warn("%s:%d: %s Unknown object loaded from checkpoint: oid 0x%llx type 0x%x/0x%x\n", "obj_checkpoint_check_for_unknown", 5920, (const char *)(*(_QWORD *)(*(_QWORD *)(a1 + 392) + 384) + 208), *(_QWORD *)(i + 112), *(_DWORD *)(i + 36), *(_DWORD *)(i + 40));
  }
  obj_cache_unlock_write(a1);
}

unint64_t obj_checksum_set(uint64_t a1, int8x16_t a2, int8x16_t a3)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  unint64_t *v7;
  unint64_t v8;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 392);
  v5 = *(_QWORD *)(a1 + 56);
  v6 = *(_DWORD *)(a1 + 48);
  v7 = (unint64_t *)(*(_QWORD *)(v4 + 376) + 984);
  do
    v8 = __ldxr(v7);
  while (__stxr(v8 + 1, v7));
  return fletcher64_set_cksum((unint64_t *)v5, (uint32x4_t *)(v5 + 8), (v6 - 8), 0, a2, a3);
}

unint64_t obj_checksum_set_phys(uint64_t a1, uint64_t a2, int a3, int8x16_t a4, int8x16_t a5)
{
  unint64_t *v5;
  unint64_t v6;

  v5 = (unint64_t *)(*(_QWORD *)(a1 + 376) + 984);
  do
    v6 = __ldxr(v5);
  while (__stxr(v6 + 1, v5));
  return fletcher64_set_cksum((unint64_t *)a2, (uint32x4_t *)(a2 + 8), (a3 - 8), 0, a4, a5);
}

uint64_t obj_mem_mgr_register(int64x2_t *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  int64x2_t **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  pthread_mutex_lock((pthread_mutex_t *)(omm + 8));
  v4 = a1[80].i64[1];
  a1[80].i64[1] = v4 | 1;
  if (a2)
  {
    a1[80].i64[1] = v4 | 3;
    v5 = omm;
    v6 = (int64x2_t **)(omm + 80);
    v7 = *(_QWORD *)(omm + 80);
    a1[58].i64[0] = v7;
    if (v7)
      *(_QWORD *)(v7 + 936) = a1 + 58;
    *v6 = a1;
    a1[58].i64[1] = (uint64_t)v6;
  }
  else
  {
    v5 = omm;
    v8 = omm + 72;
    v9 = *(_QWORD *)(omm + 72);
    a1[58].i64[0] = v9;
    if (v9)
      *(_QWORD *)(v9 + 936) = a1 + 58;
    *(_QWORD *)(v5 + 72) = a1;
    a1[58].i64[1] = v8;
    ++*(_QWORD *)(v5 + 104);
    *(int64x2_t *)(v5 + 136) = vaddq_s64(*(int64x2_t *)(v5 + 136), a1[59]);
    *(_QWORD *)(v5 + 152) += a1[60].i64[0];
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
}

void report_obj_alloc(uint64_t a1, const char *a2)
{
  int v4;
  char **v5;
  FILE **v6;
  uint64_t v7;
  void **v8;
  const char **v9;
  const void *v10;
  const void *v11;
  const char *v12;
  void *v13[2];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  *(_OWORD *)v13 = 0u;
  v14 = 0u;
  v4 = backtrace(v13, 16);
  v5 = backtrace_symbols(v13, v4);
  v6 = (FILE **)MEMORY[0x1E0C80C10];
  fprintf((FILE *)*MEMORY[0x1E0C80C10], "Allocated %s object with OID %lld flags %llx type %x %d from\n", a2, *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 40));
  if (v4 >= 1)
  {
    v7 = v4;
    v8 = v13;
    v9 = (const char **)v5;
    do
    {
      v11 = *v8++;
      v10 = v11;
      v12 = *v9++;
      fprintf(*v6, "\t%16p %s\n", v10, v12);
      --v7;
    }
    while (v7);
  }
  free(v5);
}

uint64_t *obj_cache_perform_deferred_updates(uint64_t a1)
{
  uint64_t *result;
  unint64_t v3;
  unint64_t v4;
  int tv_sec;
  unsigned int *v6;
  unsigned int v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unsigned int v19;
  timespec v20;

  v20.tv_sec = 0;
  v20.tv_nsec = 0;
  result = (uint64_t *)clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v20);
  v3 = *(unsigned int *)(a1 + 880);
  if ((_DWORD)v3)
  {
    v4 = 0;
    tv_sec = v20.tv_sec;
    do
    {
      result = *(uint64_t **)(*(_QWORD *)(a1 + 872) + 8 * v4);
      if (result)
      {
        v6 = (unsigned int *)(result + 4);
        do
          v7 = __ldxr(v6);
        while (__stxr(v7, v6));
        v8 = (unint64_t *)(result + 3);
        do
          v9 = __ldxr(v8);
        while (__stxr(v9, v8));
        v10 = v9 & 0xFFFFFF;
        v11 = (v9 >> 24) & 0xFFFFF;
        v12 = -(v9 >> 44) & 0xFFFFF;
        v13 = result + 11;
        v14 = result[11];
        if (v10 <= v11 && v12 == 0)
        {
          if (v14 == 3735928559 && *((_WORD *)result + 18) != 13)
          {
            *((_DWORD *)result + 40) = tv_sec;
            v16 = result[2];
            result[11] = 0;
            if ((v16 & 0x40000000) != 0)
            {
              v18 = *(_QWORD **)(a1 + 792);
              result[12] = (uint64_t)v18;
              *v18 = result;
              *(_QWORD *)(a1 + 792) = v13;
              ++*(_DWORD *)(a1 + 896);
            }
            else
            {
              v17 = *(_QWORD **)(a1 + 776);
              result[12] = (uint64_t)v17;
              *v17 = result;
              *(_QWORD *)(a1 + 776) = v13;
              ++*(_DWORD *)(a1 + 892);
            }
          }
        }
        else if (v14 != 3735928559)
        {
          result = obj_free_list_remove(result);
        }
        do
          v19 = __ldxr(v6);
        while (__stlxr(v19 & 0xFFFFEF, v6));
        v3 = *(unsigned int *)(a1 + 880);
      }
      ++v4;
    }
    while (v4 < v3);
  }
  *(_DWORD *)(a1 + 880) = 0;
  return result;
}

uint64_t *obj_free_list_remove(uint64_t *result)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;

  v1 = result[11];
  if (v1 != 3735928559)
  {
    v2 = *result;
    v3 = (_QWORD *)result[12];
    if ((*((_BYTE *)result + 19) & 0x40) != 0)
    {
      if (v1)
      {
        *(_QWORD *)(v1 + 96) = v3;
        v3 = (_QWORD *)result[12];
      }
      else
      {
        *(_QWORD *)(v2 + 792) = v3;
      }
      *v3 = v1;
      --*(_DWORD *)(v2 + 896);
    }
    else
    {
      if (v1)
      {
        *(_QWORD *)(v1 + 96) = v3;
        v3 = (_QWORD *)result[12];
      }
      else
      {
        *(_QWORD *)(v2 + 776) = v3;
      }
      *v3 = v1;
      --*(_DWORD *)(v2 + 892);
    }
    result[11] = 3735928559;
  }
  return result;
}

void obj_type_free(void *a1, __int16 a2, int a3)
{
  uint64_t v3;

  if (a3 == 376)
  {
LABEL_2:
    v3 = 376;
LABEL_3:
    _apfs_free(a1, v3);
  }
  else
  {
    switch(a2)
    {
      case 1:
        v3 = 1928;
        goto LABEL_3;
      case 2:
      case 3:
      case 6:
      case 7:
      case 8:
        _apfs_zfree(a1, 4u);
        break;
      case 5:
        v3 = 1608;
        goto LABEL_3;
      case 11:
        v3 = 496;
        goto LABEL_3;
      case 13:
        v3 = 3912;
        goto LABEL_3;
      case 17:
      case 30:
        v3 = 400;
        goto LABEL_3;
      case 18:
        v3 = 384;
        goto LABEL_3;
      case 25:
        v3 = 416;
        goto LABEL_3;
      case 27:
      case 29:
        v3 = 392;
        goto LABEL_3;
      default:
        goto LABEL_2;
    }
  }
}

uint64_t obj_destroy_for_obj(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = 0;
  v3 = 0;
  if ((*(_BYTE *)(a1 + 16) & 2) == 0)
  {
    if (obj_descriptor_funcs_for_type(*(_DWORD *)(a1 + 36), &v3))
      return 0;
    else
      return *(_QWORD *)(v3 + 16);
  }
  return result;
}

void obj_destroy_complete(uint64_t a1, char a2)
{
  uint64_t (*v3)(uint64_t);
  int v4;
  uint64_t v5;
  const char *v6;

  if ((a2 & 1) == 0)
  {
    v3 = (uint64_t (*)(uint64_t))obj_destroy_for_obj(a1);
    if (v3)
    {
      v4 = v3(a1);
      if (v4)
      {
        v5 = *(_QWORD *)(a1 + 8);
        if (v5)
          v6 = (const char *)(v5 + 3880);
        else
          v6 = (const char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 392) + 384) + 208);
        log_err("%s:%d: %s oid 0x%llx flags 0x%llx type 0x%x/0x%x error destroying: %d\n", "obj_destroy_complete", 2868, v6, *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 40), v4);
      }
    }
  }
  if (*(_QWORD *)(a1 + 88) != 3735928559)
    panic("object to be freed is on a list, o %p oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x refs 0x%llx list %p/%p\n", (const void *)a1, *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 40), *(_QWORD *)(a1 + 24), *(const void **)(a1 + 88), *(const void **)(a1 + 96));
  free_rwlock((pthread_rwlock_t *)(a1 + 176));
  fs_obj_zfree_oc(*(void **)(a1 + 56), *(unsigned int *)(a1 + 48), *(_QWORD *)(a1 + 16), *(_QWORD *)a1);
  obj_type_free((void *)a1, *(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 44));
}

void obj_get_callback(uint64_t a1, int8x16_t a2, int8x16_t a3)
{
  int v4;
  pthread_cond_t **v5;
  _DWORD *v6;
  uint64_t v7;
  pthread_mutex_t *v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  unint64_t v13;
  int finish;
  uint64_t v15;
  _QWORD *v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int *v20;
  unsigned int v21;
  int v22;
  char v23;
  int v24;

  v24 = 16000;
  v4 = *(_DWORD *)(a1 + 120);
  v5 = *(pthread_cond_t ***)(a1 + 136);
  if (v4)
    v6 = (_DWORD *)(a1 + 120);
  else
    v6 = 0;
  if (*(_BYTE *)(a1 + 148))
    v7 = *(_QWORD *)(a1 + 152);
  else
    v7 = 0;
  v8 = (pthread_mutex_t *)*v5;
  v9 = *(_DWORD *)(a1 + 96);
  v10 = *(_DWORD *)(a1 + 144);
  v11 = v10 & 0xFFFF0000;
  if (v4)
  {
    v11 |= v4;
    v12 = *(_DWORD *)(a1 + 124);
    if (v9)
    {
LABEL_9:
      pthread_mutex_lock((pthread_mutex_t *)*v5);
      *((_DWORD *)v5 + 13) = v9;
      goto LABEL_10;
    }
  }
  else
  {
    v12 = 0;
    if (v9)
      goto LABEL_9;
  }
  if (((unint64_t)v5[2] & 0x80020000000) != 0)
  {
    pthread_mutex_lock((pthread_mutex_t *)*v5);
    *((_DWORD *)v5 + 13) = 0;
LABEL_15:
    if (!obj_init(v5, v10, (uint64_t)v5[14], v6, v7, (unint64_t)v5[15], v11, v12))
    {
      v23 = 2;
      finish = obj_get_finish((uint64_t)v5, v10, (unint64_t)v5[15], 0, &v24, &v23);
      *((_DWORD *)v5 + 13) = finish;
      if (!finish)
        goto LABEL_18;
    }
    goto LABEL_17;
  }
  v22 = obj_checksum_verify(*(_QWORD *)(a1 + 136), a2, a3);
  pthread_mutex_lock(v8);
  *((_DWORD *)v5 + 13) = v22;
  if (!v22)
    goto LABEL_15;
LABEL_10:
  v13 = (unint64_t)v5[2];
  v5[2] = (pthread_cond_t *)(v13 & 0xFFFFFE7FFFFFFFFBLL);
  if ((v13 & 4) != 0)
    cv_wakeup(*v5 + 27);
LABEL_17:
  v5[2] = (pthread_cond_t *)((unint64_t)v5[2] & 0xFFFFFFEFFFFFFFF7 | 8);
LABEL_18:
  v15 = *(_QWORD *)(a1 + 104);
  v16 = *(_QWORD **)(a1 + 112);
  if (v15)
  {
    *(_QWORD *)(v15 + 112) = v16;
    v16 = *(_QWORD **)(a1 + 112);
  }
  else
  {
    *(_QWORD *)v8[21].__opaque = v16;
  }
  *v16 = v15;
  obj_cache_unlock_write((uint64_t)v8);
  obj_release(v5);
  if (*(_BYTE *)(a1 + 148))
    _apfs_free(*(void **)(a1 + 152), *(unsigned __int16 *)(v7 + 2));
  _apfs_free((void *)a1, 160);
  v17 = (unsigned int *)&v8[14].__opaque[12];
  do
  {
    v18 = __ldxr(v17);
    v19 = v18 - 1;
  }
  while (__stxr(v19, v17));
  if (!v19)
  {
    v20 = (unsigned int *)&v8[14].__opaque[8];
    do
      v21 = __ldxr(v20);
    while (__stxr(v21, v20));
    if (v21)
    {
      pthread_mutex_lock(v8);
      cv_wakeup((pthread_cond_t *)&v8[20].__opaque[8]);
      obj_cache_unlock_write((uint64_t)v8);
    }
  }
}

unint64_t *obj_cache_stats_update_zalloc(unint64_t *result, int a2, uint64_t a3, uint64_t a4)
{
  char v4;
  unsigned int v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;

  v5 = a2 & 0xC8000000;
  if (a2 < 0 != v4)
  {
    if (v5 == 0x80000000)
    {
      if (a3)
      {
        v17 = result + 29;
        do
          v18 = __ldxr(v17);
        while (__stxr(v18 + a4, v17));
        v19 = result + 30;
        do
          v20 = __ldxr(v19);
        while (__stxr(v20 + a4, v19));
        v21 = result + 32;
      }
      else
      {
        v21 = result + 34;
      }
      do
        v24 = __ldxr(v21);
      while (__stxr(v24 + 1, v21));
    }
    else
    {
      if (v5 != -2013265920)
        goto LABEL_28;
      if (a3)
      {
        v6 = result + 35;
        do
          v7 = __ldxr(v6);
        while (__stxr(v7 + a4, v6));
        v8 = result + 36;
        do
          v9 = __ldxr(v8);
        while (__stxr(v9 + a4, v8));
        v10 = result + 38;
      }
      else
      {
        v10 = result + 40;
      }
      do
        v23 = __ldxr(v10);
      while (__stxr(v23 + 1, v10));
    }
  }
  else
  {
    if (v5 != 0x40000000 && v5 != 0)
LABEL_28:
      panic("unexpected storagetype: 0x%x\n", a2 & 0xC8000000);
    if (a3)
    {
      v12 = result + 23;
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + a4, v12));
      v14 = result + 24;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + a4, v14));
      v16 = result + 26;
    }
    else
    {
      v16 = result + 28;
    }
    do
      v22 = __ldxr(v16);
    while (__stxr(v22 + 1, v16));
  }
  return result;
}

uint64_t apfs_update_dev_name(uint64_t result)
{
  uint64_t v1;
  char *v2;

  if (result)
  {
    v1 = *(_QWORD *)(result + 496);
    v2 = (char *)(result + 3880);
    if (v1)
      return snprintf(v2, 0x20uLL, "%ss%d:%lld");
    else
      return snprintf(v2, 0x20uLL, "%ss%d");
  }
  return result;
}

uint64_t apfs_init_phys(uint64_t a1)
{
  *(_DWORD *)(a1 + 32) = 1112756289;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 116) = 0x4000000200000002;
  *(_DWORD *)(a1 + 124) = 1073741826;
  *(int32x2_t *)(a1 + 1040) = vdup_n_s32(0x40000002u);
  *(_DWORD *)(a1 + 1068) = 2;
  *(_DWORD *)(a1 + 1104) = 2;
  return 0;
}

uint64_t apfs_init(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  void *v6;
  void *v7;
  uint64_t v8;

  v2 = *(_QWORD *)(a1 + 56);
  v3 = apfs_sanity_check_tree_type(a1, *(_DWORD *)(v2 + 116));
  if (!(_DWORD)v3)
  {
    v3 = apfs_sanity_check_tree_type(a1, *(_DWORD *)(v2 + 120));
    if (!(_DWORD)v3)
    {
      v3 = apfs_sanity_check_tree_type(a1, *(_DWORD *)(v2 + 124));
      if (!(_DWORD)v3)
      {
        v5 = *(_QWORD *)(v2 + 56);
        if ((v5 & 0x20) != 0)
        {
          v3 = apfs_sanity_check_tree_type(a1, *(_DWORD *)(v2 + 1040));
          if ((_DWORD)v3)
            return v3;
          v5 = *(_QWORD *)(v2 + 56);
        }
        if ((v5 & 0x40) == 0 || (v3 = apfs_sanity_check_tree_type(a1, *(_DWORD *)(v2 + 1044)), !(_DWORD)v3))
        {
          v6 = _apfs_calloc(0x100uLL, 8uLL);
          *(_QWORD *)(a1 + 3352) = v6;
          if (v6)
          {
            v7 = _apfs_calloc(0x10uLL, 8uLL);
            *(_QWORD *)(a1 + 3424) = v7;
            if (v7)
            {
              v8 = initialize_phys_range_lock_state(a1 + 3512, 0x20u);
              if ((_DWORD)v8)
              {
                v3 = v8;
                _apfs_free(*(void **)(a1 + 3424), 128);
                _apfs_free(*(void **)(a1 + 3352), 2048);
              }
              else
              {
                *(_QWORD *)(a1 + 376) = v2;
                *(_QWORD *)(a1 + 392) = *(_QWORD *)(*(_QWORD *)a1 + 392);
                new_lock((pthread_mutex_t *)(a1 + 1208));
                new_lock((pthread_mutex_t *)(a1 + 1272));
                new_lock((pthread_mutex_t *)(a1 + 3288));
                new_lock((pthread_mutex_t *)(a1 + 3360));
                new_lock((pthread_mutex_t *)(a1 + 1336));
                new_lock((pthread_mutex_t *)(a1 + 1400));
                new_lock((pthread_mutex_t *)(a1 + 1464));
                new_lock((pthread_mutex_t *)(a1 + 1656));
                new_lock((pthread_mutex_t *)(a1 + 1528));
                new_lock((pthread_mutex_t *)(a1 + 1592));
                new_lock((pthread_mutex_t *)(a1 + 1144));
                new_lock((pthread_mutex_t *)(a1 + 3224));
                new_lock((pthread_mutex_t *)(a1 + 1720));
                new_lock((pthread_mutex_t *)(a1 + 3792));
                new_rwlock((pthread_rwlock_t *)(a1 + 1784));
                new_rwlock((pthread_rwlock_t *)(a1 + 3000));
                new_rwlock((pthread_rwlock_t *)(a1 + 1984));
                rolling_stats_init(a1 + 3672, 0xE10u, 0x18u);
                apfs_update_dev_name(a1);
                *(_QWORD *)(a1 + 592) = 0;
                if ((*(_BYTE *)(*(_QWORD *)(a1 + 376) + 57) & 1) != 0 && !fs_is_fully_unencrypted(a1))
                {
                  v3 = 0;
                  *(_QWORD *)(a1 + 688) = 1;
                }
                else
                {
                  return 0;
                }
              }
              return v3;
            }
            _apfs_free(*(void **)(a1 + 3352), 2048);
          }
          return 12;
        }
      }
    }
  }
  return v3;
}

uint64_t apfs_destroy(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 3496);
  if (v2 && !*(_DWORD *)(*(_QWORD *)a1 + 912))
    obj_release(v2);
  _apfs_free(*(void **)(a1 + 3424), 128);
  _apfs_free(*(void **)(a1 + 3352), 2048);
  rolling_stats_destroy(a1 + 3672);
  free_rwlock((pthread_rwlock_t *)(a1 + 2800));
  free_rwlock((pthread_rwlock_t *)(a1 + 2592));
  free_rwlock((pthread_rwlock_t *)(a1 + 2392));
  free_rwlock((pthread_rwlock_t *)(a1 + 2184));
  free_rwlock((pthread_rwlock_t *)(a1 + 1984));
  free_rwlock((pthread_rwlock_t *)(a1 + 3000));
  free_rwlock((pthread_rwlock_t *)(a1 + 1784));
  free_lock((pthread_mutex_t *)(a1 + 3224));
  free_lock((pthread_mutex_t *)(a1 + 1144));
  free_lock((pthread_mutex_t *)(a1 + 1208));
  free_lock((pthread_mutex_t *)(a1 + 1528));
  free_lock((pthread_mutex_t *)(a1 + 1592));
  free_lock((pthread_mutex_t *)(a1 + 1400));
  free_lock((pthread_mutex_t *)(a1 + 1464));
  free_lock((pthread_mutex_t *)(a1 + 1656));
  free_lock((pthread_mutex_t *)(a1 + 3360));
  free_lock((pthread_mutex_t *)(a1 + 3288));
  free_lock((pthread_mutex_t *)(a1 + 1272));
  free_lock((pthread_mutex_t *)(a1 + 1336));
  free_lock((pthread_mutex_t *)(a1 + 1720));
  free_lock((pthread_mutex_t *)(a1 + 3792));
  release_phys_range_lock_state(a1 + 3512);
  return 0;
}

uint64_t apfs_reap(uint64_t a1, char a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  uint64_t v5;
  unsigned int v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t v21;

  v21 = 0;
  if (a4 < 0x14)
    return 28;
  v8 = *(_DWORD *)(a3 + 16);
  if (v8 < 5)
  {
    v11 = obj_modify((_QWORD *)a1, 0, a5);
    if ((_DWORD)v11)
    {
      v5 = v11;
      log_err("%s:%d: %s failed to modify the apfs_t before reaping (error %d).\n", "apfs_reap", 602, (const char *)(a1 + 3880), v11);
    }
    else if ((a2 & 1) != 0)
    {
      spaceman_fs_bounds_clear(*(_QWORD **)(a1 + 392), a1, a5);
      obj_delete_and_free((uint64_t *)a1, a5);
      return 0;
    }
    else
    {
      switch(*(_DWORD *)(a3 + 16))
      {
        case 0:
          *(_DWORD *)(a3 + 16) = 1;
          goto LABEL_10;
        case 1:
LABEL_10:
          v5 = apfs_reap_snapshots(a1, a5, &v21, (uint64_t *)a3);
          if ((_DWORD)v5)
            return v5;
          *(_QWORD *)a3 = 0;
          *(_DWORD *)(a3 + 16) = 2;
LABEL_12:
          v5 = apfs_reap_extentref_blocks(a1, a5, *(_QWORD *)(*(_QWORD *)(a1 + 376) + 144), &v21, (uint64_t *)a3);
          if ((_DWORD)v5)
            return v5;
          v12 = *(_QWORD *)(a1 + 376);
          v13 = *(_QWORD *)(v12 + 224);
          if (*(_QWORD *)(v12 + 232) != v13)
          {
            log_err("%s:%d: %s freed != alloced (%llu freed, %llu alloced)\n", "apfs_reap", 638, (const char *)(a1 + 3880), *(_QWORD *)(v12 + 232), v13);
            v12 = *(_QWORD *)(a1 + 376);
          }
          v14 = *(_QWORD *)(v12 + 56);
          if ((v14 & 0x20) == 0)
            goto LABEL_22;
          v15 = supplemental_tree_destroy(a1, *(_DWORD *)(v12 + 1040), 5, a5, 0, 0);
          if ((_DWORD)v15)
          {
            v5 = v15;
            strerror(v15);
            log_err("%s:%d: %s supplemental_tree_destroy(fext_tree) failed: %d (%s)\n");
          }
          else
          {
            v12 = *(_QWORD *)(a1 + 376);
            v14 = *(_QWORD *)(v12 + 56);
LABEL_22:
            if ((v14 & 0x40) != 0
              && (v17 = supplemental_tree_destroy(a1, *(_DWORD *)(v12 + 1044), 6, a5, 0, 0), (_DWORD)v17))
            {
              v5 = v17;
              strerror(v17);
              log_err("%s:%d: %s supplemental_tree_destroy(pfkur_tree) failed: %d (%s)\n");
            }
            else
            {
              *(_DWORD *)(a3 + 16) = 3;
LABEL_26:
              obj_cache_remove_new_fs_objects(*(_QWORD *)(*(_QWORD *)(a1 + 392) + 392), a1);
              v18 = *(uint64_t **)(a1 + 3432);
              if (v18)
              {
                obj_release(v18);
                *(_QWORD *)(a1 + 3432) = 0;
              }
              v19 = *(uint64_t **)(a1 + 3480);
              if (v19)
              {
                obj_release(v19);
                *(_QWORD *)(a1 + 3480) = 0;
              }
              v5 = omap_destroy(a1, *(_QWORD *)(*(_QWORD *)(a1 + 376) + 128), a5, 0);
              if ((_DWORD)v5)
              {
                log_err("%s:%d: %s omap_destroy returned %d!\n");
              }
              else
              {
                v20 = *(_QWORD *)(a1 + 376);
                *(_QWORD *)(v20 + 976) = 0;
                *(_QWORD *)(v20 + 1032) = 0;
                *(_QWORD *)(v20 + 1048) = 0;
                *(_OWORD *)(v20 + 128) = 0u;
                *(_OWORD *)(v20 + 144) = 0u;
                *(_OWORD *)(v20 + 1072) = 0u;
                fs_sb_dirty(a1, a5);
                *(_DWORD *)(a3 + 16) = 4;
              }
            }
          }
          break;
        case 2:
          goto LABEL_12;
        case 3:
          goto LABEL_26;
        default:
          return 0;
      }
    }
  }
  else
  {
    log_err("%s:%d: %s bogus phase, %u\n", "apfs_reap", 596, (const char *)(a1 + 3880), v8);
    return 5;
  }
  return v5;
}

uint64_t apfs_checkpoint_traverse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v15;

  if ((*(_BYTE *)(a3 + 20) & 0x40) != 0)
    return 0;
  v15 = 0;
  v5 = *(_QWORD *)(*(_QWORD *)(a3 + 376) + 128);
  if (!v5)
    goto LABEL_13;
  v9 = obj_get(*(_QWORD *)(a1 + 392), 0x40000000u, v5, (int *)&om_desc, 0, a3, 0, 0, (uint64_t *)&v15);
  if ((_DWORD)v9)
  {
    v10 = v9;
    v11 = *(_QWORD *)(a1 + 400);
    if (!v11 || !*(_DWORD *)(v11 + 76))
      log_err("%s:%d: %s failed to get omap %lld: %d\n");
    return v10;
  }
  v10 = omap_checkpoint_traverse(a3, a2, (uint64_t)v15, a4);
  v12 = v15[2];
  obj_release(v15);
  if (!(_DWORD)v10)
  {
    if ((v12 & 0x4000000000) == 0)
      return 0;
LABEL_13:
    obj_set_skip_checkpoint_traverse(a3, 1);
    return 0;
  }
  v13 = *(_QWORD *)(a1 + 400);
  if (!v13 || !*(_DWORD *)(v13 + 76))
    log_err("%s:%d: %s omap checkpoint traverse (op %d) failed: %d\n");
  return v10;
}

uint64_t apfs_get_fsroot_tree_ext(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t result;
  _OWORD v14[6];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a2)
    v9 = a2;
  else
    v9 = a1;
  v10 = *(_QWORD *)(v9 + 376);
  v11 = *(_DWORD *)(v10 + 116);
  v12 = *(_QWORD *)(v10 + 136);
  memset(&v14[2], 0, 64);
  v14[0] = xmmword_1EA984880;
  v14[1] = unk_1EA984890;
  if ((*(_BYTE *)(v10 + 56) & 0x20) == 0 || (result = authapfs_get_hash_args(a1, v14), !(_DWORD)result))
  {
    if ((unsigned __int16)v11 == 2)
      return btree_get_extended(a1, v11 & 0xFFFF0000, v12, a3, a4 != 0, (uint64_t)v14, a4, a5);
    else
      return 22;
  }
  return result;
}

BOOL apfs_fsroot_tree_last_key_pred(uint64_t a1, _QWORD *a2, unsigned int a3)
{
  return a3 >= 8 && (*a2 & 0xFFFFFFFFFFFFFFFLL) == *(_QWORD *)(*(_QWORD *)(a1 + 376) + 176) - 1;
}

BOOL apfs_has_secondary_fsroot(uint64_t a1)
{
  return (*(_BYTE *)(*(_QWORD *)(a1 + 376) + 57) & 1) != 0 && !fs_is_fully_unencrypted(a1);
}

uint64_t apfs_get_secondary_fsroot_tree_ext(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5;
  uint64_t v10;
  int v11;
  uint64_t v12;

  if (a2)
    v5 = a2;
  else
    v5 = a1;
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 376) + 57) & 1) == 0)
    return 45;
  v10 = *(_QWORD *)(v5 + 376);
  v11 = *(_DWORD *)(v10 + 1104);
  v12 = *(_QWORD *)(v10 + 1096);
  if (fs_is_fully_unencrypted(a1))
    return 45;
  if ((unsigned __int16)v11 == 2)
    return btree_get_extended(a1, v11 & 0xFFFF0000, v12, a3, a4 != 0, (uint64_t)apfs_get_secondary_fsroot_tree_ext_BTARGS, a4, a5);
  return 22;
}

uint64_t apfs_get_fsroot_tree(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  return apfs_get_fsroot_tree_ext(a1, 0, a2, a3, a4);
}

uint64_t apfs_get_secondary_fsroot_tree(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  return apfs_get_secondary_fsroot_tree_ext(a1, 0, a2, a3, a4);
}

uint64_t apfs_get_extentref_tree(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if ((unsigned __int16)*(_DWORD *)(*(_QWORD *)(a1 + 376) + 120) == 2)
    return btree_get_extended(a1, *(_DWORD *)(*(_QWORD *)(a1 + 376) + 120) & 0xFFFF0000, a2, 0, a3 != 0, (uint64_t)&apfs_get_extentref_tree_BTARGS, a3, a4);
  else
    return 22;
}

uint64_t apfs_get_snap_meta_tree(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 376);
  if ((unsigned __int16)*(_DWORD *)(v3 + 124) == 2)
    return btree_get_extended(a1, *(_DWORD *)(v3 + 124) & 0xFFFF0000, *(_QWORD *)(v3 + 152), 0, a2 != 0, (uint64_t)&apfs_get_snap_meta_tree_BTARGS, a2, a3);
  else
    return 22;
}

uint64_t apfs_get_doc_id_tree_ext(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (a3)
    v6 = a3;
  else
    v6 = a1;
  v7 = *(_QWORD *)(v6 + 376);
  if ((unsigned __int16)*(_DWORD *)(v7 + 1068) != 2)
    return 22;
  v8 = 1072;
  if (a2)
    v8 = 1080;
  return btree_get_extended(a1, *(_DWORD *)(v7 + 1068) & 0xFFFF0000, *(_QWORD *)(v7 + v8), a4, a5 != 0, (uint64_t)apfs_get_doc_id_tree_by_oid_BTARGS, a5, a6);
}

BOOL apfs_doc_id_tree_last_key_pred(uint64_t a1, _DWORD *a2, unsigned int a3)
{
  return a3 >= 4 && *a2 == *(_DWORD *)(*(_QWORD *)(a1 + 376) + 960) - 1;
}

uint64_t apfs_get_doc_id_tree(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  return apfs_get_doc_id_tree_ext(a1, a2, 0, a3, a4, a5);
}

uint64_t apfs_doc_id_index_supported(uint64_t a1)
{
  int v1;
  uint64_t result;
  BOOL v3;

  v1 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 376) + 964);
  result = 1;
  if (v1 > 63)
  {
    if (v1 != 64 && v1 != 576)
      return 0;
  }
  else
  {
    if (v1)
      v3 = v1 == 2;
    else
      v3 = 1;
    if (!v3)
      return 0;
  }
  return result;
}

uint64_t apfs_sanity_check_tree_type(uint64_t a1, int a2)
{
  if ((a2 | 0x40000000u) >> 30 == 1 && (unsigned __int16)a2 == 2)
    return 0;
  else
    return nx_corruption_detected_int(*(_QWORD *)(*(_QWORD *)a1 + 392));
}

uint64_t apfs_reap_snapshots(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t next_snapshot_xid;
  uint64_t v18;
  unsigned __int16 *v19;

  v18 = 0;
  v19 = 0;
  v8 = a4[1];
  if (!v8)
  {
    next_snapshot_xid = omap_find_next_snapshot_xid(a1, 0, &v18);
    if ((_DWORD)next_snapshot_xid)
    {
      v9 = next_snapshot_xid;
      if ((_DWORD)next_snapshot_xid == 2)
      {
LABEL_13:
        fs_delete_snapshot_metadata_tree(a1, a2, 0);
        return 0;
      }
      else
      {
        log_err("%s:%d: %s Hit %d looking up first snapshot\n");
      }
      return v9;
    }
    v8 = v18;
    a4[1] = v18;
  }
  v9 = fs_lookup_snapshot_metadata_by_xid(a1, v8, &v19);
  if ((_DWORD)v9)
  {
LABEL_3:
    log_err("%s:%d: %s Couldn't find snapshot metadata for xid %llu\n");
  }
  else
  {
    while (1)
    {
      v12 = v19;
      v13 = *((_QWORD *)v19 + 2);
      if (v13)
      {
        v14 = apfs_reap_extentref_blocks(a1, a2, v13, a3, a4);
        if ((_DWORD)v14)
          return v14;
        v12 = v19;
      }
      fs_delete_supplemental_tree(a1, 5, *((_QWORD *)v12 + 3), a2, 0);
      fs_delete_supplemental_tree(a1, 6, *((_QWORD *)v19 + 3), a2, 0);
      fs_delete_clone_superblock(a1, *((_QWORD *)v19 + 3), a2);
      v15 = omap_find_next_snapshot_xid(a1, a4[1], &v18);
      if ((_DWORD)v15)
        break;
      v10 = v18;
      *a4 = 0;
      a4[1] = v10;
      v11 = fs_lookup_snapshot_metadata_by_xid(a1, v10, &v19);
      if ((_DWORD)v11)
      {
        v9 = v11;
        goto LABEL_3;
      }
    }
    v9 = v15;
    if ((_DWORD)v15 == 2)
      goto LABEL_13;
    log_err("%s:%d: %s lookup_next_snapshot() returned %d\n", "apfs_reap_snapshots", 574, (const char *)(a1 + 3880), v15);
  }
  return v9;
}

uint64_t apfs_reap_extentref_blocks(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4, uint64_t *a5)
{
  uint64_t extentref_tree;
  uint64_t v11;
  uint64_t v12;
  unint64_t v14;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t *v24;
  _OWORD v25[4];
  uint64_t v26;

  v26 = 0;
  memset(v25, 0, sizeof(v25));
  v23 = 0;
  v24 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  extentref_tree = apfs_get_extentref_tree(a1, a3, 0, (uint64_t *)&v24);
  if ((_DWORD)extentref_tree)
  {
    v11 = extentref_tree;
    log_err("%s:%d: apfs_get_extentref_tree(oid=%llu) returned %d\n", "apfs_reap_extentref_blocks", 469, a3, extentref_tree);
  }
  else
  {
    v23 = *a5 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000;
    bt_iterator_init_with_hint((uint64_t)v25, (uint64_t)v24, 0, 4, (unint64_t *)&v23, 8, 8u, &v20, 0x14u, 0);
    if ((v12 & 0xFFFFFFFD) != 0)
    {
      v11 = v12;
      log_err("%s:%d: %s tree_iter_init() returned %d\n", "apfs_reap_extentref_blocks", 479, (const char *)(a1 + 3880), v12);
    }
    else
    {
      while (1)
      {
        if (bt_iterator_ended((uint64_t)v25))
        {
          btree_delete((uint64_t)v24, a2, 0);
          v11 = 0;
          goto LABEL_5;
        }
        v14 = v23 & 0xFFFFFFFFFFFFFFFLL;
        *a5 = v23 & 0xFFFFFFFFFFFFFFFLL;
        if (v20 >> 60 == 1 && v21 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v16 = v20 & 0xFFFFFFFFFFFFFFFLL;
          if ((v20 & 0xFFFFFFFFFFFFFFFLL) != 0)
          {
            if (apfs_free_data_blocks(a1, a2, v14, v20 & 0xFFFFFFFFFFFFFFFLL))
              log_err("%s:%d: %s extent at lba %llu len %llu couldn't be freed: %d\n");
          }
          else
          {
            log_err("%s:%d: %s found bogus 0-length extent at lba %llu, ignoring\n");
          }
          v17 = *a4 + v16;
          *a4 = v17;
          if (v17 > 0x4000)
            break;
        }
        v18 = bt_iterator_next((uint64_t)v25);
        if ((v18 & 0xFFFFFFFD) != 0)
        {
          v19 = v18;
          log_err("%s:%d: %s iter_next returned %d\n", "apfs_reap_extentref_blocks", 511, (const char *)(a1 + 3880), v18);
          v11 = v19;
          goto LABEL_5;
        }
      }
      v11 = 36;
    }
  }
LABEL_5:
  if (v24)
    obj_release(v24);
  return v11;
}

void *_apfs_obj_zalloc(size_t size, uint64_t a2)
{
  size_t v2;
  void *result;
  unint64_t v4;

  if (size == 0x2000)
  {
    v2 = qword_1F04740F8;
  }
  else
  {
    v2 = size;
    if (size == 4096)
      v2 = *(_QWORD *)((char *)&apfs_zone_infos[1] + ((a2 << 63 >> 63) & 0x78));
  }
  result = malloc_type_calloc(1uLL, v2, 0x284387B2uLL);
  if (result)
  {
    do
      v4 = __ldxr(&apfs_allocated_mem_total);
    while (__stxr(v4 + v2, &apfs_allocated_mem_total));
  }
  return result;
}

void *_apfs_zalloc(unsigned int a1)
{
  size_t v1;
  void *result;
  unint64_t v3;

  v1 = apfs_zone_infos[3 * a1 + 1];
  result = malloc_type_calloc(1uLL, v1, 0x284387B2uLL);
  if (result)
  {
    do
      v3 = __ldxr(&apfs_allocated_mem_total);
    while (__stxr(v3 + v1, &apfs_allocated_mem_total));
  }
  return result;
}

void *_apfs_calloc(size_t a1, size_t a2)
{
  void *result;
  unint64_t v5;

  result = malloc_type_calloc(a1, a2, 0x284387B2uLL);
  if (result)
  {
    do
      v5 = __ldxr(&apfs_allocated_mem_total);
    while (__stxr(v5 + a2 * a1, &apfs_allocated_mem_total));
  }
  return result;
}

void _apfs_obj_zfree(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t *v4;
  unint64_t v5;

  if (a2 == 0x2000)
  {
    if (!a1)
      return;
    v4 = &qword_1F04740F8;
  }
  else
  {
    v3 = a2;
    if (a2 != 4096)
    {
      if (!a1)
        return;
      goto LABEL_9;
    }
    if (!a1)
      return;
    v4 = (uint64_t *)((char *)&apfs_zone_infos + ((a3 << 63 >> 63) & 0x78) + 8);
  }
  v3 = *v4;
LABEL_9:
  free(a1);
  do
    v5 = __ldxr(&apfs_allocated_mem_total);
  while (__stxr(v5 - v3, &apfs_allocated_mem_total));
}

void _apfs_zfree(void *a1, unsigned int a2)
{
  uint64_t v2;
  unint64_t v3;

  if (a1)
  {
    v2 = apfs_zone_infos[3 * a2 + 1];
    free(a1);
    do
      v3 = __ldxr(&apfs_allocated_mem_total);
    while (__stxr(v3 - v2, &apfs_allocated_mem_total));
  }
}

void _apfs_free(void *a1, uint64_t a2)
{
  unint64_t v3;

  if (a1)
  {
    free(a1);
    do
      v3 = __ldxr(&apfs_allocated_mem_total);
    while (__stxr(v3 - a2, &apfs_allocated_mem_total));
  }
}

void *_apfs_malloc(size_t a1)
{
  void *result;
  unint64_t v3;

  result = malloc_type_malloc(a1, 0x1CC27423uLL);
  if (result)
  {
    do
      v3 = __ldxr(&apfs_allocated_mem_total);
    while (__stxr(v3 + a1, &apfs_allocated_mem_total));
  }
  return result;
}

BOOL nx_is_panic_on_corruption_enabled(uint64_t a1)
{
  if (a1)
    return *(_BYTE *)(a1 + 637) != 0;
  else
    return apfs_corruption_panics & 1;
}

uint64_t nx_calculate_metadata_parameters(unsigned int a1, unint64_t a2, unint64_t a3, unsigned int a4, uint64_t a5)
{
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  char v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;

  *(_QWORD *)(a5 + 208) = 0;
  *(_OWORD *)(a5 + 176) = 0u;
  *(_OWORD *)(a5 + 192) = 0u;
  *(_OWORD *)(a5 + 144) = 0u;
  *(_OWORD *)(a5 + 160) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 128) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  v5 = 22;
  *(_OWORD *)a5 = 0u;
  if (a1 - 65537 < 0xFFFF0FFF || !a2)
    return v5;
  v6 = 8 * a1;
  v7 = a1 - 40;
  *(_QWORD *)(a5 + 88) = v7 >> 5;
  *(_QWORD *)(a5 + 96) = v7 >> 3;
  *(_QWORD *)(a5 + 8) = a1;
  *(_QWORD *)(a5 + 16) = a2;
  v8 = (a2 + v6 - 1) / v6;
  v9 = (v7 >> 5) - 1;
  v10 = (v9 + v8) / (v7 >> 5);
  *(_QWORD *)(a5 + 24) = v8;
  *(_QWORD *)(a5 + 32) = v10;
  v11 = (v7 >> 3) - 1;
  v12 = (v11 + v10) / (v7 >> 3);
  if (v12 == 1)
    v13 = 0;
  else
    v13 = (v11 + v10) / (v7 >> 3);
  *(_QWORD *)(a5 + 40) = v13;
  *(_QWORD *)(a5 + 48) = a3;
  v14 = (a3 + v6 - 1) / v6;
  v15 = (v9 + v14) / (v7 >> 5);
  *(_QWORD *)(a5 + 56) = v14;
  *(_QWORD *)(a5 + 64) = v15;
  v16 = (v11 + v15) / (v7 >> 3);
  if (v16 == 1)
    v17 = 0;
  else
    v17 = v16;
  *(_QWORD *)(a5 + 72) = v17;
  *(_QWORD *)(a5 + 80) = v6;
  v18 = 3 * (v10 + v8 + v14 + v15 + v13 + v17);
  *(_QWORD *)(a5 + 104) = v18;
  v19 = (unint64_t)(v18 + 63) >> 6;
  v20 = (a1 - 1 + 8 * v19) / a1;
  if (HIDWORD(v20))
    return 27;
  *(_QWORD *)(a5 + 112) = v20;
  *(_QWORD *)(a5 + 120) = 16;
  if (v20 < 0x1000)
  {
    v21 = 16 * v20;
    goto LABEL_14;
  }
  if (v20 >> 13)
    return 27;
  v21 = 65534;
LABEL_14:
  *(_QWORD *)(a5 + 128) = v21;
  v22 = (2 * v21 + 6) & 0x7FFFFFFFFFFFFFF8;
  if (v13)
    v10 = v12;
  if (v17)
    v23 = v16;
  else
    v23 = v15;
  v24 = ((2 * v20 + 6) & 0x7FFFFFFFFFFFFFF8) + 8 * (v20 + v10 + v23) + v22 + 2520;
  if (v24 > 0x100000)
    return 27;
  if (v24 % a1)
    v24 = a1 - 1 + v24 - (a1 - 1 + v24) % a1;
  *(_QWORD *)(a5 + 136) = v24;
  v26 = (a1 - 96 - (((((18725 * ((unsigned __int16)(a1 - 96) >> 2)) >> 15) & 0x3FFC) + 28) & 0x7FE0))
      / 0x30uLL;
  v27 = 0x200000 / a1;
  v28 = 15;
  if (a2 >= 0x100000)
    v29 = 15;
  else
    v29 = 31;
  if (a2 >= 0x100000)
    v30 = 4;
  else
    v30 = 5;
  if (a2 < 0x40000)
  {
    v29 = 63;
    v30 = 6;
  }
  v31 = (v29 + a2) >> v30;
  v32 = v26 - 1;
  v33 = (v26 - 1 + v31) / v26;
  if (v33 >= v27)
    v33 = 0x200000 / a1;
  if (v33 == 2)
    v33 = 3;
  if (a3 >= 0x100000)
  {
    v34 = 4;
  }
  else
  {
    v28 = 31;
    v34 = 5;
  }
  if (a3 < 0x40000)
  {
    v28 = 63;
    v34 = 6;
  }
  v35 = (v32 + ((v28 + a3) >> v34)) / v26;
  if (v35 >= v27)
    v35 = 0x200000 / a1;
  if (v35 == 2)
    v35 = 3;
  *(_QWORD *)(a5 + 152) = v33;
  *(_QWORD *)(a5 + 160) = v35;
  v36 = a3 + a2;
  if ((a3 + a2) >> 18)
  {
    if (v36 >> 20)
      v19 = (unint64_t)(v18 + 15) >> 4;
    else
      v19 = (unint64_t)(v18 + 31) >> 5;
  }
  v37 = (v32 + v19) / v26;
  if (v37 >= v27)
    v37 = 0x200000 / a1;
  if (v37 == 2)
    v37 = 3;
  *(_QWORD *)(a5 + 144) = v37;
  v38 = v24 / a1;
  v39 = v38 - 1;
  if (v38 <= 1)
    v39 = 0;
  v40 = 8;
  if (v33 < 8)
    v40 = v33;
  *(_QWORD *)(a5 + 192) = 4;
  *(_QWORD *)(a5 + 200) = v40;
  if (a4)
  {
    if (a4 > 0x64)
      return 22;
  }
  else
  {
    v41 = v36 * a1;
    v42 = (v36 * a1) >> 29;
    if ((v41 & 0x1FFFFFFF) != 0)
      v43 = v42 + 1;
    else
      v43 = v42;
    if (v43 >= 0x64)
      a4 = 100;
    else
      a4 = v43;
  }
  *(_QWORD *)(a5 + 184) = a4;
  v44 = v40 * a4;
  v45 = 2;
  if (a3)
    v45 = 3;
  v46 = v45 + v33 + v35 + v37 + v38 + v39 + 8 * v44;
  *(_QWORD *)(a5 + 168) = 4
                        * ((unsigned __int16)(v46 + (unsigned __int16)(a1 - 40) / 0x28u - 1)
                         / ((unsigned __int16)(a1 - 40)
                          / 0x28u))
                        + 4;
  *(_QWORD *)(a5 + 176) = 4 * v46;
  *(_QWORD *)(a5 + 208) = 0;
  v5 = 0;
  if (a3)
  {
    v47 = 0x100000000;
    if (0x800000000uLL / a1 < a2)
      v47 = 0x200000000;
    v48 = v47 / a1;
    if (v48 >= a2 / 5)
      v48 = a2 / 5;
    *(_QWORD *)(a5 + 208) = v48;
  }
  return v5;
}

uint64_t nx_get_evict_mapping_tree(uint64_t a1, unsigned int a2, uint64_t a3, int a4, int a5, uint64_t *a6)
{
  uint64_t result;
  uint64_t (*v12)(uint64_t, _QWORD *, uint64_t, _QWORD *, uint64_t, int *);
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v13 = 0;
  v14 = 0u;
  v18 = 0;
  v16 = 0u;
  v17 = 0u;
  v15 = 0u;
  v12 = evict_mapping_key_compare;
  DWORD2(v13) = 33;
  HIDWORD(v13) = a4;
  result = btree_get_extended(a1, a2, a3, 0, 0, (uint64_t)&v12, 0, a6);
  if ((_DWORD)result == 92 && a5)
  {
    v13 = 0u;
    v14 = 0u;
    v18 = 0;
    v16 = 0u;
    v17 = 0u;
    v15 = 0u;
    v12 = evict_mapping_key_compare;
    HIDWORD(v13) = a4;
    result = btree_get_extended(a1, 0, a3, 0, 0, (uint64_t)&v12, 0, a6);
    if (!(_DWORD)result)
    {
      log_debug("%s:%d: %s found mapping tree with old subtype\n", "nx_get_evict_mapping_tree", 544, (const char *)(*(_QWORD *)(a1 + 384) + 208));
      return 0;
    }
  }
  return result;
}

uint64_t nx_init_phys(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  uint64_t v6;
  const unsigned __int8 *v7;
  uint64_t result;

  if (!a3)
    return 22;
  v5 = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a1 + 32) = 1112758350;
  *(_DWORD *)(a1 + 36) = v5;
  *(_QWORD *)(a1 + 1264) = 0;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a3 + 8);
  *(_OWORD *)(a1 + 56) = xmmword_1DF2E9030;
  v6 = *(_QWORD *)(a3 + 32);
  *(_QWORD *)(a1 + 88) = 1024;
  *(_QWORD *)(a1 + 96) = v6;
  uuid_copy((unsigned __int8 *)(a1 + 72), (const unsigned __int8 *)(a3 + 64));
  v7 = (const unsigned __int8 *)(a3 + 80);
  if (uuid_is_null(v7))
    return 0;
  uuid_copy((unsigned __int8 *)(a1 + 1280), v7);
  result = 0;
  *(_QWORD *)(a1 + 64) |= 0x100uLL;
  return result;
}

uint64_t nx_init(uint64_t a1, unsigned int *a2)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;

  if (!a2)
    return 22;
  v3 = *(_QWORD *)(a1 + 56);
  v4 = *a2;
  *(_DWORD *)(a1 + 648) = *a2;
  *(_DWORD *)(a1 + 652) = *(_DWORD *)(v3 + 36) / v4;
  v5 = *((_QWORD *)a2 + 3);
  *(_QWORD *)(a1 + 376) = v3;
  *(_QWORD *)(a1 + 384) = v5;
  LODWORD(v5) = a2[11];
  *(_BYTE *)(a1 + 627) = a2[10] != 0;
  *(_BYTE *)(a1 + 628) = (_DWORD)v5 != 0;
  LODWORD(v5) = a2[13];
  *(_BYTE *)(a1 + 629) = a2[12] != 0;
  *(_BYTE *)(a1 + 631) = (_DWORD)v5 != 0;
  LODWORD(v5) = a2[15];
  *(_BYTE *)(a1 + 632) = a2[14] != 0;
  *(_BYTE *)(a1 + 633) = (_DWORD)v5 != 0;
  *(_QWORD *)(a1 + 392) = *(_QWORD *)a1;
  new_lock((pthread_mutex_t *)(a1 + 656));
  new_lock((pthread_mutex_t *)(a1 + 848));
  *(_OWORD *)(a1 + 912) = 0u;
  new_rwlock((pthread_rwlock_t *)(a1 + 928));
  *(_QWORD *)(a1 + 1128) = 0;
  *(_QWORD *)(a1 + 1336) = 0;
  *(_BYTE *)(a1 + 635) = 0;
  new_lock((pthread_mutex_t *)(a1 + 1856));
  new_rwlock((pthread_rwlock_t *)(a1 + 1136));
  new_lock((pthread_mutex_t *)(a1 + 736));
  *(_QWORD *)(a1 + 812) = 0;
  *(_QWORD *)(a1 + 800) = 0;
  *(_WORD *)(a1 + 808) = 0;
  new_lock((pthread_mutex_t *)(a1 + 504));
  new_cv((pthread_cond_t *)(a1 + 568));
  return 0;
}

uint64_t nx_destroy(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 720);
  if (v2 && !*(_DWORD *)(*(_QWORD *)a1 + 912))
    obj_release(v2);
  free_rwlock((pthread_rwlock_t *)(a1 + 928));
  free_rwlock((pthread_rwlock_t *)(a1 + 1136));
  free_lock((pthread_mutex_t *)(a1 + 848));
  free_lock((pthread_mutex_t *)(a1 + 656));
  free_lock((pthread_mutex_t *)(a1 + 1856));
  free_lock((pthread_mutex_t *)(a1 + 736));
  free_lock((pthread_mutex_t *)(a1 + 504));
  free_cv((pthread_cond_t *)(a1 + 568));
  return 0;
}

uint64_t nx_fusion_superblock_write(uint64_t a1, const void *a2)
{
  uint64_t v2;
  _BYTE *v6;
  int8x16_t v7;
  int8x16_t v8;
  uint64_t v9;

  v2 = *(_QWORD *)(a1 + 376);
  if ((*(_BYTE *)(v2 + 65) & 1) == 0)
    return 0;
  v6 = _apfs_malloc(*(unsigned int *)(v2 + 36));
  memcpy(v6, a2, *(unsigned int *)(*(_QWORD *)(a1 + 376) + 36));
  v6[1295] |= 1u;
  obj_checksum_set_phys(a1, (uint64_t)v6, *(_DWORD *)(*(_QWORD *)(a1 + 376) + 36), v7, v8);
  v9 = dev_write(*(_QWORD *)(a1 + 384), 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(_QWORD *)(a1 + 376) + 36))));
  _apfs_free(v6, *(unsigned int *)(*(_QWORD *)(a1 + 376) + 36));
  return v9;
}

uint64_t nx_checkpoint_traverse(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t i;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  const char *v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t *v40;
  _QWORD v41[2];
  uint64_t *v42;
  uint64_t *v43;
  char *v44;
  uint64_t *v45;

  v44 = 0;
  v45 = 0;
  v43 = 0;
  v42 = 0;
  v6 = spaceman_get((_QWORD *)a1, (uint64_t *)&v45);
  if ((_DWORD)v6)
  {
    v7 = v6;
    v8 = *(_QWORD *)(a1 + 400);
    if (!v8 || !*(_DWORD *)(v8 + 76))
    {
      LODWORD(v9) = 831;
      log_err("%s:%d: %s failed to get spaceman oid %lld for checkpoint %s traverse: %d\n");
      goto LABEL_9;
    }
    return v7;
  }
  v7 = spaceman_checkpoint_traverse(a1, a2, (uint64_t)v45, a3);
  obj_release(v45);
  if ((_DWORD)v7)
  {
    v10 = *(_QWORD *)(a1 + 400);
    if (!v10 || !*(_DWORD *)(v10 + 76))
    {
      LODWORD(v9) = 838;
      log_err("%s:%d: %s spaceman checkpoint %s traverse failed: %d\n");
      goto LABEL_9;
    }
    return v7;
  }
  v13 = *(_QWORD *)(a1 + 376);
  v14 = *(_QWORD *)(v13 + 160);
  if (v14 && !*(_DWORD *)(a1 + 728))
  {
    v17 = obj_get(*(_QWORD *)(a1 + 392), 0x40000000u, v14, (int *)&om_desc, 0, 0, 0, 0, (uint64_t *)&v43);
    if ((_DWORD)v17)
    {
      v7 = v17;
      v18 = *(_QWORD *)(a1 + 400);
      if (!v18 || !*(_DWORD *)(v18 + 76))
      {
        LODWORD(v9) = 848;
        log_err("%s:%d: %s failed to get omap for checkpoint %s traverse: %d\n");
        goto LABEL_9;
      }
      return v7;
    }
    v7 = omap_checkpoint_traverse(a1, a2, (uint64_t)v43, a3);
    obj_release(v43);
    if ((_DWORD)v7)
    {
      v20 = *(_QWORD *)(a1 + 400);
      if (!v20 || !*(_DWORD *)(v20 + 76))
      {
        LODWORD(v9) = 854;
        log_err("%s:%d: %s omap checkpoint %s traverse failed: %d\n");
        goto LABEL_9;
      }
      return v7;
    }
    v13 = *(_QWORD *)(a1 + 376);
  }
  if (*(_QWORD *)(v13 + 168))
  {
    v15 = nx_reaper_get((_QWORD *)a1, &v44);
    if ((_DWORD)v15)
    {
      v7 = v15;
      v16 = *(_QWORD *)(a1 + 400);
      if (!v16 || !*(_DWORD *)(v16 + 76))
      {
        LODWORD(v9) = 867;
        log_err("%s:%d: %s failed to get reaper for checkpoint %s traverse: %d\n");
        goto LABEL_9;
      }
      return v7;
    }
    v7 = nx_reaper_checkpoint_traverse((uint64_t *)a1, a2, (uint64_t)v44, a3);
    obj_release((uint64_t *)v44);
    if ((_DWORD)v7)
    {
      v19 = *(_QWORD *)(a1 + 400);
      if (!v19 || !*(_DWORD *)(v19 + 76))
      {
        LODWORD(v9) = 874;
        log_err("%s:%d: %s nx reaper checkpoint %s traverse failed: %d\n");
        goto LABEL_9;
      }
      return v7;
    }
    v13 = *(_QWORD *)(a1 + 376);
  }
  if (*(_DWORD *)(v13 + 180))
  {
    for (i = 0; i < *(unsigned int *)(v13 + 180); ++i)
    {
      v22 = *(_QWORD *)(v13 + 8 * i + 184);
      if (v22)
      {
        v23 = obj_get(*(_QWORD *)(a1 + 392), 0, v22, (int *)&apfs_desc, 0, 0, 0, 0, (uint64_t *)&v42);
        if ((_DWORD)v23)
        {
          v7 = v23;
          v28 = *(_QWORD *)(a1 + 400);
          if (v28 && *(_DWORD *)(v28 + 76))
            return v7;
          v29 = "<UNKNOWN>";
          if ((_DWORD)a3 == 2)
            v29 = "FIXUP";
          if ((_DWORD)a3 == 1)
            v29 = "START";
          v36 = (uint64_t)v29;
          v37 = v23;
          v34 = i;
          v35 = v22;
          v33 = *(_QWORD *)(a1 + 384) + 208;
          v9 = 898;
          v27 = "%s:%d: %s failed to get fs[%d] oid %lld for checkpoint %s traverse: %d\n";
LABEL_58:
          log_err(v27, "nx_checkpoint_traverse", v9, v33, v34, v35, v36, v37, v38);
LABEL_9:
          v11 = *(_QWORD *)(a1 + 400);
          if (v11)
          {
LABEL_10:
            *(_DWORD *)(v11 + 76) = v9;
            ++*(_WORD *)(v11 + 80);
          }
          return v7;
        }
        v7 = apfs_checkpoint_traverse(a1, a2, (uint64_t)v42, a3);
        obj_release(v42);
        if ((_DWORD)v7)
        {
          v30 = *(_QWORD *)(a1 + 400);
          if (!v30 || !*(_DWORD *)(v30 + 76))
          {
            LODWORD(v9) = 904;
            log_err("%s:%d: %s fs[%d] checkpoint %s traverse failed: %d\n");
            goto LABEL_9;
          }
          return v7;
        }
        v13 = *(_QWORD *)(a1 + 376);
      }
    }
  }
  if (!*(_QWORD *)(v13 + 1344) || !obj_type_is_or_contains_ephemeral(*(_DWORD *)(v13 + 176)))
    return 0;
  v41[0] = 0;
  v41[1] = 0;
  v40 = 0;
  v39 = 0;
  v7 = obj_descriptor_and_flags_for_type(*(_DWORD *)(*(_QWORD *)(a1 + 376) + 176), &v39, (uint64_t)v41);
  HIDWORD(v41[0]) = 255;
  if ((_DWORD)v7
    || (v7 = obj_get(*(_QWORD *)(a1 + 392), v39, *(_QWORD *)(*(_QWORD *)(a1 + 376) + 1344), (int *)v41, 0, 0, 0, 0, (uint64_t *)&v40), (_DWORD)v7))
  {
    v24 = *(_QWORD *)(a1 + 400);
    if (!v24 || !*(_DWORD *)(v24 + 76))
    {
      v25 = *(_QWORD *)(a1 + 376);
      v26 = "<UNKNOWN>";
      if ((_DWORD)a3 == 2)
        v26 = "FIXUP";
      if ((_DWORD)a3 == 1)
        v26 = "START";
      v37 = (uint64_t)v26;
      v38 = v7;
      v35 = *(unsigned int *)(v25 + 176);
      v36 = 255;
      v33 = *(_QWORD *)(a1 + 384) + 208;
      v34 = *(_QWORD *)(v25 + 1344);
      v9 = 925;
      v27 = "%s:%d: %s unable to get test object 0x%llx of type 0x%x/0x%x for checkpoint %s traverse: %d\n";
      goto LABEL_58;
    }
  }
  else
  {
    v7 = obj_checkpoint_traverse(a1, a2, (uint64_t)v40, a3);
    obj_release(v40);
    if ((_DWORD)v7)
    {
      v31 = *(_QWORD *)(a1 + 400);
      if (!v31 || !*(_DWORD *)(v31 + 76))
      {
        v32 = "<UNKNOWN>";
        if ((_DWORD)a3 == 2)
          v32 = "FIXUP";
        if ((_DWORD)a3 == 1)
          v32 = "START";
        LODWORD(v9) = 931;
        log_err("%s:%d: %s failed to checkpoint %s traverse test object 0x%llx of type 0x%x/0x%x: %d\n", "nx_checkpoint_traverse", 931, (const char *)(*(_QWORD *)(a1 + 384) + 208), v32, *(_QWORD *)(*(_QWORD *)(a1 + 376) + 1344), *(_DWORD *)(*(_QWORD *)(a1 + 376) + 176), 255, v7);
        v11 = *(_QWORD *)(a1 + 400);
        if (v11)
          goto LABEL_10;
      }
    }
  }
  return v7;
}

uint64_t nx_reaper_get(_QWORD *a1, char **a2)
{
  char *v3;
  uint64_t result;

  v3 = (char *)a1[53];
  *a2 = v3;
  if (v3)
    goto LABEL_2;
  result = obj_get(a1[49], 0x80000000, *(_QWORD *)(a1[47] + 168), &nx_reaper_desc, 0, 0, 0, 0, a2);
  if (!(_DWORD)result)
  {
    a1[53] = *a2;
    v3 = *a2;
LABEL_2:
    obj_retain(v3);
    return 0;
  }
  return result;
}

uint64_t nx_reaper_checkpoint_traverse(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  int *v20;
  int v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v35;
  int v37;
  unsigned int v38;
  uint64_t *v39;
  char *v40;
  unsigned int *v41;

  v4 = a4;
  v6 = *(_QWORD *)(a3 + 376);
  v39 = 0;
  if ((_DWORD)a4 == 2)
  {
    v7 = obj_checkpoint_known(a3);
LABEL_5:
    v8 = v7;
    if ((_DWORD)v7)
      return v8;
    goto LABEL_6;
  }
  if ((_DWORD)a4 == 1)
  {
    v7 = obj_checkpoint_start((unsigned int *)a3);
    goto LABEL_5;
  }
LABEL_6:
  v40 = 0;
  v41 = 0;
  if (*(_QWORD *)(v6 + 88) && obj_type_is_or_contains_ephemeral(*(_DWORD *)(v6 + 72)))
  {
    v8 = 0;
    if ((*(_DWORD *)(v6 + 104) & 0x10) == 0 && (*(_DWORD *)(v6 + 104) & 6) != 2)
    {
      v9 = nx_reaper_obj_get(a1, *(_DWORD *)(v6 + 72), *(_DWORD *)(v6 + 76), *(_QWORD *)(v6 + 80), *(_QWORD *)(v6 + 88), &v39, &v40);
      if ((_DWORD)v9)
      {
        v8 = v9;
        v10 = a1[50];
        if (!v10 || !*(_DWORD *)(v10 + 76))
          log_err("%s:%d: %s failed to get object oid %lld: %d\n", "nx_reaper_checkpoint_traverse", 1207, (const char *)(a1[48] + 208), *(_QWORD *)(v6 + 88), v9);
      }
      else
      {
        if (v39)
          v35 = v39;
        else
          v35 = a1;
        v8 = obj_checkpoint_traverse((uint64_t)v35, a2, (uint64_t)v40, v4);
        obj_release((uint64_t *)v40);
      }
      if (v39)
      {
        obj_release(v39);
        v39 = 0;
      }
    }
  }
  else
  {
    v8 = 0;
  }
  if ((_DWORD)v8)
    return v8;
  v11 = *(_QWORD *)(v6 + 48);
  if (!v11)
    return v8;
  v37 = *(_DWORD *)(v6 + 68);
  v38 = v4;
  do
  {
    v12 = obj_get(a1[49], 0x80000000, v11, (int *)&nx_reap_list_desc, 0, 0, 0, 0, (uint64_t *)&v41);
    if ((_DWORD)v12)
    {
      v8 = v12;
      v33 = a1[50];
      if (!v33 || !*(_DWORD *)(v33 + 76))
        log_err("%s:%d: %s failed to get reap list object oid %lld: %d\n", "nx_reaper_checkpoint_traverse", 1227, (const char *)(a1[48] + 208), v11, v12);
      return v8;
    }
    v13 = *((_QWORD *)v41 + 47);
    if ((_DWORD)v4 == 2)
    {
      v14 = obj_checkpoint_known((uint64_t)v41);
      goto LABEL_23;
    }
    if ((_DWORD)v4 == 1)
    {
      v14 = obj_checkpoint_start(v41);
LABEL_23:
      v8 = v14;
      goto LABEL_25;
    }
    v8 = 0;
LABEL_25:
    v11 = *(_QWORD *)(v13 + 32);
    if ((_DWORD)v8)
      goto LABEL_56;
    v15 = *(_DWORD *)(v13 + 52);
    if (v15 == -1)
      goto LABEL_56;
    v16 = -1;
    while (1)
    {
      v17 = *(_DWORD *)(v13 + 40 * v15 + 64);
      if (v17 != -1 && v17 > *(_DWORD *)(v13 + 44))
        break;
      v18 = v13 + 40 * v15;
      v21 = *(_DWORD *)(v18 + 72);
      v20 = (int *)(v18 + 72);
      v19 = v21;
      if ((v21 != *(_DWORD *)(v6 + 72) || *(_QWORD *)(v13 + 40 * v15 + 88) != *(_QWORD *)(v6 + 88))
        && (v16 == -1
         || v19 != *(_DWORD *)(v13 + 40 * v16 + 72)
         || *(_QWORD *)(v13 + 64 + 40 * v15 + 24) != *(_QWORD *)(v13 + 64 + 40 * v16 + 24)))
      {
        v8 = 0;
        if ((*(_DWORD *)(v13 + 40 * v15 + 68) & 0x10) != 0 || (*(_DWORD *)(v13 + 40 * v15 + 68) & 6) == 2)
          goto LABEL_49;
        if (obj_type_is_or_contains_ephemeral(v19))
        {
          v22 = v13 + 40 * v15;
          v24 = *(_QWORD *)(v22 + 88);
          v23 = (_QWORD *)(v22 + 88);
          v25 = nx_reaper_obj_get(a1, *v20, *((_DWORD *)v23 - 3), *(v23 - 1), v24, &v39, &v40);
          if ((_DWORD)v25)
          {
            v8 = v25;
            v26 = a1[50];
            if (!v26 || !*(_DWORD *)(v26 + 76))
              log_err("%s:%d: %s failed to get object oid %lld: %d\n", "nx_reaper_checkpoint_traverse", 1287, (const char *)(a1[48] + 208), *v23, v25);
          }
          else
          {
            if (v39)
              v27 = v39;
            else
              v27 = a1;
            v8 = obj_checkpoint_traverse((uint64_t)v27, a2, (uint64_t)v40, v38);
            obj_release((uint64_t *)v40);
          }
          if (v39)
          {
            obj_release(v39);
            v39 = 0;
          }
          goto LABEL_49;
        }
      }
      v8 = 0;
LABEL_49:
      if (!(_DWORD)v8)
      {
        v16 = v15;
        v15 = v17;
        if (v17 != -1)
          continue;
      }
      goto LABEL_56;
    }
    v28 = a1[50];
    if (!v28 || !*(_DWORD *)(v28 + 76))
      log_err("%s:%d: %s Invalid reap list entry nrl_entries[%d].nrle_next = %d\n", "nx_reaper_checkpoint_traverse", 1249, (const char *)(a1[48] + 208), v15, v17);
    obj_release((uint64_t *)v41);
    v8 = nx_corruption_detected_int((uint64_t)a1);
LABEL_56:
    v29 = *(_DWORD *)(v6 + 68);
    if (!v29)
      goto LABEL_68;
    v30 = v37 - 1;
    if (v11 && v37 == 1)
    {
      v31 = a1[50];
      LODWORD(v4) = v38;
      if (!v31 || !*(_DWORD *)(v31 + 76))
        log_err("%s:%d: %s reap list expected %u objects, but haven't seen last reap list object yet\n", "nx_reaper_checkpoint_traverse", 1303, (const char *)(a1[48] + 208), v29);
      v8 = nx_corruption_detected_int((uint64_t)a1);
      v37 = 0;
      goto LABEL_69;
    }
    --v37;
    if (v11)
    {
LABEL_68:
      LODWORD(v4) = v38;
      goto LABEL_69;
    }
    LODWORD(v4) = v38;
    if (v30)
    {
      v32 = a1[50];
      if (!v32 || !*(_DWORD *)(v32 + 76))
        log_warn("%s:%d: %s reap list expected %u objects, but got last reap list object with %u more objects left\n", "nx_reaper_checkpoint_traverse", 1308, (const char *)(a1[48] + 208), v29, v37);
    }
LABEL_69:
    obj_release((uint64_t *)v41);
  }
  while (!(_DWORD)v8 && v11);
  return v8;
}

uint64_t nx_reaper_init_phys(uint64_t a1, int a2)
{
  *(_QWORD *)(a1 + 32) = 1;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 1;
  *(_DWORD *)(a1 + 108) = (a2 & 0xFFFFFFFC) - 112;
  return 0;
}

uint64_t nx_reaper_init(_QWORD *a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  _BOOL4 v8;
  int v9;
  BOOL v10;
  uint64_t result;
  unsigned int v13;

  v2 = a1[7];
  v4 = *(_QWORD *)(v2 + 32);
  v3 = *(_QWORD *)(v2 + 40);
  v5 = *(unsigned int *)(v2 + 108);
  v6 = (obj_size_phys((uint64_t)a1) & 0xFFFFFFFCLL) - 112;
  if (v3 < v4)
    v7 = 1;
  else
    v7 = 2;
  if (v6 >= v5)
    v8 = v3 >= v4;
  else
    v8 = v7;
  v9 = *(_DWORD *)(v2 + 68);
  if (v9 == 1)
  {
    v10 = *(_QWORD *)(v2 + 48) == *(_QWORD *)(v2 + 56);
  }
  else
  {
    if (v9)
    {
      if (v8)
        goto LABEL_19;
      goto LABEL_20;
    }
    if (*(_QWORD *)(v2 + 48))
      goto LABEL_19;
    v10 = *(_QWORD *)(v2 + 56) == 0;
  }
  if (!v10 || v8)
  {
LABEL_19:
    result = nx_corruption_detected_int(*(_QWORD *)(*a1 + 392));
    if ((_DWORD)result)
      return result;
  }
LABEL_20:
  a1[47] = v2;
  v13 = obj_size_phys((uint64_t)a1);
  result = 0;
  a1[48] = v2 + v13 - *(unsigned int *)(v2 + 108);
  return result;
}

uint64_t nx_reap_list_init_phys(uint64_t a1, unsigned int a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;

  v2 = ((unint64_t)a2 - 64) / 0x28;
  *(_DWORD *)(a1 + 44) = v2;
  *(_QWORD *)(a1 + 52) = -1;
  *(_DWORD *)(a1 + 60) = 0;
  v3 = (v2 - 1);
  if ((_DWORD)v3)
  {
    v4 = 0;
    v5 = (_DWORD *)(a1 + 64);
    do
    {
      *v5 = ++v4;
      v5 += 10;
    }
    while (v3 != v4);
  }
  else
  {
    LODWORD(v3) = 0;
  }
  *(_DWORD *)(a1 + 40 * v3 + 64) = -1;
  return 0;
}

uint64_t nx_reap_list_init(_QWORD *a1)
{
  _DWORD *v2;
  unsigned int v3;
  BOOL v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v13;
  int v15;
  BOOL v16;
  uint64_t result;

  v2 = (_DWORD *)a1[7];
  v3 = v2[11];
  v4 = v3 > (((unint64_t)obj_size_phys((uint64_t)a1) - 64) / 0x28);
  v6 = v2[11];
  v5 = v2[12];
  if (v4)
    v7 = 2;
  else
    v7 = 1;
  if (v5 <= v6)
    v8 = v4;
  else
    v8 = v7;
  v9 = v2[13];
  v10 = v2[14];
  if (v9 != -1 && v9 >= v6)
    ++v8;
  if (v10 != -1 && v10 >= v6)
    ++v8;
  v13 = v2[15];
  if (v13 != -1 && v13 >= v6)
    v15 = v8 + 1;
  else
    v15 = v8;
  if (v5 == 1)
  {
    v16 = v9 == v10;
  }
  else
  {
    if (v5)
    {
      if (v15)
        goto LABEL_36;
      goto LABEL_37;
    }
    v16 = v9 == -1 && v10 == -1;
  }
  if (!v16 || v15 != 0)
  {
LABEL_36:
    result = nx_corruption_detected_int(*(_QWORD *)(*a1 + 392));
    if ((_DWORD)result)
      return result;
  }
LABEL_37:
  result = 0;
  a1[47] = v2;
  return result;
}

uint64_t nx_reaper_obj_get(uint64_t *a1, int a2, int a3, unint64_t a4, unint64_t a5, uint64_t **a6, char **a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t *v23;

  v23 = 0;
  v22 = 0;
  v20 = 0;
  v21 = 0;
  *a7 = 0;
  *a6 = 0;
  if (a4)
  {
    v14 = obj_get(a1[49], 0, a4, (int *)&apfs_desc, 0, 0, 0, 0, (uint64_t *)&v23);
    if ((_DWORD)v14)
    {
      v15 = v14;
      log_err("%s:%d: %s unable to get fs object 0x%llx: %d\n", "nx_reaper_obj_get", 1140, (const char *)(a1[48] + 208), a4, v14);
      return v15;
    }
    v17 = v23;
  }
  else
  {
    v17 = 0;
  }
  *a6 = v17;
  if ((a2 & 0x4000FFFF) == 0x4000000B)
  {
    v18 = (uint64_t)(v17 ? v17 : a1);
    if (!omap_obj_get(v18, 0, 0, a7))
      return 0;
  }
  v16 = obj_descriptor_and_flags_for_type(a2, &v22, (uint64_t)&v20);
  if ((_DWORD)v16
    || (LODWORD(v21) = a3,
        v16 = obj_get(a1[49], v22, a5, (int *)&v20, 0, (uint64_t)v23, 0, 0, (uint64_t *)a7),
        (_DWORD)v16))
  {
    log_err("%s:%d: %s unable to get object 0x%llx: %d\n", "nx_reaper_obj_get", 1161, (const char *)(a1[48] + 208), a5, v16);
    if (v23)
      obj_release(v23);
    *a7 = 0;
    *a6 = 0;
  }
  return v16;
}

uint64_t nx_reaper_add(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, _QWORD *a8)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  pthread_mutex_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  _DWORD *v24;
  _DWORD *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  _DWORD *v31;
  _DWORD *v32;
  int v33;
  int v34;
  int v35;
  int v36;
  _DWORD *v37;
  int v38;
  _DWORD *v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;

  v46 = 0;
  v47 = 0;
  v44 = 0;
  v45 = 0;
  v16 = nx_reaper_get((_QWORD *)a1, &v47);
  if ((_DWORD)v16)
    return v16;
  v17 = *((_QWORD *)v47 + 47);
  v16 = obj_descriptor_funcs_for_type(a2, &v44);
  if ((_DWORD)v16)
  {
LABEL_3:
    log_err("%s:%d: %s object type 0x%x not reapable: %d\n", "nx_reaper_add", 1357, (const char *)(*(_QWORD *)(a1 + 384) + 208), a2, v16);
LABEL_14:
    obj_release(v47);
    return v16;
  }
  if (!*(_QWORD *)(v44 + 24))
  {
    v16 = 22;
    goto LABEL_3;
  }
  obj_lock((uint64_t)v47, 2);
  v18 = obj_modify(v47, 0, a6);
  if ((_DWORD)v18)
  {
    v16 = v18;
LABEL_13:
    obj_unlock((uint64_t)v47, 2);
    goto LABEL_14;
  }
  v19 = *(pthread_mutex_t **)(a1 + 392);
  if (*(_OWORD *)(v17 + 48) == 0)
  {
    v20 = obj_create(v19, 0x80000000, 0, (uint64_t)&nx_reap_list_desc, 0, 0, a6, &v46);
    if ((_DWORD)v20)
    {
      v16 = v20;
      log_err("%s:%d: %s failed to create reap list: %d\n");
      goto LABEL_13;
    }
    v23 = obj_oid(v46);
    *(_QWORD *)(v17 + 48) = v23;
    *(_QWORD *)(v17 + 56) = v23;
    v24 = (_DWORD *)(v17 + 68);
    goto LABEL_17;
  }
  v21 = obj_get(v19, 2147483649, *(_QWORD *)(v17 + 56), &nx_reap_list_desc, 0, 0, 0, a6, &v46);
  if ((_DWORD)v21)
  {
    v16 = v21;
    log_err("%s:%d: %s failed to get reap list tail: %d\n");
    goto LABEL_13;
  }
  v24 = (_DWORD *)(v17 + 68);
  if (!*(_DWORD *)(v17 + 68) && *(_QWORD *)(v17 + 48) == *(_QWORD *)(v17 + 56))
  {
LABEL_17:
    *v24 = 1;
    obj_dirty((uint64_t)v47, a6, 0);
  }
  v25 = *(_DWORD **)(v46 + 376);
  if (v25[12] > (v25[11] - 2))
  {
    v26 = obj_create(*(pthread_mutex_t **)(a1 + 392), 0x80000000, 0, (uint64_t)&nx_reap_list_desc, 0, 0, a6, &v45);
    if ((_DWORD)v26)
    {
      v16 = v26;
      obj_unlock((uint64_t)v47, 2);
      obj_release(v46);
      goto LABEL_14;
    }
    v27 = obj_oid(v45);
    *(_QWORD *)(*(_QWORD *)(v46 + 376) + 32) = v27;
    *(_QWORD *)(v17 + 56) = obj_oid(v45);
    v28 = *(_DWORD *)(v17 + 68);
    if (v28)
      *(_DWORD *)(v17 + 68) = v28 + 1;
    obj_dirty((uint64_t)v47, a6, 0);
    obj_release(v46);
    v46 = v45;
    v25 = *(_DWORD **)(v45 + 376);
  }
  v29 = *(_QWORD *)(v17 + 32);
  *(_QWORD *)(v17 + 32) = v29 + 1;
  v30 = v25[15];
  if (v30 == -1)
  {
    log_err("%s:%d: %s reap list object free list erroneously empty?\n", "nx_reaper_add", 1427, (const char *)(*(_QWORD *)(a1 + 384) + 208));
    obj_unlock((uint64_t)v47, 2);
    obj_release(v46);
    obj_release(v47);
    v43 = a1;
    return nx_corruption_detected_int(v43);
  }
  v31 = &v25[10 * v30];
  v34 = v31[16];
  v32 = v31 + 16;
  v33 = v34;
  v25[15] = v34;
  v35 = v25[14];
  if (v35 != -1)
    v25[10 * v35 + 16] = v30;
  if (v25[13] == -1)
    v25[13] = v30;
  v25[14] = v30;
  v36 = v25[12];
  v25[12] = v36 + 1;
  *v32 = -1;
  v37 = &v25[10 * v30];
  if ((a7 & 2) != 0)
    v38 = 21;
  else
    v38 = 5;
  v37[17] = v38;
  v37[18] = a2;
  v37[19] = a3;
  *((_QWORD *)v37 + 10) = a4;
  *((_QWORD *)v37 + 11) = a5;
  *((_QWORD *)v37 + 12) = a6;
  if (v33 == -1)
  {
    log_err("%s:%d: %s reap list object free list erroneously empty?\n", "nx_reaper_add", 1458, (const char *)(*(_QWORD *)(a1 + 384) + 208));
    obj_unlock((uint64_t)v47, 2);
    obj_release(v46);
    obj_release(v47);
    v43 = a1;
    return nx_corruption_detected_int(v43);
  }
  v39 = &v25[10 * v33];
  v40 = v39[16];
  *v32 = v33;
  v25[14] = v33;
  v25[15] = v40;
  v25[12] = v36 + 2;
  if ((a7 & 2) != 0)
    v41 = 19;
  else
    v41 = 3;
  if ((a7 & 1) != 0)
    v41 |= 0xCu;
  v39[16] = -1;
  v39[17] = v41;
  v39[18] = a2;
  v39[19] = a3;
  *((_QWORD *)v39 + 10) = a4;
  *((_QWORD *)v39 + 11) = a5;
  *((_QWORD *)v39 + 12) = v29;
  obj_dirty(v46, a6, 0);
  obj_unlock((uint64_t)v47, 2);
  obj_release(v46);
  obj_release(v47);
  if (!a8)
    return 0;
  v42 = v29;
  v16 = 0;
  *a8 = v42;
  return v16;
}

uint64_t nx_reaper_add_sub_object(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  uint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  _DWORD *v28;
  int v29;
  int v30;
  _DWORD *v31;
  int v32;
  _DWORD *v33;
  int v34;
  _DWORD *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;

  v40 = 0;
  v41 = 0;
  v38 = 0;
  v39 = 0;
  v14 = nx_reaper_get((_QWORD *)a1, &v41);
  if ((_DWORD)v14)
    return v14;
  v15 = *((_QWORD *)v41 + 47);
  v14 = obj_descriptor_funcs_for_type(a2, &v38);
  if ((_DWORD)v14)
  {
LABEL_3:
    log_err("%s:%d: %s object type 0x%x not reapable: %d\n", "nx_reaper_add_sub_object", 1536, (const char *)(*(_QWORD *)(a1 + 384) + 208), a2, v14);
LABEL_4:
    obj_release(v41);
    return v14;
  }
  if (!*(_QWORD *)(v38 + 24))
  {
    v14 = 22;
    goto LABEL_3;
  }
  obj_lock((uint64_t)v41, 2);
  v17 = obj_modify(v41, 0, a6);
  if ((_DWORD)v17)
  {
    v14 = v17;
    obj_unlock((uint64_t)v41, 2);
    goto LABEL_4;
  }
  v18 = *(_QWORD *)(v15 + 48);
  if (!v18 && !*(_QWORD *)(v15 + 56))
  {
    v21 = obj_create(*(pthread_mutex_t **)(a1 + 392), 0x80000000, 0, (uint64_t)&nx_reap_list_desc, 0, 0, a6, &v40);
    if ((_DWORD)v21)
    {
      v14 = v21;
      log_err("%s:%d: %s failed to create reap list: %d\n");
      goto LABEL_14;
    }
    v22 = obj_oid(v40);
    *(_QWORD *)(v15 + 48) = v22;
    *(_QWORD *)(v15 + 56) = v22;
    v20 = (_DWORD *)(v15 + 68);
    goto LABEL_21;
  }
  v19 = obj_get(*(_QWORD *)(a1 + 392), 2147483649, v18, &nx_reap_list_desc, 0, 0, 0, a6, &v40);
  if ((_DWORD)v19)
  {
    v14 = v19;
    log_err("%s:%d: %s failed to get reap list head: %d\n");
LABEL_14:
    log_err("%s:%d: %s failed to get reap list head: %d\n", "nx_reaper_add_sub_object", 1572, (const char *)(*(_QWORD *)(a1 + 384) + 208), v14);
    obj_unlock((uint64_t)v41, 2);
    obj_release(v41);
    return v14;
  }
  v20 = (_DWORD *)(v15 + 68);
  if (!*(_DWORD *)(v15 + 68) && *(_QWORD *)(v15 + 48) == *(_QWORD *)(v15 + 56))
  {
LABEL_21:
    *v20 = 1;
    obj_dirty((uint64_t)v41, a6, 0);
  }
  v23 = *(_DWORD **)(v40 + 376);
  if (v23[12] > v23[11] + ~(a7 & 1u))
  {
    v24 = obj_create(*(pthread_mutex_t **)(a1 + 392), 0x80000000, 0, (uint64_t)&nx_reap_list_desc, 0, 0, a6, &v39);
    if ((_DWORD)v24)
    {
      v14 = v24;
      obj_unlock((uint64_t)v41, 2);
      obj_release(v40);
      goto LABEL_4;
    }
    v25 = v39;
    *(_QWORD *)(*(_QWORD *)(v39 + 376) + 32) = *(_QWORD *)(v15 + 48);
    *(_QWORD *)(v15 + 48) = obj_oid(v25);
    v26 = *(_DWORD *)(v15 + 68);
    if (v26)
      *(_DWORD *)(v15 + 68) = v26 + 1;
    obj_dirty((uint64_t)v41, a6, 0);
    obj_release(v40);
    v40 = v39;
    v23 = *(_DWORD **)(v39 + 376);
  }
  v27 = v23[15];
  if ((a7 & 1) != 0)
  {
    if (v27 == -1)
    {
      log_err("%s:%d: %s reap list object free list erroneously empty?\n", "nx_reaper_add_sub_object", 1608, (const char *)(*(_QWORD *)(a1 + 384) + 208));
      obj_unlock((uint64_t)v41, 2);
      obj_release(v40);
      obj_release(v41);
      v37 = a1;
      return nx_corruption_detected_int(v37);
    }
    v28 = &v23[10 * v27];
    v29 = v28[16];
    v23[15] = v29;
    v30 = v23[14];
    v28[16] = v23[13];
    v23[13] = v27;
    if (v30 == -1)
      v23[14] = v27;
    ++v23[12];
    v31 = &v23[10 * v27];
    if ((a7 & 2) != 0)
      v32 = 29;
    else
      v32 = 13;
    v31[17] = v32;
    v31[18] = a2;
    v31[19] = a3;
    *((_QWORD *)v31 + 10) = a4;
    *((_QWORD *)v31 + 11) = a5;
    *((_QWORD *)v31 + 12) = a6;
    v27 = v29;
  }
  if (v27 == -1)
  {
    log_err("%s:%d: %s reap list object free list erroneously empty?\n", "nx_reaper_add_sub_object", 1636, (const char *)(*(_QWORD *)(a1 + 384) + 208));
    obj_unlock((uint64_t)v41, 2);
    obj_release(v40);
    obj_release(v41);
    v37 = a1;
    return nx_corruption_detected_int(v37);
  }
  v33 = &v23[10 * v27];
  v23[15] = v33[16];
  v34 = v23[14];
  v33[16] = v23[13];
  v23[13] = v27;
  if (v34 == -1)
    v23[14] = v27;
  ++v23[12];
  v35 = &v23[10 * v27];
  if ((a7 & 2) != 0)
    v36 = 21;
  else
    v36 = 5;
  v35[17] = v36;
  v35[18] = a2;
  v35[19] = a3;
  *((_QWORD *)v35 + 10) = a4;
  *((_QWORD *)v35 + 11) = a5;
  *((_QWORD *)v35 + 12) = a6;
  obj_dirty(v40, a6, 0);
  obj_unlock((uint64_t)v41, 2);
  obj_release(v40);
  obj_release(v41);
  return 0;
}

void nx_reaper_check_for_work(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  char *v6;

  v5 = 0;
  v6 = 0;
  if (!nx_reaper_get(a1, &v6))
  {
    v2 = *((_QWORD *)v6 + 47);
    obj_lock((uint64_t)v6, 2);
    if (!*(_QWORD *)(v2 + 88))
    {
      v3 = *(_QWORD *)(v2 + 48);
      if (!v3
        || obj_get(a1[49], 0x80000000, v3, (int *)&nx_reap_list_desc, 0, 0, 0, 0, (uint64_t *)&v5))
      {
        goto LABEL_4;
      }
      v4 = v5[47];
      if (!*(_DWORD *)(v4 + 48) && !*(_QWORD *)(v4 + 32))
      {
        obj_release(v5);
        goto LABEL_4;
      }
      obj_release(v5);
    }
    obj_unlock((uint64_t)v6, 2);
    nx_reaper(a1);
    obj_lock((uint64_t)v6, 2);
LABEL_4:
    obj_unlock((uint64_t)v6, 2);
    obj_release((uint64_t *)v6);
  }
}

uint64_t nx_reaper(uint64_t *a1)
{
  uint64_t result;
  uint64_t v3;
  char *v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int record;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;

  v20 = 0;
  v18 = 0;
  v19 = 0;
  v16 = 0;
  v17 = 0;
  result = nx_reaper_get(a1, &v20);
  if ((_DWORD)result)
    return result;
  v3 = *((_QWORD *)v20 + 47);
  obj_lock((uint64_t)v20, 2);
  v4 = v20;
  if (*((_DWORD *)v20 + 98) || *((_DWORD *)v20 + 99))
  {
    obj_unlock((uint64_t)v20, 2);
    obj_release((uint64_t *)v20);
    log_debug("%s:%d: reaper thread is exiting, returning EBUSY\n", "nx_reaper", 1792);
    return 16;
  }
  v5 = 0;
  *((_DWORD *)v20 + 98) = 1;
  while (1)
  {
    v14 = 0;
    v15 = 0;
    obj_unlock((uint64_t)v4, 2);
    v19 = 0;
    v6 = tx_enter((uint64_t)a1, &v19);
    obj_lock((uint64_t)v20, 2);
    v4 = v20;
    if (v6)
    {
LABEL_37:
      v13 = 0;
      goto LABEL_41;
    }
    v7 = obj_modify(v20, 0, v19);
    v4 = v20;
    if (v7)
    {
      v6 = v7;
LABEL_40:
      v13 = 1;
      goto LABEL_41;
    }
    if (*(_QWORD *)(v3 + 88))
      goto LABEL_13;
    if (*((_DWORD *)v20 + 99))
      goto LABEL_39;
    record = nx_reaper_next_record((uint64_t)a1, (uint64_t)v20, v19);
    if (record)
      break;
    v4 = v20;
    if (!*(_QWORD *)(v3 + 88))
    {
LABEL_39:
      v6 = 0;
      goto LABEL_40;
    }
LABEL_13:
    obj_unlock((uint64_t)v4, 2);
    if ((*(_BYTE *)(v3 + 104) & 4) == 0)
      goto LABEL_16;
    v9 = obj_descriptor_funcs_for_type(*(_DWORD *)(v3 + 72), &v18);
    if (v9)
      goto LABEL_15;
    if (!*(_QWORD *)(v18 + 24))
    {
      v9 = 22;
LABEL_15:
      log_err("%s:%d: %s object type 0x%x not reapable?: %d\n", "nx_reaper", 1833, (const char *)(a1[48] + 208), *(_DWORD *)(v3 + 72), v9);
      v5 = 1;
LABEL_16:
      obj_lock((uint64_t)v20, 2);
      goto LABEL_17;
    }
    v10 = nx_reaper_obj_get(a1, *(_DWORD *)(v3 + 72), *(_DWORD *)(v3 + 76), *(_QWORD *)(v3 + 80), *(_QWORD *)(v3 + 88), &v16, &v17);
    if (v10)
    {
      v11 = v10;
      log_err("%s:%d: %s unable to get object 0x%llx of type 0x%x: %d\n", "nx_reaper", 1838, (const char *)(a1[48] + 208), *(_QWORD *)(v3 + 88), *(_DWORD *)(v3 + 72), v10);
    }
    else
    {
      if ((*(_BYTE *)(v3 + 64) & 2) == 0)
        bzero(*((void **)v20 + 48), *(unsigned int *)(v3 + 108));
      v12 = (*(uint64_t (**)(char *, _QWORD, _QWORD, _QWORD, uint64_t))(v18 + 24))(v17, (*(_DWORD *)(v3 + 104) >> 3) & 3, *((_QWORD *)v20 + 48), *(unsigned int *)(v3 + 108), v19);
      v11 = v12;
      if (v12 && v12 != 36)
        log_err("%s:%d: %s error reaping object 0x%llx of type 0x%x: %d\n", "nx_reaper", 1852, (const char *)(a1[48] + 208), *(_QWORD *)(v3 + 88), *(_DWORD *)(v3 + 72), v12);
      obj_release((uint64_t *)v17);
      if (v16)
      {
        obj_release(v16);
        v16 = 0;
      }
    }
    obj_lock((uint64_t)v20, 2);
    if (v11 == 36)
    {
      *(_DWORD *)(v3 + 64) |= 2u;
      v5 = 1;
      goto LABEL_20;
    }
    v5 = 1;
LABEL_17:
    if ((*(_BYTE *)(v3 + 104) & 2) != 0)
      *(_QWORD *)(v3 + 40) = *(_QWORD *)(v3 + 96);
    *(_DWORD *)(v3 + 64) &= ~2u;
    *(_QWORD *)(v3 + 88) = 0;
LABEL_20:
    obj_dirty((uint64_t)v20, v19, 0);
    obj_unlock((uint64_t)v20, 2);
    spaceman_currently_available_space((uint64_t)a1, &v15, &v14, 0, 0);
    v6 = tx_leave((uint64_t)a1, v19, (v14 < 0x3E8) | (4 * (v14 < 0x7D0)));
    obj_lock((uint64_t)v20, 2);
    v4 = v20;
    if (v6)
      goto LABEL_37;
    if (*((_DWORD *)v20 + 99))
    {
      v13 = 0;
      v6 = 0;
      goto LABEL_41;
    }
  }
  v6 = record;
  v13 = 1;
  v4 = v20;
LABEL_41:
  *((_DWORD *)v4 + 98) = 0;
  obj_unlock((uint64_t)v4, 2);
  obj_release((uint64_t *)v20);
  if (v13)
    tx_leave((uint64_t)a1, v19, 0);
  if (v6 | v5)
    return v6;
  else
    return 2;
}

void nx_reaper_shut_down(_QWORD *a1)
{
  char *v2;
  uint64_t *v3;
  char *v4;

  v4 = 0;
  if (!nx_reaper_get(a1, &v4))
  {
    obj_lock((uint64_t)v4, 2);
    v2 = v4;
    ++*((_DWORD *)v4 + 99);
    obj_unlock((uint64_t)v2, 2);
    v3 = (uint64_t *)a1[53];
    if (v3)
    {
      obj_release(v3);
      a1[53] = 0;
    }
    obj_release((uint64_t *)v4);
  }
}

uint64_t extent_list_key_cmp(uint64_t a1, _QWORD *a2, int a3, _QWORD *a4, int a5, int *a6)
{
  uint64_t result;
  int v7;

  result = 22;
  if (a3 == 8 && a5 == 8)
  {
    result = 0;
    v7 = *a2 > *a4;
    if (*a2 < *a4)
      v7 = -1;
    *a6 = v7;
  }
  return result;
}

uint64_t nx_metadata_fragmented_extent_list_tree_get(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t i;
  char *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;

  if (!a2)
    return 22;
  for (i = 432; i != 464; i += 8)
  {
    v7 = *(char **)(a1 + i);
    if (v7 && obj_oid(*(_QWORD *)(a1 + i)) == a2)
    {
      obj_retain(v7);
      v12 = 0;
      *a3 = (uint64_t)v7;
      return v12;
    }
  }
  obj_lock(a1, 2);
  v8 = 0;
  v9 = -1;
  do
  {
    v10 = a1 + 8 * v8;
    v11 = *(char **)(v10 + 432);
    if (v11)
    {
      if (obj_oid(*(_QWORD *)(v10 + 432)) == a2)
      {
        obj_retain(v11);
        *a3 = (uint64_t)v11;
        obj_unlock(a1, 2);
        return 0;
      }
    }
    else if (v9 == -1)
    {
      v9 = v8;
    }
    ++v8;
  }
  while (v8 != 4);
  if (a2 < 0)
  {
    v12 = btree_get(a1, 0x88000000, a2 & 0x7FFFFFFFFFFFFFFFLL, 0, 0, 0, 10, (uint64_t)extent_list_key_cmp, 0, a3);
  }
  else
  {
    v12 = btree_get(a1, 0x40000000u, a2, 0, 0, 0, 10, (uint64_t)extent_list_key_cmp, 0, a3);
    if (!(_DWORD)v12 && v9 != -1)
    {
      *(_QWORD *)(a1 + 8 * v9 + 432) = *a3;
      obj_retain((char *)*a3);
      v12 = 0;
    }
  }
  obj_unlock(a1, 2);
  return v12;
}

uint64_t nx_metadata_fragmented_sanity_check(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  char *v12;
  _OWORD v13[4];
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t *v18;

  v18 = 0;
  v15 = 0;
  v16 = 0;
  v14 = 0;
  memset(v13, 0, sizeof(v13));
  v5 = nx_metadata_fragmented_extent_list_tree_get(a1, a2, (uint64_t *)&v18);
  if (!(_DWORD)v5)
  {
    v17 = 0;
    bt_iterator_init((uint64_t)v13, (uint64_t)v18, 0, 0, &v17, 8, 8u, &v15, 0x10u);
    v5 = v6;
    if (!(_DWORD)v6)
    {
      v8 = 0;
      while (!bt_iterator_ended((uint64_t)v13))
      {
        if (v17 == v8)
          v5 = 0;
        else
          v5 = nx_corruption_detected_int(a1);
        if (nx_superblock_sanity_check_extent(*(_QWORD *)(a1 + 376), 0, v15, v16, 0))
          v5 = nx_corruption_detected_int(a1);
        v9 = v16;
        if (v16 > (unint64_t)a3 - v8)
        {
          v5 = nx_corruption_detected_int(a1);
          v9 = v16;
        }
        if ((_DWORD)v5)
          goto LABEL_3;
        v8 += v9;
        v10 = bt_iterator_next((uint64_t)v13);
        if ((_DWORD)v10)
        {
          v5 = v10;
          v11 = (const char *)(*(_QWORD *)(a1 + 384) + 208);
          v12 = strerror(v10);
          log_err("%s:%d: %s failed to get next extent in metadata fragmented extent list tree, error %s(%d)\n", "nx_metadata_fragmented_sanity_check", 2445, v11, v12, v5);
          goto LABEL_3;
        }
      }
      if (a3 == v8)
        v5 = 0;
      else
        v5 = nx_corruption_detected_int(a1);
    }
LABEL_3:
    obj_release(v18);
  }
  return v5;
}

uint64_t nx_metadata_fragmented_block_address_lookup(uint64_t a1, uint64_t a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;

  v16 = 0;
  v13 = 0;
  v14 = 0;
  v8 = nx_metadata_fragmented_extent_list_tree_get(a1, a2, &v16);
  if (!(_DWORD)v8)
  {
    v15 = a3;
    v11 = 16;
    v12 = 8;
    v8 = bt_lookup_variant(v16, 0, &v15, &v12, 8u, &v13, &v11, 1u, 0, 0);
    if (!(_DWORD)v8)
    {
      v9 = v14 - (a3 - v15);
      if (v14 <= a3 - v15)
      {
        v8 = 2;
      }
      else
      {
        *a4 = v13 + a3 - v15;
        v8 = 0;
        if (a5)
          *a5 = v9;
      }
    }
    obj_release(v16);
  }
  return v8;
}

uint64_t nx_metadata_range_overlap_check(_QWORD *a1, unint64_t a2, unint64_t a3, unint64_t *a4)
{
  uint64_t v8;
  uint64_t result;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;

  v8 = a1[60];
  if (!v8)
  {
    v13 = 0;
    v14 = 0;
    v15 = a2;
    v12 = 8;
    v11 = 16;
    LODWORD(result) = bt_lookup_variant(a1[58], 0, &v15, &v12, 8u, &v13, &v11, 1u, 0, 0);
    if ((_DWORD)result || (v10 = v15, a2 - v15 >= v14))
    {
      if ((_DWORD)result == 2)
        result = 0;
      else
        result = result;
      if (a3 < 2 || (_DWORD)result)
        return result;
      v15 = a2;
      v11 = 16;
      v12 = 8;
      LODWORD(result) = bt_lookup_variant(a1[58], 0, &v15, &v12, 8u, &v13, &v11, 4u, 0, 0);
      if ((_DWORD)result || (v10 = v15, v15 - a2 >= a3))
      {
        if ((_DWORD)result == 2)
          return 0;
        else
          return result;
      }
    }
    if (a4)
      *a4 = v10;
    return 17;
  }
  if (calc_overlap_range(a1[59], v8, a2, a3, a4))
    return 17;
  if ((((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(a1[47] + 36)))) & a2) == 0)
  {
    if (a4)
      *a4 = a2;
    return 17;
  }
  return 0;
}

uint64_t nx_metadata_range_add(_QWORD *a1, unint64_t a2, int a3, char a4, int a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  char *v12;
  _OWORD v13[4];
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t *v18;

  if ((a4 & 1) == 0)
    return nx_metadata_range_check_and_insert(a1, a2, a3 & 0x7FFFFFFF, a5);
  v18 = 0;
  v15 = 0;
  v16 = 0;
  memset(v13, 0, sizeof(v13));
  v14 = 0;
  v6 = nx_metadata_fragmented_extent_list_tree_get((uint64_t)a1, a2, (uint64_t *)&v18);
  if (!(_DWORD)v6)
  {
    v7 = btree_iterate_nodes((uint64_t)v18, 0, 0, (uint64_t (*)(void))nx_metadata_range_add_btree_callback, 0, 0);
    if (!(_DWORD)v7)
    {
      v17 = 0;
      bt_iterator_init((uint64_t)v13, (uint64_t)v18, 0, 0, &v17, 8, 8u, &v15, 0x10u);
      v6 = v9;
      if (bt_iterator_ended((uint64_t)v13))
        goto LABEL_7;
      while (1)
      {
        v7 = nx_metadata_range_check_and_insert(a1, v15, v16, 0);
        if ((_DWORD)v7)
          break;
        v10 = bt_iterator_next((uint64_t)v13);
        if ((_DWORD)v10)
        {
          v6 = v10;
          v11 = (const char *)(a1[48] + 208);
          v12 = strerror(v10);
          log_err("%s:%d: %s failed to get next extent in metadata fragmented extent list tree, error %s(%d)\n", "nx_metadata_range_add", 2681, v11, v12, v6);
          goto LABEL_7;
        }
        if (bt_iterator_ended((uint64_t)v13))
        {
          v6 = 0;
          goto LABEL_7;
        }
      }
    }
    v6 = v7;
LABEL_7:
    obj_release(v18);
  }
  return v6;
}

uint64_t nx_metadata_range_check_and_insert(_QWORD *a1, unint64_t a2, unint64_t a3, int a4)
{
  uint64_t result;
  _QWORD v8[2];
  unint64_t v9;

  if (nx_superblock_sanity_check_extent(a1[47], 0, a2, a3, a4))
    return 22;
  if (a1[58])
  {
    result = nx_metadata_range_overlap_check(a1, a2, a3, 0);
    if ((_DWORD)result)
      return result;
    goto LABEL_5;
  }
  result = btree_create((uint64_t)a1, 0x88000000, 0, 10, 0, 8u, 16, (uint64_t)extent_list_key_cmp, 0, a1 + 58);
  if (!(_DWORD)result)
  {
LABEL_5:
    v8[1] = a3;
    v9 = a2;
    v8[0] = a2;
    return bt_insert((_QWORD *)a1[58], 0, &v9, 8, v8, 0x10u, 0);
  }
  return result;
}

uint64_t nx_metadata_range_add_btree_callback(uint64_t a1)
{
  _QWORD *v2;
  unint64_t v3;
  unint64_t v4;

  v2 = *(_QWORD **)(*(_QWORD *)a1 + 392);
  v3 = obj_oid(a1);
  v4 = (obj_size_phys(a1) + *(_DWORD *)(v2[47] + 36) - 1) / *(_DWORD *)(v2[47] + 36);
  return nx_metadata_range_check_and_insert(v2, v3, v4, 0);
}

const char *nx_metadata_range_optimize(const char *result)
{
  uint64_t v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _OWORD v6[4];
  uint64_t v7;
  unint64_t v8[3];
  __int128 v9;
  unint64_t v10;

  *((_QWORD *)result + 59) = 0;
  *((_QWORD *)result + 60) = 0;
  v1 = *((_QWORD *)result + 58);
  if (v1)
  {
    v2 = result;
    v9 = 0uLL;
    memset(v6, 0, sizeof(v6));
    v7 = 0;
    *(_OWORD *)v8 = 0uLL;
    v10 = 0;
    bt_iterator_init((uint64_t)v6, v1, 0, 0, &v10, 8, 8u, &v9, 0x10u);
    result = (const char *)bt_iterator_ended((uint64_t)v6);
    if (!(_DWORD)result)
    {
      v3 = 0;
      while (1)
      {
        v4 = *((_QWORD *)&v9 + 1);
        v5 = v9;
        if ((((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(*((_QWORD *)v2 + 47) + 36)))) & (unint64_t)v9) != 0)
        {
          if (*((_QWORD *)&v9 + 1))
            goto LABEL_9;
        }
        else
        {
          v5 = v9 + 1;
          v4 = *((_QWORD *)&v9 + 1) - 1;
          *(_QWORD *)&v9 = v9 + 1;
          *((_QWORD *)&v9 + 1) = v4;
          if (v4)
          {
LABEL_9:
            if (v8[1] && v8[0] + v8[1] == v5)
            {
              v8[1] += v4;
              if (bt_update(*((uint64_t **)v2 + 58), 0, v8, 8, v8, 0x10u, 0))
                return log_err("%s:%d: %s error updating metadata ranges tree: %d\n");
              if (bt_remove(*((_QWORD *)v2 + 58), 0, (unint64_t *)&v9, 8u, 0))
                return log_err("%s:%d: %s error removing coalesced extent from metadata ranges tree: %d\n");
            }
            else
            {
              ++v3;
              *(_OWORD *)v8 = v9;
            }
          }
        }
        bt_iterator_next((uint64_t)v6);
        result = (const char *)bt_iterator_ended((uint64_t)v6);
        if ((_DWORD)result)
        {
          if (v3 == 1)
            *(_OWORD *)(v2 + 472) = *(_OWORD *)v8;
          return result;
        }
      }
    }
  }
  return result;
}

uint64_t nx_checkpoint_desc_block_address(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  uint64_t v7;
  uint64_t result;

  v3 = *(_QWORD *)(a1 + 376);
  v4 = *(_DWORD *)(v3 + 104);
  if ((v4 & 0x7FFFFFFFu) <= a2)
    return 22;
  v7 = *(_QWORD *)(v3 + 112);
  if (v4 < 0)
    return nx_metadata_fragmented_block_address_lookup(a1, v7, a2, a3, 0);
  result = 0;
  *a3 = v7 + a2;
  return result;
}

uint64_t nx_checkpoint_data_block_address(uint64_t a1, unint64_t a2, _QWORD *a3, unint64_t *a4)
{
  uint64_t v4;
  int v5;
  unint64_t v6;
  uint64_t v10;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 376);
  v5 = *(_DWORD *)(v4 + 108);
  v6 = (v5 & 0x7FFFFFFF) - a2;
  if ((v5 & 0x7FFFFFFFu) <= a2)
    return 22;
  v10 = *(_QWORD *)(v4 + 120);
  if (v5 < 0)
    return nx_metadata_fragmented_block_address_lookup(a1, v10, a2, a3, a4);
  *a3 = v10 + a2;
  result = 0;
  if (a4)
    *a4 = v6;
  return result;
}

uint64_t nx_unblock_physical_range(_QWORD *a1)
{
  uint64_t v2;
  uint64_t evict_mapping_tree;
  uint64_t v4;
  int v5;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;

  if (!*(_QWORD *)(a1[47] + 1256))
  {
LABEL_8:
    v9 = 0;
    v2 = tx_enter((uint64_t)a1, &v9);
    if ((_DWORD)v2)
      return v2;
    v4 = spaceman_unset_block_out_range(a1, v9);
    if (!(_DWORD)v4)
      return tx_leave((uint64_t)a1, v9, 0);
    v2 = v4;
    log_err("%s:%d: %s spaceman_unset_block_out_range failed with error %u\n");
    goto LABEL_11;
  }
  v8 = 0;
  v9 = 0;
  v7 = 0;
  v2 = tx_enter((uint64_t)a1, &v9);
  if ((_DWORD)v2)
    return v2;
  evict_mapping_tree = nx_get_evict_mapping_tree((uint64_t)a1, 0x40000000u, *(_QWORD *)(a1[47] + 1256), 1, 1, (uint64_t *)&v8);
  if ((_DWORD)evict_mapping_tree)
  {
    v2 = evict_mapping_tree;
    log_err("%s:%d: %s failed to get mapping tree, error: %d\n", "nx_unblock_physical_range", 3023, (const char *)(a1[48] + 208), evict_mapping_tree);
    goto LABEL_11;
  }
  v2 = btree_delete((uint64_t)v8, v9, &v7);
  obj_release(v8);
  if (!(_DWORD)v2)
  {
    *(_QWORD *)(a1[47] + 1256) = 0;
    v2 = tx_leave((uint64_t)a1, v9, 0);
    if ((_DWORD)v2)
      return v2;
    goto LABEL_8;
  }
  log_err("%s:%d: %s failed to delete mapping, error: %d\n");
LABEL_11:
  v5 = tx_leave((uint64_t)a1, v9, 0);
  if (v5)
    log_err("%s:%d: %s tx_leave failed with error: %d\n", "nx_unblock_physical_range", 3067, (const char *)(a1[48] + 208), v5);
  return v2;
}

uint64_t nx_ratelimit_log_allowed(uint64_t a1)
{
  uint64_t timestamp;
  unint64_t v3;

  if (!a1)
    return 1;
  timestamp = get_timestamp();
  if ((unint64_t)(timestamp - *(_QWORD *)(a1 + 1792)) >= 0x3B9ACA01)
  {
    v3 = 0;
    *(_QWORD *)(a1 + 1792) = timestamp;
LABEL_6:
    *(_QWORD *)(a1 + 1800) = v3 + 1;
    return 1;
  }
  v3 = *(_QWORD *)(a1 + 1800);
  if (v3 <= 0xF)
    goto LABEL_6;
  return 0;
}

uint64_t nx_reaper_next_record(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  _DWORD *v14;
  int v15;
  _DWORD *v16;
  int v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t *v22;
  uint64_t *v23;

  v4 = *(_QWORD *)(a2 + 376);
  v5 = *(_QWORD *)(v4 + 48);
  if (!v5)
    return 0;
  v22 = 0;
  v23 = 0;
  v8 = obj_get(*(_QWORD *)(a1 + 392), 0x80000001, v5, (int *)&nx_reap_list_desc, 0, 0, 0, a3, (uint64_t *)&v23);
  if ((_DWORD)v8)
  {
    v9 = v8;
    log_err("%s:%d: %s failed to get reap list head: %d\n", "nx_reaper_next_record", 1691, (const char *)(*(_QWORD *)(a1 + 384) + 208), v8);
    return v9;
  }
  v10 = v23;
  if (*(_QWORD *)(v4 + 88))
  {
LABEL_21:
    obj_release(v10);
    return 0;
  }
  v11 = v23[47];
  while (1)
  {
    while (1)
    {
      v12 = *(_DWORD *)(v11 + 52);
      if (v12 == -1)
        break;
      v13 = v11 + 40 * v12;
      v14 = (_DWORD *)(v13 + 68);
      *(_DWORD *)(v4 + 104) = *(_DWORD *)(v13 + 68);
      *(_QWORD *)(v4 + 72) = *(_QWORD *)(v13 + 72);
      *(_OWORD *)(v4 + 80) = *(_OWORD *)(v13 + 80);
      *(_QWORD *)(v4 + 96) = *(_QWORD *)(v13 + 96);
      obj_dirty(a2, a3, 0);
      v17 = *(_DWORD *)(v13 + 64);
      v16 = (_DWORD *)(v13 + 64);
      v15 = v17;
      if (*(_DWORD *)(v11 + 52) == *(_DWORD *)(v11 + 56))
        *(_DWORD *)(v11 + 56) = v15;
      *v14 = 0;
      *v16 = *(_DWORD *)(v11 + 60);
      *(_DWORD *)(v11 + 60) = v12;
      --*(_DWORD *)(v11 + 48);
      *(_DWORD *)(v11 + 52) = v15;
      obj_dirty((uint64_t)v23, a3, 0);
      if (*(_QWORD *)(v4 + 88))
        goto LABEL_20;
    }
    v18 = *(_QWORD *)(v11 + 32);
    if (!v18)
    {
      if (!*(_DWORD *)(v4 + 68) && *(_QWORD *)(v4 + 48) == *(_QWORD *)(v4 + 56))
      {
        *(_DWORD *)(v4 + 68) = 1;
        obj_dirty(a2, a3, 0);
      }
LABEL_20:
      v10 = v23;
      goto LABEL_21;
    }
    v19 = obj_get(*(_QWORD *)(a1 + 392), 0x80000000, v18, (int *)&nx_reap_list_desc, 0, 0, 0, a3, (uint64_t *)&v22);
    if ((_DWORD)v19)
      break;
    *(_QWORD *)(v4 + 48) = *(_QWORD *)(v11 + 32);
    v20 = *(_DWORD *)(v4 + 68);
    if (v20)
      *(_DWORD *)(v4 + 68) = v20 - 1;
    obj_dirty(a2, a3, 0);
    obj_free((uint64_t)v23);
    obj_release(v23);
    v10 = v22;
    v22 = 0;
    v23 = v10;
    v11 = v10[47];
    if (*(_QWORD *)(v4 + 88))
      goto LABEL_21;
  }
  v9 = v19;
  obj_release(v23);
  return v9;
}

uint64_t spaceman_free_extent_cache_init(uint64_t a1, uint64_t a2, unsigned __int8 a3, unsigned int a4, char *a5)
{
  size_t v5;
  uint64_t result;
  void *v11;

  if (a4)
    v5 = a4;
  else
    v5 = 0x10000;
  if ((v5 - 65537) < 0xFFFF0001)
    return 22;
  bzero(a5, 0x558uLL);
  if (!a1 || (result = new_lock((pthread_mutex_t *)(a5 + 16)), !(_DWORD)result))
  {
    *(_QWORD *)a5 = a1;
    *((_QWORD *)a5 + 1) = a2;
    *((_DWORD *)a5 + 22) = a3 | ((_DWORD)v5 << 8);
    v11 = _apfs_calloc(v5, 0x18uLL);
    *((_QWORD *)a5 + 10) = v11;
    if (v11)
    {
      spaceman_free_extent_cache_table_init((uint64_t)a5);
      return 0;
    }
    else
    {
      if (a1)
        free_lock((pthread_mutex_t *)(a5 + 16));
      return 12;
    }
  }
  return result;
}

uint64_t spaceman_free_extent_cache_table_init(uint64_t result)
{
  unsigned int v1;
  uint64_t v2;
  int v3;
  int v4;
  int v5;

  v1 = *(_DWORD *)(result + 88);
  if (v1 <= 0x2FF)
  {
    v5 = (v1 >> 8) - 1;
    v2 = *(_QWORD *)(result + 80);
  }
  else
  {
    v2 = *(_QWORD *)(result + 80);
    v3 = 1;
    v4 = 1;
    do
    {
      *(_QWORD *)(v2 + 24 * (unsigned __int16)v4++) = (v3 + 1);
      v3 = (unsigned __int16)v4;
      v5 = (*(_DWORD *)(result + 88) >> 8) - 1;
    }
    while (v5 > (unsigned __int16)v4);
  }
  *(_QWORD *)(v2 + 24 * v5) = 0;
  *(_WORD *)(result + 92) = 1;
  return result;
}

void spaceman_free_extent_cache_destroy(uint64_t a1)
{
  void *v2;

  if (a1)
  {
    v2 = *(void **)(a1 + 80);
    if (v2)
    {
      _apfs_free(v2, 24 * ((unint64_t)*(unsigned int *)(a1 + 88) >> 8));
      *(_QWORD *)(a1 + 80) = 0;
    }
    if (*(_QWORD *)a1)
    {
      free_lock((pthread_mutex_t *)(a1 + 16));
      *(_QWORD *)a1 = 0;
    }
  }
}

uint64_t spaceman_free_extent_cache_reset(uint64_t a1)
{
  unsigned int v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  int v6;
  const char *v7;

  v2 = *(_DWORD *)(a1 + 88);
  if (HIBYTE(v2))
  {
    v5 = *(_QWORD *)a1;
    v4 = *(_QWORD *)(a1 + 8);
    spaceman_free_extent_cache_destroy(a1);
    result = spaceman_free_extent_cache_init(v5, v4, v2, (unsigned __int16)(v2 >> 8), (char *)a1);
    if ((_DWORD)result)
    {
      v6 = *(unsigned __int8 *)(a1 + 88);
      v7 = "main";
      if (v6 == 1)
        v7 = "tier2";
      result = (uint64_t)log_err("%s:%d: %s dev %d Error reinitializing %s free extent cache: %d\n", "spaceman_free_extent_cache_reset", 262, (const char *)(*(_QWORD *)(*(_QWORD *)a1 + 384) + 208), v6, v7, result);
      *(_QWORD *)(a1 + 280) |= 2uLL;
    }
  }
  else
  {
    bzero((void *)(a1 + 92), 0x4FCuLL);
    bzero(*(void **)(a1 + 80), 24 * (unsigned __int16)(v2 >> 8));
    return spaceman_free_extent_cache_table_init(a1);
  }
  return result;
}

uint64_t spaceman_free_extent_cache_scan_should_pause(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v5;
  uint64_t v6;

  if (a2 <= 1)
    v2 = 1;
  else
    v2 = a2;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 376) + 48 * *(unsigned __int8 *)(a1 + 88) + 56) / v2 > 0x64)
    return 0;
  if (*(_QWORD *)a1)
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if ((*(_BYTE *)(a1 + 280) & 2) != 0 || (*(_DWORD *)(a1 + 88) >> 8) - 1 > *(unsigned __int16 *)(a1 + 94))
    goto LABEL_15;
  v5 = *(_QWORD *)(a1 + 176);
  if (v5 <= *(_QWORD *)(a1 + 224))
    v5 = *(_QWORD *)(a1 + 224);
  if (v5 < *(_QWORD *)(a1 + 248) || (v6 = *(_QWORD *)(a1 + 128), (unint64_t)(v6 - *(_QWORD *)(a1 + 120)) > 3))
  {
LABEL_15:
    v3 = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 328) = v6;
    v3 = 1;
  }
  if (*(_QWORD *)a1)
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  return v3;
}

void spaceman_free_extent_cache_print_stats(_QWORD *a1)
{
  uint64_t v1;
  char i;
  char v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  uint64_t *v30;

  v30 = 0;
  if (!spaceman_get(a1, (uint64_t *)&v30))
  {
    v1 = 0;
    for (i = 1; ; i = 0)
    {
      v3 = i;
      v4 = v30[47];
      v5 = *(_QWORD *)(v4 + 48 * v1 + 48);
      if (!v5)
        goto LABEL_42;
      v6 = v30[v1 + 196];
      if (!v6)
        goto LABEL_42;
      v29 = v3;
      v7 = *(_QWORD *)(v4 + 48 * v1 + 72);
      v8 = *(unsigned __int16 *)(v6 + 94);
      if (*(_QWORD *)v6)
        pthread_mutex_lock((pthread_mutex_t *)(v6 + 16));
      v9 = v6 + 1264;
      if (spaceman_fxc_tree_last(v6, v6 + 1264, 1u))
        v28 = 0;
      else
        v28 = *(_QWORD *)(*(_QWORD *)(v6 + 80)
                        + 24 * *(unsigned __int16 *)(v9 + 4 * *(unsigned __int8 *)(v6 + 1361))
                        + 8) & 0xFFFFFFFFFFFFFLL;
      if (spaceman_fxc_tree_first(v6, v6 + 1264))
      {
        v10 = 0;
        v11 = 0;
      }
      else
      {
        v27 = *(_QWORD *)(*(_QWORD *)(v6 + 80) + 24
                                               * *(unsigned __int16 *)(v9 + 4 * *(unsigned __int8 *)(v6 + 1361))) & 0xFFFFFFFFFFFFFLL;
        if (spaceman_fxc_tree_last(v6, v6 + 1264, 0))
        {
          v11 = 0;
          v10 = v27;
        }
        else
        {
          v12 = (_QWORD *)(*(_QWORD *)(v6 + 80)
                         + 24 * *(unsigned __int16 *)(v9 + 4 * *(unsigned __int8 *)(v6 + 1361)));
          v10 = v27;
          v11 = (*v12 & 0xFFFFFFFFFFFFFLL) - v27 + (v12[1] & 0xFFFFFFFFFFFFFLL);
        }
      }
      v13 = *(_QWORD *)(v6 + 96);
      if (v13 <= 1)
        v14 = 1;
      else
        v14 = *(_QWORD *)(v6 + 96);
      if (v7)
        v15 = v7;
      else
        v15 = v14;
      if ((_DWORD)v8)
        v16 = v13 / v8;
      else
        v16 = 0;
      log_info("%s:%d: %s dev %d smfree %lld/%lld table %d/%d blocks %lld %lld:%lld:%lld %d.%02d%% range %lld:%lld %d.%02d%% scans %lld\n", "spaceman_fxc_print_stats", 477, (const char *)(*(_QWORD *)(*(_QWORD *)v6 + 384) + 208), *(_DWORD *)(v6 + 88), v7, v5, v8, (*(_DWORD *)(v6 + 88) >> 8) - 1, v13, *(_QWORD *)(v6 + 120), v16, v28, 10000 * v13 / v15 / 0x64, 10000 * v13 / v15 % 0x64, v10, v11, 10000 * v11 / v5 / 0x64, 10000 * v11 / v5 % 0x64,
        *(_QWORD *)(v6 + 336));
      v17 = (_QWORD *)(v6 + 272);
      v18 = 3;
      do
      {
        v19 = *(v17 - 4);
        if (v19)
        {
          if (v7)
            v20 = v7;
          else
            v20 = *(v17 - 4);
          v21 = *(v17 - 5);
          if (v21)
            v22 = v19 / v21;
          else
            v22 = 0;
          log_info("%s:%d: %s dev %d scan_stats[%d]: foundmax %lld extents %lld blocks %lld long %lld avg %lld %d.%02d%% range %lld:%lld %d.%02d%%\n", "spaceman_fxc_print_stats", 496, (const char *)(*(_QWORD *)(*(_QWORD *)v6 + 384) + 208), *(unsigned __int8 *)(v6 + 88), v18 - 1, *v17, v21, v19, *(v17 - 3), v22, 10000 * v19 / v20 / 0x64, 10000 * v19 / v20 % 0x64, *(v17 - 2), *(v17 - 1), 10000 * *(v17 - 1) / v5 / 0x64, 10000 * *(v17 - 1) / v5 % 0x64);
        }
        v17 -= 6;
        --v18;
      }
      while (v18);
      v23 = *(_QWORD *)(v6 + 344);
      v24 = *(_QWORD *)v6;
      if (v23)
      {
        log_info("%s:%d: %s dev %d Searches: %lld success %lld fail %lld partial %lld, bm search yes:%lld (%lld/%lld/%lld) no:%lld/%lld\n", "spaceman_fxc_print_stats", 509, (const char *)(*(_QWORD *)(v24 + 384) + 208), *(unsigned __int8 *)(v6 + 88), v23, *(_QWORD *)(v6 + 352), *(_QWORD *)(v6 + 424), *(_QWORD *)(v6 + 416), *(_QWORD *)(v6 + 448), *(_QWORD *)(v6 + 456), *(_QWORD *)(v6 + 464), *(_QWORD *)(v6 + 472), *(_QWORD *)(v6 + 432), *(_QWORD *)(v6 + 440));
        v25 = *(_QWORD *)(v6 + 360);
        v3 = v29;
        if (v25)
          v26 = *(_QWORD *)(v6 + 368) / v25;
        else
          v26 = 0;
        log_info("%s:%d: %s dev %d Remainders: zero %lld one %lld tiny %lld small %lld good %lld, total %lld blocks %lld avg %lld\n", "spaceman_fxc_print_stats", 515, (const char *)(*(_QWORD *)(*(_QWORD *)v6 + 384) + 208), *(unsigned __int8 *)(v6 + 88), *(_QWORD *)(v6 + 408), *(_QWORD *)(v6 + 400), *(_QWORD *)(v6 + 392), *(_QWORD *)(v6 + 384), *(_QWORD *)(v6 + 376), v25, *(_QWORD *)(v6 + 368), v26);
        if (!*(_QWORD *)v6)
          goto LABEL_42;
      }
      else
      {
        v3 = v29;
        if (!v24)
          goto LABEL_42;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 16));
LABEL_42:
      v1 = 1;
      if ((v3 & 1) == 0)
      {
        obj_release(v30);
        return;
      }
    }
  }
}

uint64_t spaceman_free_extent_cache_setup(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char i;
  char v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = 0;
  for (i = 1; ; i = 0)
  {
    v6 = i;
    v7 = a2 + 8 * v4;
    if (!*(_QWORD *)(v7 + 1568))
    {
      v8 = *(_QWORD *)(*(_QWORD *)(a2 + 376) + 48 * v4 + 48);
      if (v8)
      {
        v9 = v7 + 1568;
        v10 = (char *)_apfs_calloc(1uLL, 0x558uLL);
        *(_QWORD *)v9 = v10;
        if (!v10)
        {
          v13 = 12;
          goto LABEL_13;
        }
        v11 = v8 >> 18;
        if (v8 >> 18 >= 0xFF80)
          LODWORD(v11) = 65408;
        v12 = spaceman_free_extent_cache_init(a1, a2, v4, (int)v11 + 128, v10);
        if ((_DWORD)v12)
          break;
      }
    }
    v4 = 1;
    if ((v6 & 1) == 0)
      return 0;
  }
  v13 = v12;
  if (*(_QWORD *)v9)
    *(_QWORD *)(*(_QWORD *)v9 + 280) |= 2uLL;
LABEL_13:
  log_err("%s:%d: %s failed to initialize free extent cache for device %d, error %d\n", "spaceman_free_extent_cache_setup", 1556, (const char *)(*(_QWORD *)(a1 + 384) + 208), v4, v13);
  return v13;
}

uint64_t spaceman_free_extent_cache_insert(unint64_t a1, int a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  uint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t updated;
  _QWORD *v17;
  unint64_t v18;
  int v19;
  int v20;
  _OWORD *v21;
  int v23;
  _OWORD *v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  unsigned int v28;
  _QWORD *v29;
  uint64_t v30;
  unint64_t v31;
  int v32;
  unint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  uint64_t v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  unint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  uint64_t v61;
  unsigned int v62;
  unint64_t *v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t *v69;
  unint64_t v70;
  uint64_t v71;
  unsigned int v72;
  unint64_t v73;
  unsigned __int16 v74;

  if (!a1)
    return 22;
  v4 = a4;
  if ((a4 | a3) >> 52)
    return 84;
  if (!a4)
    return 0;
  if (*(_QWORD *)a1)
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v8 = *(_QWORD *)(a1 + 280);
  if ((v8 & 2) == 0)
  {
    v9 = a1 + 48 * ((v8 & 4) == 0);
    v11 = *(_QWORD *)(v9 + 176);
    v10 = (unint64_t *)(v9 + 176);
    if (v11 < v4)
      *v10 = v4;
    v74 = 0;
    v12 = spaceman_fxc_tree_node_recycle_smallest_if_full(a1, v4, a3);
    if (v12 == 55)
    {
      v13 = a1 + 16 * (a2 ^ 1u);
      v14 = *(_QWORD *)(v13 + 296);
      if (v14)
      {
        if (v14 < a3 && v4 + a3 < *(_QWORD *)(v13 + 304))
        {
          v15 = (uint64_t *)(v13 + 296);
          spaceman_fxc_dropped(a1, a3, v4);
          updated = 0;
          *v15 = a3;
          goto LABEL_28;
        }
      }
    }
    v17 = *(_QWORD **)a1;
    v18 = a3;
    if (*(_BYTE *)(a1 + 88) == 1)
      v18 = (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v17[47] + 36)))) | a3;
    v19 = spaceman_extent_check(v17, *(_QWORD *)(a1 + 8), v18, v4);
    if (v19)
    {
      v20 = v19;
      if (nx_ratelimit_log_allowed(*(_QWORD *)a1))
        log_err("%s:%d: %s dev %d free extent %lld:%lld appears to span container metadata and should not be free: %d\n", "spaceman_free_extent_cache_insert", 1648, (const char *)(*(_QWORD *)(*(_QWORD *)a1 + 384) + 208), *(unsigned __int8 *)(a1 + 88), a3, v4, v20);
      goto LABEL_25;
    }
    v21 = (_OWORD *)(a1 + 1068);
    updated = spaceman_fxc_tree_search(a1, 0, a3, v4, a1 + 1068);
    if ((_DWORD)updated)
      goto LABEL_27;
    v23 = *((unsigned __int16 *)v21 + 2 * *(unsigned __int8 *)(a1 + 1165));
    v24 = (_OWORD *)(a1 + 1166);
    v25 = *(_OWORD *)(a1 + 1148);
    *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
    *(_OWORD *)(a1 + 1246) = v25;
    *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
    v26 = *(_OWORD *)(a1 + 1084);
    *(_OWORD *)(a1 + 1166) = *v21;
    *(_OWORD *)(a1 + 1182) = v26;
    v27 = *(_OWORD *)(a1 + 1116);
    *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
    *(_OWORD *)(a1 + 1214) = v27;
    if (v23)
    {
      updated = 0;
    }
    else
    {
      v48 = spaceman_fxc_tree_adjacent(a1, a1 + 1166, -1);
      updated = v48;
      if ((v48 & 0xFFFFFFFD) != 0)
        goto LABEL_27;
      if ((_DWORD)v48 == 2)
      {
        updated = 2;
        goto LABEL_34;
      }
    }
    v28 = *((unsigned __int16 *)v24 + 2 * *(unsigned __int8 *)(a1 + 1263));
    v29 = (_QWORD *)(*(_QWORD *)(a1 + 80) + 24 * *((unsigned __int16 *)v24 + 2 * *(unsigned __int8 *)(a1 + 1263)));
    v30 = *v29 & 0xFFFFFFFFFFFFFLL;
    v31 = v29[1] & 0xFFFFFFFFFFFFFLL;
    if (v31 + v30 >= a3)
    {
      v4 = v4 + a3 - v30;
      v49 = *(_OWORD *)(a1 + 1246);
      *(_OWORD *)(a1 + 1132) = *(_OWORD *)(a1 + 1230);
      *(_OWORD *)(a1 + 1148) = v49;
      *(_WORD *)(a1 + 1164) = *(_WORD *)(a1 + 1262);
      v50 = *(_OWORD *)(a1 + 1182);
      *v21 = *v24;
      *(_OWORD *)(a1 + 1084) = v50;
      v51 = *(_OWORD *)(a1 + 1214);
      *(_OWORD *)(a1 + 1100) = *(_OWORD *)(a1 + 1198);
      *(_OWORD *)(a1 + 1116) = v51;
      if (v4 <= v31)
      {
        if ((_DWORD)updated)
        {
          updated = 1;
          goto LABEL_27;
        }
        goto LABEL_28;
      }
      updated = spaceman_fxc_update_length(a1, v30, v31, v4, v28);
      if ((_DWORD)updated)
        goto LABEL_27;
      v52 = a1 + 48 * ((*(_DWORD *)(a1 + 280) & 4) == 0);
      v54 = *(_QWORD *)(v52 + 176);
      v53 = (unint64_t *)(v52 + 176);
      if (v54 < v4)
        *v53 = v4;
      spaceman_fxc_insert_invalidate_last_unwanted_ranges_if_needed(a1, v30, v4);
      updated = 0;
LABEL_35:
      v32 = *(char *)(a1 + 1165);
      if (v32 < 0 || *((_WORD *)v21 + 2 * *(unsigned __int8 *)(a1 + 1165)))
      {
        if (!(_DWORD)updated)
        {
LABEL_38:
          v72 = *((unsigned __int16 *)v21 + 2 * v32);
          v73 = v4 + v30;
          v33 = v4;
          while (1)
          {
            v34 = *(_OWORD *)(a1 + 1148);
            *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
            *(_OWORD *)(a1 + 1246) = v34;
            *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
            v35 = *(_OWORD *)(a1 + 1084);
            *v24 = *v21;
            *(_OWORD *)(a1 + 1182) = v35;
            v36 = *(_OWORD *)(a1 + 1116);
            *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
            *(_OWORD *)(a1 + 1214) = v36;
            v37 = spaceman_fxc_tree_adjacent(a1, a1 + 1166, 1);
            if ((_DWORD)v37)
              break;
            v38 = *((unsigned __int16 *)v24 + 2 * *(unsigned __int8 *)(a1 + 1263));
            v39 = *(_QWORD *)(a1 + 80);
            v40 = *(_QWORD *)(v39 + 24 * *((unsigned __int16 *)v24 + 2 * *(unsigned __int8 *)(a1 + 1263))) & 0xFFFFFFFFFFFFFLL;
            if (v73 < v40)
              goto LABEL_68;
            v41 = v30;
            v42 = *(_QWORD *)(v39 + 24 * *((unsigned __int16 *)v24 + 2 * *(unsigned __int8 *)(a1 + 1263)) + 8) & 0xFFFFFFFFFFFFFLL;
            if (v42 + v40 >= v73)
              v43 = v42 + v40 - v73;
            else
              v43 = 0;
            spaceman_fxc_tree_delete_at_path(a1, a1 + 1166);
            v44 = spaceman_fxc_tree_search(a1, 1u, v40, v42, a1 + 1068);
            if ((_DWORD)v44)
            {
              v61 = v44;
LABEL_74:
              log_err("%s:%d: %s dev %d Failed to find successor node in length tree: %d\n", "spaceman_free_extent_cache_insert", 1852, (const char *)(*(_QWORD *)(*(_QWORD *)a1 + 384) + 208), *(unsigned __int8 *)(a1 + 88), v61);
              updated = v61;
              goto LABEL_27;
            }
            if (!*((_WORD *)v21 + 2 * *(unsigned __int8 *)(a1 + 1165)))
            {
              v61 = 2;
              goto LABEL_74;
            }
            if (v40 == *(_QWORD *)(a1 + 112))
            {
              v45 = *(_OWORD *)(a1 + 1148);
              *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
              *(_OWORD *)(a1 + 1246) = v45;
              *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
              v46 = *(_OWORD *)(a1 + 1084);
              *v24 = *v21;
              *(_OWORD *)(a1 + 1182) = v46;
              v47 = *(_OWORD *)(a1 + 1116);
              *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
              *(_OWORD *)(a1 + 1214) = v47;
              spaceman_fxc_update_smallest_with_successor(a1, a1 + 1166);
            }
            v33 += v43;
            spaceman_fxc_tree_delete_at_path(a1, a1 + 1068);
            spaceman_fxc_tree_node_free(a1, v38);
            v30 = v41;
            updated = spaceman_fxc_tree_search(a1, 0, v41, v4, a1 + 1068);
            if ((_DWORD)updated)
              goto LABEL_27;
          }
          updated = v37;
          if ((_DWORD)v37 != 2)
            goto LABEL_27;
LABEL_68:
          if (v33 <= v4)
            goto LABEL_25;
          updated = spaceman_fxc_update_length(a1, v30, v4, v33, v72);
          if (!(_DWORD)updated)
          {
            v58 = a1 + 48 * ((*(_DWORD *)(a1 + 280) & 4) == 0);
            v60 = *(_QWORD *)(v58 + 176);
            v59 = (unint64_t *)(v58 + 176);
            if (v60 >= v33)
              goto LABEL_25;
            updated = 0;
            *v59 = v33;
            goto LABEL_28;
          }
          goto LABEL_27;
        }
        goto LABEL_27;
      }
      if (v12 != 55)
      {
        v74 = 0;
        updated = spaceman_fxc_tree_insert_at_path(a1, v30, v4, &v74, a1 + 1068);
        if (!(_DWORD)updated)
        {
          v57 = spaceman_fxc_tree_insert(a1, 1u, v30, v4, &v74);
          if ((_DWORD)v57)
          {
            updated = v57;
            if (!spaceman_fxc_tree_delete(a1, v30, v4))
              spaceman_fxc_tree_node_free(a1, v74);
          }
          else
          {
            v71 = *(_QWORD *)(a1 + 120);
            if (v71 - 1 >= v4 || v4 == v71 && v30 > *(_QWORD *)(a1 + 112))
            {
              *(_QWORD *)(a1 + 112) = v30;
              *(_QWORD *)(a1 + 120) = v4;
            }
            if (v4 > *(_QWORD *)(a1 + 128))
              *(_QWORD *)(a1 + 128) = v4;
            updated = spaceman_fxc_tree_search(a1, 0, v30, v4, a1 + 1068);
            spaceman_fxc_insert_invalidate_last_unwanted_ranges_if_needed(a1, v30, v4);
            LOBYTE(v32) = *(_BYTE *)(a1 + 1165);
            if (!(_DWORD)updated)
              goto LABEL_38;
          }
        }
LABEL_27:
        log_err("%s:%d: %s dev %d Error %d, reinitializing\n", "spaceman_free_extent_cache_insert", 1881, (const char *)(*(_QWORD *)(*(_QWORD *)a1 + 384) + 208), *(unsigned __int8 *)(a1 + 88), updated);
        spaceman_free_extent_cache_reset(a1);
        goto LABEL_28;
      }
      v55 = spaceman_fxc_tree_adjacent(a1, a1 + 1068, 1);
      if ((_DWORD)v55)
      {
        updated = v55;
        v56 = 0x7FFFFFFFFFFFFFFFLL;
        goto LABEL_77;
      }
      v62 = *((unsigned __int16 *)v21 + 2 * *(unsigned __int8 *)(a1 + 1165));
      v63 = (unint64_t *)(*(_QWORD *)(a1 + 80)
                               + 24 * *((unsigned __int16 *)v21 + 2 * *(unsigned __int8 *)(a1 + 1165)));
      v64 = *v63;
      v56 = *v63 & 0xFFFFFFFFFFFFFLL;
      if (v4 + v30 < v56)
      {
        updated = 2;
LABEL_77:
        spaceman_fxc_dropped(a1, v30, v4);
        v65 = a1 + 16 * (a2 ^ 1u);
        *(_QWORD *)(v65 + 296) = v30;
        *(_QWORD *)(v65 + 304) = v56;
        if ((_DWORD)updated != 2)
          goto LABEL_27;
LABEL_25:
        updated = 0;
        goto LABEL_28;
      }
      v66 = v63[1] & 0xFFFFFFFFFFFFFLL;
      v67 = v56 - v30 + v66;
      if (v56 == *(_QWORD *)(a1 + 112))
        *(_QWORD *)(a1 + 112) = v30;
      *v63 = v64 & 0xFFF0000000000000 | v30;
      updated = spaceman_fxc_update_length(a1, v30, v66, v56 - v30 + v66, v62);
      if ((_DWORD)updated)
        goto LABEL_27;
      v68 = a1 + 48 * ((*(_DWORD *)(a1 + 280) & 4) == 0);
      v70 = *(_QWORD *)(v68 + 176);
      v69 = (unint64_t *)(v68 + 176);
      if (v70 >= v67)
        goto LABEL_25;
      updated = 0;
      *v69 = v67;
LABEL_28:
      if (*(_QWORD *)a1)
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
      return updated;
    }
LABEL_34:
    v30 = a3;
    goto LABEL_35;
  }
  if (*(_QWORD *)a1)
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  return 45;
}

uint64_t spaceman_fxc_tree_node_recycle_smallest_if_full(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v5;
  _QWORD *v7;
  uint64_t v8;
  _OWORD *v10;
  uint64_t v11;
  unsigned int v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  int v16;

  if (*(_WORD *)(a1 + 92))
    return 0;
  v5 = *(_QWORD *)(a1 + 120);
  if (v5 > a2)
    return 55;
  v7 = (_QWORD *)(a1 + 112);
  v8 = *(_QWORD *)(a1 + 112);
  if (v5 == a2 && v8 < a3)
    return 55;
  if (!v8)
    return 0;
  v10 = (_OWORD *)(a1 + 480);
  if (spaceman_fxc_tree_search(a1, 0, v8, v5, a1 + 480)
    || (v11 = 4 * *(unsigned __int8 *)(a1 + 577),
        v12 = *(unsigned __int16 *)((char *)v10 + v11),
        !*(_WORD *)((char *)v10 + v11)))
  {
    log_err("%s:%d: %s dev %d Failed to find smallest extent in paddr tree: %d\n");
  }
  else
  {
    spaceman_fxc_tree_delete_at_path(a1, a1 + 480);
    if (spaceman_fxc_tree_search(a1, 1u, *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 120), a1 + 480)
      || !*((_WORD *)v10 + 2 * *(unsigned __int8 *)(a1 + 577)))
    {
      log_err("%s:%d: %s dev %d Failed to find smallest extent %d in length tree: %d\n");
    }
    else
    {
      spaceman_fxc_dropped(a1, *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 120));
      v13 = *(_OWORD *)(a1 + 560);
      *(_OWORD *)(a1 + 642) = *(_OWORD *)(a1 + 544);
      *(_OWORD *)(a1 + 658) = v13;
      *(_WORD *)(a1 + 674) = *(_WORD *)(a1 + 576);
      v14 = *(_OWORD *)(a1 + 496);
      *(_OWORD *)(a1 + 578) = *v10;
      *(_OWORD *)(a1 + 594) = v14;
      v15 = *(_OWORD *)(a1 + 528);
      *(_OWORD *)(a1 + 610) = *(_OWORD *)(a1 + 512);
      *(_OWORD *)(a1 + 626) = v15;
      v16 = spaceman_fxc_tree_adjacent(a1, a1 + 578, 1);
      if (!v16)
      {
        *(int8x16_t *)(a1 + 112) = vandq_s8(*(int8x16_t *)(*(_QWORD *)(a1 + 80)+ 24* *(unsigned __int16 *)(a1 + 578 + 4* *(unsigned __int8 *)(a1 + 675))), (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFuLL));
        goto LABEL_23;
      }
      if (v16 == 2)
      {
        *v7 = 0;
        *(_QWORD *)(a1 + 120) = 0;
        *(_QWORD *)(a1 + 128) = 0;
LABEL_23:
        spaceman_fxc_tree_delete_at_path(a1, a1 + 480);
        spaceman_fxc_tree_node_free(a1, v12);
        return 0;
      }
      log_err("%s:%d: %s dev %d Failed to find next smallest extent in length tree: %d\n");
    }
  }
  return 3;
}

uint64_t spaceman_fxc_dropped(uint64_t a1, uint64_t a2, unint64_t a3)
{
  _BOOL4 v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  v3 = (*(_DWORD *)(a1 + 280) & 4) == 0;
  v4 = a1 + 48 * ((*(_DWORD *)(a1 + 280) & 4) == 0);
  v6 = *(_QWORD *)(v4 + 152);
  v5 = (unint64_t *)(v4 + 152);
  if (v6 < a3)
    *v5 = a3;
  v7 = (_QWORD *)(a1 + 48 * v3);
  v8 = v7[17];
  v9 = v7[18];
  v7 += 17;
  *v7 = v8 + 1;
  v7[1] = v9 + a3;
  return spaceman_fxc_dropped_range_update((uint64_t)v7, a2, a3);
}

uint64_t spaceman_fxc_tree_search(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  BOOL v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int16 v24;
  uint64_t result;
  uint64_t v26;

  *(_WORD *)(a5 + 96) = 0;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_BYTE *)(a5 + 96) = a2;
  v10 = *(unsigned __int16 *)(a1 + 2 * a2 + 104);
  *(_WORD *)a5 = v10;
  if (v10)
  {
    v11 = *(_QWORD *)(a1 + 80) + 24 * v10;
    if (a2)
      v12 = *(_BYTE *)(v11 + 15);
    else
      v12 = *(_BYTE *)(v11 + 7);
    *(_BYTE *)(a5 + 2) = v12;
  }
  v13 = 4 * *(unsigned __int8 *)(a5 + 97);
  v14 = *(unsigned __int16 *)(a5 + v13);
  if (*(_WORD *)(a5 + v13))
  {
    do
    {
      v15 = *(_QWORD *)(a1 + 80);
      v16 = (_QWORD *)(v15 + 24 * v14);
      if (a2)
      {
        v17 = *(_QWORD *)(v15 + 24 * v14 + 8) & 0xFFFFFFFFFFFFFLL;
        v18 = v17 > a4;
        v19 = v17 < a4;
        if (v18)
          v19 = -1;
        if (!v19)
        {
          v20 = *v16 & 0xFFFFFFFFFFFFFLL;
          v19 = v20 > a3;
          if (v20 < a3)
            goto LABEL_18;
        }
      }
      else
      {
        v21 = *v16 & 0xFFFFFFFFFFFFFLL;
        v19 = v21 < a3;
        if (v21 > a3)
          goto LABEL_18;
      }
      if (!v19)
        return 0;
      if (v19 < 0)
      {
LABEL_18:
        v22 = a1;
        v23 = a5;
        v24 = -1;
        goto LABEL_19;
      }
      v22 = a1;
      v23 = a5;
      v24 = 1;
LABEL_19:
      result = spaceman_fxtp_add_child(v22, v23, v24);
      if ((_DWORD)result)
        return result;
      v26 = 4 * *(unsigned __int8 *)(a5 + 97);
      v14 = *(unsigned __int16 *)(a5 + v26);
    }
    while (*(_WORD *)(a5 + v26));
  }
  return 0;
}

uint64_t spaceman_fxc_update_length(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, unsigned int a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD *v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  int8x16_t v25;
  BOOL v26;
  unint64_t v27;
  unint64_t v28;
  __int16 v29;

  v29 = a5;
  v10 = a1 + 676;
  v11 = *(_QWORD *)(a1 + 112);
  v12 = spaceman_fxc_tree_search(a1, 1u, a2, a3, a1 + 676);
  if ((_DWORD)v12)
    return v12;
  if (!*(_WORD *)(v10 + 4 * *(unsigned __int8 *)(a1 + 773)))
    return 2;
  if (*(unsigned __int16 *)(v10 + 4 * *(unsigned __int8 *)(a1 + 773)) != a5)
  {
    log_err("%s:%d: %s dev %d length tree search for 0x%llx 0x%llx returned node %d instead of %d\n", "spaceman_fxc_update_length", 1400, (const char *)(*(_QWORD *)(*(_QWORD *)a1 + 384) + 208), *(unsigned __int8 *)(a1 + 88), a2, a3, *(unsigned __int16 *)(v10 + 4 * *(unsigned __int8 *)(a1 + 773)), a5);
    return 22;
  }
  v14 = (_OWORD *)(a1 + 774);
  v15 = *(_QWORD *)(a1 + 96);
  v16 = *(_QWORD *)(a1 + 80) + 24 * a5;
  *(_QWORD *)(v16 + 8) = *(_QWORD *)(v16 + 8) & 0xFFF0000000000000 | a4 & 0xFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 96) = a4 - a3 + v15;
  if (a4 <= a3)
  {
    if (v11 != a2)
    {
      v21 = *(_OWORD *)(v10 + 80);
      *(_OWORD *)(a1 + 838) = *(_OWORD *)(v10 + 64);
      *(_OWORD *)(a1 + 854) = v21;
      *(_WORD *)(a1 + 870) = *(_WORD *)(v10 + 96);
      v22 = *(_OWORD *)(v10 + 16);
      *v14 = *(_OWORD *)v10;
      *(_OWORD *)(a1 + 790) = v22;
      v23 = *(_OWORD *)(v10 + 48);
      *(_OWORD *)(a1 + 806) = *(_OWORD *)(v10 + 32);
      *(_OWORD *)(a1 + 822) = v23;
      v24 = spaceman_fxc_tree_adjacent(a1, a1 + 774, -1);
      if ((_DWORD)v24)
      {
        v12 = v24;
        if ((_DWORD)v24 == 2)
          log_err("%s:%d: %s dev %d Failed to find length tree predecessor for node that wasn't the smallest\n", "spaceman_fxc_update_length", 1463, (const char *)(*(_QWORD *)(*(_QWORD *)a1 + 384) + 208), *(unsigned __int8 *)(a1 + 88));
        return v12;
      }
      if ((*(_QWORD *)(*(_QWORD *)(a1 + 80) + 24 * *((unsigned __int16 *)v14 + 2 * *(unsigned __int8 *)(a1 + 871)) + 8) & 0xFFFFFFFFFFFFFuLL) >= a4)
      {
        v27 = *(_QWORD *)(a1 + 120);
        if (v27 > a4 || v27 == a4 && *(_QWORD *)(a1 + 112) < a2)
        {
          *(_QWORD *)(a1 + 112) = a2;
          *(_QWORD *)(a1 + 120) = a4;
        }
        goto LABEL_36;
      }
      goto LABEL_31;
    }
  }
  else
  {
    v17 = *(_OWORD *)(v10 + 80);
    *(_OWORD *)(a1 + 838) = *(_OWORD *)(v10 + 64);
    *(_OWORD *)(a1 + 854) = v17;
    *(_WORD *)(a1 + 870) = *(_WORD *)(v10 + 96);
    v18 = *(_OWORD *)(v10 + 16);
    *v14 = *(_OWORD *)v10;
    *(_OWORD *)(a1 + 790) = v18;
    v19 = *(_OWORD *)(v10 + 48);
    *(_OWORD *)(a1 + 806) = *(_OWORD *)(v10 + 32);
    *(_OWORD *)(a1 + 822) = v19;
    v20 = spaceman_fxc_tree_adjacent(a1, a1 + 774, 1);
    if ((_DWORD)v20)
    {
      v12 = v20;
      if ((_DWORD)v20 != 2)
        return v12;
      if (v11 == a2)
        *(_QWORD *)(a1 + 120) = a4;
      if (*(_QWORD *)(a1 + 128) >= a4)
        return 0;
      v12 = 0;
LABEL_38:
      *(_QWORD *)(a1 + 128) = a4;
      return v12;
    }
    v25 = vandq_s8(*(int8x16_t *)(*(_QWORD *)(a1 + 80) + 24 * *((unsigned __int16 *)v14 + 2 * *(unsigned __int8 *)(a1 + 871))), (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFuLL));
    if (v25.i64[1] < a4 || (v25.i64[1] == a4 ? (v26 = v25.i64[0] <= a2) : (v26 = 1), !v26))
    {
      if (v11 == a2)
        *(int8x16_t *)(a1 + 112) = v25;
LABEL_36:
      spaceman_fxc_tree_delete_at_path(a1, v10);
      v12 = spaceman_fxc_tree_insert(a1, 1u, a2, a4, &v29);
      goto LABEL_37;
    }
    if (v11 != a2)
    {
LABEL_31:
      v12 = 0;
      goto LABEL_37;
    }
  }
  v12 = 0;
  *(_QWORD *)(a1 + 120) = a4;
LABEL_37:
  v28 = *(_QWORD *)(a1 + 128);
  if (v28 < a4)
    goto LABEL_38;
  if (v28 == a3)
    spaceman_fxc_update_longest_from_last(a1);
  return v12;
}

unint64_t spaceman_fxc_insert_invalidate_last_unwanted_ranges_if_needed(unint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  char v7;
  char v8;
  unint64_t v9;
  unint64_t v10;

  v3 = result;
  v4 = 0;
  v5 = a2 - 1;
  v6 = a3 + 2;
  v7 = 1;
  do
  {
    v8 = v7;
    v9 = v3 + 16 * v4;
    v10 = *(_QWORD *)(v9 + 296);
    if (v10)
    {
      result = calc_overlap_range(v5, v6, v10, *(_QWORD *)(v9 + 304) - v10, 0);
      if (result)
        *(_QWORD *)(v9 + 296) = 0;
    }
    v7 = 0;
    v4 = 1;
  }
  while ((v8 & 1) != 0);
  return result;
}

uint64_t spaceman_fxc_tree_insert_at_path(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _WORD *v13;
  int v14;
  unsigned __int8 v15;
  int v16;
  int v17;
  int v18;
  unsigned __int16 *v19;
  uint64_t v20;
  char v21;
  unsigned __int16 *v22;
  int v23;
  _QWORD *v24;
  unsigned __int16 *v25;
  int v26;
  unsigned __int16 *v27;
  int v28;

  v6 = *(unsigned __int8 *)(a5 + 96);
  if (a4 && (LOWORD(v7) = *a4) != 0)
  {
    v8 = *(_QWORD *)(a1 + 80);
    v9 = (_QWORD *)(v8 + 24 * (unsigned __int16)*a4);
    *((_DWORD *)v9 + v6 + 4) = 0;
    if ((_DWORD)v6)
      ++v9;
    *v9 &= 0xFFFFFFFFFFFFFFuLL;
  }
  else
  {
    v7 = *(unsigned __int16 *)(a1 + 92);
    if (v7 > *(_DWORD *)(a1 + 88) >> 8)
      return 22;
    if (!*(_WORD *)(a1 + 92))
      return 12;
    v11 = (_QWORD *)(*(_QWORD *)(a1 + 80) + 24 * *(unsigned __int16 *)(a1 + 92));
    *(_WORD *)(a1 + 92) = *v11;
    ++*(_WORD *)(a1 + 94);
    *(_QWORD *)(a1 + 96) += a3;
    v11[1] = 0;
    v11[2] = 0;
    *v11 = 0;
    if (a4)
      *a4 = v7;
    v8 = *(_QWORD *)(a1 + 80);
    v12 = (_QWORD *)(v8 + 24 * v7);
    *v12 = a2;
    v12[1] = a3;
  }
  v10 = *(unsigned __int8 *)(a5 + 97);
  v13 = (_WORD *)(a5 + 4 * v10);
  *v13 = v7;
  v13[1] = 0;
  if (!v10)
  {
    *(_WORD *)(a1 + 2 * v6 + 104) = v7;
    return v10;
  }
  v14 = (char)v10;
  *(_WORD *)(v8
           + 24 * *(unsigned __int16 *)(a5 + 4 * (v10 - 1))
           + 4 * v6
           + 2
           * ((*(char *)(a5 + 4 * (v10 - 1) + 3)
                              + 1
                              + (((*(char *)(a5 + 4 * (v10 - 1) + 3) + 1) & 0x8000u) >> 15)) >> 1)
           + 16) = v7;
  v15 = v10;
  if (((char)v10 & 0x80000000) == 0)
  {
    while (!*(_BYTE *)(a5 + 4 * v15 + 2))
    {
      v16 = (char)v15--;
      if (v16 <= 0)
      {
        v15 = -1;
        break;
      }
    }
  }
  v17 = (char)(v15 + 1);
  if (v17 < v14)
  {
    LOBYTE(v18) = v15 + 1;
    do
    {
      v19 = (unsigned __int16 *)(a5 + 4 * v18);
      v20 = v8 + 24 * *v19;
      if ((_DWORD)v6)
        v20 += 8;
      v21 = *((_BYTE *)v19 + 3);
      *(_BYTE *)(v20 + 7) = v21;
      *((_BYTE *)v19 + 2) = v21;
      v18 = (char)(v18 + 1);
    }
    while (v18 < v14);
  }
  if ((v15 & 0x80) != 0)
    return 0;
  v22 = (unsigned __int16 *)(a5 + 4 * v15);
  v23 = *((char *)v22 + 3);
  if (*((char *)v22 + 2) + v23)
  {
    if (*((unsigned __int8 *)v22 + 2) == *((unsigned __int8 *)v22 + 3))
    {
      if (v15)
        v25 = (unsigned __int16 *)(v8
                                 + 24 * *(unsigned __int16 *)(a5 + 4 * (v15 - 1))
                                 + 4 * v6
                                 + 2
                                 * ((*(char *)(a5 + 4 * (v15 - 1) + 3)
                                                    + 1
                                                    + (((*(char *)(a5 + 4 * (v15 - 1) + 3) + 1) & 0x8000u) >> 15)) >> 1)
                                 + 16);
      else
        v25 = (unsigned __int16 *)(a1 + 2 * v6 + 104);
      v26 = -v23;
      v27 = (unsigned __int16 *)(a5 + 4 * v17);
      v28 = *((unsigned __int8 *)v27 + 2);
      if (v28 == *((unsigned __int8 *)v22 + 3))
      {
        spaceman_fxc_tree_single_rotate(a1, v6, (char)v26, *v22, v25);
      }
      else if ((char)v28 == v26)
      {
        spaceman_fxc_tree_double_rotate(a1, v6, (char)v23, *v22, *v27, v25);
      }
    }
    return 0;
  }
  v10 = 0;
  v24 = (_QWORD *)(v8 + 24 * *v22);
  if ((_DWORD)v6)
    ++v24;
  *v24 &= 0xFFFFFFFFFFFFFFuLL;
  return v10;
}

uint64_t spaceman_fxc_tree_insert(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, _WORD *a5)
{
  uint64_t v10;
  uint64_t result;

  if ((a4 | a3) >> 52)
    return 84;
  v10 = a1 + 872;
  if (!a5 || !*a5)
    spaceman_fxc_tree_node_recycle_smallest_if_full(a1, a4, a3);
  result = spaceman_fxc_tree_search(a1, a2, a3, a4, v10);
  if (!(_DWORD)result)
  {
    if (*(_WORD *)(v10 + 4 * *(unsigned __int8 *)(a1 + 969)))
      return 17;
    else
      return spaceman_fxc_tree_insert_at_path(a1, a3, a4, a5, v10);
  }
  return result;
}

uint64_t spaceman_fxc_tree_delete(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v4;
  uint64_t result;

  if ((a3 | a2) >> 52)
    return 84;
  v4 = a1 + 970;
  result = spaceman_fxc_tree_search(a1, 0, a2, a3, a1 + 970);
  if (!(_DWORD)result)
  {
    if (*(_WORD *)(v4 + 4 * *(unsigned __int8 *)(a1 + 1067)))
    {
      spaceman_fxc_tree_delete_at_path(a1, v4);
      return 0;
    }
    else
    {
      return 2;
    }
  }
  return result;
}

uint64_t spaceman_fxc_tree_node_free(uint64_t result, unsigned int a2)
{
  _QWORD *v2;
  uint64_t v3;

  if (a2 <= *(_DWORD *)(result + 88) >> 8)
  {
    v2 = (_QWORD *)(*(_QWORD *)(result + 80) + 24 * a2);
    v3 = v2[1] & 0xFFFFFFFFFFFFFLL;
    --*(_WORD *)(result + 94);
    *(_QWORD *)(result + 96) -= v3;
    *v2 = *(unsigned __int16 *)(result + 92);
    *(_WORD *)(result + 92) = a2;
  }
  return result;
}

uint64_t spaceman_fxc_tree_delete_at_path(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  _WORD *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  unsigned int v12;
  unsigned __int8 v13;
  unsigned __int16 *v14;
  unsigned int v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  unsigned int v19;
  _WORD *v20;
  unsigned int v21;
  uint64_t v22;
  _BYTE *v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  _WORD *v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _WORD *v36;
  _WORD *v37;
  _WORD *v38;
  uint64_t v39;
  uint64_t v40;
  unsigned __int16 *v41;
  unsigned __int16 *v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  int v48;
  int v49;
  uint64_t v50;
  unsigned __int16 *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unsigned __int8 v55;
  uint64_t v56;

  v3 = result;
  v4 = *(unsigned __int8 *)(a2 + 96);
  v5 = *(unsigned __int8 *)(a2 + 97);
  v6 = (char)v5;
  v7 = (_WORD *)(a2 + 4 * v5);
  v8 = *(_QWORD *)(result + 80);
  v9 = v8 + 24 * (unsigned __int16)*v7;
  if (*(_BYTE *)(a2 + 96))
    v10 = *(_BYTE *)(v9 + 15);
  else
    v10 = *(_BYTE *)(v9 + 7);
  v11 = v8 + 24 * (unsigned __int16)*v7 + 4 * v4;
  v12 = *(unsigned __int16 *)(v11 + 18);
  v13 = v5 - 1;
  if ((char)v5 < 1)
  {
    v16 = 0;
    v15 = 0;
  }
  else
  {
    v14 = (unsigned __int16 *)(a2 + 4 * v13);
    v15 = *v14;
    LODWORD(v14) = *((char *)v14 + 3) + 1;
    result = (unsigned __int16)v14 & 0x8000;
    v16 = ((v14 + (result >> 15)) >> 1);
  }
  v17 = *(_WORD *)(v11 + 16);
  if (!v12)
  {
    if ((_BYTE)v5)
      v37 = (_WORD *)(v8 + 24 * v15 + 4 * v4 + 2 * v16 + 16);
    else
      v37 = (_WORD *)(v3 + 2 * v4 + 104);
    *v37 = v17;
    *(_BYTE *)(a2 + 97) = v13;
    if ((((_BYTE)v5 - 1) & 0x80) != 0)
      return result;
    goto LABEL_28;
  }
  result = 24;
  v18 = v8 + 24 * v12 + 4 * v4;
  v21 = *(unsigned __int16 *)(v18 + 16);
  v20 = (_WORD *)(v18 + 16);
  v19 = v21;
  if (v21)
  {
    v22 = a2 + 4 * v5;
    *(_BYTE *)(v22 + 3) = 1;
    v23 = (_BYTE *)(v22 + 3);
    v24 = v6 + 1;
    *(_BYTE *)(a2 + 97) = v6 + 1;
    v25 = a2 + 4 * (v6 + 1);
    *(_WORD *)v25 = v12;
    *(_BYTE *)(v25 + 3) = 0;
    v26 = v12;
    do
    {
      v13 = v24;
      v27 = v26;
      v26 = v19;
      *(_BYTE *)(a2 + 4 * v24++ + 3) = -1;
      v28 = a2 + 4 * v24;
      *(_WORD *)v28 = v26;
      *(_BYTE *)(v28 + 3) = 0;
      v29 = v8 + 24 * v26 + 4 * v4;
      v31 = *(unsigned __int16 *)(v29 + 16);
      v30 = (_WORD *)(v29 + 16);
      v19 = v31;
    }
    while (v31);
    result = v26;
    v32 = v8 + 24 * v26;
    v33 = v32 + 4 * v4;
    *(_WORD *)(v8 + 24 * v27 + 4 * v4 + 16) = *(_WORD *)(v33 + 18);
    *(_WORD *)(v33 + 18) = v12;
    *v30 = v17;
    v34 = v32 + 8;
    if (!(_DWORD)v4)
      v34 = v32;
    *(_BYTE *)(v34 + 7) = v10;
    v35 = v8 + 24 * v15 + 4 * v4 + 2 * v16 + 16;
    if (v6)
      v36 = (_WORD *)v35;
    else
      v36 = (_WORD *)(v3 + 2 * v4 + 104);
    *v36 = result;
    *v23 = 1;
    *v7 = result;
    *(_BYTE *)(a2 + 97) = v13;
    if ((v13 & 0x80) != 0)
      return result;
LABEL_28:
    v40 = v13 + 255;
    v41 = (unsigned __int16 *)(a2 + 4 * v13);
    v42 = v41;
    while (1)
    {
      v44 = *v42;
      v42 -= 2;
      v43 = v44;
      v45 = *(_QWORD *)(v3 + 80);
      v46 = v45 + 24 * v44;
      if ((_DWORD)v4)
        v47 = *(_BYTE *)(v45 + 24 * v43 + 15);
      else
        v47 = *(_BYTE *)(v46 + 7);
      v48 = *((unsigned __int8 *)v41 + 3);
      v49 = (char)(v47 - v48);
      if (v49 < 0)
        v49 = -v49;
      if (v49 << 24 > 0x1FFFFFF)
      {
        v51 = (unsigned __int16 *)(v3 + 2 * v4 + 104);
        if (v40 != 255)
          v51 = (unsigned __int16 *)(v45
                                   + 24 * *(unsigned __int16 *)(a2 + 4 * v40)
                                   + 4 * v4
                                   + 2
                                   * ((*(char *)(a2 + 4 * v40 + 3)
                                                      + 1
                                                      + (((*(char *)(a2 + 4 * v40 + 3) + 1) & 0x8000u) >> 15)) >> 1)
                                   + 16);
        v52 = (char)-(char)v48;
        v53 = *(unsigned __int16 *)(v45
                                  + 24 * v43
                                  + 4 * v4
                                  + 2
                                  * (((_DWORD)v52 + 1 + ((((_DWORD)v52 + 1) & 0x8000u) >> 15)) >> 1)
                                  + 16);
        v54 = v45 + 24 * v53;
        if ((_DWORD)v4)
          v55 = *(_BYTE *)(v54 + 15);
        else
          v55 = *(_BYTE *)(v54 + 7);
        if (v48 == v55)
        {
          result = spaceman_fxc_tree_double_rotate(v3, v4, v52, v43, v53, v51);
        }
        else
        {
          result = spaceman_fxc_tree_single_rotate(v3, v4, (char)v48, v43, v51);
          if (!v55)
            return result;
        }
      }
      else
      {
        v50 = v45 + 24 * v43 + 8;
        if (!(_DWORD)v4)
          v50 = v46;
        *(_BYTE *)(v50 + 7) = v47 - v48;
        if (!v47)
          return result;
      }
      v56 = v40 - 255;
      --v40;
      v41 = v42;
      if (v56 <= 0)
        return result;
    }
  }
  *v20 = v17;
  v38 = (_WORD *)(v8 + 24 * v15 + 4 * v4 + 2 * v16 + 16);
  if (!(_BYTE)v5)
    v38 = (_WORD *)(v3 + 2 * v4 + 104);
  *v38 = v12;
  v39 = v8 + 24 * v12;
  if ((_DWORD)v4)
    v39 += 8;
  *(_BYTE *)(v39 + 7) = v10;
  *(_BYTE *)(a2 + 4 * v5 + 3) = 1;
  *v7 = v12;
  v13 = v5;
  if ((v5 & 0x80) == 0)
    goto LABEL_28;
  return result;
}

const char *spaceman_fxc_update_smallest_with_successor(uint64_t a1, uint64_t a2)
{
  const char *result;

  result = (const char *)spaceman_fxc_tree_adjacent(a1, a2, 1);
  if ((_DWORD)result == 2)
  {
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 120) = 0;
  }
  else if ((_DWORD)result)
  {
    return log_err("%s:%d: %s dev %d Failed to find successor node from length tree while updating smallest: %d\n", "spaceman_fxc_update_smallest_with_successor", 1520, (const char *)(*(_QWORD *)(*(_QWORD *)a1 + 384) + 208), *(unsigned __int8 *)(a1 + 88), (_DWORD)result);
  }
  else
  {
    *(int8x16_t *)(a1 + 112) = vandq_s8(*(int8x16_t *)(*(_QWORD *)(a1 + 80)+ 24 * *(unsigned __int16 *)(a2 + 4 * *(unsigned __int8 *)(a2 + 97))), (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFuLL));
  }
  return result;
}

uint64_t spaceman_free_extent_cache_remove(uint64_t a1, unint64_t a2, unint64_t a3)
{
  _OWORD *v6;
  uint64_t updated;
  _OWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unsigned __int16 v34;

  if (!a1)
    return 22;
  if ((a3 | a2) >> 52)
    return 84;
  if (!a3)
    return 0;
  if (*(_QWORD *)a1)
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if ((*(_BYTE *)(a1 + 280) & 2) == 0)
  {
    v6 = (_OWORD *)(a1 + 1068);
    v34 = 0;
    updated = spaceman_fxc_tree_search(a1, 0, a2, a3, a1 + 1068);
    if ((_DWORD)updated)
    {
LABEL_8:
      log_err("%s:%d: %s dev %d Error %d, reinitializing\n", "spaceman_free_extent_cache_remove", 2076, (const char *)(*(_QWORD *)(*(_QWORD *)a1 + 384) + 208), *(unsigned __int8 *)(a1 + 88), updated);
      spaceman_free_extent_cache_reset(a1);
      goto LABEL_9;
    }
    v9 = (_OWORD *)(a1 + 1166);
    v10 = a3 + a2;
    v11 = 4 * *(unsigned __int8 *)(a1 + 1165);
    v12 = *(unsigned __int16 *)((char *)v6 + v11);
    if (*(_WORD *)((char *)v6 + v11))
      goto LABEL_19;
    v19 = *(_OWORD *)(a1 + 1148);
    *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
    *(_OWORD *)(a1 + 1246) = v19;
    *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
    v20 = *(_OWORD *)(a1 + 1084);
    *v9 = *v6;
    *(_OWORD *)(a1 + 1182) = v20;
    v21 = *(_OWORD *)(a1 + 1116);
    *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
    *(_OWORD *)(a1 + 1214) = v21;
    v22 = spaceman_fxc_tree_adjacent(a1, a1 + 1166, -1);
    if ((_DWORD)v22 == 2)
      goto LABEL_42;
    updated = v22;
    if ((_DWORD)v22)
      goto LABEL_8;
    v23 = (_QWORD *)(*(_QWORD *)(a1 + 80) + 24 * *((unsigned __int16 *)v9 + 2 * *(unsigned __int8 *)(a1 + 1263)));
    v24 = v23[1] & 0xFFFFFFFFFFFFFLL;
    v25 = v24 + (*v23 & 0xFFFFFFFFFFFFFLL);
    if (v25 <= a2)
      goto LABEL_42;
    updated = spaceman_fxc_update_length(a1, *v23 & 0xFFFFFFFFFFFFFLL, v24, a2 - (*v23 & 0xFFFFFFFFFFFFFLL), *((unsigned __int16 *)v9 + 2 * *(unsigned __int8 *)(a1 + 1263)));
    if ((_DWORD)updated)
      goto LABEL_8;
    v26 = v25 - v10;
    if (v25 <= v10)
    {
LABEL_42:
      v31 = spaceman_fxc_tree_adjacent(a1, a1 + 1068, 1);
      if ((_DWORD)v31 != 2)
      {
        updated = v31;
        if ((_DWORD)v31)
          goto LABEL_8;
        v12 = *((unsigned __int16 *)v6 + 2 * *(unsigned __int8 *)(a1 + 1165));
LABEL_19:
        v13 = (unint64_t *)(*(_QWORD *)(a1 + 80) + 24 * v12);
        v14 = *v13;
        v15 = *v13 & 0xFFFFFFFFFFFFFLL;
        v16 = v13[1] & 0xFFFFFFFFFFFFFLL;
        v17 = v16 + v15;
        if (v10 >= v16 + v15)
        {
          while (1)
          {
            spaceman_fxc_tree_delete_at_path(a1, a1 + 1068);
            v27 = spaceman_fxc_tree_search(a1, 1u, v15, v16, a1 + 1068);
            if ((_DWORD)v27)
            {
              v32 = v27;
              log_err("%s:%d: %s dev %d Failed to delete covered node from length tree: %d\n", "spaceman_free_extent_cache_remove", 2016, (const char *)(*(_QWORD *)(*(_QWORD *)a1 + 384) + 208), *(unsigned __int8 *)(a1 + 88), v27);
              updated = v32;
              goto LABEL_8;
            }
            if (v15 == *(_QWORD *)(a1 + 112))
            {
              v28 = *(_OWORD *)(a1 + 1148);
              *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
              *(_OWORD *)(a1 + 1246) = v28;
              *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
              v29 = *(_OWORD *)(a1 + 1084);
              *v9 = *v6;
              *(_OWORD *)(a1 + 1182) = v29;
              v30 = *(_OWORD *)(a1 + 1116);
              *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
              *(_OWORD *)(a1 + 1214) = v30;
              spaceman_fxc_update_smallest_with_successor(a1, a1 + 1166);
            }
            spaceman_fxc_tree_delete_at_path(a1, a1 + 1068);
            spaceman_fxc_tree_node_free(a1, (unsigned __int16)v12);
            if (v16 == *(_QWORD *)(a1 + 128))
              spaceman_fxc_update_longest_from_last(a1);
            updated = spaceman_fxc_tree_search(a1, 0, v15, v16, a1 + 1068);
            if (!(_DWORD)updated)
              updated = spaceman_fxc_tree_adjacent(a1, a1 + 1068, 1);
            if ((_DWORD)updated)
              break;
            v12 = *((unsigned __int16 *)v6 + 2 * *(unsigned __int8 *)(a1 + 1165));
            v13 = (unint64_t *)(*(_QWORD *)(a1 + 80)
                                     + 24 * *((unsigned __int16 *)v6 + 2 * *(unsigned __int8 *)(a1 + 1165)));
            v14 = *v13;
            v15 = *v13 & 0xFFFFFFFFFFFFFLL;
            v16 = v13[1] & 0xFFFFFFFFFFFFFLL;
            v17 = v16 + v15;
            if (v10 < (uint64_t)(v16 + v15))
              goto LABEL_20;
          }
          if ((_DWORD)updated == 2)
            goto LABEL_46;
          log_err("%s:%d: %s dev %d Failed to get next extent: %d\n", "spaceman_free_extent_cache_remove", 2047, (const char *)(*(_QWORD *)(*(_QWORD *)a1 + 384) + 208), *(unsigned __int8 *)(a1 + 88), updated);
          goto LABEL_8;
        }
LABEL_20:
        if (v10 > v15)
        {
          if (v15 == *(_QWORD *)(a1 + 112))
            *(_QWORD *)(a1 + 112) = v10;
          *v13 = v14 & 0xFFF0000000000000 | v10 & 0xFFFFFFFFFFFFFLL;
          v18 = spaceman_fxc_update_length(a1, v10, v16, v17 - v10, v12);
          updated = v18;
          if (!(_DWORD)v18)
            goto LABEL_9;
          log_err("%s:%d: %s dev %d Failed to update partially-covered node in length tree: %d\n", "spaceman_free_extent_cache_remove", 2070, (const char *)(*(_QWORD *)(*(_QWORD *)a1 + 384) + 208), *(unsigned __int8 *)(a1 + 88), v18);
          goto LABEL_8;
        }
      }
    }
    else
    {
      v34 = 0;
      if (spaceman_fxc_tree_insert(a1, 0, v10, v25 - v10, &v34))
      {
LABEL_31:
        spaceman_fxc_dropped(a1, v10, v25 - v10);
        goto LABEL_46;
      }
      if (spaceman_fxc_tree_insert(a1, 1u, v10, v25 - v10, &v34))
      {
        if (!spaceman_fxc_tree_delete(a1, v10, v25 - v10))
          spaceman_fxc_tree_node_free(a1, v34);
        goto LABEL_31;
      }
      v33 = *(_QWORD *)(a1 + 120);
      if (v26 < v33 || v26 == v33 && v10 > *(_QWORD *)(a1 + 112))
      {
        *(_QWORD *)(a1 + 112) = v10;
        *(_QWORD *)(a1 + 120) = v26;
      }
      if (v26 > *(_QWORD *)(a1 + 128))
      {
        updated = 0;
        *(_QWORD *)(a1 + 128) = v26;
LABEL_9:
        if (*(_QWORD *)a1)
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
        return updated;
      }
    }
LABEL_46:
    updated = 0;
    goto LABEL_9;
  }
  if (*(_QWORD *)a1)
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  return 45;
}

uint64_t spaceman_fxc_update_longest_from_last(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;

  v2 = a1 + 676;
  result = spaceman_fxc_tree_last(a1, a1 + 676, 1u);
  if ((_DWORD)result == 2)
  {
    v4 = 0;
  }
  else
  {
    if ((_DWORD)result)
      return result;
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 24 * *(unsigned __int16 *)(v2 + 4 * *(unsigned __int8 *)(a1 + 773)) + 8) & 0xFFFFFFFFFFFFFLL;
  }
  *(_QWORD *)(a1 + 128) = v4;
  return result;
}

uint64_t spaceman_fxc_tree_last(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  uint64_t result;
  unsigned int v10;

  *(_WORD *)(a2 + 96) = 0;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_BYTE *)(a2 + 96) = a3;
  v5 = *(unsigned __int16 *)(a1 + 2 * a3 + 104);
  *(_WORD *)a2 = v5;
  if (v5)
  {
    v6 = *(_QWORD *)(a1 + 80) + 24 * v5;
    if (a3)
      v7 = *(_BYTE *)(v6 + 15);
    else
      v7 = *(_BYTE *)(v6 + 7);
    *(_BYTE *)(a2 + 2) = v7;
  }
  while (1)
  {
    v8 = *(unsigned __int8 *)(a2 + 97);
    if (!*(_WORD *)(a2 + 4 * v8))
      break;
    result = spaceman_fxtp_add_child(a1, a2, 1);
    if ((_DWORD)result)
      return result;
  }
  v10 = v8 - 1;
  *(_BYTE *)(a2 + 97) = v10;
  return (v10 >> 6) & 2;
}

uint64_t spaceman_free_extent_cache_bitmap_scan_begin(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  _BOOL8 v5;
  uint64_t v6;

  if (!a1)
    return 0;
  if (*(_QWORD *)a1)
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v4 = *(_QWORD *)(a1 + 280);
  v5 = (v4 & 6) == 0;
  if ((v4 & 6) == 0)
  {
    *(_QWORD *)(a1 + 280) = v4 | 4;
    v6 = *(_QWORD *)(a1 + 288);
    if (v6)
    {
      if (a2)
      {
LABEL_9:
        *a2 = v6;
        goto LABEL_12;
      }
    }
    else
    {
      v6 = 1;
      *(_QWORD *)(a1 + 288) = 1;
      if (a2)
        goto LABEL_9;
    }
    *(_QWORD *)(a1 + 280) = v4 | 0xC;
LABEL_12:
    if (!*(_QWORD *)a1)
      return 1;
    goto LABEL_13;
  }
  if (*(_QWORD *)a1)
  {
LABEL_13:
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    return v5;
  }
  return 0;
}

uint64_t spaceman_free_extent_cache_bitmap_scan_finished(uint64_t result, unint64_t a2, char a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  _OWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (result)
  {
    v5 = result;
    v6 = *(_QWORD *)(result + 8);
    if (*(_QWORD *)result)
      result = pthread_mutex_lock((pthread_mutex_t *)(result + 16));
    v7 = *(_QWORD *)(v5 + 280);
    if ((v7 & 6) == 0)
      goto LABEL_21;
    if ((a3 & 1) != 0)
    {
      *(_OWORD *)(v5 + 184) = *(_OWORD *)(v5 + 136);
      *(_OWORD *)(v5 + 200) = *(_OWORD *)(v5 + 152);
      *(_OWORD *)(v5 + 216) = *(_OWORD *)(v5 + 168);
      *(_QWORD *)(v5 + 280) = v7 & 0xFFFFFFFFFFFFFFF3;
      *(_OWORD *)(v5 + 136) = 0u;
      *(_OWORD *)(v5 + 152) = 0u;
      *(_OWORD *)(v5 + 168) = 0u;
    }
    else
    {
      if (*(_QWORD *)(*(_QWORD *)(v6 + 376) + 48 * *(unsigned __int8 *)(v5 + 88) + 48) > a2
        && ((v8 = *(_QWORD *)(v5 + 288), (v7 & 8) != 0) || v8 <= a2))
      {
        v9 = 0;
        if (v8 < a2)
          *(_QWORD *)(v5 + 288) = a2;
      }
      else
      {
        v9 = 1;
      }
      v10 = v7 & 0xFFFFFFFFFFFFFFF3;
      v12 = (_OWORD *)(v5 + 136);
      v11 = *(_QWORD *)(v5 + 136);
      *(_QWORD *)(v5 + 280) = v10;
      if (v11)
      {
        v13 = *(_QWORD *)(v5 + 184) + v11;
        v14 = *(_QWORD *)(v5 + 200);
        v15 = *(_QWORD *)(v5 + 152);
        v16 = *(_QWORD *)(v5 + 192) + *(_QWORD *)(v5 + 144);
        *(_QWORD *)(v5 + 184) = v13;
        *(_QWORD *)(v5 + 192) = v16;
        if (v14 < v15)
          *(_QWORD *)(v5 + 200) = v15;
        v17 = *(_QWORD *)(v5 + 176);
        if (*(_QWORD *)(v5 + 224) < v17)
          *(_QWORD *)(v5 + 224) = v17;
        result = spaceman_fxc_dropped_range_update(v5 + 184, *(_QWORD *)(v5 + 160), *(_QWORD *)(v5 + 168));
        *(_OWORD *)(v5 + 152) = 0u;
        *(_OWORD *)(v5 + 168) = 0u;
        *v12 = 0u;
        if ((v9 & 1) == 0)
          goto LABEL_21;
      }
      else
      {
        *(_OWORD *)(v5 + 152) = 0u;
        *(_OWORD *)(v5 + 168) = 0u;
        *v12 = 0u;
        if (!v9)
        {
LABEL_21:
          if (*(_QWORD *)v5)
            return pthread_mutex_unlock((pthread_mutex_t *)(v5 + 16));
          return result;
        }
      }
    }
    v18 = *(_QWORD *)(v5 + 336) + 1;
    *(_QWORD *)(v5 + 328) = 0;
    *(_QWORD *)(v5 + 336) = v18;
    *(_OWORD *)(v5 + 232) = *(_OWORD *)(v5 + 184);
    *(_OWORD *)(v5 + 248) = *(_OWORD *)(v5 + 200);
    *(_OWORD *)(v5 + 264) = *(_OWORD *)(v5 + 216);
    *(_OWORD *)(v5 + 184) = 0u;
    *(_OWORD *)(v5 + 200) = 0u;
    *(_OWORD *)(v5 + 216) = 0u;
    *(_QWORD *)(v5 + 288) = 0;
    v19 = *(_QWORD *)(v5 + 280);
    if ((v19 & 1) == 0)
      *(_QWORD *)(v5 + 280) = v19 | 1;
    goto LABEL_21;
  }
  return result;
}

uint64_t spaceman_fxc_dropped_range_update(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *(_QWORD *)(result + 24);
  if (v3)
  {
    if (v3 <= a2)
    {
      v4 = *(_QWORD *)(result + 32);
    }
    else
    {
      v4 = v3 - a2 + *(_QWORD *)(result + 32);
      *(_QWORD *)(result + 24) = a2;
      *(_QWORD *)(result + 32) = v4;
      v3 = a2;
    }
    v5 = v4 + v3;
    if (a3 + a2 > v5)
      *(_QWORD *)(result + 32) = v4 + a3 + a2 - v5;
  }
  else
  {
    *(_QWORD *)(result + 24) = a2;
    *(_QWORD *)(result + 32) = a3;
  }
  return result;
}

unint64_t spaceman_free_extent_cache_search_better_length(__int16 a1, unint64_t a2, unint64_t a3)
{
  if ((a1 & 0x1000) == 0)
    return a2;
  if (a3 <= 1)
    return a3 + 1;
  if (a3 + (a3 >> 1) >= a2)
    return a2;
  else
    return a3 + (a3 >> 1);
}

uint64_t spaceman_free_extent_cache_search(uint64_t a1, __int16 a2, int64_t *a3, unint64_t *a4)
{
  int64_t v4;
  unint64_t v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  int v15;
  _OWORD *v16;
  int v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  unint64_t v22;
  uint64_t result;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  _OWORD *v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  int v35;
  const char *v36;
  unsigned int v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  int v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72[2];

  v4 = *a3;
  v5 = *a4;
  *a3 = 0;
  *a4 = 0;
  if (!a1)
    return 6;
  ++*(_QWORD *)(a1 + 344);
  if (!v5)
  {
    ++*(_QWORD *)(a1 + 352);
    return 22;
  }
  v10 = *(_QWORD *)(*(_QWORD *)a1 + 376);
  v11 = *(_QWORD *)(v10 + 1248);
  if (v11
    && (v12 = *(_QWORD *)(v10 + 1240),
        v13 = __clz(__rbit64(*(unsigned int *)(v10 + 36))),
        *(_BYTE *)(a1 + 88) == (((v12 << v13) & 0x4000000000000000) != 0)))
  {
    v14 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v13) & v12;
    v15 = 1;
  }
  else
  {
    v15 = 0;
    v14 = 0;
  }
  v71 = 0;
  v72[0] = 0;
  v67 = 0;
  v68 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if ((*(_BYTE *)(a1 + 280) & 2) != 0)
  {
    if (*(_QWORD *)a1)
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    return 6;
  }
  v63 = v14;
  v64 = v15;
  v16 = (_OWORD *)(a1 + 1068);
  v69 = 0;
  v70 = 0;
  v65 = 0;
  v66 = 0;
  v17 = spaceman_fxc_tree_search(a1, 1u, v4, v5, a1 + 1068);
  if (!v17)
  {
    if (*((_WORD *)v16 + 2 * *(unsigned __int8 *)(a1 + 1165)))
    {
      v18 = (_QWORD *)(*(_QWORD *)(a1 + 80) + 24 * *((unsigned __int16 *)v16 + 2 * *(unsigned __int8 *)(a1 + 1165)));
      v19 = *v18 & 0xFFFFFFFFFFFFFLL;
      v70 = v19;
      v20 = v18[1] & 0xFFFFFFFFFFFFFLL;
      v66 = v20;
      if (v15)
      {
        spaceman_clip_extent(v19, v20, v63, v11, a2, v4, (unint64_t *)&v70, (unint64_t *)&v66);
        v20 = v66;
        v19 = v70;
      }
      if (v20)
      {
        v21 = spaceman_clip_extent_to_zones(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(unsigned __int8 *)(a1 + 88), v19, v20, a2, v4, (unint64_t *)&v69, &v65);
        v19 = v70;
        v22 = v66;
        if (v21)
        {
          v71 = v70;
          v67 = v66;
          v19 = v69;
          v70 = v69;
          v22 = v65;
          v66 = v65;
        }
      }
      else
      {
        v22 = 0;
      }
      v72[0] = v19;
      v68 = v22;
      if (v22 == v5)
        goto LABEL_21;
    }
    v28 = (_OWORD *)(a1 + 1166);
    v29 = *(_OWORD *)(a1 + 1148);
    *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
    *(_OWORD *)(a1 + 1246) = v29;
    *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
    v30 = *(_OWORD *)(a1 + 1084);
    *(_OWORD *)(a1 + 1166) = *v16;
    *(_OWORD *)(a1 + 1182) = v30;
    v31 = *(_OWORD *)(a1 + 1116);
    *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
    *(_OWORD *)(a1 + 1214) = v31;
    v17 = spaceman_fxc_search_walk(a1, a1 + 1166, v64, v63, v11, a2, v4, v5, 0xFFFFFFFFFFFFFFFFLL, v72, &v68, &v71, &v67, 0x301u);
    if (!v17)
    {
      v32 = *(_OWORD *)(a1 + 1148);
      *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
      *(_OWORD *)(a1 + 1246) = v32;
      *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
      v33 = *(_OWORD *)(a1 + 1084);
      *v28 = *v16;
      *(_OWORD *)(a1 + 1182) = v33;
      v34 = *(_OWORD *)(a1 + 1116);
      *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
      *(_OWORD *)(a1 + 1214) = v34;
      v17 = spaceman_fxc_search_walk(a1, a1 + 1166, v64, v63, v11, a2, v4, v5, 0xFFFFFFFFFFFFFFFFLL, v72, &v68, &v71, &v67, 0x502u);
      if (!v17)
      {
        v38 = v67;
        if (v68 >= v5 || v67 <= v68)
        {
          v39 = v67;
          v38 = v68;
        }
        else
        {
          v39 = 0;
          v40 = v71;
          v71 = 0;
          v72[0] = v40;
          v67 = 0;
          v68 = v38;
          a2 &= ~0x2000u;
        }
        if (v38 < v5 && (a2 & 0x1000) == 0)
          goto LABEL_21;
        if (v4 <= v72[0])
        {
          v41 = v72[0] - v4;
        }
        else
        {
          if (v4 - v72[0] < v38)
            goto LABEL_21;
          v41 = v4 - (v38 + v72[0]);
        }
        if (!v41)
          goto LABEL_21;
        v57 = v39;
        v60 = v72[0];
        v61 = v38;
        v62 = v41;
        v17 = spaceman_fxc_tree_search(a1, 0, v4, v5, a1 + 1068);
        if (!v17)
        {
          if (*((_WORD *)v16 + 2 * *(unsigned __int8 *)(a1 + 1165)))
          {
            v43 = (_QWORD *)(*(_QWORD *)(a1 + 80)
                           + 24 * *((unsigned __int16 *)v16 + 2 * *(unsigned __int8 *)(a1 + 1165)));
            v44 = *v43 & 0xFFFFFFFFFFFFFLL;
            v70 = v44;
            v45 = v43[1] & 0xFFFFFFFFFFFFFLL;
            v66 = v45;
            if (v64)
            {
              spaceman_clip_extent(v44, v45, v63, v11, a2, v4, (unint64_t *)&v70, (unint64_t *)&v66);
              v45 = v66;
              v44 = v70;
            }
            if (v45)
            {
              v46 = spaceman_clip_extent_to_zones(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(unsigned __int8 *)(a1 + 88), v44, v45, a2, v4, (unint64_t *)&v69, &v65);
              v44 = v70;
              v47 = v66;
              if (v46)
              {
                v48 = v57;
                v55 = v70;
                v58 = v66;
                if (new_extent_is_better(v4, v5, v71, v48, v70, v66, a2))
                {
                  v71 = v55;
                  v67 = v58;
                }
                v44 = v69;
                v70 = v69;
                v47 = v65;
                v66 = v65;
              }
            }
            else
            {
              v47 = 0;
            }
            v56 = v44;
            v59 = v47;
            if (new_extent_is_better(v4, v5, v60, v61, v44, v47, a2))
            {
              v72[0] = v56;
              v68 = v59;
              goto LABEL_21;
            }
          }
          v49 = *(_OWORD *)(a1 + 1148);
          *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
          *(_OWORD *)(a1 + 1246) = v49;
          *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
          v50 = *(_OWORD *)(a1 + 1084);
          *v28 = *v16;
          *(_OWORD *)(a1 + 1182) = v50;
          v51 = *(_OWORD *)(a1 + 1116);
          *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
          *(_OWORD *)(a1 + 1214) = v51;
          v17 = spaceman_fxc_search_walk(a1, a1 + 1166, v64, v63, v11, a2, v4, v5, v62, v72, &v68, &v71, &v67, 0x1802u);
          if (!v17)
          {
            v52 = *(_OWORD *)(a1 + 1148);
            *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
            *(_OWORD *)(a1 + 1246) = v52;
            *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
            v53 = *(_OWORD *)(a1 + 1084);
            *v28 = *v16;
            *(_OWORD *)(a1 + 1182) = v53;
            v54 = *(_OWORD *)(a1 + 1116);
            *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
            *(_OWORD *)(a1 + 1214) = v54;
            v17 = spaceman_fxc_search_walk(a1, a1 + 1166, v64, v63, v11, a2, v4, v5, v62, v72, &v68, &v71, &v67, 0x1801u);
            if (!v17)
            {
LABEL_21:
              if (*(_QWORD *)a1)
                pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
              v24 = v68;
              if (!v68 && v67)
              {
                v72[0] = v71;
                v24 = v67;
              }
              v25 = v24 - v5;
              if (v24 > v5)
              {
                v26 = *(_QWORD *)(a1 + 368) + v25;
                ++*(_QWORD *)(a1 + 360);
                *(_QWORD *)(a1 + 368) = v26;
                if (v25 == 1)
                {
                  result = 0;
                  v27 = (_QWORD *)(a1 + 400);
                }
                else if (v25 > 7)
                {
                  result = 0;
                  if (v25 > 0xF)
                    v27 = (_QWORD *)(a1 + 376);
                  else
                    v27 = (_QWORD *)(a1 + 384);
                }
                else
                {
                  result = 0;
                  v27 = (_QWORD *)(a1 + 392);
                }
                goto LABEL_63;
              }
              if (v24 >= v5)
              {
                result = 0;
                ++*(_QWORD *)(a1 + 408);
                if (v24)
                {
LABEL_64:
                  v42 = (_QWORD *)(a1 + 352);
LABEL_80:
                  ++*v42;
                  *a3 = v72[0];
                  *a4 = v24;
                  return result;
                }
              }
              else
              {
                if ((a2 & 0x1000) != 0)
                  v37 = 0;
                else
                  v37 = 28;
                if (spaceman_fxc_bitmap_should_be_searched(a1, a2, v5, v24))
                  result = 3;
                else
                  result = v37;
                if ((a2 & 0x1000) != 0)
                {
                  if (v24)
                  {
                    v27 = (_QWORD *)(a1 + 416);
                    v5 = v24;
LABEL_63:
                    ++*v27;
                    v24 = v5;
                    goto LABEL_64;
                  }
                  if ((_DWORD)result)
                    result = result;
                  else
                    result = 28;
                }
                else
                {
                  v72[0] = 0;
                }
              }
              v24 = 0;
              v42 = (_QWORD *)(a1 + 424);
              goto LABEL_80;
            }
          }
        }
      }
    }
  }
  v35 = *(unsigned __int8 *)(a1 + 88);
  v36 = "main";
  if (v35 == 1)
    v36 = "tier2";
  log_err("%s:%d: %s dev %d Error searching %s free extent cache: %d; Reinitializing.\n",
    "spaceman_free_extent_cache_search",
    3031,
    (const char *)(*(_QWORD *)(*(_QWORD *)a1 + 384) + 208),
    v35,
    v36,
    v17);
  spaceman_free_extent_cache_reset(a1);
  if (*(_QWORD *)a1)
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  return 3;
}

uint64_t spaceman_fxc_search_walk(uint64_t a1, uint64_t a2, int a3, unint64_t a4, uint64_t a5, __int16 a6, unint64_t a7, unint64_t a8, unint64_t a9, uint64_t *a10, unint64_t *a11, uint64_t *a12, unint64_t *a13, unsigned int a14)
{
  uint64_t v15;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unsigned int v25;
  _QWORD *v26;
  unint64_t v27;
  unint64_t v28;
  __int16 v29;
  uint64_t v30;
  int v31;
  __int16 v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  BOOL v36;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v43;
  int v44;
  uint64_t v45;
  __int16 v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;

  if ((a14 & 3) == 0 || (a14 & 0x1F00) == 0)
    return 22;
  v21 = a2;
  v22 = a1;
  v49 = 0;
  v50 = 0;
  v47 = 0;
  v48 = 0;
  if ((a14 & 1) != 0)
    v23 = 1;
  else
    v23 = -1;
  v15 = spaceman_fxc_tree_adjacent(a1, a2, v23);
  if ((v15 & 0xFFFFFFFD) == 0)
  {
    v44 = a3;
    v39 = a5;
    v46 = a6;
    v25 = 0;
    v43 = (char)v23;
    v45 = a7;
    v40 = v22;
    v41 = v21;
    do
    {
      if ((_DWORD)v15 == 2)
        return 0;
      v26 = (_QWORD *)(*(_QWORD *)(v22 + 80) + 24 * *(unsigned __int16 *)(v21 + 4 * *(unsigned __int8 *)(v21 + 97)));
      v27 = *v26 & 0xFFFFFFFFFFFFFLL;
      v50 = v27;
      v28 = v26[1] & 0xFFFFFFFFFFFFFLL;
      v48 = v28;
      if (v44)
      {
        v29 = v46;
        spaceman_clip_extent(v27, v28, a4, v39, v46, a7, &v50, &v48);
        v30 = v48;
        if (!v48)
          goto LABEL_39;
      }
      else
      {
        v30 = v28;
        v29 = v46;
        if (!v28)
        {
LABEL_39:
          if ((a14 & 0x1000) != 0 && v25 > 0x7E)
            return v15;
          goto LABEL_44;
        }
      }
      v31 = spaceman_clip_extent_to_zones(*(_QWORD *)v22, *(_QWORD *)(v22 + 8), *(unsigned __int8 *)(v22 + 88), v50, v30, v29, a7, (unint64_t *)&v49, &v47);
      v32 = v29;
      v33 = v50;
      v34 = v48;
      if (v31)
      {
        if (new_extent_is_better(a7, a8, *a12, *a13, v50, v48, v32))
        {
          *a12 = v33;
          *a13 = v34;
        }
        v33 = v49;
        v50 = v49;
        v34 = v47;
        v48 = v47;
      }
      v35 = *a11;
      if (new_extent_is_better(v45, a8, *a10, *a11, v33, v34, v46))
      {
        *a10 = v33;
        *a11 = v34;
        v35 = v34;
        if ((a14 & 0x800) != 0)
          return v15;
      }
      v36 = v34 == v28 && (v28 == a8) & BYTE1(a14);
      if (v36 || ((v35 > a8) & (a14 >> 9)) != 0)
        return v15;
      if ((a14 & 0x400) != 0 && v28 < a8 && v28 <= v35)
        return v15;
      a7 = v45;
      v22 = v40;
      v21 = v41;
      if ((a14 & 0x1000) != 0)
      {
        if (v25 > 0x7E)
          return v15;
        v38 = v33 - v45;
        if (v33 < v45)
        {
          if (v45 - v33 >= v34)
            v38 = v45 - v33 - v34;
          else
            v38 = 0;
        }
        if (v38 >= a9)
          return v15;
      }
LABEL_44:
      v15 = spaceman_fxc_tree_adjacent(v22, v21, v43);
      ++v25;
    }
    while ((v15 & 0xFFFFFFFD) == 0);
  }
  return v15;
}

BOOL new_extent_is_better(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, __int16 a7)
{
  _BOOL8 result;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;

  if (!a6)
    return 0;
  if (!a4)
    return 1;
  if (a4 < a2)
  {
    if (a6 <= a4)
    {
      if (a6 != a4 || (a7 & 0x4000) == 0)
        return 0;
      if (a1 <= a3)
        v9 = a3 - a1;
      else
        v9 = a1 - a3 >= a6 ? a1 - (a3 + a6) : 0;
      if (a1 <= a5)
        v12 = a5 - a1;
      else
        v12 = a1 - a5 >= a6 ? a1 - (a5 + a6) : 0;
      if (v12 >= v9)
        return 0;
    }
    return 1;
  }
  if (a4 != a2)
  {
    v10 = a4 - a2;
    if (a4 > a2)
    {
      v11 = a6 - a2;
      if (a6 >= a2)
      {
        if (a6 == a2 || v10 <= 0xF && v11 > v10)
          return 1;
        if ((a7 & 0x4000) != 0)
        {
          if (a1 <= a3)
          {
            v14 = a3 - a1;
          }
          else if (a1 - a3 >= a4)
          {
            v14 = a1 - (a3 + a4);
          }
          else
          {
            v14 = 0;
          }
          if (a1 <= a5)
          {
            v15 = a5 - a1;
          }
          else if (a1 - a5 >= a6)
          {
            v15 = a1 - (a5 + a6);
          }
          else
          {
            v15 = 0;
          }
          return v11 >= 0x10 && v15 < v14;
        }
        if (v11 < v10 && v11 > 0xF)
          return 1;
      }
    }
    return 0;
  }
  if (a6 < a4 || a6 != a4 && (a7 & 0x4000) == 0)
    return 0;
  if (a1 <= a3)
    v8 = a3 - a1;
  else
    v8 = a1 - a3 >= a4 ? a1 - (a3 + a4) : 0;
  if (a1 <= a5)
    v13 = a5 - a1;
  else
    v13 = a1 - a5 >= a6 ? a1 - (a5 + a6) : 0;
  if (v13 >= v8)
    return 0;
  result = 1;
  if (a6 != a4 && a6 - a4 <= 0xF)
    return 0;
  return result;
}

uint64_t spaceman_fxc_bitmap_should_be_searched(uint64_t a1, __int16 a2, unint64_t a3, unint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  int64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t result;
  _QWORD *v29;
  unint64_t v30;
  unint64_t v31;
  unsigned int v32;
  int v33;
  signed int v34;
  int v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  _QWORD *v41;
  unint64_t v42;

  v8 = a3;
  if ((a2 & 0x1000) != 0)
  {
    if (a4 > 1)
    {
      if (a4 + (a4 >> 1) >= a3)
        v8 = a3;
      else
        v8 = a4 + (a4 >> 1);
    }
    else
    {
      v8 = a4 + 1;
    }
  }
  v9 = *(_QWORD *)(a1 + 200);
  v10 = *(_QWORD *)(a1 + 208);
  v11 = *(_QWORD *)(a1 + 160);
  if (*(_QWORD *)(a1 + 152) > v9)
    v9 = *(_QWORD *)(a1 + 152);
  v12 = *(_QWORD *)(a1 + 168);
  v42 = v8;
  if (v10)
  {
    v14 = v10 - v11;
    v13 = v10 <= v11;
    v15 = v12 + v11;
    if (v10 < v11)
      v11 = *(_QWORD *)(a1 + 208);
    if (v13)
      v16 = 0;
    else
      v16 = v14;
    v17 = *(_QWORD *)(a1 + 216) + v16;
    if (v15 > v17 + v11)
      v12 = v15 - v11;
    else
      v12 = v17;
  }
  v18 = *(_QWORD *)(a1 + 136);
  v19 = *(_QWORD *)(a1 + 144);
  v21 = *(_QWORD *)(a1 + 184);
  v20 = *(_QWORD *)(a1 + 192);
  v23 = *(_QWORD *)(a1 + 248);
  v22 = *(_QWORD *)(a1 + 256);
  if (v9 <= v23)
    v24 = *(_QWORD *)(a1 + 248);
  else
    v24 = v9;
  v25 = calc_overlap_range(v22, *(_QWORD *)(a1 + 264), v11, v12, 0);
  v26 = *(_QWORD *)(a1 + 96);
  v27 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 376) + 48 * *(_DWORD *)(a1 + 88) + 72);
  if (v26 == v27)
    goto LABEL_22;
  if ((*(_BYTE *)(a1 + 280) & 1) == 0)
  {
LABEL_53:
    *(_QWORD *)(a1 + 440) = 0;
    v29 = (_QWORD *)(a1 + 448);
    result = 1;
    goto LABEL_54;
  }
  v30 = v20 + v19;
  if (!v26 && v27 && v30 + *(_QWORD *)(a1 + 240))
  {
    v41 = (_QWORD *)(a1 + 456);
    goto LABEL_52;
  }
  if ((a2 & 0x1000) == 0 || a4 <= (3 * a3) >> 2)
  {
    if (v24 >= v42)
    {
      v41 = (_QWORD *)(a1 + 464);
      goto LABEL_52;
    }
    if (v24 <= a4)
      v31 = a4;
    else
      v31 = v24;
    if (v42 <= *(_QWORD *)(a1 + 240) + v30 + v31 + v31 * (v18 + v21 + *(_QWORD *)(a1 + 232)))
    {
      v32 = *(unsigned __int16 *)(a1 + 94);
      v33 = *(_DWORD *)(a1 + 88) >> 8;
      v34 = v33 - 1;
      v35 = v33 - v32;
      if (v35 <= 4)
        LODWORD(v36) = v35 + 4;
      else
        LODWORD(v36) = 8;
      v36 = (int)v36;
      if (v34 <= (int)v32)
        v36 = 4;
      v37 = (64 - v42) >> 4;
      if (v42 >= 0x40)
        v37 = 0;
      v38 = v36 + v37 + (*(_QWORD *)(a1 + 440) >> 14);
      if (v34 / 10 <= v32)
      {
        v39 = *(_QWORD *)(a1 + 128);
        if (v39 < *(_QWORD *)(a1 + 328))
        {
          v40 = *(_QWORD *)(a1 + 176);
          if (v40 <= *(_QWORD *)(a1 + 224))
            v40 = *(_QWORD *)(a1 + 224);
          if (v40 >= *(_QWORD *)(a1 + 248) && v39 - *(_QWORD *)(a1 + 120) < 4)
            v38 = 1;
        }
      }
      if (v30 > (v12 - v25 + *(_QWORD *)(a1 + 264)) / v38)
      {
        v41 = (_QWORD *)(a1 + 472);
LABEL_52:
        ++*v41;
        goto LABEL_53;
      }
    }
  }
LABEL_22:
  result = 0;
  ++*(_QWORD *)(a1 + 440);
  v29 = (_QWORD *)(a1 + 432);
LABEL_54:
  ++*v29;
  return result;
}

uint64_t spaceman_fxc_tree_first(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  unsigned int v7;

  *(_WORD *)(a2 + 96) = 0;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_BYTE *)(a2 + 96) = 0;
  v4 = *(unsigned __int16 *)(a1 + 104);
  *(_WORD *)a2 = v4;
  if (v4)
    *(_BYTE *)(a2 + 2) = *(_BYTE *)(*(_QWORD *)(a1 + 80) + 24 * v4 + 7);
  while (1)
  {
    v5 = *(unsigned __int8 *)(a2 + 97);
    if (!*(_WORD *)(a2 + 4 * v5))
      break;
    result = spaceman_fxtp_add_child(a1, a2, -1);
    if ((_DWORD)result)
      return result;
  }
  v7 = v5 - 1;
  *(_BYTE *)(a2 + 97) = v7;
  return (v7 >> 6) & 2;
}

uint64_t spaceman_fxtp_add_child(uint64_t a1, uint64_t a2, __int16 a3)
{
  int v3;
  uint64_t v4;
  const char *v5;
  uint64_t result;
  unsigned __int8 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;

  v3 = *(char *)(a2 + 97);
  v4 = *(unsigned __int8 *)(a2 + 97);
  *(_BYTE *)(a2 + 4 * v4 + 3) = a3;
  if (v3 < 23)
  {
    v7 = v4 + 1;
    *(_BYTE *)(a2 + 97) = v4 + 1;
    v8 = *(_QWORD *)(a1 + 80);
    v9 = *(unsigned __int8 *)(a2 + 96);
    v10 = *(unsigned __int16 *)(v8 + 24 * *(unsigned __int16 *)(a2 + 4 * v4) + 4 * v9 + ((a3 + 1) & 0x1FE) + 16);
    v11 = (v4 + 1);
    v12 = a2 + 4 * v7;
    *(_WORD *)v12 = v10;
    *(_BYTE *)(v12 + 3) = 0;
    if (v10)
    {
      if ((_DWORD)v9)
        v13 = *(_BYTE *)(v8 + 24 * v10 + 15);
      else
        v13 = *(_BYTE *)(v8 + 24 * v10 + 7);
    }
    else
    {
      v13 = 0;
    }
    result = 0;
    *(_BYTE *)(a2 + 4 * v11 + 2) = v13;
  }
  else
  {
    v5 = "length";
    if (!*(_BYTE *)(a2 + 96))
      v5 = "paddr";
    log_err("%s:%d: %s dev %d %s tree: PATH TOO LONG: %d\n", "spaceman_fxtp_add_child", 752, (const char *)(*(_QWORD *)(*(_QWORD *)a1 + 384) + 208), *(unsigned __int8 *)(a1 + 88), v5, v4);
    return 84;
  }
  return result;
}

uint64_t spaceman_fxc_tree_adjacent(uint64_t a1, uint64_t a2, int a3)
{
  int v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  _BYTE *v11;
  int v12;
  unsigned __int8 v13;

  v4 = -a3;
  v5 = *(unsigned __int8 *)(a2 + 97);
  if (*(_WORD *)(*(_QWORD *)(a1 + 80)
                + 24 * *(unsigned __int16 *)(a2 + 4 * v5)
                + 4 * *(unsigned __int8 *)(a2 + 96)
                + (((_WORD)a3 + 1) & 0x1FE)
                + 16))
  {
    result = spaceman_fxtp_add_child(a1, a2, a3);
    if (!(_DWORD)result)
    {
      while (1)
      {
        v8 = *(unsigned __int8 *)(a2 + 97);
        if (!*(_WORD *)(a2 + 4 * v8))
          break;
        result = spaceman_fxtp_add_child(a1, a2, (char)v4);
        if ((_DWORD)result)
          return result;
      }
      v13 = v8 - 1;
      *(_BYTE *)(a2 + 97) = v13;
      v11 = (_BYTE *)(a2 + 4 * v13 + 3);
LABEL_12:
      result = 0;
      *v11 = 0;
    }
  }
  else
  {
    LODWORD(v5) = (char)v5;
    while (1)
    {
      v9 = __OFSUB__((_DWORD)v5, 1);
      LODWORD(v5) = v5 - 1;
      if ((int)v5 < 0 != v9)
        return 2;
      v10 = a2 + 4 * v5;
      v12 = *(unsigned __int8 *)(v10 + 3);
      v11 = (_BYTE *)(v10 + 3);
      if (v12 == v4)
      {
        *(_BYTE *)(a2 + 97) = v5;
        goto LABEL_12;
      }
    }
  }
  return result;
}

uint64_t spaceman_fxc_tree_single_rotate(uint64_t result, unsigned int a2, int a3, unsigned int a4, unsigned __int16 *a5)
{
  uint64_t v5;
  uint64_t v6;
  unsigned __int16 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  unint64_t v13;
  _QWORD *v14;

  v5 = *(_QWORD *)(result + 80);
  v6 = v5
     + 24 * a4
     + 4 * a2
     + 2 * (((char)-(char)a3 + 1 + ((((char)-(char)a3 + 1) & 0x8000u) >> 15)) >> 1);
  v7 = *(_WORD *)(v6 + 16);
  v8 = v5 + 24 * v7;
  v9 = v8 + 4 * a2 + 2 * ((a3 + 1 + (((a3 + 1) & 0x8000u) >> 15)) >> 1);
  *(_WORD *)(v6 + 16) = *(_WORD *)(v9 + 16);
  *(_WORD *)(v9 + 16) = a4;
  *a5 = v7;
  v10 = v8 + 8;
  if (!a2)
    v10 = v5 + 24 * v7;
  if (*(_BYTE *)(v10 + 7))
  {
    v14 = (_QWORD *)(v5 + 24 * a4);
    if (a2)
      ++v14;
    *v14 &= 0xFFFFFFFFFFFFFFuLL;
    v13 = *(_QWORD *)v10 & 0xFFFFFFFFFFFFFFLL;
  }
  else
  {
    v11 = (uint64_t *)(v5 + 24 * a4);
    if (a2)
      ++v11;
    v12 = *v11;
    if (a3 == -1)
    {
      *v11 = v12 & 0xFFFFFFFFFFFFFFLL | 0x100000000000000;
      v13 = *(_QWORD *)v10 | 0xFF00000000000000;
    }
    else
    {
      *v11 = v12 | 0xFF00000000000000;
      v13 = *(_QWORD *)v10 & 0xFFFFFFFFFFFFFFLL | 0x100000000000000;
    }
  }
  *(_QWORD *)v10 = v13;
  return result;
}

uint64_t spaceman_fxc_tree_double_rotate(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4, unsigned int a5, _WORD *a6)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  unsigned __int8 v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;

  v6 = *(_QWORD *)(a1 + 80);
  v7 = v6
     + 24 * a5
     + 4 * a2
     + 2 * (((char)-(char)a3 + 1 + ((((char)-(char)a3 + 1) & 0x8000u) >> 15)) >> 1);
  v8 = *(unsigned __int16 *)(v7 + 16);
  v9 = v6 + 24 * *(unsigned __int16 *)(v7 + 16);
  v10 = v9 + 4 * a2 + 16;
  result = *(unsigned __int16 *)(v10
                               + 2 * (((_DWORD)a3 + 1 + ((((_DWORD)a3 + 1) & 0x8000u) >> 15)) >> 1));
  *(_WORD *)(v7 + 16) = result;
  *(_WORD *)(v10 + 2 * (((_DWORD)a3 + 1 + ((((_DWORD)a3 + 1) & 0x8000u) >> 15)) >> 1)) = a5;
  *(_WORD *)(v6
           + 24 * a4
           + 4 * a2
           + 2 * (((_DWORD)a3 + 1 + ((((_DWORD)a3 + 1) & 0x8000u) >> 15)) >> 1)
           + 16) = *(_WORD *)(v10
                            + 2
                            * (((char)-(char)a3 + 1 + ((((char)-(char)a3 + 1) & 0x8000u) >> 15)) >> 1));
  *(_WORD *)(v10 + 2 * (((char)-(char)a3 + 1 + ((((char)-(char)a3 + 1) & 0x8000u) >> 15)) >> 1)) = a4;
  *a6 = v8;
  if (a2)
    v12 = *(_BYTE *)(v6 + 24 * v8 + 15);
  else
    v12 = *(_BYTE *)(v9 + 7);
  if (v12 == a3)
  {
    v13 = v6 + 24 * a4;
    if (a2)
      v13 += 8;
    *(_BYTE *)(v13 + 7) = -(char)a3;
    v14 = (uint64_t *)(v6 + 24 * a5);
    if (a2)
      ++v14;
    v15 = *v14 & 0xFFFFFFFFFFFFFFLL;
  }
  else
  {
    v16 = (_QWORD *)(v6 + 24 * a4);
    if (a2)
      ++v16;
    *v16 &= 0xFFFFFFFFFFFFFFuLL;
    v14 = (uint64_t *)(v6 + 24 * a5);
    if (a2)
      ++v14;
    v15 = *v14 & 0xFFFFFFFFFFFFFFLL;
    if (v12)
      v15 |= a3 << 56;
  }
  *v14 = v15;
  v17 = (_QWORD *)(v6 + 24 * v8 + 8);
  if (!a2)
    v17 = (_QWORD *)v9;
  *v17 &= 0xFFFFFFFFFFFFFFuLL;
  return result;
}

void crc32c_init()
{
  void *v0;
  unsigned int v1;
  int i;
  unsigned int v3;
  unsigned int v4;

  v0 = crc32c;
  if (!crc32c)
  {
    do
    {
      v1 = 0;
      for (i = 0; i != 8; ++i)
      {
        v3 = (v0 >> i) ^ v1;
        v4 = v1 >> 1;
        v1 = (v1 >> 1) ^ 0x82F63B78;
        if ((v3 & 1) == 0)
          v1 = v4;
      }
      crc32c_table[(_QWORD)v0] = v1;
      v0 = (char *)v0 + 1;
    }
    while (v0 != (void *)256);
    crc32c = crc32c_soft;
  }
}

uint64_t crc32c_soft(uint64_t result, char *a2, uint64_t a3)
{
  char v3;

  for (; a3; --a3)
  {
    v3 = *a2++;
    result = crc32c_table[(v3 ^ result)] ^ (result >> 8);
  }
  return result;
}

uint64_t apfs_source_version_val_full()
{
  return 2313002001000000;
}

uint64_t rolling_stats_init(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t result;
  void *v7;
  timespec v8;

  result = new_lock((pthread_mutex_t *)a1);
  if (!(_DWORD)result)
  {
    v8.tv_sec = 0;
    v8.tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v8);
    *(_QWORD *)(a1 + 64) = v8.tv_sec / a2 * a2;
    *(_DWORD *)(a1 + 72) = a2;
    *(_DWORD *)(a1 + 76) = a3;
    v7 = _apfs_calloc(a3, 8uLL);
    *(_QWORD *)(a1 + 80) = v7;
    if (v7)
    {
      result = 0;
      *(_QWORD *)(a1 + 88) = 0;
    }
    else
    {
      free_lock((pthread_mutex_t *)a1);
      return 12;
    }
  }
  return result;
}

uint64_t rolling_stats_destroy(uint64_t a1)
{
  _apfs_free(*(void **)(a1 + 80), 8 * *(unsigned int *)(a1 + 76));
  *(_QWORD *)(a1 + 80) = 0;
  return free_lock((pthread_mutex_t *)a1);
}

BOOL bitmap_range_is_set(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  if (a2 >= 0)
    v3 = a2;
  else
    v3 = a2 + 63;
  v4 = v3 >> 6;
  v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0);
  v6 = 0xFFFFFFFFFFFFFFFFLL >> ((v3 & 0xC0u) - a2);
  if (a3 >= 64)
  {
    while (((-1 << v5) & ~((-1 << v5) & *(_QWORD *)(a1 + 8 * v4))) == 0
         && (!v5 || (v6 & ~*(_QWORD *)(a1 + 8 * v4 + 8)) == 0))
    {
      v7 = a3 - 64;
      ++v4;
      v8 = a3 <= 127;
      a3 -= 64;
      if (v8)
      {
        if (v7)
          goto LABEL_13;
        return 1;
      }
    }
    return 0;
  }
  v7 = a3;
  if (!a3)
    return 1;
LABEL_13:
  v9 = ~(-1 << v7);
  v10 = v9 << v5;
  v11 = v9 >> (64 - v5);
  if (!v5)
    v11 = 0;
  return (v10 & ~((-1 << v5) & *(_QWORD *)(a1 + 8 * v4))) == 0
      && (v7 <= (uint64_t)(64 - v5) || !v11 || (v11 & ~(v6 & *(_QWORD *)(a1 + 8 * v4 + 8))) == 0);
}

uint64_t bitmap_range_is_clear(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  if (a2 >= 0)
    v3 = a2;
  else
    v3 = a2 + 63;
  v4 = v3 >> 6;
  v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0);
  v6 = 64 - v5;
  if (a3 >= 64)
  {
    while (((-1 << v5) & *(_QWORD *)(a1 + 8 * v4)) == 0
         && (!v5 || (*(_QWORD *)(a1 + 8 * v4 + 8) & (0xFFFFFFFFFFFFFFFFLL >> v6)) == 0))
    {
      v7 = a3 - 64;
      ++v4;
      v8 = a3 <= 127;
      a3 -= 64;
      if (v8)
      {
        if (v7)
          goto LABEL_13;
        return 1;
      }
    }
    return 0;
  }
  v7 = a3;
  if (a3)
  {
LABEL_13:
    v9 = ~(-1 << v7);
    v10 = v9 << v5;
    v11 = v9 >> v6;
    if (!v5)
      v11 = 0;
    if ((v10 & (-1 << v5) & *(_QWORD *)(a1 + 8 * v4)) != 0
      || v7 > v6 && v11 && ((0xFFFFFFFFFFFFFFFFLL >> v6) & v11 & *(_QWORD *)(a1 + 8 * v4 + 8)) != 0)
    {
      return 0;
    }
  }
  return 1;
}

uint64_t bitmap_set_range(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  if (a2 >= 0)
    v3 = a2;
  else
    v3 = a2 + 63;
  v4 = v3 >> 6;
  v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0);
  v6 = 64 - v5;
  if (a3 < 64)
  {
    v7 = a3;
    if (!a3)
      return result;
    goto LABEL_12;
  }
  do
  {
    *(_QWORD *)(result + 8 * v4) = *(_QWORD *)(result + 8 * v4) & ~(-1 << v5) | (-1 << v5);
    if (v5)
      *(_QWORD *)(result + 8 * v4 + 8) |= 0xFFFFFFFFFFFFFFFFLL >> v6;
    v7 = a3 - 64;
    ++v4;
    v8 = a3 <= 127;
    a3 -= 64;
  }
  while (!v8);
  if (v7)
  {
LABEL_12:
    v9 = ~(-1 << v7);
    v10 = v9 << v5;
    v11 = v9 >> v6;
    if (!v5)
      v11 = 0;
    *(_QWORD *)(result + 8 * v4) = *(_QWORD *)(result + 8 * v4) & ~v10 | v10 & (-1 << v5);
    if (v7 > v6)
    {
      if (v11)
        *(_QWORD *)(result + 8 * v4 + 8) = *(_QWORD *)(result + 8 * v4 + 8) & ~v11 | v11 & (0xFFFFFFFFFFFFFFFFLL >> v6);
    }
  }
  return result;
}

uint64_t bitmap_clear_range(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;

  if (a2 >= 0)
    v3 = a2;
  else
    v3 = a2 + 63;
  v4 = v3 >> 6;
  v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0);
  v6 = 64 - v5;
  if (a3 < 64)
  {
    v7 = a3;
    if (!a3)
      return result;
    goto LABEL_12;
  }
  do
  {
    *(_QWORD *)(result + 8 * v4) &= ~(-1 << v5);
    if (v5)
      *(_QWORD *)(result + 8 * v4 + 8) &= ~(0xFFFFFFFFFFFFFFFFLL >> v6);
    v7 = a3 - 64;
    ++v4;
    v8 = a3 <= 127;
    a3 -= 64;
  }
  while (!v8);
  if (v7)
  {
LABEL_12:
    v9 = ~(-1 << v7);
    v10 = v9 << v5;
    v11 = v9 >> v6;
    if (v5)
      v12 = v11;
    else
      v12 = 0;
    *(_QWORD *)(result + 8 * v4) &= ~v10;
    if (v7 > v6)
    {
      if (v12)
        *(_QWORD *)(result + 8 * v4 + 8) &= ~v12;
    }
  }
  return result;
}

uint64_t bitmap_range_find_first(int a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v5;
  unint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;

  if (a4 < 1)
    return 0;
  if (a1)
    v5 = 0;
  else
    v5 = -1;
  v6 = (unint64_t *)(a2 + 8 * (a3 / 64));
  while (1)
  {
    v7 = a3 & 0x3F;
    if (a3 <= 0)
      v7 = -(-a3 & 0x3F);
    v8 = 64 - v7;
    v10 = *v6++;
    v9 = v10;
    if (64 - v7 >= (unint64_t)a4)
      v8 = a4;
    v11 = __clz(__rbit64((v9 >> v7) ^ v5));
    if (v8 > v11)
      break;
    a3 += v8;
    v12 = a4 <= (uint64_t)v8;
    a4 -= v8;
    if (v12)
      return 0;
  }
  *a5 = v11 + a3;
  return 1;
}

uint64_t bitmap_range_find_last_set(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  int64_t v10;
  BOOL v11;

  if (a3 < 1)
    return 0;
  v4 = a3 + a2;
  v5 = a3 + a2 - 1;
  if (a3 + a2 < 1)
    v5 = a3 + a2 + 62;
  v6 = (uint64_t *)(a1 + 8 * (v5 >> 6));
  while (1)
  {
    if (v4 <= 0)
      v7 = -(-v4 & 0x3F);
    else
      v7 = v4 & 0x3F;
    v8 = 64 - v7;
    if (!v7)
    {
      v7 = 64;
      v8 = 0;
    }
    if (v7 >= a3)
      v7 = a3;
    v9 = *v6--;
    v10 = __clz(v9 << v8);
    if (v7 > v10)
      break;
    v4 -= v7;
    v11 = a3 <= v7;
    a3 -= v7;
    if (v11)
      return 0;
  }
  *a4 = v4 + ~v10;
  return 1;
}

BOOL bitmap_range_find_desired_or_first_clear_range(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, int a7)
{
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;

  v12 = 0;
  v36 = 0;
  v34 = a4 - 1;
  v13 = -1;
  while (1)
  {
    if (v12 >= a2)
      goto LABEL_40;
    v14 = a4 - a3;
    if (a4 - a3 < 1)
      goto LABEL_40;
    v15 = 8 * (a3 / 64);
    while (1)
    {
      v16 = a3 & 0x3F;
      if (a3 <= 0)
        v16 = -(-a3 & 0x3F);
      v17 = 64 - v16;
      if (64 - v16 >= v14)
        v17 = v14;
      v18 = __clz(__rbit64(~(*(_QWORD *)(a1 + v15) >> v16)));
      if (v17 > v18)
        break;
      a3 += v17;
      v15 += 8;
      v19 = (uint64_t)v14 <= (uint64_t)v17;
      v14 -= v17;
      if (v19)
        goto LABEL_40;
    }
    v20 = v18 + a3;
    if ((uint64_t)(v18 + a3) >= a4 - v12)
    {
LABEL_40:
      v20 = v13;
      goto LABEL_41;
    }
    if (!v12)
    {
      v13 = v18 + a3;
      v12 = 1;
      if (v20 >= v34)
      {
        v12 = 1;
        goto LABEL_41;
      }
    }
    v35 = a5;
    v21 = v12 + 1;
    v22 = v12 + 1 < a4 - v20 ? v12 + 1 : a4 - v20;
    if (!bitmap_range_find_last_set(a1, v20, v22, &v36))
      break;
    a5 = v35;
    v23 = v36;
    v20 = v13;
LABEL_38:
    a3 = v23 + 1;
    if (a7)
      goto LABEL_41;
  }
  v24 = a2 - v21;
  if (a2 != v21)
  {
    v25 = v21 + v20;
    if (v24 >= a4 - (v21 + v20))
      v24 = a4 - (v21 + v20);
    if (v24 < 1)
    {
LABEL_35:
      v12 = v24 + v21;
    }
    else
    {
      v26 = v25 + 63;
      if (v25 >= 0)
        v26 = v21 + v20;
      v27 = (unint64_t *)(a1 + 8 * (v26 >> 6));
      v28 = v24;
      while (1)
      {
        v29 = v25 & 0x3F;
        if (v25 <= 0)
          v29 = -(-v25 & 0x3F);
        v30 = 64 - v29;
        if (64 - v29 >= v28)
          v30 = v28;
        v31 = *v27++;
        v32 = __clz(__rbit64(v31 >> v29));
        if (v30 > v32)
          break;
        v25 += v30;
        v19 = (uint64_t)v28 <= (uint64_t)v30;
        v28 -= v30;
        if (v19)
          goto LABEL_35;
      }
      v12 = v32 + v25 - v20;
    }
    a5 = v35;
    v23 = v12 + v20;
    v36 = v12 + v20;
    v13 = v20;
    goto LABEL_38;
  }
  v12 = a2;
  a5 = v35;
LABEL_41:
  *a5 = v20;
  *a6 = v12;
  return v12 == a2;
}

BOOL bitmap_range_find_clear_range(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  return bitmap_range_find_desired_or_first_clear_range(a1, a2, a3, a4, a5, a6, 0);
}

BOOL bitmap_range_find_first_clear_range(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  return bitmap_range_find_desired_or_first_clear_range(a1, a2, a3, a4, a5, a6, 1);
}

unint64_t bitmap_count_bits(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  unint64_t result;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;

  if (a3 >= a4)
    return 0;
  result = 0;
  if (a2)
    v6 = 0;
  else
    v6 = -1;
  if (a2)
    v7 = -1;
  else
    v7 = 0;
  do
  {
    v8 = a4 - a3;
    if (a4 - a3 < 1)
      break;
    v9 = (unint64_t *)(a1 + 8 * (a3 / 64));
    while (1)
    {
      v10 = a3 & 0x3F;
      if (a3 <= 0)
        v10 = -(-a3 & 0x3F);
      v11 = 64 - v10;
      v13 = *v9++;
      v12 = v13;
      if (64 - v10 >= v8)
        v11 = v8;
      v14 = __clz(__rbit64((v12 >> v10) ^ v6));
      if (v11 > v14)
        break;
      a3 += v11;
      v15 = (uint64_t)v8 <= (uint64_t)v11;
      v8 -= v11;
      if (v15)
        return result;
    }
    v16 = v14 + a3;
    v17 = a4 - (v14 + a3);
    if (v17 < 1)
      return result - v16 + a4;
    v18 = v16 + 63;
    if (v16 >= 0)
      v18 = v14 + a3;
    v19 = (unint64_t *)(a1 + 8 * (v18 >> 6));
    v20 = v14 + a3;
    while (1)
    {
      v21 = v20 & 0x3F;
      if (v20 <= 0)
        v21 = -(-v20 & 0x3F);
      v22 = 64 - v21;
      v24 = *v19++;
      v23 = v24;
      if (64 - v21 >= (unint64_t)v17)
        v22 = v17;
      v25 = __clz(__rbit64((v23 >> v21) ^ v7));
      if (v22 > v25)
        break;
      v20 += v22;
      v15 = v17 <= (uint64_t)v22;
      v17 -= v22;
      if (v15)
        return result - v16 + a4;
    }
    a3 = v25 + v20;
    result = result - v16 + v25 + v20;
  }
  while ((uint64_t)(v25 + v20) < a4);
  return result;
}

unint64_t fletcher64(uint32x4_t *a1, unint64_t a2, unint64_t a3, int8x16_t a4, int8x16_t a5)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t i;
  uint64_t v8;
  int64x2_t v9;
  int64x2_t v10;
  uint32x4_t v11;
  uint32x4_t v12;
  uint32x4_t v13;
  uint32x4_t v14;
  int64x2_t v15;
  uint64x2_t v16;
  uint64x2_t v17;
  int64x2_t v18;
  uint64x2_t v19;
  BOOL v20;
  uint64x2_t v21;
  uint32x4_t v22;
  uint64x2_t v23;
  int64x2_t v24;
  uint64x2_t v25;
  uint64x2_t v26;
  uint32x4_t v27;
  uint32x4_t v28;
  int64x2_t v29;
  uint32x4_t v30;
  int64x2_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unsigned __int32 v35;
  unint64_t v36;
  unint64_t v37;

  v5 = a3;
  v6 = HIDWORD(a3);
  if ((a2 & 3) == 0)
  {
    for (i = a2 >> 2; i; v6 = v34 + HIDWORD(v34))
    {
      if (i >= 0x16A00)
        v8 = 92672;
      else
        v8 = i;
      i -= v8;
      v9 = (int64x2_t)veorq_s8(a4, a4);
      v10 = (int64x2_t)veorq_s8(a5, a5);
      v9.i64[0] = v5;
      v10.i64[0] = v6;
      if (v8 >= 16)
      {
        v11 = *a1;
        v12 = a1[1];
        v13 = a1[2];
        v14 = a1[3];
        a1 += 4;
        v15 = vshlq_n_s64(v9, 4uLL);
        v16 = vmull_u32(*(uint32x2_t *)v12.i8, (uint32x2_t)constants[2]);
        v17 = vmull_u32(*(uint32x2_t *)v13.i8, (uint32x2_t)constants[4]);
        v18 = (int64x2_t)vmlal_u32(vmlal_u32((uint64x2_t)v10, *(uint32x2_t *)v11.i8, (uint32x2_t)constants[0]), *(uint32x2_t *)v14.i8, (uint32x2_t)constants[6]);
        v19 = vpadalq_u32(vpadalq_u32(vpadalq_u32((uint64x2_t)v9, v11), v12), v13);
        v20 = v8 < 32;
        for (v8 -= 32; !v20; v8 -= 16)
        {
          v21 = vmlal_high_u32(v16, v11, *(uint32x4_t *)constants);
          v22 = *a1;
          a1 += 4;
          v11 = v22;
          v23 = vmlal_high_u32(v17, v12, *(uint32x4_t *)&constants[2]);
          v12 = a1[-3];
          v24 = (int64x2_t)vpadalq_u32(v19, v14);
          v25 = vmlal_high_u32((uint64x2_t)vaddq_s64(v18, v15), v13, *(uint32x4_t *)&constants[4]);
          v13 = a1[-2];
          v26 = vmlal_high_u32(v21, v14, *(uint32x4_t *)&constants[6]);
          v14 = a1[-1];
          v15 = vshlq_n_s64(v24, 4uLL);
          v16 = vmlal_u32(v26, *(uint32x2_t *)v12.i8, (uint32x2_t)constants[2]);
          v17 = vmlal_u32(v23, *(uint32x2_t *)v13.i8, (uint32x2_t)constants[4]);
          v18 = (int64x2_t)vmlal_u32(vmlal_u32(v25, *(uint32x2_t *)v22.i8, (uint32x2_t)constants[0]), *(uint32x2_t *)v14.i8, (uint32x2_t)constants[6]);
          v19 = vpadalq_u32(vpadalq_u32(vpadalq_u32((uint64x2_t)v24, v22), v12), v13);
          v20 = v8 < 16;
        }
        v9 = (int64x2_t)vpadalq_u32(v19, v14);
        v10 = vaddq_s64(vaddq_s64((int64x2_t)vmlal_high_u32((uint64x2_t)vaddq_s64(v18, v15), v13, *(uint32x4_t *)&constants[4]), (int64x2_t)vmlal_high_u32(v17, v12, *(uint32x4_t *)&constants[2])), (int64x2_t)vmlal_high_u32(vmlal_high_u32(v16, v11, *(uint32x4_t *)constants), v14, *(uint32x4_t *)&constants[6]));
      }
      if ((v8 & 8) != 0)
      {
        v27 = *a1;
        a1 += 2;
        v28 = a1[-1];
        v29 = vshlq_n_s64(v9, 3uLL);
        v9 = (int64x2_t)vpadalq_u32(vpadalq_u32((uint64x2_t)v9, v27), v28);
        v10 = vaddq_s64((int64x2_t)vmlal_high_u32(vmlal_high_u32(vmlal_u32(vmlal_u32((uint64x2_t)v10, *(uint32x2_t *)v27.i8, (uint32x2_t)constants[4]), *(uint32x2_t *)v28.i8, (uint32x2_t)constants[6]), v27, *(uint32x4_t *)&constants[4]), v28, *(uint32x4_t *)&constants[6]), v29);
      }
      if ((v8 & 4) != 0)
      {
        v30 = *a1++;
        v31 = vshlq_n_s64(v9, 2uLL);
        v9 = (int64x2_t)vpadalq_u32((uint64x2_t)v9, v30);
        v10 = vaddq_s64((int64x2_t)vmlal_high_u32(vmlal_u32((uint64x2_t)v10, *(uint32x2_t *)v30.i8, (uint32x2_t)constants[6]), v30, *(uint32x4_t *)&constants[6]), v31);
      }
      v32 = v8 & 3;
      a4 = (int8x16_t)vpaddq_s64(v9, v9);
      a5 = (int8x16_t)vpaddq_s64(v10, v10);
      v33 = a4.i64[0];
      v34 = a5.i64[0];
      if (v32)
      {
        do
        {
          v35 = a1->i32[0];
          a1 = (uint32x4_t *)((char *)a1 + 4);
          v33 += v35;
          v34 += v33;
          v20 = v32-- <= 1;
        }
        while (!v20);
      }
      v5 = v33 + HIDWORD(v33);
    }
  }
  v36 = v5 + HIDWORD(v5);
  v37 = v6 + HIDWORD(v6);
  if (v36 == 0xFFFFFFFF)
    v36 = 0;
  if (v37 == 0xFFFFFFFF)
    v37 = 0;
  return v36 + (v37 << 32);
}

uint64_t nx_corruption_detected_int(uint64_t a1)
{
  _BOOL8 is_panic_on_corruption_enabled;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _BOOL8 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (a1)
  {
    is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(a1);
    log_corrupt(is_panic_on_corruption_enabled, "%s:%d: %s Container corruption detected by %s:%u!\n", v2, v3, v4, v5, v6, v7, (char)"nx_corruption_detected_int");
  }
  else
  {
    v8 = nx_is_panic_on_corruption_enabled(0);
    log_corrupt(v8, "%s:%d: Container corruption detected by %s:%u!\n", v9, v10, v11, v12, v13, v14, (char)"nx_corruption_detected_int");
  }
  return 92;
}

unint64_t obj_checksum_verify_phys(_QWORD *a1, int a2, int8x16_t a3, int8x16_t a4)
{
  unint64_t result;
  _BOOL8 is_panic_on_corruption_enabled;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  result = fletcher64_verify_cksum(a1, (uint32x4_t *)(a1 + 1), (a2 - 8), 0, a3, a4);
  if (result)
  {
    log_err("%s:%d: failed: cksum 0x%016llx, oid 0x%llx, type 0x%x/0x%x, size %d\n", "obj_checksum_verify_phys", 52, *a1, a1[1], *((_DWORD *)a1 + 6), *((_DWORD *)a1 + 7), a2);
    is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(0);
    log_corrupt(is_panic_on_corruption_enabled, "%s:%d: Container corruption detected by %s:%u!\n", v8, v9, v10, v11, v12, v13, (char)"nx_corruption_detected_int");
    return 92;
  }
  return result;
}

uint64_t nx_superblock_sanity_check_extent(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5)
{
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  int64_t v8;
  int64_t v9;
  uint64_t result;

  if ((*(_BYTE *)(a1 + 65) & 1) != 0)
  {
    if (a2)
    {
      v7 = *(_QWORD *)(a2 + 48);
      v5 = *(_QWORD *)(a2 + 96);
    }
    else
    {
      v7 = *(_QWORD *)(a1 + 40);
      v5 = v7;
    }
    v8 = 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(a1 + 36)));
    v9 = v8 | v5;
  }
  else
  {
    v5 = 0;
    v6 = (unint64_t *)(a2 + 48);
    if (!a2)
      v6 = (unint64_t *)(a1 + 40);
    v7 = *v6;
    v8 = 0x7FFFFFFFFFFFFFFFLL;
    v9 = v7;
  }
  result = 22;
  if ((a5 ^ 1u) <= a3 && v9 - 1 >= a3)
  {
    if (v5 && v7 <= a3)
    {
      if (a5)
      {
        if (v8 > a3)
          return result;
      }
      else if (v8 >= a3)
      {
        return result;
      }
    }
    if (a4 >= 2)
    {
      if (v9 - a3 >= a4)
      {
        if (v7 - a3 >= a4 || v7 <= a3 || v5 == 0)
          return 0;
        else
          return 22;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

unint64_t nx_check_superblock(uint64_t a1, unsigned int a2, int a3, int8x16_t a4, int8x16_t a5)
{
  unint64_t result;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  int v20;
  int v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unsigned int v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  _BOOL8 is_panic_on_corruption_enabled;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  unsigned int v45;
  int v46;

  if (a2 < 0x1000)
    return 22;
  if (*(_DWORD *)(a1 + 32) != 1112758350)
    return 79;
  if (a3 || (v8 = *(_DWORD *)(a1 + 36), v8 == a2))
  {
    result = obj_checksum_verify_phys((_QWORD *)a1, a2, a4, a5);
    if ((_DWORD)result)
      return result;
    v8 = *(_DWORD *)(a1 + 36);
  }
  v9 = *(_DWORD *)(a1 + 24);
  v10 = v9 != -2147483647;
  if (v9 == -2147483647)
    v11 = 1;
  else
    v11 = 2;
  if (*(_DWORD *)(a1 + 28))
    v10 = v11;
  if (*(_QWORD *)(a1 + 8) != 1)
    ++v10;
  if (v8 < 0x1000)
    ++v10;
  if (v8 <= 0x10000)
    v12 = v10;
  else
    v12 = v10 + 1;
  if (*(_QWORD *)(a1 + 88) < 0x400uLL)
    ++v12;
  v13 = *(_DWORD *)(a1 + 104);
  if ((v13 & 0x7FFFFFF8) != 0)
    v14 = v12;
  else
    v14 = v12 + 1;
  v15 = v13 & 0x7FFFFFFF;
  v16 = *(_QWORD *)(a1 + 40);
  v17 = *(_QWORD *)(a1 + 112);
  if (v13 < 0)
    v18 = 1;
  else
    v18 = v13 & 0x7FFFFFFF;
  if (v13 < 0)
    v19 = 1;
  else
    v19 = v13 & 0x7FFFFFFF;
  v45 = v19;
  v46 = v14;
  v20 = nx_superblock_sanity_check_extent(a1, 0, v17, v18, 0);
  v44 = *(_DWORD *)(a1 + 128);
  v21 = *(_DWORD *)(a1 + 108);
  v22 = v21 & 0x7FFFFFFF;
  v23 = *(_QWORD *)(a1 + 120);
  if (v21 < 0)
    v24 = 1;
  else
    v24 = v21 & 0x7FFFFFFF;
  if (v21 < 0)
    v25 = 1;
  else
    v25 = v21 & 0x7FFFFFFF;
  v26 = nx_superblock_sanity_check_extent(a1, 0, *(_QWORD *)(a1 + 120), v24, 0);
  v27 = v46;
  if (v17 >= v23)
    v28 = v25;
  else
    v28 = v45;
  if (v17 >= v23)
    v29 = v23;
  else
    v29 = v17;
  if (v17 <= v23)
    v30 = v23;
  else
    v30 = v17;
  if (v15 > 0x1000)
    v27 = v46 + 1;
  if (v16 <= v15)
    ++v27;
  if (v20)
    ++v27;
  if (v44 >= v15)
    ++v27;
  if ((v21 & 0x7FFFFFF8) == 0)
    ++v27;
  if (v16 <= v22)
    ++v27;
  if (v26)
    ++v27;
  v31 = v29 + v28;
  if (*(_DWORD *)(a1 + 132) < v22)
    v32 = v27;
  else
    v32 = v27 + 1;
  if (v31 <= v30)
    v33 = v32;
  else
    v33 = v32 + 1;
  if ((*(_QWORD *)(a1 + 64) & 0xFFFFFFFFFFFFFEFDLL) == 0)
  {
    v34 = *(_DWORD *)(a1 + 140);
    if (!*(_QWORD *)(a1 + 152))
      ++v33;
    if (!*(_QWORD *)(a1 + 160))
      ++v33;
    if (!(a3 | v34))
    {
      if (!*(_DWORD *)(a1 + 148) && !*(_DWORD *)(a1 + 136) && !*(_DWORD *)(a1 + 144))
        goto LABEL_91;
      v34 = 0;
    }
    if (*(_DWORD *)(a1 + 136) >= v15)
      ++v33;
    v35 = *(_DWORD *)(a1 + 148);
    if (*(_DWORD *)(a1 + 144) >= v22)
      ++v33;
    if (v34 < 2)
      ++v33;
    if (v34 >= v15)
      ++v33;
    if (v35 < 2)
      ++v33;
    if (v35 >= v22)
      ++v33;
LABEL_91:
    if (*(_DWORD *)(a1 + 180) <= 0x64u)
      v36 = 0;
    else
      v36 = -1;
    if (v33 != v36)
      goto LABEL_96;
    return 0;
  }
  if (!v33)
    return 0;
LABEL_96:
  is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(0);
  log_corrupt(is_panic_on_corruption_enabled, "%s:%d: Container corruption detected by %s:%u!\n", v38, v39, v40, v41, v42, v43, (char)"nx_corruption_detected_int");
  return 92;
}

uint64_t io_get_device_features(int a1, dev_t *a2, _DWORD *a3, int *a4, dev_t *a5)
{
  int *v10;
  char *v11;
  dev_t st_dev;
  int v13;
  int *v14;
  char *v15;
  dev_t v16;
  CFMutableDictionaryRef v17;
  __CFDictionary *v18;
  const __CFAllocator *v19;
  CFNumberRef v20;
  CFNumberRef v21;
  CFNumberRef v22;
  CFNumberRef v23;
  uint64_t MatchingService;
  uint64_t v25;
  uint64_t v26;
  const __CFDictionary *v28;
  const __CFDictionary *v29;
  const __CFBoolean *Value;
  int v31;
  io_object_t v32;
  io_registry_entry_t v33;
  _BOOL4 v34;
  CFTypeRef v35;
  const void *v36;
  CFTypeID TypeID;
  const void *v38;
  CFTypeID v39;
  int v40;
  unsigned int valuePtr;
  stat v42;
  io_registry_entry_t parent;
  io_object_t v44[3];

  if (a2)
  {
    v42.st_dev = 0;
    if (ioctl(a1, 0x4004644CuLL, &v42))
    {
      if (*__error() != 25)
      {
        v10 = __error();
        v11 = strerror(*v10);
        log_err("%s:%d: can't get features for device (%s)\n", "io_get_device_features", 182, v11);
      }
      st_dev = 0;
    }
    else
    {
      st_dev = v42.st_dev;
    }
    *a2 = st_dev;
  }
  if (a3)
    *a3 = (fcntl(a1, 3) & 3) != 0;
  if (!a4)
    goto LABEL_14;
  memset(&v42, 0, sizeof(v42));
  if (fstat(a1, &v42) || (v42.st_mode & 0xB000 | 0x4000) != 0x6000 || (v17 = IOServiceMatching("IOMedia")) == 0)
  {
LABEL_12:
    v13 = 0;
    goto LABEL_13;
  }
  v18 = v17;
  v40 = v42.st_rdev & 0xFFFFFF;
  valuePtr = HIBYTE(v42.st_rdev);
  v19 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v20 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
  if (v20)
  {
    v21 = v20;
    CFDictionarySetValue(v18, CFSTR("BSD Major"), v20);
    CFRelease(v21);
  }
  v22 = CFNumberCreate(v19, kCFNumberIntType, &v40);
  if (v22)
  {
    v23 = v22;
    CFDictionarySetValue(v18, CFSTR("BSD Minor"), v22);
    CFRelease(v23);
  }
  MatchingService = IOServiceGetMatchingService(*MEMORY[0x1E0CBBAB8], v18);
  if (!(_DWORD)MatchingService)
  {
    log_debug("%s:%d: fd %d is type %o rdev %d (%d, %d): I/O registry entry not found\n", "io_get_device_features", 230, a1, v42.st_mode & 0xF000, v42.st_rdev, HIBYTE(v42.st_rdev), v42.st_rdev & 0xFFFFFF);
    goto LABEL_12;
  }
  v25 = MatchingService;
  IOObjectRetain(MatchingService);
  v44[0] = 0;
  v26 = v25;
  while (1)
  {
    parent = 0;
    if (IOObjectConformsTo(v26, "AppleAPFSContainerScheme"))
      break;
    if (IOObjectConformsTo(v26, "IOBlockStorageDevice"))
      goto LABEL_43;
    if (IORegistryEntryGetParentEntry(v26, "IOService", &parent))
      parent = 0;
    IOObjectRelease(v26);
    v26 = parent;
    if (!parent)
    {
      v13 = 0;
      goto LABEL_45;
    }
  }
  v28 = (const __CFDictionary *)IORegistryEntrySearchCFProperty(v26, "IOService", CFSTR("Device Characteristics"), v19, 3u);
  if (v28)
  {
    v29 = v28;
    Value = (const __CFBoolean *)CFDictionaryGetValue(v28, CFSTR("Target Disk Mode"));
    if (Value)
    {
      v31 = CFBooleanGetValue(Value);
      CFRelease(v29);
      if (v31)
      {
LABEL_43:
        v13 = 0;
        goto LABEL_44;
      }
    }
    else
    {
      CFRelease(v29);
    }
  }
  if (MEMORY[0x1E0BFCCE4](v26, "IOService", v44))
    goto LABEL_43;
  while (1)
  {
    v32 = IOIteratorNext(v44[0]);
    if (!v32)
      break;
    v33 = v32;
    if (io_search_for_BOOLean_property(v32, CFSTR("image-format-read-only")))
    {
      v34 = 0;
    }
    else
    {
      if (!io_search_for_BOOLean_property(v33, CFSTR("Removable")))
      {
        v35 = IORegistryEntrySearchCFProperty(v33, "IOService", CFSTR("Protocol Characteristics"), v19, 3u);
        if (v35)
        {
          v36 = v35;
          TypeID = CFDictionaryGetTypeID();
          if (TypeID != CFGetTypeID(v36))
            goto LABEL_56;
          v38 = CFDictionaryGetValue((CFDictionaryRef)v36, CFSTR("Physical Interconnect Location"));
          if (!v38)
            goto LABEL_57;
          v39 = CFStringGetTypeID();
          if (v39 == CFGetTypeID(v38))
            LODWORD(v38) = CFEqual(v38, CFSTR("Internal")) == 0;
          else
LABEL_56:
            LODWORD(v38) = 0;
LABEL_57:
          CFRelease(v36);
        }
        else
        {
          LODWORD(v38) = 0;
        }
        v34 = (_DWORD)v38 != 0;
        goto LABEL_60;
      }
      v34 = 1;
    }
LABEL_60:
    IOObjectRelease(v33);
    if (v34)
    {
      v13 = 1;
      goto LABEL_63;
    }
  }
  v13 = 0;
LABEL_63:
  IOObjectRelease(v44[0]);
LABEL_44:
  IOObjectRelease(v26);
LABEL_45:
  IOObjectRelease(v25);
LABEL_13:
  *a4 = v13;
LABEL_14:
  if (a5)
  {
    v42.st_dev = 0;
    if (ioctl(a1, 0x4004644FuLL, &v42))
    {
      if (*__error() != 25)
      {
        v14 = __error();
        v15 = strerror(*v14);
        log_err("%s:%d: can't get solidstate for device (%s)\n", "io_get_device_features", 246, v15);
      }
      v16 = 1;
    }
    else
    {
      v16 = v42.st_dev;
    }
    *a5 = v16;
  }
  return 0;
}

uint64_t device_parse(char *__s2, char *a2, char *a3, size_t a4, char **a5)
{
  uint64_t v10;
  char *v11;
  uint64_t result;

  if (!strncmp("/dev/", __s2, 5uLL))
    v10 = 5;
  else
    v10 = 0;
  v11 = &__s2[v10];
  if (!strncmp(&__s2[v10], "disk", 4uLL))
  {
    result = snprintf(a2, a4, "%s%s", "/dev/", v11);
    if (a3)
      result = snprintf(a3, a4, "%sr%s");
    goto LABEL_14;
  }
  if (!strncmp(v11, "rdisk", 5uLL))
  {
    result = snprintf(a2, a4, "%s%s", "/dev/", v11 + 1);
    if (a3)
      result = snprintf(a3, a4, "%s%s");
LABEL_14:
    if (!a5)
      return result;
    a2 += 5;
    goto LABEL_16;
  }
  result = strlcpy(a2, __s2, a4);
  if (a3)
    result = strlcpy(a3, __s2, a4);
  if (a5)
LABEL_16:
    *a5 = a2;
  return result;
}

uint64_t get_container_io_object(char *bsdName)
{
  mach_port_t v1;
  const __CFDictionary *v2;
  uint64_t result;
  char v4;
  io_object_t object;

  v1 = *MEMORY[0x1E0CBBAB8];
  v2 = IOBSDNameMatching(*MEMORY[0x1E0CBBAB8], 0, bsdName);
  result = IOServiceGetMatchingService(v1, v2);
  object = result;
  if ((_DWORD)result)
  {
    v4 = io_next_child(&object, "AppleAPFSContainer");
    result = object;
    if ((v4 & 1) == 0)
    {
      IOObjectRelease(object);
      return 0;
    }
  }
  return result;
}

const char *device_basename(const char *a1)
{
  const char *v1;
  int v2;

  v1 = a1;
  if (!strncmp(a1, "/dev/", 5uLL))
  {
    v2 = *((unsigned __int8 *)v1 + 5);
    v1 += 5;
    if (v2 == 114)
      ++v1;
  }
  return v1;
}

unint64_t device_container_path(char *a1, _DWORD *a2)
{
  unint64_t result;
  unint64_t v5;
  int v6;

  if (!device_is_volume(a1))
    return 0;
  result = (unint64_t)strrchr(a1, 115);
  if (result)
  {
    v5 = result;
    result = strtoul((const char *)(result + 1), 0, 10);
    if (result)
    {
      v6 = result;
      result = (unint64_t)strndup(a1, v5 - (_QWORD)a1);
      if (result)
      {
        if (a2)
          *a2 = v6 - 1;
      }
    }
  }
  return result;
}

BOOL device_is_volume(const char *a1)
{
  const char *v1;
  int v2;
  mach_port_t v3;
  const __CFDictionary *v4;
  io_service_t MatchingService;
  io_object_t v6;
  _BOOL8 v7;

  v1 = a1;
  if (!strncmp(a1, "/dev/", 5uLL))
  {
    v2 = *((unsigned __int8 *)v1 + 5);
    v1 += 5;
    if (v2 == 114)
      ++v1;
  }
  v3 = *MEMORY[0x1E0CBBAB8];
  v4 = IOBSDNameMatching(*MEMORY[0x1E0CBBAB8], 0, v1);
  MatchingService = IOServiceGetMatchingService(v3, v4);
  if (!MatchingService)
    return 0;
  v6 = MatchingService;
  v7 = IOObjectConformsTo(MatchingService, "AppleAPFSVolume") != 0;
  IOObjectRelease(v6);
  return v7;
}

uint64_t io_next_child(io_object_t *a1, const char *a2)
{
  int v4;
  uint64_t result;
  io_object_t v6;
  io_object_t v7;
  io_iterator_t iterator;

  iterator = 0;
  v4 = MEMORY[0x1E0BFCCC0](*a1, "IOService", &iterator);
  result = 0;
  if (!v4)
  {
    v6 = IOIteratorNext(iterator);
    if (v6)
    {
      v7 = v6;
      while (!IOObjectConformsTo(v7, a2))
      {
        IOObjectRelease(v7);
        v7 = IOIteratorNext(iterator);
        if (!v7)
          goto LABEL_6;
      }
      IOObjectRelease(iterator);
      IOObjectRelease(*a1);
      *a1 = v7;
      return 1;
    }
    else
    {
LABEL_6:
      IOObjectRelease(iterator);
      return 0;
    }
  }
  return result;
}

uint64_t get_first_child_of_class(uint64_t a1, const char *a2)
{
  uint64_t v3;
  uint64_t v4;
  io_iterator_t iterator;

  iterator = 0;
  v3 = 0;
  if (!MEMORY[0x1E0BFCCC0](a1, "IOService", &iterator))
  {
    while (1)
    {
      v4 = IOIteratorNext(iterator);
      v3 = v4;
      if (!(_DWORD)v4 || IOObjectConformsTo(v4, a2))
        break;
      IOObjectRelease(v3);
    }
    IOObjectRelease(iterator);
  }
  return v3;
}

char *mounted_device(char *a1, CFStringRef theString)
{
  _OWORD v4[8];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  memset(v4, 0, sizeof(v4));
  if (theString && CFStringGetCString(theString, (char *)v4, 128, 0x8000100u))
    a1 = (char *)v4;
  return mounted_device_internal(a1, 0);
}

char *mounted_device_internal(char *result, int a2)
{
  const char *v3;
  int v4;
  int v5;
  char *i;
  char *v7;
  statfs *v8;
  char __s1[16];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v3 = result;
    v7 = 0;
    v8 = 0;
    *(_OWORD *)__s1 = 0u;
    v10 = 0u;
    v11 = 0u;
    v12 = 0u;
    v13 = 0u;
    v14 = 0u;
    v15 = 0u;
    v16 = 0u;
    device_parse(result, __s1, 0, 0x80uLL, &v7);
    v4 = getmntinfo(&v8, 2);
    if (!v4)
      return 0;
    v5 = v4;
    for (i = v8->f_mntfromname; ; i += 2168)
    {
      if (a2)
      {
        if (strstr(i, v3))
          return i - 1024;
      }
      else if (!strcmp(__s1, i))
      {
        return i - 1024;
      }
      v8 = (statfs *)(i + 1056);
      if (!--v5)
        return 0;
    }
  }
  return result;
}

uint64_t physical_store_to_container(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  io_iterator_t object;
  io_iterator_t iterator[2];

  *(_QWORD *)iterator = 0;
  object = 0;
  v1 = 0;
  if (MEMORY[0x1E0BFCCC0](a1, "IOService", &iterator[1]))
    return v1;
  v2 = IOIteratorNext(iterator[1]);
  if (!(_DWORD)v2)
  {
LABEL_18:
    v1 = 0;
    LODWORD(v5) = iterator[1];
    goto LABEL_20;
  }
  v3 = v2;
  while (1)
  {
    if (!IOObjectConformsTo(v3, "AppleAPFSContainerScheme")
      || MEMORY[0x1E0BFCCC0](v3, "IOService", iterator))
    {
      goto LABEL_17;
    }
    v4 = IOIteratorNext(iterator[0]);
    if ((_DWORD)v4)
      break;
LABEL_16:
    IOObjectRelease(iterator[0]);
LABEL_17:
    IOObjectRelease(v3);
    v3 = IOIteratorNext(iterator[1]);
    if (!(_DWORD)v3)
      goto LABEL_18;
  }
  v5 = v4;
  while (1)
  {
    if (!IOObjectConformsTo(v5, "AppleAPFSMedia") || MEMORY[0x1E0BFCCC0](v5, "IOService", &object))
      goto LABEL_15;
    v6 = IOIteratorNext(object);
    if ((_DWORD)v6)
      break;
LABEL_14:
    IOObjectRelease(object);
LABEL_15:
    IOObjectRelease(v5);
    v5 = IOIteratorNext(iterator[0]);
    if (!(_DWORD)v5)
      goto LABEL_16;
  }
  v1 = v6;
  while (!IOObjectConformsTo(v1, "AppleAPFSContainer"))
  {
    IOObjectRelease(v1);
    v1 = IOIteratorNext(object);
    if (!(_DWORD)v1)
      goto LABEL_14;
  }
  IOObjectRelease(iterator[1]);
  IOObjectRelease(iterator[0]);
  IOObjectRelease(object);
  IOObjectRelease(v3);
LABEL_20:
  IOObjectRelease(v5);
  return v1;
}

BOOL io_search_for_BOOLean_property(io_registry_entry_t a1, CFStringRef key)
{
  CFTypeRef v2;
  _BOOL8 v3;

  v2 = IORegistryEntrySearchCFProperty(a1, "IOService", key, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if (!v2)
    return 0;
  v3 = v2 == (CFTypeRef)*MEMORY[0x1E0C9AE50];
  CFRelease(v2);
  return v3;
}

uint64_t tx_mgr_init(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  pthread_mutex_t *v7;
  uint64_t v8;
  uint64_t inited;
  uint64_t v10;
  uint64_t v12;
  int v13;
  int v14;

  v6 = *(unsigned int *)(*(_QWORD *)(a1 + 376) + 36);
  v7 = (pthread_mutex_t *)_apfs_calloc(1uLL, 0x130uLL);
  if (!v7)
    return 12;
  v8 = (uint64_t)v7;
  v7[1].__sig = a2;
  *(_QWORD *)v7[1].__opaque = 0;
  *(_QWORD *)&v7[1].__opaque[40] = 0;
  *(_DWORD *)&v7[1].__opaque[8] = 0;
  *(_DWORD *)&v7[1].__opaque[12] = (v6 - 40) / 0x28uLL;
  *(_QWORD *)&v7[1].__opaque[48] = (char *)v7 + 112;
  v7[2].__sig = 0;
  *(_QWORD *)v7[2].__opaque = v7 + 2;
  inited = new_lock(v7);
  if (!(_DWORD)inited)
  {
    v10 = new_cv((pthread_cond_t *)(v8 + 256));
    if ((_DWORD)v10)
    {
      inited = v10;
      free_lock((pthread_mutex_t *)v8);
    }
    else if (*(_BYTE *)(a1 + 627) || (inited = tx_mgr_init_tx(v8, v6), !(_DWORD)inited))
    {
      inited = 0;
      v12 = *(_QWORD *)(a1 + 376);
      v13 = *(_DWORD *)(v12 + 104) & 0x7FFFFFFF;
      v14 = *(_DWORD *)(v12 + 108) & 0x7FFFFFFF;
      *(_DWORD *)(v8 + 88) = v13;
      *(_DWORD *)(v8 + 92) = v14;
      *(_QWORD *)(v8 + 96) = *(_QWORD *)(v12 + 128);
      *(_DWORD *)(v8 + 104) = v13;
      *(_DWORD *)(v8 + 108) = v14;
      *a3 = v8;
      return inited;
    }
  }
  _apfs_free((void *)v8, 304);
  return inited;
}

uint64_t tx_mgr_init_tx(uint64_t a1, unsigned int a2)
{
  size_t v3;
  int v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v9;
  _QWORD *v10;
  void *v11;
  void *v12;
  uint64_t *v13;

  v3 = a2;
  v4 = 4;
  while (1)
  {
    v5 = _apfs_calloc(1uLL, 0x78uLL);
    if (!v5)
      break;
    v6 = v5;
    v5[7] = _apfs_malloc(v3);
    v6[8] = _apfs_malloc(v3);
    v7 = *(_QWORD **)(a1 + 120);
    *v6 = 0;
    v6[1] = v7;
    *v7 = v6;
    *(_QWORD *)(a1 + 120) = v6;
    if (!v6[7] || !v6[8])
      break;
    if (!--v4)
      return 0;
  }
  while (1)
  {
    v13 = *(uint64_t **)(a1 + 112);
    if (!v13)
      break;
    v9 = *v13;
    v10 = (_QWORD *)v13[1];
    if (*v13)
    {
      *(_QWORD *)(v9 + 8) = v10;
      v10 = (_QWORD *)v13[1];
    }
    else
    {
      *(_QWORD *)(a1 + 120) = v10;
    }
    *v10 = v9;
    v11 = (void *)v13[7];
    if (v11)
      _apfs_free(v11, v3);
    v12 = (void *)v13[8];
    if (v12)
      _apfs_free(v12, v3);
    _apfs_free(v13, 120);
  }
  return 12;
}

void tx_mgr_free_tx(uint64_t a1, _QWORD *a2, unsigned int a3)
{
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  void *v15;

  v6 = a2[18];
  if (v6)
  {
    log_err("%s:%d: %s Trash unfinished tx xid=0x%llx\n", "tx_mgr_free_tx", 189, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(v6 + 16));
    v7 = (_QWORD *)a2[18];
    v8 = (_QWORD *)a2[15];
    *v7 = 0;
    v7[1] = v8;
    *v8 = v7;
    a2[15] = a2[18];
    a2[18] = 0;
  }
  v9 = a2[16];
  if (v9)
  {
    log_err("%s:%d: %s Trash unfinished pending tx, xid range = 0x%llx - 0x%llx\n", "tx_mgr_free_tx", 197, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(v9 + 16), *(_QWORD *)(**(_QWORD **)(a2[17] + 8) + 16));
    v10 = a2[16];
    if (v10)
    {
      *(_QWORD *)a2[15] = v10;
      *(_QWORD *)(a2[16] + 8) = a2[15];
      a2[15] = a2[17];
      a2[16] = 0;
      a2[17] = a2 + 16;
    }
  }
  v11 = (_QWORD *)a2[14];
  if (v11)
  {
    do
    {
      v13 = (_QWORD *)*v11;
      v12 = (_QWORD *)v11[1];
      if (*v11)
      {
        v13[1] = v12;
        v12 = (_QWORD *)v11[1];
      }
      else
      {
        a2[15] = v12;
      }
      *v12 = v13;
      v14 = (void *)v11[7];
      if (v14)
        _apfs_free(v14, a3);
      v15 = (void *)v11[8];
      if (v15)
        _apfs_free(v15, a3);
      _apfs_free(v11, 120);
      v11 = v13;
    }
    while (v13);
  }
}

void tx_mgr_destroy(uint64_t a1, uint64_t a2, unsigned int a3)
{
  tx_mgr_free_tx(a1, (_QWORD *)a2, a3);
  free_lock((pthread_mutex_t *)a2);
  free_cv((pthread_cond_t *)(a2 + 256));
  _apfs_free((void *)a2, 304);
}

BOOL xid_is_current_tx(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;

  if (*(_BYTE *)(a1 + 624))
  {
    v2 = (_QWORD *)(*(_QWORD *)(a1 + 376) + 96);
    return *v2 == a2;
  }
  v3 = *(_QWORD *)(a1 + 400);
  if (v3)
  {
    v4 = *(_QWORD *)(v3 + 144);
    if (v4)
    {
      v2 = (_QWORD *)(v4 + 16);
      return *v2 == a2;
    }
  }
  return 0;
}

uint64_t tx_checkpoint_space_check(uint64_t a1, uint64_t a2, int a3)
{
  char v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;

  v6 = 0;
  v7 = *(_QWORD *)(a1 + 400);
  while (1)
  {
    v8 = *(_DWORD *)(v7 + 96);
    v9 = *(_DWORD *)(v7 + 104);
    v10 = v9;
    if (v8 > v9)
      v10 = *(_DWORD *)(v7 + 88) + v9;
    v11 = *(_DWORD *)(v7 + 100);
    v12 = *(_DWORD *)(v7 + 108);
    v13 = v12;
    if (v11 > v12)
      v13 = *(_DWORD *)(v7 + 92) + v12;
    v14 = v10 - v8;
    v15 = v13 - v11;
    v16 = *(_DWORD *)(a2 + 48) + a3;
    if (v16 <= v15 && !(v6 & 1 | (*(_DWORD *)(a2 + 40) + 1 > v14)))
      return 0;
    if ((v6 & 1) != 0 || !*(_QWORD *)(v7 + 128))
      break;
    tx_barrier_internal(a1, 0x50u, 0);
    v6 = 1;
  }
  if (!*(_WORD *)(v7 + 82))
    log_err("%s:%d: %s checkpoint area out of space: stable: %d %d - next %d %d available %d %d tx[%lld] %d %d\n", "tx_checkpoint_space_check", 495, (const char *)(*(_QWORD *)(a1 + 384) + 208), v9, v12, v8, v11, v14, v15, *(_QWORD *)(a2 + 16), *(_DWORD *)(a2 + 40) + 1, v16);
  *(_WORD *)(v7 + 82) = 1;
  return 28;
}

uint64_t tx_barrier_internal(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  int v11;
  __darwin_time_t v12;
  __darwin_time_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  timespec v19;

  v6 = *(_QWORD *)(a1 + 400);
  if ((a2 & 0x40) != 0)
  {
    v7 = *(_QWORD *)(v6 + 128);
    if (!v7 || (*(_BYTE *)(v7 + 24) & 0x40) == 0)
      return 0;
  }
  if (a3)
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 400));
  v8 = dev_barrier(*(_QWORD *)(a1 + 384), (a2 >> 4) & 1);
  if (a3)
    pthread_mutex_lock((pthread_mutex_t *)v6);
  if ((_DWORD)v8 == 25 || (_DWORD)v8 == 0)
  {
    v8 = *(_QWORD *)(v6 + 128);
    if (v8)
    {
      do
      {
        v10 = *(_QWORD *)v8;
        v11 = *(_DWORD *)(v8 + 24);
        if ((v11 & 0x40) != 0)
        {
          *(_DWORD *)(v8 + 24) = v11 & 0xFFFFFFBF;
          v19.tv_sec = 0;
          v19.tv_nsec = 0;
          clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v19);
          v12 = 1000000 * v19.tv_sec + SLODWORD(v19.tv_nsec) / 1000;
          v13 = v12 - *(_QWORD *)(v8 + 72);
          *(_QWORD *)(v8 + 72) = v12;
          *(_QWORD *)(v8 + 104) += v13;
          v14 = *(_QWORD *)(v8 + 16);
          if (!*(_BYTE *)(a1 + 632) || v14 < *(_QWORD *)(*(_QWORD *)(a1 + 376) + 1408))
          {
            *(_DWORD *)(v6 + 104) = *(_DWORD *)(v8 + 36);
            *(_DWORD *)(v6 + 108) = *(_DWORD *)(v8 + 44);
          }
          spaceman_tx_complete(a1, v14);
          v15 = *(_QWORD *)v8;
          v16 = *(uint64_t **)(v8 + 8);
          if (*(_QWORD *)v8)
          {
            *(_QWORD *)(v15 + 8) = v16;
            v16 = *(uint64_t **)(v8 + 8);
          }
          else
          {
            *(_QWORD *)(v6 + 136) = v16;
          }
          *v16 = v15;
          *(_QWORD *)v8 = 0;
          v17 = *(uint64_t **)(v6 + 120);
          *(_QWORD *)(v8 + 8) = v17;
          *v17 = v8;
          *(_QWORD *)(v6 + 120) = v8;
          cv_wakeup((pthread_cond_t *)(v6 + 256));
        }
        v8 = v10;
      }
      while (v10);
    }
  }
  return v8;
}

uint64_t tx_checkpoint_write_prepare(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  int8x16_t v8;
  int8x16_t v9;
  _QWORD *v10;
  uint64_t v11;

  v5 = (*(_DWORD *)(*(_QWORD *)(a1 + 376) + 36) + *(_DWORD *)(a3 + 48) - 1)
     / *(_DWORD *)(*(_QWORD *)(a1 + 376) + 36);
  v6 = *(_QWORD *)(a2 + 64);
  if (*(_DWORD *)(v6 + 36) == *(_DWORD *)(*(_QWORD *)(a1 + 400) + 84))
  {
    ++*(_DWORD *)(a2 + 40);
    *(_DWORD *)(v6 + 36) = 0;
  }
  v7 = tx_checkpoint_space_check(a1, a2, v5);
  if (!(_DWORD)v7)
  {
    if ((*(_BYTE *)(a3 + 19) & 0x20) == 0)
    {
      v10 = *(_QWORD **)(a3 + 56);
      v8.i64[0] = *(_QWORD *)(a3 + 36);
      v10[3] = v8.i64[0];
      v11 = *(_QWORD *)(a2 + 16);
      v10[1] = *(_QWORD *)(a3 + 112);
      v10[2] = v11;
      obj_checksum_set(a3, v8, v9);
    }
    *(_QWORD *)(a3 + 120) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a3 + 144) = 0;
    ++*(_DWORD *)(*(_QWORD *)(a2 + 64) + 36);
    *(_DWORD *)(a2 + 48) += v5;
  }
  return v7;
}

uint64_t tx_checkpoint_write(_QWORD *a1, uint64_t a2, uint64_t a3, int8x16_t a4, int8x16_t a5)
{
  _DWORD *v8;
  size_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  signed int v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  char *v23;
  int v24;
  unint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  unsigned int v36;
  uint64_t v38;
  char *v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;

  v8 = (_DWORD *)a1[50];
  v42 = 0;
  v40 = 0;
  v9 = *(unsigned int *)(a1[47] + 36);
  v10 = *(_DWORD *)(a3 + 48);
  v11 = *(_QWORD *)(a2 + 64);
  if (*(_DWORD *)(v11 + 36) == v8[21])
  {
    obj_checksum_set_phys((uint64_t)a1, v11, *(_DWORD *)(a1[47] + 36), a4, a5);
    v12 = dev_write(a1[48], *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8));
    if ((_DWORD)v12)
    {
      v13 = v12;
      if (!v8[19])
        log_err("%s:%d: %s failed to write checkpoint map block %lld: %d\n");
      return v13;
    }
    v14 = (*(_DWORD *)(a2 + 40) + v8[24]) % v8[22];
    v42 = -1;
    v15 = nx_checkpoint_desc_block_address((uint64_t)a1, v14, &v42);
    if ((_DWORD)v15)
    {
      v13 = v15;
      if (!v8[19])
        log_err("%s:%d: %s error getting next checkpoint map block address %d: %d\n");
      return v13;
    }
    bzero(*(void **)(a2 + 64), v9);
    v16 = *(_QWORD *)(a2 + 64);
    *(_DWORD *)(v16 + 24) = 1073741836;
    *(_QWORD *)(v16 + 8) = v42;
    *(_QWORD *)(v16 + 16) = *(_QWORD *)(a2 + 16);
    ++*(_DWORD *)(a2 + 40);
  }
  v17 = (*(_DWORD *)(a2 + 48) + v8[25]) % v8[23];
  v41 = -1;
  v18 = nx_checkpoint_data_block_address((uint64_t)a1, v17, &v41, &v40);
  if ((_DWORD)v18)
  {
    v13 = v18;
    if (!v8[19])
      log_err("%s:%d: %s error getting next checkpoint data block address %d: %d\n");
  }
  else
  {
    v19 = ((int)v9 + v10 - 1) / v9;
    pthread_mutex_lock((pthread_mutex_t *)(a1[49] + 328));
    v20 = (unsigned int *)(a3 + 32);
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 | 8, v20));
    if ((v21 & 8) != 0)
    {
      do
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a1[49] + 328));
        pthread_mutex_lock((pthread_mutex_t *)(a1[49] + 328));
        do
          v22 = __ldxr(v20);
        while (__stxr(v22 | 8, v20));
      }
      while ((v22 & 8) != 0);
    }
    v38 = a3;
    v39 = *(char **)(a3 + 64);
    *(_QWORD *)(a3 + 128) = v41;
    if (v19 < 1)
    {
LABEL_30:
      if (v39 == *(char **)(v38 + 56))
        v27 = 0;
      else
        v27 = v39;
      *(_QWORD *)(v38 + 64) = 0;
      v28 = a1[49];
      v29 = *(_QWORD *)(*(_QWORD *)(v28 + 848) + 104);
      *(_QWORD *)(v28 + 848) = v29;
      if (!v29)
        *(_QWORD *)(v28 + 856) = v28 + 848;
      *(_QWORD *)(v38 + 104) = 3735928559;
      do
        v30 = __ldxr(v20);
      while (__stxr(v30 & 0xFFFFFFF7, v20));
      pthread_mutex_unlock((pthread_mutex_t *)(a1[49] + 328));
      v31 = *(_QWORD *)(a2 + 64);
      v32 = *(_DWORD *)(v31 + 36);
      v33 = v31 + 40 * v32;
      *(_QWORD *)(v33 + 40) = *(_QWORD *)(v38 + 36);
      *(_QWORD *)(v33 + 48) = *(unsigned int *)(v38 + 48);
      v34 = *(_QWORD *)(v38 + 8);
      if (v34)
      {
        v34 = obj_oid(v34);
        v31 = *(_QWORD *)(a2 + 64);
        v32 = *(_DWORD *)(v31 + 36);
      }
      v35 = (_QWORD *)(v31 + 40 * v32);
      v35[7] = v34;
      v35[8] = *(_QWORD *)(v38 + 112);
      v35[9] = *(_QWORD *)(v38 + 128);
      *(_DWORD *)(v31 + 36) = v32 + 1;
      *(_DWORD *)(a2 + 48) += v19;
      if (v27)
        fs_obj_zfree_oc(v27, *(unsigned int *)(v38 + 48), *(_QWORD *)(v38 + 16), a1[49]);
      return 0;
    }
    else
    {
      v23 = v39;
      v24 = v19;
      while (1)
      {
        v25 = v40 >= v24 ? v24 : v40;
        v26 = dev_write(a1[48], v41);
        if ((_DWORD)v26)
          break;
        v24 -= v25;
        if (!v24)
          goto LABEL_30;
        v17 = (int)v17 + (int)v25 >= (*(_DWORD *)(a1[47] + 108) & 0x7FFFFFFFu) ? 0 : (v17 + v25);
        v26 = nx_checkpoint_data_block_address((uint64_t)a1, v17, &v41, &v40);
        if ((_DWORD)v26)
          break;
        v23 += v25 * v9;
        if (v24 <= 0)
          goto LABEL_30;
      }
      v13 = v26;
      do
        v36 = __ldxr(v20);
      while (__stxr(v36 & 0xFFFFFFF7, v20));
      pthread_mutex_unlock((pthread_mutex_t *)(a1[49] + 328));
      if (!v8[19])
        log_err("%s:%d: %s failed to write checkpoint data block %lld: %d\n");
    }
  }
  return v13;
}

uint64_t tx_barrier(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  v4 = *(_QWORD *)(a1 + 400);
  if ((a2 & 0x80) != 0 && (v5 = *(_QWORD *)(v4 + 144)) != 0 && (*(_BYTE *)(v5 + 24) & 8) != 0)
  {
    v6 = 0;
    if ((a2 & 0x40) == 0)
      goto LABEL_11;
  }
  else
  {
    pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 400));
    v6 = 1;
    if ((a2 & 0x40) == 0)
      goto LABEL_11;
  }
  v7 = *(_QWORD *)(v4 + 128);
  if (!v7 || (*(_BYTE *)(v7 + 24) & 0x40) == 0)
  {
    if (v6)
      pthread_mutex_unlock((pthread_mutex_t *)v4);
    return 0;
  }
LABEL_11:
  v8 = tx_barrier_internal(a1, a2, 0);
  if (v6)
    pthread_mutex_unlock((pthread_mutex_t *)v4);
  return v8;
}

uint64_t tx_unmount(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  int v4;
  int8x16_t v5;
  int8x16_t v6;
  uint64_t v7;
  int v8;
  _BYTE *v9;
  int v10;
  int v11;

  v2 = *(_QWORD *)(a1 + 400);
  pthread_mutex_lock((pthread_mutex_t *)v2);
  *(_DWORD *)(v2 + 72) |= 1u;
  pthread_mutex_unlock((pthread_mutex_t *)v2);
  while (1)
  {
    result = tx_finish(a1, 8);
    if ((_DWORD)result != 16)
      break;
    log_debug("%s:%d: %s waiting for transaction to finish\n", "tx_unmount", 1869, (const char *)(*(_QWORD *)(a1 + 384) + 208));
    sleep(1u);
  }
  if ((_DWORD)result)
  {
    result = (uint64_t)log_err("%s:%d: %s tx_finish() failed, %d\n", "tx_unmount", 1884, (const char *)(*(_QWORD *)(a1 + 384) + 208), result);
    if (!*(_BYTE *)(a1 + 629))
    {
      pthread_mutex_lock((pthread_mutex_t *)v2);
      return pthread_mutex_unlock((pthread_mutex_t *)v2);
    }
  }
  else if (!*(_BYTE *)(a1 + 629))
  {
    pthread_mutex_lock((pthread_mutex_t *)v2);
    if ((*(_BYTE *)(v2 + 72) & 2) != 0)
    {
      v4 = tx_barrier_internal(a1, 0x10u, 0);
      if (v4)
        log_err("%s:%d: %s First sync/barrier failed: %d\n", "tx_unmount", 1898, (const char *)(*(_QWORD *)(a1 + 384) + 208), v4);
      if (!*(_BYTE *)(a1 + 628))
      {
        v7 = *(_QWORD *)(a1 + 376);
        if (*(_DWORD *)(v7 + 140))
        {
          if (*(_DWORD *)(v7 + 148))
            *(_QWORD *)(v7 + 1264) |= 2uLL;
        }
      }
      obj_checksum_set(a1, v5, v6);
      v8 = dev_write(*(_QWORD *)(a1 + 384), 0);
      if (v8)
        log_err("%s:%d: %s failed to write superblock to block 0: %d\n", "tx_unmount", 1909, (const char *)(*(_QWORD *)(a1 + 384) + 208), v8);
      v9 = *(_BYTE **)(a1 + 376);
      if ((v9[65] & 1) != 0)
      {
        v10 = nx_fusion_superblock_write(a1, v9);
        if (v10)
          log_err("%s:%d: %s failed to write superblock to fusion tier2 device block 0: %d\n", "tx_unmount", 1914, (const char *)(*(_QWORD *)(a1 + 384) + 208), v10);
      }
      v11 = tx_barrier_internal(a1, 0x10u, 0);
      if (v11)
        log_err("%s:%d: %s Final sync/barrier failed: %d\n", "tx_unmount", 1921, (const char *)(*(_QWORD *)(a1 + 384) + 208), v11);
    }
    return pthread_mutex_unlock((pthread_mutex_t *)v2);
  }
  return result;
}

uint64_t tx_finish(uint64_t a1, __int16 a2)
{
  uint64_t v2;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v11;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;

  if (*(_BYTE *)(a1 + 627))
    return 30;
  v5 = *(_QWORD *)(a1 + 400);
  pthread_mutex_lock((pthread_mutex_t *)v5);
  v6 = *(_DWORD *)(v5 + 72);
  if ((a2 & 8) == 0 && (v6 & 1) != 0)
  {
LABEL_18:
    v2 = 1;
  }
  else
  {
    while (1)
    {
      v7 = *(_QWORD *)(v5 + 144);
      if ((v6 & 0x40) == 0)
        break;
      if (v7)
        *(_DWORD *)(v7 + 24) |= 0x100000u;
      if ((a2 & 0x100) != 0)
      {
        *(_DWORD *)(v5 + 72) = v6 & 0xFFFFFFF3;
        cv_wakeup((pthread_cond_t *)(v5 + 256));
        v7 = *(_QWORD *)(v5 + 144);
      }
      if (v7)
      {
        v2 = *(unsigned int *)(v7 + 52);
        if ((_DWORD)v2)
          goto LABEL_19;
      }
      cv_wait((pthread_cond_t *)(v5 + 256), (pthread_mutex_t *)v5, 8, (uint64_t)"nx_tx_finish_wait_for_dirty_data", 0);
      v8 = *(_QWORD *)(v5 + 144);
      if (v8)
      {
        v9 = *(_DWORD *)(v8 + 52);
        if (v9 | a2 & 0x100)
        {
          if (v9)
            v2 = v9;
          else
            v2 = 35;
          goto LABEL_19;
        }
      }
      else if ((a2 & 0x100) != 0)
      {
        goto LABEL_65;
      }
      v6 = *(_DWORD *)(v5 + 72);
      if ((a2 & 8) == 0 && (v6 & 1) != 0)
        goto LABEL_18;
    }
    if (v7 || (v7 = **(_QWORD **)(*(_QWORD *)(v5 + 136) + 8)) != 0 && (*(_BYTE *)(v7 + 24) & 0x30) != 0)
    {
      if ((a2 & 2) == 0 && (v6 & 0xC) == 8)
      {
        v2 = 16;
        goto LABEL_19;
      }
      v11 = *(_QWORD *)(v7 + 16);
      if ((a2 & 8) == 0)
        ++*(_QWORD *)(v5 + 176);
      v12 = *(_DWORD *)(v7 + 24);
      v13 = a2 & 1;
      if (v12 & 0x100000 | a2 & 0x10 | v13 | a2 & 0x20)
        *(_DWORD *)(v7 + 24) = ((a2 & 0x30) << 14) | (v13 << 17) | v12 & 0xFFEFFFFF;
      if ((v12 & 1) != 0)
        tx_transition(v7, 1, 2);
      if (*(_DWORD *)(v7 + 28))
      {
        v2 = (16 * v13) ^ 0x10u;
      }
      else
      {
        if ((*(_BYTE *)(v7 + 24) & 2) != 0)
        {
          v14 = tx_transition(v7, 2, 4);
          v15 = v14;
          if (v14 >= 0xF4241)
            log_warn("%s:%d: %s tx xid %lld took %lld us to close\n", "tx_finish", 2138, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(v7 + 16), v14);
          *(_QWORD *)(v5 + 248) = (*(_QWORD *)(v5 + 248) + v15) >> 1;
        }
        v2 = tx_flush_initiate(a1);
        if (!(_DWORD)v2)
        {
          v16 = *(_DWORD *)(v5 + 72);
          if ((v16 & 0x40) != 0)
          {
            *(_DWORD *)(v5 + 72) = v16 & 0xFFFFFFF3;
            if ((a2 & 0x100) != 0)
            {
LABEL_65:
              v2 = 35;
              goto LABEL_19;
            }
            cv_wakeup((pthread_cond_t *)(v5 + 256));
          }
          v2 = 0;
        }
      }
      if ((a2 & 9) != 0)
      {
        if ((a2 & 1) != 0)
          v17 = 126;
        else
          v17 = 62;
        do
        {
          if (*(_QWORD *)(v7 + 16) != v11 || (*(_DWORD *)(v7 + 24) & v17) == 0)
            break;
          if (!(_DWORD)v2)
            cv_wait((pthread_cond_t *)(v5 + 256), (pthread_mutex_t *)v5, 8, (uint64_t)"nx_tx_finish_wait", 0);
          v18 = *(_DWORD *)(v5 + 72);
          if ((a2 & 8) == 0 && (v18 & 1) != 0)
            goto LABEL_18;
          if ((a2 & 0x100) != 0 && (v18 & 4) == 0)
            goto LABEL_65;
        }
        while (!*(_DWORD *)(v5 + 76));
        v19 = **(_QWORD **)(*(_QWORD *)(v5 + 136) + 8);
        if (!v19 || (v2 = *(unsigned int *)(v19 + 52), !(_DWORD)v2))
          v2 = *(unsigned int *)(v7 + 52);
      }
    }
    else if ((a2 & 0x11) != 0)
    {
      v2 = tx_barrier_internal(a1, a2 & 0x10, 0);
    }
    else
    {
      v2 = 0;
    }
  }
LABEL_19:
  pthread_mutex_unlock((pthread_mutex_t *)v5);
  return v2;
}

uint64_t tx_enter_internal(uint64_t a1, uint64_t *a2, char a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  BOOL v12;
  int8x16_t v13;
  int8x16_t v14;
  const char *v15;
  const char *v16;
  int v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  int v23;
  _BYTE *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  BOOL v29;
  unsigned int v30;
  uint64_t v32;
  __darwin_time_t tv_sec;
  int v34;
  timespec __tp;

  if (*(_BYTE *)(a1 + 627))
    return 30;
  v7 = *(_QWORD *)(a1 + 400);
  pthread_mutex_lock((pthread_mutex_t *)v7);
  if ((*(_DWORD *)(v7 + 72) & 1) != 0)
  {
LABEL_37:
    pthread_mutex_unlock((pthread_mutex_t *)v7);
    return 1;
  }
  v8 = *a2;
  if (*a2 != -1)
  {
    if (v8)
      goto LABEL_6;
    goto LABEL_15;
  }
  v11 = *(_QWORD *)(v7 + 144);
  if (v11)
    v12 = (*(_DWORD *)(v7 + 72) & 0xC) == 8;
  else
    v12 = 1;
  if (v12 || (*(_BYTE *)(v11 + 24) & 0x1C) != 0)
  {
    *a2 = 0;
LABEL_15:
    __tp.tv_sec = 0;
    __tp.tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    v15 = 0;
    v32 = SLODWORD(__tp.tv_nsec) / 1000;
    tv_sec = __tp.tv_sec;
    while (1)
    {
      v9 = *(_QWORD *)(v7 + 144);
      if (v9 && (*(_BYTE *)(v9 + 24) & 0x1E) != 0)
      {
        if (*(unsigned __int16 *)(v7 + 80) > 9u)
          goto LABEL_73;
        v16 = "nx_tx_wait";
        if ((a3 & 2) != 0)
        {
LABEL_20:
          v17 = *(_DWORD *)(v9 + 24);
          v15 = "nx_tx_wait_closing";
          if ((v17 & 2) == 0)
          {
            if ((v17 & 4) != 0)
            {
              v18 = **(_QWORD **)(*(_QWORD *)(v7 + 136) + 8);
              if (!v18 || (v15 = "nx_tx_wait_closed_prev_flushing", (*(_BYTE *)(v18 + 24) & 0x30) == 0))
                v15 = "nx_tx_wait_closed";
            }
            else if ((v17 & 0x18) != 0)
            {
              v15 = "nx_tx_wait_flush";
            }
            else
            {
              v15 = v16;
            }
          }
          goto LABEL_36;
        }
      }
      else
      {
        if ((a3 & 2) != 0 || (*(_BYTE *)(v7 + 72) & 8) == 0)
        {
          v3 = 0;
          v34 = 0;
          if (!v9)
            goto LABEL_42;
LABEL_40:
          if ((*(_BYTE *)(v9 + 24) & 1) != 0)
          {
            if (!(_DWORD)v3)
            {
              ++*(_DWORD *)(v9 + 28);
              *a2 = *(_QWORD *)(v9 + 16);
              if (v15)
              {
                v10 = v34;
                if (v34)
                {
                  if (strcmp(v15, "nx_tx_wait_frozen"))
                  {
                    __tp.tv_sec = 0;
                    __tp.tv_nsec = 0;
                    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
                    v26 = 1000000 * (__tp.tv_sec - tv_sec) - v32 + SLODWORD(__tp.tv_nsec) / 1000;
                    *(_QWORD *)(v7 + 168) += v26;
                    if (v26 > 0xF4240 && nx_ratelimit_log_allowed(a1))
                      log_warn("%s:%d: %s waited %lld us to open tx xid %lld (%s)\n", "tx_enter_internal", 2403, (const char *)(*(_QWORD *)(a1 + 384) + 208), v26, *(_QWORD *)(v9 + 16), v15);
                    ++*(_QWORD *)(v7 + 160);
                  }
                  v10 = 1;
                }
              }
              else
              {
                v10 = v34;
              }
LABEL_88:
              ++*(_DWORD *)(v9 + 32);
              pthread_mutex_unlock((pthread_mutex_t *)v7);
              if (v10)
                spaceman_manage_free_queues((_QWORD *)a1, v9);
              return 0;
            }
LABEL_86:
            pthread_mutex_unlock((pthread_mutex_t *)v7);
            return v3;
          }
          while (1)
          {
            v23 = *(_DWORD *)(v9 + 24);
            if ((v23 & 1) == 0)
              break;
            do
            {
              log_debug("%s:%d: %s waiting for available tx to open: xid %lld\n", "tx_enter_internal", 2388, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(v7 + 64));
              cv_wait((pthread_cond_t *)(v7 + 256), (pthread_mutex_t *)v7, 8, (uint64_t)"nx_tx_wait_open", 0);
LABEL_62:
              v9 = *(_QWORD *)(v7 + 144);
              if (v9)
                goto LABEL_40;
LABEL_42:
              v19 = *(uint64_t **)(v7 + 112);
            }
            while (!v19);
            *(_QWORD *)(v7 + 144) = v19;
            v20 = *v19;
            v21 = (_QWORD *)v19[1];
            if (*v19)
            {
              *(_QWORD *)(v20 + 8) = v21;
              v21 = (_QWORD *)v19[1];
            }
            else
            {
              *(_QWORD *)(v7 + 120) = v21;
            }
            *v21 = v20;
            v22 = *(_QWORD *)(v7 + 64);
            *(_QWORD *)(v7 + 64) = v22 + 1;
            v9 = *(_QWORD *)(v7 + 144);
            *(_QWORD *)(v9 + 16) = v22;
            *(_QWORD *)(v9 + 24) = 0;
            *(_DWORD *)(v9 + 32) = 0;
            *(_DWORD *)(v9 + 52) = 0;
          }
          if (*(_BYTE *)(a1 + 626))
          {
            obj_checksum_set(a1, v13, v14);
            v3 = dev_write(*(_QWORD *)(a1 + 384), 0);
            if ((_DWORD)v3)
              goto LABEL_50;
            v24 = *(_BYTE **)(a1 + 376);
            if ((v24[65] & 1) != 0)
            {
              v25 = nx_fusion_superblock_write(a1, v24);
              if ((_DWORD)v25)
              {
                v3 = v25;
                log_err("%s:%d: %s failed to write superblock to fusion tier2 device block 0: %d\n", "tx_enter_internal", 2360, (const char *)(*(_QWORD *)(a1 + 384) + 208), v25);
LABEL_50:
                log_err("%s:%d: %s Error: tx[%lld] failed to unclean superblock: %d\n", "tx_enter_internal", 2366, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(*(_QWORD *)(v7 + 144) + 16), v3);
                v9 = *(_QWORD *)(v7 + 144);
LABEL_53:
                log_err("%s:%d: %s Error: tx[%lld] failed to start: %d\n", "tx_enter_internal", 2370, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(v9 + 16), v3);
                goto LABEL_62;
              }
            }
            *(_BYTE *)(a1 + 626) = 0;
            v9 = *(_QWORD *)(v7 + 144);
            v23 = *(_DWORD *)(v9 + 24);
            if ((v23 & 1) != 0)
              panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v23, 1, 0);
          }
          else if ((_DWORD)v3)
          {
            goto LABEL_53;
          }
          *(_DWORD *)(v9 + 24) = v23 | 1;
          __tp.tv_sec = 0;
          __tp.tv_nsec = 0;
          clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
          *(_QWORD *)(v9 + 72) = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
          if ((a3 & 2) != 0)
            *(_DWORD *)(*(_QWORD *)(v7 + 144) + 24) |= 0x10000u;
          cv_wakeup((pthread_cond_t *)(v7 + 256));
          v3 = 0;
          v34 = 1;
          goto LABEL_62;
        }
        if (*(unsigned __int16 *)(v7 + 80) >= 0xAu)
        {
LABEL_73:
          v27 = **(_QWORD **)(*(_QWORD *)(v7 + 136) + 8);
          if (v27)
          {
            if (*(_DWORD *)(v27 + 24) & 0x30)
            {
              v29 = 0;
            }
            else
            {
              v27 = *(_QWORD *)(v7 + 144);
              v29 = v9 == 0;
            }
            if (!v29)
            {
              v9 = v27;
              goto LABEL_82;
            }
          }
          else if (v9)
          {
LABEL_82:
            v30 = *(_DWORD *)(v9 + 52);
            if (v30)
              v3 = v30;
            else
              v3 = 5;
            goto LABEL_86;
          }
          v3 = 5;
          goto LABEL_86;
        }
      }
      if ((*(_DWORD *)(v7 + 72) & 8) != 0)
        v16 = "nx_tx_wait_frozen";
      else
        v16 = "nx_tx_wait";
      if (v9)
        goto LABEL_20;
      v15 = v16;
LABEL_36:
      cv_wait((pthread_cond_t *)(v7 + 256), (pthread_mutex_t *)v7, 8, (uint64_t)v15, 0);
      if ((*(_BYTE *)(v7 + 72) & 1) != 0)
        goto LABEL_37;
    }
  }
  v8 = *(_QWORD *)(v11 + 16);
  *a2 = v8;
  if (!v8)
    goto LABEL_15;
LABEL_6:
  v9 = *(_QWORD *)(v7 + 144);
  if (v9 && v8 == *(_QWORD *)(v9 + 16))
  {
    v10 = 0;
    ++*(_DWORD *)(v9 + 28);
    goto LABEL_88;
  }
  pthread_mutex_unlock((pthread_mutex_t *)v7);
  return 22;
}

__darwin_time_t tx_transition(uint64_t a1, int a2, int a3)
{
  int v4;
  int v5;
  __darwin_time_t v6;
  __darwin_time_t result;
  timespec __tp;

  if (a2)
  {
    v4 = *(_DWORD *)(a1 + 24);
    if ((v4 & a2) == 0)
      panic("can't transition from tx flags 0x%x to 0x%x (expected 0x%x)\n", v4, a3, a2);
  }
  if (a3)
  {
    v5 = *(_DWORD *)(a1 + 24);
    if ((v5 & a3) != 0)
      panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v5, a3, a2);
  }
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 24) & ~a2 | a3;
  __tp.tv_sec = 0;
  __tp.tv_nsec = 0;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
  v6 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
  result = v6 - *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 72) = v6;
  return result;
}

uint64_t tx_flush_initiate(uint64_t a1)
{
  uint64_t v2;
  int i;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;

  v2 = *(_QWORD *)(a1 + 400);
  for (i = *(_DWORD *)(v2 + 72); (i & 0x10) != 0; i = *(_DWORD *)(v2 + 72))
  {
    *(_DWORD *)(v2 + 72) = i | 0x20;
    cv_wait((pthread_cond_t *)(v2 + 256), (pthread_mutex_t *)v2, 8, (uint64_t)"nx_tx_flush_busy", 0);
  }
  *(_DWORD *)(v2 + 72) = i | 0x10;
  v4 = **(_QWORD **)(*(_QWORD *)(v2 + 136) + 8);
  if (!v4 || (v5 = *(_DWORD *)(v4 + 24), (v5 & 0x10) == 0))
  {
    v4 = *(_QWORD *)(v2 + 144);
    if (!v4)
      goto LABEL_9;
    v5 = *(_DWORD *)(v4 + 24);
  }
  if ((v5 & 0x14) == 0 || (v6 = tx_flush(a1, v4), !(_DWORD)v6))
  {
LABEL_9:
    v7 = *(_QWORD *)(v2 + 144);
    if (v7 && (*(_BYTE *)(v7 + 24) & 4) != 0)
      v6 = tx_flush(a1, v7);
    else
      v6 = 0;
  }
  v8 = *(_DWORD *)(v2 + 72);
  *(_DWORD *)(v2 + 72) = v8 & 0xFFFFFFCF;
  if ((v8 & 0x20) != 0)
    cv_wakeup((pthread_cond_t *)(v2 + 256));
  return v6;
}

uint64_t tx_enter(uint64_t a1, uint64_t *a2)
{
  return tx_enter_internal(a1, a2, 0);
}

uint64_t tx_leave(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  _BOOL4 v10;
  int v11;
  int v12;
  int v13;
  int v14;
  __darwin_time_t v16;
  unint64_t v17;
  int started;
  timespec __tp;

  if (!*(_BYTE *)(a1 + 627))
  {
    v7 = *(_QWORD *)(a1 + 400);
    pthread_mutex_lock((pthread_mutex_t *)v7);
    v8 = *(_QWORD *)(v7 + 144);
    if ((*(_BYTE *)(v8 + 24) & 1) == 0)
      goto LABEL_22;
    if ((a3 & 4) != 0)
    {
      v9 = 0;
      ++*(_QWORD *)(v7 + 176);
    }
    else
    {
      if (*(_DWORD *)(v8 + 32) <= 0x186A0u && !obj_cache_tx_start_closing(*(_QWORD *)(a1 + 392)))
      {
        started = spaceman_tx_start_closing((_QWORD *)a1);
        v9 = started == 0;
        v10 = started != 0;
LABEL_10:
        if ((*(_BYTE *)(v7 + 72) & 0x40) != 0)
        {
          if (!v9)
            *(_DWORD *)(v8 + 24) |= 0x100000u;
        }
        else
        {
          v11 = *(_DWORD *)(v8 + 24);
          if ((v11 & 0x100000) != 0)
          {
            v11 &= ~0x100000u;
            *(_DWORD *)(v8 + 24) = v11;
          }
          else if (!v10)
          {
            goto LABEL_22;
          }
          if ((v11 & 1) == 0)
            panic("can't transition from tx flags 0x%x to 0x%x (expected 0x%x)\n", v11, 2, 1);
          if ((v11 & 2) != 0)
            panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v11, 2, 1);
          *(_DWORD *)(v8 + 24) = v11 & 0xFFFFFFFC | 2;
          __tp.tv_sec = 0;
          __tp.tv_nsec = 0;
          clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
          *(_QWORD *)(v8 + 72) = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
        }
LABEL_22:
        if ((~a3 & 5) != 0)
        {
          if ((a3 & 0x10) != 0)
          {
LABEL_24:
            *(_DWORD *)(v8 + 24) |= 0x40000u;
            if ((a3 & 0x20) == 0)
              goto LABEL_29;
            goto LABEL_28;
          }
        }
        else
        {
          *(_DWORD *)(v8 + 24) |= 0x20000u;
          if ((a3 & 0x10) != 0)
            goto LABEL_24;
        }
        if ((a3 & 0x20) == 0)
        {
LABEL_29:
          v12 = *(_DWORD *)(v8 + 28) - 1;
          *(_DWORD *)(v8 + 28) = v12;
          if (!v12 && (v13 = *(_DWORD *)(v8 + 24), (v13 & 2) != 0))
          {
            if ((v13 & 4) != 0)
              panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v13, 4, 2);
            *(_DWORD *)(v8 + 24) = v13 & 0xFFFFFFF9 | 4;
            __tp.tv_sec = 0;
            __tp.tv_nsec = 0;
            clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
            v16 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
            v17 = v16 - *(_QWORD *)(v8 + 72);
            *(_QWORD *)(v8 + 72) = v16;
            if (v17 > 0xF4240)
              log_warn("%s:%d: %s tx xid %lld took %lld us to close\n", "tx_leave", 2534, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(v8 + 16), v17);
            *(_QWORD *)(v7 + 248) = (*(_QWORD *)(v7 + 248) + v17) >> 1;
            v3 = tx_flush_initiate(a1);
            if ((a3 & 1) == 0)
              goto LABEL_41;
          }
          else
          {
            v3 = 0;
            if ((a3 & 1) == 0)
            {
LABEL_41:
              pthread_mutex_unlock((pthread_mutex_t *)v7);
              return v3;
            }
          }
          if ((a3 & 4) != 0)
            v14 = 127;
          else
            v14 = 63;
          do
          {
            if (*(_QWORD *)(v8 + 16) != a2 || (*(_DWORD *)(v8 + 24) & v14) == 0)
              break;
            if (!(_DWORD)v3)
              cv_wait((pthread_cond_t *)(v7 + 256), (pthread_mutex_t *)v7, 8, (uint64_t)"nx_tx_finish_wait", 0);
          }
          while (!*(_DWORD *)(v7 + 76));
          v3 = *(unsigned int *)(v8 + 52);
          goto LABEL_41;
        }
LABEL_28:
        *(_DWORD *)(v8 + 24) |= 0x80000u;
        goto LABEL_29;
      }
      v9 = 0;
    }
    v10 = 1;
    goto LABEL_10;
  }
  return 30;
}

uint64_t tx_flush(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  __darwin_time_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t i;
  int v17;
  pthread_cond_t *v18;
  int v19;
  __darwin_time_t v20;
  unint64_t v21;
  int v22;
  uint64_t *v23;
  uint64_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  unsigned int v38;
  uint64_t v39;
  int v40;
  _DWORD *v41;
  int v42;
  int v43;
  _DWORD *v45;
  int v46;
  __darwin_time_t v47;
  unint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  unint64_t v54;
  unint64_t v55;
  unsigned int v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  int8x16_t v60;
  int8x16_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  int v71;
  unsigned int v72;
  int v73;
  uint64_t v74;
  int v75;
  __darwin_time_t v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  int64x2_t v83;
  unint64_t v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  timespec __tp;

  v5 = *(_QWORD *)(a1 + 392);
  v4 = *(_QWORD *)(a1 + 400);
  v87 = 0;
  v6 = **(_QWORD **)(*(_QWORD *)(v4 + 136) + 8);
  if (v6 && (*(_BYTE *)(v6 + 24) & 0x10) != 0)
  {
    if (v6 != a2)
      panic("not handling the flushing tx!\n");
  }
  else
  {
    if (*(_QWORD *)(v4 + 144) != a2)
      panic("not handling the current tx!\n");
    if ((*(_BYTE *)(a2 + 24) & 0x14) == 0)
      panic("current tx not closed/flushing?!\n");
  }
  v7 = *(_DWORD *)(a2 + 24);
  if ((v7 & 0x10) != 0)
  {
LABEL_43:
    if (*(_BYTE *)(a1 + 629))
    {
      v22 = *(_DWORD *)(a2 + 24);
      if ((v22 & 0x10) == 0)
        panic("can't transition from tx flags 0x%x to 0x%x (expected 0x%x)\n", v22, 1, 16);
      if ((v22 & 1) != 0)
        panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v22, 1, 16);
      *(_DWORD *)(a2 + 24) = v22 & 0xFFFFFFEE | 1;
      __tp.tv_sec = 0;
      __tp.tv_nsec = 0;
      clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
      *(_QWORD *)(a2 + 72) = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
      *(_DWORD *)(a2 + 32) = 0;
      *(_DWORD *)(a2 + 52) = 0;
    }
    else if (*(_QWORD *)(v4 + 144) == a2)
    {
      *(_QWORD *)a2 = 0;
      v23 = *(uint64_t **)(v4 + 136);
      *(_QWORD *)(a2 + 8) = v23;
      *v23 = a2;
      *(_QWORD *)(v4 + 136) = a2;
      *(_QWORD *)(v4 + 144) = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)v4);
    cv_wakeup((pthread_cond_t *)(v4 + 256));
    v24 = obj_cache_flush_write((pthread_mutex_t *)v5, 2 * (*(_BYTE *)(a1 + 629) == 0));
    if (*(_BYTE *)(a1 + 629))
    {
      pthread_mutex_lock((pthread_mutex_t *)v4);
      obj_cache_flush_unprepare(v5);
      tx_barrier_internal(a1, 0, 0);
      cv_wakeup((pthread_cond_t *)(v4 + 256));
      v11 = 0;
      *(_DWORD *)(a2 + 52) = 0;
      return v11;
    }
    v11 = v24;
    if ((_DWORD)v24)
    {
      pthread_mutex_lock((pthread_mutex_t *)v4);
      if (!*(_DWORD *)(v4 + 76))
        log_err("%s:%d: %s xid %lld error flushing objects from the cache: %d\n", "tx_flush", 1109, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), v11);
      v27 = 1111;
      goto LABEL_71;
    }
    while (1)
    {
      v29 = *(_QWORD *)(v5 + 848);
      if (!v29)
        break;
      v28 = tx_checkpoint_write((_QWORD *)a1, a2, *(_QWORD *)(v5 + 848), v25, v26);
      if ((_DWORD)v28)
      {
        v11 = v28;
        pthread_mutex_lock((pthread_mutex_t *)v4);
        if (!*(_DWORD *)(v4 + 76))
          log_err("%s:%d: %s xid %lld failed to write checkpoint data @ 0x%llx: %d\n", "tx_flush", 1125, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), *(_QWORD *)(v29 + 128), v11);
        v27 = 1127;
        goto LABEL_71;
      }
      obj_checkpoint_done((unsigned int *)v29);
      obj_release((uint64_t *)v29);
    }
    v30 = *(_QWORD *)(a2 + 64);
    *(_DWORD *)(v30 + 32) |= 1u;
    obj_checksum_set_phys(a1, v30, *(_DWORD *)(*(_QWORD *)(a1 + 376) + 36), v25, v26);
    v31 = dev_write(*(_QWORD *)(a1 + 384), *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8));
    if ((_DWORD)v31)
    {
      v11 = v31;
      pthread_mutex_lock((pthread_mutex_t *)v4);
      if (!*(_DWORD *)(v4 + 76))
        log_err("%s:%d: %s xid %lld failed to write last checkpoint map block %lld: %d\n", "tx_flush", 1144, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8), v11);
      v27 = 1146;
LABEL_71:
      *(_DWORD *)(v4 + 76) = v27;
      ++*(_WORD *)(v4 + 80);
LABEL_72:
      v18 = (pthread_cond_t *)(v4 + 256);
      goto LABEL_73;
    }
    ++*(_DWORD *)(a2 + 40);
    pthread_mutex_lock((pthread_mutex_t *)v4);
    v40 = *(_DWORD *)(a2 + 40);
    v41 = *(_DWORD **)(a2 + 56);
    v42 = *(_DWORD *)(a2 + 48);
    v43 = v41[37];
    if (v40 != v41[35] || v42 != v43)
      panic("flush phase checkpoint lengths (%d %d) don't match prepare phase (%d %d)\n", v40, v42, v41[35], v43);
    v45 = *(_DWORD **)(a1 + 376);
    v45[34] = v41[34];
    v45[35] = v40;
    v45[36] = v41[36];
    v45[37] = v42;
    v46 = *(_DWORD *)(a2 + 24);
    if ((v46 & 0x10) == 0)
      panic("can't transition from tx flags 0x%x to 0x%x (expected 0x%x)\n", v46, 32, 16);
    if ((v46 & 0x20) != 0)
      panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v46, 32, 16);
    *(_DWORD *)(a2 + 24) = v46 & 0xFFFFFFCF | 0x20;
    __tp.tv_sec = 0;
    __tp.tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    v47 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
    v48 = v47 - *(_QWORD *)(a2 + 72);
    *(_QWORD *)(a2 + 72) = v47;
    if (v48 > 0xF4240)
      log_warn("%s:%d: %s tx xid %lld took %lld us to flush\n", "tx_flush", 1173, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), v48);
    *(_QWORD *)(a2 + 104) = v48;
    cv_wakeup((pthread_cond_t *)(v4 + 256));
    v49 = tx_barrier_internal(a1, 0, 1);
    if ((_DWORD)v49)
    {
      v11 = v49;
      if (!*(_DWORD *)(v4 + 76))
        log_err("%s:%d: %s xid %lld sync/barrier failed: %d\n", "tx_flush", 1182, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), v49);
      v50 = 1184;
      goto LABEL_109;
    }
    pthread_mutex_unlock((pthread_mutex_t *)v4);
    if (*(_BYTE *)(a1 + 632))
    {
      *(_DWORD *)(a2 + 24) |= 0x80000u;
      bzero(*(void **)(a2 + 64), *(unsigned int *)(*(_QWORD *)(a1 + 376) + 36));
    }
    v51 = dev_write(*(_QWORD *)(a1 + 384), *(_QWORD *)(a2 + 112));
    if ((_DWORD)v51)
    {
      v11 = v51;
      pthread_mutex_lock((pthread_mutex_t *)v4);
      if (!*(_DWORD *)(v4 + 76))
        log_err("%s:%d: %s xid %lld failed to write checkpoint superblock %lld: %d\n", "tx_flush", 1211, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 112), v11);
      v50 = 1213;
      goto LABEL_109;
    }
    if ((*(_BYTE *)(a2 + 26) & 8) == 0)
    {
LABEL_112:
      pthread_mutex_lock((pthread_mutex_t *)v4);
      v54 = tx_transition(a2, 32, 64);
      v55 = v54;
      if (v54 > 0xF4240)
        log_warn("%s:%d: %s tx xid %lld took %lld us to sync and write superblock\n", "tx_flush", 1274, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), v54);
      *(_QWORD *)(a2 + 104) += v55;
      v56 = *(_DWORD *)(a2 + 24);
      if ((v56 & 0x20000) == 0)
        goto LABEL_142;
      ++*(_QWORD *)(v4 + 184);
      if ((v56 & 0x40000) != 0)
        ++*(_QWORD *)(v4 + 192);
      v57 = tx_barrier_internal(a1, (v56 >> 14) & 0x10, 0);
      if (!(_DWORD)v57)
      {
LABEL_142:
        *(_DWORD *)(a2 + 52) = 0;
        *(_DWORD *)(v4 + 72) |= 2u;
        *(_QWORD *)(v4 + 76) = 0;
        v78 = *(_QWORD *)(a2 + 56);
        v79 = *(_DWORD *)(v78 + 128);
        v80 = *(_QWORD *)(a1 + 376);
        *(_DWORD *)(v80 + 128) = v79;
        *(_DWORD *)(v4 + 96) = v79;
        v81 = *(_DWORD *)(v78 + 132);
        *(_DWORD *)(v80 + 132) = v81;
        *(_DWORD *)(v4 + 100) = v81;
        *(_QWORD *)(v80 + 16) = *(_QWORD *)(v78 + 16);
        v82 = *(_QWORD *)(v4 + 152);
        *(_QWORD *)(v4 + 152) = v82 + 1;
        if (v82)
        {
          v83.i64[0] = *(unsigned int *)(a2 + 32);
          v83.i64[1] = *(_QWORD *)(a2 + 80);
          *(uint64x2_t *)(v4 + 200) = vshrq_n_u64((uint64x2_t)vaddq_s64(*(int64x2_t *)(v4 + 200), v83), 1uLL);
          *(uint64x2_t *)(v4 + 216) = vshrq_n_u64((uint64x2_t)vaddq_s64(*(int64x2_t *)(a2 + 88), *(int64x2_t *)(v4 + 216)), 1uLL);
          *(_QWORD *)(v4 + 240) = (*(_QWORD *)(a2 + 104) + *(_QWORD *)(v4 + 240)) >> 1;
          if (__ROR8__(0xCCCCCCCCCCCCCCCDLL * (v82 + 1), 2) <= 0xCCCCCCCCCCCCCCCuLL
            && nx_ratelimit_log_allowed(a1))
          {
            v84 = *(_QWORD *)(v4 + 160);
            if (v84 <= 1)
              v85 = 1;
            else
              v85 = *(_QWORD *)(v4 + 160);
            log_debug("%s:%d: %s xid %llu tx stats: # %llu owait %llu %lluus finish %llu bar2 %lld f %lld enter %llu fq %llu %llu %lluus close %lluus prep %lluus flush %lluus\n", "tx_flush", 1338, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), *(_QWORD *)(v4 + 152), v84, *(_QWORD *)(v4 + 168) / v85, *(_QWORD *)(v4 + 176), *(_QWORD *)(v4 + 184), *(_QWORD *)(v4 + 192), *(_QWORD *)(v4 + 200), *(_QWORD *)(v4 + 216), *(_QWORD *)(v4 + 224), *(_QWORD *)(v4 + 208), *(_QWORD *)(v4 + 248), *(_QWORD *)(v4 + 232), *(_QWORD *)(v4 + 240));
          }
        }
        else
        {
          *(_QWORD *)(v4 + 200) = *(unsigned int *)(a2 + 32);
          *(_OWORD *)(v4 + 208) = *(_OWORD *)(a2 + 80);
          *(_QWORD *)(v4 + 224) = *(_QWORD *)(a2 + 96);
          *(_QWORD *)(v4 + 240) = *(_QWORD *)(a2 + 104);
        }
        cv_wakeup((pthread_cond_t *)(v4 + 256));
        return 0;
      }
      v11 = v57;
      if (!*(_DWORD *)(v4 + 76))
        log_err("%s:%d: %s xid %lld second sync/barrier failed: %d\n", "tx_flush", 1286, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), v57);
      *(_DWORD *)(v4 + 76) = 1288;
      ++*(_WORD *)(v4 + 80);
      --*(_DWORD *)(a2 + 40);
      v52 = a2;
      v53 = 64;
LABEL_110:
      *(_QWORD *)(a2 + 104) += tx_transition(v52, v53, 16);
      goto LABEL_72;
    }
    v77 = dev_write(*(_QWORD *)(a1 + 384), 0);
    if ((_DWORD)v77)
    {
      v11 = v77;
      if (!*(_DWORD *)(v4 + 76))
        log_err("%s:%d: %s xid %lld failed to write block 0 superblock: %d\n");
    }
    else
    {
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 376) + 65) & 1) == 0)
        goto LABEL_112;
      v86 = nx_fusion_superblock_write(a1, *(const void **)(a2 + 56));
      if (!(_DWORD)v86)
        goto LABEL_112;
      v11 = v86;
      if (!*(_DWORD *)(v4 + 76))
        log_err("%s:%d: %s xid %lld failed to write superblock to fusion tier2 device block 0: %d\n");
    }
    pthread_mutex_lock((pthread_mutex_t *)v4);
    v50 = 1248;
LABEL_109:
    *(_DWORD *)(v4 + 76) = v50;
    ++*(_WORD *)(v4 + 80);
    --*(_DWORD *)(a2 + 40);
    v52 = a2;
    v53 = 32;
    goto LABEL_110;
  }
  if ((v7 & 4) == 0)
    panic("can't transition from tx flags 0x%x to 0x%x (expected 0x%x)\n", v7, 8, 4);
  if ((v7 & 8) != 0)
    panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v7, 8, 4);
  *(_DWORD *)(a2 + 24) = v7 & 0xFFFFFFF3 | 8;
  __tp.tv_sec = 0;
  __tp.tv_nsec = 0;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
  v8 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
  v9 = v8 - *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 72) = v8;
  if (v9 > 0xF4240)
    log_warn("%s:%d: %s tx xid %lld was closed for %lld us waiting to prepare to flush\n", "tx_flush", 853, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), v9);
  v10 = obj_cache_flush_prepare(v5, 0, 2 * (*(_BYTE *)(a1 + 629) == 0), *(_QWORD *)(a2 + 16));
  if ((_DWORD)v10)
  {
    v11 = v10;
    if (!*(_DWORD *)(v4 + 76))
      log_err("%s:%d: %s xid %lld error preparing to flush object cache: %d\n", "tx_flush", 859, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), v10);
    v12 = 861;
    goto LABEL_20;
  }
  if (*(_BYTE *)(a1 + 629))
  {
    v19 = *(_DWORD *)(a2 + 24);
    if ((v19 & 8) == 0)
      panic("can't transition from tx flags 0x%x to 0x%x (expected 0x%x)\n", v19, 16, 8);
    if ((v19 & 0x10) != 0)
      panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v19, 16, 8);
    *(_DWORD *)(a2 + 24) = v19 & 0xFFFFFFE7 | 0x10;
    __tp.tv_sec = 0;
    __tp.tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    v20 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
    v21 = v20 - *(_QWORD *)(a2 + 72);
    *(_QWORD *)(a2 + 72) = v20;
    if (v21 > 0xF4240)
      log_warn("%s:%d: %s tx xid %lld took %lld us to prepare to flush\n", "tx_flush", 871, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), v21);
LABEL_42:
    *(_QWORD *)(v4 + 232) = (*(_QWORD *)(v4 + 232) + v21) >> 1;
    goto LABEL_43;
  }
  *(_DWORD *)(a2 + 36) = *(_DWORD *)(v4 + 96);
  *(_DWORD *)(a2 + 44) = *(_DWORD *)(v4 + 100);
  *(_DWORD *)(a2 + 48) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  v87 = -1;
  v32 = nx_checkpoint_desc_block_address(a1, *(unsigned int *)(*(_QWORD *)(a1 + 376) + 128), &v87);
  if ((_DWORD)v32)
  {
    v11 = v32;
    if (!*(_DWORD *)(v4 + 76))
      log_err("%s:%d: %s xid %lld error getting first checkpoint map block address %d: %d\n", "tx_flush", 891, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), *(_DWORD *)(*(_QWORD *)(a1 + 376) + 128), v32);
    v12 = 893;
    goto LABEL_20;
  }
  bzero(*(void **)(a2 + 64), *(unsigned int *)(*(_QWORD *)(a1 + 376) + 36));
  v34 = *(_QWORD *)(a2 + 64);
  *(_DWORD *)(v34 + 24) = 1073741836;
  *(_QWORD *)(v34 + 8) = v87;
  *(_QWORD *)(v34 + 16) = *(_QWORD *)(a2 + 16);
  ++*(_DWORD *)(a2 + 40);
  v11 = nx_checkpoint_traverse(a1, a2, 1);
  if ((_DWORD)v11)
    goto LABEL_21;
  v35 = *(_QWORD *)(v5 + 736);
  if (!v35)
  {
LABEL_84:
    v37 = *(_DWORD *)(v4 + 96);
    *(_QWORD *)(a2 + 112) = -1;
    v38 = (*(_DWORD *)(a2 + 40) + v37) % *(_DWORD *)(v4 + 88);
    v39 = nx_checkpoint_desc_block_address(a1, v38, (_QWORD *)(a2 + 112));
    if ((_DWORD)v39)
    {
      v11 = v39;
      if (!*(_DWORD *)(v4 + 76))
        log_err("%s:%d: %s xid %lld error getting next checkpoint superblock address %d: %d\n", "tx_flush", 940, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), v38, v39);
      v12 = 942;
      goto LABEL_20;
    }
    ++*(_DWORD *)(a2 + 40);
    v58 = *(_DWORD *)(v5 + 900) - 1;
    if (*(_DWORD *)(a2 + 48) != v58)
      log_err("%s:%d: %s xid %lld checkpoint data block count is not value tracked by cache: %d != %d\n", "tx_flush", 981, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), *(_DWORD *)(a2 + 48), v58);
    v59 = *(_QWORD *)(a1 + 376);
    *(_QWORD *)(v59 + 88) = *(_QWORD *)(v5 + 400);
    *(_QWORD *)(v59 + 96) = *(_QWORD *)(v4 + 64);
    memcpy(*(void **)(a2 + 56), (const void *)v59, *(unsigned int *)(v59 + 36));
    v62 = *(_QWORD *)(a2 + 16);
    v63 = *(_QWORD *)(a2 + 56);
    *(_QWORD *)(v63 + 16) = v62;
    v64 = *(_DWORD *)(v4 + 96);
    *(_DWORD *)(v63 + 136) = v64;
    v65 = *(_DWORD *)(v4 + 100);
    *(_DWORD *)(v63 + 144) = v65;
    v66 = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(v63 + 140) = v66;
    v67 = *(_DWORD *)(a2 + 48);
    *(_DWORD *)(v63 + 148) = v67;
    v68 = v66 + v64;
    v70 = *(_DWORD *)(v4 + 88);
    v69 = *(_DWORD *)(v4 + 92);
    v71 = v68 % v70;
    v72 = (v67 + v65) % v69;
    if (!*(_DWORD *)(v4 + 76))
    {
      if (v66 > v70 >> 2)
      {
        log_err("%s:%d: %s xid %lld checkpoint descriptor count is larger than expected: %d > %d\n", "tx_flush", 1006, (const char *)(*(_QWORD *)(a1 + 384) + 208), v62, v66, v70 >> 2);
        v67 = *(_DWORD *)(a2 + 48);
        v69 = *(_DWORD *)(v4 + 92);
      }
      if (v67 > v69 >> 2)
      {
        log_err("%s:%d: %s xid %lld checkpoint data block count is larger than expected: %d > %d\n", "tx_flush", 1010, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), v67, v69 >> 2);
        v67 = *(_DWORD *)(a2 + 48);
      }
      v73 = *(_DWORD *)(v5 + 900) - 1;
      if (v67 != v73)
        log_err("%s:%d: %s xid %lld checkpoint data block count is not value tracked by cache: %d != %d\n", "tx_flush", 1014, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), v67, v73);
    }
    v74 = *(_QWORD *)(a2 + 56);
    *(_DWORD *)(v74 + 128) = v71;
    *(_DWORD *)(v74 + 132) = v72;
    obj_checksum_set_phys(a1, v74, *(_DWORD *)(*(_QWORD *)(a1 + 376) + 36), v60, v61);
    *(_DWORD *)(a2 + 48) = 0;
    *(_DWORD *)(a2 + 40) = 1;
    *(_DWORD *)(*(_QWORD *)(a2 + 64) + 36) = 0;
    v75 = *(_DWORD *)(a2 + 24);
    if ((v75 & 8) == 0)
      panic("can't transition from tx flags 0x%x to 0x%x (expected 0x%x)\n", v75, 16, 8);
    if ((v75 & 0x10) != 0)
      panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v75, 16, 8);
    *(_DWORD *)(a2 + 24) = v75 & 0xFFFFFFE7 | 0x10;
    __tp.tv_sec = 0;
    __tp.tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    v76 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
    v21 = v76 - *(_QWORD *)(a2 + 72);
    *(_QWORD *)(a2 + 72) = v76;
    if (v21 > 0xF4240)
      log_warn("%s:%d: %s tx xid %lld took %lld us to prepare to flush\n", "tx_flush", 1037, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), v21);
    goto LABEL_42;
  }
  while (v35 == a1)
  {
LABEL_83:
    v35 = *(_QWORD *)(v35 + 88);
    if (!v35)
      goto LABEL_84;
  }
  v36 = tx_checkpoint_write_prepare(a1, a2, v35);
  if (!(_DWORD)v36)
  {
    obj_retain_ephemeral_no_ref(v35);
    if ((*(_BYTE *)(v35 + 32) & 4) == 0 && (*(_BYTE *)(v35 + 20) & 0x20) == 0)
      log_warn("%s:%d: %s Unknown NEW persistent ephemeral object found: oid 0x%llx type 0x%x/0x%x\n", "tx_flush", 928, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(v35 + 112), *(_DWORD *)(v35 + 36), *(_DWORD *)(v35 + 40));
    *(_QWORD *)(v35 + 64) = *(_QWORD *)(v35 + 56);
    *(_QWORD *)(v35 + 104) = 0;
    **(_QWORD **)(v5 + 856) = v35;
    *(_QWORD *)(v5 + 856) = v35 + 104;
    goto LABEL_83;
  }
  v11 = v36;
  if (!*(_DWORD *)(v4 + 76))
    log_err("%s:%d: %s xid %lld error preparing ephemeral object (oid 0x%llx type 0x%x/0x%x): %d\n", "tx_flush", 919, (const char *)(*(_QWORD *)(a1 + 384) + 208), *(_QWORD *)(a2 + 16), *(_QWORD *)(v35 + 112), *(_DWORD *)(v35 + 36), *(_DWORD *)(v35 + 40), v36);
  v12 = 921;
LABEL_20:
  *(_DWORD *)(v4 + 76) = v12;
  ++*(_WORD *)(v4 + 80);
LABEL_21:
  obj_cache_flush_unprepare(v5);
  v13 = *(_QWORD *)(v5 + 848);
  if (v13)
  {
    v14 = (uint64_t *)(v5 + 848);
    do
    {
      v15 = *(_QWORD *)(v13 + 104);
      *v14 = v15;
      if (!v15)
        *(_QWORD *)(v5 + 856) = v14;
      *(_QWORD *)(v13 + 104) = 3735928559;
      *(_QWORD *)(v13 + 64) = 0;
      obj_checkpoint_done((unsigned int *)v13);
      obj_release((uint64_t *)v13);
      v13 = *v14;
    }
    while (*v14);
  }
  for (i = *(_QWORD *)(v5 + 736); i; i = *(_QWORD *)(i + 88))
  {
    if ((*(_BYTE *)(i + 32) & 4) != 0)
      obj_checkpoint_done((unsigned int *)i);
  }
  v17 = *(_DWORD *)(a2 + 24);
  if ((v17 & 8) == 0)
    panic("can't transition from tx flags 0x%x to 0x%x (expected 0x%x)\n", v17, 1, 8);
  if ((v17 & 1) != 0)
    panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v17, 1, 8);
  *(_DWORD *)(a2 + 24) = v17 & 0xFFFFFFF6 | 1;
  __tp.tv_sec = 0;
  __tp.tv_nsec = 0;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
  *(_QWORD *)(a2 + 72) = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
  v18 = (pthread_cond_t *)(v4 + 256);
LABEL_73:
  cv_wakeup(v18);
  *(_DWORD *)(a2 + 52) = v11;
  return v11;
}

void APFSContainerGetFreespaceInfo_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: failed to get the APFS container disk path CString from source\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void APFSContainerGetFreespaceInfo_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: failed to retrieve tidemark from free extent info in spaceman\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void APFSContainerGetFreespaceInfo_cold_3()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_10();
  OUTLINED_FUNCTION_6(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: failed to get free extent info from spaceman, error = %d\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void APFSContainerGetFreespaceInfo_cold_4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: failed to load the container\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void APFSContainerGetFreespaceInfo_cold_5()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: failed to get the APFS container device handle\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void APFSContainerGetFreespaceInfo_cold_6()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: invalid source of APFS container\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void APFSContainerGetFreespaceInfo_cold_7()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: failed to allocate source callback state\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void APFSContainerGetFreespaceInfo_cold_8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: failed to allocate source handle\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void APFSContainerGetFreespaceInfo_cold_9()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: failed to load the container\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void APFSContainerGetFreespaceInfo_cold_10()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: failed to get block size from source\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void APFSContainerGetBootDevice_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: failed to create APFS volume match dictionary\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void APFSContainerGetBootDevice_cold_2(mach_error_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  mach_error_string(a1);
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_17();
  OUTLINED_FUNCTION_3(&dword_1DF291000, MEMORY[0x1E0C81028], v1, "%s:%d: cant find entries matching %s - %s\n", v2, v3, v4, v5, 2u);
  OUTLINED_FUNCTION_5();
}

void APFSSetupMetadataRollingMediaKey_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: found multiple data volumes\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void APFSSetupMetadataRollingMediaKey_cold_2()
{
  uint64_t v0;
  __int16 v1;
  int v2;
  _WORD v3[10];
  uint64_t v4;
  __int16 v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)v3 = 136315906;
  OUTLINED_FUNCTION_0();
  *(_DWORD *)&v3[7] = 2978;
  v3[9] = 2080;
  v4 = v0;
  v5 = v1;
  v6 = v2;
  _os_log_error_impl(&dword_1DF291000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s:%d: failed to generate metadata rolling keys for the DATA volume in APFS container %s, error = %d\n", (uint8_t *)v3, 0x22u);
  OUTLINED_FUNCTION_5();
}

void APFSSetupMetadataRollingMediaKey_cold_3(mach_error_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  mach_error_string(a1);
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_4(&dword_1DF291000, MEMORY[0x1E0C81028], v1, "%s:%d: failed to lookup data volume - %s\n", v2, v3, v4, v5, 2u);
  OUTLINED_FUNCTION_5();
}

void APFSStreamRestoreWrite_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_15();
  OUTLINED_FUNCTION_16(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: comp_crc=0x%x embed_crc=0x%x\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_5();
}

void APFSStreamRestoreWrite_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_13();
  OUTLINED_FUNCTION_3(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: len=%llu embed_len=%llu\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_5();
}

void APFSStreamFingerprintWrite_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: delta_canonicalize() returned EILSEQ...\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void APFSStreamFingerprintWrite_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_15();
  OUTLINED_FUNCTION_16(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: computed_crc=%x, embedded_crc=%x", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_5();
}

void APFSStreamFingerprintWrite_cold_3()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_13();
  OUTLINED_FUNCTION_3(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: computed_len=%llu, embedded_len=%llu\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_5();
}

void APFSGetFragmentationHistogram_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_4(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: Failed to create fragmentation histogram array for %s\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_5();
}

void APFSGetFragmentationHistogram_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_4(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: Failed to create fragmentation histogram entry for %s\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_5();
}

void APFSCaptureFinishCaptureForFile_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_18(*MEMORY[0x1E0C80C00]);
  OUTLINED_FUNCTION_8();
  OUTLINED_FUNCTION_9(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: Failed to move file %s to %s: %d", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_14();
}

void APFSCaptureFinishCaptureForFile_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_18(*MEMORY[0x1E0C80C00]);
  OUTLINED_FUNCTION_8();
  OUTLINED_FUNCTION_9(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: Failed to transfer extents from %s to %s: %d", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_14();
}

void APFSContainerCommitTemporaryCheckpoint_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_10();
  OUTLINED_FUNCTION_6(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: tx_leave failed: %u\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void APFSContainerCommitTemporaryCheckpoint_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_10();
  OUTLINED_FUNCTION_6(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: tx_enter failed: %u\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void APFSContainerCommitTemporaryCheckpoint_cold_3()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_10();
  OUTLINED_FUNCTION_6(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: failed to load the container: %u\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void APFSVolumeConvertToUserCrypto_cold_1()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v0 = OUTLINED_FUNCTION_18(*MEMORY[0x1E0C80C00]);
  strerror(*v0);
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_7();
  OUTLINED_FUNCTION_3(&dword_1DF291000, MEMORY[0x1E0C81028], v1, "%s:%d: could not open metrics log file %s: %s", v2, v3, v4, v5, 2u);
  OUTLINED_FUNCTION_12();
}

void APFSVolumeConvertToUserCrypto_cold_2(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  OUTLINED_FUNCTION_19(a2, *MEMORY[0x1E0C80C00]);
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_7();
  OUTLINED_FUNCTION_3(&dword_1DF291000, MEMORY[0x1E0C81028], v2, "%s:%d: APFS_IOUC_VOLUME_CONVERT_TO_USER_CRYPTO failed for disk %s: %s", v3, v4, v5, v6, 2u);
  OUTLINED_FUNCTION_12();
}

void APFSVolumeConvertToUserCrypto_cold_3(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  OUTLINED_FUNCTION_19(a2, *MEMORY[0x1E0C80C00]);
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_7();
  OUTLINED_FUNCTION_3(&dword_1DF291000, MEMORY[0x1E0C81028], v2, "%s:%d: container_iouc failed for disk %s: %s", v3, v4, v5, v6, 2u);
  OUTLINED_FUNCTION_12();
}

void keygen_nvram_prop_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_17();
  OUTLINED_FUNCTION_4(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: Failed to create CFstring string from C string %s\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_5();
}

void keygen_nvram_prop_cold_2()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: nvram is not supported on this system\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_2();
}

void keygen_nvram_prop_cold_3(mach_error_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  mach_error_string(a1);
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_9(&dword_1DF291000, MEMORY[0x1E0C81028], v1, "%s:%d: Failed to set io registry property for key %s: %s (0x%08x)\n", v2, v3, v4, v5, 2u);
  OUTLINED_FUNCTION_14();
}

void keygen_nvram_prop_cold_4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_17();
  OUTLINED_FUNCTION_4(&dword_1DF291000, MEMORY[0x1E0C81028], v0, "%s:%d: Failed to find property with the key %s\n", v1, v2, v3, v4, 2u);
  OUTLINED_FUNCTION_5();
}

int CC_SHA512_Final(unsigned __int8 *md, CC_SHA512_CTX *c)
{
  return MEMORY[0x1E0C803B0](md, c);
}

int CC_SHA512_Init(CC_SHA512_CTX *c)
{
  return MEMORY[0x1E0C803B8](c);
}

int CC_SHA512_Update(CC_SHA512_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1E0C803C0](c, data, *(_QWORD *)&len);
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x1E0C97CF8](theArray, value);
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
  MEMORY[0x1E0C97D00](theArray, range.location, range.length, applier, context);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D38](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1E0C97D60](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1E0C97D90]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1E0C97D98](theArray, idx);
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x1E0C97DD0](theArray, idx, value);
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
  MEMORY[0x1E0C97DE0](theArray, range.location, range.length, comparator, context);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1E0C97FC8]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1E0C97FE0](BOOLean);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1E0C983A0](allocator, bytes, length);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1E0C983E0](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1E0C983F8](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1E0C98418]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98500](theDict, key, value);
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98508](theDict, applier, context);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98550](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1E0C98570](theDict);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1E0C985A8]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1E0C985B8](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1E0C985C8](theDict, key, value);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x1E0C985E8](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98610](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1E0C98620](cf1, cf2);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1E0C98738](cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1E0C98928](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1E0C989B8]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1E0C989C0](number, theType, valuePtr);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x1E0C98BC0](cf);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F10](theString1, theString2, compareOptions);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F98](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98FD0](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1E0C99018](alloc, formatOptions, format);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99098](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1E0C990A0](theString, *(_QWORD *)&encoding);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return MEMORY[0x1E0C99168]();
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1E0C99170]();
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
  MEMORY[0x1E0C991B8](str, idx, insertedStr);
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)MEMORY[0x1E0C99530](alloc, *(_QWORD *)&bytes.byte0, *(_QWORD *)&bytes.byte8);
}

CFTypeID CFUUIDGetTypeID(void)
{
  return MEMORY[0x1E0C99560]();
}

CFMutableDictionaryRef IOBSDNameMatching(mach_port_t mainPort, uint32_t options, const char *bsdName)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0CBAD28](*(_QWORD *)&mainPort, *(_QWORD *)&options, bsdName);
}

CFTypeRef IOCFUnserialize(const char *buffer, CFAllocatorRef allocator, CFOptionFlags options, CFStringRef *errorString)
{
  return (CFTypeRef)MEMORY[0x1E0CBAD38](buffer, allocator, options, errorString);
}

kern_return_t IOConnectCallStructMethod(mach_port_t connection, uint32_t selector, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt)
{
  return MEMORY[0x1E0CBAD90](*(_QWORD *)&connection, *(_QWORD *)&selector, inputStruct, inputStructCnt, outputStruct, outputStructCnt);
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return MEMORY[0x1E0CBB668](*(_QWORD *)&iterator);
}

BOOLean_t IOObjectConformsTo(io_object_t object, const io_name_t className)
{
  return MEMORY[0x1E0CBB6C8](*(_QWORD *)&object, className);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x1E0CBB6F0](*(_QWORD *)&object);
}

kern_return_t IOObjectRetain(io_object_t object)
{
  return MEMORY[0x1E0CBB6F8](*(_QWORD *)&object);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x1E0CBB900](*(_QWORD *)&entry, key, allocator, *(_QWORD *)&options);
}

io_registry_entry_t IORegistryEntryFromPath(mach_port_t mainPort, const io_string_t path)
{
  return MEMORY[0x1E0CBB918](*(_QWORD *)&mainPort, path);
}

kern_return_t IORegistryEntryGetChildIterator(io_registry_entry_t entry, const io_name_t plane, io_iterator_t *iterator)
{
  return MEMORY[0x1E0CBB920](*(_QWORD *)&entry, plane, iterator);
}

kern_return_t IORegistryEntryGetLocationInPlane(io_registry_entry_t entry, const io_name_t plane, io_name_t location)
{
  return MEMORY[0x1E0CBB928](*(_QWORD *)&entry, plane, location);
}

kern_return_t IORegistryEntryGetParentEntry(io_registry_entry_t entry, const io_name_t plane, io_registry_entry_t *parent)
{
  return MEMORY[0x1E0CBB958](*(_QWORD *)&entry, plane, parent);
}

kern_return_t IORegistryEntryGetParentIterator(io_registry_entry_t entry, const io_name_t plane, io_iterator_t *iterator)
{
  return MEMORY[0x1E0CBB960](*(_QWORD *)&entry, plane, iterator);
}

kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t *entryID)
{
  return MEMORY[0x1E0CBB988](*(_QWORD *)&entry, entryID);
}

CFTypeRef IORegistryEntrySearchCFProperty(io_registry_entry_t entry, const io_name_t plane, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x1E0CBB9A0](*(_QWORD *)&entry, plane, key, allocator, *(_QWORD *)&options);
}

kern_return_t IORegistryEntrySetCFProperty(io_registry_entry_t entry, CFStringRef propertyName, CFTypeRef property)
{
  return MEMORY[0x1E0CBB9B0](*(_QWORD *)&entry, propertyName, property);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return MEMORY[0x1E0CBB9D0](*(_QWORD *)&connect);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x1E0CBB9E0](*(_QWORD *)&mainPort, matching);
}

kern_return_t IOServiceGetMatchingServices(mach_port_t mainPort, CFDictionaryRef matching, io_iterator_t *existing)
{
  return MEMORY[0x1E0CBB9F0](*(_QWORD *)&mainPort, matching, existing);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0CBBA00](name);
}

kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect)
{
  return MEMORY[0x1E0CBBA10](*(_QWORD *)&service, *(_QWORD *)&owningTask, *(_QWORD *)&type, connect);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x1E0C80A20](exception_object);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4448](this, __s, __n);
}

void operator delete(void *__p)
{
  off_1EA983CC0(__p);
}

int *__error(void)
{
  return (int *)MEMORY[0x1E0C80AC0]();
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1E0C80B68]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1E0C80C48]();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81038](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81048](dso, log, type, format, buf, *(_QWORD *)&size);
}

int aio_error(const aiocb *aiocbp)
{
  return MEMORY[0x1E0C81528](aiocbp);
}

int aio_read(aiocb *aiocbp)
{
  return MEMORY[0x1E0C81530](aiocbp);
}

ssize_t aio_return(aiocb *aiocbp)
{
  return MEMORY[0x1E0C81538](aiocbp);
}

int aio_suspend(const aiocb *const aiocblist[], int nent, const timespec *timeoutp)
{
  return MEMORY[0x1E0C81540](aiocblist, *(_QWORD *)&nent, timeoutp);
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1E0C81608](a1, a2);
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x1E0C816B8](a1, *(_QWORD *)&a2);
}

char **__cdecl backtrace_symbols(void *const *a1, int a2)
{
  return (char **)MEMORY[0x1E0C816C8](a1, *(_QWORD *)&a2);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

uint64_t ccdigest()
{
  return MEMORY[0x1E0C81BD0]();
}

uint64_t ccsha256_di()
{
  return MEMORY[0x1E0C823E0]();
}

uint64_t ccsha384_di()
{
  return MEMORY[0x1E0C823E8]();
}

uint64_t ccsha512_256_di()
{
  return MEMORY[0x1E0C823F0]();
}

uint64_t ccsha512_di()
{
  return MEMORY[0x1E0C823F8]();
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  return MEMORY[0x1E0C82668](*(_QWORD *)&__clock_id, __tp);
}

int close(int a1)
{
  return MEMORY[0x1E0C82688](*(_QWORD *)&a1);
}

int fclose(FILE *a1)
{
  return MEMORY[0x1E0C832F8](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1E0C83300](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1E0C83460](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C83478](a1, a2);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

uint64_t freemntopts()
{
  return MEMORY[0x1E0DE8BB8]();
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1E0C83560](*(_QWORD *)&a1, a2);
}

int fstatfs(int a1, statfs *a2)
{
  return MEMORY[0x1E0C83570](*(_QWORD *)&a1, a2);
}

int fsync(int a1)
{
  return MEMORY[0x1E0C83578](*(_QWORD *)&a1);
}

FTSENT *__cdecl fts_children(FTS *a1, int a2)
{
  return (FTSENT *)MEMORY[0x1E0C83598](a1, *(_QWORD *)&a2);
}

int fts_close(FTS *a1)
{
  return MEMORY[0x1E0C835A0](a1);
}

FTS *__cdecl fts_open(char *const *a1, int a2, int (__cdecl *a3)(const FTSENT **, const FTSENT **))
{
  return (FTS *)MEMORY[0x1E0C835A8](a1, *(_QWORD *)&a2, a3);
}

FTSENT *__cdecl fts_read(FTS *a1)
{
  return (FTSENT *)MEMORY[0x1E0C835B0](a1);
}

gid_t getgid(void)
{
  return MEMORY[0x1E0C83678]();
}

int getmntinfo(statfs **a1, int a2)
{
  return MEMORY[0x1E0C836F8](a1, *(_QWORD *)&a2);
}

uint64_t getmntoptnum()
{
  return MEMORY[0x1E0DE8BC8]();
}

uint64_t getmntopts()
{
  return MEMORY[0x1E0DE8BD0]();
}

uid_t getuid(void)
{
  return MEMORY[0x1E0C83828]();
}

int ioctl(int a1, unint64_t a2, ...)
{
  return MEMORY[0x1E0C83980](*(_QWORD *)&a1, a2);
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C83C40](a1, a2);
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return (char *)MEMORY[0x1E0C83C80](*(_QWORD *)&error_value);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83EF8](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F00](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F10](ptr, size, type_id);
}

void *__cdecl malloc_type_valloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F18](size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1E0C84078](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1E0C84098](__dst, __src, __len);
}

int nanosleep(const timespec *__rqtp, timespec *__rmtp)
{
  return MEMORY[0x1E0C84238](__rqtp, __rmtp);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1E0C84480](a1, *(_QWORD *)&a2);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1E0C84780](oslog, type);
}

uint64_t os_parse_boot_arg_string()
{
  return MEMORY[0x1E0C84900]();
}

void panic(const char *a1, ...)
{
  MEMORY[0x1E0C84AD0](a1);
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1E0C84BC8](*(_QWORD *)&__fd, __buf, __nbyte, a4);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return MEMORY[0x1E0C84D18](a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return MEMORY[0x1E0C84D20](a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return MEMORY[0x1E0C84D28](a1, a2);
}

int pthread_cond_timedwait(pthread_cond_t *a1, pthread_mutex_t *a2, const timespec *a3)
{
  return MEMORY[0x1E0C84D38](a1, a2, a3);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return MEMORY[0x1E0C84D48](a1, a2);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E18](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1E0C84E20](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E28](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E38](a1);
}

int pthread_rwlock_destroy(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84E90](a1);
}

int pthread_rwlock_init(pthread_rwlock_t *a1, const pthread_rwlockattr_t *a2)
{
  return MEMORY[0x1E0C84E98](a1, a2);
}

int pthread_rwlock_rdlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84EA0](a1);
}

int pthread_rwlock_unlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84EB8](a1);
}

int pthread_rwlock_wrlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84EC0](a1);
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1E0C84F68](*(_QWORD *)&__fd, __buf, __nbyte, a4);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x1E0C84F88](__base, __nel, __width, __compar);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1E0C85040](a1, a2);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  MEMORY[0x1E0C85100](__from, __to, __ec);
}

unsigned int sleep(unsigned int a1)
{
  return MEMORY[0x1E0C85438](*(_QWORD *)&a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1E0C85440](__str, __size, __format);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C854D8](a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return MEMORY[0x1E0C85500](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1E0C85518](__s, *(_QWORD *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1E0C85520](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1E0C85540](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1E0C85548](*(_QWORD *)&__errnum);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1E0C85570](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x1E0C85590](a1, a2, a3);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1E0C855A8](__s1, __s2, __n);
}

char *__cdecl strndup(const char *__s1, size_t __n)
{
  return (char *)MEMORY[0x1E0C855B8](__s1, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return MEMORY[0x1E0C855C0](__s1, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1E0C855E8](__s, *(_QWORD *)&__c);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1E0C85610](__s1, __s2);
}

char *__cdecl strtok_r(char *__str, const char *__sep, char **__lasts)
{
  return (char *)MEMORY[0x1E0C85650](__str, __sep, __lasts);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C85658](__str, __endptr, *(_QWORD *)&__base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C85698](__str, __endptr, *(_QWORD *)&__base);
}

unint64_t strtoull(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C856A8](__str, __endptr, *(_QWORD *)&__base);
}

time_t time(time_t *a1)
{
  return MEMORY[0x1E0C85950](a1);
}

int unlink(const char *a1)
{
  return MEMORY[0x1E0C859B8](a1);
}

void uuid_clear(uuid_t uu)
{
  MEMORY[0x1E0C85A00](uu);
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
  MEMORY[0x1E0C85A10](dst, src);
}

void uuid_generate(uuid_t out)
{
  MEMORY[0x1E0C85A18](out);
}

int uuid_is_null(const uuid_t uu)
{
  return MEMORY[0x1E0C85A30](uu);
}

int uuid_parse(const uuid_string_t in, uuid_t uu)
{
  return MEMORY[0x1E0C85A38](in, uu);
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
  MEMORY[0x1E0C85A40](uu, out);
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  return MEMORY[0x1E0C85A68](a1, a2, a3);
}

