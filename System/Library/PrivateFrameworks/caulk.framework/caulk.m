unsigned int *caulk::pooled_semaphore_mutex::_unlock(caulk::pooled_semaphore_mutex *this)
{
  return caulk::pooled_semaphore_mutex::unlock_impl((unsigned int *)this, 0);
}

unint64_t caulk::pooled_semaphore_mutex::_lock(caulk::pooled_semaphore_mutex *this)
{
  return caulk::pooled_semaphore_mutex::lock_impl((unint64_t)this, 0);
}

_QWORD *__destroy_helper_block_ea8_32c60_ZTSKZN5caulk3xpc22reply_watchdog_factory10make_timerEiE3__0(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t __copy_helper_block_ea8_32c60_ZTSKZN5caulk3xpc22reply_watchdog_factory10make_timerEiE3__0(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<void * ()(unsigned long,unsigned long)>::__value_func[abi:ne180100](a1 + 32, a2 + 32);
}

uint64_t caulk::semaphore::signal(uint64_t this)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(this + 8);
  do
    v2 = __ldxr(v1);
  while (__stlxr(v2 + 1, v1));
  if ((v2 & 0x80000000) != 0)
    JUMPOUT(0x20BCFA1F0);
  return this;
}

uint64_t caulk::pooled_semaphore_mutex::try_lock(caulk::pooled_semaphore_mutex *this)
{
  unsigned int v1;
  uint64_t result;
  unsigned int v3;

  v1 = atomic_load((unsigned int *)this);
  if ((_WORD)v1)
    return 0;
  while (1)
  {
    v3 = __ldaxr((unsigned int *)this);
    if (v3 != v1)
      break;
    if (!__stlxr(1u, (unsigned int *)this))
    {
      __dmb(9u);
      return 1;
    }
  }
  result = 0;
  __clrex();
  return result;
}

unint64_t *caulk::concurrent::messenger::enqueue(unint64_t **a1, unint64_t a2)
{
  unint64_t *result;
  unsigned int *v3;
  unsigned int v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  int v9;

  result = *a1;
  v3 = (unsigned int *)(a2 + 16);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 | 1, v3));
  if (v4)
  {
    __break(1u);
    return result;
  }
  v5 = result + 1;
  v6 = result[1];
  atomic_store(v6, (unint64_t *)(a2 + 8));
  v7 = __ldaxr(result + 1);
  if (v7 != v6)
  {
    __clrex();
LABEL_8:
    while (1)
    {
      atomic_store(v7, (unint64_t *)(a2 + 8));
      v8 = __ldaxr(v5);
      if (v8 != v7)
        break;
      if (__stlxr(a2, v5))
        goto LABEL_12;
      v9 = 1;
LABEL_13:
      v7 = v8;
      if (v9)
        goto LABEL_14;
    }
    __clrex();
LABEL_12:
    v9 = 0;
    goto LABEL_13;
  }
  if (__stlxr(a2, v5))
    goto LABEL_8;
LABEL_14:
  __dmb(0xBu);
  return (unint64_t *)(*(uint64_t (**)(unint64_t *))(*result + 16))(result);
}

unsigned int *caulk::pooled_semaphore_mutex::unlock_impl(unsigned int *this, char a2)
{
  caulk::details::semaphore_pool *v2;
  caulk::details::semaphore_pool *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  if ((a2 & 1) == 0)
    __dmb(0xBu);
  v4 = *this;
  if ((unsigned __int16)*this)
  {
    v5 = *this;
    do
    {
      v6 = v5;
      v2 = (caulk::details::semaphore_pool *)HIWORD(v5);
      if ((unsigned __int16)v4 == 1)
        v3 = 0;
      else
        v3 = (caulk::details::semaphore_pool *)v2;
      v5 = __ldaxr(this);
      if (v5 == v6)
      {
        if (!__stlxr((unsigned __int16)(v4 - 1) | ((unsigned __int16)v3 << 16), this))
          goto LABEL_14;
      }
      else
      {
        __clrex();
      }
      LOWORD(v4) = v5;
    }
    while ((_WORD)v5);
  }
  __break(1u);
LABEL_14:
  if ((_DWORD)v3)
  {
    if ((a2 & 1) == 0)
    {
      caulk::details::semaphore_pool::instance((caulk::details::semaphore_pool *)this);
      this = (unsigned int *)caulk::details::semaphore_pool::sema_ref_to_bank(v3);
      v7 = &this[4 * (unsigned __int16)((_WORD)v3 - *(_WORD *)this) + 3];
      do
        v8 = __ldxr(v7);
      while (__stlxr(v8 + 1, v7));
      if ((v8 & 0x80000000) != 0)
        JUMPOUT(0x20BCFA1F0);
    }
  }
  else if ((_DWORD)v2)
  {
    caulk::details::semaphore_pool::instance((caulk::details::semaphore_pool *)this);
    this = (unsigned int *)caulk::details::semaphore_pool::sema_ref_to_bank(v2);
    v9 = ~(1 << (v2 - *(_WORD *)this));
    v10 = (unint64_t *)(this + 260);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 & v9, v10));
  }
  return this;
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_size_for_ptr()
{
  return 0;
}

uint64_t caulk::xpc::reply_watchdog_factory::reply_watchdog_factory(uint64_t this)
{
  *(_BYTE *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_QWORD *)(this + 32) = 0;
  return this;
}

{
  *(_BYTE *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_QWORD *)(this + 32) = 0;
  return this;
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_size_for_ptr(uint64_t a1, unint64_t a2)
{
  unsigned __int128 *v3;
  uint64_t owner;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  char v9;
  unsigned __int128 *v11;
  unsigned __int128 *v12;

  v3 = *(unsigned __int128 **)(a1 - 8);
  v11 = v3 + 62;
  v12 = v3 + 72;
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal(v3 + 72);
  owner = caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::find_owner((uint64_t *)&v11, a2);
  if (owner)
    v5 = caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::size(owner + 16, a2);
  else
    v5 = 0;
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v3 + 72);
  if (!v5)
  {
    v11 = v3 + 24;
    v12 = v3 + 34;
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal(v3 + 34);
    v6 = caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::find_owner((uint64_t *)&v11, a2);
    v5 = v6
       ? caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>::size(v6 + 16, a2)
       : 0;
    caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v3 + 34);
    if (!v5)
    {
      caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal(v3 + 18);
      v11 = (unsigned __int128 *)a2;
      v7 = caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::search_to_level<caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::key_le>((uint64_t)(v3 + 2), &v11, 0);
      if (*(_QWORD *)(v7 + 16) != a2)
      {
        if (*(_BYTE *)(v8 + 26) == 2)
          v7 = (unint64_t)v3 + 232;
        else
          v7 = v8;
      }
      if ((unsigned __int128 *)v7 == (unsigned __int128 *)((char *)v3 + 232)
        || *(_BYTE *)(v7 + 26) == 2
        || (v9 = atomic_load((unint64_t *)(v7 + 40)), (v9 & 1) != 0)
        || *(_QWORD *)(v7 + 16) != a2)
      {
        v5 = 0;
      }
      else
      {
        v5 = *(_QWORD *)v7;
      }
      caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal(v3 + 18);
    }
  }
  return v5;
}

double caulk::mach::os_workgroup_interval_managed::make_with_workload_id@<D0>(uint64_t a1@<X8>)
{
  double result;
  uint64_t v3;

  if (os_workgroup_attr_set_interval_type())
  {
    *(_QWORD *)(a1 + 56) = 0;
    result = 0.0;
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 24) = 0u;
    *(_OWORD *)(a1 + 8) = 0u;
    *(_QWORD *)a1 = &off_24BF2E0C8;
  }
  else
  {
    v3 = os_workgroup_interval_create_with_workload_id();
    result = 0.0;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 41) = 0u;
    *(_QWORD *)a1 = &off_24BF2E0C8;
    *(_QWORD *)(a1 + 8) = v3;
    *(_BYTE *)(a1 + 57) = 0;
  }
  return result;
}

{
  return caulk::mach::os_workgroup_interval_managed::make_with_workload_id(a1);
}

uint64_t caulk::mach::thread::priority_realtime::apply_to_this_thread(integer_t *this)
{
  _opaque_pthread_t *v2;

  v2 = pthread_self();
  return caulk::mach::thread::priority_realtime::apply_to_thread(this, v2);
}

double caulk::mach::os_workgroup_managed::make@<D0>(const char *a1@<X0>, mach_port_t a2@<W1>, uint64_t a3@<X8>)
{
  os_workgroup_t v4;
  double result;

  if (a1[23] < 0)
    a1 = *(const char **)a1;
  v4 = os_workgroup_create_with_port(a1, a2);
  *(_QWORD *)a3 = &off_24BF2E088;
  *(_QWORD *)(a3 + 8) = v4;
  result = 0.0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 41) = 0u;
  return result;
}

uint64_t caulk::mach::thread::priority_realtime::apply_to_thread(integer_t *this, pthread_t a2)
{
  thread_act_t v3;

  v3 = pthread_mach_thread_np(a2);
  return thread_policy_set(v3, 2u, this, 4u);
}

uint64_t *caulk::alloc::make_audio_buffer_resource(caulk::alloc *this)
{
  const char *zone_name;
  const char *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  _QWORD *v5;
  malloc_zone_t *zone;

  zone_name = malloc_get_zone_name(*(malloc_zone_t **)*MEMORY[0x24BDAEDD8]);
  if (zone_name && !strcmp(zone_name, "ProbGuardMallocZone"))
  {
    v5 = (_QWORD *)operator new();
    *v5 = &off_24BF2CD90;
    v5[1] = 0;
    v5[2] = 0;
    v4 = v5 + 2;
    v5[3] = 0;
    zone = malloc_create_zone(0, 0);
    v5[2] = &off_24BF2CEA8;
    v5[3] = zone;
    malloc_set_zone_name(zone, "caulk::audio_buffer_resource");
  }
  else
  {
    if ((v3 & 1) == 0
    {
      caulk::alloc::exported_resource<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>,caulk::alloc::memory_resource,caulk::memory_resource>::exported_resource<char const*>();
    }
    dword_253D0A0E8 = 1;
    v4 = &qword_253D09DE0;
    dword_253D09F50 = 1;
    dword_253D09DF0 = 1;
    caulk::alloc::registerAllocatorStateDump((caulk::alloc *)&qword_253D09DE0, (caulk::alloc::memory_resource *)"com.apple.caulk.alloc.audiodump", "caulk_audio_alloc.", v2);
  }
  return v4;
}

void sub_2065BFB44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void caulk::alloc::registerAllocatorStateDump(caulk::alloc *this, caulk::alloc::memory_resource *a2, const char *a3, const char *a4)
{
  NSObject *global_queue;
  caulk::alloc::base_allocator *v8;
  int v9;
  NSObject *v10;
  _QWORD handler[6];
  int out_token;
  uint8_t buf[4];
  caulk::alloc::memory_resource *v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  out_token = 0;
  global_queue = dispatch_get_global_queue(0, 0);
  handler[0] = MEMORY[0x24BDAC760];
  handler[1] = 0x40000000;
  handler[2] = ___ZN5caulk5allocL26registerAllocatorStateDumpEPNS0_15memory_resourceEPKcS4__block_invoke;
  handler[3] = &__block_descriptor_tmp;
  handler[4] = a3;
  handler[5] = this;
  v8 = (caulk::alloc::base_allocator *)notify_register_dispatch((const char *)a2, &out_token, global_queue, handler);
  v9 = (int)v8;
  caulk::alloc::base_allocator::log(v8);
  v10 = caulk::alloc::base_allocator::log(void)::global;
  if (os_log_type_enabled((os_log_t)caulk::alloc::base_allocator::log(void)::global, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    v14 = a2;
    v15 = 1024;
    v16 = v9;
    _os_log_impl(&dword_2065BE000, v10, OS_LOG_TYPE_DEFAULT, "Registered notify signal %s (%u)", buf, 0x12u);
  }
}

uint64_t *caulk::alloc::base_allocator::log(caulk::alloc::base_allocator *this)
{
  unsigned __int8 v1;

  {
    qword_253D0A388 = 0;
    caulk::alloc::base_allocator::log(void)::global = (uint64_t)os_log_create("com.apple.audio.caulk", "alloc");
  }
  return &caulk::alloc::base_allocator::log(void)::global;
}

uint64_t caulk::mach::os_workgroup_managed::join(caulk::mach::os_workgroup_managed *this)
{
  uint64_t result;

  if (*((_BYTE *)this + 56))
    return 1;
  if (!*((_QWORD *)this + 1))
    return 2;
  result = os_workgroup_join_self();
  *((_BYTE *)this + 56) = (_DWORD)result == 0;
  return result;
}

void caulk::mach::os_workgroup_interval_managed::~os_workgroup_interval_managed(caulk::mach::details **this, void *a2)
{
  *this = (caulk::mach::details *)&off_24BF2E088;
  caulk::mach::details::release_os_object(this[1], a2);
}

{
  *this = (caulk::mach::details *)&off_24BF2E088;
  caulk::mach::details::release_os_object(this[1], a2);
  JUMPOUT(0x20BCF9C08);
}

{
  *this = (caulk::mach::details *)&off_24BF2E088;
  caulk::mach::details::release_os_object(this[1], a2);
}

void caulk::mach::os_workgroup_managed::~os_workgroup_managed(caulk::mach::details **this, void *a2)
{
  *this = (caulk::mach::details *)&off_24BF2E088;
  caulk::mach::details::release_os_object(this[1], a2);
}

{
  *this = (caulk::mach::details *)&off_24BF2E088;
  caulk::mach::details::release_os_object(this[1], a2);
  JUMPOUT(0x20BCF9C08);
}

{
  *this = (caulk::mach::details *)&off_24BF2E088;
  caulk::mach::details::release_os_object(this[1], a2);
}

void caulk::mach::details::release_os_object(caulk::mach::details *this, void *a2)
{
  if (this)
    os_release(this);
}

_QWORD *caulk::xpc::reply_watchdog_factory::init2(uint64_t a1, int a2, uint64_t a3)
{
  caulk *v6;
  _QWORD *v7;
  _QWORD *result;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;

  v6 = (caulk *)getpid();
  *(_BYTE *)a1 = caulk::is_debugger_attached(v6);
  *(_DWORD *)(a1 + 4) = a2;
  v7 = (_QWORD *)(a1 + 8);
  v10 = *(_QWORD **)(a1 + 32);
  v9 = (_QWORD *)(a1 + 32);
  result = v10;
  *v9 = 0;
  if (v10 == v7)
  {
    v11 = 4;
    result = v7;
  }
  else
  {
    if (!result)
      goto LABEL_6;
    v11 = 5;
  }
  result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v11))();
LABEL_6:
  v12 = (_QWORD *)(a3 + 24);
  v13 = *(_QWORD *)(a3 + 24);
  if (!v13)
  {
    v12 = v9;
    goto LABEL_10;
  }
  if (v13 != a3)
  {
    *v9 = v13;
LABEL_10:
    *v12 = 0;
    return result;
  }
  *v9 = v7;
  return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)*v12 + 24))(*v12, v7);
}

uint64_t caulk::is_debugger_attached(caulk *this)
{
  size_t v2;
  _BYTE v3[32];
  unsigned int v4;
  int v5[2];
  int v6;
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)v5 = 0xE00000001;
  v6 = 1;
  v7 = (int)this;
  v2 = 648;
  v4 = 0;
  sysctl(v5, 4u, v3, &v2, 0, 0);
  return (v4 >> 11) & 1;
}

OS_os_workgroup *caulk::mach::os_workgroup_managed::copy_mach_port(caulk::mach::os_workgroup_managed *this)
{
  OS_os_workgroup *result;
  mach_port_t mach_port_out;

  result = (OS_os_workgroup *)*((_QWORD *)this + 1);
  if (result)
  {
    mach_port_out = 0;
    if (os_workgroup_copy_port(result, &mach_port_out))
      return 0;
    else
      return (OS_os_workgroup *)mach_port_out;
  }
  return result;
}

void *caulk::mach::details::retain_os_object(void *this, void *a2)
{
  if (this)
    return os_retain(this);
  return this;
}

void *caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::do_allocate(uint64_t a1, unint64_t a2, unint64_t a3)
{
  void *v5;
  size_t v6;
  void *v7;
  void (*v8)(uint64_t, uint64_t, unint64_t, _QWORD, void *, _QWORD);
  std::bad_alloc *exception;
  std::bad_alloc *v11;

  v5 = (void *)caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,256000ul,caulk::alloc::guarded_edges_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,4ul>>,caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>::allocate(a1 + 16, a2, a3);
  if (!v5)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v11 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v11, MEMORY[0x24BEDB758], MEMORY[0x24BEDB670]);
  }
  v7 = v5;
  bzero(v5, v6);
  v8 = *(void (**)(uint64_t, uint64_t, unint64_t, _QWORD, void *, _QWORD))(a1 + 1408);
  if (v8)
    v8(10, *(_QWORD *)(a1 + 1392) + 8, a2, 0, v7, 0);
  return v7;
}

uint64_t caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::maybe_create_free_node(uint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;

  v3 = *(_QWORD *)(a2 + 24);
  v4 = (v3 >> 1) - a3;
  if (v4 >= 0x21)
  {
    v6 = a2 + a3;
    v7 = (_QWORD *)(a2 + a3 + 32);
    *(_QWORD *)(v6 + 48) = (2 * a3) | 1;
    *(_QWORD *)(v6 + 56) = (v3 & 1 | (2 * v4)) - 64;
    *(_QWORD *)(a2 + 24) = 2 * a3;
    v8 = *(_QWORD *)(v6 + 56);
    if ((v8 & 1) == 0)
      *(_QWORD *)((char *)v7 + (v8 >> 1) + 48) = v8 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)((char *)v7 + (v8 >> 1) + 48) & 1;
    return caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::add_freemap_node(result, v7);
  }
  return result;
}

uint64_t caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::add_freemap_node(uint64_t result, _QWORD *a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t **v5;
  uint64_t *v6;
  uint64_t *v7;
  _QWORD *v8;
  unint64_t v9;
  BOOL v10;
  _QWORD *v11;
  uint64_t **v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  _QWORD *v16;

  v3 = result;
  v4 = a2[3] >> 1;
  v5 = (uint64_t **)(result + 368);
  v6 = *(uint64_t **)(result + 368);
  if (!v6)
  {
    v12 = (uint64_t **)(result + 368);
LABEL_19:
    v7 = (uint64_t *)operator new(0x38uLL);
    v7[5] = 0;
    v7[6] = 0;
    v7[4] = v4;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = (uint64_t)v12;
    *v5 = v7;
    v14 = **(_QWORD **)(v3 + 360);
    v15 = v7;
    if (v14)
    {
      *(_QWORD *)(v3 + 360) = v14;
      v15 = *v5;
    }
    result = (uint64_t)std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v3 + 368), v15);
    ++*(_QWORD *)(v3 + 376);
    goto LABEL_22;
  }
  v7 = (uint64_t *)(result + 368);
  v8 = *(_QWORD **)(result + 368);
  do
  {
    v9 = v8[4];
    v10 = v9 >= v4;
    if (v9 >= v4)
      v11 = v8;
    else
      v11 = v8 + 1;
    if (v10)
      v7 = v8;
    v8 = (_QWORD *)*v11;
  }
  while (*v11);
  if (v7 != (uint64_t *)v5 && v7[4] <= v4)
  {
LABEL_22:
    v16 = (_QWORD *)v7[6];
    *a2 = v7 + 5;
    a2[1] = v16;
    if (v16)
      *v16 = a2;
    v7[6] = (uint64_t)a2;
    return result;
  }
  while (1)
  {
    while (1)
    {
      v12 = (uint64_t **)v6;
      v13 = v6[4];
      if (v13 <= v4)
        break;
      v6 = *v12;
      v5 = v12;
      if (!*v12)
        goto LABEL_19;
    }
    if (v13 >= v4)
      break;
    v6 = v12[1];
    if (!v6)
    {
      v5 = v12 + 1;
      goto LABEL_19;
    }
  }
  _os_assert_log();
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t **std::__tree<std::__value_type<unsigned long,caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::FreelistOfSize>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::FreelistOfSize>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::FreelistOfSize>>>::__remove_node_pointer(uint64_t **result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  int v9;
  uint64_t **v10;
  uint64_t *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t *v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v25 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v25);
  }
  if (*result == a2)
    *result = v3;
  v5 = result[1];
  result[2] = (uint64_t *)((char *)result[2] - 1);
  v6 = *a2;
  v7 = a2;
  if (*a2)
  {
    v8 = (uint64_t *)a2[1];
    if (!v8)
    {
      v7 = a2;
      goto LABEL_15;
    }
    do
    {
      v7 = v8;
      v8 = (uint64_t *)*v8;
    }
    while (v8);
  }
  v6 = v7[1];
  if (v6)
  {
LABEL_15:
    v9 = 0;
    *(_QWORD *)(v6 + 16) = v7[2];
    goto LABEL_16;
  }
  v9 = 1;
LABEL_16:
  v10 = (uint64_t **)v7[2];
  v11 = *v10;
  if (*v10 == v7)
  {
    *v10 = (uint64_t *)v6;
    if (v7 == v5)
    {
      v11 = 0;
      v5 = (uint64_t *)v6;
    }
    else
    {
      v11 = v10[1];
    }
  }
  else
  {
    v10[1] = (uint64_t *)v6;
  }
  v12 = *((unsigned __int8 *)v7 + 24);
  if (v7 != a2)
  {
    v13 = a2[2];
    v7[2] = v13;
    *(_QWORD *)(v13 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v7;
    v15 = *a2;
    v14 = a2[1];
    *(_QWORD *)(v15 + 16) = v7;
    *v7 = v15;
    v7[1] = v14;
    if (v14)
      *(_QWORD *)(v14 + 16) = v7;
    *((_BYTE *)v7 + 24) = *((_BYTE *)a2 + 24);
    if (v5 == a2)
      v5 = v7;
  }
  if (!v12 || !v5)
    return result;
  if (!v9)
  {
    *(_BYTE *)(v6 + 24) = 1;
    return result;
  }
  while (1)
  {
    v16 = v11[2];
    if (*(uint64_t **)v16 != v11)
      break;
    if (!*((_BYTE *)v11 + 24))
    {
      *((_BYTE *)v11 + 24) = 1;
      *(_BYTE *)(v16 + 24) = 0;
      v22 = v11[1];
      *(_QWORD *)v16 = v22;
      if (v22)
        *(_QWORD *)(v22 + 16) = v16;
      v11[2] = *(_QWORD *)(v16 + 16);
      *(_QWORD *)(*(_QWORD *)(v16 + 16) + 8 * (**(_QWORD **)(v16 + 16) != v16)) = v11;
      v11[1] = v16;
      *(_QWORD *)(v16 + 16) = v11;
      if (v5 == (uint64_t *)v16)
        v5 = v11;
      v11 = *(uint64_t **)v16;
    }
    v23 = (_QWORD *)*v11;
    if (*v11 && !*((_BYTE *)v23 + 24))
      goto LABEL_76;
    v24 = (uint64_t *)v11[1];
    if (v24 && !*((_BYTE *)v24 + 24))
    {
      if (v23 && !*((_BYTE *)v23 + 24))
      {
LABEL_76:
        v24 = v11;
      }
      else
      {
        *((_BYTE *)v24 + 24) = 1;
        *((_BYTE *)v11 + 24) = 0;
        v30 = *v24;
        v11[1] = *v24;
        if (v30)
          *(_QWORD *)(v30 + 16) = v11;
        v24[2] = v11[2];
        *(_QWORD *)(v11[2] + 8 * (*(_QWORD *)v11[2] != (_QWORD)v11)) = v24;
        *v24 = (uint64_t)v11;
        v11[2] = (uint64_t)v24;
        v23 = v11;
      }
      v27 = v24[2];
      *((_BYTE *)v24 + 24) = *(_BYTE *)(v27 + 24);
      *(_BYTE *)(v27 + 24) = 1;
      *((_BYTE *)v23 + 24) = 1;
      v28 = *(uint64_t **)v27;
      v31 = *(_QWORD *)(*(_QWORD *)v27 + 8);
      *(_QWORD *)v27 = v31;
      if (v31)
        *(_QWORD *)(v31 + 16) = v27;
      v28[2] = *(_QWORD *)(v27 + 16);
      *(_QWORD *)(*(_QWORD *)(v27 + 16) + 8 * (**(_QWORD **)(v27 + 16) != v27)) = v28;
      v28[1] = v27;
      goto LABEL_80;
    }
    *((_BYTE *)v11 + 24) = 0;
    v21 = (uint64_t *)v11[2];
    if (*((_BYTE *)v21 + 24))
      v25 = v21 == v5;
    else
      v25 = 1;
    if (v25)
      goto LABEL_61;
LABEL_57:
    v11 = *(uint64_t **)(v21[2] + 8 * (*(_QWORD *)v21[2] == (_QWORD)v21));
  }
  if (!*((_BYTE *)v11 + 24))
  {
    *((_BYTE *)v11 + 24) = 1;
    *(_BYTE *)(v16 + 24) = 0;
    v17 = *(uint64_t **)(v16 + 8);
    v18 = *v17;
    *(_QWORD *)(v16 + 8) = *v17;
    if (v18)
      *(_QWORD *)(v18 + 16) = v16;
    v17[2] = *(_QWORD *)(v16 + 16);
    *(_QWORD *)(*(_QWORD *)(v16 + 16) + 8 * (**(_QWORD **)(v16 + 16) != v16)) = v17;
    *v17 = v16;
    *(_QWORD *)(v16 + 16) = v17;
    if (v5 == (uint64_t *)*v11)
      v5 = v11;
    v11 = *(uint64_t **)(*v11 + 8);
  }
  v19 = (_QWORD *)*v11;
  if (!*v11 || *((_BYTE *)v19 + 24))
  {
    v20 = (uint64_t *)v11[1];
    if (v20 && !*((_BYTE *)v20 + 24))
      goto LABEL_67;
    *((_BYTE *)v11 + 24) = 0;
    v21 = (uint64_t *)v11[2];
    if (v21 == v5)
    {
      v21 = v5;
LABEL_61:
      *((_BYTE *)v21 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v21 + 24))
      goto LABEL_61;
    goto LABEL_57;
  }
  v20 = (uint64_t *)v11[1];
  if (v20 && !*((_BYTE *)v20 + 24))
  {
LABEL_67:
    v19 = v11;
  }
  else
  {
    *((_BYTE *)v19 + 24) = 1;
    *((_BYTE *)v11 + 24) = 0;
    v26 = v19[1];
    *v11 = v26;
    if (v26)
      *(_QWORD *)(v26 + 16) = v11;
    v19[2] = v11[2];
    *(_QWORD *)(v11[2] + 8 * (*(_QWORD *)v11[2] != (_QWORD)v11)) = v19;
    v19[1] = v11;
    v11[2] = (uint64_t)v19;
    v20 = v11;
  }
  v27 = v19[2];
  *((_BYTE *)v19 + 24) = *(_BYTE *)(v27 + 24);
  *(_BYTE *)(v27 + 24) = 1;
  *((_BYTE *)v20 + 24) = 1;
  v28 = *(uint64_t **)(v27 + 8);
  v29 = *v28;
  *(_QWORD *)(v27 + 8) = *v28;
  if (v29)
    *(_QWORD *)(v29 + 16) = v27;
  v28[2] = *(_QWORD *)(v27 + 16);
  *(_QWORD *)(*(_QWORD *)(v27 + 16) + 8 * (**(_QWORD **)(v27 + 16) != v27)) = v28;
  *v28 = v27;
LABEL_80:
  *(_QWORD *)(v27 + 16) = v28;
  return result;
}

void caulk::platform::process_name(caulk::platform *this@<X0>, std::string *a2@<X8>)
{
  size_t v3;
  int v4[2];
  int v5;
  int v6;
  _BYTE v7[243];
  std::string::value_type v8[405];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  v3 = 648;
  *(_QWORD *)v4 = 0xE00000001;
  v5 = 1;
  v6 = (int)this;
  if (sysctl(v4, 4u, v7, &v3, 0, 0) == -1)
  {
    perror("sysctl");
  }
  else if (v3)
  {
    std::string::__assign_external(a2, v8);
  }
}

void sub_2065C062C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t caulk::mach::os_workgroup_interval_managed::finish(caulk::mach::os_workgroup_interval_managed *this, os_workgroup_interval_data_opaque_s *a2)
{
  uint64_t result;

  if (!*((_BYTE *)this + 56) || !*((_BYTE *)this + 57))
    return 1;
  result = os_workgroup_interval_finish(*((os_workgroup_interval_t *)this + 1), a2);
  *((_BYTE *)this + 57) = 0;
  return result;
}

uint64_t caulk::mach::os_workgroup_interval_managed::start(caulk::mach::os_workgroup_interval_managed *this, uint64_t a2, uint64_t a3, os_workgroup_interval_data_opaque_s *a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!*((_BYTE *)this + 56) || *((_BYTE *)this + 57))
    return 1;
  v9 = mach_absolute_time();
  if (a2 >= v9)
    v10 = v9;
  else
    v10 = a2;
  if (v9 <= a3)
    v11 = a3;
  else
    v11 = v9;
  if (v10 == v11)
    return 22;
  result = os_workgroup_interval_start(*((os_workgroup_interval_t *)this + 1), v10, v11, a4);
  *((_BYTE *)this + 57) = (_DWORD)result == 0;
  return result;
}

void caulk::xpc::reply_watchdog_factory::make_timer(caulk::xpc::reply_watchdog_factory *this@<X0>, int a2@<W1>, dispatch_source_t *a3@<X8>)
{
  int v3;
  NSObject *v6;
  dispatch_source_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  NSObject *v12;
  dispatch_time_t v13;
  uint64_t v14;
  _QWORD v15[3];
  _QWORD *v16;
  _QWORD handler[4];
  _BYTE v18[24];
  _BYTE *v19;
  uint64_t v20;

  v3 = a2;
  v20 = *MEMORY[0x24BDAC8D0];
  if (!a2)
    v3 = *((_DWORD *)this + 1);
  dispatch_get_global_queue(0, 0);
  v6 = objc_claimAutoreleasedReturnValue();
  v7 = dispatch_source_create(MEMORY[0x24BDACA18], 0, 0, v6);
  *a3 = v7;
  applesauce::dispatch::v1::source::operator*(v7);
  objc_claimAutoreleasedReturnValue();
  handler[0] = MEMORY[0x24BDAC760];
  handler[1] = 3321888768;
  handler[2] = ___ZN5caulk3xpc22reply_watchdog_factory10make_timerEi_block_invoke;
  handler[3] = &__block_descriptor_64_ea8_32c60_ZTSKZN5caulk3xpc22reply_watchdog_factory10make_timerEiE3__0_e5_v8__0l;
  std::__function::__value_func<void * ()(unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v15, (uint64_t)this + 8);
  v8 = v18;
  v9 = (uint64_t)v16;
  if (!v16)
    goto LABEL_6;
  if (v16 != v15)
  {
    v9 = (*(uint64_t (**)(void))(*v16 + 16))();
LABEL_6:
    v19 = (_BYTE *)v9;
    goto LABEL_8;
  }
  v19 = v18;
  (*(void (**)(_QWORD *, _BYTE *))(v15[0] + 24))(v15, v18);
LABEL_8:
  dispatch_source_set_event_handler(v7, handler);
  v10 = v16;
  if (v16 == v15)
  {
    v11 = 4;
    v10 = v15;
  }
  else
  {
    if (!v16)
      goto LABEL_13;
    v11 = 5;
  }
  (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_13:

  applesauce::dispatch::v1::source::operator*(v7);
  v12 = objc_claimAutoreleasedReturnValue();
  dispatch_resume(v12);

  applesauce::dispatch::v1::source::operator*(v7);
  objc_claimAutoreleasedReturnValue();
  v13 = dispatch_time(0, 1000000 * v3);
  dispatch_source_set_timer(v7, v13, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);

  if (v19 == v18)
  {
    v14 = 4;
    goto LABEL_17;
  }
  if (v19)
  {
    v14 = 5;
    v8 = v19;
LABEL_17:
    (*(void (**)(_QWORD *))(*v8 + 8 * v14))(v8);
  }

}

void sub_2065C0904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  void *v13;
  void *v14;
  id *v15;
  char *v17;
  uint64_t v18;

  v17 = a13;
  if (a13 == &a10)
  {
    v18 = 4;
    v17 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_6:

  applesauce::dispatch::v1::source::~source(v15);
  _Unwind_Resume(a1);
}

unint64_t caulk::alloc::page_allocator::advise_free(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;
  unint64_t v4;

  result = (unint64_t)(a2 + *MEMORY[0x24BDB03C8] - 1) / *MEMORY[0x24BDB03C8] * *MEMORY[0x24BDB03C8];
  v4 = (unint64_t)(a2 + a3) / *MEMORY[0x24BDB03C8] * *MEMORY[0x24BDB03C8];
  if (v4 > result)
    return madvise((void *)result, v4 - result, 5);
  return result;
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_size_for_ptr(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t owner;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  char v9;
  uint64_t v11[2];

  v3 = *(_QWORD *)(a1 - 8);
  v11[0] = v3 + 800;
  v11[1] = v3 + 960;
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(v3 + 960));
  owner = caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::find_owner(v11, a2);
  if (owner)
    v5 = caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::size(owner + 16, a2);
  else
    v5 = 0;
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal((unsigned __int128 *)(v3 + 960));
  if (!v5)
  {
    v6 = caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::size(v3 + 368, a2 - 32);
    if ((v6 & 0x7FFFFFFFFFFFFFBFLL) != 0)
    {
      return v6 - 64;
    }
    else
    {
      caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(v3 + 288));
      v11[0] = a2;
      v7 = caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::search_to_level<caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::key_le>(v3 + 32, v11, 0);
      if (*(_QWORD *)(v7 + 16) != a2)
      {
        if (*(_BYTE *)(v8 + 26) == 2)
          v7 = v3 + 232;
        else
          v7 = v8;
      }
      if (v7 == v3 + 232
        || *(_BYTE *)(v7 + 26) == 2
        || (v9 = atomic_load((unint64_t *)(v7 + 40)), (v9 & 1) != 0)
        || *(_QWORD *)(v7 + 16) != a2)
      {
        v5 = 0;
      }
      else
      {
        v5 = *(_QWORD *)v7;
      }
      caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal((unsigned __int128 *)(v3 + 288));
    }
  }
  return v5;
}

unint64_t caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::search_right<caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::key_le &>(uint64_t a1, uint64_t a2, unint64_t a3, _QWORD *a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char v10;
  int v11;
  unint64_t v12;

  v4 = a3;
  v5 = atomic_load((unint64_t *)(a3 + 16 * a2 + 40));
  v6 = v5 & 0xFFFFFFFFFFFFFFFCLL;
  if (*a4 >= *(_QWORD *)((v5 & 0xFFFFFFFFFFFFFFFCLL) + 16))
  {
    do
    {
      v10 = atomic_load((unint64_t *)(v6 + 40));
      if ((v10 & 1) != 0)
      {
        v4 = caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::try_flag_node(a1, a2, v4, v6);
        if (!v11)
          caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::help_flagged(a1, a2, v4, v6);
      }
      else
      {
        v4 = v6;
      }
      v12 = atomic_load((unint64_t *)(v4 + 16 * a2 + 40));
      v6 = v12 & 0xFFFFFFFFFFFFFFFCLL;
    }
    while (*a4 >= *(_QWORD *)((v12 & 0xFFFFFFFFFFFFFFFCLL) + 16));
  }
  return v4;
}

unint64_t caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::search_to_level<caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::key_le>(uint64_t a1, _QWORD *a2, unint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;

  v6 = -1;
  v7 = 56;
  do
  {
    do
    {
      ++v6;
      v8 = atomic_load((unint64_t *)(a1 + v7));
      v7 += 16;
    }
    while (v6 < a3);
  }
  while (*(_BYTE *)((v8 & 0xFFFFFFFFFFFFFFFCLL) + 26) != 2);
  v9 = a1;
  if (v6 > a3)
  {
    v9 = a1;
    do
      v9 = caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::search_right<caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::key_le &>(a1, v6--, v9, a2);
    while (v6 > a3);
  }
  return caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::search_right<caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::key_le &>(a1, a3, v9, a2);
}

unsigned __int128 *caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal(unsigned __int128 *result)
{
  unsigned __int128 v1;
  unint64_t v2;
  uint64_t v3;
  unsigned __int128 v4;
  int v5;
  unsigned __int128 v7;
  int v8;
  uint64_t v9;
  uint64_t v10;

  do
    v1 = __ldaxp(result);
  while (__stlxp(v1, result));
  do
  {
    while (1)
    {
      v4 = __ldaxp(result);
      v3 = *((_QWORD *)&v4 + 1);
      v2 = v4;
      v5 = (_QWORD)v4 != (_QWORD)v1;
      if (*((_QWORD *)&v4 + 1) != *((_QWORD *)&v1 + 1))
        ++v5;
      if (!v5)
        break;
      if (!__stlxp(v4, result))
        goto LABEL_8;
    }
  }
  while (__stlxp(__PAIR128__((DWORD2(v1) + 1), v1), result));
LABEL_8:
  if ((_QWORD)v4 != (_QWORD)v1 || *((_QWORD *)&v4 + 1) != *((_QWORD *)&v1 + 1))
  {
    while (1)
    {
      while (1)
      {
        v7 = __ldaxp(result);
        v8 = (_QWORD)v7 != v2;
        if (*((_QWORD *)&v7 + 1) != v3)
          ++v8;
        if (!v8)
          break;
        if (!__stlxp(v7, result))
          goto LABEL_18;
      }
      if (!__stlxp(__PAIR128__((v3 + 1), v2), result))
      {
LABEL_18:
        v9 = *((_QWORD *)&v7 + 1) ^ v3;
        v10 = v7 ^ v2;
        v3 = v7 >> 64;
        v2 = v7;
        if (!(v10 | v9))
          return result;
      }
    }
  }
  return result;
}

unsigned __int128 *caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal(unsigned __int128 *result)
{
  unint64_t v1;
  int v2;
  unsigned __int128 v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;
  unsigned __int128 v9;
  int v10;

  do
  {
    v3 = __ldaxp(result);
    v2 = DWORD2(v3);
    v1 = v3;
  }
  while (__stlxp(v3, result));
  v4 = HIDWORD(*((_QWORD *)&v3 + 1));
  while (1)
  {
    v5 = v2 - 1;
    v6 = v2 - 1;
    v7 = v2 <= 1 ? 0 : v1;
    v8 = v2 | (unint64_t)(v4 << 32);
    do
    {
      while (1)
      {
        v9 = __ldaxp(result);
        v2 = DWORD2(v9);
        v10 = (_QWORD)v9 != v1;
        if (*((_QWORD *)&v9 + 1) != v8)
          ++v10;
        if (!v10)
          break;
        if (!__stlxp(v9, result))
          goto LABEL_13;
      }
    }
    while (__stlxp(__PAIR128__(v6, v7), result));
LABEL_13:
    if (!((unint64_t)v9 ^ v1 | *((_QWORD *)&v9 + 1) ^ v8))
      break;
    v4 = HIDWORD(*((_QWORD *)&v9 + 1));
    v1 = v9;
  }
  if (!v5)
  {
    if (v1)
      return (unsigned __int128 *)caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::free_node_chain_now((caulk::alloc::base_allocator *)result, v1);
  }
  return result;
}

void caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::remove_freemap_entry(uint64_t a1, uint64_t *a2)
{
  uint64_t *v2;
  _QWORD *v3;
  uint64_t **v5;
  unint64_t v6;
  uint64_t *v7;
  unint64_t v8;
  BOOL v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;

  v3 = *(_QWORD **)(a1 + 368);
  if (!v3)
    goto LABEL_12;
  v5 = (uint64_t **)(a1 + 360);
  v6 = (unint64_t)a2[3] >> 1;
  v7 = (uint64_t *)(a1 + 368);
  v2 = v7;
  do
  {
    v8 = v3[4];
    v9 = v8 >= v6;
    if (v8 >= v6)
      v10 = v3;
    else
      v10 = v3 + 1;
    if (v9)
      v2 = v3;
    v3 = (_QWORD *)*v10;
  }
  while (*v10);
  if (v2 == v7 || v2[4] > v6)
  {
LABEL_12:
    _os_assert_log();
    v5 = (uint64_t **)_os_crash();
    __break(1u);
  }
  v11 = *a2;
  if (*a2)
  {
    v12 = (_QWORD *)a2[1];
    *(_QWORD *)(v11 + 8) = v12;
    if (v12)
      *v12 = v11;
    if (!v2[6])
    {
      std::__tree<std::__value_type<unsigned long,caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::FreelistOfSize>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::FreelistOfSize>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::FreelistOfSize>>>::__remove_node_pointer(v5, v2);
      operator delete(v2);
    }
  }
  else
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
}

uint64_t caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::consolidate_free(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v2 = *(_QWORD *)(a2 + 24) & 1;
  v3 = *(_QWORD *)(result + 24);
  v4 = v3 >> 1;
  v5 = v3 & 0xFFFFFFFFFFFFFFFELL | v2;
  *(_QWORD *)(result + 24) = v5;
  v6 = v4 + (*(_QWORD *)(a2 + 24) >> 1) + 32;
  *(_QWORD *)(result + 24) = v5 & 1 | (2 * v6);
  if ((v2 & 1) == 0)
    *(_QWORD *)(result + (v6 & 0x7FFFFFFFFFFFFFFFLL) + 48) = *(_QWORD *)(result + (v6 & 0x7FFFFFFFFFFFFFFFLL) + 48) & 1 | (2 * v6);
  return result;
}

uint64_t caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>::allocate(caulk::alloc::page_allocator *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  void *v6;
  uint64_t result;
  __int128 v8;

  v6 = caulk::alloc::page_allocator::allocate(a1, a2, a3);
  if (!v6)
    return (uint64_t)v6;
  *(_QWORD *)&v8 = v5;
  *((_QWORD *)&v8 + 1) = a3;
  if ((caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::emplace<caulk::alloc::detail::tracked_block>((uint64_t)a1 + 16, (unint64_t)v6, &v8) & 1) != 0)return (uint64_t)v6;
  _os_assert_log();
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::emplace<caulk::alloc::detail::tracked_block>(uint64_t result, unint64_t a2, _OWORD *a3)
{
  uint64_t v4;
  unsigned __int128 *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  int value;
  uint64_t i;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unsigned __int128 *v18;
  unint64_t *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  char v28;
  char v29;
  unint64_t v30;
  unint64_t v31;
  char v32;
  int v33;
  unint64_t v34;
  char v35;
  unint64_t v36;
  uint64_t v37;
  _OWORD *v38;
  unint64_t v39;

  if (*(_QWORD *)(result + 16) >= a2 || (v4 = result, *(_QWORD *)(result + 216) <= a2))
  {
    __break(1u);
  }
  else
  {
    v6 = (unsigned __int128 *)(result + 256);
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(result + 256));
    v39 = a2;
    v7 = caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::search_to_level<caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::key_le>(v4, &v39, 0);
    if (*(_QWORD *)(v7 + 16) != a2)
    {
      v9 = v7;
      v10 = v8;
      v38 = a3;
      v11 = 0;
      value = 0;
      for (i = 1; i != 9; ++i)
      {
        if (i == 1)
        {
          caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::random_engine();
          value = caulk::multi_simple_random<unsigned int,4ul,std::uniform_int_distribution<unsigned int>,std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>::next_value((uint64_t)&caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::random_engine(void)::engine);
          v11 = 3;
        }
        if ((v11 & ~value) != 0)
          break;
        v11 *= 4;
      }
      v14 = 0;
      v15 = *(_QWORD *)(v4 + 272);
      while (1)
      {
        v16 = *(_QWORD *)&caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>::Sizes[8 * v14];
        if (v16 >= *(_QWORD *)&caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>::Sizes[8 * i - 8])
          break;
        if (++v14 == 10)
        {
          v17 = 0;
          goto LABEL_19;
        }
      }
      v18 = (unsigned __int128 *)(v15 + 64 + 32 * v14);
      v19 = caulk::concurrent::stack<caulk::alloc::free_block,caulk::concurrent::intrusive_single_link_node<caulk::alloc::free_block>>::pop(v18);
      if (v19)
      {
        v17 = (unint64_t)v19;
        v20 = (unint64_t *)(v18 + 1);
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
      }
      else
      {
        v17 = caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>::allocate(v15, v16);
      }
      v6 = (unsigned __int128 *)(v4 + 256);
LABEL_19:
      *(_QWORD *)v17 = 0;
      *(_QWORD *)(v17 + 8) = 0;
      *(_BYTE *)(v17 + 24) = i;
      *(_WORD *)(v17 + 25) = 1;
      *(_BYTE *)(v17 + 27) = i;
      *(_QWORD *)(v17 + 16) = a2;
      *(_OWORD *)v17 = *v38;
      *(_QWORD *)(v17 + 40) = 0;
      *(_QWORD *)(v17 + 48) = 0;
      *(_QWORD *)(v17 + 32) = 0;
      if ((_BYTE)i)
      {
        v22 = (unint64_t *)(v17 + 48);
        v23 = i;
        do
        {
          atomic_store(0, v22 - 1);
          atomic_store(0, v22);
          v22 += 2;
          --v23;
        }
        while (v23);
      }
      v24 = 0;
      __dmb(0xBu);
      while (1)
      {
        while (*(_QWORD *)(v9 + 16) != *(_QWORD *)(v17 + 16))
        {
          v25 = (unint64_t *)(v9 + 16 * v24 + 40);
          v26 = atomic_load(v25);
          if ((v26 & 2) != 0)
          {
            caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::help_flagged(v4, v24, v9, v26 & 0xFFFFFFFFFFFFFFFCLL);
          }
          else
          {
            atomic_store(v10, (unint64_t *)(v17 + 16 * v24 + 40));
            v27 = __ldaxr(v25);
            if (v27 == v10)
            {
              if (!__stlxr(v17, v25))
              {
                v34 = v17;
                goto LABEL_42;
              }
            }
            else
            {
              __clrex();
            }
            if ((v27 & 2) != 0)
              caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::help_flagged(v4, v24, v9, v27 & 0xFFFFFFFFFFFFFFFCLL);
            v28 = atomic_load(v25);
            if ((v28 & 1) != 0)
            {
              do
              {
                v9 = atomic_load((unint64_t *)(v9 + 16 * v24 + 48));
                v29 = atomic_load((unint64_t *)(v9 + 16 * v24 + 40));
              }
              while ((v29 & 1) != 0);
            }
          }
          v30 = *(_QWORD *)(v17 + 16);
          while (1)
          {
            v31 = atomic_load((unint64_t *)(v9 + 16 * v24 + 40));
            v10 = v31 & 0xFFFFFFFFFFFFFFFCLL;
            if (v30 < *(_QWORD *)((v31 & 0xFFFFFFFFFFFFFFFCLL) + 16))
              break;
            v32 = atomic_load((unint64_t *)(v10 + 40));
            if ((v32 & 1) != 0)
            {
              v9 = caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::try_flag_node(v4, v24, v9, v10);
              if (!v33)
                caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::help_flagged(v4, v24, v9, v10);
            }
            else
            {
              v9 = v10;
            }
          }
        }
        v34 = 0;
LABEL_42:
        if (!(v34 | v24))
          break;
        v35 = atomic_load((unint64_t *)(v17 + 40));
        if ((v35 & 1) != 0 || (++v24, v24 == i))
        {
          v37 = 1;
          goto LABEL_49;
        }
        v39 = a2;
        v9 = caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::search_to_level<caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::key_le>(v4, &v39, v24);
        v10 = v36;
      }
      caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>::deallocate(*(caulk::alloc::base_allocator **)(v4 + 272), (unint64_t *)v17, *(_QWORD *)&caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>::Sizes[8 * *(unsigned __int8 *)(v17 + 24) - 8]);
    }
    v37 = 0;
LABEL_49:
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal(v6);
    return v37;
  }
  return result;
}

unint64_t *caulk::concurrent::stack<caulk::alloc::free_block,caulk::concurrent::intrusive_single_link_node<caulk::alloc::free_block>>::pop(unsigned __int128 *a1)
{
  unint64_t *v1;
  uint64_t v2;
  unsigned __int128 v3;
  unint64_t v4;
  unsigned __int128 v5;
  int v6;

  do
  {
    v3 = __ldaxp(a1);
    v2 = *((_QWORD *)&v3 + 1);
    v1 = (unint64_t *)v3;
  }
  while (__stlxp(v3, a1));
  if ((_QWORD)v3)
  {
    do
    {
      v4 = atomic_load(v1);
      do
      {
        while (1)
        {
          v5 = __ldaxp(a1);
          v6 = (_QWORD)v5 != (_QWORD)v1;
          if (*((_QWORD *)&v5 + 1) != v2)
            ++v6;
          if (!v6)
            break;
          if (!__stlxp(v5, a1))
            goto LABEL_10;
        }
      }
      while (__stlxp(__PAIR128__(v2 + 1, v4), a1));
LABEL_10:
      if ((unint64_t *)v5 == v1 && *((_QWORD *)&v5 + 1) == v2)
        break;
      v2 = v5 >> 64;
      v1 = (unint64_t *)v5;
    }
    while ((_QWORD)v5);
  }
  return v1;
}

void caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::random_engine()
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      caulk::multi_simple_random<unsigned int,4ul,std::uniform_int_distribution<unsigned int>,std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>::multi_simple_random((uint64_t)&caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::random_engine(void)::engine);
    }
  }
}

void sub_2065C130C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t caulk::multi_simple_random<unsigned int,4ul,std::uniform_int_distribution<unsigned int>,std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>::next_value(uint64_t a1)
{
  uint64_t v2;
  unsigned __int8 *v3;
  unsigned __int8 v4;
  uint64_t result;
  int v6;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned int v13;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v14;

  v2 = 0;
  while (1)
  {
    v3 = (unsigned __int8 *)(a1 + 2512 * v2 + 2504);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(1u, v3));
    if ((v4 & 1) == 0)
      break;
    if (v2 == 3)
      v2 = 0;
    else
      ++v2;
  }
  result = *(unsigned int *)(a1 + 10052);
  v6 = result - *(_DWORD *)(a1 + 10048);
  if (v6)
  {
    v7 = (std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *)(a1 + 2512 * v2);
    v8 = v6 + 1;
    if (v6 == -1)
    {
      result = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()((std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *)(a1 + 2512 * v2));
    }
    else
    {
      v9 = __clz(v8);
      v10 = 31;
      if (((v8 << v9) & 0x7FFFFFFF) != 0)
        v10 = 32;
      v11 = v10 - v9;
      v12 = v11 >> 5;
      if ((v11 & 0x1F) != 0)
        ++v12;
      if (v12 <= v11)
        v13 = 0xFFFFFFFF >> -(v11 / v12);
      else
        v13 = 0;
      do
        v14 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(v7) & v13;
      while (v14 >= v8);
      result = *(_DWORD *)(a1 + 10048) + v14;
    }
  }
  atomic_store(0, v3);
  return result;
}

std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *this)
{
  size_t i;
  size_t v2;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v3;

  i = this->__i_;
  v2 = (i + 1) % 0x270;
  v3 = this->__x_[(i + 397) % 0x270] ^ ((this->__x_[v2] & 0x7FFFFFFE | this->__x_[i] & 0x80000000) >> 1) ^ ((int)(this->__x_[v2] << 31) >> 31) & 0x9908B0DF;
  this->__x_[i] = v3;
  this->__i_ = v2;
  LODWORD(i) = ((v3 ^ (v3 >> 11)) << 7) & 0x9D2C5680 ^ v3 ^ (v3 >> 11);
  return ((_DWORD)i << 15) & 0xEFC60000 ^ i ^ ((((_DWORD)i << 15) & 0xEFC60000 ^ i) >> 18);
}

uint64_t caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>::allocate(uint64_t a1, unint64_t a2)
{
  unsigned int *v3;
  unsigned int v4;
  unint64_t *v5;
  int v6;
  unint64_t *v7;
  unint64_t v8;
  BOOL v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  char v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char v22;
  unint64_t v23;
  char v24;
  uint64_t v25;
  unsigned int v26;

  v3 = (unsigned int *)(a1 + 40);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 + 2049, v3));
  v5 = *(unint64_t **)(a1 + 24);
  if (!v5)
    v5 = *(unint64_t **)(a1 + 16);
  v6 = 0;
  v7 = (unint64_t *)(a1 + 16);
  v8 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v8)
    v9 = a2 > 0x3FF0;
  else
    v9 = 1;
  while (!v5)
  {
LABEL_28:
    if (os_unfair_lock_trylock((os_unfair_lock_t)(a1 + 32)))
    {
      v18 = caulk::alloc::details::caching_page_allocator_base::allocate(*(caulk::alloc::details::caching_page_allocator_base **)(a1 + 8), 0x4000, 0x10uLL);
      v5 = v18;
      *v18 = 0;
      v18[1] = v19;
      v18[2] = 0;
      __dmb(0xBu);
      v20 = *v7;
      atomic_store(*v7, v18);
      v21 = __ldaxr(v7);
      if (v21 == v20)
      {
        if (!__stlxr((unint64_t)v18, v7))
        {
          v22 = 1;
          goto LABEL_36;
        }
      }
      else
      {
        __clrex();
      }
      v22 = 0;
LABEL_36:
      if ((v22 & 1) == 0)
      {
        while (1)
        {
          atomic_store(v21, v18);
          v23 = __ldaxr(v7);
          if (v23 != v21)
            break;
          if (__stlxr((unint64_t)v18, v7))
            goto LABEL_41;
          v24 = 1;
LABEL_42:
          v21 = v23;
          if ((v24 & 1) != 0)
            goto LABEL_43;
        }
        __clrex();
LABEL_41:
        v24 = 0;
        goto LABEL_42;
      }
LABEL_43:
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
    }
    else if (++v6 == 100)
    {
      sched_yield();
      v6 = 0;
    }
  }
  v10 = v5;
  while (1)
  {
    if (!v9)
    {
      v11 = v10[2];
      v12 = ~((_BYTE)v10 + 39 + (_BYTE)v11) & 7;
      v13 = v11 + v8 + v12;
      if (v13 <= 0x3FE0)
        break;
    }
LABEL_12:
    v10 = (unint64_t *)atomic_load(v10);
    if (!v10)
      v10 = (unint64_t *)*v7;
    if (v5 == v10)
      goto LABEL_28;
  }
  v14 = v10 + 2;
  v15 = __ldaxr(v10 + 2);
  if (v15 == v11)
  {
    if (!__stlxr(v13, v14))
    {
      v16 = 1;
      goto LABEL_21;
    }
  }
  else
  {
    __clrex();
  }
  v16 = 0;
LABEL_21:
  if ((v16 & 1) == 0)
  {
    while (1)
    {
      v11 = v15;
      v12 = ~((_BYTE)v10 + 39 + (_BYTE)v15) & 7;
      v17 = v15 + v8 + v12;
      if (v17 > 0x3FE0)
        goto LABEL_12;
      v15 = __ldaxr(v14);
      if (v15 == v11)
      {
        if (!__stlxr(v17, v14))
          break;
      }
      else
      {
        __clrex();
      }
    }
  }
  v25 = (uint64_t)v10 + v11 + v12 + 32;
  caulk::alloc::base_allocator::assert_aligned(v25, 8);
  *(_QWORD *)(a1 + 24) = v10;
  do
    v26 = __ldaxr(v3);
  while (__stlxr(v26 - 1, v3));
  return v25;
}

void sub_2065C16DC(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;
  unsigned int *v2;
  unsigned int v4;

  os_unfair_lock_unlock(v1);
  do
    v4 = __ldaxr(v2);
  while (__stlxr(v4 - 1, v2));
  _Unwind_Resume(a1);
}

uint64_t caulk::alloc::base_allocator::assert_aligned(uint64_t this, uint64_t a2)
{
  if (((a2 - 1) & this) != 0)
  {
    _os_assert_log();
    this = _os_crash();
    __break(1u);
  }
  return this;
}

unint64_t *caulk::alloc::details::caching_page_allocator_base::allocate(caulk::alloc::details::caching_page_allocator_base *this, uint64_t a2, unint64_t a3)
{
  unsigned int *v6;
  unsigned int v7;
  unint64_t *v8;
  unint64_t *v9;
  unint64_t *v10;
  unint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int *v15;
  unsigned int v16;
  unint64_t *result;

  if (*MEMORY[0x24BDB03C8] >= a3)
  {
    if (*((_QWORD *)this + 2) == a2)
    {
      v6 = (unsigned int *)((char *)this + 108);
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 + 1, v6));
      v8 = caulk::concurrent::stack<caulk::alloc::free_block,caulk::concurrent::intrusive_single_link_node<caulk::alloc::free_block>>::pop((unsigned __int128 *)this + 2);
      if (v8)
      {
        v9 = v8;
        v10 = (unint64_t *)((char *)this + 48);
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        do
          v12 = __ldaxr(v6);
        while (__stlxr(v12 - 1, v6));
        v13 = *((_QWORD *)this + 11);
        if (v13)
          std::function<void * ()(unsigned long,unsigned long)>::operator()(v13, *((_QWORD *)this + 2), *((_QWORD *)this + 6));
        return v9;
      }
      do
        v14 = __ldaxr(v6);
      while (__stlxr(v14 - 1, v6));
      v15 = (unsigned int *)((char *)this + 104);
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 + 1, v15));
    }
    return (unint64_t *)caulk::alloc::page_allocator::allocate(this, a2, a3);
  }
  _os_assert_log();
  result = (unint64_t *)_os_crash();
  __break(1u);
  return result;
}

uint64_t std::function<void * ()(unsigned long,unsigned long)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  v4 = a3;
  v5 = a2;
  if (!a1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v5, &v4);
}

uint64_t caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::remove(uint64_t a1, uint64_t a2)
{
  unsigned __int128 *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;

  v4 = (unsigned __int128 *)(a1 + 256);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 256));
  v17 = a2;
  v5 = -1;
  v6 = 56;
  do
  {
    v7 = atomic_load((unint64_t *)(a1 + v6));
    ++v5;
    v6 += 16;
  }
  while (*(_BYTE *)((v7 & 0xFFFFFFFFFFFFFFFCLL) + 26) != 2);
  v8 = a1;
  if (v5)
  {
    v8 = a1;
    do
      v8 = caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::search_right<caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::key_lt &>(a1, v5--, v8, &v17);
    while (v5);
  }
  v9 = caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::search_right<caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::key_lt &>(a1, 0, v8, &v17);
  if (*(_QWORD *)(v10 + 16) == a2)
  {
    v12 = v10;
    v13 = caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::try_flag_node(a1, 0, v9, v10);
    v15 = v14;
    if (!(_DWORD)v14)
      caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::help_flagged(a1, 0, v13, v12);
    v11 = 0;
    if ((v15 & 0xFF00000000) != 0 && v12)
    {
      v17 = a2;
      caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::search_to_level<caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::key_le>(a1, &v17, 0);
      v11 = 1;
    }
  }
  else
  {
    v11 = 0;
  }
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal(v4);
  return v11;
}

unint64_t caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::try_flag_node(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  char v12;
  char v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char v17;
  int v18;

  v8 = a4 | 2;
  do
  {
    v9 = (unint64_t *)(a3 + 16 * a2 + 40);
    v10 = atomic_load(v9);
    if (v10 == v8)
      break;
    v11 = __ldaxr(v9);
    if (v11 == a4)
    {
      if (!__stlxr(v8, v9))
        return a3;
    }
    else
    {
      __clrex();
    }
    if (v11 == v8)
      break;
    v12 = atomic_load(v9);
    if ((v12 & 1) != 0)
    {
      do
      {
        a3 = atomic_load((unint64_t *)(a3 + 16 * a2 + 48));
        v13 = atomic_load((unint64_t *)(a3 + 16 * a2 + 40));
      }
      while ((v13 & 1) != 0);
    }
    v14 = *(_QWORD *)(a4 + 16);
    while (1)
    {
      v15 = atomic_load((unint64_t *)(a3 + 16 * a2 + 40));
      v16 = v15 & 0xFFFFFFFFFFFFFFFCLL;
      if (v14 <= *(_QWORD *)((v15 & 0xFFFFFFFFFFFFFFFCLL) + 16))
        break;
      v17 = atomic_load((unint64_t *)(v16 + 40));
      if ((v17 & 1) != 0)
      {
        a3 = caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::try_flag_node(a1, a2, a3, v16);
        if (!v18)
          caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::help_flagged(a1, a2, a3, v16);
      }
      else
      {
        a3 = v16;
      }
    }
  }
  while (v16 == a4);
  return a3;
}

unint64_t caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::search_right<caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::key_lt &>(uint64_t a1, uint64_t a2, unint64_t a3, _QWORD *a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char v10;
  int v11;
  unint64_t v12;

  v4 = a3;
  v5 = atomic_load((unint64_t *)(a3 + 16 * a2 + 40));
  v6 = v5 & 0xFFFFFFFFFFFFFFFCLL;
  if (*a4 > *(_QWORD *)((v5 & 0xFFFFFFFFFFFFFFFCLL) + 16))
  {
    do
    {
      v10 = atomic_load((unint64_t *)(v6 + 40));
      if ((v10 & 1) != 0)
      {
        v4 = caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::try_flag_node(a1, a2, v4, v6);
        if (!v11)
          caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::help_flagged(a1, a2, v4, v6);
      }
      else
      {
        v4 = v6;
      }
      v12 = atomic_load((unint64_t *)(v4 + 16 * a2 + 40));
      v6 = v12 & 0xFFFFFFFFFFFFFFFCLL;
    }
    while (*a4 > *(_QWORD *)((v12 & 0xFFFFFFFFFFFFFFFCLL) + 16));
  }
  return v4;
}

uint64_t caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::help_flagged(uint64_t result, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  char v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unsigned __int8 *v17;
  int v18;
  unsigned __int128 *v19;
  unsigned __int128 v20;
  unint64_t v21;
  uint64_t v22;
  unsigned __int128 v23;
  int v24;
  unsigned __int128 v26;
  int v27;
  uint64_t v28;
  uint64_t v29;

  v7 = result;
  v8 = a4 + 16 * a2;
  v9 = (unint64_t *)(v8 + 40);
  atomic_store(a3, (unint64_t *)(v8 + 48));
  while (1)
  {
    v10 = atomic_load(v9);
    if ((v10 & 1) != 0)
      break;
    v11 = atomic_load(v9);
    v12 = v11 & 0xFFFFFFFFFFFFFFFCLL;
    v13 = __ldaxr(v9);
    if (v13 == v12)
    {
      __stlxr(v12 | 1, v9);
      if ((v13 & 2) != 0)
LABEL_7:
        result = caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::help_flagged(v7, a2, a4, v13 & 0xFFFFFFFFFFFFFFFCLL);
    }
    else
    {
      __clrex();
      if ((v13 & 2) != 0)
        goto LABEL_7;
    }
  }
  v14 = atomic_load(v9);
  v15 = (unint64_t *)(a3 + 16 * a2 + 40);
  v16 = __ldaxr(v15);
  if (v16 == (a4 | 2))
  {
    if (!__stlxr(v14 & 0xFFFFFFFFFFFFFFFCLL, v15))
    {
      v17 = (unsigned __int8 *)(a4 + 27);
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (v18 == 1)
      {
        v19 = (unsigned __int128 *)(v7 + 256);
        do
          v20 = __ldaxp(v19);
        while (__stlxp(v20, v19));
        atomic_store(v20, (unint64_t *)(a4 + 32));
        do
        {
          while (1)
          {
            v23 = __ldaxp(v19);
            v22 = *((_QWORD *)&v23 + 1);
            v21 = v23;
            v24 = (_QWORD)v23 != (_QWORD)v20;
            if (*((_QWORD *)&v23 + 1) != *((_QWORD *)&v20 + 1))
              ++v24;
            if (!v24)
              break;
            if (!__stlxp(v23, v19))
              goto LABEL_22;
          }
        }
        while (__stlxp(__PAIR128__(DWORD2(v20), a4), v19));
LABEL_22:
        if ((_QWORD)v23 != (_QWORD)v20 || *((_QWORD *)&v23 + 1) != *((_QWORD *)&v20 + 1))
        {
          do
          {
            atomic_store(v21, (unint64_t *)(a4 + 32));
            do
            {
              while (1)
              {
                v26 = __ldaxp(v19);
                v27 = (_QWORD)v26 != v21;
                if (*((_QWORD *)&v26 + 1) != v22)
                  ++v27;
                if (!v27)
                  break;
                if (!__stlxp(v26, v19))
                  goto LABEL_33;
              }
            }
            while (__stlxp(__PAIR128__(v22, a4), v19));
LABEL_33:
            v28 = *((_QWORD *)&v26 + 1) ^ v22;
            v29 = v26 ^ v21;
            v22 = *((_QWORD *)&v26 + 1);
            v21 = v26;
          }
          while (v29 | v28);
        }
      }
    }
  }
  else
  {
    __clrex();
  }
  return result;
}

caulk::alloc::base_allocator *caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::free_node_chain_now(caulk::alloc::base_allocator *result, unint64_t a2)
{
  unint64_t v2;
  caulk::alloc::base_allocator *v3;
  char *v4;
  unint64_t v5;
  uint64_t v6;

  if (a2)
  {
    v2 = a2;
    v3 = result;
    v4 = (char *)result + 40;
    do
    {
      v5 = atomic_load((unint64_t *)(v2 + 32));
      v6 = *((_QWORD *)v3 + 4);
      if (*(_BYTE *)(v6 + 32))
      {
        if (!*(_BYTE *)(v2 + 26))
          (*(void (**)(char *, unint64_t))v6)(v4, v2);
      }
      result = caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>::deallocate(*((caulk::alloc::base_allocator **)v3 + 2), (unint64_t *)v2, *(_QWORD *)&caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>::Sizes[8 * *(unsigned __int8 *)(v2 + 24) - 8]);
      v2 = v5;
    }
    while (v5);
  }
  return result;
}

caulk::alloc::base_allocator *caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>::deallocate(caulk::alloc::base_allocator *result, unint64_t *a2, unint64_t a3)
{
  uint64_t v3;
  unsigned __int128 *v4;
  unsigned __int128 v5;
  unint64_t v6;
  uint64_t v7;
  unsigned __int128 v8;
  int v9;
  unsigned __int128 v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;

  v3 = 0;
  while (*(_QWORD *)&caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>::Sizes[8 * v3] < a3)
  {
    if (++v3 == 10)
      caulk::alloc::base_allocator::bad_dealloc(result);
  }
  v4 = (unsigned __int128 *)((char *)result + 32 * v3 + 64);
  do
    v5 = __ldaxp(v4);
  while (__stlxp(v5, v4));
  atomic_store(v5, a2);
  do
  {
    while (1)
    {
      v8 = __ldaxp(v4);
      v7 = *((_QWORD *)&v8 + 1);
      v6 = v8;
      v9 = (_QWORD)v8 != (_QWORD)v5;
      if (*((_QWORD *)&v8 + 1) != *((_QWORD *)&v5 + 1))
        ++v9;
      if (!v9)
        break;
      if (!__stlxp(v8, v4))
        goto LABEL_14;
    }
  }
  while (__stlxp(__PAIR128__(*((_QWORD *)&v5 + 1) + 1, (unint64_t)a2), v4));
LABEL_14:
  if ((_QWORD)v8 != (_QWORD)v5 || *((_QWORD *)&v8 + 1) != *((_QWORD *)&v5 + 1))
  {
    do
    {
      atomic_store(v6, a2);
      do
      {
        while (1)
        {
          v11 = __ldaxp(v4);
          v12 = (_QWORD)v11 != v6;
          if (*((_QWORD *)&v11 + 1) != v7)
            ++v12;
          if (!v12)
            break;
          if (!__stlxp(v11, v4))
            goto LABEL_25;
        }
      }
      while (__stlxp(__PAIR128__(v7 + 1, (unint64_t)a2), v4));
LABEL_25:
      v13 = *((_QWORD *)&v11 + 1) ^ v7;
      v14 = v11 ^ v6;
      v7 = v11 >> 64;
      v6 = v11;
    }
    while (v14 | v13);
  }
  v15 = (unint64_t *)((char *)result + 32 * v3 + 80);
  do
    v16 = __ldaxr(v15);
  while (__stlxr(v16 + 1, v15));
  return result;
}

uint64_t caulk::alloc::details::caching_page_allocator_base::preallocate(uint64_t this, unint64_t a2, unint64_t a3)
{
  caulk::alloc::page_allocator *v4;
  uint64_t v6;
  unsigned __int128 *v7;
  unint64_t *v8;
  void *v9;
  size_t v10;
  unsigned __int128 v11;
  unint64_t v12;
  uint64_t v13;
  unsigned __int128 v14;
  int v15;
  unsigned __int128 v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;

  if (a3)
  {
    v4 = (caulk::alloc::page_allocator *)this;
    if (*(_QWORD *)(this + 16) == a2)
    {
      if (0xFFFFFFFFFFFFFFFFLL / a3 <= a2)
      {
        _os_assert_log();
        this = _os_crash();
        __break(1u);
      }
      else
      {
        v6 = 0;
        v7 = (unsigned __int128 *)(this + 32);
        v8 = (unint64_t *)(this + 48);
        do
        {
          v9 = caulk::alloc::page_allocator::allocate(v4, a2, 0x1000uLL);
          this = madvise(v9, v10, 3);
          do
            v11 = __ldaxp(v7);
          while (__stlxp(v11, v7));
          atomic_store(v11, (unint64_t *)v9);
          do
          {
            while (1)
            {
              v14 = __ldaxp(v7);
              v13 = *((_QWORD *)&v14 + 1);
              v12 = v14;
              v15 = (_QWORD)v14 != (_QWORD)v11;
              if (*((_QWORD *)&v14 + 1) != *((_QWORD *)&v11 + 1))
                ++v15;
              if (!v15)
                break;
              if (!__stlxp(v14, v7))
                goto LABEL_14;
            }
          }
          while (__stlxp(__PAIR128__(*((_QWORD *)&v11 + 1) + 1, (unint64_t)v9), v7));
LABEL_14:
          if ((_QWORD)v14 != (_QWORD)v11 || *((_QWORD *)&v14 + 1) != *((_QWORD *)&v11 + 1))
          {
            do
            {
              atomic_store(v12, (unint64_t *)v9);
              do
              {
                while (1)
                {
                  v17 = __ldaxp(v7);
                  v18 = (_QWORD)v17 != v12;
                  if (*((_QWORD *)&v17 + 1) != v13)
                    ++v18;
                  if (!v18)
                    break;
                  if (!__stlxp(v17, v7))
                    goto LABEL_25;
                }
              }
              while (__stlxp(__PAIR128__(v13 + 1, (unint64_t)v9), v7));
LABEL_25:
              v19 = *((_QWORD *)&v17 + 1) ^ v13;
              v20 = v17 ^ v12;
              v13 = v17 >> 64;
              v12 = v17;
            }
            while (v20 | v19);
          }
          do
            v21 = __ldaxr(v8);
          while (__stlxr(v21 + 1, v8));
          ++v6;
        }
        while (v6 != a3);
      }
    }
  }
  return this;
}

void *caulk::alloc::page_allocator::allocate(caulk::alloc::page_allocator *this, uint64_t a2, unint64_t a3)
{
  void *result;

  if (*MEMORY[0x24BDB03C8] >= a3)
    return caulk::mach::vm_block::alloc((a2 + *MEMORY[0x24BDB03C8] - 1) & -*MEMORY[0x24BDB03C8], *(_DWORD *)this);
  _os_assert_log();
  result = (void *)_os_crash();
  __break(1u);
  return result;
}

void *caulk::mach::vm_block::alloc(size_t this, int a2)
{
  int v2;
  void *result;
  std::bad_alloc *exception;
  std::bad_alloc *v5;

  if (a2)
    v2 = a2 << 24;
  else
    v2 = -1;
  result = mmap(0, this, 3, 4098, v2, 0);
  if ((unint64_t)result + 1 <= 1)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v5 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v5, MEMORY[0x24BEDB758], MEMORY[0x24BEDB670]);
  }
  return result;
}

void caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::do_deallocate(uint64_t a1, unint64_t a2, unint64_t a3)
{
  void (*v6)(uint64_t, uint64_t, unint64_t, _QWORD, _QWORD, _QWORD);

  v6 = *(void (**)(uint64_t, uint64_t, unint64_t, _QWORD, _QWORD, _QWORD))(a1 + 1408);
  if (v6)
    v6(12, *(_QWORD *)(a1 + 1392) + 8, a2, 0, 0, 0);
  caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,256000ul,caulk::alloc::guarded_edges_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,4ul>>,caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>::deallocate(a1 + 16, a2, a3);
}

double caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_statistics(uint64_t a1, _OWORD *a2)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  double result;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD v20[3];
  _QWORD *v21;
  _QWORD v22[3];
  _QWORD *v23;
  int v24;
  _QWORD v25[3];
  _QWORD *v26;
  _BYTE v27[24];
  _BYTE *v28;
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 - 8);
  v16 = 0u;
  v17 = 0u;
  v20[0] = &off_24BF2D620;
  v20[1] = &v16;
  v21 = v20;
  v22[0] = &off_24BF2D360;
  v22[1] = v20;
  v23 = v22;
  v24 = 7;
  v4 = v25;
  v25[0] = &off_24BF2E1C8;
  v25[1] = caulk::alloc::introspector::local_reader;
  v5 = v27;
  v26 = v25;
  std::__function::__value_func<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v27, (uint64_t)v22);
  v29 = 1;
  v6 = v23;
  if (v23 == v22)
  {
    v7 = 4;
    v6 = v22;
  }
  else
  {
    if (!v23)
      goto LABEL_6;
    v7 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_6:
  v18 = 1424;
  v19 = v3;
  if (!v26)
    std::__throw_bad_function_call[abi:ne180100]();
  v8 = (*(uint64_t (**)(_QWORD *, uint64_t *, uint64_t *))(*v26 + 48))(v26, &v19, &v18);
  caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,256000ul,caulk::alloc::guarded_edges_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,4ul>>,caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>::introspect(v8 + 16, v3, (uint64_t)&v24);
  if (v28 == v27)
  {
    v9 = 4;
  }
  else
  {
    if (!v28)
      goto LABEL_12;
    v9 = 5;
    v5 = v28;
  }
  (*(void (**)(_QWORD *))(*v5 + 8 * v9))(v5);
LABEL_12:
  if (v26 == v25)
  {
    v10 = 4;
  }
  else
  {
    if (!v26)
      goto LABEL_17;
    v10 = 5;
    v4 = v26;
  }
  (*(void (**)(_QWORD *))(*v4 + 8 * v10))(v4);
LABEL_17:
  v11 = v21;
  if (v21 == v20)
  {
    v12 = 4;
    v11 = v20;
  }
  else
  {
    if (!v21)
      goto LABEL_22;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_22:
  v13 = *((_QWORD *)&v16 + 1);
  if (*(_QWORD *)(v3 + 1400) > *((_QWORD *)&v16 + 1))
    v13 = *(_QWORD *)(v3 + 1400);
  *(_QWORD *)&v17 = v13;
  *((_QWORD *)&v17 + 1) += *((_QWORD *)&v16 + 1);
  *(_QWORD *)(v3 + 1400) = v13;
  result = *(double *)&v16;
  v15 = v17;
  *a2 = v16;
  a2[1] = v15;
  return result;
}

void sub_2065C2318(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,_QWORD *a28,uint64_t a29,uint64_t a30,uint64_t a31,_QWORD *a32)
{
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;

  if (a32 == v33)
  {
    v35 = 4;
  }
  else
  {
    if (!a32)
      goto LABEL_6;
    v35 = 5;
    v33 = a32;
  }
  (*(void (**)(_QWORD *))(*v33 + 8 * v35))(v33);
LABEL_6:
  if (a28 == v32)
  {
    v36 = 4;
  }
  else
  {
    if (!a28)
      goto LABEL_11;
    v36 = 5;
    v32 = a28;
  }
  (*(void (**)(_QWORD *))(*v32 + 8 * v36))(v32);
LABEL_11:
  v37 = a19;
  if (a19 == &a16)
  {
    v38 = 4;
    v37 = &a16;
  }
  else
  {
    if (!a19)
      goto LABEL_16;
    v38 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v37 + 8 * v38))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

uint64_t caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::introspect<void caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect_foreach<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1}>(caulk::alloc::introspector const&,caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1} &&)::{lambda(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1} const&)#1}>(uint64_t result, uint64_t a2, int ***a3)
{
  _QWORD *v5;
  unint64_t v6;
  int **v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int v11;

  v5 = (_QWORD *)MEMORY[0x24BDB03C8];
  while (1)
  {
    v6 = atomic_load((unint64_t *)(result + 40));
    if (!*(_BYTE *)(result + 26))
    {
      v7 = *a3;
      v8 = *(_QWORD *)(result + 16);
      v9 = (*(_QWORD *)result + *v5 - 1) & -*v5;
      v10 = **a3;
      v11 = *v10;
      if ((*v10 & 2) != 0)
      {
        result = std::function<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(*((_QWORD *)v10 + 8), 2, v8, v9);
        v10 = *v7;
        v11 = **v7;
      }
      if ((v11 & 1) != 0)
        result = std::function<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(*((_QWORD *)v10 + 8), 1, v8, v9);
    }
    if ((v6 & 0xFFFFFFFFFFFFFFFCLL) == 0)
      break;
    result = std::function<void * ()(unsigned long,unsigned long)>::operator()(*(_QWORD *)(a2 + 24), v6 & 0xFFFFFFFFFFFFFFFCLL, 56);
  }
  return result;
}

double caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_statistics(uint64_t a1, _OWORD *a2)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  double result;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD v20[3];
  _QWORD *v21;
  _QWORD v22[3];
  _QWORD *v23;
  int v24;
  _QWORD v25[3];
  _QWORD *v26;
  _BYTE v27[24];
  _BYTE *v28;
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 - 8);
  v16 = 0u;
  v17 = 0u;
  v20[0] = &off_24BF2D5C8;
  v20[1] = &v16;
  v21 = v20;
  v22[0] = &off_24BF2D308;
  v22[1] = v20;
  v23 = v22;
  v24 = 7;
  v4 = v25;
  v25[0] = &off_24BF2E1C8;
  v25[1] = caulk::alloc::introspector::local_reader;
  v5 = v27;
  v26 = v25;
  std::__function::__value_func<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v27, (uint64_t)v22);
  v29 = 1;
  v6 = v23;
  if (v23 == v22)
  {
    v7 = 4;
    v6 = v22;
  }
  else
  {
    if (!v23)
      goto LABEL_6;
    v7 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_6:
  v18 = 1616;
  v19 = v3;
  if (!v26)
    std::__throw_bad_function_call[abi:ne180100]();
  v8 = (*(uint64_t (**)(_QWORD *, uint64_t *, uint64_t *))(*v26 + 48))(v26, &v19, &v18);
  caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,16128ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>>,caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>::introspect(v8 + 16, v3, (uint64_t)&v24);
  if (v28 == v27)
  {
    v9 = 4;
  }
  else
  {
    if (!v28)
      goto LABEL_12;
    v9 = 5;
    v5 = v28;
  }
  (*(void (**)(_QWORD *))(*v5 + 8 * v9))(v5);
LABEL_12:
  if (v26 == v25)
  {
    v10 = 4;
  }
  else
  {
    if (!v26)
      goto LABEL_17;
    v10 = 5;
    v4 = v26;
  }
  (*(void (**)(_QWORD *))(*v4 + 8 * v10))(v4);
LABEL_17:
  v11 = v21;
  if (v21 == v20)
  {
    v12 = 4;
    v11 = v20;
  }
  else
  {
    if (!v21)
      goto LABEL_22;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_22:
  v13 = *((_QWORD *)&v16 + 1);
  if (*(_QWORD *)(v3 + 1592) > *((_QWORD *)&v16 + 1))
    v13 = *(_QWORD *)(v3 + 1592);
  *(_QWORD *)&v17 = v13;
  *((_QWORD *)&v17 + 1) += *((_QWORD *)&v16 + 1);
  *(_QWORD *)(v3 + 1592) = v13;
  result = *(double *)&v16;
  v15 = v17;
  *a2 = v16;
  a2[1] = v15;
  return result;
}

void sub_2065C2674(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,_QWORD *a28,uint64_t a29,uint64_t a30,uint64_t a31,_QWORD *a32)
{
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;

  if (a32 == v33)
  {
    v35 = 4;
  }
  else
  {
    if (!a32)
      goto LABEL_6;
    v35 = 5;
    v33 = a32;
  }
  (*(void (**)(_QWORD *))(*v33 + 8 * v35))(v33);
LABEL_6:
  if (a28 == v32)
  {
    v36 = 4;
  }
  else
  {
    if (!a28)
      goto LABEL_11;
    v36 = 5;
    v32 = a28;
  }
  (*(void (**)(_QWORD *))(*v32 + 8 * v36))(v32);
LABEL_11:
  v37 = a19;
  if (a19 == &a16)
  {
    v38 = 4;
    v37 = &a16;
  }
  else
  {
    if (!a19)
      goto LABEL_16;
    v38 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v37 + 8 * v38))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

double caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_statistics(uint64_t a1, _OWORD *a2)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  double result;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[3];
  _QWORD *v22;
  _QWORD v23[3];
  _QWORD *v24;
  int v25;
  _QWORD v26[3];
  _QWORD *v27;
  _BYTE v28[24];
  _BYTE *v29;
  char v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 - 8);
  v17 = 0u;
  v18 = 0u;
  v21[0] = &off_24BF2D678;
  v21[1] = &v17;
  v22 = v21;
  v23[0] = &off_24BF2D3B8;
  v23[1] = v21;
  v24 = v23;
  v25 = 7;
  v4 = v26;
  v26[0] = &off_24BF2E1C8;
  v26[1] = caulk::alloc::introspector::local_reader;
  v5 = v28;
  v27 = v26;
  std::__function::__value_func<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v28, (uint64_t)v23);
  v30 = 1;
  v6 = v24;
  if (v24 == v23)
  {
    v7 = 4;
    v6 = v23;
  }
  else
  {
    if (!v24)
      goto LABEL_6;
    v7 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_6:
  v19 = 160;
  v20 = v3;
  if (!v27)
    std::__throw_bad_function_call[abi:ne180100]();
  v8 = (*(uint64_t (**)(_QWORD *, uint64_t *, uint64_t *))(*v27 + 48))(v27, &v20, &v19);
  caulk::alloc::details::caching_page_allocator_base::introspect((unint64_t *)(v8 + 16), v9, (const caulk::alloc::introspector *)&v25);
  if (v29 == v28)
  {
    v10 = 4;
  }
  else
  {
    if (!v29)
      goto LABEL_12;
    v10 = 5;
    v5 = v29;
  }
  (*(void (**)(_QWORD *))(*v5 + 8 * v10))(v5);
LABEL_12:
  if (v27 == v26)
  {
    v11 = 4;
  }
  else
  {
    if (!v27)
      goto LABEL_17;
    v11 = 5;
    v4 = v27;
  }
  (*(void (**)(_QWORD *))(*v4 + 8 * v11))(v4);
LABEL_17:
  v12 = v22;
  if (v22 == v21)
  {
    v13 = 4;
    v12 = v21;
  }
  else
  {
    if (!v22)
      goto LABEL_22;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_22:
  v14 = *((_QWORD *)&v17 + 1);
  if (*(_QWORD *)(v3 + 136) > *((_QWORD *)&v17 + 1))
    v14 = *(_QWORD *)(v3 + 136);
  *(_QWORD *)&v18 = v14;
  *((_QWORD *)&v18 + 1) += *((_QWORD *)&v17 + 1);
  *(_QWORD *)(v3 + 136) = v14;
  result = *(double *)&v17;
  v16 = v18;
  *a2 = v17;
  a2[1] = v16;
  return result;
}

void sub_2065C2904(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,_QWORD *a28,uint64_t a29,uint64_t a30,uint64_t a31,_QWORD *a32)
{
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;

  if (a32 == v33)
  {
    v35 = 4;
  }
  else
  {
    if (!a32)
      goto LABEL_6;
    v35 = 5;
    v33 = a32;
  }
  (*(void (**)(_QWORD *))(*v33 + 8 * v35))(v33);
LABEL_6:
  if (a28 == v32)
  {
    v36 = 4;
  }
  else
  {
    if (!a28)
      goto LABEL_11;
    v36 = 5;
    v32 = a28;
  }
  (*(void (**)(_QWORD *))(*v32 + 8 * v36))(v32);
LABEL_11:
  v37 = a19;
  if (a19 == &a16)
  {
    v38 = 4;
    v37 = &a16;
  }
  else
  {
    if (!a19)
      goto LABEL_16;
    v38 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v37 + 8 * v38))();
LABEL_16:
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2D3B8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::affix_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,std::array<unsigned long long,4ul>,std::array<unsigned long long,4ul>>::introspect<true,(BOOL *)0>(unsigned long,caulk::alloc::introspector const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::affix_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,std::array<unsigned long long,4ul>,std::array<unsigned long long,4ul>>::introspect<true,(BOOL *)0>(unsigned long,caulk::alloc::introspector const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2E488;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2D360;
  a2[1] = v2;
  return result;
}

uint64_t caulk::alloc::introspector::copy_with_types(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  v4 = a1 + 40;
  std::__function::__value_func<void * ()(unsigned long,unsigned long)>::__value_func[abi:ne180100](a1 + 8, a2 + 8);
  result = *(_QWORD *)(a2 + 64);
  if (result)
  {
    if (result == a2 + 40)
    {
      *(_QWORD *)(a1 + 64) = v4;
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 24))(result, v4);
      goto LABEL_6;
    }
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  }
  *(_QWORD *)(a1 + 64) = result;
LABEL_6:
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_DWORD *)a1 = 6;
  return result;
}

void sub_2065C2A88(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v4;
  uint64_t v5;

  v4 = *(_QWORD **)(v1 + 32);
  if (v4 == v2)
  {
    v5 = 4;
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
    v2 = *(_QWORD **)(v1 + 32);
  }
  (*(void (**)(_QWORD *))(*v2 + 8 * v5))(v2);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<void * (*)(unsigned long,unsigned long),std::allocator<void * (*)(unsigned long,unsigned long)>,void * ()(unsigned long,unsigned long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2E1C8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2D308;
  a2[1] = v2;
  return result;
}

void caulk::concurrent::details::messenger_servicer::drain(caulk::concurrent::details::messenger_servicer *this)
{
  unint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  semaphore_t v15;
  uint64_t v16;

  caulk::mach::semaphore::semaphore(&v15);
  v16 = 0;
  v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)caulk::alloc::realtime_safe_resource + 16))(caulk::alloc::realtime_safe_resource, 40, 8);
  *(_DWORD *)(v2 + 16) = 0;
  v3 = (unsigned int *)(v2 + 16);
  *(_QWORD *)(v2 + 24) = &v15;
  *(_QWORD *)v2 = &off_24BF2DF78;
  *(_QWORD *)(v2 + 8) = 0;
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 | 1, v3));
  if (v4)
  {
    __break(1u);
    return;
  }
  v5 = (unint64_t *)((char *)this + 8);
  v6 = *((_QWORD *)this + 1);
  atomic_store(v6, (unint64_t *)(v2 + 8));
  v7 = __ldaxr((unint64_t *)this + 1);
  if (v7 != v6)
  {
    __clrex();
LABEL_8:
    while (1)
    {
      atomic_store(v7, (unint64_t *)(v2 + 8));
      v8 = __ldaxr(v5);
      if (v8 != v7)
        break;
      if (__stlxr(v2, v5))
        goto LABEL_12;
      v9 = 1;
LABEL_13:
      v7 = v8;
      if (v9)
        goto LABEL_14;
    }
    __clrex();
LABEL_12:
    v9 = 0;
    goto LABEL_13;
  }
  if (__stlxr(v2, v5))
    goto LABEL_8;
LABEL_14:
  __dmb(0xBu);
  (*(void (**)(caulk::concurrent::details::messenger_servicer *))(*(_QWORD *)this + 16))(this);
  do
  {
    if ((*(unsigned int (**)(caulk::concurrent::details::messenger_servicer *))(*(_QWORD *)this + 24))(this))
    {
      while (1)
      {
        v10 = *((_QWORD *)this + 9);
        if (!v10)
        {
          do
            v13 = __ldaxr(v5);
          while (__stxr(0, v5));
          if (!v13)
            goto LABEL_25;
          v10 = 0;
          do
          {
            v11 = v10;
            v10 = v13;
            v12 = (unint64_t *)(v13 + 8);
            v13 = atomic_load((unint64_t *)(v13 + 8));
            atomic_store(v11, v12);
          }
          while (v13);
          *((_QWORD *)this + 9) = v10;
        }
        v14 = atomic_load((unint64_t *)(v10 + 8));
        *((_QWORD *)this + 9) = v14;
        atomic_store(0, (unsigned int *)(v10 + 16));
      }
    }
  }
  while (!caulk::semaphore::timed_wait(&v15, 0.5));
LABEL_25:
  caulk::semaphore::~semaphore((caulk::semaphore *)&v15);
}

void sub_2065C2C6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  caulk::semaphore::~semaphore((caulk::semaphore *)&a9);
  _Unwind_Resume(a1);
}

unint64_t *caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::do_allocate(uint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t *v5;
  unint64_t *v6;
  void (*v7)(uint64_t, uint64_t, unint64_t, _QWORD, unint64_t *, _QWORD);
  std::bad_alloc *exception;
  std::bad_alloc *v10;

  v5 = caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,16128ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>>,caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>::allocate(a1 + 16, a2, a3);
  if (!v5)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v10 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v10, MEMORY[0x24BEDB758], MEMORY[0x24BEDB670]);
  }
  v6 = v5;
  v7 = *(void (**)(uint64_t, uint64_t, unint64_t, _QWORD, unint64_t *, _QWORD))(a1 + 1600);
  if (v7)
    v7(10, *(_QWORD *)(a1 + 1584) + 8, a2, 0, v5, 0);
  return v6;
}

uint64_t `non-virtual thunk to'caulk::concurrent::details::service_thread::messenger_signal_wakeup(uint64_t this)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(this - 16);
  do
    v2 = __ldxr(v1);
  while (__stlxr(v2 + 1, v1));
  if ((v2 & 0x80000000) != 0)
    JUMPOUT(0x20BCFA1F0);
  return this;
}

void caulk::semaphore::~semaphore(caulk::semaphore *this)
{
  signed int v1;

  v1 = atomic_load((unsigned int *)this + 2);
  if (v1 < *((_DWORD *)this + 3))
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  else
  {
    caulk::mach::semaphore::~semaphore((semaphore_t *)this);
  }
}

void caulk::mach::semaphore::~semaphore(semaphore_t *this)
{
  if (*((_BYTE *)this + 4))
  {
    if (*this)
      semaphore_destroy(*MEMORY[0x24BDAEC58], *this);
  }
}

uint64_t `non-virtual thunk to'caulk::concurrent::details::service_thread::messenger_is_terminating_with_error(caulk::concurrent::details::service_thread *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)this - 8);
  return v1 & 1;
}

void caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::introspect<void caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>::introspect_foreach<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1}>(caulk::alloc::introspector const&,caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1} &&)::{lambda(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1} const&)#1}>(uint64_t a1, uint64_t a2, int ***a3)
{
  unint64_t v5;
  int **v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  int *v13;
  int v14;
  unint64_t v15;
  int v16;
  uint8_t v17[16];

  while (1)
  {
    v5 = atomic_load((unint64_t *)(a1 + 40));
    if (!*(_BYTE *)(a1 + 26))
    {
      v6 = *a3;
      v7 = *(_QWORD *)(a1 + 16);
      v8 = (*(_QWORD *)a1 + *MEMORY[0x24BDB03C8] - 1) & -*MEMORY[0x24BDB03C8];
      v9 = std::function<void * ()(unsigned long,unsigned long)>::operator()(*((_QWORD *)**a3 + 4), v7, v8);
      v10 = v7 - v9;
      v11 = v8 + v9;
      v12 = v9;
      while (v12 >= v9 && v11 > v12)
      {
        v13 = *v6;
        v14 = **v6;
        if ((v14 & 4) != 0)
        {
          std::function<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(*((_QWORD *)v13 + 8), 4, v10 + v12, 32);
          v13 = *v6;
          v14 = **v6;
        }
        v15 = *(_QWORD *)(v12 + 24);
        if ((*(_QWORD *)(v12 + 16) & 1) != 0)
          v16 = 2;
        else
          v16 = 1;
        if ((v16 & v14) != 0)
        {
          std::function<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(*((_QWORD *)v13 + 8), v16, v10 + v12 + 32, v15 >> 1);
          v15 = *(_QWORD *)(v12 + 24);
        }
        v12 += (v15 >> 1) + 32;
        if ((v15 & 1) != 0)
          goto LABEL_16;
      }
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v17 = 0;
        _os_log_fault_impl(&dword_2065BE000, MEMORY[0x24BDACB70], OS_LOG_TYPE_FAULT, "consolidating_free_map::introspect: walked past end of slab; target process's memory may be corrupt",
          v17,
          2u);
      }
    }
LABEL_16:
    if ((v5 & 0xFFFFFFFFFFFFFFFCLL) == 0)
      break;
    a1 = std::function<void * ()(unsigned long,unsigned long)>::operator()(*(_QWORD *)(a2 + 24), v5 & 0xFFFFFFFFFFFFFFFCLL, 56);
  }
}

uint64_t std::function<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  int v7;

  v7 = a2;
  v5 = a4;
  v6 = a3;
  if (!a1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, int *, uint64_t *, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v7, &v6, &v5);
}

uint64_t std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v5;
  _QWORD v6[2];

  v6[0] = a3;
  v6[1] = a4;
  v5 = a2;
  if (!a1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, int *, _QWORD *))(*(_QWORD *)a1 + 48))(a1, &v5, v6);
}

uint64_t std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(uint64_t result, int *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  _QWORD *v6;
  _DWORD *v7;

  v3 = *a2;
  v4 = *(_QWORD *)(a3 + 8);
  if (*a2 == 4 || v3 == 2)
  {
    v6 = (_QWORD *)(*(_QWORD *)(result + 8) + 24);
  }
  else
  {
    if (v3 != 1)
      return result;
    v7 = *(_DWORD **)(result + 8);
    ++*v7;
    v6 = v7 + 2;
  }
  *v6 += v4;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(uint64_t a1, int *a2, uint64_t *a3, uint64_t *a4)
{
  return std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 24), *a2, *a3, *a4);
}

uint64_t std::__function::__func<void caulk::alloc::affix_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,std::array<unsigned long long,4ul>,std::array<unsigned long long,4ul>>::introspect<true,(BOOL *)0>(unsigned long,caulk::alloc::introspector const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::affix_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,std::array<unsigned long long,4ul>,std::array<unsigned long long,4ul>>::introspect<true,(BOOL *)0>(unsigned long,caulk::alloc::introspector const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(uint64_t result, int *a2, uint64_t *a3, uint64_t *a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  int v8;
  uint64_t v9;

  v4 = *a2;
  v5 = *a3;
  v6 = *a4;
  v7 = *(int **)(result + 8);
  v8 = *v7;
  if (v4 == 1)
  {
    if ((v8 & 1) == 0)
      return result;
    v6 -= 64;
    v5 += 32;
    v9 = *((_QWORD *)v7 + 8);
    v4 = 1;
    return std::function<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(v9, v4, v5, v6);
  }
  if ((v8 & v4) != 0)
  {
    v9 = *((_QWORD *)v7 + 8);
    return std::function<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(v9, v4, v5, v6);
  }
  return result;
}

uint64_t std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(uint64_t result, int *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  _QWORD *v6;
  _DWORD *v7;

  v3 = *a2;
  v4 = *(_QWORD *)(a3 + 8);
  if (*a2 == 4 || v3 == 2)
  {
    v6 = (_QWORD *)(*(_QWORD *)(result + 8) + 24);
  }
  else
  {
    if (v3 != 1)
      return result;
    v7 = *(_DWORD **)(result + 8);
    ++*v7;
    v6 = v7 + 2;
  }
  *v6 += v4;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(uint64_t a1, int *a2, uint64_t *a3, uint64_t *a4)
{
  return std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 24), *a2, *a3, *a4);
}

unint64_t *caulk::alloc::details::caching_page_allocator_base::introspect(unint64_t *this, unint64_t a2, const caulk::alloc::introspector *a3)
{
  uint64_t v3;
  unint64_t *v5;

  v3 = this[4];
  if (v3)
  {
    v5 = this;
    do
    {
      if ((*(_BYTE *)a3 & 2) != 0)
        std::function<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(*((_QWORD *)a3 + 8), 2, v3, v5[2]);
      this = (unint64_t *)std::function<void * ()(unsigned long,unsigned long)>::operator()(*((_QWORD *)a3 + 4), v3, 8);
      v3 = atomic_load(this);
    }
    while (v3);
  }
  return this;
}

uint64_t std::__function::__func<void * (*)(unsigned long,unsigned long),std::allocator<void * (*)(unsigned long,unsigned long)>,void * ()(unsigned long,unsigned long)>::operator()(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 8))(*a2, *a3);
}

void caulk::concurrent::messenger::drain(caulk::concurrent::details::messenger_servicer **this)
{
  caulk::concurrent::details::messenger_servicer::drain(*this);
}

uint64_t caulk::thread_proxy<std::tuple<caulk::thread::attributes,void (caulk::concurrent::details::worker_thread::*)(void),std::tuple<caulk::concurrent::details::worker_thread*>>>(_QWORD *a1)
{
  uint64_t v2;
  void (*v3)(_QWORD *);
  _QWORD *v4;

  caulk::thread::attributes::apply_to_this_thread((uint64_t)a1);
  v2 = a1[9];
  v3 = (void (*)(_QWORD *))a1[8];
  v4 = (_QWORD *)(a1[10] + (v2 >> 1));
  if ((v2 & 1) != 0)
    v3 = *(void (**)(_QWORD *))(*v4 + v3);
  v3(v4);
  std::default_delete<std::tuple<caulk::thread::attributes,void (caulk::concurrent::details::worker_thread::*)(void),std::tuple<caulk::concurrent::details::worker_thread*>>>::operator()[abi:ne180100]((uint64_t)a1);
  return 0;
}

void sub_2065C3188(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::default_delete<std::tuple<caulk::thread::attributes,void (caulk::concurrent::details::worker_thread::*)(void),std::tuple<caulk::concurrent::details::worker_thread*>>>::operator()[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t caulk::thread::attributes::apply_to_this_thread(uint64_t this)
{
  uint64_t v1;

  v1 = this;
  if (*(_BYTE *)(this + 24))
  {
    if (*(char *)(this + 23) < 0)
      this = *(_QWORD *)this;
    this = pthread_setname_np((const char *)this);
  }
  if (*(_BYTE *)(v1 + 52))
    return caulk::mach::this_thread::set_priority((caulk::mach::thread::priority_absolute *)(v1 + 32));
  return this;
}

uint64_t caulk::concurrent::details::worker_thread::run(caulk::concurrent::details::worker_thread *this)
{
  semaphore_t *v2;
  uint64_t result;
  unsigned __int8 v4;

  v2 = (semaphore_t *)((char *)this + 32);
  do
  {
    caulk::semaphore::timed_wait(v2, -1.0);
    result = (*(uint64_t (**)(caulk::concurrent::details::worker_thread *))(*(_QWORD *)this + 16))(this);
    v4 = atomic_load((unsigned __int8 *)this + 49);
  }
  while ((v4 & 1) == 0);
  return result;
}

void sub_2065C3238(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  atomic_store(1u, (unsigned __int8 *)(v1 + 48));
  __cxa_end_catch();
}

BOOL caulk::semaphore::timed_wait(semaphore_t *this, double a2)
{
  unsigned int *v2;
  int v3;
  int v4;
  _BOOL8 result;
  uint64_t v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  char v11;
  unint64_t v12;

  v2 = this + 2;
  if (a2 == 0.0)
  {
    v3 = atomic_load(v2);
    if (v3 >= 1)
    {
      while (1)
      {
        v4 = __ldaxr(v2);
        if (v4 == v3)
        {
          if (!__stlxr(v3 - 1, v2))
            return 1;
        }
        else
        {
          __clrex();
        }
        result = 0;
        v3 = v4;
        if (v4 < 1)
          return result;
      }
    }
    return 0;
  }
  do
    v7 = __ldaxr(v2);
  while (__stxr(v7 - 1, v2));
  if ((int)v7 > 0)
    return 1;
  if (a2 > 0.0)
  {
    v12 = caulk::mach::semaphore::timed_wait_or_error(this, a2, v7);
    if (!HIDWORD(v12))
      return 0;
    caulk::expected<BOOL,int>::value((uint64_t)&v12);
    if ((_BYTE)v12)
      return 1;
    v8 = atomic_load(v2);
    if ((v8 & 0x80000000) != 0)
    {
      while (1)
      {
        v10 = __ldxr(v2);
        if (v10 != v8)
          break;
        if (__stxr(v8 + 1, v2))
          goto LABEL_23;
        v11 = 1;
LABEL_24:
        if ((v11 & 1) != 0)
          return 0;
        v8 = v10;
        if ((v10 & 0x80000000) == 0)
          goto LABEL_17;
      }
      __clrex();
LABEL_23:
      v11 = 0;
      goto LABEL_24;
    }
  }
  do
LABEL_17:
    v9 = MEMORY[0x20BCFA220](*this);
  while (v9 == 14);
  return v9 == 0;
}

uint64_t caulk::concurrent::details::messenger_servicer::check_dequeue(caulk::concurrent::details::messenger_servicer *this)
{
  unint64_t v1;
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v1 = *((_QWORD *)this + 9);
  if (!v1)
  {
    v2 = (unint64_t *)((char *)this + 8);
    do
      v3 = __ldaxr(v2);
    while (__stxr(0, v2));
    if (!v3)
      return 0;
    v1 = 0;
    do
    {
      v4 = v1;
      v1 = v3;
      v5 = (unint64_t *)(v3 + 8);
      v3 = atomic_load((unint64_t *)(v3 + 8));
      atomic_store(v4, v5);
    }
    while (v3);
    *((_QWORD *)this + 9) = v1;
  }
  v6 = atomic_load((unint64_t *)(v1 + 8));
  *((_QWORD *)this + 9) = v6;
  atomic_store(0, (unsigned int *)(v1 + 16));
  __dmb(9u);
  (*(void (**)(unint64_t))(*(_QWORD *)v1 + 16))(v1);
  return 1;
}

uint64_t caulk::concurrent::details::service_thread::wake(caulk::concurrent::details::service_thread *this)
{
  return caulk::concurrent::details::messenger_servicer::check_dequeue((caulk::concurrent::details::service_thread *)((char *)this + 56));
}

caulk::concurrent::message **caulk::concurrent::details::rt_message_call<caulk::concurrent::details::messenger_servicer::drain(void)::{lambda(void)#1} &&>::perform(caulk::concurrent::message *a1)
{
  unsigned int *v1;
  unsigned int *v2;
  unsigned int v3;
  caulk::concurrent::message *v5;

  v5 = a1;
  v1 = (unsigned int *)*((_QWORD *)a1 + 3);
  v2 = v1 + 2;
  do
    v3 = __ldxr(v2);
  while (__stlxr(v3 + 1, v2));
  if ((v3 & 0x80000000) != 0)
    MEMORY[0x20BCFA1F0](*v1);
  return caulk::concurrent::details::rt_message_call<caulk::concurrent::details::messenger_servicer::drain(void)::{lambda(void)#1} &&>::rt_cleanup::~rt_cleanup(&v5);
}

void sub_2065C3458(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  caulk::concurrent::details::rt_message_call<caulk::concurrent::details::messenger_servicer::drain(void)::{lambda(void)#1} &&>::rt_cleanup::~rt_cleanup((caulk::concurrent::message **)va);
  _Unwind_Resume(a1);
}

caulk::concurrent::message **caulk::concurrent::details::rt_message_call<caulk::concurrent::details::messenger_servicer::drain(void)::{lambda(void)#1} &&>::rt_cleanup::~rt_cleanup(caulk::concurrent::message **a1)
{
  caulk::concurrent::message *v2;

  v2 = *a1;
  caulk::concurrent::message::~message(*a1);
  (*(void (**)(uint64_t, caulk::concurrent::message *, uint64_t, uint64_t))(*(_QWORD *)caulk::alloc::realtime_safe_resource
                                                                                  + 24))(caulk::alloc::realtime_safe_resource, v2, 40, 8);
  return a1;
}

void caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::do_deallocate(uint64_t a1, caulk::mach::vm_block *a2, unint64_t a3)
{
  void (*v6)(uint64_t, uint64_t, caulk::mach::vm_block *, _QWORD, _QWORD, _QWORD);

  v6 = *(void (**)(uint64_t, uint64_t, caulk::mach::vm_block *, _QWORD, _QWORD, _QWORD))(a1 + 1600);
  if (v6)
    v6(12, *(_QWORD *)(a1 + 1584) + 8, a2, 0, 0, 0);
  caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,16128ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>>,caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>::deallocate(a1 + 16, a2, a3);
}

void caulk::concurrent::message::~message(caulk::concurrent::message *this)
{
  *(_QWORD *)this = off_24BF2DFD0;
  if (atomic_load((unsigned int *)this + 4))
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
}

uint64_t caulk::expected<BOOL,int>::value(uint64_t result)
{
  int *v1;
  _DWORD *exception;
  int v3;

  if (!*(_BYTE *)(result + 4))
  {
    v1 = (int *)result;
    exception = __cxa_allocate_exception(0x10uLL);
    v3 = *v1;
    *(_QWORD *)exception = &off_24BF2DFF8;
    exception[2] = v3;
  }
  return result;
}

uint64_t caulk::mach::semaphore::timed_wait_or_error@<X0>(semaphore_t *this@<X0>, double a2@<D0>, uint64_t a3@<X8>)
{
  unint64_t v4;
  mach_timespec_t v5;
  kern_return_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  int v11;
  unsigned int v12;

  LODWORD(a3) = vcvtmd_u64_f64(a2);
  v4 = a3 | ((unint64_t)(int)((a2 - floor(a2)) * 1000000000.0) << 32);
  do
  {
    v5 = (mach_timespec_t)v4;
    v6 = semaphore_timedwait(*this, v5);
  }
  while (v6 == 14);
  v7 = 0x100000000;
  v8 = 0x100000000;
  v9 = v6 & 0xFFFFFF00;
  v10 = v6;
  if (v6 == 49)
    v10 = 0;
  else
    v8 = 0;
  if (v6 == 49)
    v9 = 0;
  if (v6)
  {
    v7 = v8;
    v11 = v10;
  }
  else
  {
    v11 = 1;
  }
  if (v6)
    v12 = v9;
  else
    v12 = 0;
  return v7 | v12 | v11;
}

uint64_t caulk::alloc::page_cache_monitor_impl::evaluate_reservations(uint64_t **this)
{
  unint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t result;
  unint64_t v11;

  v2 = (unint64_t)this[19];
  v3 = this[21];
  v4 = this[22];
  while (v3 != v4)
  {
    v5 = (std::__shared_weak_count *)v3[1];
    if (v5)
    {
      v6 = std::__shared_weak_count::lock(v5);
      if (v6)
      {
        v7 = v6;
        if (*v3 && *(_QWORD *)(*v3 + 32) > v2)
          v2 = *(_QWORD *)(*v3 + 32);
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          v9 = __ldaxr(p_shared_owners);
        while (__stlxr(v9 - 1, p_shared_owners));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
    }
    v3 += 2;
  }
  atomic_store(v2, (unint64_t *)this + 20);
  result = **this;
  v11 = *(_QWORD *)(result + 48);
  if (v2 > v11)
    return caulk::alloc::details::caching_page_allocator_base::preallocate(result, *(_QWORD *)(result + 16), v2 - v11);
  return result;
}

void caulk::lifetime_guard<caulk::alloc::page_cache_monitor,caulk::shared_ptr_mutex<caulk::mach::unfair_lock>>::weak_ref::lock(_QWORD *a1, uint64_t *a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  os_unfair_lock_t *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;

  v3 = (std::__shared_weak_count *)a2[1];
  if (v3)
  {
    while (1)
    {
      v5 = std::__shared_weak_count::lock(v3);
      if (!v5)
        goto LABEL_10;
      v6 = v5;
      v7 = *a2;
      if (!*a2)
        break;
      v8 = *(os_unfair_lock_t **)(*(_QWORD *)(v7 + 16) + 48);
      if (os_unfair_lock_trylock(*v8))
      {
        *a1 = **(_QWORD **)(v7 + 16);
        a1[1] = v6;
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          v12 = __ldxr(p_shared_owners);
        while (__stxr(v12 + 1, p_shared_owners));
        os_unfair_lock_unlock(*v8);
LABEL_15:
        v13 = (unint64_t *)&v6->__shared_owners_;
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
        return;
      }
      v9 = (unint64_t *)&v6->__shared_owners_;
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
      std::this_thread::sleep_for[abi:ne180100]<long long,std::ratio<1l,1000l>>(5);
      v3 = (std::__shared_weak_count *)a2[1];
      if (!v3)
        goto LABEL_10;
    }
    *a1 = 0;
    a1[1] = 0;
    goto LABEL_15;
  }
LABEL_10:
  *a1 = 0;
  a1[1] = 0;
}

void caulk::deferred_logger::create_v(caulk::deferred_logger *this@<X0>, std::__shared_weak_count_vtbl **a2@<X8>)
{
  uint64_t v5;
  std::__shared_weak_count_vtbl *v6;
  unsigned __int8 v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v10;
  unint64_t v11;
  unint64_t *p_shared_weak_owners;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  std::string __p;
  std::string v19;
  char v20;
  uint64_t v21;
  int v22;
  char v23;
  char v24;
  char v25;

  v5 = operator new();
  v6 = (std::__shared_weak_count_vtbl *)v5;
  *(_QWORD *)v5 = 0;
  *(_QWORD *)(v5 + 8) = 0;
  if ((v7 & 1) == 0)
  {
    if ((_DWORD)v5)
    {
      std::string::basic_string[abi:ne180100]<0>(&__p, "caulk::deferred_logger");
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&v19, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      else
        v19 = __p;
      v20 = 1;
      v21 = -4294967271;
      v22 = 0;
      v23 = 1;
      v24 = 0;
      v25 = 0;
      caulk::concurrent::messenger::messenger((caulk::concurrent::messenger *)&caulk::defLogMessenger(void)::global, 1, (uint64_t)&v19);
      if (v20 && SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v19.__r_.__value_.__l.__data_);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  v6->__on_zero_shared = (void (__cdecl *)(std::__shared_count *__hidden))&caulk::defLogMessenger(void)::global;
  v6->__get_deleter = (const void *(__cdecl *)(const std::__shared_weak_count *__hidden, const std::type_info *))this;
  v6->__on_zero_shared_weak = 0;
  v6[1].~__shared_weak_count = 0;
  caulk::alloc::init_realtime_safe_resource((caulk::alloc *)v5);
  *a2 = v6;
  v8 = (std::__shared_weak_count *)operator new();
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2E658;
  v8->__shared_weak_owners_ = 0;
  v8[1].__vftable = v6;
  a2[1] = (std::__shared_weak_count_vtbl *)v8;
  v10 = (std::__shared_weak_count *)v6->~__shared_weak_count_0;
  if (v10)
  {
    if (v10->__shared_owners_ != -1)
      return;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v13 = __ldxr(p_shared_weak_owners);
    while (__stxr(v13 + 1, p_shared_weak_owners));
    v6->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v6;
    v6->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v8;
    std::__shared_weak_count::__release_weak(v10);
  }
  else
  {
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
    v15 = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
    v6->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v6;
    v6->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v8;
  }
  do
    v17 = __ldaxr(p_shared_owners);
  while (__stlxr(v17 - 1, p_shared_owners));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
}

void sub_2065C3A38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  uint64_t v22;
  std::__shared_weak_count *v24;

  if (a15 < 0)
    operator delete(__p);
  v24 = *(std::__shared_weak_count **)(v22 + 8);
  if (v24)
    std::__shared_weak_count::__release_weak(v24);
  MEMORY[0x20BCF9C08](v22, 0x10A0C404BBAD8CELL);
  _Unwind_Resume(a1);
}

uint64_t caulk::multi_simple_random<unsigned int,4ul,std::uniform_int_distribution<unsigned int>,std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>::multi_simple_random(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t i;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t j;

  v2 = 0;
  v3 = a1;
  do
  {
    v4 = a1 + 2512 * v2;
    v5 = 5489;
    *(_DWORD *)v4 = 5489;
    for (i = 1; i != 624; ++i)
    {
      v5 = i + 1812433253 * (v5 ^ (v5 >> 30));
      *(_DWORD *)(v3 + 4 * i) = v5;
    }
    *(_QWORD *)(v4 + 2496) = 0;
    *(_BYTE *)(a1 + 2512 * v2++ + 2504) = 0;
    v3 += 2512;
  }
  while (v2 != 4);
  v7 = 0;
  *(_QWORD *)(a1 + 10048) = 0xFFFFFFFF00000000;
  v8 = a1;
  do
  {
    v9 = mach_absolute_time();
    *(_DWORD *)v8 = v9;
    for (j = 1; j != 624; ++j)
    {
      v9 = j + 1812433253 * (v9 ^ (v9 >> 30));
      *(_DWORD *)(v8 + 4 * j) = v9;
    }
    *(_QWORD *)(v8 + 2496) = 0;
    ++v7;
    v8 += 2512;
  }
  while (v7 != 4);
  return a1;
}

uint64_t *caulk::inplace_function<void ()(void),32ul,8ul,caulk::inplace_function_detail::vtable>::operator=(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;

  if (a1 != a2)
  {
    (*(void (**)(uint64_t *))(*a1 + 24))(a1 + 1);
    v4 = *a2;
    *a2 = (uint64_t)&caulk::inplace_function_detail::vtable<void>::empty;
    *a1 = v4;
    (*(void (**)(uint64_t *, uint64_t *))(v4 + 16))(a1 + 1, a2 + 1);
  }
  return a1;
}

uint64_t caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::skiplist(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t i;
  _QWORD *v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  _QWORD *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t j;

  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  os_unfair_lock_lock((os_unfair_lock_t)&caulk::alloc::shared_allocator<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::shared_instance(void)::global);
  if (qword_253D09D40)
  {
    v2 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_253D09D40);
    if (v2)
    {
      v3 = v2;
      v4 = qword_253D09D38;
      if (qword_253D09D38)
        goto LABEL_14;
      p_shared_owners = (unint64_t *)&v2->__shared_owners_;
      do
        v6 = __ldaxr(p_shared_owners);
      while (__stlxr(v6 - 1, p_shared_owners));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }
  v3 = (std::__shared_weak_count *)operator new(0x1A0uLL);
  v3->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2D780;
  v3->__shared_owners_ = 0;
  *(_OWORD *)&v3[1].__shared_owners_ = 0u;
  v4 = (uint64_t)&v3[1].__shared_owners_;
  v3->__shared_weak_owners_ = 0;
  v3[2].std::__shared_count = 0u;
  *(_OWORD *)&v3[2].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v3[3].__shared_owners_ = 0u;
  v3[4].std::__shared_count = 0u;
  *(_OWORD *)&v3[4].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v3[5].__shared_owners_ = 0u;
  v3[6].std::__shared_count = 0u;
  *(_OWORD *)&v3[6].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v3[7].__shared_owners_ = 0u;
  v3[8].std::__shared_count = 0u;
  *(_OWORD *)&v3[8].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v3[9].__shared_owners_ = 0u;
  v3[10].std::__shared_count = 0u;
  *(_OWORD *)&v3[10].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v3[11].__shared_owners_ = 0u;
  v3[12].std::__shared_count = 0u;
  *(_OWORD *)&v3[12].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v3[13].__shared_owners_ = 0u;
  v3[14].std::__shared_count = 0u;
  *(_OWORD *)&v3[14].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v3[15].__shared_owners_ = 0u;
  v3[16].std::__shared_count = 0u;
  *(_OWORD *)&v3[16].__shared_weak_owners_ = 0u;
  caulk::alloc::global_page_cache::instance((caulk::alloc::global_page_cache *)v3);
  v3[3].__shared_owners_ = 0;
  v3[1].__shared_weak_owners_ = (uint64_t)&unk_253D0A3B0;
  v3[2].__vftable = 0;
  v3[2].__shared_owners_ = 0;
  v3[2].__shared_weak_owners_ = 0;
  LODWORD(v3[3].__vftable) = 0;
  for (i = 96; i != 416; i += 32)
  {
    v8 = (std::__shared_weak_count_vtbl **)((char *)&v3->__vftable + i);
    *v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
  }
  p_shared_weak_owners = (unint64_t *)&v3->__shared_weak_owners_;
  do
    v10 = __ldxr(p_shared_weak_owners);
  while (__stxr(v10 + 1, p_shared_weak_owners));
  v11 = (std::__shared_weak_count *)qword_253D09D40;
  qword_253D09D38 = (uint64_t)&v3[1].__shared_owners_;
  qword_253D09D40 = (uint64_t)v3;
  if (v11)
    std::__shared_weak_count::__release_weak(v11);
LABEL_14:
  v12 = (_QWORD *)(a1 + 200);
  os_unfair_lock_unlock((os_unfair_lock_t)&caulk::alloc::shared_allocator<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::shared_instance(void)::global);
  v13 = (unint64_t *)&v3->__shared_owners_;
  do
    v14 = __ldxr(v13);
  while (__stxr(v14 + 1, v13));
  v15 = *(std::__shared_weak_count **)(a1 + 280);
  *(_QWORD *)(a1 + 272) = v4;
  *(_QWORD *)(a1 + 280) = v3;
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  do
    v18 = __ldaxr(v13);
  while (__stlxr(v18 - 1, v13));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  *(_QWORD *)(a1 + 288) = &caulk::inplace_function_detail::vtable<void,caulk::concurrent::details::skiplist_node<void *,caulk::alloc::detail::tracked_block>::layout_vk const&>::empty;
  caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::random_engine();
  v19 = 0;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 167837706;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  do
  {
    atomic_store(0, (unint64_t *)(a1 + v19 + 40));
    atomic_store(0, (unint64_t *)(a1 + v19 + 48));
    v19 += 16;
  }
  while (v19 != 160);
  *v12 = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 224) = 16908289;
  *(_QWORD *)(a1 + 216) = -1;
  *(_QWORD *)(a1 + 232) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  atomic_store(0, (unint64_t *)(a1 + 240));
  atomic_store(0, (unint64_t *)(a1 + 248));
  for (j = 40; j != 200; j += 16)
    atomic_store((unint64_t)v12, (unint64_t *)(a1 + j));
  __dmb(0xBu);
  return a1;
}

void sub_2065C3EA0(void *a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  void *v4;

  std::__shared_weak_count::~__shared_weak_count(v2);
  operator delete(v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&caulk::alloc::shared_allocator<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::shared_instance(void)::global);
  std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](v1 + 272);
  __clang_call_terminate(a1);
}

caulk::concurrent::messenger *caulk::concurrent::messenger::messenger(caulk::concurrent::messenger *a1, int a2, uint64_t a3)
{
  std::__shared_weak_count *v5;
  unsigned int *v6;
  uint64_t v7;
  BOOL v8;
  int v9;
  BOOL v11;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  _BOOL4 v20;
  uint64_t v21;
  int v22;
  _BOOL4 v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  caulk::concurrent::details::service_thread *v28;
  std::__shared_weak_count *v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *p_shared_weak_owners;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  char *v46;
  char *v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  uint64_t v51;
  __int128 v52;
  uint64_t v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t *v58;
  unint64_t v59;
  unint64_t v60;
  std::string::size_type v61;
  unint64_t *v62;
  unint64_t v63;
  caulk::alloc *v64;
  std::__shared_weak_count *size;
  unint64_t *v66;
  unint64_t v67;
  unint64_t *v68;
  unint64_t v69;
  uint64_t v71;
  std::__shared_weak_count *v72;
  std::string v73;
  char v74;
  __int128 v75;
  int v76;
  char v77;
  char v78;
  char v79;
  std::string __p;
  std::string v81;
  __int128 v82;
  char v83;
  char *v84;

  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  if (a2 == 1)
  {
    v5 = (std::__shared_weak_count *)operator new(0xE0uLL);
    v5->__shared_owners_ = 0;
    v5->__shared_weak_owners_ = 0;
    v5->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2E508;
    v72 = v5;
    v73.__r_.__value_.__r.__words[0] = (std::string::size_type)caulk::concurrent::details::service_thread::service_thread((caulk::concurrent::details::service_thread *)&v5[1], (const caulk::thread::attributes *)a3)+ 56;
    v73.__r_.__value_.__l.__size_ = (std::string::size_type)v5;
    goto LABEL_109;
  }
  memset(&v81, 0, sizeof(v81));
  if (!*(_BYTE *)(a3 + 52))
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_123;
  }
  v6 = (unsigned int *)(a3 + 32);
  caulk::concurrent::messenger::shared_high_priority(a1);
  v7 = *(unsigned int *)(a3 + 48);
  v8 = dword_253D09D88 != (_DWORD)v7 || dword_253D09D88 == -1;
  v9 = !v8;
  if ((_DWORD)v7 == -1 || v9 == 0)
  {
    v11 = dword_253D09D88 == -1;
    if ((_DWORD)v7 != -1)
      v11 = v9;
    if (!v11)
    {
LABEL_21:
      if (!(_DWORD)v7)
      {
        std::to_string(&v73, *v6);
        v81 = v73;
        goto LABEL_24;
      }
LABEL_123:
      _os_assert_log();
      _os_crash();
      __break(1u);
      goto LABEL_124;
    }
  }
  else
  {
    v73.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
    if (((unsigned int (*)(std::string *, uint64_t, uint64_t *))off_24BF2E748[v7])(&v73, a3 + 32, &qword_253D09D78))
    {
      LODWORD(v7) = *(_DWORD *)(a3 + 48);
      goto LABEL_21;
    }
  }
  *((_BYTE *)&v81.__r_.__value_.__s + 23) = 4;
  strcpy((char *)&v81, "high");
LABEL_24:
  std::operator+<char>();
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v73, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  else
    v73 = __p;
  v74 = 1;
  v75 = *(_OWORD *)v6;
  v76 = *(_DWORD *)(a3 + 48);
  v77 = 1;
  v78 = 0;
  v79 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&caulk::concurrent::details::service_thread::sharedMgr(void)::global);
  v13 = std::remove_if[abi:ne180100]<std::__wrap_iter<std::weak_ptr<caulk::lifetime_observed<std::unique_ptr<caulk::concurrent::details::service_thread>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::observer>> *>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::remove_expired(void)::{lambda(std::__wrap_iter<std::weak_ptr<caulk::lifetime_observed<std::unique_ptr<caulk::concurrent::details::service_thread>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::observer>> *> const&)#1}>((uint64_t *)qword_253D09DA0, (uint64_t *)qword_253D09DA8);
  std::vector<std::weak_ptr<caulk::lifetime_observed<std::unique_ptr<caulk::concurrent::details::service_thread>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::observer>>>::erase((uint64_t)&qword_253D09DA0, (uint64_t)v13, qword_253D09DA8);
  v14 = (_QWORD *)qword_253D09DA0;
  v15 = qword_253D09DA8;
  if (qword_253D09DA0 == qword_253D09DA8)
  {
LABEL_45:
    v72 = 0;
    goto LABEL_46;
  }
  while (1)
  {
    v16 = (std::__shared_weak_count *)v14[1];
    if (v16)
    {
      v17 = std::__shared_weak_count::lock(v16);
      *((_QWORD *)&v82 + 1) = v17;
      if (v17)
        break;
    }
LABEL_44:
    v14 += 2;
    if (v14 == (_QWORD *)v15)
      goto LABEL_45;
  }
  v18 = v17;
  *(_QWORD *)&v82 = *v14;
  if (!(_QWORD)v82)
    goto LABEL_40;
  v19 = *(_QWORD *)(v82 + 16);
  v20 = (*(_BYTE *)(a3 + 52) != 0) == (*(_BYTE *)(v19 + 188) != 0);
  if (*(_BYTE *)(a3 + 52) && *(_BYTE *)(v19 + 188))
  {
    v21 = *(unsigned int *)(a3 + 48);
    v22 = *(_DWORD *)(v19 + 184);
    v23 = v22 == v21;
    v8 = v22 == -1;
    v20 = v22 == -1;
    if (v8)
      v23 = 0;
    if ((_DWORD)v21 != -1)
    {
      v20 = v23;
      if (v23)
      {
        v84 = &v83;
        if ((((uint64_t (*)(char **, uint64_t, uint64_t))off_24BF2E760[v21])(&v84, a3 + 32, v19 + 168) & 1) != 0)
          goto LABEL_92;
        goto LABEL_40;
      }
    }
  }
  if (!v20)
  {
LABEL_40:
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
    goto LABEL_44;
  }
LABEL_92:
  v71 = v19;
  v72 = v18;
  v58 = (unint64_t *)&v18->__shared_owners_;
  do
    v59 = __ldxr(v58);
  while (__stxr(v59 + 1, v58));
  do
    v60 = __ldaxr(v58);
  while (__stlxr(v60 - 1, v58));
  if (!v60)
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  if (!v19)
  {
LABEL_46:
    if (v72)
    {
      v26 = (unint64_t *)&v72->__shared_owners_;
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
        std::__shared_weak_count::__release_weak(v72);
      }
    }
    v28 = (caulk::concurrent::details::service_thread *)operator new();
    caulk::concurrent::details::service_thread::service_thread(v28, (const caulk::thread::attributes *)&v73);
    v29 = (std::__shared_weak_count *)operator new(0x38uLL);
    v30 = v29;
    v29->__shared_owners_ = 0;
    v31 = (unint64_t *)&v29->__shared_owners_;
    v29->__shared_weak_owners_ = 0;
    v29[1].__vftable = 0;
    v29->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2E578;
    v29[1].__shared_owners_ = 0;
    v29[1].__shared_weak_owners_ = (uint64_t)v28;
    v29[2].__vftable = (std::__shared_weak_count_vtbl *)&caulk::concurrent::details::service_thread::sharedMgr(void)::global;
    *(_QWORD *)&v82 = v29 + 1;
    *((_QWORD *)&v82 + 1) = v29;
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
    p_shared_weak_owners = (unint64_t *)&v29->__shared_weak_owners_;
    do
      v34 = __ldxr(p_shared_weak_owners);
    while (__stxr(v34 + 1, p_shared_weak_owners));
    v29[1].__vftable = (std::__shared_weak_count_vtbl *)&v29[1];
    v29[1].__shared_owners_ = (uint64_t)v29;
    do
      v35 = __ldaxr(v31);
    while (__stlxr(v35 - 1, v31));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v30);
    }
    v36 = (_QWORD *)qword_253D09DA8;
    if (qword_253D09DA8 < (unint64_t)qword_253D09DB0)
    {
      *(_QWORD *)qword_253D09DA8 = v82;
      v37 = (std::__shared_weak_count *)*((_QWORD *)&v82 + 1);
      v36[1] = *((_QWORD *)&v82 + 1);
      if (v37)
      {
        v38 = (unint64_t *)&v37->__shared_weak_owners_;
        do
          v39 = __ldxr(v38);
        while (__stxr(v39 + 1, v38));
      }
      v40 = (uint64_t)(v36 + 2);
      qword_253D09DA8 = (uint64_t)(v36 + 2);
      goto LABEL_84;
    }
    v41 = (_QWORD *)qword_253D09DA0;
    v42 = (qword_253D09DA8 - qword_253D09DA0) >> 4;
    v43 = v42 + 1;
    if (!((unint64_t)(v42 + 1) >> 60))
    {
      v44 = qword_253D09DB0 - qword_253D09DA0;
      if ((qword_253D09DB0 - qword_253D09DA0) >> 3 > v43)
        v43 = v44 >> 3;
      if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF0)
        v45 = 0xFFFFFFFFFFFFFFFLL;
      else
        v45 = v43;
      if (v45 >> 60)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v46 = (char *)operator new(16 * v45);
      v47 = &v46[16 * v42];
      v48 = (std::__shared_weak_count *)*((_QWORD *)&v82 + 1);
      *(_OWORD *)v47 = v82;
      v37 = v48;
      if (v48)
      {
        v49 = (unint64_t *)&v48->__shared_weak_owners_;
        do
          v50 = __ldxr(v49);
        while (__stxr(v50 + 1, v49));
        v36 = (_QWORD *)qword_253D09DA8;
      }
      v51 = (uint64_t)&v46[16 * v45];
      v40 = (uint64_t)(v47 + 16);
      if (v36 == v41)
      {
        qword_253D09DA0 = (uint64_t)v47;
        qword_253D09DA8 = (uint64_t)(v47 + 16);
        qword_253D09DB0 = v51;
        if (!v41)
          goto LABEL_84;
      }
      else
      {
        do
        {
          v52 = *((_OWORD *)v36 - 1);
          v36 -= 2;
          *((_OWORD *)v47 - 1) = v52;
          v47 -= 16;
          *v36 = 0;
          v36[1] = 0;
        }
        while (v36 != v41);
        v53 = qword_253D09DA0;
        v41 = (_QWORD *)qword_253D09DA8;
        qword_253D09DA0 = (uint64_t)v47;
        qword_253D09DA8 = v40;
        qword_253D09DB0 = v51;
        if (v41 != (_QWORD *)v53)
        {
          do
          {
            v54 = (std::__shared_weak_count *)*(v41 - 1);
            if (v54)
              std::__shared_weak_count::__release_weak(v54);
            v41 -= 2;
          }
          while (v41 != (_QWORD *)v53);
          v41 = (_QWORD *)v53;
        }
        if (!v41)
          goto LABEL_84;
      }
      operator delete(v41);
      v37 = (std::__shared_weak_count *)*((_QWORD *)&v82 + 1);
LABEL_84:
      qword_253D09DA8 = v40;
      v71 = *(_QWORD *)(v82 + 16);
      v72 = v37;
      if (v37)
      {
        v55 = (unint64_t *)&v37->__shared_owners_;
        do
          v56 = __ldxr(v55);
        while (__stxr(v56 + 1, v55));
        do
          v57 = __ldaxr(v55);
        while (__stlxr(v57 - 1, v55));
        if (!v57)
        {
          ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
          std::__shared_weak_count::__release_weak(v37);
        }
      }
      goto LABEL_98;
    }
LABEL_124:
    std::vector<std::weak_ptr<caulk::lifetime_observed<std::unique_ptr<caulk::concurrent::details::service_thread>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::observer>>>::__throw_length_error[abi:ne180100]();
  }
LABEL_98:
  os_unfair_lock_unlock((os_unfair_lock_t)&caulk::concurrent::details::service_thread::sharedMgr(void)::global);
  if (v74 && SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v73.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v81.__r_.__value_.__l.__data_);
  v5 = v72;
  if (v71)
    v61 = v71 + 56;
  else
    v61 = 0;
  v73.__r_.__value_.__r.__words[0] = v61;
  v73.__r_.__value_.__l.__size_ = (std::string::size_type)v72;
  if (v72)
  {
LABEL_109:
    v62 = (unint64_t *)&v5->__shared_owners_;
    do
      v63 = __ldxr(v62);
    while (__stxr(v63 + 1, v62));
  }
  v64 = (caulk::alloc *)std::shared_ptr<caulk::concurrent::details::messenger_servicer>::operator=[abi:ne180100]((uint64_t)a1, (__int128 *)&v73);
  size = (std::__shared_weak_count *)v73.__r_.__value_.__l.__size_;
  if (v73.__r_.__value_.__l.__size_)
  {
    v66 = (unint64_t *)(v73.__r_.__value_.__l.__size_ + 8);
    do
      v67 = __ldaxr(v66);
    while (__stlxr(v67 - 1, v66));
    if (!v67)
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
  }
  caulk::alloc::init_realtime_safe_resource(v64);
  if (v72)
  {
    v68 = (unint64_t *)&v72->__shared_owners_;
    do
      v69 = __ldaxr(v68);
    while (__stlxr(v69 - 1, v68));
    if (!v69)
    {
      ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
      std::__shared_weak_count::__release_weak(v72);
    }
  }
  return a1;
}

void sub_2065C45A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  uint64_t v34;

  if (a28 < 0)
    operator delete(__p);
  if (a34 < 0)
    operator delete(a29);
  std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](v34);
  _Unwind_Resume(a1);
}

uint64_t caulk::alloc::get_realtime_safe_resource(caulk::alloc *this)
{
  uint64_t result;

  result = caulk::alloc::realtime_safe_resource;
  if (!caulk::alloc::realtime_safe_resource)
  {
    caulk::alloc::init_realtime_safe_resource(0);
    return caulk::alloc::realtime_safe_resource;
  }
  return result;
}

caulk::concurrent::details::service_thread *caulk::concurrent::details::service_thread::service_thread(caulk::concurrent::details::service_thread *this, const caulk::thread::attributes *a2)
{
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  uint64_t v10;
  unsigned __int8 v11[8];

  *(_QWORD *)this = off_24BF2DEE8;
  *((_BYTE *)this + 8) = 0;
  *((_BYTE *)this + 24) = 0;
  caulk::mach::semaphore::semaphore((semaphore_t *)this + 8);
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_WORD *)this + 24) = 0;
  *(_QWORD *)this = &off_24BF2DF10;
  *((_QWORD *)this + 7) = &unk_24BF2DF48;
  *((_QWORD *)this + 8) = 0;
  std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100]((std::string *)((char *)this + 136), (__int128 *)a2);
  v4 = *((_OWORD *)a2 + 2);
  *(_OWORD *)((char *)this + 181) = *(_OWORD *)((char *)a2 + 45);
  *(_OWORD *)((char *)this + 168) = v4;
  v10 = 0;
  v11[0] = 0;
  v5 = operator new();
  std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100]((std::string *)v5, (__int128 *)a2);
  *(_OWORD *)(v5 + 32) = *((_OWORD *)a2 + 2);
  *(_OWORD *)(v5 + 45) = *(_OWORD *)((char *)a2 + 45);
  *(_QWORD *)(v5 + 64) = caulk::concurrent::details::worker_thread::run;
  *(_QWORD *)(v5 + 72) = 0;
  *(_QWORD *)(v5 + 80) = this;
  caulk::thread::start((uint64_t)&v10, v5, (void *(__cdecl *)(void *))caulk::thread_proxy<std::tuple<caulk::thread::attributes,void (caulk::concurrent::details::worker_thread::*)(void),std::tuple<caulk::concurrent::details::worker_thread*>>>, (void *)v5);
  if (*((_BYTE *)this + 24))
  {
    v6 = *((_QWORD *)this + 1);
    *((_QWORD *)this + 1) = v10;
    v10 = v6;
    LOBYTE(v6) = atomic_load(v11);
    atomic_store(v6 & 1, (unsigned __int8 *)this + 16);
  }
  else
  {
    *((_BYTE *)this + 16) = 0;
    *((_QWORD *)this + 1) = v10;
    v10 = 0;
    v7 = atomic_load(v11);
    atomic_store(v7 & 1, (unsigned __int8 *)this + 16);
    v8 = atomic_load(v11);
    atomic_store(v8 & 1, (unsigned __int8 *)this + 16);
    *((_BYTE *)this + 24) = 1;
  }
  if (v10)
    std::terminate();
  return this;
}

semaphore_t *caulk::semaphore::semaphore(semaphore_t *this, semaphore_t a2)
{
  semaphore_t *result;

  result = caulk::mach::semaphore::semaphore(this);
  result[2] = a2;
  result[3] = a2;
  return result;
}

{
  semaphore_t *result;

  result = caulk::mach::semaphore::semaphore(this);
  result[2] = a2;
  result[3] = a2;
  return result;
}

semaphore_t *caulk::mach::semaphore::semaphore(semaphore_t *semaphore)
{
  const char *v2;

  *semaphore = 0;
  *((_BYTE *)semaphore + 4) = 0;
  v2 = (const char *)semaphore_create(*MEMORY[0x24BDAEC58], semaphore, 0, 0);
  caulk::mach::throw_if_mach_error((uint64_t)"semaphore_create", v2);
  *((_BYTE *)semaphore + 4) = 1;
  return semaphore;
}

uint64_t caulk::mach::throw_if_mach_error(uint64_t this, const char *a2)
{
  const char *v2;
  std::runtime_error *exception;
  std::runtime_error *v4;
  std::runtime_error v5[2];
  _BYTE v6[24];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if ((_DWORD)a2)
  {
    *(_QWORD *)v6 = &off_24BF2E040;
    MEMORY[0x20BCF9A70](v5, a2, v6, this);
    std::error_category::~error_category((std::error_category *)v6);
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
    {
      v2 = std::runtime_error::what(v5);
      *(_DWORD *)v6 = 136315138;
      *(_QWORD *)&v6[4] = v2;
      _os_log_error_impl(&dword_2065BE000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "Throwing: %s", v6, 0xCu);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x20uLL);
    v4 = std::runtime_error::runtime_error(exception, v5);
    v4->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x24BEDB818] + 16);
    v4[1] = v5[1];
    __cxa_throw(v4, MEMORY[0x24BEDB6E8], (void (*)(void *))MEMORY[0x24BEDADC8]);
  }
  return this;
}

void sub_2065C4A24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::runtime_error a9, uint64_t a10, uint64_t a11, std::error_category a12)
{
  std::runtime_error::~runtime_error(&a9);
  _Unwind_Resume(a1);
}

uint64_t caulk::thread::start(uint64_t a1, uint64_t a2, void *(__cdecl *a3)(void *), void *a4)
{
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  sched_param v13;
  uint64_t result;
  sched_param v15;
  pthread_attr_t __attr;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (pthread_attr_init(&__attr))
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_28;
  }
  if (*(_BYTE *)(a2 + 52))
  {
    v8 = *(_DWORD *)(a2 + 48);
    if (v8 == -1)
      v9 = -1;
    else
      v9 = *(unsigned int *)(a2 + 48);
    if (v9 == 2)
    {
      if (v8 == 2)
      {
        v15 = 0;
        pthread_attr_getschedparam(&__attr, &v15);
        v15.sched_priority = *(_DWORD *)(a2 + 32);
        pthread_attr_setschedparam(&__attr, &v15);
        if (*(_BYTE *)(a2 + 36))
          pthread_attr_setschedpolicy(&__attr, 4);
        goto LABEL_14;
      }
    }
    else
    {
      if (v9 == 1)
      {
        v15 = 0;
        pthread_attr_getschedparam(&__attr, &v15);
        v15.sched_priority = 63;
        pthread_attr_setschedparam(&__attr, &v15);
        goto LABEL_17;
      }
      if (v9)
        goto LABEL_17;
      if (!v8)
      {
        pthread_attr_set_qos_class_np(&__attr, *(qos_class_t *)(a2 + 32), *(_DWORD *)(a2 + 36));
LABEL_14:
        if (*(_BYTE *)(a2 + 52))
          *(_BYTE *)(a2 + 52) = 0;
        goto LABEL_17;
      }
    }
    std::__throw_bad_variant_access[abi:ne180100]();
  }
LABEL_17:
  if (*(_BYTE *)(a2 + 60))
  {
    v10 = *(_DWORD *)(a2 + 56);
    if (v10 == 1)
      v11 = 2;
    else
      v11 = 1;
    pthread_attr_setdetachstate(&__attr, v11);
    v15 = 0;
    v12 = pthread_create((pthread_t *)&v15, &__attr, a3, a4);
    if (v10 == 1)
      goto LABEL_25;
  }
  else
  {
    v15 = 0;
    v12 = pthread_create((pthread_t *)&v15, &__attr, a3, a4);
  }
  v13 = v15;
  *(sched_param *)a1 = v15;
  if (!*(_QWORD *)&v13)
    goto LABEL_29;
LABEL_25:
  atomic_store(1u, (unsigned __int8 *)(a1 + 8));
  result = pthread_attr_destroy(&__attr);
  if (v12)
  {
LABEL_28:
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_29:
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  return result;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

char *caulk::concurrent::messenger::shared_high_priority(caulk::concurrent::messenger *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    caulk::concurrent::messenger::shared_high_priority(void)::global = 0;
    byte_253D09D70 = 0;
    qword_253D09D78 = 0x100000037;
    dword_253D09D88 = 2;
    byte_253D09D8C = 1;
    byte_253D09D90 = 0;
    byte_253D09D94 = 0;
  }
  return &caulk::concurrent::messenger::shared_high_priority(void)::global;
}

void std::vector<std::weak_ptr<caulk::lifetime_observed<std::unique_ptr<caulk::concurrent::details::service_thread>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::observer>>>::erase(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  __int128 v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;

  if (a2 != a3)
  {
    v3 = a3;
    v4 = a2;
    v6 = *(_QWORD *)(a1 + 8);
    if (a3 != v6)
    {
      v7 = 16 * ((a3 - a2) >> 4);
      do
      {
        v8 = (_QWORD *)(v4 + v7);
        v9 = *(_OWORD *)(v4 + v7);
        *v8 = 0;
        v8[1] = 0;
        v10 = *(std::__shared_weak_count **)(v4 + 8);
        *(_OWORD *)v4 = v9;
        if (v10)
          std::__shared_weak_count::__release_weak(v10);
        v4 += 16;
      }
      while (v4 + v7 != v6);
      v3 = *(_QWORD *)(a1 + 8);
    }
    while (v3 != v4)
    {
      v11 = *(std::__shared_weak_count **)(v3 - 8);
      if (v11)
        std::__shared_weak_count::__release_weak(v11);
      v3 -= 16;
    }
    *(_QWORD *)(a1 + 8) = v4;
  }
}

uint64_t *caulk::alloc::global_page_cache::instance(caulk::alloc::global_page_cache *this)
{
  unsigned __int8 v1;

  {
    caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::darwin_resource();
  }
  return &caulk::alloc::global_page_cache::instance(void)::global;
}

void sub_2065C4E18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::darwin_resource()
{
  uint64_t v0;

  caulk::alloc::details::caching_page_allocator_base::caching_page_allocator_base((caulk::alloc::details::caching_page_allocator_base *)&unk_253D0A3B0, 0x4000);
  caulk::alloc::global_page_cache::instance(void)::global = (uint64_t)&off_24BF2CCB0;
  v0 = operator new();
  *(_QWORD *)v0 = &caulk::alloc::global_page_cache::instance(void)::global;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 40) = 0u;
  *(_OWORD *)(v0 + 56) = 0u;
  *(_OWORD *)(v0 + 72) = 0u;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 88) = 0u;
  *(_OWORD *)(v0 + 136) = 0u;
  *(_OWORD *)(v0 + 120) = 0u;
  *(_OWORD *)(v0 + 152) = 0u;
  *(_OWORD *)(v0 + 168) = 0u;
  *(_OWORD *)(v0 + 184) = 0u;
  *(_QWORD *)(v0 + 200) = 0;
  *(_QWORD *)(v0 + 24) = caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_size_for_ptr;
  *(_QWORD *)(v0 + 32) = caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_plus::zone_plus(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>&,char const*)::{lambda(_malloc_zone_t *,unsigned long)#1}::__invoke;
  *(_QWORD *)(v0 + 40) = caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_plus::zone_plus(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>&,char const*)::{lambda(_malloc_zone_t *,unsigned long,unsigned long)#1}::__invoke;
  *(_QWORD *)(v0 + 48) = caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_plus::zone_plus(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>&,char const*)::{lambda(_malloc_zone_t *,unsigned long)#2}::__invoke;
  *(_QWORD *)(v0 + 56) = caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_plus::zone_plus(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>&,char const*)::{lambda(_malloc_zone_t *,void *)#1}::__invoke;
  *(_QWORD *)(v0 + 64) = caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_plus::zone_plus(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>&,char const*)::{lambda(_malloc_zone_t *,void *,unsigned long)#1}::__invoke;
  *(_QWORD *)(v0 + 136) = caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_pressure_relief;
  *(_DWORD *)(v0 + 112) = 8;
  *(_QWORD *)(v0 + 104) = caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::introspection_funcs(void)::funcs;
  *(_QWORD *)(v0 + 80) = "caulk::global_page_cache";
  malloc_zone_register((malloc_zone_t *)(v0 + 8));
  qword_253D0A420 = v0;
  *(_QWORD *)algn_253D0A428 = 0;
  qword_253D0A430 = *MEMORY[0x24BDAED40];
}

void sub_2065C4F44(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BCF9C08](v1, 0x10F0C4098D16567);
  caulk::alloc::details::caching_page_allocator_base::~caching_page_allocator_base((caulk::alloc::details::caching_page_allocator_base *)&unk_253D0A3B0);
  _Unwind_Resume(a1);
}

caulk::alloc::details::caching_page_allocator_base *caulk::alloc::details::caching_page_allocator_base::caching_page_allocator_base(caulk::alloc::details::caching_page_allocator_base *this, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;

  *(_DWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = a2;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 11) = 0;
  v3 = (_QWORD *)operator new();
  *v3 = this;
  v4 = operator new(0x20uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_24BF2E5B0;
  *((_DWORD *)v4 + 6) = 0;
  v3[1] = v4 + 3;
  v3[2] = v4;
  v5 = operator new(0x20uLL);
  v5[1] = 0;
  v5[2] = 0;
  *v5 = &off_24BF2E5B0;
  *((_DWORD *)v5 + 6) = 0;
  v3[3] = v5 + 3;
  v3[4] = v5;
  v3[5] = 0;
  *((_QWORD *)this + 12) = v3;
  *((_QWORD *)this + 13) = 0;
  return this;
}

void sub_2065C5024(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v6;
  uint64_t v7;

  v4 = v3;
  std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](v4);
  MEMORY[0x20BCF9C08](v2, 0x20C40A759441BLL);
  v6 = *(_QWORD **)(v1 + 88);
  if (v6 == (_QWORD *)(v1 + 64))
  {
    v7 = 4;
    v6 = (_QWORD *)(v1 + 64);
  }
  else
  {
    if (!v6)
      goto LABEL_6;
    v7 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_6:
  _Unwind_Resume(a1);
}

void caulk::alloc::page_cache_monitor::enable_preallocation(os_unfair_lock_t *this, uint64_t *a2)
{
  uint64_t **v4;
  caulk::concurrent::messenger *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD v27[3];
  _QWORD *v28;
  _QWORD v29[3];
  _QWORD *v30;
  _QWORD v31[4];

  v31[3] = *MEMORY[0x24BDAC8D0];
  caulk::alloc::init_realtime_safe_resource((caulk::alloc *)this);
  os_unfair_lock_lock(this[3]);
  if (!a2)
  {
    v18 = (uint64_t *)(this + 5);
    v19 = 0;
LABEL_39:
    std::unique_ptr<caulk::alloc::page_cache_monitor_impl>::reset[abi:ne180100](v18, v19);
    goto LABEL_40;
  }
  if (!this[5])
  {
    v4 = (uint64_t **)operator new();
    *v4 = (uint64_t *)this;
    v4[1] = (uint64_t *)this;
    v5 = (caulk::concurrent::messenger *)operator new(0x30uLL);
    v6 = (std::__shared_weak_count *)v5;
    *((_QWORD *)v5 + 1) = 0;
    v7 = (unint64_t *)((char *)v5 + 8);
    *((_QWORD *)v5 + 2) = 0;
    *(_QWORD *)v5 = &off_24BF2E620;
    *((_QWORD *)v5 + 3) = 0;
    *((_QWORD *)v5 + 4) = 0;
    *((_QWORD *)v5 + 5) = v4 + 1;
    v4[2] = (uint64_t *)((char *)v5 + 24);
    v4[3] = (uint64_t *)v5;
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
    v9 = (unint64_t *)((char *)v5 + 16);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    *((_QWORD *)v5 + 3) = (char *)v5 + 24;
    *((_QWORD *)v5 + 4) = v5;
    do
      v11 = __ldaxr(v7);
    while (__stlxr(v11 - 1, v7));
    if (!v11)
    {
      (*(void (**)(caulk::concurrent::messenger *))(*(_QWORD *)v5 + 16))(v5);
      std::__shared_weak_count::__release_weak(v6);
    }
    *((_BYTE *)v4 + 32) = 0;
    *((_BYTE *)v4 + 48) = 0;
    v4[7] = (uint64_t *)(this + 1);
    caulk::concurrent::messenger::shared_high_priority(v5);
    caulk::concurrent::messenger::messenger(v4 + 8, 0, &caulk::concurrent::messenger::shared_high_priority(void)::global);
    v13 = v4[2];
    v12 = v4[3];
    if (v12)
    {
      v14 = (unint64_t *)(v12 + 2);
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    v29[0] = &off_24BF2D6D0;
    v29[1] = v13;
    v29[2] = v12;
    v30 = v29;
    *((_DWORD *)v4 + 24) = 0;
    v4[10] = (uint64_t *)&off_24BF2DEC0;
    v4[11] = 0;
    v4[13] = (uint64_t *)(v4 + 8);
    *((_BYTE *)v4 + 112) = 0;
    v4[18] = (uint64_t *)(v4 + 15);
    std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0>,void ()(void)>::__clone((uint64_t)v29, v4 + 15);
    v16 = v30;
    if (v30 == v29)
    {
      v17 = 4;
      v16 = v29;
    }
    else
    {
      if (!v30)
        goto LABEL_20;
      v17 = 5;
    }
    (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_20:
    v4[19] = a2;
    *((_OWORD *)v4 + 10) = 0u;
    *((_OWORD *)v4 + 11) = 0u;
    v20 = **v4;
    v27[0] = &off_24BF2D728;
    v27[1] = v4;
    v28 = v27;
    v21 = (_QWORD *)(v20 + 64);
    v30 = v29;
    std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_1,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_1>,void ()(unsigned long,unsigned long)>::__clone((uint64_t)v27, v29);
    v22 = v30;
    if ((_QWORD *)(v20 + 64) != v29)
    {
      v23 = *(_QWORD **)(v20 + 88);
      if (v30 == v29)
      {
        if (v23 == v21)
        {
          (*(void (**)(_QWORD *, _QWORD *))(v29[0] + 24))(v29, v31);
          (*(void (**)(_QWORD *))(*v30 + 32))(v30);
          v30 = 0;
          (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(v20 + 88) + 24))(*(_QWORD *)(v20 + 88), v29);
          (*(void (**)(_QWORD))(**(_QWORD **)(v20 + 88) + 32))(*(_QWORD *)(v20 + 88));
          *(_QWORD *)(v20 + 88) = 0;
          v30 = v29;
          (*(void (**)(_QWORD *, uint64_t))(v31[0] + 24))(v31, v20 + 64);
          (*(void (**)(_QWORD *))(v31[0] + 32))(v31);
          *(_QWORD *)(v20 + 88) = v21;
          v22 = v30;
        }
        else
        {
          (*(void (**)(_QWORD *, uint64_t))(v29[0] + 24))(v29, v20 + 64);
          (*(void (**)(_QWORD *))(*v30 + 32))(v30);
          v22 = *(_QWORD **)(v20 + 88);
          v30 = v22;
          *(_QWORD *)(v20 + 88) = v21;
        }
      }
      else
      {
        if (v23 == v21)
        {
          v22 = v29;
          (*(void (**)(uint64_t, _QWORD *))(*v21 + 24))(v20 + 64, v29);
          (*(void (**)(_QWORD))(**(_QWORD **)(v20 + 88) + 32))(*(_QWORD *)(v20 + 88));
          *(_QWORD *)(v20 + 88) = v30;
          v30 = v29;
          v24 = 4;
          goto LABEL_32;
        }
        v30 = *(_QWORD **)(v20 + 88);
        *(_QWORD *)(v20 + 88) = v22;
        v22 = v23;
      }
    }
    if (v22 == v29)
    {
      v24 = 4;
      v22 = v29;
    }
    else
    {
      if (!v22)
        goto LABEL_33;
      v24 = 5;
    }
LABEL_32:
    (*(void (**)(_QWORD *))(*v22 + 8 * v24))(v22);
LABEL_33:
    v25 = v28;
    if (v28 == v27)
    {
      v26 = 4;
      v25 = v27;
    }
    else
    {
      if (!v28)
      {
LABEL_38:
        atomic_store((unint64_t)v4[19], (unint64_t *)v4 + 20);
        caulk::alloc::page_cache_monitor_impl::evaluate_reservations(v4);
        v18 = (uint64_t *)(this + 5);
        v19 = (uint64_t)v4;
        goto LABEL_39;
      }
      v26 = 5;
    }
    (*(void (**)(void))(*v25 + 8 * v26))();
    goto LABEL_38;
  }
LABEL_40:
  os_unfair_lock_unlock(this[3]);
}

void sub_2065C5488(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t caulk::concurrent::condition_message::perform(caulk::concurrent::condition_message *this)
{
  uint64_t v1;

  atomic_store(0, (unsigned __int8 *)this + 32);
  v1 = *((_QWORD *)this + 8);
  if (!v1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

caulk::pooled_semaphore_mutex *caulk::pooled_semaphore_mutex::pooled_semaphore_mutex(caulk::pooled_semaphore_mutex *this)
{
  *(_DWORD *)this = 0;
  caulk::details::semaphore_pool::instance(this);
  return this;
}

{
  *(_DWORD *)this = 0;
  caulk::details::semaphore_pool::instance(this);
  return this;
}

void caulk::details::semaphore_pool::instance(caulk::details::semaphore_pool *this)
{
  unsigned __int8 v1;
  caulk::details::semaphore_pool *v2;

  if ((v1 & 1) == 0)
  {
    if ((_DWORD)v2)
    {
      caulk::details::semaphore_pool::semaphore_pool(v2);
    }
  }
}

void sub_2065C55A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t caulk::mach::this_thread::set_priority(caulk::mach::thread::priority_absolute *a1)
{
  int v1;
  uint64_t v2;

  v1 = *((_DWORD *)a1 + 4);
  if (v1 == -1)
    v2 = -1;
  else
    v2 = *((unsigned int *)a1 + 4);
  switch(v2)
  {
    case 2:
      if (v1 != 2)
        goto LABEL_14;
      return caulk::mach::thread::priority_absolute::apply_to_this_thread(a1);
    case 1:
      if (v1 != 1)
        goto LABEL_14;
      return caulk::mach::thread::priority_realtime::apply_to_this_thread((integer_t *)a1);
    case 0:
      if (!v1)
        return caulk::mach::thread::priority_qos::apply_to_this_thread(a1);
LABEL_14:
      std::__throw_bad_variant_access[abi:ne180100]();
    default:
      return 0xFFFFFFFFLL;
  }
}

void caulk::mach::vm_block::dealloc(caulk::mach::vm_block *this, size_t a2)
{
  int v2;
  int v3;
  _DWORD v4[2];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  v2 = munmap(this, a2);
  if (v2)
  {
    v3 = v2;
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109120;
      v4[1] = v3;
      _os_log_error_impl(&dword_2065BE000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "munmap failed! %d", (uint8_t *)v4, 8u);
    }
  }
}

uint64_t caulk::mach::os_workgroup_managed::leave(caulk::mach::os_workgroup_managed *this)
{
  uint64_t result;

  if (!*((_BYTE *)this + 56))
    return 1;
  if (!*((_QWORD *)this + 1))
    return 2;
  os_workgroup_leave_self();
  result = 0;
  *((_BYTE *)this + 56) = 0;
  return result;
}

uint64_t caulk::mach::this_thread::set_name(caulk::mach::this_thread *this, const char *a2)
{
  return pthread_setname_np((const char *)this);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

uint64_t caulk::mach::thread::priority_qos::apply_to_this_thread(caulk::mach::thread::priority_qos *this)
{
  return pthread_set_qos_class_self_np(*(qos_class_t *)this, *((_DWORD *)this + 1));
}

void std::__throw_bad_variant_access[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x24BEDB8D8] + 16;
  __cxa_throw(exception, MEMORY[0x24BEDB738], (void (*)(void *))std::bad_variant_access::~bad_variant_access);
}

uint64_t caulk::mach::thread::priority_absolute::apply_to_this_thread(caulk::mach::thread::priority_absolute *this)
{
  _opaque_pthread_t *v2;
  thread_act_t v3;
  thread_act_t v4;
  uint64_t result;
  pid_t v6;
  int v7;
  int v8;
  integer_t v9;
  integer_t policy_info;
  _BYTE buffer[228];
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v2 = pthread_self();
  v3 = pthread_mach_thread_np(v2);
  v4 = v3;
  if (!v3)
    return 0xFFFFFFFFLL;
  policy_info = *((unsigned __int8 *)this + 4);
  result = thread_policy_set(v3, 1u, &policy_info, 1u);
  if (!(_DWORD)result)
  {
    v6 = getpid();
    v7 = proc_pidinfo(v6, 2, 0, buffer, 232);
    v8 = v12;
    if (v7 <= 0)
      v8 = 0;
    v9 = *(_DWORD *)this - v8;
    return thread_policy_set(v4, 3u, &v9, 1u);
  }
  return result;
}

void sub_2065C5870(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_opaque_pthread_t *caulk::mach::thread::get_base_priority(_opaque_pthread_t *this, _opaque_pthread_t *a2)
{
  return get_priority(this, 0);
}

_opaque_pthread_t *get_priority(_opaque_pthread_t *result, int a2)
{
  thread_inspect_t v3;
  mach_msg_type_number_t thread_info_outCnt;
  integer_t v5[5];
  integer_t v6[5];
  integer_t v7[4];
  integer_t thread_info_out[5];
  int v9;

  if (result)
  {
    v3 = pthread_mach_thread_np(result);
    thread_info_outCnt = 10;
    if (thread_info(v3, 3u, thread_info_out, &thread_info_outCnt))
      return 0;
    switch(v9)
    {
      case 4:
        thread_info_outCnt = 4;
        if (thread_info(v3, 0xCu, v7, &thread_info_outCnt))
          return 0;
        if (v7[2] && a2)
          return (_opaque_pthread_t *)v7[3];
        else
          return (_opaque_pthread_t *)v7[1];
      case 2:
        thread_info_outCnt = 5;
        if (thread_info(v3, 0xBu, v6, &thread_info_outCnt))
          return 0;
        if (v6[3] && a2)
          return (_opaque_pthread_t *)v6[4];
        else
          return (_opaque_pthread_t *)v6[1];
      case 1:
        thread_info_outCnt = 5;
        if (thread_info(v3, 0xAu, v5, &thread_info_outCnt))
          return 0;
        if (a2)
          return (_opaque_pthread_t *)v5[2];
        else
          return (_opaque_pthread_t *)v5[1];
      default:
        return 0;
    }
  }
  return result;
}

_opaque_pthread_t *caulk::mach::thread::get_scheduled_priority(_opaque_pthread_t *this, _opaque_pthread_t *a2)
{
  return get_priority(this, 1);
}

_QWORD *caulk::mach::thread::get_name@<X0>(_opaque_pthread_t *this@<X0>, _QWORD *a2@<X8>)
{
  int v4;
  _OWORD v6[16];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  memset(v6, 0, sizeof(v6));
  v4 = pthread_getname_np(this, (char *)v6, 0x100uLL);
  check_posix_error((uint64_t)"pthread_getname_np failed", v4);
  return std::string::basic_string[abi:ne180100]<0>(a2, (char *)v6);
}

uint64_t check_posix_error(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  const std::error_category *v4;
  const char *v5;
  std::runtime_error *exception;
  std::runtime_error *v7;
  std::runtime_error v8[2];
  uint8_t buf[4];
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    v2 = result;
    v3 = *__error();
    v4 = std::generic_category();
    MEMORY[0x20BCF9A70](v8, v3, v4, v2);
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
    {
      v5 = std::runtime_error::what(v8);
      *(_DWORD *)buf = 136315138;
      v10 = v5;
      _os_log_error_impl(&dword_2065BE000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "%s", buf, 0xCu);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x20uLL);
    v7 = std::runtime_error::runtime_error(exception, v8);
    v7->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x24BEDB818] + 16);
    v7[1] = v8[1];
    __cxa_throw(v7, MEMORY[0x24BEDB6E8], (void (*)(void *))MEMORY[0x24BEDADC8]);
  }
  return result;
}

void sub_2065C5B54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
  std::runtime_error::~runtime_error(&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::string::basic_string[abi:ne180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_24BF2BD50, MEMORY[0x24BEDAAF0]);
}

void sub_2065C5C6C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8B8] + 16);
  return result;
}

uint64_t caulk::mach::thread::get_qos_class(_opaque_pthread_t *this, _opaque_pthread_t *a2)
{
  int qos_class_np;
  qos_class_t __qos_class[2];

  *(_QWORD *)__qos_class = 21;
  qos_class_np = pthread_get_qos_class_np(this, __qos_class, (int *)&__qos_class[1]);
  check_posix_error((uint64_t)"pthread_get_qos_class_np failed", qos_class_np);
  return *(_QWORD *)__qos_class;
}

BOOL caulk::memory_resource::do_is_equal(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t caulk::alloc::memory_resource::malloc_zone(caulk::alloc::memory_resource *this)
{
  return 0;
}

uint64_t *caulk::alloc::get_default_resource(caulk::alloc *this)
{
  unsigned __int8 v1;

  {
    caulk::alloc::get_default_resource(void)::global = (uint64_t)&off_24BF2CE38;
  }
  return &caulk::alloc::get_default_resource(void)::global;
}

void caulk::alloc::resource<caulk::alloc::malloc_allocator,caulk::alloc::memory_resource>::~resource()
{
  JUMPOUT(0x20BCF9C08);
}

void *caulk::alloc::resource<caulk::alloc::malloc_allocator,caulk::alloc::memory_resource>::do_allocate(caulk::alloc::malloc_allocator *a1, size_t a2, size_t a3)
{
  void *result;
  std::bad_alloc *exception;
  std::bad_alloc *v5;

  result = caulk::alloc::malloc_allocator::allocate(a1, a2, a3);
  if (!result)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v5 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v5, MEMORY[0x24BEDB758], MEMORY[0x24BEDB670]);
  }
  return result;
}

void caulk::alloc::resource<caulk::alloc::malloc_allocator,caulk::alloc::memory_resource>::do_deallocate(int a1, void *a2)
{
  free(a2);
}

BOOL caulk::alloc::resource<caulk::alloc::malloc_allocator,caulk::alloc::memory_resource>::do_is_equal(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

_QWORD *caulk::alloc::resource<caulk::alloc::malloc_allocator,caulk::alloc::memory_resource>::print(caulk::alloc::malloc_allocator *a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  char v5;

  v3 = a2;
  v4 = 0;
  v5 = 0;
  return caulk::alloc::malloc_allocator::describe(a1, (caulk::alloc::base_allocator::formatter *)&v3);
}

uint64_t caulk::alloc::resource<caulk::alloc::malloc_allocator,caulk::alloc::memory_resource>::compact()
{
  return 0;
}

void caulk::alloc::resource<caulk::alloc::malloc_allocator,caulk::alloc::memory_resource>::reserve(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void caulk::alloc::create_malloc_zone_resource(caulk::alloc *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v5;
  malloc_zone_t *zone;

  v5 = (_QWORD *)operator new();
  v5[1] = 0;
  v5[2] = 0;
  *v5 = 0;
  zone = malloc_create_zone(0, 0);
  *v5 = &off_24BF2E158;
  v5[1] = zone;
  v5[2] = 0;
  malloc_set_zone_name(zone, (const char *)this);
  v5[2] = v5[1];
  *a2 = v5;
}

void sub_2065C5EA8(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t caulk::alloc::resource_with_zone<caulk::alloc::malloc_zone_allocator>::~resource_with_zone(uint64_t a1)
{
  caulk::alloc::malloc_zone_allocator::~malloc_zone_allocator((malloc_zone_t **)(a1 + 8));
  return a1;
}

void caulk::alloc::resource_with_zone<caulk::alloc::malloc_zone_allocator>::~resource_with_zone(uint64_t a1)
{
  caulk::alloc::malloc_zone_allocator::~malloc_zone_allocator((malloc_zone_t **)(a1 + 8));
  JUMPOUT(0x20BCF9C08);
}

void *caulk::alloc::resource<caulk::alloc::malloc_zone_allocator,caulk::alloc::memory_resource>::do_allocate(uint64_t a1, size_t a2, size_t a3)
{
  void *result;
  std::bad_alloc *exception;
  std::bad_alloc *v5;

  result = caulk::alloc::malloc_zone_allocator::allocate((malloc_zone_t **)(a1 + 8), a2, a3);
  if (!result)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v5 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v5, MEMORY[0x24BEDB758], MEMORY[0x24BEDB670]);
  }
  return result;
}

void caulk::alloc::resource<caulk::alloc::malloc_zone_allocator,caulk::alloc::memory_resource>::do_deallocate(uint64_t a1, void *a2)
{
  malloc_zone_free(*(malloc_zone_t **)(a1 + 8), a2);
}

BOOL caulk::alloc::resource<caulk::alloc::malloc_zone_allocator,caulk::alloc::memory_resource>::do_is_equal(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

_QWORD *caulk::alloc::resource<caulk::alloc::malloc_zone_allocator,caulk::alloc::memory_resource>::print(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  char v5;

  v3 = a2;
  v4 = 0;
  v5 = 0;
  return caulk::alloc::malloc_zone_allocator::describe((malloc_zone_t **)(a1 + 8), (caulk::alloc::base_allocator::formatter *)&v3);
}

uint64_t caulk::alloc::resource<caulk::alloc::malloc_zone_allocator,caulk::alloc::memory_resource>::compact()
{
  return 0;
}

void caulk::alloc::resource<caulk::alloc::malloc_zone_allocator,caulk::alloc::memory_resource>::reserve(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t caulk::alloc::resource_with_zone<caulk::alloc::malloc_zone_allocator>::malloc_zone(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t caulk::alloc::init_realtime_safe_resource(caulk::alloc *this)
{
  caulk::alloc::global_page_cache *v1;
  int v2;
  uint64_t v3;
  caulk::alloc::global_page_cache *v4;
  uint64_t v5;
  caulk::alloc::global_page_cache *v6;
  uint64_t v7;
  uint64_t v8;
  caulk::alloc::global_page_cache *v9;
  const char *v10;
  _QWORD v12[4];
  void (**v13)();
  _QWORD v14[4];
  uint64_t (**v15)();
  _QWORD v16[5];

  v16[4] = *MEMORY[0x24BDAC8D0];
  v1 = (caulk::alloc::global_page_cache *)os_unfair_recursive_lock_lock_with_options();
  v2 = caulk::alloc::init_realtime_safe_resource(void)::state;
  caulk::alloc::init_realtime_safe_resource(void)::state = 1;
  if (!v2)
  {
    if (byte_253D026D0)
    {
      qword_253D02070 = (uint64_t)&off_24BF2CD20;
      qword_253D02080 = (uint64_t)&off_24BF2CBD0;
      v3 = qword_253D026B0;
      qword_253D026B0 = 0;
      if (v3)
        std::default_delete<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_plus>::operator()[abi:ne180100](v3);
      caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::~tree_allocator((uint64_t)&unk_253D02450);
      caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::~tree_allocator((uint64_t)&unk_253D021F0);
      caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::~tracking_allocator((uint64_t)&qword_253D02090);
      std::pmr::memory_resource::~memory_resource((std::pmr::memory_resource *)&qword_253D02070);
      byte_253D026D0 = 0;
    }
    qword_253D02070 = (uint64_t)&off_24BF2CD20;
    *(_QWORD *)algn_253D02078 = 0;
    qword_253D02090 = 0;
    caulk::alloc::global_page_cache::instance(v1);
    qword_253D02090 = (uint64_t)&unk_253D0A3B0;
    v4 = (caulk::alloc::global_page_cache *)caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::skiplist((uint64_t)&unk_253D020A0);
    qword_253D021F8 = 0;
    caulk::alloc::global_page_cache::instance(v4);
    qword_253D021F8 = (uint64_t)&unk_253D0A3B0;
    caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::skiplist((uint64_t)&unk_253D02200);
    caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::skiplist((uint64_t)&qword_253D022C8[11]);
    qword_253D02440 = 0;
    v13 = &caulk::inplace_function_detail::vtable<void,caulk::concurrent::details::skiplist_node<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>::layout_kv const&>::empty;
    v14[0] = &unk_253D021F0;
    v15 = _ZN5caulk16inplace_functionIFvRKNS_10concurrent7details13skiplist_nodeImPNS_5alloc15chunk_allocatorINS4_17global_page_cacheENS4_16bitmap_allocatorENS4_18embed_block_memoryELm16384EJLm256ELm6EEE9node_implINS4_14tree_allocatorIS9_E11node_headerES8_EEE9layout_kvEELm32ELm8ENS_23inplace_function_detail6vtableEE16k_wrapper_vtableIZNSC_C1EvEUlRKT_E_EE;
    _ZZN5caulk23inplace_function_detail6vtableIvJRKNS_10concurrent7details13skiplist_nodeImPNS_5alloc15chunk_allocatorINS5_17global_page_cacheENS5_16bitmap_allocatorENS5_18embed_block_memoryELm16384EJLm256ELm6EEE9node_implINS5_14tree_allocatorISA_E11node_headerES9_EEE9layout_kvEEEC1IZNSD_C1EvEUlRKT_E_EENS0_7wrapperISN_EEENUlPvST_E0_8__invokeEST_ST_(v16, v14);
    (*(void (**)(_QWORD *))(qword_253D022C0 + 24))(qword_253D022C8);
    v5 = (uint64_t)v15;
    v15 = (uint64_t (**)())&caulk::inplace_function_detail::vtable<void,caulk::concurrent::details::skiplist_node<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>::layout_kv const&>::empty;
    qword_253D022C0 = v5;
    (*(void (**)(_QWORD *, _QWORD *))(v5 + 16))(qword_253D022C8, v16);
    ((void (*)(_QWORD *))v15[3])(v16);
    caulk::inplace_function_detail::vtable<void,caulk::concurrent::details::skiplist_node<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>::layout_kv const&>::vtable(void)::{lambda(void *)#1}::__invoke(v14);
    v12[0] = &unk_253D021F0;
    v15 = caulk::inplace_function<void ()(void),32ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>;
    caulk::inplace_function_detail::vtable<void>::vtable<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>(caulk::inplace_function_detail::wrapper<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>)::{lambda(void *,void *)#2}::__invoke(v16, v12);
    caulk::inplace_function<void ()(void),32ul,8ul,caulk::inplace_function_detail::vtable>::operator=(&qword_253D022C8[40], (uint64_t *)&v15);
    ((void (*)(_QWORD *))v15[3])(v16);
    v6 = (caulk::alloc::global_page_cache *)((uint64_t (*)(_QWORD *))caulk::inplace_function_detail::vtable<void>::vtable(void)::{lambda(void *)#2}::__invoke)(v12);
    qword_253D02458 = 0;
    caulk::alloc::global_page_cache::instance(v6);
    qword_253D02458 = (uint64_t)&unk_253D0A3B0;
    caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::skiplist((uint64_t)&unk_253D02460);
    caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::skiplist((uint64_t)&qword_253D02528[11]);
    qword_253D026A0 = 0;
    v13 = &caulk::inplace_function_detail::vtable<void,caulk::concurrent::details::skiplist_node<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>::layout_kv const&>::empty;
    v14[0] = &unk_253D02450;
    v15 = _ZN5caulk16inplace_functionIFvRKNS_10concurrent7details13skiplist_nodeImPNS_5alloc15chunk_allocatorINS4_17global_page_cacheENS4_16bitmap_allocatorENS4_18embed_block_memoryELm16384EJLm16ELm6EEE9node_implINS4_14tree_allocatorIS9_E11node_headerES8_EEE9layout_kvEELm32ELm8ENS_23inplace_function_detail6vtableEE16k_wrapper_vtableIZNSC_C1EvEUlRKT_E_EE;
    _ZZN5caulk23inplace_function_detail6vtableIvJRKNS_10concurrent7details13skiplist_nodeImPNS_5alloc15chunk_allocatorINS5_17global_page_cacheENS5_16bitmap_allocatorENS5_18embed_block_memoryELm16384EJLm16ELm6EEE9node_implINS5_14tree_allocatorISA_E11node_headerES9_EEE9layout_kvEEEC1IZNSD_C1EvEUlRKT_E_EENS0_7wrapperISN_EEENUlPvST_E0_8__invokeEST_ST_(v16, v14);
    (*(void (**)(_QWORD *))(qword_253D02520 + 24))(qword_253D02528);
    v7 = (uint64_t)v15;
    v15 = (uint64_t (**)())&caulk::inplace_function_detail::vtable<void,caulk::concurrent::details::skiplist_node<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>::layout_kv const&>::empty;
    qword_253D02520 = v7;
    (*(void (**)(_QWORD *, _QWORD *))(v7 + 16))(qword_253D02528, v16);
    ((void (*)(_QWORD *))v15[3])(v16);
    v12[0] = &unk_253D02450;
    v15 = caulk::inplace_function<void ()(void),32ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>;
    caulk::inplace_function_detail::vtable<void>::vtable<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>(caulk::inplace_function_detail::wrapper<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>)::{lambda(void *,void *)#2}::__invoke(v16, v12);
    caulk::inplace_function<void ()(void),32ul,8ul,caulk::inplace_function_detail::vtable>::operator=(&qword_253D02528[40], (uint64_t *)&v15);
    ((void (*)(_QWORD *))v15[3])(v16);
    qword_253D02080 = (uint64_t)&off_24BF2CBD0;
    v8 = operator new();
    *(_QWORD *)v8 = &qword_253D02080;
    *(_OWORD *)(v8 + 24) = 0u;
    *(_OWORD *)(v8 + 40) = 0u;
    *(_OWORD *)(v8 + 56) = 0u;
    *(_OWORD *)(v8 + 72) = 0u;
    *(_OWORD *)(v8 + 8) = 0u;
    *(_OWORD *)(v8 + 88) = 0u;
    *(_OWORD *)(v8 + 136) = 0u;
    *(_OWORD *)(v8 + 120) = 0u;
    *(_OWORD *)(v8 + 152) = 0u;
    *(_OWORD *)(v8 + 168) = 0u;
    *(_OWORD *)(v8 + 184) = 0u;
    *(_QWORD *)(v8 + 200) = 0;
    *(_QWORD *)(v8 + 24) = caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_size_for_ptr;
    *(_QWORD *)(v8 + 32) = caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_plus::zone_plus(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>&,char const*)::{lambda(_malloc_zone_t *,unsigned long)#1}::__invoke;
    *(_QWORD *)(v8 + 40) = caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_plus::zone_plus(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>&,char const*)::{lambda(_malloc_zone_t *,unsigned long,unsigned long)#1}::__invoke;
    *(_QWORD *)(v8 + 48) = caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_plus::zone_plus(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>&,char const*)::{lambda(_malloc_zone_t *,unsigned long)#2}::__invoke;
    *(_QWORD *)(v8 + 56) = caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_plus::zone_plus(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>&,char const*)::{lambda(_malloc_zone_t *,void *)#1}::__invoke;
    *(_QWORD *)(v8 + 64) = caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_plus::zone_plus(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>&,char const*)::{lambda(_malloc_zone_t *,void *,unsigned long)#1}::__invoke;
    *(_QWORD *)(v8 + 136) = caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_pressure_relief;
    *(_DWORD *)(v8 + 112) = 8;
    *(_QWORD *)(v8 + 104) = caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::introspection_funcs(void)::funcs;
    *(_QWORD *)(v8 + 80) = "caulk::realtime_safe_resource";
    malloc_zone_register((malloc_zone_t *)(v8 + 8));
    qword_253D026B0 = v8;
    *(_QWORD *)algn_253D026B8 = 0;
    qword_253D026C0 = *MEMORY[0x24BDAED40];
    byte_253D026D0 = 1;
    caulk::alloc::global_page_cache::instance(v9);
    caulk::alloc::page_cache_monitor::enable_preallocation((os_unfair_lock_t *)qword_253D0A410, (uint64_t *)8);
    caulk::alloc::registerAllocatorStateDump((caulk::alloc *)&qword_253D02080, (caulk::alloc::memory_resource *)"com.apple.caulk.alloc.rtdump", "caulk_rt_alloc.", v10);
    caulk::alloc::realtime_safe_resource = (uint64_t)&qword_253D02080;
    caulk::g_realtime_safe_resource = (uint64_t)&qword_253D02070;
  }
  return os_unfair_recursive_lock_unlock();
}

void sub_2065C641C(_Unwind_Exception *a1)
{
  os_unfair_recursive_lock_unlock();
  _Unwind_Resume(a1);
}

void ___ZN5caulk5allocL26registerAllocatorStateDumpEPNS0_15memory_resourceEPKcS4__block_invoke(uint64_t a1)
{
  size_t v2;
  std::string *v3;
  __int128 v4;
  pid_t v5;
  std::string *v6;
  std::string::size_type size;
  std::string *v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  std::string::size_type *v12;
  std::string::size_type v13;
  std::string::size_type v14;
  std::ios_base *v15;
  caulk::alloc::base_allocator *v16;
  NSObject *v17;
  void **v18;
  std::string v19;
  void *__p[2];
  int64_t v21;
  std::string v22;
  uint64_t v23[20];
  std::string v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  std::string::basic_string[abi:ne180100]<0>(&v24, "/tmp/");
  v2 = strlen(*(const char **)(a1 + 32));
  v3 = std::string::append(&v24, *(const std::string::value_type **)(a1 + 32), v2);
  v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  v22.__r_.__value_.__r.__words[2] = v3->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v4;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  v5 = getpid();
  std::to_string(&v19, v5);
  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v6 = &v19;
  else
    v6 = (std::string *)v19.__r_.__value_.__r.__words[0];
  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v19.__r_.__value_.__r.__words[2]);
  else
    size = v19.__r_.__value_.__l.__size_;
  v8 = std::string::append(&v22, (const std::string::value_type *)v6, size);
  v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v21 = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v19.__r_.__value_.__l.__data_);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v24.__r_.__value_.__l.__data_);
  v10 = MEMORY[0x24BEDB840];
  v11 = MEMORY[0x24BEDB840] + 64;
  v12 = (std::string::size_type *)MEMORY[0x24BEDB7E8];
  v13 = *(_QWORD *)(MEMORY[0x24BEDB7E8] + 8);
  v14 = *(_QWORD *)(MEMORY[0x24BEDB7E8] + 16);
  v23[0] = MEMORY[0x24BEDB840] + 64;
  v22.__r_.__value_.__r.__words[0] = v13;
  *(std::string::size_type *)((char *)v22.__r_.__value_.__r.__words + *(_QWORD *)(v13 - 24)) = v14;
  v15 = (std::ios_base *)((char *)&v22 + *(_QWORD *)(v22.__r_.__value_.__r.__words[0] - 24));
  std::ios_base::init(v15, &v22.__r_.__value_.__r.__words[1]);
  v15[1].__vftable = 0;
  v15[1].__fmtflags_ = -1;
  v22.__r_.__value_.__r.__words[0] = v10 + 24;
  v23[0] = v11;
  MEMORY[0x20BCF9A94](&v22.__r_.__value_.__r.__words[1]);
  if (!std::filebuf::open())
    std::ios_base::clear((std::ios_base *)((char *)&v22 + *(_QWORD *)(v22.__r_.__value_.__r.__words[0] - 24)), *(_DWORD *)((char *)&v22 + *(_QWORD *)(v22.__r_.__value_.__r.__words[0] - 24) + 32) | 4);
  v16 = (caulk::alloc::base_allocator *)(*(uint64_t (**)(_QWORD, std::string *, _QWORD))(**(_QWORD **)(a1 + 40)
                                                                                                 + 48))(*(_QWORD *)(a1 + 40), &v22, 0);
  caulk::alloc::base_allocator::log(v16);
  v17 = caulk::alloc::base_allocator::log(void)::global;
  if (os_log_type_enabled((os_log_t)caulk::alloc::base_allocator::log(void)::global, OS_LOG_TYPE_DEFAULT))
  {
    v18 = __p;
    if (v21 < 0)
      v18 = (void **)__p[0];
    LODWORD(v24.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v24.__r_.__value_.__r.__words + 4) = (std::string::size_type)v18;
    _os_log_impl(&dword_2065BE000, v17, OS_LOG_TYPE_DEFAULT, "Wrote %s", (uint8_t *)&v24, 0xCu);
  }
  v22.__r_.__value_.__r.__words[0] = *v12;
  *(std::string::size_type *)((char *)v22.__r_.__value_.__r.__words + *(_QWORD *)(v22.__r_.__value_.__r.__words[0] - 24)) = v12[3];
  MEMORY[0x20BCF9AA0](&v22.__r_.__value_.__r.__words[1]);
  std::ostream::~ostream();
  MEMORY[0x20BCF9BA8](v23);
  if (SHIBYTE(v21) < 0)
    operator delete(__p[0]);
}

void sub_2065C6760(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  std::ofstream::~ofstream(&a23);
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

_QWORD *std::ofstream::~ofstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x24BEDB7E8];
  v3 = *MEMORY[0x24BEDB7E8];
  *a1 = *MEMORY[0x24BEDB7E8];
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  MEMORY[0x20BCF9AA0](a1 + 1);
  std::ostream::~ostream();
  MEMORY[0x20BCF9BA8](a1 + 52);
  return a1;
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_pressure_relief(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 - 8) + 72))(*(_QWORD *)(a1 - 8));
}

uint64_t caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::~resource()
{
  caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::~tree_allocator((uint64_t)&unk_253D02450);
  caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::~tree_allocator((uint64_t)&unk_253D021F0);
  return caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::~tracking_allocator((uint64_t)&qword_253D02090);
}

uint64_t caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::~tree_allocator(uint64_t a1)
{
  uint64_t v2;

  v2 = a1 + 304;
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::clear(a1 + 304);
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::clear(a1 + 16);
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::clear(v2);
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::~node_allocator(a1 + 464);
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::clear(a1 + 16);
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::~node_allocator(a1 + 176);
  return a1;
}

uint64_t caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::~tree_allocator(uint64_t a1)
{
  uint64_t v2;

  v2 = a1 + 304;
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::clear(a1 + 304);
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::clear(a1 + 16);
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::clear(v2);
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::~node_allocator(a1 + 464);
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::clear(a1 + 16);
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::~node_allocator(a1 + 176);
  return a1;
}

uint64_t caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::~tracking_allocator(uint64_t a1)
{
  unsigned __int128 *v2;
  unint64_t i;
  unint64_t v4;
  char v5;

  v2 = (unsigned __int128 *)(a1 + 272);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 272));
  for (i = atomic_load((unint64_t *)(a1 + 56)); ; i = atomic_load((unint64_t *)(v4 + 40)))
  {
    v4 = i & 0xFFFFFFFFFFFFFFFCLL;
    if (a1 + 216 == (i & 0xFFFFFFFFFFFFFFFCLL))
      break;
    if (*(_BYTE *)(v4 + 26) != 2)
    {
      v5 = atomic_load((unint64_t *)(v4 + 40));
      if ((v5 & 1) == 0)
        caulk::alloc::details::caching_page_allocator_base::deallocate(*(uint64_t **)a1, *(caulk::mach::vm_block **)(v4 + 16), *(_QWORD *)v4);
    }
  }
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal(v2);
  caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::clear(a1 + 16);
  caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::clear(a1 + 16);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::~node_allocator((uint64_t)v2);
  return a1;
}

void sub_2065C6A1C(void *a1)
{
  unsigned __int128 *v1;

  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal(v1);
  __clang_call_terminate(a1);
}

unsigned __int128 *caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::clear(uint64_t a1)
{
  unsigned __int128 *v2;
  unint64_t i;
  unint64_t v4;
  char v5;

  v2 = (unsigned __int128 *)(a1 + 256);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 256));
  for (i = atomic_load((unint64_t *)(a1 + 40)); ; i = atomic_load((unint64_t *)(v4 + 40)))
  {
    v4 = i & 0xFFFFFFFFFFFFFFFCLL;
    if (a1 + 200 == (i & 0xFFFFFFFFFFFFFFFCLL))
      break;
    if (*(_BYTE *)(v4 + 26) != 2)
    {
      v5 = atomic_load((unint64_t *)(v4 + 40));
      if ((v5 & 1) == 0)
        caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::remove(a1, *(_QWORD *)(v4 + 16));
    }
  }
  return caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal(v2);
}

uint64_t caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::~node_allocator(uint64_t a1)
{
  unsigned __int128 v2;

  do
    v2 = __ldaxp((unsigned __int128 *)a1);
  while (__stlxp(v2, (unsigned __int128 *)a1));
  if ((_QWORD)v2)
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::free_node_chain_now((caulk::alloc::base_allocator *)a1, v2);
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 24))(a1 + 40);
  std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](a1 + 16);
  return a1;
}

uint64_t std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

void caulk::alloc::base_allocator::bad_dealloc(caulk::alloc::base_allocator *this)
{
  std::runtime_error *exception;
  const char *v2;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  caulk::alloc::alloc_error::alloc_error(exception, v2);
}

void sub_2065C6B9C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::runtime_error *caulk::alloc::alloc_error::alloc_error(std::runtime_error *this, const char *a2)
{
  std::runtime_error *result;

  result = std::runtime_error::runtime_error(this, "deallocate() called for unowned block");
  result->__vftable = (std::runtime_error_vtbl *)&off_24BF2D878;
  return result;
}

void caulk::alloc::alloc_error::~alloc_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x20BCF9C08);
}

unsigned __int128 *caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::clear(uint64_t a1)
{
  unsigned __int128 *v2;
  unint64_t i;
  unint64_t v4;
  char v5;

  v2 = (unsigned __int128 *)(a1 + 160);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 160));
  for (i = atomic_load((unint64_t *)(a1 + 32)); ; i = atomic_load((unint64_t *)(v4 + 32)))
  {
    v4 = i & 0xFFFFFFFFFFFFFFFCLL;
    if (a1 + 112 == (i & 0xFFFFFFFFFFFFFFFCLL))
      break;
    if (*(_BYTE *)(v4 + 18) != 2)
    {
      v5 = atomic_load((unint64_t *)(v4 + 32));
      if ((v5 & 1) == 0)
        caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove(a1, *(_QWORD *)v4);
    }
  }
  return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v2);
}

uint64_t caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::~node_allocator(uint64_t a1)
{
  unsigned __int128 v2;

  do
    v2 = __ldaxp((unsigned __int128 *)a1);
  while (__stlxp(v2, (unsigned __int128 *)a1));
  if ((_QWORD)v2)
    caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::free_node_chain(a1, v2);
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::perform_deferred_deletions<true,(BOOL *)0>((caulk::alloc::base_allocator *)a1);
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 72) + 24))(a1 + 80);
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 24))(a1 + 40);
  std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](a1 + 16);
  return a1;
}

uint64_t caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::free_node_chain(uint64_t result, unint64_t a2)
{
  unsigned __int128 *v2;
  unsigned __int128 v3;
  unint64_t v4;
  uint64_t v5;
  unsigned __int128 v6;
  int v7;
  unsigned __int128 v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v2 = (unsigned __int128 *)(result + 112);
  do
    v3 = __ldaxp(v2);
  while (__stlxp(v3, v2));
  atomic_store(v3, (unint64_t *)(a2 + 40));
  do
  {
    while (1)
    {
      v6 = __ldaxp(v2);
      v5 = *((_QWORD *)&v6 + 1);
      v4 = v6;
      v7 = (_QWORD)v6 != (_QWORD)v3;
      if (*((_QWORD *)&v6 + 1) != *((_QWORD *)&v3 + 1))
        ++v7;
      if (!v7)
        break;
      if (!__stlxp(v6, v2))
        goto LABEL_10;
    }
  }
  while (__stlxp(__PAIR128__(*((_QWORD *)&v3 + 1) + 1, a2), v2));
LABEL_10:
  if ((_QWORD)v6 != (_QWORD)v3 || *((_QWORD *)&v6 + 1) != *((_QWORD *)&v3 + 1))
  {
    do
    {
      atomic_store(v4, (unint64_t *)(a2 + 40));
      do
      {
        while (1)
        {
          v9 = __ldaxp(v2);
          v10 = (_QWORD)v9 != v4;
          if (*((_QWORD *)&v9 + 1) != v5)
            ++v10;
          if (!v10)
            break;
          if (!__stlxp(v9, v2))
            goto LABEL_21;
        }
      }
      while (__stlxp(__PAIR128__(v5 + 1, a2), v2));
LABEL_21:
      v11 = *((_QWORD *)&v9 + 1) ^ v5;
      v12 = v9 ^ v4;
      v5 = v9 >> 64;
      v4 = v9;
    }
    while (v12 | v11);
  }
  v13 = *(_QWORD *)(result + 72);
  if (*(_BYTE *)(v13 + 32))
    return (*(uint64_t (**)(uint64_t))v13)(result + 80);
  return result;
}

caulk::alloc::base_allocator *caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::perform_deferred_deletions<true,(BOOL *)0>(caulk::alloc::base_allocator *result)
{
  caulk::alloc::base_allocator *v1;
  unsigned __int128 *v2;
  char *v3;
  uint64_t v4;
  unsigned __int128 v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unsigned __int128 v9;
  int v10;
  unint64_t v12;
  uint64_t v13;

  v1 = result;
  v2 = (unsigned __int128 *)((char *)result + 112);
  v3 = (char *)result + 40;
  while (1)
  {
    do
    {
      v5 = __ldaxp(v2);
      v4 = *((_QWORD *)&v5 + 1);
    }
    while (__stlxp(v5, v2));
    if (!(_QWORD)v5)
      return result;
    v6 = v5;
    v7 = v5;
    while (1)
    {
      v8 = atomic_load((unint64_t *)(v6 + 40));
      do
      {
        while (1)
        {
          v9 = __ldaxp(v2);
          v10 = (_QWORD)v9 != v7;
          if (*((_QWORD *)&v9 + 1) != v4)
            ++v10;
          if (!v10)
            break;
          if (!__stlxp(v9, v2))
            goto LABEL_12;
        }
      }
      while (__stlxp(__PAIR128__(v4 + 1, v8), v2));
LABEL_12:
      if ((_QWORD)v9 == v7 && *((_QWORD *)&v9 + 1) == v4)
        break;
      v4 = v9 >> 64;
      v6 = v9;
      v7 = v9;
      if (!(_QWORD)v9)
        return result;
    }
    do
    {
      v12 = atomic_load((unint64_t *)(v6 + 24));
      v13 = *((_QWORD *)v1 + 4);
      if (*(_BYTE *)(v13 + 32))
      {
        if (!*(_BYTE *)(v6 + 18))
          (*(void (**)(char *, uint64_t))v13)(v3, v6);
      }
      result = caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>::deallocate(*((caulk::alloc::base_allocator **)v1 + 2), (unint64_t *)v6, *(_QWORD *)&caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::node_sizes[8 * *(unsigned __int8 *)(v6 + 16) - 8]);
      v6 = v12;
    }
    while (v12);
  }
}

caulk::alloc::base_allocator *caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>::deallocate(caulk::alloc::base_allocator *result, unint64_t *a2, unint64_t a3)
{
  uint64_t v3;
  unsigned __int128 *v4;
  unsigned __int128 v5;
  unint64_t v6;
  uint64_t v7;
  unsigned __int128 v8;
  int v9;
  unsigned __int128 v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;

  v3 = 0;
  while (*(_QWORD *)&caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::node_sizes[8 * v3] < a3)
  {
    if (++v3 == 5)
      caulk::alloc::base_allocator::bad_dealloc(result);
  }
  v4 = (unsigned __int128 *)((char *)result + 32 * v3 + 64);
  do
    v5 = __ldaxp(v4);
  while (__stlxp(v5, v4));
  atomic_store(v5, a2);
  do
  {
    while (1)
    {
      v8 = __ldaxp(v4);
      v7 = *((_QWORD *)&v8 + 1);
      v6 = v8;
      v9 = (_QWORD)v8 != (_QWORD)v5;
      if (*((_QWORD *)&v8 + 1) != *((_QWORD *)&v5 + 1))
        ++v9;
      if (!v9)
        break;
      if (!__stlxp(v8, v4))
        goto LABEL_14;
    }
  }
  while (__stlxp(__PAIR128__(*((_QWORD *)&v5 + 1) + 1, (unint64_t)a2), v4));
LABEL_14:
  if ((_QWORD)v8 != (_QWORD)v5 || *((_QWORD *)&v8 + 1) != *((_QWORD *)&v5 + 1))
  {
    do
    {
      atomic_store(v6, a2);
      do
      {
        while (1)
        {
          v11 = __ldaxp(v4);
          v12 = (_QWORD)v11 != v6;
          if (*((_QWORD *)&v11 + 1) != v7)
            ++v12;
          if (!v12)
            break;
          if (!__stlxp(v11, v4))
            goto LABEL_25;
        }
      }
      while (__stlxp(__PAIR128__(v7 + 1, (unint64_t)a2), v4));
LABEL_25:
      v13 = *((_QWORD *)&v11 + 1) ^ v7;
      v14 = v11 ^ v6;
      v7 = v11 >> 64;
      v6 = v11;
    }
    while (v14 | v13);
  }
  v15 = (unint64_t *)((char *)result + 32 * v3 + 80);
  do
    v16 = __ldaxr(v15);
  while (__stlxr(v16 + 1, v15));
  return result;
}

unsigned __int128 *caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(unsigned __int128 *result)
{
  unint64_t v1;
  int v2;
  unsigned __int128 v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;
  unsigned __int128 v9;
  int v10;

  do
  {
    v3 = __ldaxp(result);
    v2 = DWORD2(v3);
    v1 = v3;
  }
  while (__stlxp(v3, result));
  v4 = HIDWORD(*((_QWORD *)&v3 + 1));
  while (1)
  {
    v5 = v2 - 1;
    v6 = v2 - 1;
    v7 = v2 <= 1 ? 0 : v1;
    v8 = v2 | (unint64_t)(v4 << 32);
    do
    {
      while (1)
      {
        v9 = __ldaxp(result);
        v2 = DWORD2(v9);
        v10 = (_QWORD)v9 != v1;
        if (*((_QWORD *)&v9 + 1) != v8)
          ++v10;
        if (!v10)
          break;
        if (!__stlxp(v9, result))
          goto LABEL_13;
      }
    }
    while (__stlxp(__PAIR128__(v6, v7), result));
LABEL_13:
    if (!((unint64_t)v9 ^ v1 | *((_QWORD *)&v9 + 1) ^ v8))
      break;
    v4 = HIDWORD(*((_QWORD *)&v9 + 1));
    v1 = v9;
  }
  if (!v5)
  {
    if (v1)
      return (unsigned __int128 *)caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::free_node_chain((uint64_t)result, v1);
  }
  return result;
}

unsigned __int128 *caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove(uint64_t a1, uint64_t a2)
{
  unsigned __int128 *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;

  v4 = (unsigned __int128 *)(a1 + 160);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 160));
  v16 = a2;
  v5 = -1;
  v6 = 48;
  do
  {
    v7 = atomic_load((unint64_t *)(a1 + v6));
    ++v5;
    v6 += 16;
  }
  while (*(_BYTE *)((v7 & 0xFFFFFFFFFFFFFFFCLL) + 18) != 2);
  v8 = a1;
  if (v5)
  {
    v8 = a1;
    do
      v8 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_right<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_lt &>(a1, v5--, v8, &v16);
    while (v5);
  }
  v9 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_right<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_lt &>(a1, 0, v8, &v16);
  if (*v10 == a2)
  {
    v11 = (unint64_t)v10;
    v12 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::try_flag_node(a1, 0, v9, (unint64_t)v10);
    v14 = v13;
    if (!(_DWORD)v13)
      caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(a1, 0, v12, v11);
    if ((v14 & 0xFF00000000) != 0)
    {
      v16 = a2;
      caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>(a1, &v16, 0);
    }
  }
  return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v4);
}

unint64_t caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>(uint64_t a1, _QWORD *a2, unint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;

  v6 = -1;
  v7 = 48;
  do
  {
    do
    {
      ++v6;
      v8 = atomic_load((unint64_t *)(a1 + v7));
      v7 += 16;
    }
    while (v6 < a3);
  }
  while (*(_BYTE *)((v8 & 0xFFFFFFFFFFFFFFFCLL) + 18) != 2);
  v9 = a1;
  if (v6 > a3)
  {
    v9 = a1;
    do
      v9 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_right<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le &>(a1, v6--, v9, a2);
    while (v6 > a3);
  }
  return caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_right<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le &>(a1, a3, v9, a2);
}

unint64_t caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_right<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le &>(uint64_t a1, uint64_t a2, unint64_t a3, _QWORD *a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char v10;
  int v11;
  unint64_t v12;

  v4 = a3;
  v5 = atomic_load((unint64_t *)(a3 + 16 * a2 + 32));
  v6 = v5 & 0xFFFFFFFFFFFFFFFCLL;
  if (*a4 >= *(_QWORD *)(v5 & 0xFFFFFFFFFFFFFFFCLL))
  {
    do
    {
      v10 = atomic_load((unint64_t *)(v6 + 32));
      if ((v10 & 1) != 0)
      {
        v4 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::try_flag_node(a1, a2, v4, v6);
        if (!v11)
          caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(a1, a2, v4, v6);
      }
      else
      {
        v4 = v6;
      }
      v12 = atomic_load((unint64_t *)(v4 + 16 * a2 + 32));
      v6 = v12 & 0xFFFFFFFFFFFFFFFCLL;
    }
    while (*a4 >= *(_QWORD *)(v12 & 0xFFFFFFFFFFFFFFFCLL));
  }
  return v4;
}

unint64_t caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::try_flag_node(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  char v12;
  char v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char v17;
  int v18;

  v8 = a4 | 2;
  do
  {
    v9 = (unint64_t *)(a3 + 16 * a2 + 32);
    v10 = atomic_load(v9);
    if (v10 == v8)
      break;
    v11 = __ldaxr(v9);
    if (v11 == a4)
    {
      if (!__stlxr(v8, v9))
        return a3;
    }
    else
    {
      __clrex();
    }
    if (v11 == v8)
      break;
    v12 = atomic_load(v9);
    if ((v12 & 1) != 0)
    {
      do
      {
        a3 = atomic_load((unint64_t *)(a3 + 16 * a2 + 40));
        v13 = atomic_load((unint64_t *)(a3 + 16 * a2 + 32));
      }
      while ((v13 & 1) != 0);
    }
    v14 = *(_QWORD *)a4;
    while (1)
    {
      v15 = atomic_load((unint64_t *)(a3 + 16 * a2 + 32));
      v16 = v15 & 0xFFFFFFFFFFFFFFFCLL;
      if (v14 <= *(_QWORD *)(v15 & 0xFFFFFFFFFFFFFFFCLL))
        break;
      v17 = atomic_load((unint64_t *)(v16 + 32));
      if ((v17 & 1) != 0)
      {
        a3 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::try_flag_node(a1, a2, a3, v16);
        if (!v18)
          caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(a1, a2, a3, v16);
      }
      else
      {
        a3 = v16;
      }
    }
  }
  while (v16 == a4);
  return a3;
}

uint64_t caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(uint64_t result, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  char v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unsigned __int8 *v17;
  int v18;
  unsigned __int128 *v19;
  unsigned __int128 v20;
  unint64_t v21;
  uint64_t v22;
  unsigned __int128 v23;
  int v24;
  unsigned __int128 v26;
  int v27;
  uint64_t v28;
  uint64_t v29;

  v7 = result;
  v8 = a4 + 16 * a2;
  v9 = (unint64_t *)(v8 + 32);
  atomic_store(a3, (unint64_t *)(v8 + 40));
  while (1)
  {
    v10 = atomic_load(v9);
    if ((v10 & 1) != 0)
      break;
    v11 = atomic_load(v9);
    v12 = v11 & 0xFFFFFFFFFFFFFFFCLL;
    v13 = __ldaxr(v9);
    if (v13 == v12)
    {
      __stlxr(v12 | 1, v9);
      if ((v13 & 2) != 0)
LABEL_7:
        result = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(v7, a2, a4, v13 & 0xFFFFFFFFFFFFFFFCLL);
    }
    else
    {
      __clrex();
      if ((v13 & 2) != 0)
        goto LABEL_7;
    }
  }
  v14 = atomic_load(v9);
  v15 = (unint64_t *)(a3 + 16 * a2 + 32);
  v16 = __ldaxr(v15);
  if (v16 == (a4 | 2))
  {
    if (!__stlxr(v14 & 0xFFFFFFFFFFFFFFFCLL, v15))
    {
      v17 = (unsigned __int8 *)(a4 + 19);
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (v18 == 1)
      {
        v19 = (unsigned __int128 *)(v7 + 160);
        do
          v20 = __ldaxp(v19);
        while (__stlxp(v20, v19));
        atomic_store(v20, (unint64_t *)(a4 + 24));
        do
        {
          while (1)
          {
            v23 = __ldaxp(v19);
            v22 = *((_QWORD *)&v23 + 1);
            v21 = v23;
            v24 = (_QWORD)v23 != (_QWORD)v20;
            if (*((_QWORD *)&v23 + 1) != *((_QWORD *)&v20 + 1))
              ++v24;
            if (!v24)
              break;
            if (!__stlxp(v23, v19))
              goto LABEL_22;
          }
        }
        while (__stlxp(__PAIR128__(DWORD2(v20), a4), v19));
LABEL_22:
        if ((_QWORD)v23 != (_QWORD)v20 || *((_QWORD *)&v23 + 1) != *((_QWORD *)&v20 + 1))
        {
          do
          {
            atomic_store(v21, (unint64_t *)(a4 + 24));
            do
            {
              while (1)
              {
                v26 = __ldaxp(v19);
                v27 = (_QWORD)v26 != v21;
                if (*((_QWORD *)&v26 + 1) != v22)
                  ++v27;
                if (!v27)
                  break;
                if (!__stlxp(v26, v19))
                  goto LABEL_33;
              }
            }
            while (__stlxp(__PAIR128__(v22, a4), v19));
LABEL_33:
            v28 = *((_QWORD *)&v26 + 1) ^ v22;
            v29 = v26 ^ v21;
            v22 = *((_QWORD *)&v26 + 1);
            v21 = v26;
          }
          while (v29 | v28);
        }
      }
    }
  }
  else
  {
    __clrex();
  }
  return result;
}

unint64_t caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_right<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_lt &>(uint64_t a1, uint64_t a2, unint64_t a3, _QWORD *a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char v10;
  int v11;
  unint64_t v12;

  v4 = a3;
  v5 = atomic_load((unint64_t *)(a3 + 16 * a2 + 32));
  v6 = v5 & 0xFFFFFFFFFFFFFFFCLL;
  if (*a4 > *(_QWORD *)(v5 & 0xFFFFFFFFFFFFFFFCLL))
  {
    do
    {
      v10 = atomic_load((unint64_t *)(v6 + 32));
      if ((v10 & 1) != 0)
      {
        v4 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::try_flag_node(a1, a2, v4, v6);
        if (!v11)
          caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(a1, a2, v4, v6);
      }
      else
      {
        v4 = v6;
      }
      v12 = atomic_load((unint64_t *)(v4 + 16 * a2 + 32));
      v6 = v12 & 0xFFFFFFFFFFFFFFFCLL;
    }
    while (*a4 > *(_QWORD *)(v12 & 0xFFFFFFFFFFFFFFFCLL));
  }
  return v4;
}

unsigned __int128 *caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::clear(uint64_t a1)
{
  unsigned __int128 *v2;
  unint64_t i;
  unint64_t v4;
  char v5;

  v2 = (unsigned __int128 *)(a1 + 160);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 160));
  for (i = atomic_load((unint64_t *)(a1 + 32)); ; i = atomic_load((unint64_t *)(v4 + 32)))
  {
    v4 = i & 0xFFFFFFFFFFFFFFFCLL;
    if (a1 + 112 == (i & 0xFFFFFFFFFFFFFFFCLL))
      break;
    if (*(_BYTE *)(v4 + 18) != 2)
    {
      v5 = atomic_load((unint64_t *)(v4 + 32));
      if ((v5 & 1) == 0)
        caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove(a1, *(_QWORD *)v4);
    }
  }
  return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v2);
}

uint64_t caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::~node_allocator(uint64_t a1)
{
  unsigned __int128 v2;

  do
    v2 = __ldaxp((unsigned __int128 *)a1);
  while (__stlxp(v2, (unsigned __int128 *)a1));
  if ((_QWORD)v2)
    caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::free_node_chain(a1, v2);
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::perform_deferred_deletions<true,(BOOL *)0>((caulk::alloc::base_allocator *)a1);
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 72) + 24))(a1 + 80);
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 24))(a1 + 40);
  std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](a1 + 16);
  return a1;
}

unsigned __int128 *caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove(uint64_t a1, uint64_t a2)
{
  unsigned __int128 *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;

  v4 = (unsigned __int128 *)(a1 + 160);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 160));
  v16 = a2;
  v5 = -1;
  v6 = 48;
  do
  {
    v7 = atomic_load((unint64_t *)(a1 + v6));
    ++v5;
    v6 += 16;
  }
  while (*(_BYTE *)((v7 & 0xFFFFFFFFFFFFFFFCLL) + 18) != 2);
  v8 = a1;
  if (v5)
  {
    v8 = a1;
    do
      v8 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_right<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_lt &>(a1, v5--, v8, &v16);
    while (v5);
  }
  v9 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_right<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_lt &>(a1, 0, v8, &v16);
  if (*v10 == a2)
  {
    v11 = (unint64_t)v10;
    v12 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::try_flag_node(a1, 0, v9, (unint64_t)v10);
    v14 = v13;
    if (!(_DWORD)v13)
      caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(a1, 0, v12, v11);
    if ((v14 & 0xFF00000000) != 0)
    {
      v16 = a2;
      caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>(a1, &v16, 0);
    }
  }
  return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v4);
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  _BYTE v26[24];
  _BYTE *v27;
  _QWORD v28[3];
  _QWORD *v29;
  int v30;
  _BYTE v31[24];
  _BYTE *v32;
  _BYTE v33[24];
  _BYTE *v34;
  char v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v28[0] = &off_24BF2D048;
  v28[1] = a5;
  v28[2] = a1;
  v29 = v28;
  v11 = operator new(0x20uLL);
  *v11 = &off_24BF2CFF0;
  v11[1] = a6;
  *((_DWORD *)v11 + 4) = a1;
  v11[3] = a2;
  v27 = v11;
  v30 = a3;
  std::__function::__value_func<void * ()(unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v31, (uint64_t)v28);
  std::__function::__value_func<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v33, (uint64_t)v26);
  v35 = 0;
  v12 = v27;
  if (v27 == v26)
  {
    v13 = 4;
    v12 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_6;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_6:
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_11;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_11:
  v24 = 208;
  v25 = a4 - 8;
  if (!v32)
    std::__throw_bad_function_call[abi:ne180100]();
  v16 = (_QWORD *)(*(uint64_t (**)(_BYTE *, uint64_t *, uint64_t *))(*(_QWORD *)v32 + 48))(v32, &v25, &v24);
  if (*v16)
    v17 = *v16 + 16;
  else
    v17 = 0;
  v24 = 1568;
  v25 = v17;
  if (!v32)
    std::__throw_bad_function_call[abi:ne180100]();
  v18 = (*(uint64_t (**)(_BYTE *, uint64_t *, uint64_t *))(*(_QWORD *)v32 + 48))(v32, &v25, &v24);
  caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,16128ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>>,caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>::introspect(v18, v17, (uint64_t)&v30);
  v19 = v34;
  if (v34 == v33)
  {
    v20 = 4;
    v19 = v33;
  }
  else
  {
    if (!v34)
      goto LABEL_21;
    v20 = 5;
  }
  (*(void (**)(void))(*v19 + 8 * v20))();
LABEL_21:
  v21 = v32;
  if (v32 == v31)
  {
    v22 = 4;
    v21 = v31;
    goto LABEL_25;
  }
  if (v32)
  {
    v22 = 5;
LABEL_25:
    (*(void (**)(void))(*v21 + 8 * v22))();
  }
  return 0;
}

void sub_2065C7A50(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_2065C7A5C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x2065C79B0);
  }
  caulk::alloc::introspector::~introspector((caulk::alloc::introspector *)&a20);
  JUMPOUT(0x2065C7A54);
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_good_size(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_check()
{
  return 1;
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_print(uint64_t a1, int a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, BOOL))(**(_QWORD **)(a1 - 8) + 48))(*(_QWORD *)(a1 - 8), MEMORY[0x24BEDB318], a2 != 0);
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_locked()
{
  return 0;
}

uint64_t std::__function::__value_func<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

uint64_t caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,16128ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>>,caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>::introspect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t i;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t j;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  char v26;
  int **v27;
  _BYTE v28[24];
  _BYTE *v29;
  _BYTE v30[24];
  _BYTE *v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  LOBYTE(v24) = 0;
  v26 = 0;
  if (*(_BYTE *)(a3 + 72))
  {
    v24 = a1 + 976;
    v25 = a1 + 1136;
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 1136));
    v26 = 1;
  }
  for (i = a1 + 976;
        ;
        i = std::function<void * ()(unsigned long,unsigned long)>::operator()(*(_QWORD *)(a3 + 32), v6 & 0xFFFFFFFFFFFFFFFCLL, 48))
  {
    v6 = atomic_load((unint64_t *)(i + 32));
    if (!*(_BYTE *)(i + 18))
    {
      v7 = *(_QWORD *)(i + 8);
      v8 = std::function<void * ()(unsigned long,unsigned long)>::operator()(*(_QWORD *)(a3 + 32), v7, 0x4000);
      caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::introspect(v8 + 16, v7 + 16, a3);
    }
    if ((v6 & 0xFFFFFFFFFFFFFFFCLL) == 0)
      break;
  }
  caulk::alloc::introspector::copy_with_types((uint64_t)&v27, a3);
  v11 = v31;
  if (v31 == v30)
  {
    v12 = 4;
    v11 = v30;
  }
  else
  {
    if (!v31)
      goto LABEL_13;
    v12 = 5;
  }
  (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v11 + 8 * v12))(v11, v9, v10);
LABEL_13:
  v13 = v29;
  if (v29 == v28)
  {
    v14 = 4;
    v13 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_18;
    v14 = 5;
  }
  (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v13 + 8 * v14))(v13, v9, v10);
LABEL_18:
  std::__optional_destruct_base<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::iteration,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v24);
  LOBYTE(v24) = 0;
  v26 = 0;
  if (*(_BYTE *)(a3 + 72))
  {
    v24 = a1 + 368;
    v25 = a1 + 528;
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 528));
    v26 = 1;
  }
  for (j = a1 + 368;
        ;
        j = std::function<void * ()(unsigned long,unsigned long)>::operator()(*(_QWORD *)(a3 + 32), v16 & 0xFFFFFFFFFFFFFFFCLL, 48))
  {
    v16 = atomic_load((unint64_t *)(j + 32));
    if (!*(_BYTE *)(j + 18))
    {
      v17 = *(_QWORD *)(j + 8);
      v18 = std::function<void * ()(unsigned long,unsigned long)>::operator()(*(_QWORD *)(a3 + 32), v17, 0x4000);
      caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>::introspect(v18 + 16, v17 + 16, a3);
    }
    if ((v16 & 0xFFFFFFFFFFFFFFFCLL) == 0)
      break;
  }
  caulk::alloc::introspector::copy_with_types((uint64_t)&v27, a3);
  v19 = v31;
  if (v31 == v30)
  {
    v20 = 4;
    v19 = v30;
  }
  else
  {
    if (!v31)
      goto LABEL_30;
    v20 = 5;
  }
  (*(void (**)(void))(*v19 + 8 * v20))();
LABEL_30:
  v21 = v29;
  if (v29 == v28)
  {
    v22 = 4;
    v21 = v28;
    goto LABEL_34;
  }
  if (v29)
  {
    v22 = 5;
LABEL_34:
    (*(void (**)(void))(*v21 + 8 * v22))();
  }
  std::__optional_destruct_base<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::iteration,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v24);
  v24 = a3;
  v27 = (int **)&v24;
  return caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::introspect<void caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect_foreach<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1}>(caulk::alloc::introspector const&,caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1} &&)::{lambda(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1} const&)#1}>(a1 + 16, a3 + 8, &v27);
}

void sub_2065C7DC4(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void caulk::alloc::introspector::~introspector(caulk::alloc::introspector *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  caulk::alloc::introspector *v5;
  uint64_t v6;

  v2 = (char *)this + 40;
  v3 = (char *)*((_QWORD *)this + 8);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  v5 = (caulk::alloc::introspector *)*((_QWORD *)this + 4);
  if (v5 == (caulk::alloc::introspector *)((char *)this + 8))
  {
    v6 = 4;
    v5 = (caulk::alloc::introspector *)((char *)this + 8);
  }
  else
  {
    if (!v5)
      return;
    v6 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v5 + 8 * v6))();
}

uint64_t std::__optional_destruct_base<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::iteration,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 16))
    caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(*(unsigned __int128 **)(a1 + 8));
  return a1;
}

uint64_t std::__function::__value_func<void * ()(unsigned long,unsigned long)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      *(_QWORD *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
  }
  return a1;
}

{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

uint64_t *caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>::introspect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(_BYTE *)a3 & 4) != 0)
    std::function<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(*(_QWORD *)(a3 + 64), 4, a2, 240);
  return caulk::alloc::detail::state_bit_span::introspect((uint64_t *)(a1 + 8), 2, (const caulk::alloc::introspector *)(a2 + 240), a3, 0x100u, 0x3Fu);
}

uint64_t *caulk::alloc::detail::state_bit_span::introspect(uint64_t *this, uint64_t a2, const caulk::alloc::introspector *a3, uint64_t a4, unsigned int a5, unsigned int a6)
{
  uint64_t *v9;
  unsigned int v10;
  int v11;
  const caulk::alloc::introspector *v12;
  int v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  int v23;
  uint64_t *v24;

  if (!a2)
    return this;
  v9 = this;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 1;
  v14 = &this[a2];
  v24 = v14;
  do
  {
    v15 = *v9;
    if (v10 >= a6)
      goto LABEL_27;
    v16 = 0;
    v17 = 1;
    v18 = v13;
    do
    {
      v13 = ((v15 & (v17 << 32)) != 0) | (2 * ((v17 & v15) != 0));
      switch(v13)
      {
        case 0:
          if ((v18 - 2) >= 2)
          {
            if (v18)
            {
              v12 = a3;
              v11 = 0;
            }
            break;
          }
          if ((*(_BYTE *)a4 & 1) != 0)
          {
            v19 = v11 * a5;
            v20 = *(_QWORD *)(a4 + 64);
            v21 = 1;
LABEL_22:
            this = (uint64_t *)std::function<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(v20, v21, (uint64_t)v12, v19);
            goto LABEL_23;
          }
          goto LABEL_23;
        case 3:
          if ((v18 - 2) >= 2)
          {
            if (v18 || (*(_BYTE *)a4 & 2) == 0)
              goto LABEL_23;
            v21 = 2;
            goto LABEL_21;
          }
          if ((*(_BYTE *)a4 & 1) != 0)
          {
            v21 = 1;
LABEL_21:
            v19 = v11 * a5;
            v20 = *(_QWORD *)(a4 + 64);
            goto LABEL_22;
          }
LABEL_23:
          v11 = 0;
          v12 = a3;
          break;
        case 1:
          __break(1u);
          return this;
      }
      ++v11;
      a3 = (const caulk::alloc::introspector *)((char *)a3 + a5);
      v22 = v16 + 1;
      if (v16 > 0x1E)
        break;
      v17 *= 2;
      ++v16;
      v18 = v13;
    }
    while (v22 + v10 < a6);
    v10 += v22;
    v14 = v24;
LABEL_27:
    ++v9;
  }
  while (v9 != v14);
  if ((v13 - 2) >= 2)
  {
    if (!v13 && (*(_BYTE *)a4 & 2) != 0)
    {
      v23 = 2;
      return (uint64_t *)std::function<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(*(_QWORD *)(a4 + 64), v23, (uint64_t)v12, v11 * a5);
    }
  }
  else if ((*(_BYTE *)a4 & 1) != 0)
  {
    v23 = 1;
    return (uint64_t *)std::function<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(*(_QWORD *)(a4 + 64), v23, (uint64_t)v12, v11 * a5);
  }
  return this;
}

uint64_t std::__optional_destruct_base<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::iteration,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 16))
    caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(*(unsigned __int128 **)(a1 + 8));
  return a1;
}

uint64_t *caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::introspect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(_BYTE *)a3 & 4) != 0)
    std::function<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(*(_QWORD *)(a3 + 64), 4, a2, 272);
  return caulk::alloc::detail::state_bit_span::introspect((uint64_t *)(a1 + 8), 32, (const caulk::alloc::introspector *)(a2 + 272), a3, 0x10u, 0x3EEu);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x20BCF9C08);
}

void std::__function::__func<void * (*)(unsigned long,unsigned long),std::allocator<void * (*)(unsigned long,unsigned long)>,void * ()(unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<void * (*)(unsigned long,unsigned long),std::allocator<void * (*)(unsigned long,unsigned long)>,void * ()(unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2E1C8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void * (*)(unsigned long,unsigned long),std::allocator<void * (*)(unsigned long,unsigned long)>,void * ()(unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), 0x80000002065E2262))
    return a1 + 8;
  else
    return 0;
}

void *std::__function::__func<void * (*)(unsigned long,unsigned long),std::allocator<void * (*)(unsigned long,unsigned long)>,void * ()(unsigned long,unsigned long)>::target_type()
{
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a1 == a2)
    return 1;
  if ((a2 & a1) < 0 != __OFSUB__(a1, a2))
    return strcmp((const char *)(a1 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(a2 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

void std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2D308;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(uint64_t a1, int *a2, uint64_t *a3, uint64_t *a4)
{
  return std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 24), *a2, *a3, *a4);
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc19allocator_enumerateINS0_15darwin_resourceINS0_14dsw_allocator2ILb1EEENS0_23rt_safe_memory_resourceEEEEEvRT_NS_10option_setINS0_12region_usageEjEERKNSt3__18functionIFvSA_NS0_5blockEEEEEUlSA_mmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target_type()
{
}

void std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2D5C8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2D5C8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(uint64_t result, int *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  _QWORD *v6;
  _DWORD *v7;

  v3 = *a2;
  v4 = *(_QWORD *)(a3 + 8);
  if (*a2 == 4 || v3 == 2)
  {
    v6 = (_QWORD *)(*(_QWORD *)(result + 8) + 24);
  }
  else
  {
    if (v3 != 1)
      return result;
    v7 = *(_DWORD **)(result + 8);
    ++*v7;
    v6 = v7 + 2;
  }
  *v6 += v4;
  return result;
}

uint64_t std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc20allocator_statisticsINS0_15darwin_resourceINS0_14dsw_allocator2ILb1EEENS0_23rt_safe_memory_resourceEEEEE19malloc_statistics_tRT_EUlNS0_12region_usageENS0_5blockEE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target_type()
{
}

void std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

__n128 std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_24BF2CFF0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24BF2CFF0;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(uint64_t a1, unsigned int *a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[2];

  v4 = *a2;
  v5 = *a4;
  v7[0] = *a3;
  v7[1] = v5;
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD *, uint64_t))(a1 + 8))(*(unsigned int *)(a1 + 16), *(_QWORD *)(a1 + 24), v4, v7, 1);
}

uint64_t std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc15darwin_resourceINS0_14dsw_allocator2ILb1EEENS0_23rt_safe_memory_resourceEE14zone_enumerateEjPvjmPFijmmPS6_EPFvjS6_jP10vm_range_tjEEUlNS0_12region_usageEmmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target_type()
{
}

void std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

__n128 std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24BF2D048;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24BF2D048;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  uint64_t v7;

  v3 = *a2;
  v4 = *a3;
  v7 = 0;
  v5 = (const char *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t *))(a1 + 8))(*(unsigned int *)(a1 + 16), v3, v4, &v7);
  caulk::mach::throw_if_mach_error((uint64_t)"reader failed", v5);
  return v7;
}

uint64_t std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc15darwin_resourceINS0_14dsw_allocator2ILb1EEENS0_23rt_safe_memory_resourceEE14zone_enumerateEjPvjmPFijmmPS6_EPFvjS6_jP10vm_range_tjEEUlmmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::target_type()
{
}

void caulk::mach::error_category::~error_category(std::error_category *this)
{
  std::error_category::~error_category(this);
  JUMPOUT(0x20BCF9C08);
}

const char *caulk::mach::error_category::name(caulk::mach::error_category *this)
{
  return "Mach";
}

void caulk::mach::error_category::message(caulk::mach::error_category *this@<X0>, mach_error_t a2@<W1>, std::string *a3@<X8>)
{
  char *v5;
  std::string *v6;
  __int128 v7;
  char *v8;
  size_t v9;
  std::string *v10;
  std::string v11;
  std::string v12;

  v5 = (char *)(*(uint64_t (**)(caulk::mach::error_category *))(*(_QWORD *)this + 16))(this);
  std::string::basic_string[abi:ne180100]<0>(&v11, v5);
  v6 = std::string::append(&v11, ": ", 2uLL);
  v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v12.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v12.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  v8 = mach_error_string(a2);
  v9 = strlen(v8);
  v10 = std::string::append(&v12, v8, v9);
  *a3 = *v10;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v12.__r_.__value_.__l.__data_);
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v11.__r_.__value_.__l.__data_);
}

void sub_2065C87E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::find_owner(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  char v7;
  uint64_t result;
  unint64_t v10;

  v4 = *a1;
  v10 = a2;
  v5 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>(v4, &v10, 0);
  if (*(_BYTE *)(v5 + 18) == 1)
    v6 = *a1 + 112;
  else
    v6 = v5;
  if (*a1 + 112 == v6)
    return 0;
  if (*(_BYTE *)(v6 + 18) == 2)
    return 0;
  v7 = atomic_load((unint64_t *)(v6 + 32));
  if ((v7 & 1) != 0)
    return 0;
  result = *(_QWORD *)(v6 + 8);
  if (a2 < result + 256 || a2 >= result + 0x4000)
    return 0;
  return result;
}

unint64_t caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>::size(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  _QWORD v6[4];

  if (a1 + 240 > a2)
    return 0;
  v4 = a2 - (a1 + 240);
  if ((v4 >> 8) > 0x3EuLL)
    return 0;
  v6[2] = v2;
  v6[3] = v3;
  v6[0] = a1 + 8;
  v6[1] = 2;
  return (unint64_t)caulk::alloc::detail::state_bit_span::allocatedSlotsAtIndex(v6, v4 >> 8) << 8;
}

_QWORD *caulk::alloc::detail::state_bit_span::allocatedSlotsAtIndex(_QWORD *this, unsigned int a2)
{
  unint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  int v5;
  int v6;
  unint64_t *v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  unint64_t v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;

  v2 = a2 >> 5;
  if (this[1] <= v2)
  {
    __break(1u);
    return this;
  }
  v3 = (unint64_t *)(*this + 8 * v2);
  v4 = atomic_load(v3);
  v5 = a2 & 0x1F;
  if ((((1 << (a2 & 0x1F | 0x20)) | (1 << (a2 & 0x1F))) & ~v4) != 0)
    return 0;
  v6 = 0;
  v7 = v3 + 1;
  v8 = 1;
  while (1)
  {
    v9 = v8 + v5;
    if (v9 > 0x1F)
      goto LABEL_7;
    v10 = ~(_DWORD)v4 >> v9;
    v11 = HIDWORD(v4);
    if (v10)
      break;
    v12 = v11 >> v9;
    if (v12)
    {
      v13 = __clz(__rbit32(v12)) + v9;
      return (_QWORD *)(v6 - v5 + v13);
    }
LABEL_7:
    if (v7 == (unint64_t *)(*this + 8 * this[1]))
    {
      v13 = 32;
      return (_QWORD *)(v6 - v5 + v13);
    }
    v8 = 0;
    v4 = atomic_load(v7);
    v6 = v6 - v5 + 32;
    ++v7;
    v5 = 0;
  }
  v14 = __clz(__rbit32(v10)) + v9;
  v15 = v11 >> v9;
  v16 = __clz(__rbit32(v15)) + v9;
  if (v16 >= v14)
    v16 = v14;
  if (v15)
    v13 = v16;
  else
    v13 = v14;
  return (_QWORD *)(v6 - v5 + v13);
}

uint64_t caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::find_owner(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  char v7;
  uint64_t result;
  unint64_t v10;

  v4 = *a1;
  v10 = a2;
  v5 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>(v4, &v10, 0);
  if (*(_BYTE *)(v5 + 18) == 1)
    v6 = *a1 + 112;
  else
    v6 = v5;
  if (*a1 + 112 == v6)
    return 0;
  if (*(_BYTE *)(v6 + 18) == 2)
    return 0;
  v7 = atomic_load((unint64_t *)(v6 + 32));
  if ((v7 & 1) != 0)
    return 0;
  result = *(_QWORD *)(v6 + 8);
  if (a2 < result + 288 || a2 >= result + 0x4000)
    return 0;
  return result;
}

uint64_t caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::size(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  _QWORD v6[4];

  if (a1 + 272 > a2)
    return 0;
  v4 = a2 - (a1 + 272);
  if (((v4 >> 5) & 0x7FFFFFFF) > 0x1F6)
    return 0;
  v6[2] = v2;
  v6[3] = v3;
  v6[0] = a1 + 8;
  v6[1] = 32;
  return 16 * caulk::alloc::detail::state_bit_span::allocatedSlotsAtIndex(v6, v4 >> 4);
}

_QWORD *caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::~darwin_resource(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24BF2CBD0;
  v2 = a1[198];
  a1[198] = 0;
  if (v2)
    std::default_delete<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_plus>::operator()[abi:ne180100](v2);
  caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::~tree_allocator((uint64_t)(a1 + 122));
  caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::~tree_allocator((uint64_t)(a1 + 46));
  caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::~tracking_allocator((uint64_t)(a1 + 2));
  return a1;
}

void caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::~darwin_resource(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24BF2CBD0;
  v2 = a1[198];
  a1[198] = 0;
  if (v2)
    std::default_delete<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_plus>::operator()[abi:ne180100](v2);
  caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::~tree_allocator((uint64_t)(a1 + 122));
  caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::~tree_allocator((uint64_t)(a1 + 46));
  caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::~tracking_allocator((uint64_t)(a1 + 2));
  JUMPOUT(0x20BCF9C08);
}

BOOL caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::do_is_equal(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

void caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::print(uint64_t a1, _QWORD *a2, int a3)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  int v10;
  std::string *v11;
  std::string::size_type size;
  std::string *v13;
  unsigned int v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t (**v18)();
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  int v24;
  std::string *v25;
  std::string::size_type v26;
  std::string *v27;
  std::string::size_type v28;
  unsigned int *v29;
  std::string *v30;
  std::string *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  std::string::size_type *p_size;
  uint64_t v37;
  std::string *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t (**v42)();
  _QWORD *v43;
  char v44;
  _QWORD *v45;
  _QWORD **v46;
  BOOL v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  std::string *v51;
  std::string::size_type *v52;
  _QWORD *v53;
  std::string *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  std::string *v59;
  uint64_t v60;
  _QWORD *v61;
  char v62;
  _QWORD *v63;
  _QWORD **v64;
  std::string *v65;
  uint64_t v66;
  uint64_t v69;
  std::string::value_type *__s;
  int v71;
  _QWORD *v72;
  int v73;
  char v74;
  _DWORD v75[2];
  std::string v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  _QWORD **v81;
  _QWORD *v82;
  uint64_t v83;
  uint64_t v84;
  std::string v85;
  std::string *v86;
  std::string v87;
  std::string *v88;
  std::string v89;
  std::string *v90;
  std::string *v91;
  _BYTE v92[24];
  _BYTE *v93;
  char v94;
  uint64_t v95;

  v95 = *MEMORY[0x24BDAC8D0];
  v72 = a2;
  v73 = 0;
  v74 = 0;
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "dsw_allocator2 @ ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  v89.__r_.__value_.__s.__data_[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v72, (uint64_t)&v89, 1);
  v73 += 2;
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "[tier ");
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "sizes ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "-");
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "] ");
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "tree_allocator @ ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "\n");
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 1152));
  v4 = atomic_load((unint64_t *)(a1 + 1024));
  v5 = v4 & 0xFFFFFFFFFFFFFFFCLL;
  if (a1 + 1104 == (v4 & 0xFFFFFFFFFFFFFFFCLL))
  {
    v6 = 0;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    do
    {
      if (*(_BYTE *)(v5 + 18) != 2)
      {
        v8 = atomic_load((unint64_t *)(v5 + 32));
        if ((v8 & 1) == 0)
        {
          v9 = *(_QWORD *)(v5 + 8);
          v10 = atomic_load((unsigned int *)(v9 + 4));
          std::string::basic_string[abi:ne180100]<0>(&v87, "availability ");
          std::to_string(&v85, v10);
          if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v11 = &v85;
          else
            v11 = (std::string *)v85.__r_.__value_.__r.__words[0];
          if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            size = HIBYTE(v85.__r_.__value_.__r.__words[2]);
          else
            size = v85.__r_.__value_.__l.__size_;
          v13 = std::string::append(&v87, (const std::string::value_type *)v11, size);
          v89 = *v13;
          v13->__r_.__value_.__l.__size_ = 0;
          v13->__r_.__value_.__r.__words[2] = 0;
          v13->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v85.__r_.__value_.__l.__data_);
          if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v87.__r_.__value_.__l.__data_);
          caulk::alloc::base_allocator::formatter::print_allocator<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>((caulk::alloc::base_allocator::formatter *)&v72, (uint64_t)&v89, v9 + 16);
          v14 = atomic_load((unsigned int *)(v9 + 16));
          if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v89.__r_.__value_.__l.__data_);
          ++v6;
          v7 += 16 * v14;
        }
      }
      v15 = atomic_load((unint64_t *)(v5 + 32));
      v5 = v15 & 0xFFFFFFFFFFFFFFFCLL;
    }
    while (a1 + 1104 != (v15 & 0xFFFFFFFFFFFFFFFCLL));
  }
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal((unsigned __int128 *)(a1 + 1152));
  v73 += 2;
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v72, " nodes, total capacity ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v72, ", free capacity ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  std::ostream::operator<<();
  if (16096 * v6)
  {
    caulk::alloc::base_allocator::formatter::emit_string(&v72, " (");
    caulk::alloc::base_allocator::formatter::check_line_start(&v72);
    std::ostream::operator<<();
    caulk::alloc::base_allocator::formatter::emit_string(&v72, "%)");
  }
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "\n");
  v73 -= 2;
  std::string::basic_string[abi:ne180100]<0>(&v89, "super");
  caulk::alloc::base_allocator::formatter::print_allocator<caulk::alloc::global_page_cache>((caulk::alloc::base_allocator::formatter *)&v72, (uint64_t)&v89, (caulk::alloc::details::caching_page_allocator_base **)(a1 + 984));
  if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v89.__r_.__value_.__l.__data_);
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "[tier ");
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "sizes ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "-");
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "] ");
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "tree_allocator @ ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "\n");
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 544));
  v69 = a1;
  v16 = a1 + 496;
  v17 = atomic_load((unint64_t *)(a1 + 416));
  v18 = &off_24BF2E1C8;
  v19 = v17 & 0xFFFFFFFFFFFFFFFCLL;
  if (a1 + 496 != (v17 & 0xFFFFFFFFFFFFFFFCLL))
  {
    v20 = 0;
    v21 = 0;
    while (1)
    {
      if (*(_BYTE *)(v19 + 18) != 2)
      {
        v22 = atomic_load((unint64_t *)(v19 + 32));
        if ((v22 & 1) == 0)
          break;
      }
LABEL_83:
      v49 = atomic_load((unint64_t *)(v19 + 32));
      v19 = v49 & 0xFFFFFFFFFFFFFFFCLL;
      if (v16 == (v49 & 0xFFFFFFFFFFFFFFFCLL))
        goto LABEL_86;
    }
    v23 = *(_QWORD *)(v19 + 8);
    v24 = atomic_load((unsigned int *)(v23 + 4));
    std::string::basic_string[abi:ne180100]<0>(&v89, "availability ");
    std::to_string(&v87, v24);
    if ((v87.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v25 = &v87;
    else
      v25 = (std::string *)v87.__r_.__value_.__r.__words[0];
    if ((v87.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v26 = HIBYTE(v87.__r_.__value_.__r.__words[2]);
    else
      v26 = v87.__r_.__value_.__l.__size_;
    v27 = std::string::append(&v89, (const std::string::value_type *)v25, v26);
    v28 = v27->__r_.__value_.__l.__size_;
    __s = (std::string::value_type *)v27->__r_.__value_.__r.__words[0];
    v75[0] = v27->__r_.__value_.__r.__words[2];
    *(_DWORD *)((char *)v75 + 3) = *(_DWORD *)((char *)&v27->__r_.__value_.__r.__words[2] + 3);
    v71 = SHIBYTE(v27->__r_.__value_.__r.__words[2]);
    v27->__r_.__value_.__l.__size_ = 0;
    v27->__r_.__value_.__r.__words[2] = 0;
    v27->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v87.__r_.__value_.__l.__data_);
    if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v89.__r_.__value_.__l.__data_);
    v73 += 2;
    if (v71 < 0)
    {
      if (!v28)
        goto LABEL_46;
      std::string::__init_copy_ctor_external(&v76, __s, v28);
    }
    else
    {
      if (!v71)
        goto LABEL_46;
      v76.__r_.__value_.__r.__words[0] = (std::string::size_type)__s;
      v76.__r_.__value_.__l.__size_ = v28;
      LODWORD(v76.__r_.__value_.__r.__words[2]) = v75[0];
      *(_DWORD *)((char *)&v76.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v75 + 3);
      *((_BYTE *)&v76.__r_.__value_.__s + 23) = v71;
    }
    caulk::alloc::base_allocator::formatter::operator<<<std::string>(&v72, (uint64_t)&v76);
    caulk::alloc::base_allocator::formatter::emit_string(&v72, ": ");
    if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v76.__r_.__value_.__l.__data_);
LABEL_46:
    caulk::alloc::base_allocator::formatter::emit_string(&v72, "bitmap_allocator @ ");
    caulk::alloc::base_allocator::formatter::check_line_start(&v72);
    v29 = (unsigned int *)(v23 + 16);
    std::ostream::operator<<();
    caulk::alloc::base_allocator::formatter::emit_string(&v72, ", block size ");
    caulk::alloc::base_allocator::formatter::check_line_start(&v72);
    std::ostream::operator<<();
    caulk::alloc::base_allocator::formatter::emit_string(&v72, ", slot size ");
    caulk::alloc::base_allocator::formatter::check_line_start(&v72);
    std::ostream::operator<<();
    caulk::alloc::base_allocator::formatter::emit_string(&v72, ", ");
    caulk::alloc::base_allocator::formatter::check_line_start(&v72);
    std::ostream::operator<<();
    caulk::alloc::base_allocator::formatter::emit_string(&v72, " slots, ");
    caulk::alloc::base_allocator::formatter::emit_string(&v72, "max size ");
    caulk::alloc::base_allocator::formatter::check_line_start(&v72);
    std::ostream::operator<<();
    caulk::alloc::base_allocator::formatter::emit_string(&v72, ", memory ");
    caulk::alloc::base_allocator::formatter::check_line_start(&v72);
    std::ostream::operator<<();
    caulk::alloc::base_allocator::formatter::emit_string(&v72, ":");
    caulk::alloc::base_allocator::formatter::check_line_start(&v72);
    std::ostream::operator<<();
    caulk::alloc::base_allocator::formatter::emit_string(&v72, "\n");
    v73 += 2;
    caulk::alloc::base_allocator::formatter::emit_string(&v72, "state bits:  ");
    caulk::alloc::base_allocator::formatter::hexdump((caulk::alloc::base_allocator::formatter *)&v72, (char *)(v23 + 24), 0x10uLL);
    caulk::alloc::base_allocator::formatter::emit_string(&v72, "search hint: ");
    atomic_load((unsigned int *)(v23 + 20));
    caulk::alloc::base_allocator::formatter::check_line_start(&v72);
    std::ostream::operator<<();
    caulk::alloc::base_allocator::formatter::emit_string(&v72, "\n");
    v82 = 0;
    v83 = 0;
    v81 = &v82;
    v78 = 0;
    v79 = 0;
    v77 = 0;
    v30 = (std::string *)operator new(0x28uLL);
    v30->__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24BF2CF98;
    v30->__r_.__value_.__l.__size_ = (std::string::size_type)&v81;
    v30->__r_.__value_.__r.__words[2] = (std::string::size_type)&v79;
    v30[1].__r_.__value_.__r.__words[0] = (std::string::size_type)&v78;
    v30[1].__r_.__value_.__l.__size_ = (std::string::size_type)&v77;
    v86 = v30;
    v87.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24BF2D468;
    v87.__r_.__value_.__l.__size_ = (std::string::size_type)&v85;
    v88 = &v87;
    LODWORD(v89.__r_.__value_.__l.__data_) = 7;
    v89.__r_.__value_.__l.__size_ = (std::string::size_type)v18;
    v89.__r_.__value_.__r.__words[2] = (std::string::size_type)caulk::alloc::introspector::local_reader;
    v91 = (std::string *)&v89.__r_.__value_.__r.__words[1];
    std::__function::__value_func<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v92, (uint64_t)&v87);
    v94 = 1;
    v31 = v88;
    if (v88 == &v87)
    {
      v31 = &v87;
      v32 = 4;
    }
    else
    {
      if (!v88)
        goto LABEL_51;
      v32 = 5;
    }
    (*(void (**)(void))(v31->__r_.__value_.__r.__words[0] + 8 * v32))();
LABEL_51:
    v84 = v23 + 16;
    v80 = 16368;
    if (!v91)
      std::__throw_bad_function_call[abi:ne180100]();
    v33 = (*(uint64_t (**)(std::string *, uint64_t *, uint64_t *))(v91->__r_.__value_.__r.__words[0] + 48))(v91, &v84, &v80);
    caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>::introspect(v33, (uint64_t)v29, (uint64_t)&v89);
    v34 = v93;
    if (v93 == v92)
    {
      v34 = v92;
      v35 = 4;
    }
    else
    {
      if (!v93)
        goto LABEL_57;
      v35 = 5;
    }
    (*(void (**)(void))(*v34 + 8 * v35))();
LABEL_57:
    p_size = (std::string::size_type *)v91;
    if (v91 == (std::string *)&v89.__r_.__value_.__r.__words[1])
    {
      p_size = &v89.__r_.__value_.__l.__size_;
      v37 = 4;
    }
    else
    {
      if (!v91)
        goto LABEL_62;
      v37 = 5;
    }
    (*(void (**)(void))(*p_size + 8 * v37))();
LABEL_62:
    v38 = v86;
    if (v86 == &v85)
    {
      v38 = &v85;
      v39 = 4;
    }
    else
    {
      if (!v86)
      {
LABEL_67:
        caulk::alloc::base_allocator::formatter::check_line_start(&v72);
        *(_DWORD *)((char *)v72 + *(_QWORD *)(*v72 - 24) + 8) = *(_DWORD *)((_BYTE *)v72 + *(_QWORD *)(*v72 - 24)
                                                                                           + 8) & 0xFFFFFFB5 | 2;
        caulk::alloc::base_allocator::formatter::check_line_start(&v72);
        std::ostream::operator<<();
        caulk::alloc::base_allocator::formatter::emit_string(&v72, " allocations for ");
        caulk::alloc::base_allocator::formatter::check_line_start(&v72);
        std::ostream::operator<<();
        caulk::alloc::base_allocator::formatter::emit_string(&v72, " bytes");
        caulk::alloc::base_allocator::formatter::emit_string(&v72, " (");
        caulk::alloc::base_allocator::formatter::check_line_start(&v72);
        std::ostream::operator<<();
        caulk::alloc::base_allocator::formatter::emit_string(&v72, "%)");
        caulk::alloc::base_allocator::formatter::emit_string(&v72, "; ");
        caulk::alloc::base_allocator::formatter::check_line_start(&v72);
        std::ostream::operator<<();
        caulk::alloc::base_allocator::formatter::emit_string(&v72, " bytes free\n");
        if (v83)
        {
          caulk::alloc::base_allocator::formatter::emit_string(&v72, "sizes:");
          v40 = v20;
          v41 = v21;
          v42 = v18;
          v43 = v81;
          if (v81 != &v82)
          {
            v44 = 0;
            do
            {
              if ((v44 & 1) == 0 && (v43[4] & 0x8000000000000000) != 0)
              {
                caulk::alloc::base_allocator::formatter::emit_string(&v72, "\n");
                caulk::alloc::base_allocator::formatter::emit_string(&v72, "free sizes:");
                v44 = 1;
              }
              caulk::alloc::base_allocator::formatter::emit_string(&v72, " ");
              caulk::alloc::base_allocator::formatter::check_line_start(&v72);
              std::ostream::operator<<();
              caulk::alloc::base_allocator::formatter::emit_string(&v72, caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::sizeLabels[(v43[4] >> 61) & 3]);
              caulk::alloc::base_allocator::formatter::emit_string(&v72, "[");
              caulk::alloc::base_allocator::formatter::check_line_start(&v72);
              std::ostream::operator<<();
              caulk::alloc::base_allocator::formatter::emit_string(&v72, "]");
              v45 = (_QWORD *)v43[1];
              if (v45)
              {
                do
                {
                  v46 = (_QWORD **)v45;
                  v45 = (_QWORD *)*v45;
                }
                while (v45);
              }
              else
              {
                do
                {
                  v46 = (_QWORD **)v43[2];
                  v47 = *v46 == v43;
                  v43 = v46;
                }
                while (!v47);
              }
              v43 = v46;
            }
            while (v46 != &v82);
          }
          caulk::alloc::base_allocator::formatter::emit_string(&v72, "\n");
          v18 = v42;
          v21 = v41;
          v20 = v40;
        }
        std::__tree<std::__value_type<unsigned long long,unsigned int>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned int>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned int>>>::destroy(v82);
        v73 -= 4;
        v48 = atomic_load(v29);
        if (v71 < 0)
          operator delete(__s);
        ++v20;
        v21 += v48 << 8;
        v16 = a1 + 496;
        goto LABEL_83;
      }
      v39 = 5;
    }
    (*(void (**)(void))(v38->__r_.__value_.__r.__words[0] + 8 * v39))();
    goto LABEL_67;
  }
  v20 = 0;
LABEL_86:
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal((unsigned __int128 *)(a1 + 544));
  v73 += 2;
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  v50 = a1;
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v72, " nodes, total capacity ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v72, ", free capacity ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  std::ostream::operator<<();
  if (16128 * v20)
  {
    caulk::alloc::base_allocator::formatter::emit_string(&v72, " (");
    caulk::alloc::base_allocator::formatter::check_line_start(&v72);
    std::ostream::operator<<();
    caulk::alloc::base_allocator::formatter::emit_string(&v72, "%)");
  }
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "\n");
  v73 -= 2;
  std::string::basic_string[abi:ne180100]<0>(&v89, "super");
  caulk::alloc::base_allocator::formatter::print_allocator<caulk::alloc::global_page_cache>((caulk::alloc::base_allocator::formatter *)&v72, (uint64_t)&v89, (caulk::alloc::details::caching_page_allocator_base **)(a1 + 376));
  if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v89.__r_.__value_.__l.__data_);
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "[tier] ");
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "[tracking] ");
  caulk::alloc::global_page_cache::describe((caulk::alloc::details::caching_page_allocator_base **)(a1 + 16), (caulk::alloc::base_allocator::formatter *)&v72);
  v73 += 2;
  v82 = 0;
  v83 = 0;
  v80 = 0;
  v81 = &v82;
  v78 = 0;
  v79 = 0;
  v51 = (std::string *)operator new(0x28uLL);
  v51->__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24BF2E2D0;
  v51->__r_.__value_.__l.__size_ = (std::string::size_type)&v81;
  v51->__r_.__value_.__r.__words[2] = (std::string::size_type)&v80;
  v51[1].__r_.__value_.__r.__words[0] = (std::string::size_type)&v79;
  v51[1].__r_.__value_.__l.__size_ = (std::string::size_type)&v78;
  v86 = v51;
  v87.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24BF2E3D8;
  v87.__r_.__value_.__l.__size_ = (std::string::size_type)&v85;
  v88 = &v87;
  LODWORD(v89.__r_.__value_.__l.__data_) = 7;
  v52 = &v89.__r_.__value_.__l.__size_;
  v89.__r_.__value_.__l.__size_ = (std::string::size_type)v18;
  v89.__r_.__value_.__r.__words[2] = (std::string::size_type)caulk::alloc::introspector::local_reader;
  v53 = v92;
  v91 = (std::string *)&v89.__r_.__value_.__r.__words[1];
  std::__function::__value_func<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v92, (uint64_t)&v87);
  v94 = 1;
  v54 = v88;
  if (v88 == &v87)
  {
    v55 = 4;
    v54 = &v87;
  }
  else
  {
    if (!v88)
      goto LABEL_95;
    v55 = 5;
  }
  (*(void (**)(void))(v54->__r_.__value_.__r.__words[0] + 8 * v55))();
LABEL_95:
  v76.__r_.__value_.__r.__words[0] = a1 + 16;
  v84 = 352;
  if (!v91)
    std::__throw_bad_function_call[abi:ne180100]();
  v56 = (*(uint64_t (**)(std::string *, std::string *, uint64_t *))(v91->__r_.__value_.__r.__words[0] + 48))(v91, &v76, &v84);
  v84 = (uint64_t)&v89;
  v76.__r_.__value_.__r.__words[0] = (std::string::size_type)&v84;
  caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::introspect<void caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect_foreach<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1}>(caulk::alloc::introspector const&,caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1} &&)::{lambda(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1} const&)#1}>(v56 + 16, (uint64_t)&v89.__r_.__value_.__l.__size_, (int ***)&v76);
  if (v93 == v92)
  {
    v57 = 4;
  }
  else
  {
    if (!v93)
      goto LABEL_101;
    v57 = 5;
    v53 = v93;
  }
  (*(void (**)(_QWORD *))(*v53 + 8 * v57))(v53);
LABEL_101:
  if (v91 == (std::string *)&v89.__r_.__value_.__r.__words[1])
  {
    v58 = 4;
  }
  else
  {
    if (!v91)
      goto LABEL_106;
    v58 = 5;
    v52 = (std::string::size_type *)v91;
  }
  (*(void (**)(std::string::size_type *))(*v52 + 8 * v58))(v52);
LABEL_106:
  v59 = v86;
  if (v86 == &v85)
  {
    v60 = 4;
    v59 = &v85;
  }
  else
  {
    if (!v86)
      goto LABEL_111;
    v60 = 5;
  }
  (*(void (**)(void))(v59->__r_.__value_.__r.__words[0] + 8 * v60))();
LABEL_111:
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  *(_DWORD *)((char *)v72 + *(_QWORD *)(*v72 - 24) + 8) = *(_DWORD *)((_BYTE *)v72 + *(_QWORD *)(*v72 - 24) + 8) & 0xFFFFFFB5 | 2;
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v72, " allocations for ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v72, " bytes");
  caulk::alloc::base_allocator::formatter::emit_string(&v72, "; ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v72);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v72, " bytes free\n");
  if (v83)
  {
    caulk::alloc::base_allocator::formatter::emit_string(&v72, "sizes:");
    v61 = v81;
    if (v81 != &v82)
    {
      v62 = 0;
      do
      {
        if ((v62 & 1) == 0 && (v61[4] & 0x8000000000000000) != 0)
        {
          caulk::alloc::base_allocator::formatter::emit_string(&v72, "\n");
          caulk::alloc::base_allocator::formatter::emit_string(&v72, "free sizes:");
          v62 = 1;
        }
        caulk::alloc::base_allocator::formatter::emit_string(&v72, " ");
        caulk::alloc::base_allocator::formatter::check_line_start(&v72);
        std::ostream::operator<<();
        caulk::alloc::base_allocator::formatter::emit_string(&v72, caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::sizeLabels[(v61[4] >> 61) & 3]);
        caulk::alloc::base_allocator::formatter::emit_string(&v72, "[");
        caulk::alloc::base_allocator::formatter::check_line_start(&v72);
        std::ostream::operator<<();
        caulk::alloc::base_allocator::formatter::emit_string(&v72, "]");
        v63 = (_QWORD *)v61[1];
        if (v63)
        {
          do
          {
            v64 = (_QWORD **)v63;
            v63 = (_QWORD *)*v63;
          }
          while (v63);
        }
        else
        {
          do
          {
            v64 = (_QWORD **)v61[2];
            v47 = *v64 == v61;
            v61 = v64;
          }
          while (!v47);
        }
        v61 = v64;
      }
      while (v64 != &v82);
    }
    caulk::alloc::base_allocator::formatter::emit_string(&v72, "\n");
    v50 = v69;
  }
  std::__tree<std::__value_type<unsigned long long,unsigned int>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned int>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned int>>>::destroy(v82);
  v73 -= 4;
  if (a3)
  {
    v89.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24BF2D200;
    v89.__r_.__value_.__l.__size_ = (std::string::size_type)a2;
    v90 = &v89;
    caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(v50, 7, (uint64_t)&v89);
    v65 = v90;
    if (v90 == &v89)
    {
      v66 = 4;
      v65 = &v89;
    }
    else
    {
      if (!v90)
        return;
      v66 = 5;
    }
    (*(void (**)(void))(v65->__r_.__value_.__r.__words[0] + 8 * v66))();
  }
}

void sub_2065C9C34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, int a20,int a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45)
{
  _QWORD *v45;
  uint64_t v46;
  _QWORD *v48;
  uint64_t v49;

  v48 = *(_QWORD **)(v46 - 152);
  if (v48 == v45)
  {
    v49 = 4;
    v48 = (_QWORD *)(v46 - 176);
  }
  else
  {
    if (!v48)
      goto LABEL_6;
    v49 = 5;
  }
  (*(void (**)(void))(*v48 + 8 * v49))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::enumerate(uint64_t a1, int a2, uint64_t a3)
{
  return caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(a1, a2, a3);
}

unint64_t caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::compact(uint64_t a1, unint64_t a2)
{
  unsigned __int128 *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char v8;
  uint64_t v9;
  unsigned __int8 v10;
  unsigned int v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char v17;
  uint64_t v18;
  unsigned __int8 v19;
  unsigned int v20;
  unint64_t v21;
  uint64_t v22;

  v4 = (unsigned __int128 *)(a1 + 1440);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 1440));
  v5 = atomic_load((unint64_t *)(a1 + 1312));
  v6 = v5 & 0xFFFFFFFFFFFFFFFCLL;
  if (a1 + 1392 == (v5 & 0xFFFFFFFFFFFFFFFCLL))
  {
    v7 = 0;
  }
  else
  {
    v7 = 0;
    do
    {
      if (*(_BYTE *)(v6 + 18) != 2)
      {
        v8 = atomic_load((unint64_t *)(v6 + 32));
        if ((v8 & 1) == 0)
        {
          v9 = *(_QWORD *)(v6 + 8);
          do
            v10 = __ldaxr((unsigned __int8 *)v9);
          while (__stlxr(1u, (unsigned __int8 *)v9));
          if ((v10 & 1) == 0)
          {
            v11 = atomic_load((unsigned int *)(v9 + 16));
            if (v11 == 1006)
            {
              v7 += *(_QWORD *)(v9 + 8);
              caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove(a1 + 1280, *(_QWORD *)v6);
              caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove(a1 + 992, *(_QWORD *)v6);
              if (a2 - 1 < v7)
                break;
            }
            else
            {
              atomic_store(0, (unsigned __int8 *)v9);
            }
          }
        }
      }
      v12 = atomic_load((unint64_t *)(v6 + 32));
      v6 = v12 & 0xFFFFFFFFFFFFFFFCLL;
    }
    while (a1 + 1392 != (v12 & 0xFFFFFFFFFFFFFFFCLL));
  }
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v4);
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::perform_deferred_deletions<true,(BOOL *)0>((caulk::alloc::base_allocator *)(a1 + 1152));
  if (a2 - 1 >= v7)
  {
    if (a2 >= v7)
      v13 = a2 - v7;
    else
      v13 = 0;
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 832));
    v14 = atomic_load((unint64_t *)(a1 + 704));
    v15 = v14 & 0xFFFFFFFFFFFFFFFCLL;
    if (a1 + 784 == (v14 & 0xFFFFFFFFFFFFFFFCLL))
    {
      v16 = 0;
    }
    else
    {
      v16 = 0;
      do
      {
        if (*(_BYTE *)(v15 + 18) != 2)
        {
          v17 = atomic_load((unint64_t *)(v15 + 32));
          if ((v17 & 1) == 0)
          {
            v18 = *(_QWORD *)(v15 + 8);
            do
              v19 = __ldaxr((unsigned __int8 *)v18);
            while (__stlxr(1u, (unsigned __int8 *)v18));
            if ((v19 & 1) == 0)
            {
              v20 = atomic_load((unsigned int *)(v18 + 16));
              if (v20 == 63)
              {
                v16 += *(_QWORD *)(v18 + 8);
                caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove(a1 + 672, *(_QWORD *)v15);
                caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove(a1 + 384, *(_QWORD *)v15);
                if (v13 - 1 < v16)
                  break;
              }
              else
              {
                atomic_store(0, (unsigned __int8 *)v18);
              }
            }
          }
        }
        v21 = atomic_load((unint64_t *)(v15 + 32));
        v15 = v21 & 0xFFFFFFFFFFFFFFFCLL;
      }
      while (a1 + 784 != (v21 & 0xFFFFFFFFFFFFFFFCLL));
    }
    caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal((unsigned __int128 *)(a1 + 832));
    caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::perform_deferred_deletions<true,(BOOL *)0>((caulk::alloc::base_allocator *)(a1 + 544));
    if (v13 - 1 >= v16)
    {
      if (v13 >= v16)
        v22 = v13 - v16;
      else
        v22 = 0;
      v16 += caulk::alloc::details::caching_page_allocator_base::compact(*(caulk::alloc::details::caching_page_allocator_base **)(a1 + 16), v22);
    }
    v7 += v16;
  }
  return v7;
}

void caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::reserve(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::malloc_zone(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1584) + 8;
}

_QWORD *caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(uint64_t a1, int a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[3];
  _QWORD *v14;
  int v15;
  _QWORD v16[3];
  _QWORD *v17;
  _BYTE v18[24];
  _BYTE *v19;
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v13[0] = &off_24BF2D4C0;
  v13[1] = a3;
  v14 = v13;
  v15 = a2;
  v16[0] = &off_24BF2E1C8;
  v16[1] = caulk::alloc::introspector::local_reader;
  v17 = v16;
  std::__function::__value_func<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v18, (uint64_t)v13);
  v20 = 1;
  v4 = v14;
  if (v14 == v13)
  {
    v5 = 4;
    v4 = v13;
  }
  else
  {
    if (!v14)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  v11 = 1584;
  v12 = a1;
  if (!v17)
    std::__throw_bad_function_call[abi:ne180100]();
  v6 = (*(uint64_t (**)(_QWORD *, uint64_t *, uint64_t *))(*v17 + 48))(v17, &v12, &v11);
  caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,16128ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>>,caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>::introspect(v6 + 16, a1, (uint64_t)&v15);
  v7 = v19;
  if (v19 == v18)
  {
    v8 = 4;
    v7 = v18;
  }
  else
  {
    if (!v19)
      goto LABEL_12;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_12:
  result = v17;
  if (v17 == v16)
  {
    v10 = 4;
    result = v16;
  }
  else
  {
    if (!v17)
      return result;
    v10 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v10))();
}

void sub_2065CA2A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  caulk::alloc::introspector::~introspector((caulk::alloc::introspector *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2D4C0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2D4C0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(uint64_t a1, int *a2, uint64_t *a3, uint64_t *a4)
{
  return std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 24), *a2, *a3, *a4);
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc19allocator_enumerateINS0_8resourceINS0_14dsw_allocator2ILb1EEENS0_23rt_safe_memory_resourceEEEEEvRT_NS_10option_setINS0_12region_usageEjEERKNSt3__18functionIFvSA_NS0_5blockEEEEEUlSA_mmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target_type()
{
}

void std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2D200;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2D200;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(uint64_t a1, int *a2)
{
  return caulk::alloc::describe_block(*(_QWORD *)(a1 + 8), *a2);
}

uint64_t std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc15print_allocatorINS0_8resourceINS0_14dsw_allocator2ILb1EEENS0_23rt_safe_memory_resourceEEEEEvRT_RNSt3__113basic_ostreamIcNS9_11char_traitsIcEEEEbEUlNS0_12region_usageENS0_5blockEE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>>(caulk::alloc::resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target_type()
{
}

uint64_t caulk::alloc::describe_block(uint64_t a1, int a2)
{
  const char *v2;
  _QWORD *v3;
  _QWORD *v4;
  size_t v5;
  _QWORD *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  char v10;
  char v11;
  char v12;
  std::locale v13;

  if ((a2 - 1) > 3)
    v2 = "?";
  else
    v2 = off_24BF2E708[a2 - 1];
  v3 = (_QWORD *)std::ostream::operator<<();
  v10 = 58;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)&v10, 1);
  v4 = (_QWORD *)std::ostream::operator<<();
  v11 = 32;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)&v11, 1);
  v5 = strlen(v2);
  v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)v2, v5);
  v12 = 32;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)&v12, 1);
  v7 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
  v8 = std::locale::use_facet(&v13, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
  std::locale::~locale(&v13);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_2065CA554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

_QWORD *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  char *v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  size_t v16;
  std::locale::__imp *p_b;
  uint64_t v18;
  uint64_t v19;
  std::locale *v20;
  uint64_t v21;
  _BYTE v23[16];
  std::locale __b;
  size_t v25;
  int64_t v26;

  MEMORY[0x20BCF9AD0](v23, a1);
  if (v23[0])
  {
    v6 = (char *)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *((_QWORD *)v6 + 5);
    v8 = *((_DWORD *)v6 + 2);
    v9 = *((_DWORD *)v6 + 36);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&__b, MEMORY[0x24BEDB350]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&__b);
      *((_DWORD *)v6 + 36) = v9;
    }
    v11 = a2 + a3;
    if ((v8 & 0xB0) == 0x20)
      v12 = a2 + a3;
    else
      v12 = a2;
    if (!v7)
      goto LABEL_29;
    v13 = *((_QWORD *)v6 + 3);
    v14 = v13 <= a3;
    v15 = v13 - a3;
    v16 = v14 ? 0 : v15;
    if (v12 - a2 >= 1
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 96))(v7, a2, v12 - a2) != v12 - a2)
    {
      goto LABEL_29;
    }
    if ((uint64_t)v16 >= 1)
    {
      if (v16 >= 0x7FFFFFFFFFFFFFF8)
        std::string::__throw_length_error[abi:ne180100]();
      if (v16 >= 0x17)
      {
        v18 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v16 | 7) != 0x17)
          v18 = v16 | 7;
        v19 = v18 + 1;
        p_b = (std::locale::__imp *)operator new(v18 + 1);
        v25 = v16;
        v26 = v19 | 0x8000000000000000;
        __b.__locale_ = p_b;
      }
      else
      {
        HIBYTE(v26) = v16;
        p_b = (std::locale::__imp *)&__b;
      }
      memset(p_b, v9, v16);
      *((_BYTE *)p_b + v16) = 0;
      v20 = v26 >= 0 ? &__b : (std::locale *)__b.__locale_;
      v21 = (*(uint64_t (**)(uint64_t, std::locale *, size_t))(*(_QWORD *)v7 + 96))(v7, v20, v16);
      if (SHIBYTE(v26) < 0)
        operator delete(__b.__locale_);
      if (v21 != v16)
        goto LABEL_29;
    }
    if (v11 - v12 < 1
      || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 96))(v7, v12, v11 - v12) == v11 - v12)
    {
      *((_QWORD *)v6 + 3) = 0;
    }
    else
    {
LABEL_29:
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x20BCF9ADC](v23);
  return a1;
}

void sub_2065CA788(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  _QWORD *v17;

  if (a17 < 0)
    operator delete(__p);
  MEMORY[0x20BCF9ADC](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v17 + *(_QWORD *)(*v17 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x2065CA75CLL);
}

void sub_2065CA7E8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *caulk::alloc::base_allocator::formatter::emit_string(_QWORD *this, char *a2)
{
  char *v2;
  _QWORD **v3;
  char *v4;
  char *v5;
  char *v6;
  size_t v7;

  if (*a2)
  {
    v2 = a2;
    v3 = (_QWORD **)this;
    while (1)
    {
      caulk::alloc::base_allocator::formatter::check_line_start(v3);
      v4 = strchr(v2, 10);
      if (!v4)
        break;
      v5 = v4;
      v6 = v4 + 1;
      this = (_QWORD *)std::ostream::write();
      *((_BYTE *)v3 + 12) = 1;
      v2 = v6;
      if (!v5[1])
        return this;
    }
    v7 = strlen(v2);
    return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(*v3, (uint64_t)v2, v7);
  }
  return this;
}

_QWORD *caulk::alloc::base_allocator::formatter::check_line_start(_QWORD *this)
{
  uint64_t v1;
  int v2;
  unsigned int v3;
  _QWORD *v4;
  char v5;

  if (*((_BYTE *)this + 12))
  {
    v1 = (uint64_t)this;
    v2 = *((_DWORD *)this + 2);
    if (v2 >= 1)
    {
      v3 = v2 + 1;
      do
      {
        v4 = *(_QWORD **)v1;
        v5 = 32;
        this = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)&v5, 1);
        --v3;
      }
      while (v3 > 1);
    }
    *(_BYTE *)(v1 + 12) = 0;
  }
  return this;
}

_QWORD *caulk::alloc::global_page_cache::describe(caulk::alloc::details::caching_page_allocator_base **this, caulk::alloc::base_allocator::formatter *a2)
{
  caulk::alloc::base_allocator::formatter::emit_string(a2, "[global] ");
  caulk::alloc::base_allocator::formatter::emit_string(a2, "[ref] ");
  return caulk::alloc::details::caching_page_allocator_base::describe(*this, a2);
}

void std::__tree<std::__value_type<unsigned long long,unsigned int>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned int>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned int>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned long long,unsigned int>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned int>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned int>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned long long,unsigned int>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned int>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned int>>>::destroy(a1[1]);
    operator delete(a1);
  }
}

void std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2E3D8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2E3D8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(uint64_t a1, int *a2, uint64_t *a3, uint64_t *a4)
{
  return std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 24), *a2, *a3, *a4);
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc19allocator_enumerateINS0_18tracking_allocatorINS0_17global_page_cacheEEEEEvRT_NS_10option_setINS0_12region_usageEjEERKNSt3__18functionIFvS8_NS0_5blockEEEEEUlS8_mmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target_type()
{
}

void std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

__n128 std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_24BF2E2D0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24BF2E2D0;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t **std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(uint64_t **result, int *a2, uint64_t a3)
{
  int v3;
  uint64_t **v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD **v10;
  uint64_t *v11;

  v3 = *a2;
  if ((*a2 - 3) >= 0xFFFFFFFE)
  {
    v4 = result;
    v5 = *(_QWORD *)(a3 + 8);
    v6 = v5 & 0x1FFFFFFFFFFFFFFFLL;
    v7 = (v5 >> 4) & 0x1FFFFFFFFFFFFFFLL;
    if (v6 <= 0xF423F)
      v8 = ((v6 + 1023) >> 10) | 0x2000000000000000;
    else
      v8 = ((v6 + 0xFFFFF) >> 20) | 0x4000000000000000;
    if (v7 >= 0x271)
      v9 = v8;
    else
      v9 = v6;
    v11 = (uint64_t *)(v9 | ((unint64_t)(v3 == 2) << 63));
    result = std::__tree<std::__value_type<unsigned long long,unsigned int>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned int>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t **)result[1], (unint64_t)v11, &v11);
    ++*((_DWORD *)result + 10);
    if (v3 == 2)
    {
      v10 = v4 + 4;
    }
    else
    {
      ++*v4[2];
      v10 = v4 + 3;
    }
    **v10 += v6;
  }
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc14base_allocator9formatter24summarize_blocks_by_sizeINS0_18tracking_allocatorINS0_17global_page_cacheEEEEEvRT_mEUlNS0_12region_usageENS0_5blockEE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target_type()
{
}

uint64_t **std::__tree<std::__value_type<unsigned long long,unsigned int>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned int>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t **a1, unint64_t a2, uint64_t **a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = v5[4];
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x30uLL);
    v7[4] = *a3;
    *((_DWORD *)v7 + 10) = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

_QWORD *caulk::alloc::base_allocator::formatter::print_allocator<caulk::alloc::global_page_cache>(caulk::alloc::base_allocator::formatter *a1, uint64_t a2, caulk::alloc::details::caching_page_allocator_base **this)
{
  std::string::size_type v5;
  _QWORD *result;
  std::string __p;

  *((_DWORD *)a1 + 2) += 2;
  if (*(char *)(a2 + 23) < 0)
  {
    v5 = *(_QWORD *)(a2 + 8);
    if (!v5)
      goto LABEL_8;
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, v5);
  }
  else
  {
    if (!*(_BYTE *)(a2 + 23))
      goto LABEL_8;
    __p = *(std::string *)a2;
  }
  caulk::alloc::base_allocator::formatter::operator<<<std::string>(a1, (uint64_t)&__p);
  caulk::alloc::base_allocator::formatter::emit_string(a1, ": ");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_8:
  result = caulk::alloc::global_page_cache::describe(this, a1);
  *((_DWORD *)a1 + 2) -= 2;
  return result;
}

void sub_2065CAF00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *caulk::alloc::base_allocator::formatter::operator<<<std::string>(_QWORD *a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;

  caulk::alloc::base_allocator::formatter::check_line_start(a1);
  v4 = *(char *)(a2 + 23);
  if (v4 >= 0)
    v5 = a2;
  else
    v5 = *(_QWORD *)a2;
  if (v4 >= 0)
    v6 = *(unsigned __int8 *)(a2 + 23);
  else
    v6 = *(_QWORD *)(a2 + 8);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)*a1, v5, v6);
  return a1;
}

_QWORD *caulk::alloc::base_allocator::formatter::hexdump(caulk::alloc::base_allocator::formatter *this, char *a2, unint64_t a3)
{
  unint64_t v5;
  uint64_t v6;
  unsigned int v7;
  _QWORD *v8;
  uint64_t v9;
  char v11;

  v5 = a3 >> 2;
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  v6 = *(_QWORD *)this + *(_QWORD *)(**(_QWORD **)this - 24);
  *(_DWORD *)(v6 + 8) = *(_DWORD *)(v6 + 8) & 0xFFFFFFB5 | 8;
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  std::operator<<[abi:ne180100]<std::char_traits<char>>(*(_QWORD **)this, 48);
  v7 = v5 + 1;
  do
  {
    caulk::alloc::base_allocator::formatter::check_line_start(this);
    v8 = *(_QWORD **)this;
    v11 = 32;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)&v11, 1);
    caulk::alloc::base_allocator::formatter::check_line_start(this);
    *(_QWORD *)(*(_QWORD *)this + *(_QWORD *)(**(_QWORD **)this - 24) + 24) = 8;
    a2 += 4;
    caulk::alloc::base_allocator::formatter::check_line_start(this);
    std::ostream::operator<<();
    --v7;
  }
  while (v7 > 1);
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  v9 = *(_QWORD *)this + *(_QWORD *)(**(_QWORD **)this - 24);
  *(_DWORD *)(v9 + 8) = *(_DWORD *)(v9 + 8) & 0xFFFFFFB5 | 2;
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  std::operator<<[abi:ne180100]<std::char_traits<char>>(*(_QWORD **)this, 32);
  return caulk::alloc::base_allocator::formatter::emit_string(this, "\n");
}

void std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2D468;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2D468;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(uint64_t a1, int *a2, uint64_t *a3, uint64_t *a4)
{
  return std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 24), *a2, *a3, *a4);
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc19allocator_enumerateINS0_16bitmap_allocatorINS0_18embed_block_memoryELm16368ELm256ELm6EEEEEvRT_NS_10option_setINS0_12region_usageEjEERKNSt3__18functionIFvS8_NS0_5blockEEEEEUlS8_mmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target_type()
{
}

void std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

__n128 std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_24BF2CF98;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24BF2CF98;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t **std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(uint64_t **result, int *a2, uint64_t a3)
{
  int v3;
  uint64_t **v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD **v10;
  uint64_t *v11;

  v3 = *a2;
  if ((*a2 - 3) >= 0xFFFFFFFE)
  {
    v4 = result;
    v5 = *(_QWORD *)(a3 + 8);
    v6 = v5 & 0x1FFFFFFFFFFFFFFFLL;
    v7 = (v5 >> 4) & 0x1FFFFFFFFFFFFFFLL;
    if (v6 <= 0xF423F)
      v8 = ((v6 + 1023) >> 10) | 0x2000000000000000;
    else
      v8 = ((v6 + 0xFFFFF) >> 20) | 0x4000000000000000;
    if (v7 >= 0x271)
      v9 = v8;
    else
      v9 = v6;
    v11 = (uint64_t *)(v9 | ((unint64_t)(v3 == 2) << 63));
    result = std::__tree<std::__value_type<unsigned long long,unsigned int>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned int>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t **)result[1], (unint64_t)v11, &v11);
    ++*((_DWORD *)result + 10);
    if (v3 == 2)
    {
      v10 = v4 + 4;
    }
    else
    {
      ++*v4[2];
      v10 = v4 + 3;
    }
    **v10 += v6;
  }
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc14base_allocator9formatter24summarize_blocks_by_sizeINS0_16bitmap_allocatorINS0_18embed_block_memoryELm16368ELm256ELm6EEEEEvRT_mEUlNS0_12region_usageENS0_5blockEE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target_type()
{
}

_QWORD *std::operator<<[abi:ne180100]<std::char_traits<char>>(_QWORD *a1, char a2)
{
  char *v4;
  const std::locale::facet *v5;
  int v6;
  std::locale v8;

  v4 = (char *)a1 + *(_QWORD *)(*a1 - 24);
  if (*((_DWORD *)v4 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
    v5 = std::locale::use_facet(&v8, MEMORY[0x24BEDB350]);
    v6 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 32);
    std::locale::~locale(&v8);
    *((_DWORD *)v4 + 36) = v6;
  }
  *((_DWORD *)v4 + 36) = a2;
  return a1;
}

void sub_2065CB384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

void caulk::alloc::base_allocator::formatter::print_allocator<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::base_allocator::formatter *this, uint64_t a2, uint64_t a3)
{
  std::string::size_type v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  char v18;
  _QWORD *v19;
  _QWORD **v20;
  BOOL v21;
  std::string __p;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD **v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE v31[24];
  _BYTE *v32;
  _QWORD v33[3];
  _QWORD *v34;
  int v35;
  _QWORD v36[3];
  _QWORD *v37;
  _BYTE v38[24];
  _BYTE *v39;
  char v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  *((_DWORD *)this + 2) += 2;
  if (*(char *)(a2 + 23) < 0)
  {
    v5 = *(_QWORD *)(a2 + 8);
    if (!v5)
      goto LABEL_8;
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, v5);
  }
  else
  {
    if (!*(_BYTE *)(a2 + 23))
      goto LABEL_8;
    __p = *(std::string *)a2;
  }
  caulk::alloc::base_allocator::formatter::operator<<<std::string>(this, (uint64_t)&__p);
  caulk::alloc::base_allocator::formatter::emit_string(this, ": ");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_8:
  caulk::alloc::base_allocator::formatter::emit_string(this, "bitmap_allocator @ ");
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(this, ", block size ");
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(this, ", slot size ");
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(this, ", ");
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(this, " slots, ");
  caulk::alloc::base_allocator::formatter::emit_string(this, "max size ");
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(this, ", memory ");
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(this, ":");
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(this, "\n");
  *((_DWORD *)this + 2) += 2;
  caulk::alloc::base_allocator::formatter::emit_string(this, "state bits:  ");
  caulk::alloc::base_allocator::formatter::hexdump(this, (char *)(a3 + 8), 0x100uLL);
  caulk::alloc::base_allocator::formatter::emit_string(this, "search hint: ");
  atomic_load((unsigned int *)(a3 + 4));
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(this, "\n");
  v27 = 0;
  v28 = 0;
  v25 = 0;
  v26 = &v27;
  v23 = 0;
  v24 = 0;
  v6 = operator new(0x28uLL);
  *v6 = &off_24BF2CF40;
  v6[1] = &v26;
  v6[2] = &v25;
  v6[3] = &v24;
  v6[4] = &v23;
  v32 = v6;
  v33[0] = &off_24BF2D410;
  v33[1] = v31;
  v34 = v33;
  v35 = 7;
  v7 = v36;
  v36[0] = &off_24BF2E1C8;
  v36[1] = caulk::alloc::introspector::local_reader;
  v8 = v38;
  v37 = v36;
  std::__function::__value_func<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v38, (uint64_t)v33);
  v40 = 1;
  v9 = v34;
  if (v34 == v33)
  {
    v10 = 4;
    v9 = v33;
  }
  else
  {
    if (!v34)
      goto LABEL_13;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_13:
  v29 = 16368;
  v30 = a3;
  if (!v37)
    std::__throw_bad_function_call[abi:ne180100]();
  v11 = (*(uint64_t (**)(_QWORD *, uint64_t *, uint64_t *))(*v37 + 48))(v37, &v30, &v29);
  caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::introspect(v11, a3, (uint64_t)&v35);
  if (v39 == v38)
  {
    v12 = 4;
  }
  else
  {
    if (!v39)
      goto LABEL_19;
    v12 = 5;
    v8 = v39;
  }
  (*(void (**)(_QWORD *))(*v8 + 8 * v12))(v8);
LABEL_19:
  if (v37 == v36)
  {
    v13 = 4;
  }
  else
  {
    if (!v37)
      goto LABEL_24;
    v13 = 5;
    v7 = v37;
  }
  (*(void (**)(_QWORD *))(*v7 + 8 * v13))(v7);
LABEL_24:
  v14 = v32;
  if (v32 == v31)
  {
    v15 = 4;
    v14 = v31;
  }
  else
  {
    if (!v32)
      goto LABEL_29;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_29:
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  v16 = *(_QWORD *)this + *(_QWORD *)(**(_QWORD **)this - 24);
  *(_DWORD *)(v16 + 8) = *(_DWORD *)(v16 + 8) & 0xFFFFFFB5 | 2;
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(this, " allocations for ");
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(this, " bytes");
  caulk::alloc::base_allocator::formatter::emit_string(this, " (");
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(this, "%)");
  caulk::alloc::base_allocator::formatter::emit_string(this, "; ");
  caulk::alloc::base_allocator::formatter::check_line_start(this);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(this, " bytes free\n");
  if (v28)
  {
    caulk::alloc::base_allocator::formatter::emit_string(this, "sizes:");
    v17 = v26;
    if (v26 != &v27)
    {
      v18 = 0;
      do
      {
        if ((v18 & 1) == 0 && (v17[4] & 0x8000000000000000) != 0)
        {
          caulk::alloc::base_allocator::formatter::emit_string(this, "\n");
          caulk::alloc::base_allocator::formatter::emit_string(this, "free sizes:");
          v18 = 1;
        }
        caulk::alloc::base_allocator::formatter::emit_string(this, " ");
        caulk::alloc::base_allocator::formatter::check_line_start(this);
        std::ostream::operator<<();
        caulk::alloc::base_allocator::formatter::emit_string(this, caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::sizeLabels[(v17[4] >> 61) & 3]);
        caulk::alloc::base_allocator::formatter::emit_string(this, "[");
        caulk::alloc::base_allocator::formatter::check_line_start(this);
        std::ostream::operator<<();
        caulk::alloc::base_allocator::formatter::emit_string(this, "]");
        v19 = (_QWORD *)v17[1];
        if (v19)
        {
          do
          {
            v20 = (_QWORD **)v19;
            v19 = (_QWORD *)*v19;
          }
          while (v19);
        }
        else
        {
          do
          {
            v20 = (_QWORD **)v17[2];
            v21 = *v20 == v17;
            v17 = v20;
          }
          while (!v21);
        }
        v17 = v20;
      }
      while (v20 != &v27);
    }
    caulk::alloc::base_allocator::formatter::emit_string(this, "\n");
  }
  std::__tree<std::__value_type<unsigned long long,unsigned int>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned int>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned int>>>::destroy(v27);
  *((_DWORD *)this + 2) -= 4;
}

void sub_2065CB9D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, _QWORD *a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40)
{
  std::__tree<std::__value_type<unsigned long long,unsigned int>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned int>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned int>>>::destroy(a20);
  _Unwind_Resume(a1);
}

void std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2D410;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2D410;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(uint64_t a1, int *a2, uint64_t *a3, uint64_t *a4)
{
  return std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 24), *a2, *a3, *a4);
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc19allocator_enumerateINS0_16bitmap_allocatorINS0_18embed_block_memoryELm16368ELm16ELm6EEEEEvRT_NS_10option_setINS0_12region_usageEjEERKNSt3__18functionIFvS8_NS0_5blockEEEEEUlS8_mmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target_type()
{
}

void std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

__n128 std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_24BF2CF40;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24BF2CF40;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t **std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(uint64_t **result, int *a2, uint64_t a3)
{
  int v3;
  uint64_t **v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD **v10;
  uint64_t *v11;

  v3 = *a2;
  if ((*a2 - 3) >= 0xFFFFFFFE)
  {
    v4 = result;
    v5 = *(_QWORD *)(a3 + 8);
    v6 = v5 & 0x1FFFFFFFFFFFFFFFLL;
    v7 = (v5 >> 4) & 0x1FFFFFFFFFFFFFFLL;
    if (v6 <= 0xF423F)
      v8 = ((v6 + 1023) >> 10) | 0x2000000000000000;
    else
      v8 = ((v6 + 0xFFFFF) >> 20) | 0x4000000000000000;
    if (v7 >= 0x271)
      v9 = v8;
    else
      v9 = v6;
    v11 = (uint64_t *)(v9 | ((unint64_t)(v3 == 2) << 63));
    result = std::__tree<std::__value_type<unsigned long long,unsigned int>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned int>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t **)result[1], (unint64_t)v11, &v11);
    ++*((_DWORD *)result + 10);
    if (v3 == 2)
    {
      v10 = v4 + 4;
    }
    else
    {
      ++*v4[2];
      v10 = v4 + 3;
    }
    **v10 += v6;
  }
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc14base_allocator9formatter24summarize_blocks_by_sizeINS0_16bitmap_allocatorINS0_18embed_block_memoryELm16368ELm16ELm6EEEEEvRT_mEUlNS0_12region_usageENS0_5blockEE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>(caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target_type()
{
}

void caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,16128ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>>,caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>::deallocate(uint64_t a1, caulk::mach::vm_block *a2, unint64_t a3)
{
  uint64_t owner;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned __int8 v11;
  caulk::alloc::base_allocator *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unsigned int *v16;
  unint64_t v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned __int8 v21;
  uint64_t v22;
  unsigned __int128 *v23;
  uint64_t v24;
  uint64_t v25;

  if (a3 <= 0x3F0)
  {
    v24 = a1 + 976;
    v25 = a1 + 1136;
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 1136));
    owner = caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::find_owner(&v24, (unint64_t)a2);
    if (owner)
    {
      v7 = owner;
      v8 = (unsigned int *)(owner + 16);
      caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::deallocate((caulk::alloc::base_allocator *)(owner + 16), (unint64_t)a2, a3);
      v9 = atomic_load((unsigned int *)(v7 + 4));
      if (v9 == -1)
      {
        v10 = atomic_load(v8);
        if (v10 >= 0xFC)
        {
          do
            v11 = __ldaxr((unsigned __int8 *)v7);
          while (__stlxr(1u, (unsigned __int8 *)v7));
          if ((v11 & 1) == 0)
          {
            v22 = v7;
            caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::emplace<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>((unsigned __int128 *)(a1 + 1264), v7 + 288, &v22);
            atomic_store(0, (unsigned int *)(v7 + 4));
            atomic_store(0, (unsigned __int8 *)v7);
          }
        }
      }
      caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal((unsigned __int128 *)v25);
      return;
    }
LABEL_25:
    caulk::alloc::base_allocator::bad_dealloc((caulk::alloc::base_allocator *)owner);
  }
  if ((a3 - 1009) >> 4 > 0x3B0)
  {
    if ((caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::remove(a1 + 16, (uint64_t)a2) & 1) != 0)
    {
      caulk::alloc::details::caching_page_allocator_base::deallocate(*(uint64_t **)a1, a2, a3);
      return;
    }
    _os_assert_log();
    owner = _os_crash();
    __break(1u);
    goto LABEL_25;
  }
  v22 = a1 + 368;
  v23 = (unsigned __int128 *)(a1 + 528);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 528));
  v12 = (caulk::alloc::base_allocator *)caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::find_owner(&v22, (unint64_t)a2);
  if (!v12)
    caulk::alloc::base_allocator::bad_dealloc(0);
  v13 = (uint64_t)v12;
  v14 = (unint64_t)v12 + 256;
  if ((caulk::alloc::base_allocator *)((char *)v12 + 256) > a2
    || (v15 = (unint64_t)a2 - v14, (((unint64_t)a2 - v14) >> 8) >= 0x3FuLL))
  {
    caulk::alloc::base_allocator::bad_dealloc(v12);
  }
  v16 = (unsigned int *)((char *)v12 + 16);
  v17 = (a3 + 255) >> 8;
  v24 = (uint64_t)v12 + 24;
  v25 = 2;
  caulk::alloc::detail::state_bit_span::deallocate(&v24, v15 >> 8, v17);
  do
    v18 = __ldaxr(v16);
  while (__stlxr(v18 + v17, v16));
  v19 = atomic_load((unsigned int *)(v13 + 4));
  if (v19 == -1)
  {
    v20 = atomic_load(v16);
    if (v20 >= 0x10)
    {
      do
        v21 = __ldaxr((unsigned __int8 *)v13);
      while (__stlxr(1u, (unsigned __int8 *)v13));
      if ((v21 & 1) == 0)
      {
        v24 = v13;
        caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::emplace<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>((unsigned __int128 *)(a1 + 656), v14, &v24);
        atomic_store(0, (unsigned int *)(v13 + 4));
        atomic_store(0, (unsigned __int8 *)v13);
      }
    }
  }
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v23);
}

void sub_2065CBF34(_Unwind_Exception *a1)
{
  unsigned __int128 *v1;

  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v1);
  _Unwind_Resume(a1);
}

unsigned __int128 *caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::emplace<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>(unsigned __int128 *result, unint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  unsigned __int128 *v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  int v10;
  int value;
  uint64_t i;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unsigned __int128 *v17;
  unint64_t *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  char v27;
  char v28;
  unint64_t v29;
  unint64_t v30;
  char v31;
  int v32;
  char v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v37;

  if (*(_QWORD *)result >= a2 || (v4 = (uint64_t)result, *((_QWORD *)result + 14) <= a2))
  {
    __break(1u);
  }
  else
  {
    v5 = result + 10;
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal(result + 10);
    v37 = a2;
    v6 = (_QWORD *)caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>(v4, &v37, 0);
    if (*v6 != a2)
    {
      v8 = v6;
      v9 = v7;
      v10 = 0;
      value = 0;
      for (i = 1; i != 4; ++i)
      {
        if (i == 1)
        {
          caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::random_engine();
          value = caulk::multi_simple_random<unsigned int,4ul,std::uniform_int_distribution<unsigned int>,std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>::next_value((uint64_t)&caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::random_engine(void)::engine);
          v10 = 3;
        }
        if ((v10 & ~value) != 0)
          break;
        v10 *= 4;
      }
      v13 = 0;
      v14 = *(_QWORD *)(v4 + 176);
      while (1)
      {
        v15 = *(_QWORD *)&caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::node_sizes[8 * v13];
        if (v15 >= *(_QWORD *)&caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::node_sizes[8 * i - 8])
          break;
        if (++v13 == 5)
        {
          v16 = 0;
          goto LABEL_19;
        }
      }
      v17 = (unsigned __int128 *)(v14 + 64 + 32 * v13);
      v18 = caulk::concurrent::stack<caulk::alloc::free_block,caulk::concurrent::intrusive_single_link_node<caulk::alloc::free_block>>::pop(v17);
      if (v18)
      {
        v16 = (unint64_t)v18;
        v19 = (unint64_t *)(v17 + 1);
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
      }
      else
      {
        v16 = caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>::allocate(v14, v15);
      }
      v5 = (unsigned __int128 *)(v4 + 160);
LABEL_19:
      *(_BYTE *)(v16 + 16) = i;
      *(_WORD *)(v16 + 17) = 1;
      *(_BYTE *)(v16 + 19) = i;
      *(_QWORD *)v16 = a2;
      *(_QWORD *)(v16 + 8) = 0;
      *(_QWORD *)(v16 + 8) = *a3;
      *(_QWORD *)(v16 + 32) = 0;
      *(_QWORD *)(v16 + 40) = 0;
      *(_QWORD *)(v16 + 24) = 0;
      if ((_BYTE)i)
      {
        v21 = (unint64_t *)(v16 + 40);
        v22 = i;
        do
        {
          atomic_store(0, v21 - 1);
          atomic_store(0, v21);
          v21 += 2;
          --v22;
        }
        while (v22);
      }
      v23 = 0;
      __dmb(0xBu);
      while (1)
      {
        while (*v8 != *(_QWORD *)v16)
        {
          v24 = &v8[2 * v23 + 4];
          v25 = atomic_load(v24);
          if ((v25 & 2) != 0)
          {
            caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(v4, v23, (unint64_t)v8, v25 & 0xFFFFFFFFFFFFFFFCLL);
          }
          else
          {
            atomic_store(v9, (unint64_t *)(v16 + 16 * v23 + 32));
            v26 = __ldaxr(v24);
            if (v26 == v9)
            {
              if (!__stlxr(v16, v24))
              {
                v35 = v16;
                goto LABEL_42;
              }
            }
            else
            {
              __clrex();
            }
            if ((v26 & 2) != 0)
              caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(v4, v23, (unint64_t)v8, v26 & 0xFFFFFFFFFFFFFFFCLL);
            v27 = atomic_load(v24);
            if ((v27 & 1) != 0)
            {
              do
              {
                v8 = (_QWORD *)atomic_load(&v8[2 * v23 + 5]);
                v28 = atomic_load(&v8[2 * v23 + 4]);
              }
              while ((v28 & 1) != 0);
            }
          }
          v29 = *(_QWORD *)v16;
          while (1)
          {
            v30 = atomic_load(&v8[2 * v23 + 4]);
            v9 = v30 & 0xFFFFFFFFFFFFFFFCLL;
            if (v29 < *(_QWORD *)(v30 & 0xFFFFFFFFFFFFFFFCLL))
              break;
            v31 = atomic_load((unint64_t *)(v9 + 32));
            if ((v31 & 1) != 0)
            {
              v8 = (_QWORD *)caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::try_flag_node(v4, v23, (unint64_t)v8, v9);
              if (!v32)
                caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(v4, v23, (unint64_t)v8, v9);
            }
            else
            {
              v8 = (_QWORD *)v9;
            }
          }
        }
        v35 = 0;
LABEL_42:
        if (!(v35 | v23))
          break;
        v33 = atomic_load((unint64_t *)(v16 + 32));
        if ((v33 & 1) != 0)
          return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v5);
        if (++v23 == i)
          return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v5);
        v37 = a2;
        v8 = (_QWORD *)caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>(v4, &v37, v23);
        v9 = v34;
      }
      caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>::deallocate(*(caulk::alloc::base_allocator **)(v4 + 176), (unint64_t *)v16, *(_QWORD *)&caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::node_sizes[8 * *(unsigned __int8 *)(v16 + 16) - 8]);
    }
    return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v5);
  }
  return result;
}

void caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::random_engine()
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      caulk::multi_simple_random<unsigned int,4ul,std::uniform_int_distribution<unsigned int>,std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>::multi_simple_random((uint64_t)&caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::random_engine(void)::engine);
    }
  }
}

void sub_2065CC320(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_QWORD *caulk::alloc::detail::state_bit_span::deallocate(_QWORD *this, unsigned int a2, unsigned int a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  char v8;
  unsigned int v9;
  int v10;
  int v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  _QWORD v18[3];

  v4 = a2 >> 5;
  v5 = (unint64_t *)this[1];
  if ((unint64_t)v5 > v4)
  {
    v5 = (unint64_t *)(*this + 8 * v4);
    v6 = atomic_load(v5);
    v7 = 1 << (a2 & 0x1F | 0x20);
    if ((v6 & v7) != 0)
    {
      v8 = a2 & 0x1F;
      v9 = 32 - (a2 & 0x1F);
      v10 = v9 >= a3 ? a3 : 32 - (a2 & 0x1F);
      if (v10)
      {
        v11 = 0;
        v12 = v6 & ~v7;
        v13 = (unint64_t *)(*this + 8 * v4 + 8);
        do
        {
          v14 = 0xFFFFFFFFFFFFFFFFLL >> ~(v10 - 1) << v8;
          v3 = (v14 | (v14 << 32)) & v12;
          if (v3 != v14)
            break;
          LODWORD(v3) = v11 + 1;
          v18[v11] = ~(v14 | v7);
          if (a3 <= v9)
            goto LABEL_16;
          if (v13 == (unint64_t *)(*this + 8 * this[1]))
            break;
          v7 = 0;
          v8 = 0;
          a3 -= v10;
          v12 = atomic_load(v13);
          v9 = 32;
          v10 = a3 >= 0x20 ? 32 : a3;
          ++v13;
          ++v11;
        }
        while (v10);
      }
    }
  }
  __break(1u);
LABEL_16:
  while ((_DWORD)v3)
  {
    LODWORD(v3) = v3 - 1;
    v15 = v18[v3];
    v16 = &v5[v3];
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 & v15, v16));
  }
  return this;
}

_QWORD *caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::deallocate(caulk::alloc::base_allocator *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v5;
  unint64_t v6;
  _QWORD *result;
  unsigned int v8;
  _QWORD v9[2];

  if ((unint64_t)a1 + 272 > a2 || (v3 = a2 - ((_QWORD)a1 + 272), ((v3 >> 5) & 0x7FFFFFFF) > 0x1F6))
    caulk::alloc::base_allocator::bad_dealloc(a1);
  v5 = v3 >> 4;
  if (!a3)
    a3 = caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::size((uint64_t)a1, a2);
  v6 = (unint64_t)(a3 + 15) >> 4;
  v9[0] = (char *)a1 + 8;
  v9[1] = 32;
  result = caulk::alloc::detail::state_bit_span::deallocate(v9, v5, v6);
  do
    v8 = __ldaxr((unsigned int *)a1);
  while (__stlxr(v8 + v6, (unsigned int *)a1));
  if (*((_DWORD *)a1 + 1) > v5)
    *((_DWORD *)a1 + 1) = v5;
  return result;
}

unsigned __int128 *caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::emplace<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>(unsigned __int128 *result, unint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  unsigned __int128 *v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  int v10;
  int value;
  uint64_t i;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unsigned __int128 *v17;
  unint64_t *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  char v27;
  char v28;
  unint64_t v29;
  unint64_t v30;
  char v31;
  int v32;
  char v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v37;

  if (*(_QWORD *)result >= a2 || (v4 = (uint64_t)result, *((_QWORD *)result + 14) <= a2))
  {
    __break(1u);
  }
  else
  {
    v5 = result + 10;
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal(result + 10);
    v37 = a2;
    v6 = (_QWORD *)caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>(v4, &v37, 0);
    if (*v6 != a2)
    {
      v8 = v6;
      v9 = v7;
      v10 = 0;
      value = 0;
      for (i = 1; i != 4; ++i)
      {
        if (i == 1)
        {
          caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::random_engine();
          value = caulk::multi_simple_random<unsigned int,4ul,std::uniform_int_distribution<unsigned int>,std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>::next_value((uint64_t)&caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::random_engine(void)::engine);
          v10 = 3;
        }
        if ((v10 & ~value) != 0)
          break;
        v10 *= 4;
      }
      v13 = 0;
      v14 = *(_QWORD *)(v4 + 176);
      while (1)
      {
        v15 = *(_QWORD *)&caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::node_sizes[8 * v13];
        if (v15 >= *(_QWORD *)&caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::node_sizes[8 * i - 8])
          break;
        if (++v13 == 5)
        {
          v16 = 0;
          goto LABEL_19;
        }
      }
      v17 = (unsigned __int128 *)(v14 + 64 + 32 * v13);
      v18 = caulk::concurrent::stack<caulk::alloc::free_block,caulk::concurrent::intrusive_single_link_node<caulk::alloc::free_block>>::pop(v17);
      if (v18)
      {
        v16 = (unint64_t)v18;
        v19 = (unint64_t *)(v17 + 1);
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
      }
      else
      {
        v16 = caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>::allocate(v14, v15);
      }
      v5 = (unsigned __int128 *)(v4 + 160);
LABEL_19:
      *(_BYTE *)(v16 + 16) = i;
      *(_WORD *)(v16 + 17) = 1;
      *(_BYTE *)(v16 + 19) = i;
      *(_QWORD *)v16 = a2;
      *(_QWORD *)(v16 + 8) = 0;
      *(_QWORD *)(v16 + 8) = *a3;
      *(_QWORD *)(v16 + 32) = 0;
      *(_QWORD *)(v16 + 40) = 0;
      *(_QWORD *)(v16 + 24) = 0;
      if ((_BYTE)i)
      {
        v21 = (unint64_t *)(v16 + 40);
        v22 = i;
        do
        {
          atomic_store(0, v21 - 1);
          atomic_store(0, v21);
          v21 += 2;
          --v22;
        }
        while (v22);
      }
      v23 = 0;
      __dmb(0xBu);
      while (1)
      {
        while (*v8 != *(_QWORD *)v16)
        {
          v24 = &v8[2 * v23 + 4];
          v25 = atomic_load(v24);
          if ((v25 & 2) != 0)
          {
            caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(v4, v23, (unint64_t)v8, v25 & 0xFFFFFFFFFFFFFFFCLL);
          }
          else
          {
            atomic_store(v9, (unint64_t *)(v16 + 16 * v23 + 32));
            v26 = __ldaxr(v24);
            if (v26 == v9)
            {
              if (!__stlxr(v16, v24))
              {
                v35 = v16;
                goto LABEL_42;
              }
            }
            else
            {
              __clrex();
            }
            if ((v26 & 2) != 0)
              caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(v4, v23, (unint64_t)v8, v26 & 0xFFFFFFFFFFFFFFFCLL);
            v27 = atomic_load(v24);
            if ((v27 & 1) != 0)
            {
              do
              {
                v8 = (_QWORD *)atomic_load(&v8[2 * v23 + 5]);
                v28 = atomic_load(&v8[2 * v23 + 4]);
              }
              while ((v28 & 1) != 0);
            }
          }
          v29 = *(_QWORD *)v16;
          while (1)
          {
            v30 = atomic_load(&v8[2 * v23 + 4]);
            v9 = v30 & 0xFFFFFFFFFFFFFFFCLL;
            if (v29 < *(_QWORD *)(v30 & 0xFFFFFFFFFFFFFFFCLL))
              break;
            v31 = atomic_load((unint64_t *)(v9 + 32));
            if ((v31 & 1) != 0)
            {
              v8 = (_QWORD *)caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::try_flag_node(v4, v23, (unint64_t)v8, v9);
              if (!v32)
                caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(v4, v23, (unint64_t)v8, v9);
            }
            else
            {
              v8 = (_QWORD *)v9;
            }
          }
        }
        v35 = 0;
LABEL_42:
        if (!(v35 | v23))
          break;
        v33 = atomic_load((unint64_t *)(v16 + 32));
        if ((v33 & 1) != 0)
          return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v5);
        if (++v23 == i)
          return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v5);
        v37 = a2;
        v8 = (_QWORD *)caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>(v4, &v37, v23);
        v9 = v34;
      }
      caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>::deallocate(*(caulk::alloc::base_allocator **)(v4 + 176), (unint64_t *)v16, *(_QWORD *)&caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::node_sizes[8 * *(unsigned __int8 *)(v16 + 16) - 8]);
    }
    return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v5);
  }
  return result;
}

void caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::random_engine()
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      caulk::multi_simple_random<unsigned int,4ul,std::uniform_int_distribution<unsigned int>,std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>::multi_simple_random((uint64_t)&caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::random_engine(void)::engine);
    }
  }
}

void sub_2065CC8A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t *caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,16128ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>>,caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>::allocate(uint64_t a1, unint64_t a2, unint64_t a3)
{
  unsigned __int128 *v3;
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char v18;
  unint64_t *v19;
  uint64_t v20;
  unsigned __int8 v21;
  uint64_t v22;
  unint64_t v23;
  char v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  char v30;
  unsigned __int8 v31;
  unint64_t v32;
  unint64_t v34;
  unsigned __int8 v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char v39;
  unint64_t *v40;
  uint64_t v41;
  unsigned __int8 v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  char v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  char v52;
  unsigned __int8 v53;
  unint64_t v54;
  unint64_t v56;
  unsigned __int8 v57;
  unsigned __int128 *v59;
  unsigned __int128 *v60;
  unsigned __int128 *v61;
  uint64_t v62;
  __int128 v63;

  v4 = a3;
  if (a2 <= 0x3F0 && a3 <= 0x10)
  {
    v62 = a2;
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 1136));
    v3 = (unsigned __int128 *)(a1 + 1264);
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 1424));
    v4 = *(_QWORD *)(a1 + 1552);
    v59 = (unsigned __int128 *)(a1 + 1136);
    v60 = (unsigned __int128 *)(a1 + 1424);
    if (v4)
    {
      *(_QWORD *)&v63 = *(_QWORD *)(a1 + 1552);
      v8 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>(a1 + 1264, &v63, 0);
      if (*(_QWORD *)v8 != v4)
      {
        if (*(_BYTE *)(v7 + 18) == 2)
          v8 = a1 + 1376;
        else
          v8 = v7;
      }
      goto LABEL_19;
    }
LABEL_18:
    v15 = atomic_load((unint64_t *)(a1 + 1296));
    v8 = v15 & 0xFFFFFFFFFFFFFFFCLL;
LABEL_19:
    v16 = a1 + 1376;
    if (a1 + 1376 != v8)
    {
      v17 = v8;
      do
      {
        if (*(_BYTE *)(v17 + 18) != 2)
        {
          v18 = atomic_load((unint64_t *)(v17 + 32));
          if ((v18 & 1) == 0)
          {
            v20 = *(_QWORD *)v17;
            v19 = *(unint64_t **)(v17 + 8);
            do
              v21 = __ldaxr((unsigned __int8 *)v19);
            while (__stlxr(1u, (unsigned __int8 *)v19));
            if ((v21 & 1) == 0)
            {
              v22 = caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::allocate((unsigned int *)v19 + 4, v62);
              if (v22)
                goto LABEL_58;
              atomic_store(0xFFFFFFFF, (unsigned int *)v19 + 1);
              caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove((uint64_t)v3, v20);
              atomic_store(0, (unsigned __int8 *)v19);
            }
          }
        }
        v23 = atomic_load((unint64_t *)(v17 + 32));
        v17 = v23 & 0xFFFFFFFFFFFFFFFCLL;
      }
      while (v16 != (v23 & 0xFFFFFFFFFFFFFFFCLL));
    }
    if (*(_BYTE *)(v8 + 18) == 2 || (v24 = atomic_load((unint64_t *)(v8 + 32)), (v24 & 1) != 0))
    {
      if (v4)
      {
        *(_QWORD *)&v63 = v4;
        v8 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>((uint64_t)v3, &v63, 0);
        if (*(_QWORD *)v8 != v4)
        {
          if (*(_BYTE *)(v25 + 18) == 2)
            v8 = a1 + 1376;
          else
            v8 = v25;
        }
      }
      else
      {
        v26 = atomic_load((unint64_t *)(a1 + 1296));
        v8 = v26 & 0xFFFFFFFFFFFFFFFCLL;
      }
    }
    v27 = atomic_load((unint64_t *)(a1 + 1296));
    v28 = v27 & 0xFFFFFFFFFFFFFFFCLL;
    if (v8 != (v27 & 0xFFFFFFFFFFFFFFFCLL) && v16 != v28)
    {
      do
      {
        if (*(_BYTE *)(v28 + 18) != 2)
        {
          v30 = atomic_load((unint64_t *)(v28 + 32));
          if ((v30 & 1) == 0)
          {
            v20 = *(_QWORD *)v28;
            v19 = *(unint64_t **)(v28 + 8);
            do
              v31 = __ldaxr((unsigned __int8 *)v19);
            while (__stlxr(1u, (unsigned __int8 *)v19));
            if ((v31 & 1) == 0)
            {
              v22 = caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::allocate((unsigned int *)v19 + 4, v62);
              if (v22)
                goto LABEL_58;
              atomic_store(0xFFFFFFFF, (unsigned int *)v19 + 1);
              caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove((uint64_t)v3, v20);
              atomic_store(0, (unsigned __int8 *)v19);
            }
          }
        }
        v32 = atomic_load((unint64_t *)(v28 + 32));
        v28 = v32 & 0xFFFFFFFFFFFFFFFCLL;
      }
      while (v8 != (v32 & 0xFFFFFFFFFFFFFFFCLL) && v16 != v28);
    }
    while (1)
    {
      do
      {
        v19 = caulk::alloc::details::caching_page_allocator_base::allocate(*(caulk::alloc::details::caching_page_allocator_base **)(a1 + 968), 0x4000, 0x10uLL);
        *(_BYTE *)v19 = 0;
        *((_DWORD *)v19 + 1) = 0;
        *((_OWORD *)v19 + 1) = 0u;
        v19[1] = v34;
        v20 = (uint64_t)(v19 + 36);
        *((_OWORD *)v19 + 2) = 0u;
        *((_OWORD *)v19 + 3) = 0u;
        *((_OWORD *)v19 + 4) = 0u;
        *((_OWORD *)v19 + 5) = 0u;
        *((_OWORD *)v19 + 6) = 0u;
        *((_OWORD *)v19 + 7) = 0u;
        *((_OWORD *)v19 + 8) = 0u;
        *((_OWORD *)v19 + 9) = 0u;
        *((_OWORD *)v19 + 10) = 0u;
        *((_OWORD *)v19 + 11) = 0u;
        *((_OWORD *)v19 + 12) = 0u;
        *((_OWORD *)v19 + 13) = 0u;
        *((_OWORD *)v19 + 14) = 0u;
        *((_OWORD *)v19 + 15) = 0u;
        *((_OWORD *)v19 + 16) = 0u;
        v19[34] = 0;
        caulk::alloc::base_allocator::assert_aligned((uint64_t)(v19 + 36), 16);
        *(_OWORD *)(v19 + 31) = 0u;
        *(_OWORD *)(v19 + 29) = 0u;
        *(_OWORD *)(v19 + 27) = 0u;
        *(_OWORD *)(v19 + 25) = 0u;
        *(_OWORD *)(v19 + 23) = 0u;
        *(_OWORD *)(v19 + 21) = 0u;
        *(_OWORD *)(v19 + 19) = 0u;
        *(_OWORD *)(v19 + 17) = 0u;
        *(_OWORD *)(v19 + 15) = 0u;
        *(_OWORD *)(v19 + 13) = 0u;
        *(_OWORD *)(v19 + 11) = 0u;
        *(_OWORD *)(v19 + 9) = 0u;
        *(_OWORD *)(v19 + 7) = 0u;
        *(_OWORD *)(v19 + 5) = 0u;
        *(_OWORD *)(v19 + 3) = 0u;
        *(_OWORD *)(v19 + 33) = 0u;
        atomic_store(0x3EEu, (unsigned int *)v19 + 4);
        atomic_store(0, (unsigned int *)v19 + 5);
        *(_QWORD *)&v63 = v19;
        caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::emplace<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>((unsigned __int128 *)(a1 + 976), (unint64_t)(v19 + 36), &v63);
        *(_QWORD *)&v63 = v19;
        caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::emplace<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>(v3, (unint64_t)(v19 + 36), &v63);
        do
          v35 = __ldaxr((unsigned __int8 *)v19);
        while (__stlxr(1u, (unsigned __int8 *)v19));
      }
      while ((v35 & 1) != 0);
      v22 = caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::allocate((unsigned int *)v19 + 4, v62);
      if (v22)
        break;
      atomic_store(0xFFFFFFFF, (unsigned int *)v19 + 1);
      caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove((uint64_t)v3, v20);
      atomic_store(0, (unsigned __int8 *)v19);
    }
LABEL_58:
    v14 = (unint64_t *)v22;
    *(_QWORD *)(a1 + 1552) = v20;
    atomic_store(0, (unsigned __int8 *)v19);
    caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v60);
    caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v59);
    return v14;
  }
  if ((a2 - 1009) >> 4 > 0x3B0 || a3 > 0x100)
  {
    v14 = caulk::alloc::details::caching_page_allocator_base::allocate(*(caulk::alloc::details::caching_page_allocator_base **)a1, a2, a3);
    if (!v14)
      return v14;
    *(_QWORD *)&v63 = v13;
    *((_QWORD *)&v63 + 1) = v4;
    if ((caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::emplace<caulk::alloc::detail::tracked_block>(a1 + 16, (unint64_t)v14, &v63) & 1) != 0)return v14;
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_18;
  }
  v61 = (unsigned __int128 *)(a1 + 528);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 528));
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 816));
  v9 = *(_QWORD *)(a1 + 944);
  v10 = a2;
  if (v9)
  {
    *(_QWORD *)&v63 = *(_QWORD *)(a1 + 944);
    v12 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>(a1 + 656, &v63, 0);
    if (*(_QWORD *)v12 != v9)
    {
      if (*(_BYTE *)(v11 + 18) == 2)
        v12 = a1 + 768;
      else
        v12 = v11;
    }
  }
  else
  {
    v36 = atomic_load((unint64_t *)(a1 + 688));
    v12 = v36 & 0xFFFFFFFFFFFFFFFCLL;
  }
  v37 = a1 + 768;
  if (a1 + 768 != v12)
  {
    v38 = v12;
    do
    {
      if (*(_BYTE *)(v38 + 18) != 2)
      {
        v39 = atomic_load((unint64_t *)(v38 + 32));
        if ((v39 & 1) == 0)
        {
          v41 = *(_QWORD *)v38;
          v40 = *(unint64_t **)(v38 + 8);
          do
            v42 = __ldaxr((unsigned __int8 *)v40);
          while (__stlxr(1u, (unsigned __int8 *)v40));
          if ((v42 & 1) == 0)
          {
            v43 = caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>::allocate((unsigned int *)v40 + 4, v10);
            if (v43)
              goto LABEL_99;
            atomic_store(0xFFFFFFFF, (unsigned int *)v40 + 1);
            caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove(a1 + 656, v41);
            atomic_store(0, (unsigned __int8 *)v40);
          }
        }
      }
      v44 = atomic_load((unint64_t *)(v38 + 32));
      v38 = v44 & 0xFFFFFFFFFFFFFFFCLL;
    }
    while (v37 != (v44 & 0xFFFFFFFFFFFFFFFCLL));
  }
  v45 = v10;
  if (*(_BYTE *)(v12 + 18) == 2 || (v46 = atomic_load((unint64_t *)(v12 + 32)), (v46 & 1) != 0))
  {
    if (v9)
    {
      *(_QWORD *)&v63 = v9;
      v12 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>(a1 + 656, &v63, 0);
      if (*(_QWORD *)v12 != v9)
      {
        if (*(_BYTE *)(v47 + 18) == 2)
          v12 = a1 + 768;
        else
          v12 = v47;
      }
    }
    else
    {
      v48 = atomic_load((unint64_t *)(a1 + 688));
      v12 = v48 & 0xFFFFFFFFFFFFFFFCLL;
    }
  }
  v49 = atomic_load((unint64_t *)(a1 + 688));
  v50 = v49 & 0xFFFFFFFFFFFFFFFCLL;
  if (v12 != (v49 & 0xFFFFFFFFFFFFFFFCLL) && v37 != v50)
  {
    do
    {
      if (*(_BYTE *)(v50 + 18) != 2)
      {
        v52 = atomic_load((unint64_t *)(v50 + 32));
        if ((v52 & 1) == 0)
        {
          v41 = *(_QWORD *)v50;
          v40 = *(unint64_t **)(v50 + 8);
          do
            v53 = __ldaxr((unsigned __int8 *)v40);
          while (__stlxr(1u, (unsigned __int8 *)v40));
          if ((v53 & 1) == 0)
          {
            v43 = caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>::allocate((unsigned int *)v40 + 4, v45);
            if (v43)
              goto LABEL_99;
            atomic_store(0xFFFFFFFF, (unsigned int *)v40 + 1);
            caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove(a1 + 656, v41);
            atomic_store(0, (unsigned __int8 *)v40);
          }
        }
      }
      v54 = atomic_load((unint64_t *)(v50 + 32));
      v50 = v54 & 0xFFFFFFFFFFFFFFFCLL;
    }
    while (v12 != (v54 & 0xFFFFFFFFFFFFFFFCLL) && v37 != v50);
  }
  while (1)
  {
    do
    {
      v40 = caulk::alloc::details::caching_page_allocator_base::allocate(*(caulk::alloc::details::caching_page_allocator_base **)(a1 + 360), 0x4000, 0x10uLL);
      *(_BYTE *)v40 = 0;
      *((_DWORD *)v40 + 1) = 0;
      v40[1] = v56;
      *((_OWORD *)v40 + 1) = 0u;
      v41 = (uint64_t)(v40 + 32);
      *((_OWORD *)v40 + 2) = 0u;
      *((_OWORD *)v40 + 3) = 0u;
      *((_OWORD *)v40 + 4) = 0u;
      *((_OWORD *)v40 + 5) = 0u;
      *((_OWORD *)v40 + 6) = 0u;
      *((_OWORD *)v40 + 7) = 0u;
      *((_OWORD *)v40 + 8) = 0u;
      *((_OWORD *)v40 + 9) = 0u;
      *((_OWORD *)v40 + 10) = 0u;
      *((_OWORD *)v40 + 11) = 0u;
      *((_OWORD *)v40 + 12) = 0u;
      *((_OWORD *)v40 + 13) = 0u;
      *((_OWORD *)v40 + 14) = 0u;
      v40[30] = 0;
      caulk::alloc::base_allocator::assert_aligned((uint64_t)(v40 + 32), 256);
      v40[3] = 0;
      v40[4] = 0;
      atomic_store(0x3Fu, (unsigned int *)v40 + 4);
      atomic_store(0, (unsigned int *)v40 + 5);
      *(_QWORD *)&v63 = v40;
      caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::emplace<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>((unsigned __int128 *)(a1 + 368), (unint64_t)(v40 + 32), &v63);
      *(_QWORD *)&v63 = v40;
      caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::emplace<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>((unsigned __int128 *)(a1 + 656), (unint64_t)(v40 + 32), &v63);
      do
        v57 = __ldaxr((unsigned __int8 *)v40);
      while (__stlxr(1u, (unsigned __int8 *)v40));
    }
    while ((v57 & 1) != 0);
    v43 = caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>::allocate((unsigned int *)v40 + 4, v45);
    if (v43)
      break;
    atomic_store(0xFFFFFFFF, (unsigned int *)v40 + 1);
    caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove(a1 + 656, v41);
    atomic_store(0, (unsigned __int8 *)v40);
  }
LABEL_99:
  v14 = (unint64_t *)v43;
  *(_QWORD *)(a1 + 944) = v41;
  atomic_store(0, (unsigned __int8 *)v40);
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal((unsigned __int128 *)(a1 + 816));
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v61);
  return v14;
}

void sub_2065CCF84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, unsigned __int128 *a11, unsigned __int128 *a12)
{
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(a12);
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(a11);
  _Unwind_Resume(a1);
}

unint64_t caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,256ul,6ul>::allocate(unsigned int *a1, unint64_t a2)
{
  unint64_t v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;

  if (a2 > 0x4000)
    return 0;
  v3 = (a2 + 255) >> 8;
  v4 = atomic_load(a1);
  if (v4 < v3)
    return 0;
  v5 = caulk::alloc::detail::state_bit_span::allocate((uint64_t)(a1 + 2), 2uLL, 0, 0x3Eu, v3, 0x3Fu);
  if ((v5 & 0x80000000) != 0)
    return 0;
  do
    v6 = __ldaxr(a1);
  while (__stlxr(v6 - v3, a1));
  return (unint64_t)&a1[64 * (unint64_t)v5 + 60];
}

uint64_t caulk::alloc::detail::state_bit_span::allocate(uint64_t this, unint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  unsigned int v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  BOOL v17;
  unsigned int v18;
  unsigned int v20;
  int v21;
  unsigned int v22;
  signed int v23;
  unint64_t v24;
  unint64_t v25;
  char v26;
  unsigned int v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  char v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;

  if (a3 > a4 || (v6 = a3 >> 5, v6 >= a2) || (v7 = a4 >> 5, v7 >= a2))
  {
LABEL_67:
    __break(1u);
    return this;
  }
  v8 = this;
  this = 0xFFFFFFFFLL;
  if (v6 <= v7)
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = a3 & 0xFFFFFFE0;
    v14 = v8 + 8 * v7;
    v15 = (unint64_t *)(v8 + 8 * v6);
    while (1)
    {
      v16 = *v15;
      this = __clz(__rbit32(*v15));
      if ((_DWORD)this)
        v17 = v9 == 0;
      else
        v17 = 1;
      v18 = v9 + v10;
      if (!v17 && v9 + v10 + this >= a5)
      {
        v27 = a5 - v18;
        if (a5 == v18 || v27 > this)
          goto LABEL_67;
        if (v10)
        {
          this = v13 - v10 - 32;
          if (this + a5 >= a6)
            return 0xFFFFFFFFLL;
          v28 = -(1 << -(char)v10) | ((unint64_t)(1 << -(char)v10) << 32);
          v29 = v15 - 2;
          while (1)
          {
            v30 = __ldaxr(v29);
            if (v30 != v12)
              break;
            if (!__stlxr(v28 | v12, v29))
              goto LABEL_41;
          }
          v9 = 0;
          v20 = 0;
          __clrex();
        }
        else
        {
          this = v13 - v9;
          if (this + a5 >= a6)
            return 0xFFFFFFFFLL;
          v28 = 0;
LABEL_41:
          v31 = (1 << -(char)v9);
          v32 = -(int)v31;
          v33 = v31 << 32;
          if (v10)
            v33 = 0;
          v34 = v33 | v32;
          v35 = v15 - 1;
          while (1)
          {
            v36 = __ldaxr(v35);
            if (v36 != v11)
              break;
            if (!__stlxr(v34 | v11, v35))
            {
              v37 = 1;
              goto LABEL_48;
            }
          }
          v37 = 0;
          __clrex();
LABEL_48:
          if (v37)
          {
            v38 = v16 | (0xFFFFFFFF >> -(char)v27);
            while (1)
            {
              v39 = __ldaxr(v15);
              if (v39 != v16)
                break;
              if (!__stlxr(v38, v15))
              {
                v40 = 1;
                goto LABEL_54;
              }
            }
            v40 = 0;
            __clrex();
LABEL_54:
            if ((v40 & 1) != 0)
              return this;
            do
              v41 = __ldaxr(v35);
            while (__stlxr(v41 & ~v34, v35));
            v16 = v39;
          }
          else
          {
            v11 = v36;
          }
          if (v10)
          {
            v42 = ~v28;
            v43 = v15 - 2;
            do
            {
              v44 = __ldaxr(v43);
              v9 = __stlxr(v44 & v42, v43);
            }
            while (v9);
          }
          else
          {
            v9 = 0;
          }
          v20 = 0;
        }
      }
      else
      {
        if (a5 <= 0x20)
        {
          v21 = 0;
          v22 = 0xFFFFFFFF >> -(char)a5;
          while ((v22 & v16) != 0)
          {
            v23 = __clz(v22 & v16);
            v22 <<= 32 - v23 - v21;
            v21 = 32 - v23;
            if (v23 < (int)a5)
            {
              if ((_DWORD)v16)
                goto LABEL_15;
              goto LABEL_20;
            }
          }
          this = v21 + v13;
          if (this + a5 >= a6)
            return 0xFFFFFFFFLL;
          v24 = (~(-1 << a5) << v21) | v16 | (1 << (v21 + 32));
          while (1)
          {
            v25 = __ldaxr(v15);
            if (v25 != v16)
              break;
            if (!__stlxr(v24, v15))
            {
              v26 = 1;
              goto LABEL_37;
            }
          }
          v26 = 0;
          __clrex();
LABEL_37:
          if ((v26 & 1) == 0)
          {
            v9 = 0;
            v20 = 0;
            v16 = v25;
            goto LABEL_21;
          }
          return this;
        }
        if ((_DWORD)v16)
        {
LABEL_15:
          v9 = 0;
          v20 = __clz(v16);
        }
        else
        {
LABEL_20:
          v20 = 32;
        }
      }
LABEL_21:
      v10 = v9;
      v12 = v11;
      ++v15;
      v13 += 32;
      v9 = v20;
      v11 = v16;
      if ((unint64_t)v15 > v14)
        return 0xFFFFFFFFLL;
    }
  }
  return this;
}

uint64_t caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::allocate(unsigned int *a1, uint64_t a2)
{
  unint64_t v2;
  unsigned int v3;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;

  v2 = (unint64_t)(a2 + 15) >> 4;
  v3 = atomic_load(a1);
  if (v3 < v2)
    return 0;
  v5 = a1[1];
  v6 = (uint64_t)(a1 + 2);
  do
  {
    v7 = v5;
    v8 = caulk::alloc::detail::state_bit_span::allocate(v6, 0x20uLL, v5, 0x3EDu, v2, 0x3EEu);
    if (!v7)
      break;
    v5 = 0;
  }
  while (v8 == -1);
  if (v8 < 0)
    return 0;
  do
    v9 = __ldaxr(a1);
  while (__stlxr(v9 - v2, a1));
  v10 = v8 + v2;
  if ((v8 + v2) > 0x3ED)
    v10 = 0;
  if (v10 != v7)
    a1[1] = v10;
  return (uint64_t)&a1[4 * v8 + 68];
}

void std::default_delete<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_plus>::operator()[abi:ne180100](uint64_t a1)
{
  malloc_zone_unregister((malloc_zone_t *)(a1 + 8));
  JUMPOUT(0x20BCF9C08);
}

uint64_t caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::skiplist(uint64_t a1)
{
  unint64_t v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t i;
  _QWORD *v9;
  unint64_t *p_shared_weak_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t j;

  *(_OWORD *)(a1 + 112) = 0u;
  v2 = a1 + 112;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  os_unfair_lock_lock((os_unfair_lock_t)&caulk::alloc::shared_allocator<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::shared_instance(void)::global);
  if (qword_253D075D0)
  {
    v3 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_253D075D0);
    if (v3)
    {
      v4 = v3;
      v5 = qword_253D075C8;
      if (qword_253D075C8)
        goto LABEL_14;
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
  v4 = (std::__shared_weak_count *)operator new(0x100uLL);
  v4->__shared_owners_ = 0;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2D7F0;
  *(_OWORD *)&v4[1].__shared_owners_ = 0u;
  v5 = (uint64_t)&v4[1].__shared_owners_;
  v4[2].std::__shared_count = 0u;
  *(_OWORD *)&v4[2].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v4[3].__shared_owners_ = 0u;
  v4[4].std::__shared_count = 0u;
  *(_OWORD *)&v4[4].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v4[5].__shared_owners_ = 0u;
  v4[6].std::__shared_count = 0u;
  *(_OWORD *)&v4[6].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v4[7].__shared_owners_ = 0u;
  v4[8].std::__shared_count = 0u;
  *(_OWORD *)&v4[8].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v4[9].__shared_owners_ = 0u;
  v4[10].std::__shared_count = 0u;
  caulk::alloc::global_page_cache::instance((caulk::alloc::global_page_cache *)v4);
  v4[3].__shared_owners_ = 0;
  v4[1].__shared_weak_owners_ = (uint64_t)&unk_253D0A3B0;
  v4[2].__vftable = 0;
  v4[2].__shared_owners_ = 0;
  v4[2].__shared_weak_owners_ = 0;
  LODWORD(v4[3].__vftable) = 0;
  for (i = 96; i != 256; i += 32)
  {
    v9 = (std::__shared_weak_count_vtbl **)((char *)&v4->__vftable + i);
    *v9 = 0;
    v9[1] = 0;
    v9[2] = 0;
  }
  p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
  do
    v11 = __ldxr(p_shared_weak_owners);
  while (__stxr(v11 + 1, p_shared_weak_owners));
  v12 = (std::__shared_weak_count *)qword_253D075D0;
  qword_253D075C8 = (uint64_t)&v4[1].__shared_owners_;
  qword_253D075D0 = (uint64_t)v4;
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
LABEL_14:
  os_unfair_lock_unlock((os_unfair_lock_t)&caulk::alloc::shared_allocator<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::shared_instance(void)::global);
  v13 = (unint64_t *)&v4->__shared_owners_;
  do
    v14 = __ldxr(v13);
  while (__stxr(v14 + 1, v13));
  v15 = *(std::__shared_weak_count **)(a1 + 184);
  *(_QWORD *)(a1 + 176) = v5;
  *(_QWORD *)(a1 + 184) = v4;
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  do
    v18 = __ldaxr(v13);
  while (__stlxr(v18 - 1, v13));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  *(_QWORD *)(a1 + 192) = &caulk::inplace_function_detail::vtable<void,caulk::concurrent::details::skiplist_node<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>::layout_kv const&>::empty;
  *(_QWORD *)(a1 + 232) = &caulk::inplace_function_detail::vtable<void>::empty;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 280) = 0;
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::random_engine();
  v19 = 0;
  *(_DWORD *)(a1 + 16) = 83951621;
  *(_OWORD *)a1 = 0u;
  *(_QWORD *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  do
  {
    atomic_store(0, (unint64_t *)(a1 + v19 + 32));
    atomic_store(0, (unint64_t *)(a1 + v19 + 40));
    v19 += 16;
  }
  while (v19 != 80);
  *(_QWORD *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 128) = 16908289;
  *(_OWORD *)(a1 + 112) = xmmword_2065DE1A0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  atomic_store(0, (unint64_t *)(a1 + 144));
  atomic_store(0, (unint64_t *)(a1 + 152));
  for (j = 32; j != 112; j += 16)
    atomic_store(v2, (unint64_t *)(a1 + j));
  __dmb(0xBu);
  return a1;
}

void sub_2065CD6B0(void *a1)
{
  std::__shared_weak_count *v1;
  uint64_t v2;
  void *v4;

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&caulk::alloc::shared_allocator<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::shared_instance(void)::global);
  std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](v2);
  __clang_call_terminate(a1);
}

void caulk::inplace_function_detail::vtable<void>::vtable(void)::{lambda(void *)#1}::__invoke()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

caulk::alloc::base_allocator *caulk::inplace_function_detail::vtable<void>::vtable<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>(caulk::inplace_function_detail::wrapper<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::perform_deferred_deletions<true,(BOOL *)0>((caulk::alloc::base_allocator *)(*(_QWORD *)a1 + 464));
}

_QWORD *caulk::inplace_function_detail::vtable<void>::vtable<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>(caulk::inplace_function_detail::wrapper<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>)::{lambda(void *,void *)#1}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void>::vtable<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>(caulk::inplace_function_detail::wrapper<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>)::{lambda(void *,void *)#2}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

void caulk::inplace_function_detail::vtable<void,caulk::concurrent::details::skiplist_node<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>::layout_kv const&>::vtable(void)::{lambda(void *,caulk::concurrent::details::skiplist_node<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>::layout_kv const&)#1}::__invoke()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

void _ZZN5caulk23inplace_function_detail6vtableIvJRKNS_10concurrent7details13skiplist_nodeImPNS_5alloc15chunk_allocatorINS5_17global_page_cacheENS5_16bitmap_allocatorENS5_18embed_block_memoryELm16384EJLm16ELm6EEE9node_implINS5_14tree_allocatorISA_E11node_headerES9_EEE9layout_kvEEEC1IZNSD_C1EvEUlRKT_E_EENS0_7wrapperISN_EEENUlPvSK_E_8__invokeEST_SK_(uint64_t a1, uint64_t a2)
{
  caulk::alloc::details::caching_page_allocator_base::deallocate(*(uint64_t **)(*(_QWORD *)a1 + 8), *(caulk::mach::vm_block **)(a2 + 8), *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8));
}

_QWORD *_ZZN5caulk23inplace_function_detail6vtableIvJRKNS_10concurrent7details13skiplist_nodeImPNS_5alloc15chunk_allocatorINS5_17global_page_cacheENS5_16bitmap_allocatorENS5_18embed_block_memoryELm16384EJLm16ELm6EEE9node_implINS5_14tree_allocatorISA_E11node_headerES9_EEE9layout_kvEEEC1IZNSD_C1EvEUlRKT_E_EENS0_7wrapperISN_EEENUlPvST_E_8__invokeEST_ST_(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *_ZZN5caulk23inplace_function_detail6vtableIvJRKNS_10concurrent7details13skiplist_nodeImPNS_5alloc15chunk_allocatorINS5_17global_page_cacheENS5_16bitmap_allocatorENS5_18embed_block_memoryELm16384EJLm16ELm6EEE9node_implINS5_14tree_allocatorISA_E11node_headerES9_EEE9layout_kvEEEC1IZNSD_C1EvEUlRKT_E_EENS0_7wrapperISN_EEENUlPvST_E0_8__invokeEST_ST_(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

void std::__shared_ptr_emplace<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2D7F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2D7F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BCF9C08);
}

void std::__shared_ptr_emplace<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t v7;

  v1 = 0;
  v2 = (_QWORD *)(a1 + 32);
  v3 = a1 + 96;
  do
  {
    v4 = *(_QWORD *)&caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::node_sizes[8 * v1];
    v5 = (unint64_t *)(v3 + 32 * v1 + 16);
    while (1)
    {
      v6 = caulk::concurrent::stack<caulk::alloc::free_block,caulk::concurrent::intrusive_single_link_node<caulk::alloc::free_block>>::pop((unsigned __int128 *)(v3 + 32 * v1));
      if (!v6)
        break;
      do
        v7 = __ldaxr(v5);
      while (__stlxr(v7 - 1, v5));
      caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>::deallocate(v2, (unint64_t)v6, v4);
    }
    ++v1;
  }
  while (v1 != 5);
  caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>::self_deallocate_all((uint64_t)v2);
}

void caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>::self_deallocate_all(uint64_t a1)
{
  unint64_t v1;
  unint64_t v3;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
  {
    do
    {
      v3 = atomic_load((unint64_t *)v1);
      caulk::alloc::details::caching_page_allocator_base::deallocate(*(uint64_t **)(a1 + 8), (caulk::mach::vm_block *)v1, *(_QWORD *)(v1 + 8));
      v1 = v3;
    }
    while (v3);
  }
}

_QWORD *caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>::deallocate(_QWORD *result, unint64_t a2, uint64_t a3)
{
  unsigned int *v3;
  unsigned int v4;
  unint64_t *v5;
  BOOL v7;
  unsigned int v9;

  v3 = (unsigned int *)(result + 5);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 + 2049, v3));
  v5 = (unint64_t *)result[2];
  if (v5)
  {
    while ((unint64_t)(v5 + 4) > a2 || a2 + a3 > (unint64_t)(v5 + 2048))
    {
      v5 = (unint64_t *)atomic_load(v5);
      if (!v5)
        goto LABEL_10;
    }
  }
  else
  {
LABEL_10:
    v5 = (unint64_t *)atomic_load(result + 6);
    if (v5)
      v7 = (unint64_t)(v5 + 4) > a2;
    else
      v7 = 1;
    if (v7 || a2 + a3 > (unint64_t)(v5 + 2048))
LABEL_22:
      caulk::alloc::base_allocator::bad_dealloc((caulk::alloc::base_allocator *)result);
  }
  if (!v5)
    goto LABEL_22;
  if ((unint64_t)(v5 + 4) > a2 || a2 + a3 > (unint64_t)(v5 + 2048))
    caulk::alloc::base_allocator::bad_dealloc((caulk::alloc::base_allocator *)result);
  do
    v9 = __ldaxr(v3);
  while (__stlxr(v9 - 1, v3));
  return result;
}

void sub_2065CD98C(_Unwind_Exception *a1)
{
  unsigned int *v1;
  unsigned int v2;

  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  _Unwind_Resume(a1);
}

uint64_t caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::skiplist(uint64_t a1)
{
  unint64_t v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t i;
  _QWORD *v9;
  unint64_t *p_shared_weak_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t j;

  *(_OWORD *)(a1 + 112) = 0u;
  v2 = a1 + 112;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  os_unfair_lock_lock((os_unfair_lock_t)&caulk::alloc::shared_allocator<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::shared_instance(void)::global);
  if (qword_253D04E58)
  {
    v3 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_253D04E58);
    if (v3)
    {
      v4 = v3;
      v5 = qword_253D04E50;
      if (qword_253D04E50)
        goto LABEL_14;
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
  v4 = (std::__shared_weak_count *)operator new(0x100uLL);
  v4->__shared_owners_ = 0;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2D828;
  *(_OWORD *)&v4[1].__shared_owners_ = 0u;
  v5 = (uint64_t)&v4[1].__shared_owners_;
  v4[2].std::__shared_count = 0u;
  *(_OWORD *)&v4[2].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v4[3].__shared_owners_ = 0u;
  v4[4].std::__shared_count = 0u;
  *(_OWORD *)&v4[4].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v4[5].__shared_owners_ = 0u;
  v4[6].std::__shared_count = 0u;
  *(_OWORD *)&v4[6].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v4[7].__shared_owners_ = 0u;
  v4[8].std::__shared_count = 0u;
  *(_OWORD *)&v4[8].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v4[9].__shared_owners_ = 0u;
  v4[10].std::__shared_count = 0u;
  caulk::alloc::global_page_cache::instance((caulk::alloc::global_page_cache *)v4);
  v4[3].__shared_owners_ = 0;
  v4[1].__shared_weak_owners_ = (uint64_t)&unk_253D0A3B0;
  v4[2].__vftable = 0;
  v4[2].__shared_owners_ = 0;
  v4[2].__shared_weak_owners_ = 0;
  LODWORD(v4[3].__vftable) = 0;
  for (i = 96; i != 256; i += 32)
  {
    v9 = (std::__shared_weak_count_vtbl **)((char *)&v4->__vftable + i);
    *v9 = 0;
    v9[1] = 0;
    v9[2] = 0;
  }
  p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
  do
    v11 = __ldxr(p_shared_weak_owners);
  while (__stxr(v11 + 1, p_shared_weak_owners));
  v12 = (std::__shared_weak_count *)qword_253D04E58;
  qword_253D04E50 = (uint64_t)&v4[1].__shared_owners_;
  qword_253D04E58 = (uint64_t)v4;
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
LABEL_14:
  os_unfair_lock_unlock((os_unfair_lock_t)&caulk::alloc::shared_allocator<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::shared_instance(void)::global);
  v13 = (unint64_t *)&v4->__shared_owners_;
  do
    v14 = __ldxr(v13);
  while (__stxr(v14 + 1, v13));
  v15 = *(std::__shared_weak_count **)(a1 + 184);
  *(_QWORD *)(a1 + 176) = v5;
  *(_QWORD *)(a1 + 184) = v4;
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  do
    v18 = __ldaxr(v13);
  while (__stlxr(v18 - 1, v13));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  *(_QWORD *)(a1 + 192) = &caulk::inplace_function_detail::vtable<void,caulk::concurrent::details::skiplist_node<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>::layout_kv const&>::empty;
  *(_QWORD *)(a1 + 232) = &caulk::inplace_function_detail::vtable<void>::empty;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 280) = 0;
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::random_engine();
  v19 = 0;
  *(_DWORD *)(a1 + 16) = 83951621;
  *(_OWORD *)a1 = 0u;
  *(_QWORD *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  do
  {
    atomic_store(0, (unint64_t *)(a1 + v19 + 32));
    atomic_store(0, (unint64_t *)(a1 + v19 + 40));
    v19 += 16;
  }
  while (v19 != 80);
  *(_QWORD *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 128) = 16908289;
  *(_OWORD *)(a1 + 112) = xmmword_2065DE1A0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  atomic_store(0, (unint64_t *)(a1 + 144));
  atomic_store(0, (unint64_t *)(a1 + 152));
  for (j = 32; j != 112; j += 16)
    atomic_store(v2, (unint64_t *)(a1 + j));
  __dmb(0xBu);
  return a1;
}

void sub_2065CDC40(void *a1)
{
  std::__shared_weak_count *v1;
  uint64_t v2;
  void *v4;

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&caulk::alloc::shared_allocator<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::shared_instance(void)::global);
  std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](v2);
  __clang_call_terminate(a1);
}

caulk::alloc::base_allocator *caulk::inplace_function_detail::vtable<void>::vtable<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>(caulk::inplace_function_detail::wrapper<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::perform_deferred_deletions<true,(BOOL *)0>((caulk::alloc::base_allocator *)(*(_QWORD *)a1 + 464));
}

_QWORD *caulk::inplace_function_detail::vtable<void>::vtable<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>(caulk::inplace_function_detail::wrapper<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>)::{lambda(void *,void *)#1}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void>::vtable<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>(caulk::inplace_function_detail::wrapper<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>)::{lambda(void *,void *)#2}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

void caulk::inplace_function_detail::vtable<void,caulk::concurrent::details::skiplist_node<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>::layout_kv const&>::vtable(void)::{lambda(void *,caulk::concurrent::details::skiplist_node<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>::layout_kv const&)#1}::__invoke()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

void _ZZN5caulk23inplace_function_detail6vtableIvJRKNS_10concurrent7details13skiplist_nodeImPNS_5alloc15chunk_allocatorINS5_17global_page_cacheENS5_16bitmap_allocatorENS5_18embed_block_memoryELm16384EJLm256ELm6EEE9node_implINS5_14tree_allocatorISA_E11node_headerES9_EEE9layout_kvEEEC1IZNSD_C1EvEUlRKT_E_EENS0_7wrapperISN_EEENUlPvSK_E_8__invokeEST_SK_(uint64_t a1, uint64_t a2)
{
  caulk::alloc::details::caching_page_allocator_base::deallocate(*(uint64_t **)(*(_QWORD *)a1 + 8), *(caulk::mach::vm_block **)(a2 + 8), *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8));
}

_QWORD *_ZZN5caulk23inplace_function_detail6vtableIvJRKNS_10concurrent7details13skiplist_nodeImPNS_5alloc15chunk_allocatorINS5_17global_page_cacheENS5_16bitmap_allocatorENS5_18embed_block_memoryELm16384EJLm256ELm6EEE9node_implINS5_14tree_allocatorISA_E11node_headerES9_EEE9layout_kvEEEC1IZNSD_C1EvEUlRKT_E_EENS0_7wrapperISN_EEENUlPvST_E_8__invokeEST_ST_(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *_ZZN5caulk23inplace_function_detail6vtableIvJRKNS_10concurrent7details13skiplist_nodeImPNS_5alloc15chunk_allocatorINS5_17global_page_cacheENS5_16bitmap_allocatorENS5_18embed_block_memoryELm16384EJLm256ELm6EEE9node_implINS5_14tree_allocatorISA_E11node_headerES9_EEE9layout_kvEEEC1IZNSD_C1EvEUlRKT_E_EENS0_7wrapperISN_EEENUlPvST_E0_8__invokeEST_ST_(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

void std::__shared_ptr_emplace<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2D828;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2D828;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BCF9C08);
}

void std::__shared_ptr_emplace<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t v7;

  v1 = 0;
  v2 = (_QWORD *)(a1 + 32);
  v3 = a1 + 96;
  do
  {
    v4 = *(_QWORD *)&caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::node_sizes[8 * v1];
    v5 = (unint64_t *)(v3 + 32 * v1 + 16);
    while (1)
    {
      v6 = caulk::concurrent::stack<caulk::alloc::free_block,caulk::concurrent::intrusive_single_link_node<caulk::alloc::free_block>>::pop((unsigned __int128 *)(v3 + 32 * v1));
      if (!v6)
        break;
      do
        v7 = __ldaxr(v5);
      while (__stlxr(v7 - 1, v5));
      caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>::deallocate(v2, (unint64_t)v6, v4);
    }
    ++v1;
  }
  while (v1 != 5);
  caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>::self_deallocate_all((uint64_t)v2);
}

void caulk::inplace_function_detail::vtable<void,caulk::concurrent::details::skiplist_node<void *,caulk::alloc::detail::tracked_block>::layout_vk const&>::vtable(void)::{lambda(void *,caulk::concurrent::details::skiplist_node<void *,caulk::alloc::detail::tracked_block>::layout_vk const&)#1}::__invoke()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

void std::__shared_ptr_emplace<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2D780;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2D780;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BCF9C08);
}

void std::__shared_ptr_emplace<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t v7;

  v1 = 0;
  v2 = (_QWORD *)(a1 + 32);
  v3 = a1 + 96;
  do
  {
    v4 = *(_QWORD *)&caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>::Sizes[8 * v1];
    v5 = (unint64_t *)(v3 + 32 * v1 + 16);
    while (1)
    {
      v6 = caulk::concurrent::stack<caulk::alloc::free_block,caulk::concurrent::intrusive_single_link_node<caulk::alloc::free_block>>::pop((unsigned __int128 *)(v3 + 32 * v1));
      if (!v6)
        break;
      do
        v7 = __ldaxr(v5);
      while (__stlxr(v7 - 1, v5));
      caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>::deallocate(v2, (unint64_t)v6, v4);
    }
    ++v1;
  }
  while (v1 != 10);
  caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>::self_deallocate_all((uint64_t)v2);
}

void caulk::alloc::exported_resource<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>,caulk::alloc::rt_safe_memory_resource,caulk::rt_safe_memory_resource>::~exported_resource(std::pmr::memory_resource *a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = &off_24BF2CD20;
  *((_QWORD *)a1 + 2) = &off_24BF2CBD0;
  v2 = *((_QWORD *)a1 + 200);
  *((_QWORD *)a1 + 200) = 0;
  if (v2)
    std::default_delete<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_plus>::operator()[abi:ne180100](v2);
  caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::~tree_allocator((uint64_t)a1 + 992);
  caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::~tree_allocator((uint64_t)a1 + 384);
  caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::~tracking_allocator((uint64_t)a1 + 32);
  std::pmr::memory_resource::~memory_resource(a1);
}

{
  uint64_t v2;

  *(_QWORD *)a1 = &off_24BF2CD20;
  *((_QWORD *)a1 + 2) = &off_24BF2CBD0;
  v2 = *((_QWORD *)a1 + 200);
  *((_QWORD *)a1 + 200) = 0;
  if (v2)
    std::default_delete<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>::zone_plus>::operator()[abi:ne180100](v2);
  caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::~tree_allocator((uint64_t)a1 + 992);
  caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::~tree_allocator((uint64_t)a1 + 384);
  caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::~tracking_allocator((uint64_t)a1 + 32);
  std::pmr::memory_resource::~memory_resource(a1);
  JUMPOUT(0x20BCF9C08);
}

unint64_t *caulk::alloc::exported_resource<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>,caulk::alloc::rt_safe_memory_resource,caulk::rt_safe_memory_resource>::do_allocate(uint64_t a1, unint64_t a2, unint64_t a3)
{
  return caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,16128ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>>,caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>::allocate(a1 + 32, a2, a3);
}

void caulk::alloc::exported_resource<caulk::alloc::darwin_resource<caulk::alloc::dsw_allocator2<true>,caulk::alloc::rt_safe_memory_resource>,caulk::alloc::rt_safe_memory_resource,caulk::rt_safe_memory_resource>::do_deallocate(uint64_t a1, caulk::mach::vm_block *a2, unint64_t a3)
{
  caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,16128ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>>,caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>>::deallocate(a1 + 32, a2, a3);
}

uint64_t caulk::alloc::_audio_buffer_resource(caulk::alloc *this)
{
  unsigned __int8 v1;
  caulk::alloc *v3;
  uint64_t v4;

  if ((v1 & 1) == 0)
  {
    if ((_DWORD)v3)
    {
      caulk::alloc::_audio_buffer_resource(void)::global = (uint64_t)caulk::alloc::make_audio_buffer_resource(v3);
      caulk::alloc::_audio_buffer_resource(void)::global = v4;
    }
  }
  return caulk::alloc::_audio_buffer_resource(void)::global;
}

void sub_2065CE05C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void caulk::alloc::exported_resource<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>,caulk::alloc::memory_resource,caulk::memory_resource>::exported_resource<char const*>()
{
  uint64_t v0;
  uint64_t v1;
  _QWORD v2[5];
  void *v3;
  uint64_t (**v4)();
  _QWORD v5[5];

  v5[4] = *MEMORY[0x24BDAC8D0];
  caulk::alloc::make_audio_buffer_resource(void)::global = (uint64_t)&off_24BF2CD58;
  *(_QWORD *)algn_253D09DD8 = 0;
  dword_253D09DF0 = 0;
  qword_253D09DF8 = 0;
  caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::skiplist((uint64_t)&unk_253D09E00);
  dword_253D09F50 = 0;
  qword_253D09F58 = 0;
  caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::skiplist((uint64_t)&unk_253D09F60);
  dword_253D0A0B0 = 0;
  qword_253D0A0C0 = 0;
  qword_253D0A0D0 = 0;
  qword_253D0A0C8 = 0;
  qword_253D0A0B8 = (uint64_t)&qword_253D0A0C0;
  dword_253D0A0E8 = 0;
  qword_253D0A0F0 = 0;
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::skiplist((uint64_t)&unk_253D0A100);
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::skiplist((uint64_t)&qword_253D0A1C8[11]);
  qword_253D0A340 = 0;
  v2[4] = &caulk::inplace_function_detail::vtable<void,caulk::concurrent::details::skiplist_node<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>::layout_kv const&>::empty;
  v3 = &unk_253D0A0E0;
  v4 = _ZN5caulk16inplace_functionIFvRKNS_10concurrent7details13skiplist_nodeImPNS_5alloc15chunk_allocatorINS4_14page_allocatorENS4_16bitmap_allocatorENS4_18embed_block_memoryELm16384EJLm16ELm6EEE9node_implINS4_14tree_allocatorIS9_E11node_headerES8_EEE9layout_kvEELm32ELm8ENS_23inplace_function_detail6vtableEE16k_wrapper_vtableIZNSC_C1EvEUlRKT_E_EE;
  _ZZN5caulk23inplace_function_detail6vtableIvJRKNS_10concurrent7details13skiplist_nodeImPNS_5alloc15chunk_allocatorINS5_14page_allocatorENS5_16bitmap_allocatorENS5_18embed_block_memoryELm16384EJLm16ELm6EEE9node_implINS5_14tree_allocatorISA_E11node_headerES9_EEE9layout_kvEEEC1IZNSD_C1EvEUlRKT_E_EENS0_7wrapperISN_EEENUlPvST_E0_8__invokeEST_ST_(v5, &v3);
  (*(void (**)(_QWORD *))(qword_253D0A1C0 + 24))(qword_253D0A1C8);
  v0 = (uint64_t)v4;
  v4 = (uint64_t (**)())&caulk::inplace_function_detail::vtable<void,caulk::concurrent::details::skiplist_node<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>::layout_kv const&>::empty;
  qword_253D0A1C0 = v0;
  (*(void (**)(_QWORD *, _QWORD *))(v0 + 16))(qword_253D0A1C8, v5);
  ((void (*)(_QWORD *))v4[3])(v5);
  v2[0] = &unk_253D0A0E0;
  v4 = caulk::inplace_function<void ()(void),32ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>;
  caulk::inplace_function_detail::vtable<void>::vtable<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>(caulk::inplace_function_detail::wrapper<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>)::{lambda(void *,void *)#2}::__invoke(v5, v2);
  caulk::inplace_function<void ()(void),32ul,8ul,caulk::inplace_function_detail::vtable>::operator=(&qword_253D0A1C8[40], (uint64_t *)&v4);
  ((void (*)(_QWORD *))v4[3])(v5);
  qword_253D09DE0 = (uint64_t)&off_24BF2CC40;
  v1 = operator new();
  *(_QWORD *)v1 = &qword_253D09DE0;
  *(_OWORD *)(v1 + 24) = 0u;
  *(_OWORD *)(v1 + 40) = 0u;
  *(_OWORD *)(v1 + 56) = 0u;
  *(_OWORD *)(v1 + 72) = 0u;
  *(_OWORD *)(v1 + 8) = 0u;
  *(_OWORD *)(v1 + 88) = 0u;
  *(_OWORD *)(v1 + 136) = 0u;
  *(_OWORD *)(v1 + 120) = 0u;
  *(_OWORD *)(v1 + 152) = 0u;
  *(_OWORD *)(v1 + 168) = 0u;
  *(_OWORD *)(v1 + 184) = 0u;
  *(_QWORD *)(v1 + 200) = 0;
  *(_QWORD *)(v1 + 24) = caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_size_for_ptr;
  *(_QWORD *)(v1 + 32) = caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_plus::zone_plus(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>&,char const*)::{lambda(_malloc_zone_t *,unsigned long)#1}::__invoke;
  *(_QWORD *)(v1 + 40) = caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_plus::zone_plus(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>&,char const*)::{lambda(_malloc_zone_t *,unsigned long,unsigned long)#1}::__invoke;
  *(_QWORD *)(v1 + 48) = caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_plus::zone_plus(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>&,char const*)::{lambda(_malloc_zone_t *,unsigned long)#2}::__invoke;
  *(_QWORD *)(v1 + 56) = caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_plus::zone_plus(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>&,char const*)::{lambda(_malloc_zone_t *,void *)#1}::__invoke;
  *(_QWORD *)(v1 + 64) = caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_plus::zone_plus(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>&,char const*)::{lambda(_malloc_zone_t *,void *,unsigned long)#1}::__invoke;
  *(_QWORD *)(v1 + 136) = caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_pressure_relief;
  *(_DWORD *)(v1 + 112) = 8;
  *(_QWORD *)(v1 + 104) = caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::introspection_funcs(void)::funcs;
  *(_QWORD *)(v1 + 80) = "caulk::audio_buffer_resource";
  malloc_zone_register((malloc_zone_t *)(v1 + 8));
  qword_253D0A350 = v1;
  *(_QWORD *)algn_253D0A358 = 0;
  qword_253D0A360 = *MEMORY[0x24BDAED40];
}

void sub_2065CE2EC(_Unwind_Exception *a1)
{
  std::pmr::memory_resource *v1;
  uint64_t v2;
  uint64_t v3;

  v3 = v2;
  MEMORY[0x20BCF9C08](v3, 0x10F0C4098D16567);
  caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::~resource((uint64_t)v1 + 16);
  std::pmr::memory_resource::~memory_resource(v1);
  _Unwind_Resume(a1);
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_pressure_relief(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 - 8) + 72))(*(_QWORD *)(a1 - 8));
}

uint64_t caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::~resource(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a1 + 16;
  v3 = a1 + 1088;
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::clear(a1 + 1088);
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::clear(a1 + 800);
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::clear(v3);
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::~node_allocator(a1 + 1248);
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::clear(a1 + 800);
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::~node_allocator(a1 + 960);
  std::__tree<std::__value_type<unsigned long long,unsigned int>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned int>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned int>>>::destroy(*(_QWORD **)(a1 + 736));
  caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>::~tracking_allocator(a1 + 368);
  caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>::~tracking_allocator(v2);
  return a1;
}

uint64_t caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>::~tracking_allocator(uint64_t a1)
{
  unsigned __int128 *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  char v6;
  unint64_t v7;

  v2 = (unsigned __int128 *)(a1 + 272);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 272));
  v3 = atomic_load((unint64_t *)(a1 + 56));
  v4 = v3 & 0xFFFFFFFFFFFFFFFCLL;
  if (a1 + 216 != (v3 & 0xFFFFFFFFFFFFFFFCLL))
  {
    v5 = (_QWORD *)MEMORY[0x24BDB03C8];
    do
    {
      if (*(_BYTE *)(v4 + 26) != 2)
      {
        v6 = atomic_load((unint64_t *)(v4 + 40));
        if ((v6 & 1) == 0)
          caulk::mach::vm_block::dealloc(*(caulk::mach::vm_block **)(v4 + 16), (*(_QWORD *)v4 + *v5 - 1) & -*v5);
      }
      v7 = atomic_load((unint64_t *)(v4 + 40));
      v4 = v7 & 0xFFFFFFFFFFFFFFFCLL;
    }
    while (a1 + 216 != (v7 & 0xFFFFFFFFFFFFFFFCLL));
  }
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal(v2);
  caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::clear(a1 + 16);
  caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::clear(a1 + 16);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::~node_allocator((uint64_t)v2);
  return a1;
}

void sub_2065CE4BC(void *a1)
{
  unsigned __int128 *v1;

  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal(v1);
  __clang_call_terminate(a1);
}

unsigned __int128 *caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::clear(uint64_t a1)
{
  unsigned __int128 *v2;
  unint64_t i;
  unint64_t v4;
  char v5;

  v2 = (unsigned __int128 *)(a1 + 160);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 160));
  for (i = atomic_load((unint64_t *)(a1 + 32)); ; i = atomic_load((unint64_t *)(v4 + 32)))
  {
    v4 = i & 0xFFFFFFFFFFFFFFFCLL;
    if (a1 + 112 == (i & 0xFFFFFFFFFFFFFFFCLL))
      break;
    if (*(_BYTE *)(v4 + 18) != 2)
    {
      v5 = atomic_load((unint64_t *)(v4 + 32));
      if ((v5 & 1) == 0)
        caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove(a1, *(_QWORD *)v4);
    }
  }
  return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v2);
}

uint64_t caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::~node_allocator(uint64_t a1)
{
  unsigned __int128 v2;

  do
    v2 = __ldaxp((unsigned __int128 *)a1);
  while (__stlxp(v2, (unsigned __int128 *)a1));
  if ((_QWORD)v2)
    caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::free_node_chain(a1, v2);
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::perform_deferred_deletions<true,(BOOL *)0>((caulk::alloc::base_allocator *)a1);
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 72) + 24))(a1 + 80);
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 24))(a1 + 40);
  std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](a1 + 16);
  return a1;
}

unsigned __int128 *caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove(uint64_t a1, uint64_t a2)
{
  unsigned __int128 *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;

  v4 = (unsigned __int128 *)(a1 + 160);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 160));
  v16 = a2;
  v5 = -1;
  v6 = 48;
  do
  {
    v7 = atomic_load((unint64_t *)(a1 + v6));
    ++v5;
    v6 += 16;
  }
  while (*(_BYTE *)((v7 & 0xFFFFFFFFFFFFFFFCLL) + 18) != 2);
  v8 = a1;
  if (v5)
  {
    v8 = a1;
    do
      v8 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_right<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_lt &>(a1, v5--, v8, &v16);
    while (v5);
  }
  v9 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_right<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_lt &>(a1, 0, v8, &v16);
  if (*v10 == a2)
  {
    v11 = (unint64_t)v10;
    v12 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::try_flag_node(a1, 0, v9, (unint64_t)v10);
    v14 = v13;
    if (!(_DWORD)v13)
      caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(a1, 0, v12, v11);
    if ((v14 & 0xFF00000000) != 0)
    {
      v16 = a2;
      caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>(a1, &v16, 0);
    }
  }
  return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v4);
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  _BYTE v26[24];
  _BYTE *v27;
  _QWORD v28[3];
  _QWORD *v29;
  int v30;
  _BYTE v31[24];
  _BYTE *v32;
  _BYTE v33[24];
  _BYTE *v34;
  char v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v28[0] = &off_24BF2D0F8;
  v28[1] = a5;
  v28[2] = a1;
  v29 = v28;
  v11 = operator new(0x20uLL);
  *v11 = &off_24BF2D0A0;
  v11[1] = a6;
  *((_DWORD *)v11 + 4) = a1;
  v11[3] = a2;
  v27 = v11;
  v30 = a3;
  std::__function::__value_func<void * ()(unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v31, (uint64_t)v28);
  std::__function::__value_func<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v33, (uint64_t)v26);
  v35 = 0;
  v12 = v27;
  if (v27 == v26)
  {
    v13 = 4;
    v12 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_6;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_6:
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_11;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_11:
  v24 = 208;
  v25 = a4 - 8;
  if (!v32)
    std::__throw_bad_function_call[abi:ne180100]();
  v16 = (_QWORD *)(*(uint64_t (**)(_BYTE *, uint64_t *, uint64_t *))(*(_QWORD *)v32 + 48))(v32, &v25, &v24);
  if (*v16)
    v17 = *v16 + 16;
  else
    v17 = 0;
  v24 = 1376;
  v25 = v17;
  if (!v32)
    std::__throw_bad_function_call[abi:ne180100]();
  v18 = (*(uint64_t (**)(_BYTE *, uint64_t *, uint64_t *))(*(_QWORD *)v32 + 48))(v32, &v25, &v24);
  caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,256000ul,caulk::alloc::guarded_edges_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,4ul>>,caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>::introspect(v18, v17, (uint64_t)&v30);
  v19 = v34;
  if (v34 == v33)
  {
    v20 = 4;
    v19 = v33;
  }
  else
  {
    if (!v34)
      goto LABEL_21;
    v20 = 5;
  }
  (*(void (**)(void))(*v19 + 8 * v20))();
LABEL_21:
  v21 = v32;
  if (v32 == v31)
  {
    v22 = 4;
    v21 = v31;
    goto LABEL_25;
  }
  if (v32)
  {
    v22 = 5;
LABEL_25:
    (*(void (**)(void))(*v21 + 8 * v22))();
  }
  return 0;
}

void sub_2065CE8E8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_2065CE8F4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x2065CE848);
  }
  caulk::alloc::introspector::~introspector((caulk::alloc::introspector *)&a20);
  JUMPOUT(0x2065CE8ECLL);
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_good_size(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_check()
{
  return 1;
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_print(uint64_t a1, int a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, BOOL))(**(_QWORD **)(a1 - 8) + 48))(*(_QWORD *)(a1 - 8), MEMORY[0x24BEDB318], a2 != 0);
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_locked()
{
  return 0;
}

uint64_t caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,256000ul,caulk::alloc::guarded_edges_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,4ul>>,caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>::introspect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t i;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int ***v16;
  int ****v17;
  _QWORD v18[3];
  _QWORD *v19;
  int **v20;
  uint64_t v21;
  char v22;
  uint64_t *v23;
  _BYTE v24[24];
  _BYTE *v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  LOBYTE(v20) = 0;
  v22 = 0;
  if (*(_BYTE *)(a3 + 72))
  {
    v20 = (int **)(a1 + 784);
    v21 = a1 + 944;
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 944));
    v22 = 1;
  }
  for (i = a1 + 784;
        ;
        i = std::function<void * ()(unsigned long,unsigned long)>::operator()(*(_QWORD *)(a3 + 32), v6 & 0xFFFFFFFFFFFFFFFCLL, 48))
  {
    v6 = atomic_load((unint64_t *)(i + 32));
    if (!*(_BYTE *)(i + 18))
    {
      v7 = *(_QWORD *)(i + 8);
      v8 = std::function<void * ()(unsigned long,unsigned long)>::operator()(*(_QWORD *)(a3 + 32), v7, 0x4000);
      caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::introspect(v8 + 16, v7 + 16, a3);
    }
    if ((v6 & 0xFFFFFFFFFFFFFFFCLL) == 0)
      break;
  }
  std::__optional_destruct_base<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::iteration,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v20);
  v18[0] = &off_24BF2E488;
  v18[1] = a3;
  v19 = v18;
  LODWORD(v20) = *(_DWORD *)a3;
  v9 = &v21;
  std::__function::__value_func<void * ()(unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)&v21, a3 + 8);
  v10 = v24;
  std::__function::__value_func<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v24, (uint64_t)v18);
  v26 = *(_BYTE *)(a3 + 72);
  v11 = v19;
  if (v19 == v18)
  {
    v12 = 4;
    v11 = v18;
  }
  else
  {
    if (!v19)
      goto LABEL_13;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_13:
  v16 = &v20;
  v17 = &v16;
  caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::introspect<void caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>::introspect_foreach<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1}>(caulk::alloc::introspector const&,caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1} &&)::{lambda(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1} const&)#1}>(a1 + 368, (uint64_t)&v21, (int ***)&v17);
  if (v25 == v24)
  {
    v13 = 4;
  }
  else
  {
    if (!v25)
      goto LABEL_18;
    v13 = 5;
    v10 = v25;
  }
  (*(void (**)(_QWORD *))(*v10 + 8 * v13))(v10);
LABEL_18:
  if (v23 == &v21)
  {
    v14 = 4;
    goto LABEL_22;
  }
  if (v23)
  {
    v14 = 5;
    v9 = v23;
LABEL_22:
    (*(void (**)(uint64_t *))(*v9 + 8 * v14))(v9);
  }
  v18[0] = a3;
  v20 = (int **)v18;
  return caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::introspect<void caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect_foreach<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1}>(caulk::alloc::introspector const&,caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1} &&)::{lambda(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1} const&)#1}>(a1 + 16, a3 + 8, &v20);
}

void sub_2065CEB60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  _Unwind_Resume(exception_object);
}

void std::__function::__func<void caulk::alloc::affix_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,std::array<unsigned long long,4ul>,std::array<unsigned long long,4ul>>::introspect<true,(BOOL *)0>(unsigned long,caulk::alloc::introspector const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::affix_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,std::array<unsigned long long,4ul>,std::array<unsigned long long,4ul>>::introspect<true,(BOOL *)0>(unsigned long,caulk::alloc::introspector const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<void caulk::alloc::affix_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,std::array<unsigned long long,4ul>,std::array<unsigned long long,4ul>>::introspect<true,(BOOL *)0>(unsigned long,caulk::alloc::introspector const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::affix_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,std::array<unsigned long long,4ul>,std::array<unsigned long long,4ul>>::introspect<true,(BOOL *)0>(unsigned long,caulk::alloc::introspector const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2E488;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::affix_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,std::array<unsigned long long,4ul>,std::array<unsigned long long,4ul>>::introspect<true,(BOOL *)0>(unsigned long,caulk::alloc::introspector const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::affix_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,std::array<unsigned long long,4ul>,std::array<unsigned long long,4ul>>::introspect<true,(BOOL *)0>(unsigned long,caulk::alloc::introspector const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZNK5caulk5alloc15affix_allocatorINS0_22consolidating_free_mapINS0_14page_allocatorELm10485760EEENSt3__15arrayIyLm4EEES7_E10introspectILb1ELPb0EEEvmRKNS0_12introspectorEEUlNS0_12region_usageEmmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::affix_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,std::array<unsigned long long,4ul>,std::array<unsigned long long,4ul>>::introspect<true,(BOOL *)0>(unsigned long,caulk::alloc::introspector const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::affix_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,std::array<unsigned long long,4ul>,std::array<unsigned long long,4ul>>::introspect<true,(BOOL *)0>(unsigned long,caulk::alloc::introspector const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target_type()
{
}

uint64_t std::__optional_destruct_base<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::iteration,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 16))
    caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(*(unsigned __int128 **)(a1 + 8));
  return a1;
}

void std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2D360;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc19allocator_enumerateINS0_15darwin_resourceINS0_15audio_allocatorENS0_15memory_resourceEEEEEvRT_NS_10option_setINS0_12region_usageEjEERKNSt3__18functionIFvS9_NS0_5blockEEEEEUlS9_mmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target_type()
{
}

void std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2D620;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2D620;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc20allocator_statisticsINS0_15darwin_resourceINS0_15audio_allocatorENS0_15memory_resourceEEEEE19malloc_statistics_tRT_EUlNS0_12region_usageENS0_5blockEE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target_type()
{
}

void std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

__n128 std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_24BF2D0A0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24BF2D0A0;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(uint64_t a1, unsigned int *a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[2];

  v4 = *a2;
  v5 = *a4;
  v7[0] = *a3;
  v7[1] = v5;
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD *, uint64_t))(a1 + 8))(*(unsigned int *)(a1 + 16), *(_QWORD *)(a1 + 24), v4, v7, 1);
}

uint64_t std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc15darwin_resourceINS0_15audio_allocatorENS0_15memory_resourceEE14zone_enumerateEjPvjmPFijmmPS5_EPFvjS5_jP10vm_range_tjEEUlNS0_12region_usageEmmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target_type()
{
}

void std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

__n128 std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24BF2D0F8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24BF2D0F8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  uint64_t v7;

  v3 = *a2;
  v4 = *a3;
  v7 = 0;
  v5 = (const char *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t *))(a1 + 8))(*(unsigned int *)(a1 + 16), v3, v4, &v7);
  caulk::mach::throw_if_mach_error((uint64_t)"reader failed", v5);
  return v7;
}

uint64_t std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc15darwin_resourceINS0_15audio_allocatorENS0_15memory_resourceEE14zone_enumerateEjPvjmPFijmmPS5_EPFvjS5_jP10vm_range_tjEEUlmmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::target_type()
{
}

uint64_t caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::size(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  unsigned __int128 *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char v10;
  unint64_t v11;
  uint64_t v12;
  _BOOL4 v14;
  uint64_t result;
  unint64_t v16;

  v4 = a1 + 16;
  v5 = (unsigned __int128 *)(a1 + 272);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 272));
  v16 = a2;
  v6 = caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::search_to_level<caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::key_le>(v4, &v16, 0);
  v7 = 0;
  v8 = 0;
  if (*(_BYTE *)(v6 + 26) == 1)
    v9 = a1 + 216;
  else
    v9 = v6;
  if (*(_BYTE *)(v9 + 26) != 2)
  {
    v7 = 0;
    v10 = atomic_load((unint64_t *)(v9 + 40));
    if ((v10 & 1) != 0)
    {
      v8 = 0;
    }
    else
    {
      v8 = 0;
      if (a1 + 216 != v9)
      {
        v11 = *(_QWORD *)(v9 + 16);
        v12 = *(_QWORD *)v9;
        v14 = v11 > a2 || v11 + v12 < a2;
        if (v14)
          v8 = 0;
        else
          v8 = v12;
        if (v14)
          v7 = 0;
        else
          v7 = v11;
      }
    }
  }
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal(v5);
  result = 0;
  if (v7 && v7 + 32 <= a2 && v7 + v8 - 32 > a2)
  {
    if ((*(_QWORD *)(a2 - 16) & 1) != 0)
      return 0;
    else
      return *(_QWORD *)(a2 - 8) >> 1;
  }
  return result;
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::~darwin_resource(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24BF2CC40;
  v2 = a1[174];
  a1[174] = 0;
  if (v2)
    std::default_delete<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_plus>::operator()[abi:ne180100](v2);
  return caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::~resource((uint64_t)a1);
}

void caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::~darwin_resource(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24BF2CC40;
  v2 = a1[174];
  a1[174] = 0;
  if (v2)
    std::default_delete<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_plus>::operator()[abi:ne180100](v2);
  caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::~resource((uint64_t)a1);
  JUMPOUT(0x20BCF9C08);
}

BOOL caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::do_is_equal(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

void caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::print(uint64_t a1, _QWORD *a2, int a3)
{
  unsigned __int128 *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  int v12;
  std::string *v13;
  std::string::size_type size;
  std::string *v15;
  unsigned int v16;
  unint64_t v17;
  uint64_t v18;
  std::string *v19;
  std::string::size_type *p_size;
  _QWORD *v21;
  std::string *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  std::string *v27;
  uint64_t v28;
  _QWORD *v29;
  char v30;
  _QWORD *v31;
  _QWORD **v32;
  BOOL v33;
  std::string *v34;
  std::string::size_type *v35;
  _QWORD *v36;
  std::string *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  std::string *v42;
  uint64_t v43;
  _QWORD *v44;
  char v45;
  _QWORD *v46;
  _QWORD **v47;
  std::string *v48;
  uint64_t v49;
  uint64_t v52;
  caulk::alloc::page_allocator *v53;
  _QWORD *v54;
  int v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD **v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  int **v64;
  std::string v65;
  std::string *v66;
  std::string v67;
  std::string *v68;
  std::string v69;
  std::string *v70;
  std::string *v71;
  _BYTE v72[24];
  _BYTE *v73;
  char v74;
  uint64_t v75;

  v75 = *MEMORY[0x24BDAC8D0];
  v54 = a2;
  v55 = 0;
  v56 = 0;
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "audio_allocator @ ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  v53 = (caulk::alloc::page_allocator *)(a1 + 16);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  v69.__r_.__value_.__s.__data_[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v54, (uint64_t)&v69, 1);
  v55 += 2;
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "[zeroing] ");
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "[tier ");
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "sizes ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "-");
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "] ");
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "tree_allocator @ ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "\n");
  v4 = (unsigned __int128 *)(a1 + 960);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 960));
  v5 = atomic_load((unint64_t *)(a1 + 832));
  v52 = a1;
  v6 = a1 + 912;
  v7 = v5 & 0xFFFFFFFFFFFFFFFCLL;
  if (v6 == (v5 & 0xFFFFFFFFFFFFFFFCLL))
  {
    v8 = 0;
  }
  else
  {
    v8 = 0;
    v9 = 0;
    do
    {
      if (*(_BYTE *)(v7 + 18) != 2)
      {
        v10 = atomic_load((unint64_t *)(v7 + 32));
        if ((v10 & 1) == 0)
        {
          v11 = *(_QWORD *)(v7 + 8);
          v12 = atomic_load((unsigned int *)(v11 + 4));
          std::string::basic_string[abi:ne180100]<0>(&v67, "availability ");
          std::to_string(&v65, v12);
          if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v13 = &v65;
          else
            v13 = (std::string *)v65.__r_.__value_.__r.__words[0];
          if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            size = HIBYTE(v65.__r_.__value_.__r.__words[2]);
          else
            size = v65.__r_.__value_.__l.__size_;
          v15 = std::string::append(&v67, (const std::string::value_type *)v13, size);
          v69 = *v15;
          v15->__r_.__value_.__l.__size_ = 0;
          v15->__r_.__value_.__r.__words[2] = 0;
          v15->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v65.__r_.__value_.__l.__data_);
          if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v67.__r_.__value_.__l.__data_);
          caulk::alloc::base_allocator::formatter::print_allocator<caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>>((caulk::alloc::base_allocator::formatter *)&v54, (uint64_t)&v69, v11 + 16);
          v16 = atomic_load((unsigned int *)(v11 + 16));
          if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v69.__r_.__value_.__l.__data_);
          ++v8;
          v9 += 16 * v16;
        }
      }
      v17 = atomic_load((unint64_t *)(v7 + 32));
      v7 = v17 & 0xFFFFFFFFFFFFFFFCLL;
    }
    while (v6 != (v17 & 0xFFFFFFFFFFFFFFFCLL));
  }
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v4);
  v55 += 2;
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v54, " nodes, total capacity ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v54, ", free capacity ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  if (16096 * v8)
  {
    caulk::alloc::base_allocator::formatter::emit_string(&v54, " (");
    caulk::alloc::base_allocator::formatter::check_line_start(&v54);
    std::ostream::operator<<();
    caulk::alloc::base_allocator::formatter::emit_string(&v54, "%)");
  }
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "\n");
  v55 -= 2;
  std::string::basic_string[abi:ne180100]<0>(&v67, "super");
  v55 += 2;
  if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!v67.__r_.__value_.__l.__size_)
      goto LABEL_30;
    std::string::__init_copy_ctor_external(&v69, v67.__r_.__value_.__l.__data_, v67.__r_.__value_.__l.__size_);
  }
  else
  {
    if (!*((_BYTE *)&v67.__r_.__value_.__s + 23))
      goto LABEL_30;
    v69 = v67;
  }
  caulk::alloc::base_allocator::formatter::operator<<<std::string>(&v54, (uint64_t)&v69);
  caulk::alloc::base_allocator::formatter::emit_string(&v54, ": ");
  if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v69.__r_.__value_.__l.__data_);
LABEL_30:
  caulk::alloc::page_allocator::describe((caulk::alloc::page_allocator *)(v52 + 776), (caulk::alloc::base_allocator::formatter *)&v54, 0);
  v55 -= 2;
  if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v67.__r_.__value_.__l.__data_);
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "[tier ");
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "sizes ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "-");
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "] ");
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "guarded_edges_allocator<");
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "> @ ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "\n");
  v55 += 2;
  os_unfair_lock_lock((os_unfair_lock_t)(v52 + 720));
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "consolidating_free_map @ ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "\n");
  v55 += 2;
  v18 = *(_QWORD *)(v52 + 752);
  v61 = 0;
  v62 = 0;
  v59 = 0;
  v60 = &v61;
  v57 = 0;
  v58 = 0;
  v19 = (std::string *)operator new(0x28uLL);
  v19->__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24BF2E328;
  v19->__r_.__value_.__l.__size_ = (std::string::size_type)&v60;
  v19->__r_.__value_.__r.__words[2] = (std::string::size_type)&v59;
  v19[1].__r_.__value_.__r.__words[0] = (std::string::size_type)&v58;
  v19[1].__r_.__value_.__l.__size_ = (std::string::size_type)&v57;
  v66 = v19;
  v67.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24BF2E430;
  v67.__r_.__value_.__l.__size_ = (std::string::size_type)&v65;
  v68 = &v67;
  LODWORD(v69.__r_.__value_.__l.__data_) = 7;
  p_size = &v69.__r_.__value_.__l.__size_;
  v69.__r_.__value_.__l.__size_ = (std::string::size_type)&off_24BF2E1C8;
  v69.__r_.__value_.__r.__words[2] = (std::string::size_type)caulk::alloc::introspector::local_reader;
  v21 = v72;
  v71 = (std::string *)&v69.__r_.__value_.__r.__words[1];
  std::__function::__value_func<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v72, (uint64_t)&v67);
  v74 = 1;
  v22 = v68;
  if (v68 == &v67)
  {
    v23 = 4;
    v22 = &v67;
  }
  else
  {
    if (!v68)
      goto LABEL_37;
    v23 = 5;
  }
  (*(void (**)(void))(v22->__r_.__value_.__r.__words[0] + 8 * v23))();
LABEL_37:
  v63 = 400;
  v64 = (int **)(v52 + 368);
  if (!v71)
    std::__throw_bad_function_call[abi:ne180100]();
  v24 = (*(uint64_t (**)(std::string *, int ***, uint64_t *))(v71->__r_.__value_.__r.__words[0] + 48))(v71, &v64, &v63);
  v63 = (uint64_t)&v69;
  v64 = (int **)&v63;
  caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::introspect<void caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>::introspect_foreach<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1}>(caulk::alloc::introspector const&,caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1} &&)::{lambda(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1} const&)#1}>(v24 + 16, (uint64_t)&v69.__r_.__value_.__l.__size_, &v64);
  if (v73 == v72)
  {
    v25 = 4;
  }
  else
  {
    if (!v73)
      goto LABEL_43;
    v25 = 5;
    v21 = v73;
  }
  (*(void (**)(_QWORD *))(*v21 + 8 * v25))(v21);
LABEL_43:
  if (v71 == (std::string *)&v69.__r_.__value_.__r.__words[1])
  {
    v26 = 4;
  }
  else
  {
    if (!v71)
      goto LABEL_48;
    v26 = 5;
    p_size = (std::string::size_type *)v71;
  }
  (*(void (**)(std::string::size_type *))(*p_size + 8 * v26))(p_size);
LABEL_48:
  v27 = v66;
  if (v66 == &v65)
  {
    v28 = 4;
    v27 = &v65;
  }
  else
  {
    if (!v66)
      goto LABEL_53;
    v28 = 5;
  }
  (*(void (**)(void))(v27->__r_.__value_.__r.__words[0] + 8 * v28))();
LABEL_53:
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  *(_DWORD *)((char *)v54 + *(_QWORD *)(*v54 - 24) + 8) = *(_DWORD *)((_BYTE *)v54 + *(_QWORD *)(*v54 - 24) + 8) & 0xFFFFFFB5 | 2;
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v54, " allocations for ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v54, " bytes");
  if (v18)
  {
    caulk::alloc::base_allocator::formatter::emit_string(&v54, " (");
    caulk::alloc::base_allocator::formatter::check_line_start(&v54);
    std::ostream::operator<<();
    caulk::alloc::base_allocator::formatter::emit_string(&v54, "%)");
  }
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "; ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v54, " bytes free\n");
  if (v62)
  {
    caulk::alloc::base_allocator::formatter::emit_string(&v54, "sizes:");
    v29 = v60;
    if (v60 != &v61)
    {
      v30 = 0;
      do
      {
        if ((v30 & 1) == 0 && (v29[4] & 0x8000000000000000) != 0)
        {
          caulk::alloc::base_allocator::formatter::emit_string(&v54, "\n");
          caulk::alloc::base_allocator::formatter::emit_string(&v54, "free sizes:");
          v30 = 1;
        }
        caulk::alloc::base_allocator::formatter::emit_string(&v54, " ");
        caulk::alloc::base_allocator::formatter::check_line_start(&v54);
        std::ostream::operator<<();
        caulk::alloc::base_allocator::formatter::emit_string(&v54, caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::sizeLabels[(v29[4] >> 61) & 3]);
        caulk::alloc::base_allocator::formatter::emit_string(&v54, "[");
        caulk::alloc::base_allocator::formatter::check_line_start(&v54);
        std::ostream::operator<<();
        caulk::alloc::base_allocator::formatter::emit_string(&v54, "]");
        v31 = (_QWORD *)v29[1];
        if (v31)
        {
          do
          {
            v32 = (_QWORD **)v31;
            v31 = (_QWORD *)*v31;
          }
          while (v31);
        }
        else
        {
          do
          {
            v32 = (_QWORD **)v29[2];
            v33 = *v32 == v29;
            v29 = v32;
          }
          while (!v33);
        }
        v29 = v32;
      }
      while (v32 != &v61);
    }
    caulk::alloc::base_allocator::formatter::emit_string(&v54, "\n");
  }
  std::__tree<std::__value_type<unsigned long long,unsigned int>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned int>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned int>>>::destroy(v61);
  v55 -= 2;
  os_unfair_lock_unlock((os_unfair_lock_t)(v52 + 720));
  v55 -= 2;
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "[tier] ");
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "[tracking] ");
  caulk::alloc::page_allocator::describe(v53, (caulk::alloc::base_allocator::formatter *)&v54, 0);
  v55 += 2;
  v61 = 0;
  v62 = 0;
  v59 = 0;
  v60 = &v61;
  v57 = 0;
  v58 = 0;
  v34 = (std::string *)operator new(0x28uLL);
  v34->__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24BF2E278;
  v34->__r_.__value_.__l.__size_ = (std::string::size_type)&v60;
  v34->__r_.__value_.__r.__words[2] = (std::string::size_type)&v59;
  v34[1].__r_.__value_.__r.__words[0] = (std::string::size_type)&v58;
  v34[1].__r_.__value_.__l.__size_ = (std::string::size_type)&v57;
  v66 = v34;
  v67.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24BF2E380;
  v67.__r_.__value_.__l.__size_ = (std::string::size_type)&v65;
  v68 = &v67;
  LODWORD(v69.__r_.__value_.__l.__data_) = 7;
  v35 = &v69.__r_.__value_.__l.__size_;
  v69.__r_.__value_.__l.__size_ = (std::string::size_type)&off_24BF2E1C8;
  v69.__r_.__value_.__r.__words[2] = (std::string::size_type)caulk::alloc::introspector::local_reader;
  v36 = v72;
  v71 = (std::string *)&v69.__r_.__value_.__r.__words[1];
  std::__function::__value_func<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v72, (uint64_t)&v67);
  v74 = 1;
  v37 = v68;
  if (v68 == &v67)
  {
    v38 = 4;
    v37 = &v67;
  }
  else
  {
    if (!v68)
      goto LABEL_73;
    v38 = 5;
  }
  (*(void (**)(void))(v37->__r_.__value_.__r.__words[0] + 8 * v38))();
LABEL_73:
  v63 = 352;
  v64 = (int **)v53;
  if (!v71)
    std::__throw_bad_function_call[abi:ne180100]();
  v39 = (*(uint64_t (**)(std::string *, int ***, uint64_t *))(v71->__r_.__value_.__r.__words[0] + 48))(v71, &v64, &v63);
  v63 = (uint64_t)&v69;
  v64 = (int **)&v63;
  caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::introspect<void caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect_foreach<caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1}>(caulk::alloc::introspector const&,caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1} &&)::{lambda(caulk::alloc::tracking_allocator<caulk::alloc::global_page_cache>::introspect(unsigned long,caulk::alloc::introspector const&)::{lambda(void *,unsigned long)#1} const&)#1}>(v39 + 16, (uint64_t)&v69.__r_.__value_.__l.__size_, &v64);
  if (v73 == v72)
  {
    v40 = 4;
  }
  else
  {
    if (!v73)
      goto LABEL_79;
    v40 = 5;
    v36 = v73;
  }
  (*(void (**)(_QWORD *))(*v36 + 8 * v40))(v36);
LABEL_79:
  if (v71 == (std::string *)&v69.__r_.__value_.__r.__words[1])
  {
    v41 = 4;
  }
  else
  {
    if (!v71)
      goto LABEL_84;
    v41 = 5;
    v35 = (std::string::size_type *)v71;
  }
  (*(void (**)(std::string::size_type *))(*v35 + 8 * v41))(v35);
LABEL_84:
  v42 = v66;
  if (v66 == &v65)
  {
    v43 = 4;
    v42 = &v65;
  }
  else
  {
    if (!v66)
      goto LABEL_89;
    v43 = 5;
  }
  (*(void (**)(void))(v42->__r_.__value_.__r.__words[0] + 8 * v43))();
LABEL_89:
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  *(_DWORD *)((char *)v54 + *(_QWORD *)(*v54 - 24) + 8) = *(_DWORD *)((_BYTE *)v54 + *(_QWORD *)(*v54 - 24) + 8) & 0xFFFFFFB5 | 2;
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v54, " allocations for ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v54, " bytes");
  caulk::alloc::base_allocator::formatter::emit_string(&v54, "; ");
  caulk::alloc::base_allocator::formatter::check_line_start(&v54);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(&v54, " bytes free\n");
  if (v62)
  {
    caulk::alloc::base_allocator::formatter::emit_string(&v54, "sizes:");
    v44 = v60;
    if (v60 != &v61)
    {
      v45 = 0;
      do
      {
        if ((v45 & 1) == 0 && (v44[4] & 0x8000000000000000) != 0)
        {
          caulk::alloc::base_allocator::formatter::emit_string(&v54, "\n");
          caulk::alloc::base_allocator::formatter::emit_string(&v54, "free sizes:");
          v45 = 1;
        }
        caulk::alloc::base_allocator::formatter::emit_string(&v54, " ");
        caulk::alloc::base_allocator::formatter::check_line_start(&v54);
        std::ostream::operator<<();
        caulk::alloc::base_allocator::formatter::emit_string(&v54, caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::sizeLabels[(v44[4] >> 61) & 3]);
        caulk::alloc::base_allocator::formatter::emit_string(&v54, "[");
        caulk::alloc::base_allocator::formatter::check_line_start(&v54);
        std::ostream::operator<<();
        caulk::alloc::base_allocator::formatter::emit_string(&v54, "]");
        v46 = (_QWORD *)v44[1];
        if (v46)
        {
          do
          {
            v47 = (_QWORD **)v46;
            v46 = (_QWORD *)*v46;
          }
          while (v46);
        }
        else
        {
          do
          {
            v47 = (_QWORD **)v44[2];
            v33 = *v47 == v44;
            v44 = v47;
          }
          while (!v33);
        }
        v44 = v47;
      }
      while (v47 != &v61);
    }
    caulk::alloc::base_allocator::formatter::emit_string(&v54, "\n");
  }
  std::__tree<std::__value_type<unsigned long long,unsigned int>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned int>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned int>>>::destroy(v61);
  v55 -= 4;
  if (a3)
  {
    v69.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24BF2D258;
    v69.__r_.__value_.__l.__size_ = (std::string::size_type)a2;
    v70 = &v69;
    caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(v52, 7, (uint64_t)&v69);
    v48 = v70;
    if (v70 == &v69)
    {
      v49 = 4;
      v48 = &v69;
    }
    else
    {
      if (!v70)
        return;
      v49 = 5;
    }
    (*(void (**)(void))(v48->__r_.__value_.__r.__words[0] + 8 * v49))();
  }
}

void sub_2065CFF3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  _QWORD *v37;
  uint64_t v38;
  _QWORD *v40;
  uint64_t v41;

  v40 = *(_QWORD **)(v38 - 152);
  if (v40 == v37)
  {
    v41 = 4;
    v40 = (_QWORD *)(v38 - 176);
  }
  else
  {
    if (!v40)
      goto LABEL_6;
    v41 = 5;
  }
  (*(void (**)(void))(*v40 + 8 * v41))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::enumerate(uint64_t a1, int a2, uint64_t a3)
{
  return caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(a1, a2, a3);
}

unint64_t caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::compact(uint64_t a1, uint64_t a2)
{
  unsigned __int128 *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  char v9;
  uint64_t v10;
  unsigned __int8 v11;
  unsigned int v12;
  unint64_t v13;

  v4 = (unsigned __int128 *)(a1 + 1248);
  caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 1248));
  v5 = atomic_load((unint64_t *)(a1 + 1120));
  v6 = v5 & 0xFFFFFFFFFFFFFFFCLL;
  if (a1 + 1200 == (v5 & 0xFFFFFFFFFFFFFFFCLL))
  {
    v7 = 0;
  }
  else
  {
    v7 = 0;
    v8 = a2 - 1;
    do
    {
      if (*(_BYTE *)(v6 + 18) != 2)
      {
        v9 = atomic_load((unint64_t *)(v6 + 32));
        if ((v9 & 1) == 0)
        {
          v10 = *(_QWORD *)(v6 + 8);
          do
            v11 = __ldaxr((unsigned __int8 *)v10);
          while (__stlxr(1u, (unsigned __int8 *)v10));
          if ((v11 & 1) == 0)
          {
            v12 = atomic_load((unsigned int *)(v10 + 16));
            if (v12 == 1006)
            {
              v7 += *(_QWORD *)(v10 + 8);
              caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove(a1 + 1088, *(_QWORD *)v6);
              caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove(a1 + 800, *(_QWORD *)v6);
              if (v8 < v7)
                break;
            }
            else
            {
              atomic_store(0, (unsigned __int8 *)v10);
            }
          }
        }
      }
      v13 = atomic_load((unint64_t *)(v6 + 32));
      v6 = v13 & 0xFFFFFFFFFFFFFFFCLL;
    }
    while (a1 + 1200 != (v13 & 0xFFFFFFFFFFFFFFFCLL));
  }
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v4);
  caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::perform_deferred_deletions<true,(BOOL *)0>((caulk::alloc::base_allocator *)(a1 + 960));
  return v7;
}

void caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::reserve(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::malloc_zone(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1392) + 8;
}

_QWORD *caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(uint64_t a1, int a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[3];
  _QWORD *v14;
  int v15;
  _QWORD v16[3];
  _QWORD *v17;
  _BYTE v18[24];
  _BYTE *v19;
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v13[0] = &off_24BF2D518;
  v13[1] = a3;
  v14 = v13;
  v15 = a2;
  v16[0] = &off_24BF2E1C8;
  v16[1] = caulk::alloc::introspector::local_reader;
  v17 = v16;
  std::__function::__value_func<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v18, (uint64_t)v13);
  v20 = 1;
  v4 = v14;
  if (v14 == v13)
  {
    v5 = 4;
    v4 = v13;
  }
  else
  {
    if (!v14)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  v11 = 1392;
  v12 = a1;
  if (!v17)
    std::__throw_bad_function_call[abi:ne180100]();
  v6 = (*(uint64_t (**)(_QWORD *, uint64_t *, uint64_t *))(*v17 + 48))(v17, &v12, &v11);
  caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,256000ul,caulk::alloc::guarded_edges_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,4ul>>,caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>::introspect(v6 + 16, a1, (uint64_t)&v15);
  v7 = v19;
  if (v19 == v18)
  {
    v8 = 4;
    v7 = v18;
  }
  else
  {
    if (!v19)
      goto LABEL_12;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_12:
  result = v17;
  if (v17 == v16)
  {
    v10 = 4;
    result = v16;
  }
  else
  {
    if (!v17)
      return result;
    v10 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v10))();
}

void sub_2065D0430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  caulk::alloc::introspector::~introspector((caulk::alloc::introspector *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2D518;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2D518;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(uint64_t a1, int *a2, uint64_t *a3, uint64_t *a4)
{
  return std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 24), *a2, *a3, *a4);
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc19allocator_enumerateINS0_8resourceINS0_15audio_allocatorENS0_15memory_resourceEEEEEvRT_NS_10option_setINS0_12region_usageEjEERKNSt3__18functionIFvS9_NS0_5blockEEEEEUlS9_mmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target_type()
{
}

void std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2D258;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2D258;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(uint64_t a1, int *a2)
{
  return caulk::alloc::describe_block(*(_QWORD *)(a1 + 8), *a2);
}

uint64_t std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc15print_allocatorINS0_8resourceINS0_15audio_allocatorENS0_15memory_resourceEEEEEvRT_RNSt3__113basic_ostreamIcNS8_11char_traitsIcEEEEbEUlNS0_12region_usageENS0_5blockEE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target_type()
{
}

void std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2E380;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2E380;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(uint64_t a1, int *a2, uint64_t *a3, uint64_t *a4)
{
  return std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 24), *a2, *a3, *a4);
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc19allocator_enumerateINS0_18tracking_allocatorINS0_14page_allocatorEEEEEvRT_NS_10option_setINS0_12region_usageEjEERKNSt3__18functionIFvS8_NS0_5blockEEEEEUlS8_mmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target_type()
{
}

void std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

__n128 std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_24BF2E278;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24BF2E278;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t **std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(uint64_t **result, int *a2, uint64_t a3)
{
  int v3;
  uint64_t **v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD **v10;
  uint64_t *v11;

  v3 = *a2;
  if ((*a2 - 3) >= 0xFFFFFFFE)
  {
    v4 = result;
    v5 = *(_QWORD *)(a3 + 8);
    v6 = v5 & 0x1FFFFFFFFFFFFFFFLL;
    v7 = (v5 >> 4) & 0x1FFFFFFFFFFFFFFLL;
    if (v6 <= 0xF423F)
      v8 = ((v6 + 1023) >> 10) | 0x2000000000000000;
    else
      v8 = ((v6 + 0xFFFFF) >> 20) | 0x4000000000000000;
    if (v7 >= 0x271)
      v9 = v8;
    else
      v9 = v6;
    v11 = (uint64_t *)(v9 | ((unint64_t)(v3 == 2) << 63));
    result = std::__tree<std::__value_type<unsigned long long,unsigned int>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned int>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t **)result[1], (unint64_t)v11, &v11);
    ++*((_DWORD *)result + 10);
    if (v3 == 2)
    {
      v10 = v4 + 4;
    }
    else
    {
      ++*v4[2];
      v10 = v4 + 3;
    }
    **v10 += v6;
  }
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc14base_allocator9formatter24summarize_blocks_by_sizeINS0_18tracking_allocatorINS0_14page_allocatorEEEEEvRT_mEUlNS0_12region_usageENS0_5blockEE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>(caulk::alloc::tracking_allocator<caulk::alloc::page_allocator> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target_type()
{
}

void std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2E430;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2E430;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(uint64_t a1, int *a2, uint64_t *a3, uint64_t *a4)
{
  return std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 24), *a2, *a3, *a4);
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc19allocator_enumerateINS0_22consolidating_free_mapINS0_14page_allocatorELm10485760EEEEEvRT_NS_10option_setINS0_12region_usageEjEERKNSt3__18functionIFvS8_NS0_5blockEEEEEUlS8_mmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target_type()
{
}

void std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

__n128 std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_24BF2E328;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24BF2E328;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t **std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(uint64_t **result, int *a2, uint64_t a3)
{
  int v3;
  uint64_t **v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD **v10;
  uint64_t *v11;

  v3 = *a2;
  if ((*a2 - 3) >= 0xFFFFFFFE)
  {
    v4 = result;
    v5 = *(_QWORD *)(a3 + 8);
    v6 = v5 & 0x1FFFFFFFFFFFFFFFLL;
    v7 = (v5 >> 4) & 0x1FFFFFFFFFFFFFFLL;
    if (v6 <= 0xF423F)
      v8 = ((v6 + 1023) >> 10) | 0x2000000000000000;
    else
      v8 = ((v6 + 0xFFFFF) >> 20) | 0x4000000000000000;
    if (v7 >= 0x271)
      v9 = v8;
    else
      v9 = v6;
    v11 = (uint64_t *)(v9 | ((unint64_t)(v3 == 2) << 63));
    result = std::__tree<std::__value_type<unsigned long long,unsigned int>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned int>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t **)result[1], (unint64_t)v11, &v11);
    ++*((_DWORD *)result + 10);
    if (v3 == 2)
    {
      v10 = v4 + 4;
    }
    else
    {
      ++*v4[2];
      v10 = v4 + 3;
    }
    **v10 += v6;
  }
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc14base_allocator9formatter24summarize_blocks_by_sizeINS0_22consolidating_free_mapINS0_14page_allocatorELm10485760EEEEEvRT_mEUlNS0_12region_usageENS0_5blockEE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::base_allocator::formatter::summarize_blocks_by_size<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>>(caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul> &,unsigned long)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target_type()
{
}

void caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,256000ul,caulk::alloc::guarded_edges_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,4ul>>,caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>::deallocate(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t owner;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned __int8 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  os_unfair_lock_s *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int128 *v25;
  uint64_t v26;

  if (a3 <= 0x3F0)
  {
    v24 = a1 + 784;
    v25 = (unsigned __int128 *)(a1 + 944);
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 944));
    owner = caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::find_owner(&v24, a2);
    if (owner)
    {
      v7 = owner;
      v8 = (unsigned int *)(owner + 16);
      caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::deallocate((caulk::alloc::base_allocator *)(owner + 16), a2, a3);
      v9 = atomic_load((unsigned int *)(v7 + 4));
      if (v9 == -1)
      {
        v10 = atomic_load(v8);
        if (v10 >= 0xFC)
        {
          do
            v11 = __ldaxr((unsigned __int8 *)v7);
          while (__stlxr(1u, (unsigned __int8 *)v7));
          if ((v11 & 1) == 0)
          {
            v26 = v7;
            caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::emplace<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>((unsigned __int128 *)(a1 + 1072), v7 + 288, &v26);
            atomic_store(0, (unsigned int *)(v7 + 4));
            atomic_store(0, (unsigned __int8 *)v7);
          }
        }
      }
      caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v25);
      return;
    }
LABEL_28:
    caulk::alloc::base_allocator::bad_dealloc((caulk::alloc::base_allocator *)owner);
  }
  if (a3 - 1009 > 0x3E40F)
  {
    if ((caulk::concurrent::skiplist<void *,caulk::alloc::detail::tracked_block,10,(caulk::concurrent::skiplist_options)0>::remove(a1 + 16, a2) & 1) != 0)
    {
      caulk::mach::vm_block::dealloc((caulk::mach::vm_block *)a2, (a3 + *MEMORY[0x24BDB03C8] - 1) & -*MEMORY[0x24BDB03C8]);
      return;
    }
    goto LABEL_27;
  }
  v12 = 0;
  v13 = a1 + 352;
  v14 = a2 ^ a3 ^ 0x3E9E8527D393999FLL;
  v15 = a2 - 32;
  do
  {
    if (*(_QWORD *)(v15 + v12) != v14)
    {
      _os_assert_log();
      _os_crash();
      __break(1u);
LABEL_26:
      _os_assert_log();
      _os_crash();
      __break(1u);
LABEL_27:
      _os_assert_log();
      owner = _os_crash();
      __break(1u);
      goto LABEL_28;
    }
    if (*(_QWORD *)(a2 + ((a3 + 7) & 0xFFFFFFFFFFFFFFF8) + v12) != v14)
      goto LABEL_26;
    v12 += 8;
  }
  while (v12 != 32);
  v16 = (os_unfair_lock_s *)(a1 + 704);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 704));
  if (!caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::size(v13, a2 - 32))
    caulk::alloc::base_allocator::bad_dealloc(0);
  v17 = a2 - 64;
  v18 = *(_QWORD *)(a2 - 40);
  v19 = *(_QWORD *)(a2 - 48) | 1;
  *(_QWORD *)(a2 - 48) = v19;
  if ((v18 & 1) == 0)
  {
    v20 = v15 + (v18 >> 1);
    if ((*(_BYTE *)(v20 + 16) & 1) != 0)
    {
      caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::remove_freemap_entry(v13, (uint64_t *)v20);
      caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::consolidate_free(a2 - 64, v20);
      v19 = *(_QWORD *)(a2 - 48);
    }
  }
  if (v19 >= 2 && (v21 = v17 - (v19 >> 1), (*(_BYTE *)(v21 - 16) & 1) != 0))
  {
    v22 = (_QWORD *)(v21 - 32);
    caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::remove_freemap_entry(v13, (uint64_t *)(v21 - 32));
    caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::consolidate_free((uint64_t)v22, v17);
  }
  else
  {
    v22 = (_QWORD *)(a2 - 64);
  }
  v23 = caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::add_freemap_node(v13, v22);
  caulk::alloc::page_allocator::advise_free(v23, (uint64_t)(v22 + 4), v22[3] >> 1);
  os_unfair_lock_unlock(v16);
}

void sub_2065D0D1C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

unsigned __int128 *caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::emplace<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>(unsigned __int128 *result, unint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  unsigned __int128 *v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  int v10;
  int value;
  uint64_t i;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unsigned __int128 *v17;
  unint64_t *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  char v27;
  char v28;
  unint64_t v29;
  unint64_t v30;
  char v31;
  int v32;
  char v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v37;

  if (*(_QWORD *)result >= a2 || (v4 = (uint64_t)result, *((_QWORD *)result + 14) <= a2))
  {
    __break(1u);
  }
  else
  {
    v5 = result + 10;
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal(result + 10);
    v37 = a2;
    v6 = (_QWORD *)caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>(v4, &v37, 0);
    if (*v6 != a2)
    {
      v8 = v6;
      v9 = v7;
      v10 = 0;
      value = 0;
      for (i = 1; i != 4; ++i)
      {
        if (i == 1)
        {
          caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::random_engine();
          value = caulk::multi_simple_random<unsigned int,4ul,std::uniform_int_distribution<unsigned int>,std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>::next_value((uint64_t)&caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::random_engine(void)::engine);
          v10 = 3;
        }
        if ((v10 & ~value) != 0)
          break;
        v10 *= 4;
      }
      v13 = 0;
      v14 = *(_QWORD *)(v4 + 176);
      while (1)
      {
        v15 = *(_QWORD *)&caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::node_sizes[8 * v13];
        if (v15 >= *(_QWORD *)&caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::node_sizes[8 * i - 8])
          break;
        if (++v13 == 5)
        {
          v16 = 0;
          goto LABEL_19;
        }
      }
      v17 = (unsigned __int128 *)(v14 + 64 + 32 * v13);
      v18 = caulk::concurrent::stack<caulk::alloc::free_block,caulk::concurrent::intrusive_single_link_node<caulk::alloc::free_block>>::pop(v17);
      if (v18)
      {
        v16 = (unint64_t)v18;
        v19 = (unint64_t *)(v17 + 1);
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
      }
      else
      {
        v16 = caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>::allocate(v14, v15);
      }
      v5 = (unsigned __int128 *)(v4 + 160);
LABEL_19:
      *(_BYTE *)(v16 + 16) = i;
      *(_WORD *)(v16 + 17) = 1;
      *(_BYTE *)(v16 + 19) = i;
      *(_QWORD *)v16 = a2;
      *(_QWORD *)(v16 + 8) = 0;
      *(_QWORD *)(v16 + 8) = *a3;
      *(_QWORD *)(v16 + 32) = 0;
      *(_QWORD *)(v16 + 40) = 0;
      *(_QWORD *)(v16 + 24) = 0;
      if ((_BYTE)i)
      {
        v21 = (unint64_t *)(v16 + 40);
        v22 = i;
        do
        {
          atomic_store(0, v21 - 1);
          atomic_store(0, v21);
          v21 += 2;
          --v22;
        }
        while (v22);
      }
      v23 = 0;
      __dmb(0xBu);
      while (1)
      {
        while (*v8 != *(_QWORD *)v16)
        {
          v24 = &v8[2 * v23 + 4];
          v25 = atomic_load(v24);
          if ((v25 & 2) != 0)
          {
            caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(v4, v23, (unint64_t)v8, v25 & 0xFFFFFFFFFFFFFFFCLL);
          }
          else
          {
            atomic_store(v9, (unint64_t *)(v16 + 16 * v23 + 32));
            v26 = __ldaxr(v24);
            if (v26 == v9)
            {
              if (!__stlxr(v16, v24))
              {
                v35 = v16;
                goto LABEL_42;
              }
            }
            else
            {
              __clrex();
            }
            if ((v26 & 2) != 0)
              caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(v4, v23, (unint64_t)v8, v26 & 0xFFFFFFFFFFFFFFFCLL);
            v27 = atomic_load(v24);
            if ((v27 & 1) != 0)
            {
              do
              {
                v8 = (_QWORD *)atomic_load(&v8[2 * v23 + 5]);
                v28 = atomic_load(&v8[2 * v23 + 4]);
              }
              while ((v28 & 1) != 0);
            }
          }
          v29 = *(_QWORD *)v16;
          while (1)
          {
            v30 = atomic_load(&v8[2 * v23 + 4]);
            v9 = v30 & 0xFFFFFFFFFFFFFFFCLL;
            if (v29 < *(_QWORD *)(v30 & 0xFFFFFFFFFFFFFFFCLL))
              break;
            v31 = atomic_load((unint64_t *)(v9 + 32));
            if ((v31 & 1) != 0)
            {
              v8 = (_QWORD *)caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::try_flag_node(v4, v23, (unint64_t)v8, v9);
              if (!v32)
                caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::help_flagged(v4, v23, (unint64_t)v8, v9);
            }
            else
            {
              v8 = (_QWORD *)v9;
            }
          }
        }
        v35 = 0;
LABEL_42:
        if (!(v35 | v23))
          break;
        v33 = atomic_load((unint64_t *)(v16 + 32));
        if ((v33 & 1) != 0)
          return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v5);
        if (++v23 == i)
          return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v5);
        v37 = a2;
        v8 = (_QWORD *)caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>(v4, &v37, v23);
        v9 = v34;
      }
      caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>::deallocate(*(caulk::alloc::base_allocator **)(v4 + 176), (unint64_t *)v16, *(_QWORD *)&caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::node_sizes[8 * *(unsigned __int8 *)(v16 + 16) - 8]);
    }
    return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v5);
  }
  return result;
}

void caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::random_engine()
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      caulk::multi_simple_random<unsigned int,4ul,std::uniform_int_distribution<unsigned int>,std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>::multi_simple_random((uint64_t)&caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::random_engine(void)::engine);
    }
  }
}

void sub_2065D110C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,256000ul,caulk::alloc::guarded_edges_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,4ul>>,caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>::allocate(uint64_t a1, unint64_t a2, unint64_t a3)
{
  unsigned __int128 *v4;
  char *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t *v14;
  uint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  BOOL v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t v22;
  uint64_t *v23;
  unint64_t v24;
  BOOL v25;
  _QWORD *v26;
  unint64_t v27;
  BOOL v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t result;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  char v35;
  char *v36;
  uint64_t v37;
  unsigned __int8 v38;
  uint64_t v39;
  unint64_t v40;
  char v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  char v47;
  unsigned __int8 v48;
  unint64_t v49;
  uint64_t v51;
  unsigned __int8 v52;
  unsigned __int128 *v53;
  _QWORD *v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unsigned __int128 *v61;
  unsigned __int128 *v62;
  uint64_t v63;
  char *v65;

  if (a2 <= 0x3F0 && a3 <= 0x10)
  {
    v61 = (unsigned __int128 *)(a1 + 944);
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 944));
    v4 = (unsigned __int128 *)(a1 + 1072);
    v62 = (unsigned __int128 *)(a1 + 1232);
    caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal((unsigned __int128 *)(a1 + 1232));
    v5 = *(char **)(a1 + 1360);
    if (v5)
    {
      v65 = *(char **)(a1 + 1360);
      v7 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>(a1 + 1072, &v65, 0);
      if (*(char **)v7 != v5)
      {
        if (*(_BYTE *)(v6 + 18) == 2)
          v7 = a1 + 1184;
        else
          v7 = v6;
      }
    }
    else
    {
      v32 = atomic_load((unint64_t *)(a1 + 1104));
      v7 = v32 & 0xFFFFFFFFFFFFFFFCLL;
    }
    v63 = a1;
    v33 = a1 + 1184;
    if (a1 + 1184 != v7)
    {
      v34 = v7;
      do
      {
        if (*(_BYTE *)(v34 + 18) != 2)
        {
          v35 = atomic_load((unint64_t *)(v34 + 32));
          if ((v35 & 1) == 0)
          {
            v37 = *(_QWORD *)v34;
            v36 = *(char **)(v34 + 8);
            do
              v38 = __ldaxr((unsigned __int8 *)v36);
            while (__stlxr(1u, (unsigned __int8 *)v36));
            if ((v38 & 1) == 0)
            {
              v39 = caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::allocate((unsigned int *)v36 + 4, a2);
              if (v39)
                goto LABEL_87;
              atomic_store(0xFFFFFFFF, (unsigned int *)v36 + 1);
              caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove((uint64_t)v4, v37);
              atomic_store(0, (unsigned __int8 *)v36);
            }
          }
        }
        v40 = atomic_load((unint64_t *)(v34 + 32));
        v34 = v40 & 0xFFFFFFFFFFFFFFFCLL;
      }
      while (v33 != (v40 & 0xFFFFFFFFFFFFFFFCLL));
    }
    if (*(_BYTE *)(v7 + 18) == 2 || (v41 = atomic_load((unint64_t *)(v7 + 32)), (v41 & 1) != 0))
    {
      if (v5)
      {
        v65 = v5;
        v7 = caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::search_to_level<caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::key_le>((uint64_t)v4, &v65, 0);
        if (*(char **)v7 != v5)
        {
          if (*(_BYTE *)(v42 + 18) == 2)
            v7 = v33;
          else
            v7 = v42;
        }
      }
      else
      {
        v43 = atomic_load((unint64_t *)(v63 + 1104));
        v7 = v43 & 0xFFFFFFFFFFFFFFFCLL;
      }
    }
    v44 = atomic_load((unint64_t *)(v63 + 1104));
    v45 = v44 & 0xFFFFFFFFFFFFFFFCLL;
    if (v7 != (v44 & 0xFFFFFFFFFFFFFFFCLL) && v33 != v45)
    {
      do
      {
        if (*(_BYTE *)(v45 + 18) != 2)
        {
          v47 = atomic_load((unint64_t *)(v45 + 32));
          if ((v47 & 1) == 0)
          {
            v37 = *(_QWORD *)v45;
            v36 = *(char **)(v45 + 8);
            do
              v48 = __ldaxr((unsigned __int8 *)v36);
            while (__stlxr(1u, (unsigned __int8 *)v36));
            if ((v48 & 1) == 0)
            {
              v39 = caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::allocate((unsigned int *)v36 + 4, a2);
              if (v39)
                goto LABEL_87;
              atomic_store(0xFFFFFFFF, (unsigned int *)v36 + 1);
              caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove((uint64_t)v4, v37);
              atomic_store(0, (unsigned __int8 *)v36);
            }
          }
        }
        v49 = atomic_load((unint64_t *)(v45 + 32));
        v45 = v49 & 0xFFFFFFFFFFFFFFFCLL;
      }
      while (v7 != (v49 & 0xFFFFFFFFFFFFFFFCLL) && v33 != v45);
    }
    while (1)
    {
      do
      {
        v36 = (char *)caulk::alloc::page_allocator::allocate((caulk::alloc::page_allocator *)(v63 + 760), 0x4000, 0x10uLL);
        *v36 = 0;
        *((_DWORD *)v36 + 1) = 0;
        *((_OWORD *)v36 + 1) = 0u;
        *((_QWORD *)v36 + 1) = v51;
        v37 = (uint64_t)(v36 + 288);
        *((_OWORD *)v36 + 2) = 0u;
        *((_OWORD *)v36 + 3) = 0u;
        *((_OWORD *)v36 + 4) = 0u;
        *((_OWORD *)v36 + 5) = 0u;
        *((_OWORD *)v36 + 6) = 0u;
        *((_OWORD *)v36 + 7) = 0u;
        *((_OWORD *)v36 + 8) = 0u;
        *((_OWORD *)v36 + 9) = 0u;
        *((_OWORD *)v36 + 10) = 0u;
        *((_OWORD *)v36 + 11) = 0u;
        *((_OWORD *)v36 + 12) = 0u;
        *((_OWORD *)v36 + 13) = 0u;
        *((_OWORD *)v36 + 14) = 0u;
        *((_OWORD *)v36 + 15) = 0u;
        *((_OWORD *)v36 + 16) = 0u;
        *((_QWORD *)v36 + 34) = 0;
        caulk::alloc::base_allocator::assert_aligned((uint64_t)(v36 + 288), 16);
        *(_OWORD *)(v36 + 248) = 0u;
        *(_OWORD *)(v36 + 232) = 0u;
        *(_OWORD *)(v36 + 216) = 0u;
        *(_OWORD *)(v36 + 200) = 0u;
        *(_OWORD *)(v36 + 184) = 0u;
        *(_OWORD *)(v36 + 168) = 0u;
        *(_OWORD *)(v36 + 152) = 0u;
        *(_OWORD *)(v36 + 136) = 0u;
        *(_OWORD *)(v36 + 120) = 0u;
        *(_OWORD *)(v36 + 104) = 0u;
        *(_OWORD *)(v36 + 88) = 0u;
        *(_OWORD *)(v36 + 72) = 0u;
        *(_OWORD *)(v36 + 56) = 0u;
        *(_OWORD *)(v36 + 40) = 0u;
        *(_OWORD *)(v36 + 24) = 0u;
        *(_OWORD *)(v36 + 264) = 0u;
        atomic_store(0x3EEu, (unsigned int *)v36 + 4);
        atomic_store(0, (unsigned int *)v36 + 5);
        v65 = v36;
        caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::emplace<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>((unsigned __int128 *)(v63 + 784), (unint64_t)(v36 + 288), &v65);
        v65 = v36;
        caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::emplace<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>(v4, (unint64_t)(v36 + 288), &v65);
        do
          v52 = __ldaxr((unsigned __int8 *)v36);
        while (__stlxr(1u, (unsigned __int8 *)v36));
      }
      while ((v52 & 1) != 0);
      v39 = caulk::alloc::bitmap_allocator<caulk::alloc::embed_block_memory,16368ul,16ul,6ul>::allocate((unsigned int *)v36 + 4, a2);
      if (v39)
        break;
      atomic_store(0xFFFFFFFF, (unsigned int *)v36 + 1);
      caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::remove((uint64_t)v4, v37);
      atomic_store(0, (unsigned __int8 *)v36);
    }
LABEL_87:
    v10 = v39;
    v53 = v62;
    *(_QWORD *)(v63 + 1360) = v37;
    atomic_store(0, (unsigned __int8 *)v36);
    caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v53);
    caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::end_traversal(v61);
    return v10;
  }
  if (a2 - 1009 > 0x3E40F || a3 > 0x10)
    return caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>::allocate((caulk::alloc::page_allocator *)a1, a2, a3);
  v8 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
  v9 = (v8 + 79) & 0xFFFFFFFFFFFFFFF0;
  if ((uint64_t)v9 < 1)
    return 0;
  v10 = 0;
  v11 = (_QWORD *)MEMORY[0x24BDB03C8];
  if (v9 + 32 > ((unint64_t)(*MEMORY[0x24BDB03C8] + 10485759) & -*MEMORY[0x24BDB03C8]))
    return v10;
  v12 = v8 + 64;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 704));
  v13 = *(_QWORD **)(a1 + 720);
  if (!v13)
    goto LABEL_89;
  v14 = (uint64_t *)(a1 + 720);
  v15 = (uint64_t *)(a1 + 720);
  v16 = *(_QWORD **)(a1 + 720);
  do
  {
    v17 = v16[4];
    v18 = v17 >= v9;
    if (v17 >= v9)
      v19 = v16;
    else
      v19 = v16 + 1;
    if (v18)
      v15 = v16;
    v16 = (_QWORD *)*v19;
  }
  while (*v19);
  if (v15 == v14)
    goto LABEL_89;
  v20 = v15[4];
  if (v20 >= 2 * v9 || v20 - v9 <= v20 >> 3)
    goto LABEL_41;
  v22 = 2 * v9;
  v23 = (uint64_t *)(a1 + 720);
  do
  {
    v24 = v13[4];
    v25 = v24 >= v22;
    if (v24 >= v22)
      v26 = v13;
    else
      v26 = v13 + 1;
    if (v25)
      v23 = v13;
    v13 = (_QWORD *)*v26;
  }
  while (*v26);
  if (v23 == v14 || ((v27 = v23[4], v27 < v22) ? (v28 = v27 - v9 > v27 >> 3) : (v28 = 0), v28))
LABEL_41:
    v23 = v15;
  if (v23 == v14)
  {
LABEL_89:
    v54 = (_QWORD *)caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>::allocate((caulk::alloc::page_allocator *)(a1 + 352), (*v11 + 10485759) & -*v11, 0x1000uLL);
    v56 = v54;
    if (v54)
    {
      *(_QWORD *)(a1 + 736) += v55;
      *v54 = 0;
      v54[1] = 0;
      v54[2] = 0;
      v54[3] = 2 * v55 - 63;
      caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::maybe_create_free_node(a1 + 352, (uint64_t)v54, v9);
      v57 = (uint64_t)(v56 + 4);
    }
    else
    {
      v57 = 0;
      v12 = 0;
    }
    goto LABEL_95;
  }
  v29 = v23[6];
  if (v29)
  {
    v30 = *(_QWORD **)(v29 + 8);
    v23[6] = (uint64_t)v30;
    if (v30)
    {
      *v30 = v23 + 5;
    }
    else
    {
      std::__tree<std::__value_type<unsigned long,caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::FreelistOfSize>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::FreelistOfSize>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::FreelistOfSize>>>::__remove_node_pointer((uint64_t **)(a1 + 712), v23);
      operator delete(v23);
    }
    caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>::maybe_create_free_node(a1 + 352, v29, v9);
    *(_QWORD *)(v29 + 16) &= ~1uLL;
    v57 = v29 + 32;
LABEL_95:
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 704));
    if (v57)
      v10 = v57 + 32;
    else
      v10 = 0;
    if (v57)
      v58 = a2;
    else
      v58 = v12;
    if (v57)
    {
      v59 = 0;
      v60 = v10 ^ v58 ^ 0x3E9E8527D393999FLL;
      do
      {
        *(_QWORD *)(v10 - 32 + v59) = v60;
        *(_QWORD *)(v10 + ((v58 + 7) & 0xFFFFFFFFFFFFFFF8) + v59) = v60;
        v59 += 8;
      }
      while (v59 != 32);
    }
    return v10;
  }
  _os_assert_log();
  result = _os_crash();
  __break(1u);
  return result;
}

void sub_2065D1734(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  os_unfair_lock_s *v11;

  os_unfair_lock_unlock(v11);
  _Unwind_Resume(a1);
}

void std::default_delete<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_plus>::operator()[abi:ne180100](uint64_t a1)
{
  malloc_zone_unregister((malloc_zone_t *)(a1 + 8));
  JUMPOUT(0x20BCF9C08);
}

uint64_t caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::skiplist(uint64_t a1)
{
  unint64_t v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t i;
  _QWORD *v9;
  unint64_t *p_shared_weak_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t j;

  *(_OWORD *)(a1 + 112) = 0u;
  v2 = a1 + 112;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  os_unfair_lock_lock((os_unfair_lock_t)&caulk::alloc::shared_allocator<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::shared_instance(void)::global);
  if (qword_253D02048)
  {
    v3 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_253D02048);
    if (v3)
    {
      v4 = v3;
      v5 = qword_253D02040;
      if (qword_253D02040)
        goto LABEL_14;
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
  v4 = (std::__shared_weak_count *)operator new(0x100uLL);
  v4->__shared_owners_ = 0;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2D7B8;
  *(_OWORD *)&v4[1].__shared_owners_ = 0u;
  v5 = (uint64_t)&v4[1].__shared_owners_;
  v4[2].std::__shared_count = 0u;
  *(_OWORD *)&v4[2].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v4[3].__shared_owners_ = 0u;
  v4[4].std::__shared_count = 0u;
  *(_OWORD *)&v4[4].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v4[5].__shared_owners_ = 0u;
  v4[6].std::__shared_count = 0u;
  *(_OWORD *)&v4[6].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v4[7].__shared_owners_ = 0u;
  v4[8].std::__shared_count = 0u;
  *(_OWORD *)&v4[8].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v4[9].__shared_owners_ = 0u;
  v4[10].std::__shared_count = 0u;
  caulk::alloc::global_page_cache::instance((caulk::alloc::global_page_cache *)v4);
  v4[3].__shared_owners_ = 0;
  v4[1].__shared_weak_owners_ = (uint64_t)&unk_253D0A3B0;
  v4[2].__vftable = 0;
  v4[2].__shared_owners_ = 0;
  v4[2].__shared_weak_owners_ = 0;
  LODWORD(v4[3].__vftable) = 0;
  for (i = 96; i != 256; i += 32)
  {
    v9 = (std::__shared_weak_count_vtbl **)((char *)&v4->__vftable + i);
    *v9 = 0;
    v9[1] = 0;
    v9[2] = 0;
  }
  p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
  do
    v11 = __ldxr(p_shared_weak_owners);
  while (__stxr(v11 + 1, p_shared_weak_owners));
  v12 = (std::__shared_weak_count *)qword_253D02048;
  qword_253D02040 = (uint64_t)&v4[1].__shared_owners_;
  qword_253D02048 = (uint64_t)v4;
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
LABEL_14:
  os_unfair_lock_unlock((os_unfair_lock_t)&caulk::alloc::shared_allocator<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::shared_instance(void)::global);
  v13 = (unint64_t *)&v4->__shared_owners_;
  do
    v14 = __ldxr(v13);
  while (__stxr(v14 + 1, v13));
  v15 = *(std::__shared_weak_count **)(a1 + 184);
  *(_QWORD *)(a1 + 176) = v5;
  *(_QWORD *)(a1 + 184) = v4;
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  do
    v18 = __ldaxr(v13);
  while (__stlxr(v18 - 1, v13));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  *(_QWORD *)(a1 + 192) = &caulk::inplace_function_detail::vtable<void,caulk::concurrent::details::skiplist_node<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>::layout_kv const&>::empty;
  *(_QWORD *)(a1 + 232) = &caulk::inplace_function_detail::vtable<void>::empty;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 280) = 0;
  caulk::concurrent::skiplist<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5,(caulk::concurrent::skiplist_options)1>::random_engine();
  v19 = 0;
  *(_DWORD *)(a1 + 16) = 83951621;
  *(_OWORD *)a1 = 0u;
  *(_QWORD *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  do
  {
    atomic_store(0, (unint64_t *)(a1 + v19 + 32));
    atomic_store(0, (unint64_t *)(a1 + v19 + 40));
    v19 += 16;
  }
  while (v19 != 80);
  *(_QWORD *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 128) = 16908289;
  *(_OWORD *)(a1 + 112) = xmmword_2065DE1A0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  atomic_store(0, (unint64_t *)(a1 + 144));
  atomic_store(0, (unint64_t *)(a1 + 152));
  for (j = 32; j != 112; j += 16)
    atomic_store(v2, (unint64_t *)(a1 + j));
  __dmb(0xBu);
  return a1;
}

void sub_2065D1A40(void *a1)
{
  std::__shared_weak_count *v1;
  uint64_t v2;
  void *v4;

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&caulk::alloc::shared_allocator<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::shared_instance(void)::global);
  std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](v2);
  __clang_call_terminate(a1);
}

caulk::alloc::base_allocator *caulk::inplace_function_detail::vtable<void>::vtable<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>(caulk::inplace_function_detail::wrapper<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,256ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::perform_deferred_deletions<true,(BOOL *)0>((caulk::alloc::base_allocator *)(*(_QWORD *)a1 + 480));
}

_QWORD *caulk::inplace_function_detail::vtable<void>::vtable<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>(caulk::inplace_function_detail::wrapper<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>)::{lambda(void *,void *)#1}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void>::vtable<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>(caulk::inplace_function_detail::wrapper<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::tree_allocator(void)::{lambda(void)#1}>)::{lambda(void *,void *)#2}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

void caulk::inplace_function_detail::vtable<void,caulk::concurrent::details::skiplist_node<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>::layout_kv const&>::vtable(void)::{lambda(void *,caulk::concurrent::details::skiplist_node<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *>::layout_kv const&)#1}::__invoke()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

void _ZZN5caulk23inplace_function_detail6vtableIvJRKNS_10concurrent7details13skiplist_nodeImPNS_5alloc15chunk_allocatorINS5_14page_allocatorENS5_16bitmap_allocatorENS5_18embed_block_memoryELm16384EJLm16ELm6EEE9node_implINS5_14tree_allocatorISA_E11node_headerES9_EEE9layout_kvEEEC1IZNSD_C1EvEUlRKT_E_EENS0_7wrapperISN_EEENUlPvSK_E_8__invokeEST_SK_(uint64_t a1, uint64_t a2)
{
  caulk::mach::vm_block::dealloc(*(caulk::mach::vm_block **)(a2 + 8), (*(_QWORD *)(*(_QWORD *)(a2 + 8) + 8) + *MEMORY[0x24BDB03C8] - 1) & -*MEMORY[0x24BDB03C8]);
}

_QWORD *_ZZN5caulk23inplace_function_detail6vtableIvJRKNS_10concurrent7details13skiplist_nodeImPNS_5alloc15chunk_allocatorINS5_14page_allocatorENS5_16bitmap_allocatorENS5_18embed_block_memoryELm16384EJLm16ELm6EEE9node_implINS5_14tree_allocatorISA_E11node_headerES9_EEE9layout_kvEEEC1IZNSD_C1EvEUlRKT_E_EENS0_7wrapperISN_EEENUlPvST_E_8__invokeEST_ST_(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *_ZZN5caulk23inplace_function_detail6vtableIvJRKNS_10concurrent7details13skiplist_nodeImPNS_5alloc15chunk_allocatorINS5_14page_allocatorENS5_16bitmap_allocatorENS5_18embed_block_memoryELm16384EJLm16ELm6EEE9node_implINS5_14tree_allocatorISA_E11node_headerES9_EEE9layout_kvEEEC1IZNSD_C1EvEUlRKT_E_EENS0_7wrapperISN_EEENUlPvST_E0_8__invokeEST_ST_(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

void std::__shared_ptr_emplace<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2D7B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2D7B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BCF9C08);
}

void std::__shared_ptr_emplace<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::size_generator,8ul,1ul,-1l>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t v7;

  v1 = 0;
  v2 = (_QWORD *)(a1 + 32);
  v3 = a1 + 96;
  do
  {
    v4 = *(_QWORD *)&caulk::concurrent::details::node_allocator<unsigned long,caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>::node_impl<caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>::node_header,caulk::alloc::embed_block_memory> *,5ul,(caulk::concurrent::skiplist_options)1>::node_sizes[8 * v1];
    v5 = (unint64_t *)(v3 + 32 * v1 + 16);
    while (1)
    {
      v6 = caulk::concurrent::stack<caulk::alloc::free_block,caulk::concurrent::intrusive_single_link_node<caulk::alloc::free_block>>::pop((unsigned __int128 *)(v3 + 32 * v1));
      if (!v6)
        break;
      do
        v7 = __ldaxr(v5);
      while (__stlxr(v7 - 1, v5));
      caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>::deallocate(v2, (unint64_t)v6, v4);
    }
    ++v1;
  }
  while (v1 != 5);
  caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>::self_deallocate_all((uint64_t)v2);
}

void caulk::alloc::exported_resource<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>,caulk::alloc::memory_resource,caulk::memory_resource>::~exported_resource(std::pmr::memory_resource *a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = &off_24BF2CD58;
  *((_QWORD *)a1 + 2) = &off_24BF2CC40;
  v2 = (uint64_t)a1 + 16;
  v3 = *((_QWORD *)a1 + 176);
  *((_QWORD *)a1 + 176) = 0;
  if (v3)
    std::default_delete<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_plus>::operator()[abi:ne180100](v3);
  caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::~resource(v2);
  std::pmr::memory_resource::~memory_resource(a1);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = &off_24BF2CD58;
  *((_QWORD *)a1 + 2) = &off_24BF2CC40;
  v2 = (uint64_t)a1 + 16;
  v3 = *((_QWORD *)a1 + 176);
  *((_QWORD *)a1 + 176) = 0;
  if (v3)
    std::default_delete<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::zone_plus>::operator()[abi:ne180100](v3);
  caulk::alloc::resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>::~resource(v2);
  std::pmr::memory_resource::~memory_resource(a1);
  JUMPOUT(0x20BCF9C08);
}

void *caulk::alloc::exported_resource<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>,caulk::alloc::memory_resource,caulk::memory_resource>::do_allocate(uint64_t a1, unint64_t a2, unint64_t a3)
{
  void *v3;
  size_t v4;
  void *v5;

  v3 = (void *)caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,256000ul,caulk::alloc::guarded_edges_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,4ul>>,caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>::allocate(a1 + 32, a2, a3);
  v5 = v3;
  if (v3)
    bzero(v3, v4);
  return v5;
}

void caulk::alloc::exported_resource<caulk::alloc::darwin_resource<caulk::alloc::audio_allocator,caulk::alloc::memory_resource>,caulk::alloc::memory_resource,caulk::memory_resource>::do_deallocate(uint64_t a1, unint64_t a2, unint64_t a3)
{
  caulk::alloc::tiered_allocator<caulk::alloc::size_range_tier<0ul,1008ul,caulk::alloc::tree_allocator<caulk::alloc::chunk_allocator<caulk::alloc::page_allocator,caulk::alloc::bitmap_allocator,caulk::alloc::embed_block_memory,16384ul,16ul,6ul>>>,caulk::alloc::size_range_tier<1009ul,256000ul,caulk::alloc::guarded_edges_allocator<caulk::alloc::consolidating_free_map<caulk::alloc::page_allocator,10485760ul>,4ul>>,caulk::alloc::tracking_allocator<caulk::alloc::page_allocator>>::deallocate(a1 + 32, a2, a3);
}

uint64_t caulk::alloc::resource<caulk::alloc::zeroing_allocator<caulk::alloc::malloc_zone_allocator>,caulk::alloc::memory_resource>::~resource(uint64_t a1)
{
  caulk::alloc::malloc_zone_allocator::~malloc_zone_allocator((malloc_zone_t **)(a1 + 8));
  return a1;
}

void caulk::alloc::resource<caulk::alloc::zeroing_allocator<caulk::alloc::malloc_zone_allocator>,caulk::alloc::memory_resource>::~resource(uint64_t a1)
{
  caulk::alloc::malloc_zone_allocator::~malloc_zone_allocator((malloc_zone_t **)(a1 + 8));
  JUMPOUT(0x20BCF9C08);
}

void caulk::alloc::resource<caulk::alloc::zeroing_allocator<caulk::alloc::malloc_zone_allocator>,caulk::alloc::memory_resource>::do_allocate(uint64_t a1, size_t a2, size_t a3)
{
  void *v3;
  size_t v4;
  std::bad_alloc *exception;
  std::bad_alloc *v6;

  v3 = caulk::alloc::malloc_zone_allocator::allocate((malloc_zone_t **)(a1 + 8), a2, a3);
  if (!v3)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v6 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v6, MEMORY[0x24BEDB758], MEMORY[0x24BEDB670]);
  }
  bzero(v3, v4);
}

void caulk::alloc::resource<caulk::alloc::zeroing_allocator<caulk::alloc::malloc_zone_allocator>,caulk::alloc::memory_resource>::do_deallocate(uint64_t a1, void *a2)
{
  malloc_zone_free(*(malloc_zone_t **)(a1 + 8), a2);
}

BOOL caulk::alloc::resource<caulk::alloc::zeroing_allocator<caulk::alloc::malloc_zone_allocator>,caulk::alloc::memory_resource>::do_is_equal(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

_QWORD *caulk::alloc::resource<caulk::alloc::zeroing_allocator<caulk::alloc::malloc_zone_allocator>,caulk::alloc::memory_resource>::print(uint64_t a1, uint64_t a2)
{
  malloc_zone_t **v2;
  uint64_t v4;
  int v5;
  char v6;

  v4 = a2;
  v5 = 0;
  v6 = 0;
  v2 = (malloc_zone_t **)(a1 + 8);
  caulk::alloc::base_allocator::formatter::emit_string(&v4, "[zeroing] ");
  return caulk::alloc::malloc_zone_allocator::describe(v2, (caulk::alloc::base_allocator::formatter *)&v4);
}

uint64_t caulk::alloc::resource<caulk::alloc::zeroing_allocator<caulk::alloc::malloc_zone_allocator>,caulk::alloc::memory_resource>::compact()
{
  return 0;
}

void caulk::alloc::resource<caulk::alloc::zeroing_allocator<caulk::alloc::malloc_zone_allocator>,caulk::alloc::memory_resource>::reserve(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void caulk::alloc::exported_resource<caulk::alloc::resource<caulk::alloc::zeroing_allocator<caulk::alloc::malloc_zone_allocator>,caulk::alloc::memory_resource>,caulk::alloc::memory_resource,caulk::memory_resource>::~exported_resource(malloc_zone_t **a1)
{
  *a1 = (malloc_zone_t *)&off_24BF2CD90;
  caulk::alloc::malloc_zone_allocator::~malloc_zone_allocator(a1 + 3);
  std::pmr::memory_resource::~memory_resource((std::pmr::memory_resource *)a1);
}

{
  *a1 = (malloc_zone_t *)&off_24BF2CD90;
  caulk::alloc::malloc_zone_allocator::~malloc_zone_allocator(a1 + 3);
  std::pmr::memory_resource::~memory_resource((std::pmr::memory_resource *)a1);
  JUMPOUT(0x20BCF9C08);
}

void *caulk::alloc::exported_resource<caulk::alloc::resource<caulk::alloc::zeroing_allocator<caulk::alloc::malloc_zone_allocator>,caulk::alloc::memory_resource>,caulk::alloc::memory_resource,caulk::memory_resource>::do_allocate(uint64_t a1, size_t a2, size_t a3)
{
  void *v3;
  size_t v4;
  void *v5;

  v3 = caulk::alloc::malloc_zone_allocator::allocate((malloc_zone_t **)(a1 + 24), a2, a3);
  v5 = v3;
  if (v3)
    bzero(v3, v4);
  return v5;
}

void caulk::alloc::exported_resource<caulk::alloc::resource<caulk::alloc::zeroing_allocator<caulk::alloc::malloc_zone_allocator>,caulk::alloc::memory_resource>,caulk::alloc::memory_resource,caulk::memory_resource>::do_deallocate(uint64_t a1, void *a2)
{
  malloc_zone_free(*(malloc_zone_t **)(a1 + 24), a2);
}

uint64_t caulk::rt_safe_memory_resource::rt_allocate(caulk::rt_safe_memory_resource *this)
{
  return (*(uint64_t (**)(caulk::rt_safe_memory_resource *))(*(_QWORD *)this + 16))(this);
}

uint64_t caulk::rt_safe_memory_resource::rt_deallocate(caulk::rt_safe_memory_resource *this, void *a2)
{
  return (*(uint64_t (**)(caulk::rt_safe_memory_resource *, void *))(*(_QWORD *)this + 24))(this, a2);
}

uint64_t caulk::audio_buffer_resource(caulk *this)
{
  uint64_t v1;
  uint64_t result;

  caulk::alloc::_audio_buffer_resource(this);
  if (v1)
    return v1;
  _os_assert_log();
  result = _os_crash();
  __break(1u);
  return result;
}

caulk::autorelease_pool *caulk::autorelease_pool::autorelease_pool(caulk::autorelease_pool *this)
{
  *(_QWORD *)this = objc_alloc_init(MEMORY[0x24BDD1460]);
  return this;
}

{
  *(_QWORD *)this = objc_alloc_init(MEMORY[0x24BDD1460]);
  return this;
}

void caulk::autorelease_pool::~autorelease_pool(id *this)
{

}

{

}

void caulk::bad_expected_access<int>::~bad_expected_access(std::exception *a1)
{
  std::exception::~exception(a1);
  JUMPOUT(0x20BCF9C08);
}

void caulk::mach::os_workgroup::~os_workgroup(caulk::mach::details **this, void *a2)
{
  *this = (caulk::mach::details *)&off_24BF2E020;
  caulk::mach::details::release_os_object(this[1], a2);
}

{
  *this = (caulk::mach::details *)&off_24BF2E020;
  caulk::mach::details::release_os_object(this[1], a2);
  JUMPOUT(0x20BCF9C08);
}

{
  *this = (caulk::mach::details *)&off_24BF2E020;
  caulk::mach::details::release_os_object(this[1], a2);
}

void caulk::mach::os_workgroup_interval::~os_workgroup_interval(caulk::mach::details **this, void *a2)
{
  *this = (caulk::mach::details *)&off_24BF2E020;
  caulk::mach::details::release_os_object(this[1], a2);
}

{
  *this = (caulk::mach::details *)&off_24BF2E020;
  caulk::mach::details::release_os_object(this[1], a2);
  JUMPOUT(0x20BCF9C08);
}

{
  *this = (caulk::mach::details *)&off_24BF2E020;
  caulk::mach::details::release_os_object(this[1], a2);
}

void caulk::mach::os_workgroup::make(_QWORD *a1@<X8>)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  os_workgroup_attr_set_flags();
  v2 = (void *)os_workgroup_create();
  v4 = caulk::mach::details::retain_os_object(v2, v3);
  *a1 = &off_24BF2E020;
  a1[1] = v4;
  caulk::mach::details::release_os_object((caulk::mach::details *)v2, v5);
}

void sub_2065D2274(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

os_workgroup_t caulk::mach::os_workgroup::make@<X0>(const char *a1@<X0>, mach_port_t a2@<W1>, _QWORD *a3@<X8>)
{
  os_workgroup_t result;

  if (a1[23] < 0)
    a1 = *(const char **)a1;
  result = os_workgroup_create_with_port(a1, a2);
  *a3 = &off_24BF2E020;
  a3[1] = result;
  return result;
}

uint64_t caulk::mach::os_workgroup::make_with_workload_id@<X0>(_QWORD *a1@<X8>)
{
  uint64_t result;

  result = os_workgroup_create_with_workload_id_and_port();
  *a1 = &off_24BF2E020;
  a1[1] = result;
  return result;
}

OS_os_workgroup *caulk::mach::os_workgroup::copy_mach_port(caulk::mach::os_workgroup *this)
{
  OS_os_workgroup *result;
  mach_port_t mach_port_out;

  result = (OS_os_workgroup *)*((_QWORD *)this + 1);
  if (result)
  {
    mach_port_out = 0;
    if (os_workgroup_copy_port(result, &mach_port_out))
      return 0;
    else
      return (OS_os_workgroup *)mach_port_out;
  }
  return result;
}

uint64_t caulk::mach::os_workgroup::join(caulk::mach::os_workgroup *this, os_workgroup_join_token_opaque_s *a2)
{
  if (*((_QWORD *)this + 1))
    return os_workgroup_join_self();
  else
    return 2;
}

uint64_t caulk::mach::os_workgroup_interval::make@<X0>(_QWORD *a1@<X8>)
{
  uint64_t result;

  result = os_workgroup_attr_set_interval_type();
  if ((_DWORD)result)
  {
    a1[1] = 0;
  }
  else
  {
    result = os_workgroup_interval_create();
    a1[1] = result;
  }
  *a1 = &off_24BF2E0A8;
  return result;
}

void sub_2065D2460(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t caulk::mach::os_workgroup_interval::make_with_workload_id@<X0>(_QWORD *a1@<X8>)
{
  uint64_t result;

  result = os_workgroup_attr_set_interval_type();
  if ((_DWORD)result)
  {
    a1[1] = 0;
  }
  else
  {
    result = os_workgroup_interval_create_with_workload_id();
    a1[1] = result;
  }
  *a1 = &off_24BF2E0A8;
  return result;
}

void sub_2065D2540(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

double caulk::mach::os_workgroup_managed::make_with_workload_id@<D0>(uint64_t a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = os_workgroup_create_with_workload_id_and_port();
  *(_QWORD *)a1 = &off_24BF2E088;
  *(_QWORD *)(a1 + 8) = v2;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 41) = 0u;
  return result;
}

double caulk::mach::os_workgroup_interval_managed::make@<D0>(uint64_t a1@<X8>)
{
  double result;
  uint64_t v3;

  if (os_workgroup_attr_set_interval_type())
  {
    *(_QWORD *)(a1 + 56) = 0;
    result = 0.0;
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 24) = 0u;
    *(_OWORD *)(a1 + 8) = 0u;
    *(_QWORD *)a1 = &off_24BF2E0C8;
  }
  else
  {
    v3 = os_workgroup_interval_create();
    result = 0.0;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 41) = 0u;
    *(_QWORD *)a1 = &off_24BF2E0C8;
    *(_QWORD *)(a1 + 8) = v3;
    *(_BYTE *)(a1 + 57) = 0;
  }
  return result;
}

void sub_2065D26EC(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t caulk::mach::os_workgroup_interval_managed::start(caulk::mach::os_workgroup_interval_managed *this, uint64_t a2, uint64_t a3)
{
  return caulk::mach::os_workgroup_interval_managed::start(this, a2, a3, 0);
}

uint64_t caulk::mach::os_workgroup_interval_managed::update_deadline(os_workgroup_interval_t *this, uint64_t a2, os_workgroup_interval_data_opaque_s *a3)
{
  if (*((_BYTE *)this + 56) && *((_BYTE *)this + 57))
    return os_workgroup_interval_update(this[1], a2, a3);
  else
    return 1;
}

uint64_t caulk::mach::os_workgroup_interval_managed::update_deadline(os_workgroup_interval_t *this, uint64_t a2)
{
  return caulk::mach::os_workgroup_interval_managed::update_deadline(this, a2, 0);
}

uint64_t caulk::mach::os_workgroup_interval_managed::finish(caulk::mach::os_workgroup_interval_managed *this)
{
  return caulk::mach::os_workgroup_interval_managed::finish(this, 0);
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s)
{
  size_t v4;

  v4 = strlen(__s);
  return std::string::__assign_external(this, __s, v4);
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  unint64_t v6;
  std::string *v7;
  std::string::size_type size;
  unint64_t v9;
  unint64_t v10;

  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    v10 = this->__r_.__value_.__r.__words[2];
    v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __n)
    {
      size = this->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    v6 = HIBYTE(v10);
    v7 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    v7 = this;
    if (__n > 0x16)
    {
      size = HIBYTE(this->__r_.__value_.__r.__words[2]);
      v9 = 22;
LABEL_6:
      std::string::__grow_by_and_replace(this, v9, __n - v9, size, 0, size, __n, __s);
      return this;
    }
  }
  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = *((_BYTE *)&this->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0)
    this->__r_.__value_.__l.__size_ = __n;
  else
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __n & 0x7F;
  v7->__r_.__value_.__s.__data_[__n] = 0;
  return this;
}

BOOL caulk::platform::is_virtual_machine(caulk::platform *this)
{
  size_t v2;
  int v3;

  v3 = 0;
  v2 = 4;
  if (sysctlbyname("kern.hv_vmm_present", &v3, &v2, 0, 0))
    perror("sysctlbyname");
  return v3 != 0;
}

void caulk::shared_semaphore_mutex::~shared_semaphore_mutex(caulk::shared_semaphore_mutex *this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if ((*(_QWORD *)this & 0x1FFFFFLL) != 0)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_7;
  }
  if ((v1 & 0x3FFFFE00000) != 0)
  {
LABEL_7:
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if ((v1 & 0x7FFFFC0000000000) != 0)
  {
LABEL_8:
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  if ((v1 & 0x8000000000000000) == 0)
  {
    caulk::semaphore::~semaphore((caulk::shared_semaphore_mutex *)((char *)this + 24));
    caulk::semaphore::~semaphore((caulk::shared_semaphore_mutex *)((char *)this + 8));
    return;
  }
LABEL_9:
  _os_assert_log();
  _os_crash();
  __break(1u);
}

uint64_t caulk::shared_semaphore_mutex::_lock_shared(caulk::shared_semaphore_mutex *this, char a2)
{
  unint64_t v4;
  semaphore_t *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t result;

  v4 = *(_QWORD *)this;
  v5 = (semaphore_t *)((char *)this + 8);
  while (1)
  {
    while ((v4 & 0x8000000000000000) != 0)
    {
      if ((a2 & 1) != 0)
        return (v4 & 0x8000000000000000) == 0;
      if ((((v4 >> 21) + 1) & 0x1FFFFFLL) == 0x1FFFFF)
        goto LABEL_18;
      v7 = __ldaxr((unint64_t *)this);
      if (v7 != v4)
      {
        __clrex();
        goto LABEL_15;
      }
      if (__stlxr(v4 & 0xFFFFFC00001FFFFFLL | ((((v4 >> 21) + 1) & 0x1FFFFFLL) << 21), (unint64_t *)this))
      {
        goto LABEL_15;
      }
      caulk::semaphore::timed_wait(v5, -1.0);
      v4 = atomic_load((unint64_t *)this);
    }
    v6 = ((int)v4 + 1) & 0x1FFFFFLL;
    if (v6 == 0x1FFFFF)
      break;
    v7 = __ldaxr((unint64_t *)this);
    if (v7 == v4)
    {
      if (!__stlxr(v6 | v4 & 0xFFFFFFFFFFE00000, (unint64_t *)this))
      {
        __dmb(9u);
        return (v4 & 0x8000000000000000) == 0;
      }
    }
    else
    {
      __clrex();
    }
LABEL_15:
    v4 = v7;
  }
  _os_assert_log();
  _os_crash();
  __break(1u);
LABEL_18:
  _os_assert_log();
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t caulk::shared_semaphore_mutex::lock_shared(caulk::shared_semaphore_mutex *this)
{
  return caulk::shared_semaphore_mutex::_lock_shared(this, 0);
}

uint64_t caulk::shared_semaphore_mutex::try_lock_shared(caulk::shared_semaphore_mutex *this)
{
  return caulk::shared_semaphore_mutex::_lock_shared(this, 1);
}

unint64_t *caulk::shared_semaphore_mutex::unlock_shared(unint64_t *this)
{
  unint64_t v1;
  uint64_t v2;
  BOOL v3;
  char v4;
  unint64_t v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int v8;

  __dmb(0xBu);
  v1 = *this;
  v2 = *this & 0x1FFFFF;
  if ((*(_DWORD *)this & 0x1FFFFF) != 0)
  {
    do
    {
      v3 = (v1 & 0x7FFFFC0000000000) != 0 && (_DWORD)v2 == 1;
      v4 = !v3;
      v5 = v1 & 0xFFFFFFFFFFE00000 | ((_DWORD)v1 - 1) & 0x1FFFFF;
      if (v3)
        v5 = v1 & 0x800003FFFFE00000 | ((int)v1 - 1) & 0x1FFFFFLL | ((((v1 + 0x7FFFFC0000000000) >> 42) & 0x1FFFFF) << 42);
      v6 = __ldaxr(this);
      if (v6 == v1)
      {
        if (!__stlxr(v5, this))
          goto LABEL_17;
      }
      else
      {
        __clrex();
      }
      v1 = v6;
      LODWORD(v2) = v6 & 0x1FFFFF;
    }
    while ((v6 & 0x1FFFFF) != 0);
  }
  _os_assert_log();
  this = (unint64_t *)_os_crash();
  __break(1u);
LABEL_17:
  if ((v4 & 1) == 0)
  {
    v7 = (unsigned int *)(this + 4);
    do
      v8 = __ldxr(v7);
    while (__stlxr(v8 + 1, v7));
    if ((v8 & 0x80000000) != 0)
      JUMPOUT(0x20BCFA1F0);
  }
  return this;
}

uint64_t caulk::shared_semaphore_mutex::lock(uint64_t this)
{
  unint64_t *v1;
  unint64_t v2;
  semaphore_t *v3;
  unint64_t v4;

  v1 = (unint64_t *)this;
  v2 = *(_QWORD *)this;
  v3 = (semaphore_t *)(this + 24);
  while (1)
  {
    while ((v2 & 0x80000000001FFFFFLL) == 0)
    {
      v4 = __ldaxr(v1);
      if (v4 == v2)
      {
        if (!__stlxr(v2 | 0x8000000000000000, v1))
        {
          __dmb(9u);
          return this;
        }
      }
      else
      {
        __clrex();
      }
LABEL_13:
      v2 = v4;
    }
    if ((((v2 >> 42) + 1) & 0x1FFFFFLL) == 0x1FFFFF)
      break;
    v4 = __ldaxr(v1);
    if (v4 != v2)
    {
      __clrex();
      goto LABEL_13;
    }
    if (__stlxr(v2 & 0x800003FFFFFFFFFFLL | ((((v2 >> 42) + 1) & 0x1FFFFFLL) << 42), v1))
      goto LABEL_13;
    this = caulk::semaphore::timed_wait(v3, -1.0);
    v2 = atomic_load(v1);
  }
  _os_assert_log();
  this = _os_crash();
  __break(1u);
  return this;
}

uint64_t caulk::shared_semaphore_mutex::try_lock(caulk::shared_semaphore_mutex *this)
{
  unint64_t v1;
  unint64_t v2;

  v1 = *(_QWORD *)this;
  if ((*(_QWORD *)this & 0x80000000001FFFFFLL) == 0)
  {
    do
    {
      v2 = __ldaxr((unint64_t *)this);
      if (v2 == v1)
      {
        if (!__stlxr(v1 | 0x8000000000000000, (unint64_t *)this))
        {
          __dmb(9u);
          return 1;
        }
      }
      else
      {
        __clrex();
      }
      v1 = v2;
    }
    while ((v2 & 0x80000000001FFFFFLL) == 0);
  }
  return 0;
}

unint64_t *caulk::shared_semaphore_mutex::unlock(unint64_t *this)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t *v5;
  unsigned int *v6;
  unsigned int v7;

  __dmb(0xBu);
  v1 = *this;
  if ((*this & 0x8000000000000000) != 0)
  {
    do
    {
      while ((v1 & 0x7FFFFC0000000000) != 0)
      {
        v2 = __ldaxr(this);
        if (v2 == v1)
        {
          if (!__stlxr((v1 + 0x7FFFFC0000000000) & 0x7FFFFC0000000000 | v1 & 0x3FFFFFFFFFFLL, this))
            goto LABEL_17;
        }
        else
        {
          __clrex();
        }
        v1 = v2;
        if ((v2 & 0x8000000000000000) == 0)
          goto LABEL_16;
      }
      v3 = (v1 + 0x3FFFFE00000) & 0x3FFFFE00000 | v1 & 0x7FFFFC00001FFFFFLL;
      if ((v1 & 0x3FFFFE00000) == 0)
        v3 = v1 & 0x7FFFFFFFFFFFFFFFLL;
      v4 = __ldaxr(this);
      if (v4 == v1)
      {
        if (!__stlxr(v3, this))
        {
          if ((v1 & 0x3FFFFE00000) != 0)
          {
            v5 = this + 1;
            goto LABEL_20;
          }
          return this;
        }
      }
      else
      {
        __clrex();
      }
      v1 = v4;
    }
    while ((v4 & 0x8000000000000000) != 0);
  }
LABEL_16:
  _os_assert_log();
  this = (unint64_t *)_os_crash();
  __break(1u);
LABEL_17:
  v5 = this + 3;
LABEL_20:
  v6 = (unsigned int *)(v5 + 1);
  do
    v7 = __ldxr(v6);
  while (__stlxr(v7 + 1, v6));
  if ((v7 & 0x80000000) != 0)
    JUMPOUT(0x20BCFA1F0);
  return this;
}

caulk::concurrent::details::lf_read_sync_write_impl *caulk::concurrent::details::lf_read_sync_write_impl::lf_read_sync_write_impl(caulk::concurrent::details::lf_read_sync_write_impl *this)
{
  *(_QWORD *)this = 0;
  caulk::details::semaphore_pool::instance(this);
  return this;
}

{
  *(_QWORD *)this = 0;
  caulk::details::semaphore_pool::instance(this);
  return this;
}

_WORD *caulk::details::semaphore_pool::semaphore_pool(caulk::details::semaphore_pool *this)
{
  uint64_t i;
  _QWORD *v2;
  uint64_t v3;
  uint64_t j;
  unsigned __int16 v5;
  _WORD *result;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  _BYTE v10[16];

  for (i = 0; i != 8; i += 2)
  {
    v2 = &caulk::details::semaphore_pool::instance(void)::global[i];
    *v2 = 0;
    v2[1] = 0;
  }
  v3 = 0;
  dword_253D0A488 = 0;
  do
  {
    this = (caulk::details::semaphore_pool *)caulk::details::semaphore_pool::acquire(this);
    *(_WORD *)&v10[v3] = (_WORD)this;
    v3 += 2;
  }
  while (v3 != 16);
  for (j = 0; j != 8; ++j)
  {
    v5 = *(_WORD *)&v10[2 * j];
    result = (_WORD *)caulk::details::semaphore_pool::sema_ref_to_bank((caulk::details::semaphore_pool *)v5);
    v7 = ~(1 << (v5 - *result));
    v8 = (unint64_t *)(result + 520);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 & v7, v8));
  }
  return result;
}

uint64_t caulk::details::semaphore_pool::acquire(caulk::details::semaphore_pool *this)
{
  uint64_t v1;
  __int16 v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  semaphore_t *v11;
  unint64_t v12;

  v1 = 0;
  v2 = 1;
  while (1)
  {
    v3 = caulk::details::semaphore_pool::instance(void)::global[v1];
    if (!v3)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&dword_253D0A488);
      v3 = caulk::details::semaphore_pool::instance(void)::global[v1];
      if (!v3)
      {
        v3 = operator new();
        *(_WORD *)v3 = v2;
        *(_OWORD *)(v3 + 1032) = 0u;
        caulk::details::semaphore_pool::instance(void)::global[v1] = v3;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&dword_253D0A488);
    }
    v4 = *(_QWORD *)(v3 + 1040);
    if (v4 != -1)
      break;
LABEL_18:
    v2 += 64;
    if (++v1 == 8)
    {
      v2 = 1;
      std::this_thread::sleep_for[abi:ne180100]<long long,std::ratio<1l,1000l>>(1);
      v1 = 0;
    }
  }
  v5 = (unint64_t *)(v3 + 1040);
  v6 = __clz(__rbit64(~v4));
  while (1)
  {
    v7 = 1 << v6;
    v8 = __ldaxr(v5);
    if (v8 != v4)
    {
      __clrex();
      goto LABEL_12;
    }
    if (!__stlxr(v7 | v4, v5))
      break;
LABEL_12:
    v6 = __clz(__rbit64(~v8));
    v4 = v8;
    if (v8 == -1)
      goto LABEL_18;
  }
  v9 = (unint64_t *)(v3 + 1032);
  v10 = atomic_load((unint64_t *)(v3 + 1032));
  if ((v10 & v7) == 0)
  {
    v11 = (semaphore_t *)(v3 + 16 * v6);
    caulk::mach::semaphore::semaphore(v11 + 1);
    v11[3] = 0;
    v11[4] = 0;
    do
      v12 = __ldaxr(v9);
    while (__stlxr(v12 | v7, v9));
  }
  if (!(*(_WORD *)v3 + (_WORD)v6))
    goto LABEL_18;
  return (unsigned __int16)(*(_WORD *)v3 + v6);
}

void sub_2065D3014(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_253D0A488);
  _Unwind_Resume(a1);
}

unint64_t caulk::details::semaphore_pool::sema_ref_to_bank(caulk::details::semaphore_pool *this)
{
  unint64_t v1;
  unint64_t *v2;

  v1 = this - 1;
  if (v1 >= 0x200)
LABEL_5:
    std::__throw_out_of_range[abi:ne180100]();
  v2 = &caulk::details::semaphore_pool::instance(void)::global[v1 >> 6];
  if (!atomic_load(v2))
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_5;
  }
  return atomic_load(v2);
}

void std::__throw_out_of_range[abi:ne180100]()
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception);
  __cxa_throw(exception, (struct type_info *)off_24BF2BD58, MEMORY[0x24BEDAB00]);
}

void sub_2065D30B0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, "array::at");
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8C0] + 16);
  return result;
}

void std::this_thread::sleep_for[abi:ne180100]<long long,std::ratio<1l,1000l>>(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  BOOL v4;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v5;
  std::chrono::nanoseconds __ns;
  uint64_t v7;
  uint64_t v8;

  if (a1 >= 1)
  {
    v7 = v1;
    v8 = v2;
    if (a1 == 0x8637BD057A0)
      v3 = 0;
    else
      v3 = -127;
    if ((unint64_t)a1 > 0x8637BD057A0)
      v3 = 1;
    if ((unint64_t)a1 < 0x8637BD057A0)
      v3 = -1;
    v4 = v3 >= 0 || v3 == -127;
    v5 = 1000000 * a1;
    if (v4)
      v5 = 0x7FFFFFFFFFFFFFFFLL;
    __ns.__rep_ = v5;
    std::this_thread::sleep_for (&__ns);
  }
}

uint64_t caulk::concurrent::details::lf_read_sync_write_impl::begin_access(caulk::concurrent::details::lf_read_sync_write_impl *this)
{
  unsigned int v1;
  unsigned int v2;
  __int16 v3;
  unsigned int v4;

  v1 = *(_DWORD *)this;
  v2 = *(_DWORD *)this + 1;
  v3 = v2 & 0x7FFF;
  if ((v2 & 0x7FFF) != 0)
  {
    v2 = *(_DWORD *)this;
    do
    {
      v4 = __ldaxr((unsigned int *)this);
      if (v4 == v2)
      {
        if (!__stlxr(v2 & 0xFFFF0000 | (unsigned __int16)(v3 | v1 & 0x8000), (unsigned int *)this))
          goto LABEL_9;
      }
      else
      {
        __clrex();
      }
      LOWORD(v1) = v4;
      v2 = v4;
      v3 = (v4 + 1) & 0x7FFF;
    }
    while (v3);
  }
  __break(1u);
LABEL_9:
  __dmb(9u);
  return (v2 >> 15) & 1;
}

unsigned int *caulk::concurrent::details::lf_read_sync_write_impl::end_access(unsigned int *this)
{
  unsigned int v1;
  caulk::details::semaphore_pool *v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;

  v3 = *this;
  if ((*this & 0x7FFF) != 0)
  {
    v4 = *this;
    do
    {
      v5 = v4;
      v2 = (caulk::details::semaphore_pool *)HIWORD(v4);
      if ((((_WORD)v3 - 1) & 0x7FFF) != 0)
        v1 = HIWORD(v4);
      else
        v1 = 0;
      v4 = __ldaxr(this);
      if (v4 == v5)
      {
        if (!__stlxr(((_WORD)v3 - 1) & 0x7FFF | v3 & 0x8000 | (v1 << 16), this))
          goto LABEL_12;
      }
      else
      {
        __clrex();
      }
      LOWORD(v3) = v4;
    }
    while ((v4 & 0x7FFF) != 0);
  }
  __break(1u);
LABEL_12:
  if ((_DWORD)v2 && !v1)
  {
    caulk::details::semaphore_pool::instance((caulk::details::semaphore_pool *)this);
    this = (unsigned int *)caulk::details::semaphore_pool::sema_ref_to_bank(v2);
    v6 = &this[4 * (unsigned __int16)((_WORD)v2 - *(_WORD *)this)];
    v7 = v6 + 1;
    v8 = v6 + 3;
    do
      v9 = __ldxr(v8);
    while (__stlxr(v9 + 1, v8));
    if ((v9 & 0x80000000) != 0)
      return (unsigned int *)MEMORY[0x20BCFA1F0](*v7);
  }
  return this;
}

uint64_t caulk::concurrent::details::lf_read_sync_write_impl::begin_mutate(caulk::concurrent::details::lf_read_sync_write_impl *this)
{
  unsigned int v1;

  v1 = atomic_load((unsigned int *)this);
  return (v1 >> 15) & 1;
}

caulk::details::semaphore_pool *caulk::concurrent::details::lf_read_sync_write_impl::end_mutate(caulk::details::semaphore_pool *this, __int16 a2)
{
  unsigned int *v2;
  unsigned __int16 v3;
  unsigned int v4;
  unsigned __int16 v5;
  unsigned int v6;
  caulk::details::semaphore_pool *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unsigned int v11;
  int v12;
  _WORD *v13;
  _BOOL8 v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;

  v2 = (unsigned int *)this;
  v3 = 0;
  __dmb(0xBu);
  v4 = *(_DWORD *)this;
  v5 = a2 << 15;
  do
  {
    if ((v4 & 0x7FFF) != 0)
    {
      LOWORD(v6) = v3;
      if (!v3)
      {
        caulk::details::semaphore_pool::instance(this);
        this = (caulk::details::semaphore_pool *)caulk::details::semaphore_pool::acquire(v7);
        LOWORD(v6) = (_WORD)this;
        v3 = (unsigned __int16)this;
      }
    }
    else
    {
      v6 = HIWORD(v4);
      if (v3)
      {
        caulk::details::semaphore_pool::instance(this);
        this = (caulk::details::semaphore_pool *)caulk::details::semaphore_pool::sema_ref_to_bank((caulk::details::semaphore_pool *)v3);
        v8 = ~(1 << (v3 - *(_WORD *)this));
        v9 = (unint64_t *)((char *)this + 1040);
        do
          v10 = __ldaxr(v9);
        while (__stlxr(v10 & v8, v9));
      }
      v3 = 0;
    }
    v11 = __ldaxr(v2);
    if (v11 == v4)
    {
      if (!__stlxr(v4 & 0x7FFF | v5 | ((unsigned __int16)v6 << 16), v2))
      {
        v12 = 1;
        goto LABEL_14;
      }
    }
    else
    {
      __clrex();
    }
    v12 = 0;
LABEL_14:
    v4 = v11;
  }
  while (!v12);
  if (v3)
  {
    caulk::details::semaphore_pool::instance(this);
    v13 = (_WORD *)caulk::details::semaphore_pool::sema_ref_to_bank((caulk::details::semaphore_pool *)v3);
    v14 = caulk::semaphore::timed_wait((semaphore_t *)&v13[8 * (unsigned __int16)(v3 - *v13) + 2], -1.0);
    caulk::details::semaphore_pool::instance((caulk::details::semaphore_pool *)v14);
    this = (caulk::details::semaphore_pool *)caulk::details::semaphore_pool::sema_ref_to_bank((caulk::details::semaphore_pool *)v3);
    v15 = ~(1 << (v3 - *(_WORD *)this));
    v16 = (unint64_t *)((char *)this + 1040);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 & v15, v16));
  }
  return this;
}

caulk::alloc::malloc_zone_allocator *caulk::alloc::malloc_zone_allocator::malloc_zone_allocator(caulk::alloc::malloc_zone_allocator *this)
{
  *(_QWORD *)this = malloc_create_zone(0, 0);
  return this;
}

{
  *(_QWORD *)this = malloc_create_zone(0, 0);
  return this;
}

_QWORD *caulk::alloc::malloc_zone_allocator::malloc_zone_allocator(_QWORD *this, _malloc_zone_t *a2)
{
  *this = a2;
  return this;
}

{
  *this = a2;
  return this;
}

void caulk::alloc::malloc_zone_allocator::~malloc_zone_allocator(malloc_zone_t **this)
{
  malloc_destroy_zone(*this);
  *this = 0;
}

void *caulk::alloc::malloc_zone_allocator::allocate(malloc_zone_t **this, size_t size, size_t alignment)
{
  malloc_zone_t *v4;

  if (alignment <= 0x10)
    return malloc_type_zone_malloc(*this, size, 0xBCA753B2uLL);
  v4 = *this;
  if (alignment > 0x1000)
    return malloc_type_zone_valloc(v4, size, 0x33AAA77DuLL);
  else
    return malloc_type_zone_memalign(v4, alignment, size, 0x8E3CAEBuLL);
}

void caulk::alloc::malloc_zone_allocator::deallocate(malloc_zone_t **a1, void *a2)
{
  malloc_zone_free(*a1, a2);
}

_QWORD *caulk::alloc::malloc_zone_allocator::describe(malloc_zone_t **this, caulk::alloc::base_allocator::formatter *a2)
{
  const char *zone_name;
  char *v4;

  zone_name = malloc_get_zone_name(*this);
  caulk::alloc::base_allocator::formatter::emit_string(a2, "malloc_zone_allocator @");
  caulk::alloc::base_allocator::formatter::check_line_start(a2);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(a2, ", zone ");
  caulk::alloc::base_allocator::formatter::check_line_start(a2);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(a2, ", \"");
  if (zone_name)
    v4 = (char *)zone_name;
  else
    v4 = "(null)";
  caulk::alloc::base_allocator::formatter::emit_string(a2, v4);
  return caulk::alloc::base_allocator::formatter::emit_string(a2, "\"\n");
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_pressure_relief(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 - 8) + 72))(*(_QWORD *)(a1 - 8));
}

void caulk::alloc::details::caching_page_allocator_base::~caching_page_allocator_base(caulk::alloc::details::caching_page_allocator_base *this)
{
  unsigned __int128 *v2;
  unint64_t *v3;
  _QWORD *i;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  caulk::alloc::details::caching_page_allocator_base *v8;
  uint64_t v9;

  v2 = (unsigned __int128 *)((char *)this + 32);
  v3 = (unint64_t *)((char *)this + 48);
  for (i = (_QWORD *)MEMORY[0x24BDB03C8];
        ;
        caulk::mach::vm_block::dealloc((caulk::mach::vm_block *)v5, (*((_QWORD *)this + 2) + *i - 1) & -*i))
  {
    v5 = caulk::concurrent::stack<caulk::alloc::free_block,caulk::concurrent::intrusive_single_link_node<caulk::alloc::free_block>>::pop(v2);
    if (!v5)
      break;
    do
      v6 = __ldaxr(v3);
    while (__stlxr(v6 - 1, v3));
  }
  v7 = *((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = 0;
  if (v7)
  {
    std::unique_ptr<caulk::alloc::page_cache_monitor_impl>::reset[abi:ne180100]((uint64_t *)(v7 + 40), 0);
    std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](v7 + 24);
    std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](v7 + 8);
    MEMORY[0x20BCF9C08](v7, 0x20C40A759441BLL);
  }
  v8 = (caulk::alloc::details::caching_page_allocator_base *)*((_QWORD *)this + 11);
  if (v8 == (caulk::alloc::details::caching_page_allocator_base *)((char *)this + 64))
  {
    v9 = 4;
    v8 = (caulk::alloc::details::caching_page_allocator_base *)((char *)this + 64);
  }
  else
  {
    if (!v8)
      return;
    v9 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v8 + 8 * v9))();
}

uint64_t *std::unique_ptr<caulk::alloc::page_cache_monitor_impl>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  void **v8;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    if (*(_QWORD *)(v2 + 16))
    {
      if (*(_BYTE *)(v2 + 48))
      {
        caulk::semaphore::~semaphore((caulk::semaphore *)(v2 + 32));
        *(_BYTE *)(v2 + 48) = 0;
      }
      caulk::mach::semaphore::semaphore((semaphore_t *)(v2 + 32));
      *(_QWORD *)(v2 + 40) = 0;
      *(_BYTE *)(v2 + 48) = 1;
      v3 = *(std::__shared_weak_count **)(v2 + 24);
      *(_QWORD *)(v2 + 16) = 0;
      *(_QWORD *)(v2 + 24) = 0;
      if (v3)
      {
        p_shared_owners = (unint64_t *)&v3->__shared_owners_;
        do
          v5 = __ldaxr(p_shared_owners);
        while (__stlxr(v5 - 1, p_shared_owners));
        if (!v5)
        {
          ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
          std::__shared_weak_count::__release_weak(v3);
        }
      }
      caulk::semaphore::timed_wait((semaphore_t *)(v2 + 32), -1.0);
      __dmb(9u);
    }
    v8 = (void **)(v2 + 168);
    std::vector<std::weak_ptr<caulk::alloc::preallocation_reservation>>::__destroy_vector::operator()[abi:ne180100](&v8);
    *(_QWORD *)(v2 + 80) = &off_24BF2DEC0;
    v6 = *(_QWORD **)(v2 + 144);
    if (v6 == (_QWORD *)(v2 + 120))
    {
      v7 = 4;
      v6 = (_QWORD *)(v2 + 120);
    }
    else
    {
      if (!v6)
      {
LABEL_17:
        caulk::concurrent::message::~message((caulk::concurrent::message *)(v2 + 80));
        caulk::concurrent::messenger::~messenger((caulk::concurrent::details::messenger_servicer **)(v2 + 64));
        caulk::details::lifetime_guard_base<caulk::alloc::page_cache_monitor>::~lifetime_guard_base(v2 + 8);
        JUMPOUT(0x20BCF9C08);
      }
      v7 = 5;
    }
    (*(void (**)(void))(*v6 + 8 * v7))();
    goto LABEL_17;
  }
  return result;
}

void std::vector<std::weak_ptr<caulk::alloc::preallocation_reservation>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  std::__shared_weak_count *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (std::__shared_weak_count *)*((_QWORD *)v4 - 1);
        if (v6)
          std::__shared_weak_count::__release_weak(v6);
        v4 -= 16;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t caulk::details::lifetime_guard_base<caulk::alloc::page_cache_monitor>::~lifetime_guard_base(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t result;

  if (*(_QWORD *)(a1 + 8))
  {
    _os_assert_log();
    result = _os_crash();
    __break(1u);
  }
  else
  {
    if (*(_BYTE *)(a1 + 40))
      caulk::semaphore::~semaphore((caulk::semaphore *)(a1 + 24));
    v2 = *(std::__shared_weak_count **)(a1 + 16);
    if (v2)
    {
      p_shared_owners = (unint64_t *)&v2->__shared_owners_;
      do
        v4 = __ldaxr(p_shared_owners);
      while (__stlxr(v4 - 1, p_shared_owners));
      if (!v4)
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
    return a1;
  }
  return result;
}

void caulk::concurrent::condition_message::~condition_message(caulk::concurrent::condition_message *this)
{
  char *v2;
  char *v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24BF2DEC0;
  v2 = (char *)this + 40;
  v3 = (char *)*((_QWORD *)this + 8);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  caulk::concurrent::message::~message(this);
}

{
  char *v2;
  char *v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24BF2DEC0;
  v2 = (char *)this + 40;
  v3 = (char *)*((_QWORD *)this + 8);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
    {
LABEL_6:
      caulk::concurrent::message::~message(this);
      JUMPOUT(0x20BCF9C08);
    }
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  goto LABEL_6;
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  _BYTE v27[24];
  _BYTE *v28;
  _QWORD v29[3];
  _QWORD *v30;
  int v31;
  _BYTE v32[24];
  _BYTE *v33;
  _BYTE v34[24];
  _BYTE *v35;
  char v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v29[0] = &off_24BF2D1A8;
  v29[1] = a5;
  v29[2] = a1;
  v30 = v29;
  v11 = operator new(0x20uLL);
  *v11 = &off_24BF2D150;
  v11[1] = a6;
  *((_DWORD *)v11 + 4) = a1;
  v11[3] = a2;
  v28 = v11;
  v31 = a3;
  std::__function::__value_func<void * ()(unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v32, (uint64_t)v29);
  std::__function::__value_func<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v34, (uint64_t)v27);
  v36 = 0;
  v12 = v28;
  if (v28 == v27)
  {
    v13 = 4;
    v12 = v27;
  }
  else
  {
    if (!v28)
      goto LABEL_6;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_6:
  v14 = v30;
  if (v30 == v29)
  {
    v15 = 4;
    v14 = v29;
  }
  else
  {
    if (!v30)
      goto LABEL_11;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_11:
  v25 = 208;
  v26 = a4 - 8;
  if (!v33)
    std::__throw_bad_function_call[abi:ne180100]();
  v16 = (_QWORD *)(*(uint64_t (**)(_BYTE *, uint64_t *, uint64_t *))(*(_QWORD *)v33 + 48))(v33, &v26, &v25);
  if (*v16)
    v17 = *v16 + 16;
  else
    v17 = 0;
  v25 = 112;
  v26 = v17;
  if (!v33)
    std::__throw_bad_function_call[abi:ne180100]();
  v18 = (unint64_t *)(*(uint64_t (**)(_BYTE *, uint64_t *, uint64_t *))(*(_QWORD *)v33 + 48))(v33, &v26, &v25);
  caulk::alloc::details::caching_page_allocator_base::introspect(v18, v19, (const caulk::alloc::introspector *)&v31);
  v20 = v35;
  if (v35 == v34)
  {
    v21 = 4;
    v20 = v34;
  }
  else
  {
    if (!v35)
      goto LABEL_21;
    v21 = 5;
  }
  (*(void (**)(void))(*v20 + 8 * v21))();
LABEL_21:
  v22 = v33;
  if (v33 == v32)
  {
    v23 = 4;
    v22 = v32;
    goto LABEL_25;
  }
  if (v33)
  {
    v23 = 5;
LABEL_25:
    (*(void (**)(void))(*v22 + 8 * v23))();
  }
  return 0;
}

void sub_2065D3C14(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_2065D3C20(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x2065D3B74);
  }
  caulk::alloc::introspector::~introspector((caulk::alloc::introspector *)&a20);
  JUMPOUT(0x2065D3C18);
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_good_size(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_check()
{
  return 1;
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_print(uint64_t a1, int a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, BOOL))(**(_QWORD **)(a1 - 8) + 48))(*(_QWORD *)(a1 - 8), MEMORY[0x24BEDB318], a2 != 0);
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_locked()
{
  return 0;
}

void std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2D3B8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc19allocator_enumerateINS0_15darwin_resourceINS0_22caching_page_allocatorILm16384EEENS0_15memory_resourceEEEEEvRT_NS_10option_setINS0_12region_usageEjEERKNSt3__18functionIFvSA_NS0_5blockEEEEEUlSA_mmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target_type()
{
}

void std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2D678;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2D678;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc20allocator_statisticsINS0_15darwin_resourceINS0_22caching_page_allocatorILm16384EEENS0_15memory_resourceEEEEE19malloc_statistics_tRT_EUlNS0_12region_usageENS0_5blockEE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<malloc_statistics_t caulk::alloc::allocator_statistics<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target_type()
{
}

void std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

__n128 std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_24BF2D150;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24BF2D150;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(uint64_t a1, unsigned int *a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[2];

  v4 = *a2;
  v5 = *a4;
  v7[0] = *a3;
  v7[1] = v5;
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD *, uint64_t))(a1 + 8))(*(unsigned int *)(a1 + 16), *(_QWORD *)(a1 + 24), v4, v7, 1);
}

uint64_t std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc15darwin_resourceINS0_22caching_page_allocatorILm16384EEENS0_15memory_resourceEE14zone_enumerateEjPvjmPFijmmPS6_EPFvjS6_jP10vm_range_tjEEUlNS0_12region_usageEmmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target_type()
{
}

void std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

__n128 std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24BF2D1A8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24BF2D1A8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  uint64_t v7;

  v3 = *a2;
  v4 = *a3;
  v7 = 0;
  v5 = (const char *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t *))(a1 + 8))(*(unsigned int *)(a1 + 16), v3, v4, &v7);
  caulk::mach::throw_if_mach_error((uint64_t)"reader failed", v5);
  return v7;
}

uint64_t std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc15darwin_resourceINS0_22caching_page_allocatorILm16384EEENS0_15memory_resourceEE14zone_enumerateEjPvjmPFijmmPS6_EPFvjS6_jP10vm_range_tjEEUlmmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1},std::allocator<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_enumerate(unsigned int,void *,unsigned int,unsigned long,int (*)(unsigned int,unsigned long,unsigned long,void **),void (*)(unsigned int,void *,unsigned int,vm_range_t *,unsigned int))::{lambda(unsigned long,unsigned long)#1}>,void * ()(unsigned long,unsigned long)>::target_type()
{
}

_QWORD *caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::~darwin_resource(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24BF2CCB0;
  v2 = a1[16];
  a1[16] = 0;
  if (v2)
    std::default_delete<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_plus>::operator()[abi:ne180100](v2);
  caulk::alloc::details::caching_page_allocator_base::~caching_page_allocator_base((caulk::alloc::details::caching_page_allocator_base *)(a1 + 2));
  return a1;
}

void caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::~darwin_resource(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24BF2CCB0;
  v2 = a1[16];
  a1[16] = 0;
  if (v2)
    std::default_delete<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_plus>::operator()[abi:ne180100](v2);
  caulk::alloc::details::caching_page_allocator_base::~caching_page_allocator_base((caulk::alloc::details::caching_page_allocator_base *)(a1 + 2));
  JUMPOUT(0x20BCF9C08);
}

unint64_t *caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::do_allocate(_QWORD *a1, uint64_t a2, unint64_t a3)
{
  unint64_t *v5;
  unint64_t *v6;
  void (*v7)(uint64_t, uint64_t, uint64_t, _QWORD, unint64_t *, _QWORD);
  std::bad_alloc *exception;
  std::bad_alloc *v10;

  v5 = caulk::alloc::details::caching_page_allocator_base::allocate((caulk::alloc::details::caching_page_allocator_base *)(a1 + 2), a2, a3);
  if (!v5)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v10 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v10, MEMORY[0x24BEDB758], MEMORY[0x24BEDB670]);
  }
  v6 = v5;
  v7 = (void (*)(uint64_t, uint64_t, uint64_t, _QWORD, unint64_t *, _QWORD))a1[18];
  if (v7)
    v7(10, a1[16] + 8, a2, 0, v5, 0);
  return v6;
}

void caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::do_deallocate(uint64_t *a1, caulk::mach::vm_block *this, uint64_t a3)
{
  void (*v6)(uint64_t, uint64_t, caulk::mach::vm_block *, _QWORD, _QWORD, _QWORD);

  v6 = (void (*)(uint64_t, uint64_t, caulk::mach::vm_block *, _QWORD, _QWORD, _QWORD))a1[18];
  if (v6)
    v6(12, a1[16] + 8, this, 0, 0, 0);
  caulk::alloc::details::caching_page_allocator_base::deallocate(a1 + 2, this, a3);
}

BOOL caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::do_is_equal(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

_QWORD *caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::print(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *result;
  uint64_t v7;
  uint64_t v8;
  int v9;
  char v10;
  _QWORD v11[3];
  _QWORD *v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v8 = a2;
  v9 = 0;
  v10 = 0;
  result = caulk::alloc::details::caching_page_allocator_base::describe((caulk::alloc::details::caching_page_allocator_base *)(a1 + 16), (caulk::alloc::base_allocator::formatter *)&v8);
  if (a3)
  {
    v11[0] = &off_24BF2D2B0;
    v11[1] = a2;
    v12 = v11;
    caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(a1, 7, (uint64_t)v11);
    result = v12;
    if (v12 == v11)
    {
      v7 = 4;
      result = v11;
    }
    else
    {
      if (!v12)
        return result;
      v7 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v7))();
  }
  return result;
}

void sub_2065D422C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char *a15)
{
  char *v15;
  char *v17;
  uint64_t v18;

  v17 = a15;
  if (a15 == v15)
  {
    v18 = 4;
    v17 = &a12;
  }
  else
  {
    if (!a15)
      goto LABEL_6;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::enumerate(uint64_t a1, int a2, uint64_t a3)
{
  return caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(a1, a2, a3);
}

unint64_t caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::compact(uint64_t a1, uint64_t a2)
{
  return caulk::alloc::details::caching_page_allocator_base::compact((caulk::alloc::details::caching_page_allocator_base *)(a1 + 16), a2);
}

void caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::reserve(uint64_t a1@<X0>, uint64_t a2@<X1>, caulk::alloc::page_cache_monitor *a3@<X8>)
{
  caulk::alloc::page_cache_monitor::enable_preallocation(*(os_unfair_lock_t **)(a1 + 112), (uint64_t *)1);
  caulk::alloc::page_cache_monitor::reserve(a3, *(_QWORD *)(a1 + 112), a2);
}

uint64_t caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::malloc_zone(uint64_t a1)
{
  return *(_QWORD *)(a1 + 128) + 8;
}

void caulk::alloc::page_cache_monitor::reserve(caulk::alloc::page_cache_monitor *this, uint64_t a2, uint64_t a3)
{
  uint64_t **v6;
  unint64_t v7;
  __int128 v8;
  unint64_t *v9;
  unint64_t v10;
  char *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  __int128 v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  uint64_t *v32;
  uint64_t *v33;
  __int128 v34;
  uint64_t *v35;
  std::__shared_weak_count *v36;
  __int128 v37;
  __int128 v38;

  os_unfair_lock_lock(*(os_unfair_lock_t *)(a2 + 24));
  v6 = *(uint64_t ***)(a2 + 40);
  if (!v6)
  {
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(a2 + 24));
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
    return;
  }
  v7 = *(_QWORD *)(**v6 + 16);
  v8 = *((_OWORD *)v6 + 1);
  v37 = v8;
  if (*((_QWORD *)&v8 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 16);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = (char *)operator new(0x40uLL);
  v12 = (std::__shared_weak_count *)v11;
  *(_QWORD *)v11 = &off_24BF2E5E8;
  *((_QWORD *)v11 + 1) = 0;
  v13 = (unint64_t *)(v11 + 8);
  *((_QWORD *)v11 + 2) = 0;
  *((_QWORD *)v11 + 4) = 0;
  *((_QWORD *)v11 + 3) = 0;
  *(_OWORD *)(v11 + 40) = v37;
  *((_QWORD *)v11 + 7) = (a3 + v7 - 1) / v7;
  *(_QWORD *)this = v11 + 24;
  *((_QWORD *)this + 1) = v11;
  do
    v14 = __ldxr(v13);
  while (__stxr(v14 + 1, v13));
  v15 = (unint64_t *)(v11 + 16);
  do
    v16 = __ldxr(v15);
  while (__stxr(v16 + 1, v15));
  *((_QWORD *)v11 + 3) = v11 + 24;
  *((_QWORD *)v11 + 4) = v11;
  do
    v17 = __ldaxr(v13);
  while (__stlxr(v17 - 1, v13));
  if (!v17)
  {
    (*(void (**)(char *))(*(_QWORD *)v11 + 16))(v11);
    std::__shared_weak_count::__release_weak(v12);
  }
  v18 = *(_OWORD *)this;
  v19 = *((_QWORD *)this + 1);
  if (v19)
  {
    v20 = (unint64_t *)(v19 + 16);
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  v23 = v6[22];
  v22 = v6[23];
  if (v23 >= v22)
  {
    v26 = v6[21];
    v27 = ((char *)v23 - (char *)v26) >> 4;
    v28 = v27 + 1;
    if ((unint64_t)(v27 + 1) >> 60)
      std::vector<std::weak_ptr<caulk::lifetime_observed<std::unique_ptr<caulk::concurrent::details::service_thread>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::observer>>>::__throw_length_error[abi:ne180100]();
    v38 = v18;
    v29 = (char *)v22 - (char *)v26;
    if (v29 >> 3 > v28)
      v28 = v29 >> 3;
    if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF0)
      v30 = 0xFFFFFFFFFFFFFFFLL;
    else
      v30 = v28;
    if (v30 >> 60)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v31 = (char *)operator new(16 * v30);
    v32 = (uint64_t *)&v31[16 * v27];
    v33 = (uint64_t *)&v31[16 * v30];
    *(_OWORD *)v32 = v38;
    v25 = v32 + 2;
    if (v23 == v26)
    {
      v6[21] = v32;
      v6[22] = v25;
      v6[23] = v33;
      if (!v23)
        goto LABEL_35;
    }
    else
    {
      do
      {
        v34 = *((_OWORD *)v23 - 1);
        v23 -= 2;
        *((_OWORD *)v32 - 1) = v34;
        v32 -= 2;
        *v23 = 0;
        v23[1] = 0;
      }
      while (v23 != v26);
      v35 = v6[21];
      v23 = v6[22];
      v6[21] = v32;
      v6[22] = v25;
      v6[23] = v33;
      if (v23 != v35)
      {
        do
        {
          v36 = (std::__shared_weak_count *)*(v23 - 1);
          if (v36)
            std::__shared_weak_count::__release_weak(v36);
          v23 -= 2;
        }
        while (v23 != v35);
        v23 = v35;
      }
      if (!v23)
        goto LABEL_35;
    }
    operator delete(v23);
  }
  else
  {
    *(_OWORD *)v23 = v18;
    v24 = v23 + 2;
    v6[22] = v24;
    v25 = v24;
  }
LABEL_35:
  v6[22] = v25;
  caulk::alloc::page_cache_monitor_impl::evaluate_reservations(v6);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(a2 + 24));
}

void sub_2065D4540(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](v2);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v1 + 24));
  _Unwind_Resume(a1);
}

unint64_t caulk::alloc::details::caching_page_allocator_base::compact(caulk::alloc::details::caching_page_allocator_base *this, uint64_t a2)
{
  unsigned int *v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t *v13;
  caulk::mach::vm_block *v14;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;

  v4 = (unsigned int *)((char *)this + 108);
  do
    v5 = __ldaxr(v4);
  while (__stlxr(v5 | 0x80000000, v4));
  if ((v5 & 0x80000000) != 0)
    return 0;
  v6 = *((_QWORD *)this + 12);
  os_unfair_lock_lock(*(os_unfair_lock_t *)(v6 + 24));
  v7 = *(_QWORD *)(v6 + 40);
  if (v7)
    v8 = atomic_load((unint64_t *)(v7 + 160));
  else
    v8 = 0;
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v6 + 24));
  if (*((_QWORD *)this + 6) <= v8)
  {
    v9 = 0;
  }
  else
  {
    v9 = 0;
    v10 = (unint64_t *)((char *)this + 48);
    v11 = a2 - 1;
    v12 = (_QWORD *)MEMORY[0x24BDB03C8];
    do
    {
      v13 = caulk::concurrent::stack<caulk::alloc::free_block,caulk::concurrent::intrusive_single_link_node<caulk::alloc::free_block>>::pop((unsigned __int128 *)this + 2);
      if (v13)
      {
        v14 = (caulk::mach::vm_block *)v13;
        do
          v15 = __ldaxr(v10);
        while (__stlxr(v15 - 1, v10));
        while (1)
        {
          v16 = atomic_load(v4);
          if ((v16 & 0x7FFFFFFF) == 0)
            break;
          std::this_thread::sleep_for[abi:ne180100]<long long,std::ratio<1l,1000l>>(1);
        }
        caulk::mach::vm_block::dealloc(v14, (*((_QWORD *)this + 2) + *v12 - 1) & -*v12);
        v9 += *((_QWORD *)this + 2);
        if (v11 < v9)
          break;
      }
    }
    while (*v10 > v8);
  }
  do
    v17 = __ldaxr(v4);
  while (__stlxr(v17 & 0x7FFFFFFF, v4));
  return v9;
}

_QWORD *caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(uint64_t a1, int a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[3];
  _QWORD *v15;
  int v16;
  _QWORD v17[3];
  _QWORD *v18;
  _BYTE v19[24];
  _BYTE *v20;
  char v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v14[0] = &off_24BF2D570;
  v14[1] = a3;
  v15 = v14;
  v16 = a2;
  v17[0] = &off_24BF2E1C8;
  v17[1] = caulk::alloc::introspector::local_reader;
  v18 = v17;
  std::__function::__value_func<void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v19, (uint64_t)v14);
  v21 = 1;
  v4 = v15;
  if (v15 == v14)
  {
    v5 = 4;
    v4 = v14;
  }
  else
  {
    if (!v15)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  v12 = 128;
  v13 = a1;
  if (!v18)
    std::__throw_bad_function_call[abi:ne180100]();
  v6 = (*(uint64_t (**)(_QWORD *, uint64_t *, uint64_t *))(*v18 + 48))(v18, &v13, &v12);
  caulk::alloc::details::caching_page_allocator_base::introspect((unint64_t *)(v6 + 16), v7, (const caulk::alloc::introspector *)&v16);
  v8 = v20;
  if (v20 == v19)
  {
    v9 = 4;
    v8 = v19;
  }
  else
  {
    if (!v20)
      goto LABEL_12;
    v9 = 5;
  }
  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_12:
  result = v18;
  if (v18 == v17)
  {
    v11 = 4;
    result = v17;
  }
  else
  {
    if (!v18)
      return result;
    v11 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v11))();
}

void sub_2065D4828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  caulk::alloc::introspector::~introspector((caulk::alloc::introspector *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2D570;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2D570;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::operator()(uint64_t a1, int *a2, uint64_t *a3, uint64_t *a4)
{
  return std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 24), *a2, *a3, *a4);
}

uint64_t std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc19allocator_enumerateINS0_8resourceINS0_22caching_page_allocatorILm16384EEENS0_15memory_resourceEEEEEvRT_NS_10option_setINS0_12region_usageEjEERKNSt3__18functionIFvSA_NS0_5blockEEEEEUlSA_mmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1},std::allocator<void caulk::alloc::allocator_enumerate<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,caulk::option_set<caulk::alloc::region_usage,unsigned int>,std::function<void ()(caulk::alloc::region_usage,caulk::alloc::block)> const&)::{lambda(caulk::alloc::region_usage,unsigned long,unsigned long)#1}>,void ()(caulk::alloc::region_usage,unsigned long,unsigned long)>::target_type()
{
}

_QWORD *caulk::alloc::details::caching_page_allocator_base::describe(caulk::alloc::details::caching_page_allocator_base *this, caulk::alloc::base_allocator::formatter *a2)
{
  caulk::alloc::page_allocator::describe(this, a2, "caching_page_allocator");
  caulk::alloc::base_allocator::formatter::emit_string(a2, "  free stack: ");
  caulk::alloc::base_allocator::formatter::check_line_start(a2);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(a2, " x ");
  caulk::alloc::base_allocator::formatter::check_line_start(a2);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(a2, ", ");
  atomic_load((unsigned int *)this + 26);
  caulk::alloc::base_allocator::formatter::check_line_start(a2);
  std::ostream::operator<<();
  caulk::alloc::base_allocator::formatter::emit_string(a2, " cache misses");
  return caulk::alloc::base_allocator::formatter::emit_string(a2, "\n");
}

void std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2D2B0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2D2B0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::operator()(uint64_t a1, int *a2)
{
  return caulk::alloc::describe_block(*(_QWORD *)(a1 + 8), *a2);
}

uint64_t std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc15print_allocatorINS0_8resourceINS0_22caching_page_allocatorILm16384EEENS0_15memory_resourceEEEEEvRT_RNSt3__113basic_ostreamIcNS9_11char_traitsIcEEEEbEUlNS0_12region_usageENS0_5blockEE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1},std::allocator<void caulk::alloc::print_allocator<caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>>(caulk::alloc::resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource> &,std::ostream &,BOOL)::{lambda(caulk::alloc::region_usage,caulk::alloc::block)#1}>,void ()(caulk::alloc::region_usage,caulk::alloc::block)>::target_type()
{
}

_QWORD *caulk::alloc::page_allocator::describe(caulk::alloc::page_allocator *this, caulk::alloc::base_allocator::formatter *a2, char *a3)
{
  char *v5;

  if (a3)
    v5 = a3;
  else
    v5 = "page_allocator";
  caulk::alloc::base_allocator::formatter::emit_string(a2, v5);
  if (*(_DWORD *)this)
  {
    caulk::alloc::base_allocator::formatter::emit_string(a2, ", VM tag ");
    caulk::alloc::base_allocator::formatter::check_line_start(a2);
    std::ostream::operator<<();
  }
  return caulk::alloc::base_allocator::formatter::emit_string(a2, "\n");
}

void caulk::alloc::details::caching_page_allocator_base::deallocate(uint64_t *a1, caulk::mach::vm_block *this, uint64_t a3)
{
  unsigned __int128 *v3;
  unsigned __int128 v4;
  unint64_t v5;
  uint64_t v6;
  unsigned __int128 v7;
  int v8;
  unsigned __int128 v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;

  if (a3)
  {
    if (a3 == a1[2])
    {
      v3 = (unsigned __int128 *)(a1 + 4);
      do
        v4 = __ldaxp(v3);
      while (__stlxp(v4, v3));
      atomic_store(v4, (unint64_t *)this);
      do
      {
        while (1)
        {
          v7 = __ldaxp(v3);
          v6 = *((_QWORD *)&v7 + 1);
          v5 = v7;
          v8 = (_QWORD)v7 != (_QWORD)v4;
          if (*((_QWORD *)&v7 + 1) != *((_QWORD *)&v4 + 1))
            ++v8;
          if (!v8)
            break;
          if (!__stlxp(v7, v3))
            goto LABEL_12;
        }
      }
      while (__stlxp(__PAIR128__(*((_QWORD *)&v4 + 1) + 1, (unint64_t)this), v3));
LABEL_12:
      if ((_QWORD)v7 != (_QWORD)v4 || *((_QWORD *)&v7 + 1) != *((_QWORD *)&v4 + 1))
      {
        do
        {
          atomic_store(v5, (unint64_t *)this);
          do
          {
            while (1)
            {
              v10 = __ldaxp(v3);
              v11 = (_QWORD)v10 != v5;
              if (*((_QWORD *)&v10 + 1) != v6)
                ++v11;
              if (!v11)
                break;
              if (!__stlxp(v10, v3))
                goto LABEL_23;
            }
          }
          while (__stlxp(__PAIR128__(v6 + 1, (unint64_t)this), v3));
LABEL_23:
          v12 = *((_QWORD *)&v10 + 1) ^ v6;
          v13 = v10 ^ v5;
          v6 = v10 >> 64;
          v5 = v10;
        }
        while (v13 | v12);
      }
      v14 = (unint64_t *)(a1 + 6);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 + 1, v14));
      if (a1[11])
        std::function<void * ()(unsigned long,unsigned long)>::operator()(a1[11], a1[2], a1[6]);
    }
    else
    {
      caulk::mach::vm_block::dealloc(this, (a3 + *MEMORY[0x24BDB03C8] - 1) & -*MEMORY[0x24BDB03C8]);
    }
  }
  else
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
}

void std::default_delete<caulk::alloc::darwin_resource<caulk::alloc::caching_page_allocator<16384ul>,caulk::alloc::memory_resource>::zone_plus>::operator()[abi:ne180100](uint64_t a1)
{
  malloc_zone_unregister((malloc_zone_t *)(a1 + 8));
  JUMPOUT(0x20BCF9C08);
}

void std::__shared_ptr_emplace<caulk::mach::unfair_lock>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2E5B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<caulk::mach::unfair_lock>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2E5B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BCF9C08);
}

void caulk::alloc::page_allocator::deallocate(int a1, caulk::mach::vm_block *this, uint64_t a3)
{
  caulk::mach::vm_block::dealloc(this, (a3 + *MEMORY[0x24BDB03C8] - 1) & -*MEMORY[0x24BDB03C8]);
}

_QWORD *caulk::alloc::guarded_page_allocator::describe(caulk::alloc::guarded_page_allocator *this, caulk::alloc::base_allocator::formatter *a2)
{
  return caulk::alloc::page_allocator::describe(this, a2, "guarded_page_allocator");
}

char *caulk::alloc::guarded_page_allocator::allocate(caulk::alloc::guarded_page_allocator *this, uint64_t a2, unint64_t a3)
{
  size_t *v3;
  uint64_t v6;
  char *v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  char *result;
  __int16 v15[8];

  v3 = (size_t *)MEMORY[0x24BDB03C8];
  if (*MEMORY[0x24BDB03C8] < a3)
  {
    _os_assert_log();
    result = (char *)_os_crash();
    __break(1u);
  }
  else
  {
    v6 = ((a2 + *MEMORY[0x24BDB03C8] - 1) & -*MEMORY[0x24BDB03C8]) + 2 * *MEMORY[0x24BDB03C8];
    v7 = (char *)caulk::alloc::page_allocator::allocate(this, v6, a3);
    v8 = mprotect(v7, *v3, 0);
    if (v8 | mprotect(&v7[v6 - *v3], *v3, 0) && os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
    {
      v15[0] = 0;
      _os_log_error_impl(&dword_2065BE000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "couldn't protect region", (uint8_t *)v15, 2u);
    }
    v9 = a3 + ((*v3 - 1) & a2) - 1;
    v10 = v9 % a3 - v9 + *v3;
    v11 = &v7[*v3];
    if (v10 >= 4)
    {
      v12 = v10 >> 2;
      if (v10 >> 2 <= 1)
        v12 = 1;
      v13 = &v7[*v3];
      do
      {
        *(_DWORD *)v13 = -267262961;
        v13 += 4;
        --v12;
      }
      while (v12);
    }
    return &v11[v10];
  }
  return result;
}

void caulk::alloc::guarded_page_allocator::deallocate(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;

  v4 = *MEMORY[0x24BDB03C8] - 1;
  v5 = a4 + ((a3 - 2 * *MEMORY[0x24BDB03C8]) & v4) - 1;
  v6 = v5 % a4 - v5 + *MEMORY[0x24BDB03C8];
  v7 = a2 - v6;
  if (v6 < 4)
  {
LABEL_6:
    caulk::mach::vm_block::dealloc((caulk::mach::vm_block *)(v7 - *MEMORY[0x24BDB03C8]), (v4 + a3) & -*MEMORY[0x24BDB03C8]);
  }
  else
  {
    v8 = 0;
    v9 = v6 >> 2;
    if (v9 <= 1)
      v9 = 1;
    while (*(_DWORD *)(v7 + 4 * v8) == -267262961)
    {
      ++v8;
      if (!--v9)
        goto LABEL_6;
    }
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
}

void caulk::alloc::details::caching_page_allocator_base::enable_preallocation(os_unfair_lock_t **this, uint64_t *a2)
{
  caulk::alloc::page_cache_monitor::enable_preallocation(this[12], a2);
}

void caulk::alloc::details::caching_page_allocator_base::enable_preallocation(os_unfair_lock_t **this, int a2)
{
  caulk::alloc::page_cache_monitor::enable_preallocation(this[12], (uint64_t *)a2);
}

unint64_t caulk::alloc::details::caching_page_allocator_base::compact(caulk::alloc::details::caching_page_allocator_base *this)
{
  return caulk::alloc::details::caching_page_allocator_base::compact(this, 0);
}

void caulk::alloc::details::caching_page_allocator_base::reserve(os_unfair_lock_t **this@<X0>, uint64_t a2@<X1>, caulk::alloc::page_cache_monitor *a3@<X8>)
{
  caulk::alloc::page_cache_monitor::enable_preallocation(this[12], (uint64_t *)1);
  caulk::alloc::page_cache_monitor::reserve(a3, (uint64_t)this[12], a2);
}

uint64_t caulk::execution_queue::global_executor@<X0>(uint64_t a1@<X8>)
{
  unsigned __int8 v3;
  uint64_t result;

  {
    caulk::execution_queue::global_executor(void)::global = (uint64_t)&off_24BF2E220;
    qword_254512B80 = (uint64_t)&caulk::execution_queue::global_executor(void)::global;
  }
  result = qword_254512B80;
  if (qword_254512B80)
  {
    if ((uint64_t *)qword_254512B80 == &caulk::execution_queue::global_executor(void)::global)
    {
      *(_QWORD *)(a1 + 24) = a1;
      return (*(uint64_t (**)(uint64_t *, uint64_t))(caulk::execution_queue::global_executor(void)::global + 24))(&caulk::execution_queue::global_executor(void)::global, a1);
    }
    else
    {
      result = (*(uint64_t (**)(void))(*(_QWORD *)qword_254512B80 + 16))();
      *(_QWORD *)(a1 + 24) = result;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
  }
  return result;
}

void std::__function::__func<caulk::execution_queue::global_executor(void)::$_0,std::allocator<caulk::execution_queue::global_executor(void)::$_0>,void ()(caulk::v1::task<void ()(void)>)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<caulk::execution_queue::global_executor(void)::$_0,std::allocator<caulk::execution_queue::global_executor(void)::$_0>,void ()(caulk::v1::task<void ()(void)>)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24BF2E220;
  return result;
}

void std::__function::__func<caulk::execution_queue::global_executor(void)::$_0,std::allocator<caulk::execution_queue::global_executor(void)::$_0>,void ()(caulk::v1::task<void ()(void)>)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24BF2E220;
}

uint64_t std::__function::__func<caulk::execution_queue::global_executor(void)::$_0,std::allocator<caulk::execution_queue::global_executor(void)::$_0>,void ()(caulk::v1::task<void ()(void)>)>::operator()(uint64_t a1, uint64_t *a2)
{
  void *v2;
  NSObject *global_queue;
  void (***v5)(uint64_t);
  uint64_t v6;
  _BYTE v7[248];
  void (**v8)(_QWORD *);
  _QWORD v9[32];

  v9[31] = *MEMORY[0x24BDAC8D0];
  v6 = *a2;
  (*(void (**)(uint64_t *, _BYTE *))(v6 + 8))(a2 + 1, v7);
  v8 = (void (**)(_QWORD *))v6;
  (*(void (**)(_BYTE *, _QWORD *))(v6 + 8))(v7, v9);
  v2 = (void *)operator new();
  global_queue = dispatch_get_global_queue(21, 0);
  *(_QWORD *)v2 = v8;
  (*(void (**)(_QWORD *, uint64_t))(*(_QWORD *)v2 + 8))(v9, (uint64_t)v2 + 8);
  v5 = 0;
  dispatch_async_f(global_queue, v2, (dispatch_function_t)applesauce::dispatch::v1::async<caulk::execution_queue::global_executor(void)::$_0::operator() const(caulk::v1::task<void ()(void)>)::{lambda(void)#1}>(dispatch_queue_s *,caulk::execution_queue::global_executor(void)::$_0::operator() const(caulk::v1::task<void ()(void)>)::{lambda(void)#1} &&)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<caulk::execution_queue::global_executor(void)::$_0::operator() const(caulk::v1::task<void ()(void)>)::{lambda(void)#1},std::default_delete<caulk::execution_queue::global_executor(void)::$_0::operator() const(caulk::v1::task<void ()(void)>)::{lambda(void)#1}>>::~unique_ptr[abi:ne180100](&v5);
  (*v8)(v9);
  return (*(uint64_t (**)(_BYTE *))v6)(v7);
}

void sub_2065D5160(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<caulk::execution_queue::global_executor(void)::$_0,std::allocator<caulk::execution_queue::global_executor(void)::$_0>,void ()(caulk::v1::task<void ()(void)>)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk15execution_queue15global_executorEvE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<caulk::execution_queue::global_executor(void)::$_0,std::allocator<caulk::execution_queue::global_executor(void)::$_0>,void ()(caulk::v1::task<void ()(void)>)>::target_type()
{
}

void (****applesauce::dispatch::v1::async<caulk::execution_queue::global_executor(void)::$_0::operator() const(caulk::v1::task<void ()(void)>)::{lambda(void)#1}>(dispatch_queue_s *,caulk::execution_queue::global_executor(void)::$_0::operator() const(caulk::v1::task<void ()(void)>)::{lambda(void)#1} &&)::{lambda(void *)#1}::__invoke(void (***a1)(uint64_t)))(uint64_t)
{
  void (***v2)(uint64_t);

  v2 = a1;
  (*a1)[2]((uint64_t)(a1 + 1));
  return std::unique_ptr<caulk::execution_queue::global_executor(void)::$_0::operator() const(caulk::v1::task<void ()(void)>)::{lambda(void)#1},std::default_delete<caulk::execution_queue::global_executor(void)::$_0::operator() const(caulk::v1::task<void ()(void)>)::{lambda(void)#1}>>::~unique_ptr[abi:ne180100](&v2);
}

void sub_2065D51F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<caulk::execution_queue::global_executor(void)::$_0::operator() const(caulk::v1::task<void ()(void)>)::{lambda(void)#1},std::default_delete<caulk::execution_queue::global_executor(void)::$_0::operator() const(caulk::v1::task<void ()(void)>)::{lambda(void)#1}>>::~unique_ptr[abi:ne180100]((void (****)(uint64_t))va);
  _Unwind_Resume(a1);
}

void (****std::unique_ptr<caulk::execution_queue::global_executor(void)::$_0::operator() const(caulk::v1::task<void ()(void)>)::{lambda(void)#1},std::default_delete<caulk::execution_queue::global_executor(void)::$_0::operator() const(caulk::v1::task<void ()(void)>)::{lambda(void)#1}>>::~unique_ptr[abi:ne180100](void (****a1)(uint64_t)))(uint64_t)
{
  void (***v2)(uint64_t);

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    (**v2)((uint64_t)(v2 + 1));
    MEMORY[0x20BCF9C08](v2, 0x1060C404CFE1F30);
  }
  return a1;
}

uint64_t caulk::execution_queue::execution_queue(uint64_t result, _QWORD *a2)
{
  *(_BYTE *)result = 0;
  *(_QWORD *)(result + 8) = *a2;
  *a2 = 0;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

{
  *(_BYTE *)result = 0;
  *(_QWORD *)(result + 8) = *a2;
  *a2 = 0;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

void caulk::execution_queue::~execution_queue(caulk::execution_queue *this)
{
  unsigned __int8 v2;
  NSObject *v3;

  v2 = atomic_load((unsigned __int8 *)this);
  if ((v2 & 1) == 0)
    caulk::execution_queue::invalidate((dispatch_queue_t *)this);
  v3 = *((_QWORD *)this + 1);
  if (v3)
    dispatch_release(v3);
}

uint64_t caulk::execution_queue::invalidate(dispatch_queue_t *this)
{
  uint64_t v2;
  const char *label;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_not_V2(this[1]);
  atomic_store(1u, (unsigned __int8 *)this);
  dispatch_sync_f(this[1], this, (dispatch_function_t)caulk::execution_queue::drain);
  v2 = *((unsigned int *)this + 4);
  if ((_DWORD)v2 && os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT))
  {
    label = dispatch_queue_get_label(this[1]);
    v5 = 136315394;
    v6 = label;
    v7 = 1024;
    v8 = v2;
    _os_log_impl(&dword_2065BE000, MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT, "%s: discarded %d message(s) post-invalidation", (uint8_t *)&v5, 0x12u);
    return *((unsigned int *)this + 4);
  }
  return v2;
}

void sub_2065D53B0(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t caulk::execution_queue::async_task(uint64_t a1, uint64_t *a2)
{
  unsigned __int8 v2;
  uint64_t v4;
  NSObject *v5;
  _QWORD *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t (**v10)(_QWORD *);
  _QWORD v11[32];

  v11[31] = *MEMORY[0x24BDAC8D0];
  v2 = atomic_load((unsigned __int8 *)a1);
  if ((v2 & 1) != 0)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  v4 = *a2;
  v9 = a1;
  v10 = (uint64_t (**)(_QWORD *))v4;
  (*(void (**)(uint64_t *, _QWORD *))(v4 + 8))(a2 + 1, v11);
  v5 = *(NSObject **)(a1 + 8);
  v6 = (_QWORD *)operator new();
  *v6 = v9;
  v6[1] = v10;
  (*(void (**)(_QWORD *, _QWORD *))(v6[1] + 8))(v11, v6 + 2);
  v8 = 0;
  dispatch_async_f(v5, v6, (dispatch_function_t)applesauce::dispatch::v1::async<caulk::execution_queue::async_task(caulk::v1::task<void ()(void)> &&)::$_0>(dispatch_queue_s *,caulk::execution_queue::async_task(caulk::v1::task<void ()(void)> &&)::$_0 &&)::{lambda(void *)#1}::__invoke);
  std::unique_ptr<caulk::execution_queue::async_task(caulk::v1::task<void ()(void)> &&)::$_0,std::default_delete<caulk::v1::task<void ()(void)> &&>>::~unique_ptr[abi:ne180100](&v8);
  return (*v10)(v11);
}

void sub_2065D54D0(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

uint64_t *applesauce::dispatch::v1::async<caulk::execution_queue::async_task(caulk::v1::task<void ()(void)> &&)::$_0>(dispatch_queue_s *,caulk::execution_queue::async_task(caulk::v1::task<void ()(void)> &&)::$_0 &&)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t *v2;

  v2 = a1;
  caulk::execution_queue::execute_internal(*a1, (uint64_t)(a1 + 1));
  return std::unique_ptr<caulk::execution_queue::async_task(caulk::v1::task<void ()(void)> &&)::$_0,std::default_delete<caulk::v1::task<void ()(void)> &&>>::~unique_ptr[abi:ne180100]((uint64_t *)&v2);
}

void sub_2065D551C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<caulk::execution_queue::async_task(caulk::v1::task<void ()(void)> &&)::$_0,std::default_delete<caulk::v1::task<void ()(void)> &&>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<caulk::execution_queue::async_task(caulk::v1::task<void ()(void)> &&)::$_0,std::default_delete<caulk::v1::task<void ()(void)> &&>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    (**(void (***)(uint64_t))(v2 + 8))(v2 + 16);
    MEMORY[0x20BCF9C08](v2, 0x1060C40B185B547);
  }
  return a1;
}

uint64_t caulk::execution_queue::execute_internal(uint64_t result, uint64_t a2)
{
  unsigned __int8 v2;

  v2 = atomic_load((unsigned __int8 *)result);
  if ((v2 & 1) == 0)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2 + 8);
  ++*(_DWORD *)(result + 16);
  return result;
}

void sub_2065D5600(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 a9)
{
  uint64_t v9;
  const char *label;

  if (a2)
  {
    __cxa_begin_catch(a1);
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
    {
      label = dispatch_queue_get_label(*(dispatch_queue_t *)(v9 + 8));
      LODWORD(a9) = 136315138;
      *(_QWORD *)((char *)&a9 + 4) = label;
      _os_log_error_impl(&dword_2065BE000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "%s: caught exception", (uint8_t *)&a9, 0xCu);
    }
    __cxa_end_catch();
    JUMPOUT(0x2065D55D4);
  }
  _Unwind_Resume(a1);
}

uint64_t caulk::execution_queue::sync_task(uint64_t a1, uint64_t *a2)
{
  unsigned __int8 v2;
  uint64_t v4;
  NSObject *v5;
  _QWORD block[5];
  uint64_t v8;
  uint64_t (**v9)(_QWORD *);
  _QWORD v10[32];

  v10[31] = *MEMORY[0x24BDAC8D0];
  v2 = atomic_load((unsigned __int8 *)a1);
  if ((v2 & 1) != 0)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  v4 = *a2;
  v8 = a1;
  v9 = (uint64_t (**)(_QWORD *))v4;
  (*(void (**)(uint64_t *, _QWORD *))(v4 + 8))(a2 + 1, v10);
  v5 = *(NSObject **)(a1 + 8);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 0x40000000;
  block[2] = ___ZN10applesauce8dispatch2v19sync_implIZN5caulk15execution_queue9sync_taskEONS3_2v14taskIFvvEEEE3__0EEvP16dispatch_queue_sOT_NSt3__117integral_constantIbLb1EEE_block_invoke;
  block[3] = &__block_descriptor_tmp_117;
  block[4] = &v8;
  dispatch_sync(v5, block);
  return (*v9)(v10);
}

void sub_2065D574C(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN10applesauce8dispatch2v19sync_implIZN5caulk15execution_queue9sync_taskEONS3_2v14taskIFvvEEEE3__0EEvP16dispatch_queue_sOT_NSt3__117integral_constantIbLb1EEE_block_invoke(uint64_t a1)
{
  return caulk::execution_queue::execute_internal(**(_QWORD **)(a1 + 32), *(_QWORD *)(a1 + 32) + 8);
}

CFTypeRef caulk::xstring::assign(caulk::xstring *this, CFTypeRef cf)
{
  const void *v4;

  v4 = (const void *)*((_QWORD *)this + 1);
  if (v4)
    CFRelease(v4);
  *((_QWORD *)this + 1) = cf;
  return CFRetain(cf);
}

void caulk::xstring::clear(caulk::xstring *this)
{
  const void *v2;

  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 1) = 0;
  }
}

CFStringRef caulk::xstring::assign(caulk::xstring *this, const char *cStr)
{
  const void *v4;
  CFStringRef result;

  v4 = (const void *)*((_QWORD *)this + 1);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)this + 1) = 0;
  }
  result = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], cStr, 0x8000100u);
  *((_QWORD *)this + 1) = result;
  return result;
}

CFStringRef caulk::xstring::assign(caulk::xstring *this, UInt8 *bytes, CFIndex numBytes)
{
  const void *v6;
  CFStringRef result;

  v6 = (const void *)*((_QWORD *)this + 1);
  if (v6)
  {
    CFRelease(v6);
    *((_QWORD *)this + 1) = 0;
  }
  result = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x24BDBD240], bytes, numBytes, 0x8000100u, 0);
  *((_QWORD *)this + 1) = result;
  return result;
}

CFStringRef caulk::xstring::assign(caulk::xstring *a1, UInt8 *a2)
{
  CFIndex v2;
  CFIndex v3;

  v2 = *((_QWORD *)a2 + 1);
  if ((a2[23] & 0x80u) == 0)
  {
    v3 = a2[23];
  }
  else
  {
    a2 = *(UInt8 **)a2;
    v3 = v2;
  }
  return caulk::xstring::assign(a1, a2, v3);
}

CFTypeRef caulk::xstring::assign(caulk::xstring *this, const caulk::xstring *a2)
{
  const void *v4;
  CFTypeRef result;

  v4 = (const void *)*((_QWORD *)this + 1);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)this + 1) = 0;
  }
  result = (CFTypeRef)*((_QWORD *)a2 + 1);
  if (result)
  {
    *((_QWORD *)this + 1) = result;
    return CFRetain(result);
  }
  return result;
}

void caulk::xstring::move(uint64_t a1, uint64_t a2)
{
  const void *v4;

  v4 = *(const void **)(a1 + 8);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 8) = 0;
  }
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
}

uint64_t caulk::xstring::swap(uint64_t this, caulk::xstring *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(this + 8);
  *(_QWORD *)(this + 8) = *((_QWORD *)a2 + 1);
  *((_QWORD *)a2 + 1) = v2;
  return this;
}

const char *caulk::xstring::c_str(caulk::xstring *this)
{
  const __CFString *v2;
  const char *result;

  v2 = (const __CFString *)*((_QWORD *)this + 1);
  if (!v2)
    return "";
  result = CFStringGetCStringPtr(v2, 0x8000100u);
  if (!result)
    return (const char *)objc_msgSend(objc_retainAutorelease(*((id *)this + 1)), "UTF8String");
  return result;
}

BOOL caulk::xstring::empty(caulk::xstring *this)
{
  return *caulk::xstring::c_str(this) == 0;
}

size_t caulk::xstring::size(caulk::xstring *this)
{
  const char *v1;

  v1 = caulk::xstring::c_str(this);
  return strlen(v1);
}

CFComparisonResult caulk::xstring::compare(caulk::xstring *this, const caulk::xstring *a2)
{
  const __CFString *v2;
  const __CFString *v3;

  v2 = (const __CFString *)*((_QWORD *)this + 1);
  v3 = (const __CFString *)*((_QWORD *)a2 + 1);
  if (!v2)
    return (unint64_t)(v3 == 0);
  if (v3)
    return CFStringCompare(v2, v3, 0);
  return 0;
}

const __CFString *caulk::xstring::materialize_cfstring(caulk::xstring *this)
{
  if (*((_QWORD *)this + 1))
    return (const __CFString *)*((_QWORD *)this + 1);
  else
    return &stru_24BF2E7B8;
}

void caulk::details::log_msg::~log_msg(caulk::details::log_msg *this)
{
  *(_QWORD *)this = &off_24BF2CF18;
  std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100]((uint64_t)this + 24);
  caulk::concurrent::message::~message(this);
}

{
  *(_QWORD *)this = &off_24BF2CF18;
  std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100]((uint64_t)this + 24);
  caulk::concurrent::message::~message(this);
  JUMPOUT(0x20BCF9C08);
}

uint64_t caulk::details::log_msg::perform(caulk::details::log_msg *this)
{
  uint64_t v2;
  unint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  unsigned int *v10;
  unsigned int v11;
  NSObject *v12;
  _DWORD v14[2];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 3);
  v3 = (unint64_t *)(v2 + 32);
  v4 = *(_QWORD *)(v2 + 32);
  if (*((_BYTE *)this + 22) == 2)
    v5 = -1;
  else
    v5 = 0;
  v6 = __ldaxr(v3);
  if (v6 != v4)
  {
    __clrex();
    goto LABEL_8;
  }
  if (__stlxr((v4 - *((unsigned __int16 *)this + 10)) | (v4 + (v5 << 32)) & 0xFFFFFFFF00000000, v3))
  {
LABEL_8:
    v7 = v5 << 32;
    while (1)
    {
      v8 = __ldaxr(v3);
      if (v8 != v6)
        break;
      if (__stlxr((v6 - *((unsigned __int16 *)this + 10)) | (v6 + v7) & 0xFFFFFFFF00000000, v3))
        goto LABEL_13;
      v9 = 1;
LABEL_14:
      v6 = v8;
      if (v9)
        goto LABEL_15;
    }
    __clrex();
LABEL_13:
    v9 = 0;
    goto LABEL_14;
  }
LABEL_15:
  os_log_pack_send();
  if (*(_DWORD *)(v2 + 40))
  {
    v10 = (unsigned int *)(v2 + 40);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(0, v10));
    v12 = *(NSObject **)(v2 + 24);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v14[0] = 67109120;
      v14[1] = v11;
      _os_log_error_impl(&dword_2065BE000, v12, OS_LOG_TYPE_ERROR, "%u messages were dropped due to log throttling", (uint8_t *)v14, 8u);
    }
  }
  (**(void (***)(caulk::details::log_msg *))this)(this);
  if (!caulk::g_realtime_safe_resource)
    __break(1u);
  return (*(uint64_t (**)(void))(*(_QWORD *)caulk::g_realtime_safe_resource + 24))();
}

uint64_t std::default_delete<caulk::deferred_logger>::operator()[abi:ne180100](uint64_t result)
{
  std::__shared_weak_count *v1;

  if (result)
  {
    v1 = *(std::__shared_weak_count **)(result + 8);
    if (v1)
      std::__shared_weak_count::__release_weak(v1);
    JUMPOUT(0x20BCF9C08);
  }
  return result;
}

void std::__shared_ptr_pointer<caulk::deferred_logger *,std::shared_ptr<caulk::deferred_logger>::__shared_ptr_default_delete<caulk::deferred_logger,caulk::deferred_logger>,std::allocator<caulk::deferred_logger>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BCF9C08);
}

uint64_t std::__shared_ptr_pointer<caulk::deferred_logger *,std::shared_ptr<caulk::deferred_logger>::__shared_ptr_default_delete<caulk::deferred_logger,caulk::deferred_logger>,std::allocator<caulk::deferred_logger>>::__on_zero_shared(uint64_t a1)
{
  return std::default_delete<caulk::deferred_logger>::operator()[abi:ne180100](*(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<caulk::deferred_logger *,std::shared_ptr<caulk::deferred_logger>::__shared_ptr_default_delete<caulk::deferred_logger,caulk::deferred_logger>,std::allocator<caulk::deferred_logger>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN5caulk15deferred_loggerEE27__shared_ptr_default_deleteIS2_S2_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void caulk::deferred_logger::~deferred_logger(caulk::deferred_logger *this)
{
  std::__shared_weak_count *v1;

  v1 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

{
  std::__shared_weak_count *v1;

  v1 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

uint64_t caulk::deferred_logger::create_message(caulk::deferred_logger *this, unint64_t a2, int a3)
{
  char v3;
  unsigned __int16 v4;
  unint64_t v5;
  unsigned int v6;
  uint64_t v7;
  unint64_t *v9;
  unint64_t v10;
  BOOL v11;
  unsigned int *v12;
  unsigned int v13;
  uint64_t v14;
  std::__shared_weak_count *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  _QWORD *exception;
  _QWORD v23[2];

  if (a2 >= 0x10000)
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = &off_24BF2DE98;
  }
  v3 = a3;
  v4 = a2;
  v5 = *((_QWORD *)this + 4);
  v6 = a2 + v5;
  if (a3 == 2)
    v7 = (HIDWORD(v5) + 1);
  else
    v7 = HIDWORD(v5);
  if (v6 > 0x10000 && (_DWORD)v7 == 0)
  {
LABEL_19:
    v12 = (unsigned int *)((char *)this + 40);
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 + 1, v12));
    return 0;
  }
  v9 = (unint64_t *)((char *)this + 32);
  while (1)
  {
    v10 = __ldaxr(v9);
    if (v10 != v5)
    {
      __clrex();
      goto LABEL_14;
    }
    if (!__stlxr(v6 | (unint64_t)(v7 << 32), v9))
      break;
LABEL_14:
    v6 = a2 + v10;
    v7 = HIDWORD(v10) + (a3 == 2);
    v11 = (a2 + v10) > 0x10000 && (_DWORD)v7 == 0;
    v5 = v10;
    if (v11)
      goto LABEL_19;
  }
  v17 = *(_QWORD *)this;
  v16 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  v23[0] = v17;
  if (!v16 || (v18 = std::__shared_weak_count::lock(v16), (v23[1] = v18) == 0))
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v19 = v18;
  v14 = caulk::details::log_msg::create(v23, v4, v3);
  p_shared_owners = (unint64_t *)&v19->__shared_owners_;
  do
    v21 = __ldaxr(p_shared_owners);
  while (__stlxr(v21 - 1, p_shared_owners));
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  return v14;
}

uint64_t caulk::details::log_msg::create(_QWORD *a1, unsigned int a2, char a3)
{
  uint64_t result;
  __int16 v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  result = caulk::g_realtime_safe_resource;
  if (caulk::g_realtime_safe_resource)
  {
    v6 = a2;
    result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)caulk::g_realtime_safe_resource + 16))(caulk::g_realtime_safe_resource, a2, 8);
    *(_DWORD *)(result + 16) = 0;
    *(_QWORD *)result = &off_24BF2CF18;
    *(_QWORD *)(result + 8) = 0;
    *(_WORD *)(result + 20) = v6;
    *(_BYTE *)(result + 22) = a3;
    v7 = a1[1];
    *(_QWORD *)(result + 24) = *a1;
    *(_QWORD *)(result + 32) = v7;
    if (v7)
    {
      v8 = (unint64_t *)(v7 + 8);
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
  }
  else
  {
    __break(1u);
  }
  return result;
}

void std::__throw_bad_weak_ptr[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x24BEDB808] + 16;
  __cxa_throw(exception, MEMORY[0x24BEDB6D8], MEMORY[0x24BEDAC00]);
}

void gsl::narrowing_error::~narrowing_error(std::exception *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x20BCF9C08);
}

uint64_t caulk::xpc::reply_watchdog_factory::reply_watchdog_factory(uint64_t a1, int a2, _QWORD *a3)
{
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _BYTE v10[24];
  _QWORD v11[2];

  v11[1] = *MEMORY[0x24BDAC8D0];
  *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  v5 = a3 + 3;
  v6 = (_QWORD *)a3[3];
  if (!v6)
  {
    v5 = v11;
    goto LABEL_5;
  }
  if (v6 != a3)
  {
    v11[0] = a3[3];
LABEL_5:
    *v5 = 0;
    goto LABEL_7;
  }
  v11[0] = v10;
  (*(void (**)(_QWORD *, _BYTE *))(*a3 + 24))(a3, v10);
LABEL_7:
  caulk::xpc::reply_watchdog_factory::init2(a1, a2, (uint64_t)v10);
  v7 = (_QWORD *)v11[0];
  if ((_BYTE *)v11[0] == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_11;
  }
  if (v11[0])
  {
    v8 = 5;
LABEL_11:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return a1;
}

void sub_2065D6074(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN5caulk3xpc22reply_watchdog_factory10make_timerEi_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint8_t v4[16];

  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_2065BE000, MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT, "XPC timeout", v4, 2u);
  }
  v2 = *(_QWORD *)(a1 + 56);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
}

void applesauce::dispatch::v1::source::~source(id *this)
{
  id v2;

  v2 = *this;
  *this = 0;

}

void caulk::thread::thread(uint64_t a1, _QWORD *a2)
{
  unsigned __int8 *v2;
  unsigned __int8 v3;
  unsigned __int8 v4;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)a1 = *a2;
  *(_BYTE *)(a1 + 8) = 0;
  *a2 = 0;
  v2 = (unsigned __int8 *)(a2 + 1);
  v3 = atomic_load(v2);
  atomic_store(v3 & 1, (unsigned __int8 *)(a1 + 8));
  v4 = atomic_load(v2);
  atomic_store(v4 & 1, (unsigned __int8 *)(a1 + 8));
}

{
  unsigned __int8 *v2;
  unsigned __int8 v3;
  unsigned __int8 v4;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)a1 = *a2;
  *(_BYTE *)(a1 + 8) = 0;
  *a2 = 0;
  v2 = (unsigned __int8 *)(a2 + 1);
  v3 = atomic_load(v2);
  atomic_store(v3 & 1, (unsigned __int8 *)(a1 + 8));
  v4 = atomic_load(v2);
  atomic_store(v4 & 1, (unsigned __int8 *)(a1 + 8));
}

void caulk::thread::operator=(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)a1;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)a2 = v2;
  LOBYTE(v2) = atomic_load(a2 + 8);
  atomic_store(v2 & 1, a1 + 8);
}

void caulk::thread::~thread(caulk::thread *this)
{
  if (*(_QWORD *)this)
    std::terminate();
}

{
  if (*(_QWORD *)this)
    std::terminate();
}

uint64_t caulk::thread::join(pthread_t *this)
{
  uint64_t result;

  if (!*this)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_6;
  }
  if (pthread_self() == *this)
  {
LABEL_6:
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_7;
  }
  result = pthread_join(*this, 0);
  if (!(_DWORD)result)
  {
    *this = 0;
    return result;
  }
LABEL_7:
  _os_assert_log();
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t caulk::thread::detach(_opaque_pthread_t **this)
{
  _opaque_pthread_t *v2;
  uint64_t result;

  v2 = *this;
  if (v2)
  {
    result = pthread_detach(v2);
    if (!(_DWORD)result)
    {
      *this = 0;
      return result;
    }
  }
  else
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  _os_assert_log();
  result = _os_crash();
  __break(1u);
  return result;
}

void caulk::mach::os_eventlink::make(void **a1@<X8>)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)os_eventlink_create();
  if (v2)
  {
    if (os_eventlink_activate())
    {
      os_release(v2);
      v2 = 0;
    }
    std::this_thread::sleep_for[abi:ne180100]<long long,std::ratio<1l,1000l>>(1);
    *a1 = caulk::mach::details::retain_os_object(v2, v3);
    caulk::mach::details::release_os_object((caulk::mach::details *)v2, v4);
  }
  else
  {
    *a1 = 0;
  }
}

void caulk::mach::os_eventlink::make(_QWORD *a1@<X8>)
{
  void *v2;

  v2 = (void *)os_eventlink_create_with_port();
  if (v2 && os_eventlink_activate())
  {
    os_release(v2);
    v2 = 0;
  }
  *a1 = v2;
}

uint64_t caulk::mach::os_eventlink::copy_mach_port(caulk::mach::os_eventlink *this)
{
  uint64_t result;

  result = *(_QWORD *)this;
  if (result)
  {
    if (os_eventlink_extract_remote_port())
      return 0;
    else
      return 0;
  }
  return result;
}

uint64_t caulk::mach::os_eventlink::associate(caulk::mach::os_eventlink *this)
{
  if (*(_QWORD *)this)
    return os_eventlink_associate();
  else
    return 22;
}

uint64_t caulk::mach::os_eventlink::dissociate(caulk::mach::os_eventlink *this)
{
  if (*(_QWORD *)this)
    return os_eventlink_disassociate();
  else
    return 22;
}

uint64_t caulk::mach::os_eventlink::signal_or_error(caulk::mach::os_eventlink *this)
{
  int v1;
  uint64_t v2;
  unsigned int v3;
  int v4;

  if (*(_QWORD *)this)
  {
    v1 = os_eventlink_signal();
    v2 = 0x100000000;
    v3 = v1 & 0xFFFFFF00;
    v4 = v1;
    if (v1)
      v2 = 0;
    else
      v4 = 0;
    if (!v1)
      v3 = 0;
  }
  else
  {
    v2 = 0;
    v3 = 0;
    v4 = 22;
  }
  return v2 | v3 | v4;
}

unint64_t caulk::mach::os_eventlink::wait_or_error(caulk::mach::os_eventlink *this)
{
  unsigned int v1;

  if (!*(_QWORD *)this)
    return 22;
  v1 = os_eventlink_wait();
  return v1 | ((unint64_t)(v1 == 0) << 32);
}

uint64_t caulk::mach::os_eventlink::timed_wait_or_error(caulk::mach::os_eventlink *this, double a2)
{
  int v2;
  unsigned int v3;
  uint64_t v4;

  if (*(_QWORD *)this)
  {
    v2 = os_eventlink_wait_until();
    if (v2 && v2 != 60)
    {
      v4 = 0;
      v3 = v2 & 0xFFFFFF00;
    }
    else
    {
      v3 = 0;
      LOBYTE(v2) = 0;
      v4 = 0x100000000;
    }
  }
  else
  {
    v4 = 0;
    v3 = 0;
    LOBYTE(v2) = 22;
  }
  return v4 & 0x100000000 | v3 & 0xFFFFFF00 | v2;
}

unint64_t caulk::mach::os_eventlink::wait_signal_or_error(caulk::mach::os_eventlink *this)
{
  unsigned int v1;

  if (!*(_QWORD *)this)
    return 22;
  v1 = os_eventlink_signal_and_wait();
  return v1 | ((unint64_t)(v1 == 0) << 32);
}

uint64_t caulk::mach::os_eventlink::timed_wait_signal_or_error(caulk::mach::os_eventlink *this, double a2)
{
  int v2;
  unsigned int v3;
  uint64_t v4;

  if (*(_QWORD *)this)
  {
    v2 = os_eventlink_signal_and_wait_until();
    if (v2 && v2 != 60)
    {
      v4 = 0;
      v3 = v2 & 0xFFFFFF00;
    }
    else
    {
      v3 = 0;
      LOBYTE(v2) = 0;
      v4 = 0x100000000;
    }
  }
  else
  {
    v4 = 0;
    v3 = 0;
    LOBYTE(v2) = 22;
  }
  return v4 & 0x100000000 | v3 & 0xFFFFFF00 | v2;
}

unint64_t caulk::pooled_semaphore_mutex::lock_impl(unint64_t this, double *a2)
{
  unsigned int *v3;
  unsigned __int16 v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  int v11;
  caulk::details::semaphore_pool *v12;
  unsigned int v13;
  int v14;
  _WORD *v15;
  semaphore_t *v16;

  v3 = (unsigned int *)this;
  v4 = 0;
  v5 = *(_DWORD *)this;
  do
  {
    v6 = HIWORD(v5);
    if ((unsigned __int16)v5 == 1 && v6 == 0)
    {
      if (v4)
      {
        LOWORD(v11) = 2;
        LOWORD(v6) = v4;
      }
      else
      {
        caulk::details::semaphore_pool::instance((caulk::details::semaphore_pool *)this);
        LOWORD(v11) = 2;
        this = caulk::details::semaphore_pool::acquire(v12);
        LOWORD(v6) = this;
        v4 = this;
      }
    }
    else
    {
      if (v4)
      {
        caulk::details::semaphore_pool::instance((caulk::details::semaphore_pool *)this);
        this = caulk::details::semaphore_pool::sema_ref_to_bank((caulk::details::semaphore_pool *)v4);
        v8 = ~(1 << (v4 - *(_WORD *)this));
        v9 = (unint64_t *)(this + 1040);
        do
          v10 = __ldaxr(v9);
        while (__stlxr(v10 & v8, v9));
      }
      v11 = (unsigned __int16)v5 + 1;
      if ((v11 & 0x10000) != 0)
      {
        __break(1u);
        return this;
      }
      v4 = 0;
    }
    v13 = __ldaxr(v3);
    if (v13 == v5)
    {
      if (!__stlxr((unsigned __int16)v11 | ((unsigned __int16)v6 << 16), v3))
      {
        v14 = 1;
        goto LABEL_19;
      }
    }
    else
    {
      __clrex();
    }
    v14 = 0;
LABEL_19:
    v5 = v13;
  }
  while (!v14);
  if ((_WORD)v6)
  {
    caulk::details::semaphore_pool::instance((caulk::details::semaphore_pool *)this);
    v15 = (_WORD *)caulk::details::semaphore_pool::sema_ref_to_bank((caulk::details::semaphore_pool *)(unsigned __int16)v6);
    v16 = (semaphore_t *)&v15[8 * (unsigned __int16)(v6 - *v15) + 2];
    if (a2)
    {
      if (!caulk::semaphore::timed_wait(v16, *a2))
      {
        caulk::pooled_semaphore_mutex::unlock_impl(v3, 1);
        return 0;
      }
    }
    else
    {
      caulk::semaphore::timed_wait(v16, -1.0);
    }
  }
  __dmb(9u);
  return 1;
}

unint64_t caulk::pooled_semaphore_mutex::_try_lock_for (caulk::pooled_semaphore_mutex *this, double a2)
{
  double v3;

  v3 = a2;
  return caulk::pooled_semaphore_mutex::lock_impl((unint64_t)this, &v3);
}

caulk::ipc::mapped_memory *caulk::ipc::mapped_memory::mapped_memory(caulk::ipc::mapped_memory *this, uint64_t a2, int a3)
{
  size_t v5;
  int v6;
  void *v7;
  std::runtime_error *exception;

  v5 = (a2 + 0x3FFF) & 0xFFFFFFFFFFFFC000;
  if (a3)
    v6 = a3 << 24;
  else
    v6 = -1;
  v7 = mmap(0, (a2 + 0x3FFF) & 0xFFFFFFFFFFFFC000, 3, 4097, v6, 0);
  *(_QWORD *)this = v7;
  *((_QWORD *)this + 1) = v5;
  *((_BYTE *)this + 16) = 1;
  if (!a2)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_8:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "failed to create shared memory");
    __cxa_throw(exception, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  if ((unint64_t)v7 + 1 <= 1)
    goto LABEL_8;
  bzero(v7, v5);
  return this;
}

void sub_2065D68EC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t caulk::ipc::mapped_memory::mapped_memory(uint64_t a1, xpc_object_t *a2)
{
  size_t v4;
  std::runtime_error *exception;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  if (!*a2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "no object");
    goto LABEL_9;
  }
  if (MEMORY[0x20BCFA2BC]() != MEMORY[0x24BDACFE8])
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "not a shared memory object");
    goto LABEL_9;
  }
  v4 = xpc_shmem_map(*a2, (void **)a1);
  *(_QWORD *)(a1 + 8) = v4;
  if (!*(_QWORD *)a1 || !v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "failed to map in shared memory");
LABEL_9:
    __cxa_throw(exception, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  return a1;
}

void sub_2065D69D0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *caulk::ipc::mapped_memory::create_xpc_object@<X0>(caulk::ipc::mapped_memory *this@<X0>, _QWORD *a2@<X8>)
{
  void *result;
  size_t v5;

  if (*((_BYTE *)this + 16))
  {
    result = *(void **)this;
    if (result)
    {
      v5 = *((_QWORD *)this + 1);
      if (v5)
        result = xpc_shmem_create(result, v5);
      else
        result = 0;
    }
    *a2 = result;
  }
  else
  {
    _os_assert_log();
    result = (void *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t caulk::ipc::mapped_memory::reset(caulk::ipc::mapped_memory *this)
{
  uint64_t result;
  size_t v3;

  result = *(_QWORD *)this;
  if (result)
  {
    v3 = *((_QWORD *)this + 1);
    if (v3)
      result = munmap((void *)result, v3);
  }
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  return result;
}

uint64_t caulk::mach::vm_block::alloc_at(caulk::mach::vm_block *this)
{
  return 0;
}

const void *caulk::mach::vm_block::lock(const void *this, size_t a2)
{
  const char *v2;

  if (this)
  {
    if (a2)
    {
      v2 = (const char *)mlock(this, a2);
      return (const void *)caulk::mach::throw_if_mach_error((uint64_t)"mlock failed", v2);
    }
  }
  return this;
}

const void *caulk::mach::vm_block::unlock(const void *this, size_t a2)
{
  const char *v2;

  if (this)
  {
    if (a2)
    {
      v2 = (const char *)munlock(this, a2);
      return (const void *)caulk::mach::throw_if_mach_error((uint64_t)"munlock failed", v2);
    }
  }
  return this;
}

caulk::mach::vm_block *caulk::mach::vm_block::vm_block(caulk::mach::vm_block *this, size_t a2)
{
  *(_QWORD *)this = (a2 + *MEMORY[0x24BDB03C8] - 1) & -*MEMORY[0x24BDB03C8];
  *((_QWORD *)this + 1) = caulk::mach::vm_block::alloc(a2, 0);
  return this;
}

{
  *(_QWORD *)this = (a2 + *MEMORY[0x24BDB03C8] - 1) & -*MEMORY[0x24BDB03C8];
  *((_QWORD *)this + 1) = caulk::mach::vm_block::alloc(a2, 0);
  return this;
}

caulk::mach::vm_block *caulk::mach::vm_block::vm_block(caulk::mach::vm_block *this, size_t a2, int a3)
{
  *(_QWORD *)this = (a2 + *MEMORY[0x24BDB03C8] - 1) & -*MEMORY[0x24BDB03C8];
  *((_QWORD *)this + 1) = caulk::mach::vm_block::alloc(a2, a3);
  return this;
}

{
  *(_QWORD *)this = (a2 + *MEMORY[0x24BDB03C8] - 1) & -*MEMORY[0x24BDB03C8];
  *((_QWORD *)this + 1) = caulk::mach::vm_block::alloc(a2, a3);
  return this;
}

_QWORD *caulk::mach::vm_block::vm_block(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *a2;
  v3 = a2[1];
  *a2 = 0;
  a2[1] = 0;
  *result = v2;
  result[1] = v3;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;

  v2 = *a2;
  v3 = a2[1];
  *a2 = 0;
  a2[1] = 0;
  *result = v2;
  result[1] = v3;
  return result;
}

uint64_t *caulk::mach::vm_block::operator=(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  *result = *a2;
  result[1] = v4;
  *a2 = v3;
  a2[1] = v2;
  return result;
}

void caulk::mach::vm_block::destroy(caulk::mach::vm_block *this)
{
  caulk::mach::vm_block *v2;

  v2 = (caulk::mach::vm_block *)*((_QWORD *)this + 1);
  if (v2)
  {
    caulk::mach::vm_block::dealloc(v2, *(_QWORD *)this);
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
  }
}

void caulk::mach::vm_block::~vm_block(caulk::mach::vm_block *this)
{
  caulk::mach::vm_block *v2;

  v2 = (caulk::mach::vm_block *)*((_QWORD *)this + 1);
  if (v2)
  {
    caulk::mach::vm_block::dealloc(v2, *(_QWORD *)this);
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
  }
}

double caulk::mach::vm_scanner::vm_scanner(caulk::mach::vm_scanner *this, uint64_t a2)
{
  double result;

  *(_QWORD *)this = a2;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_DWORD *)this + 14) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = a2;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_DWORD *)this + 14) = 0;
  return result;
}

_QWORD *caulk::mach::vm_scanner::next_region(caulk::mach::vm_scanner *this)
{
  _QWORD *v2;
  _QWORD *v3;
  kern_return_t v4;
  mach_port_t object_name;
  mach_msg_type_number_t infoCnt;

  *((_QWORD *)this + 1) = *(_QWORD *)this;
  v2 = (_QWORD *)((char *)this + 8);
  *((_QWORD *)this + 2) = 0;
  v3 = (_QWORD *)((char *)this + 16);
  object_name = 0;
  infoCnt = 9;
  v4 = vm_region_64(*MEMORY[0x24BDAEC58], (vm_address_t *)this + 1, (vm_size_t *)this + 2, 13, (vm_region_info_t)this + 6, &infoCnt, &object_name);
  *(_QWORD *)this = *v3 + *v2;
  if (v4)
    return 0;
  else
    return v2;
}

caulk::mach *caulk::mach::find_unused_vm_address_range(caulk::mach *this, uint64_t a2)
{
  caulk::mach *v3;
  unint64_t *region;
  unint64_t v5;
  caulk::mach *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  int v11;

  v3 = this;
  v7 = this;
  v8 = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = 0;
  while (1)
  {
    region = caulk::mach::vm_scanner::next_region((caulk::mach::vm_scanner *)&v7);
    if (!region)
      break;
    v5 = *region;
    if (v3)
    {
      if (v5 >= (unint64_t)v3 + a2)
        break;
    }
    v3 = (caulk::mach *)(region[1] + v5);
  }
  return v3;
}

char *caulk::concurrent::messenger::shared_logging_priority(caulk::concurrent::messenger *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    caulk::concurrent::messenger::shared_logging_priority(void)::global = 0;
    byte_253CFF898 = 0;
    qword_253CFF8A0 = 21;
    dword_253CFF8B0 = 0;
    byte_253CFF8B4 = 1;
    byte_253CFF8B8 = 0;
    byte_253CFF8BC = 0;
  }
  return &caulk::concurrent::messenger::shared_logging_priority(void)::global;
}

uint64_t std::shared_ptr<caulk::concurrent::details::messenger_servicer>::operator=[abi:ne180100](uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

void std::vector<std::weak_ptr<caulk::lifetime_observed<std::unique_ptr<caulk::concurrent::details::service_thread>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::observer>>>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x24BEDB748], MEMORY[0x24BEDABB8]);
}

void std::__shared_ptr_emplace<caulk::lifetime_observed<std::unique_ptr<caulk::concurrent::details::service_thread>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::observer>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2E578;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<caulk::lifetime_observed<std::unique_ptr<caulk::concurrent::details::service_thread>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::observer>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2E578;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BCF9C08);
}

void std::__shared_ptr_emplace<caulk::lifetime_observed<std::unique_ptr<caulk::concurrent::details::service_thread>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::observer>>::__on_zero_shared(_QWORD *a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;

  v2 = a1[6];
  if (os_unfair_lock_trylock((os_unfair_lock_t)v2))
  {
    v3 = std::remove_if[abi:ne180100]<std::__wrap_iter<std::weak_ptr<caulk::lifetime_observed<std::unique_ptr<caulk::concurrent::details::service_thread>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::observer>> *>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::remove_expired(void)::{lambda(std::__wrap_iter<std::weak_ptr<caulk::lifetime_observed<std::unique_ptr<caulk::concurrent::details::service_thread>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::observer>> *> const&)#1}>(*(uint64_t **)(v2 + 8), *(uint64_t **)(v2 + 16));
    std::vector<std::weak_ptr<caulk::lifetime_observed<std::unique_ptr<caulk::concurrent::details::service_thread>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::observer>>>::erase(v2 + 8, (uint64_t)v3, *(_QWORD *)(v2 + 16));
    os_unfair_lock_unlock((os_unfair_lock_t)v2);
  }
  v4 = a1[5];
  a1[5] = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = (std::__shared_weak_count *)a1[4];
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

uint64_t *std::remove_if[abi:ne180100]<std::__wrap_iter<std::weak_ptr<caulk::lifetime_observed<std::unique_ptr<caulk::concurrent::details::service_thread>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::observer>> *>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::remove_expired(void)::{lambda(std::__wrap_iter<std::weak_ptr<caulk::lifetime_observed<std::unique_ptr<caulk::concurrent::details::service_thread>,caulk::shared_instance_manager<caulk::concurrent::details::service_thread>::observer>> *> const&)#1}>(uint64_t *a1, uint64_t *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t *i;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  if (a1 == a2)
    return a2;
  v3 = a1;
  while (1)
  {
    v4 = v3[1];
    if (!v4 || *(_QWORD *)(v4 + 8) == -1)
      break;
    v3 += 2;
    if (v3 == a2)
      return a2;
  }
  if (v3 != a2)
  {
    for (i = v3 + 2; i != a2; i += 2)
    {
      v7 = i[1];
      if (v7 && *(_QWORD *)(v7 + 8) != -1)
      {
        v8 = *i;
        *i = 0;
        i[1] = 0;
        v9 = (std::__shared_weak_count *)v3[1];
        *v3 = v8;
        v3[1] = v7;
        if (v9)
          std::__shared_weak_count::__release_weak(v9);
        v3 += 2;
      }
    }
  }
  return v3;
}

std::string *std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100](std::string *this, __int128 *a2)
{
  __int128 v3;

  this->__r_.__value_.__s.__data_[0] = 0;
  this[1].__r_.__value_.__s.__data_[0] = 0;
  if (*((_BYTE *)a2 + 24))
  {
    if (*((char *)a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
    }
    else
    {
      v3 = *a2;
      this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
      *(_OWORD *)&this->__r_.__value_.__l.__data_ = v3;
    }
    this[1].__r_.__value_.__s.__data_[0] = 1;
  }
  return this;
}

void sub_2065D70E8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void caulk::concurrent::details::worker_thread::~worker_thread(caulk::concurrent::details::worker_thread *this)
{
  *(_QWORD *)this = off_24BF2DEE8;
  caulk::semaphore::~semaphore((caulk::concurrent::details::worker_thread *)((char *)this + 32));
  if (*((_BYTE *)this + 24))
  {
    if (*((_QWORD *)this + 1))
      std::terminate();
  }
}

uint64_t std::default_delete<std::tuple<caulk::thread::attributes,void (caulk::concurrent::details::worker_thread::*)(void),std::tuple<caulk::concurrent::details::worker_thread*>>>::operator()[abi:ne180100](uint64_t result)
{
  if (result)
  {
    if (*(_BYTE *)(result + 24))
    {
      if (*(char *)(result + 23) < 0)
        operator delete(*(void **)result);
    }
    JUMPOUT(0x20BCF9C08);
  }
  return result;
}

void caulk::concurrent::details::service_thread::~service_thread(caulk::concurrent::details::service_thread *this)
{
  caulk::concurrent::details::service_thread::~service_thread(this);
  JUMPOUT(0x20BCF9C08);
}

{
  unsigned __int8 v2;
  unsigned int *v3;
  unsigned int v4;

  *(_QWORD *)this = &off_24BF2DF10;
  *((_QWORD *)this + 7) = &unk_24BF2DF48;
  caulk::concurrent::details::messenger_servicer::drain((caulk::concurrent::details::service_thread *)((char *)this + 56));
  v2 = atomic_load((unsigned __int8 *)this + 48);
  if ((v2 & 1) == 0)
  {
    atomic_store(1u, (unsigned __int8 *)this + 49);
    v3 = (unsigned int *)((char *)this + 40);
    do
      v4 = __ldxr(v3);
    while (__stlxr(v4 + 1, v3));
    if ((v4 & 0x80000000) != 0)
      MEMORY[0x20BCFA1F0](*((unsigned int *)this + 8));
  }
  if (*((_BYTE *)this + 24) && *((_QWORD *)this + 1))
    caulk::thread::join((pthread_t *)this + 1);
  if (*((_BYTE *)this + 160) && *((char *)this + 159) < 0)
    operator delete(*((void **)this + 17));
  caulk::concurrent::details::worker_thread::~worker_thread(this);
}

uint64_t caulk::concurrent::details::service_thread::messenger_signal_wakeup(uint64_t this)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(this + 40);
  do
    v2 = __ldxr(v1);
  while (__stlxr(v2 + 1, v1));
  if ((v2 & 0x80000000) != 0)
    JUMPOUT(0x20BCFA1F0);
  return this;
}

uint64_t caulk::concurrent::details::service_thread::messenger_is_terminating_with_error(caulk::concurrent::details::service_thread *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)this + 48);
  return v1 & 1;
}

void `non-virtual thunk to'caulk::concurrent::details::service_thread::~service_thread(caulk::concurrent::details::service_thread *this)
{
  caulk::concurrent::details::service_thread::~service_thread((caulk::concurrent::details::service_thread *)((char *)this - 56));
}

{
  caulk::concurrent::details::service_thread::~service_thread((caulk::concurrent::details::service_thread *)((char *)this - 56));
  JUMPOUT(0x20BCF9C08);
}

void caulk::concurrent::details::rt_message_call<caulk::concurrent::details::messenger_servicer::drain(void)::{lambda(void)#1} &&>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);
  JUMPOUT(0x20BCF9C08);
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<0ul,0ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,caulk::mach::thread::priority_qos,caulk::mach::priority_realtime,caulk::mach::priority_absolute> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,caulk::mach::thread::priority_qos,caulk::mach::priority_realtime,caulk::mach::priority_absolute> const>(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  return *a2 == *a3 && a2[1] == a3[1];
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<1ul,1ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,caulk::mach::thread::priority_qos,caulk::mach::priority_realtime,caulk::mach::priority_absolute> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,caulk::mach::thread::priority_qos,caulk::mach::priority_realtime,caulk::mach::priority_absolute> const>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a2 == *a3 && a2[1] == a3[1];
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<2ul,2ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,caulk::mach::thread::priority_qos,caulk::mach::priority_realtime,caulk::mach::priority_absolute> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,caulk::mach::thread::priority_qos,caulk::mach::priority_realtime,caulk::mach::priority_absolute> const>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(_DWORD *)a2 == *(_DWORD *)a3 && *(unsigned __int8 *)(a2 + 4) == *(unsigned __int8 *)(a3 + 4);
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<0ul,0ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::not_equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,caulk::mach::thread::priority_qos,caulk::mach::priority_realtime,caulk::mach::priority_absolute> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,caulk::mach::thread::priority_qos,caulk::mach::priority_realtime,caulk::mach::priority_absolute> const>(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  return *a2 != *a3 || a2[1] != a3[1];
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<1ul,1ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::not_equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,caulk::mach::thread::priority_qos,caulk::mach::priority_realtime,caulk::mach::priority_absolute> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,caulk::mach::thread::priority_qos,caulk::mach::priority_realtime,caulk::mach::priority_absolute> const>(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  return *a2 != *a3 || a2[1] != a3[1] || a2[2] != a3[2] || a2[3] != a3[3];
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<2ul,2ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::not_equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,caulk::mach::thread::priority_qos,caulk::mach::priority_realtime,caulk::mach::priority_absolute> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,caulk::mach::thread::priority_qos,caulk::mach::priority_realtime,caulk::mach::priority_absolute> const>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(_DWORD *)a2 != *(_DWORD *)a3 || *(unsigned __int8 *)(a2 + 4) != *(unsigned __int8 *)(a3 + 4);
}

void std::__shared_ptr_emplace<caulk::concurrent::details::service_thread>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2E508;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<caulk::concurrent::details::service_thread>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2E508;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BCF9C08);
}

uint64_t std::__shared_ptr_emplace<caulk::concurrent::details::service_thread>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *caulk::concurrent::messenger::messenger(_QWORD *a1, dispatch_object_t *a2)
{
  char *v4;
  unint64_t *v5;
  dispatch_object_t v6;
  mach_port_name_t *v7;
  ipc_space_t *v8;
  const char *v9;
  const char *inserted;
  NSObject *v11;
  NSObject *v12;
  unint64_t v13;
  caulk::alloc *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v21;
  __int128 handler;
  uint64_t (*v23)(uint64_t);
  void *v24;
  char *v25;

  *a1 = 0;
  a1[1] = 0;
  v4 = (char *)operator new(0x88uLL);
  *((_QWORD *)v4 + 1) = 0;
  v5 = (unint64_t *)(v4 + 8);
  *((_QWORD *)v4 + 2) = 0;
  *(_QWORD *)v4 = &off_24BF2E540;
  v6 = *a2;
  if (*a2)
    dispatch_retain(*a2);
  *((_DWORD *)v4 + 28) = 0;
  v7 = (mach_port_name_t *)(v4 + 112);
  *((_QWORD *)v4 + 3) = &off_24BF2DFA0;
  *((_QWORD *)v4 + 4) = 0;
  *((_QWORD *)v4 + 12) = 0;
  *((_QWORD *)v4 + 13) = v6;
  *((_QWORD *)v4 + 15) = 0;
  v4[128] = 0;
  v8 = (ipc_space_t *)MEMORY[0x24BDAEC58];
  v9 = (const char *)mach_port_allocate(*MEMORY[0x24BDAEC58], 1u, (mach_port_name_t *)v4 + 28);
  caulk::mach::throw_if_mach_error((uint64_t)"mach_port_allocate failed", v9);
  inserted = (const char *)mach_port_insert_right(*v8, *v7, *v7, 0x14u);
  if ((_DWORD)inserted)
  {
    mach_port_mod_refs(*v8, *v7, 1u, -1);
    *v7 = 0;
    caulk::mach::throw_if_mach_error((uint64_t)"mach_port_insert_right failed", inserted);
  }
  v11 = dispatch_source_create(MEMORY[0x24BDAC9E0], *((unsigned int *)v4 + 28), 0, *((dispatch_queue_t *)v4 + 13));
  v12 = *((_QWORD *)v4 + 15);
  *((_QWORD *)v4 + 15) = v11;
  if (v12)
  {
    dispatch_release(v12);
    v11 = *((_QWORD *)v4 + 15);
  }
  *(_QWORD *)&handler = MEMORY[0x24BDAC760];
  *((_QWORD *)&handler + 1) = 0x40000000;
  v23 = ___ZN5caulk10concurrent7details17dispatch_receiverC2EN10applesauce8dispatch2v15queueE_block_invoke;
  v24 = &__block_descriptor_tmp_147;
  v25 = v4 + 24;
  dispatch_source_set_event_handler(v11, &handler);
  dispatch_resume(*((dispatch_object_t *)v4 + 15));
  v21 = (std::__shared_weak_count *)v4;
  *(_QWORD *)&handler = v4 + 24;
  *((_QWORD *)&handler + 1) = v4;
  do
    v13 = __ldxr(v5);
  while (__stxr(v13 + 1, v5));
  v14 = (caulk::alloc *)std::shared_ptr<caulk::concurrent::details::messenger_servicer>::operator=[abi:ne180100]((uint64_t)a1, &handler);
  v15 = (std::__shared_weak_count *)*((_QWORD *)&handler + 1);
  if (*((_QWORD *)&handler + 1))
  {
    v16 = (unint64_t *)(*((_QWORD *)&handler + 1) + 8);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  caulk::alloc::init_realtime_safe_resource(v14);
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  return a1;
}

void sub_2065D7630(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

uint64_t ___ZN5caulk10concurrent7details17dispatch_receiverC2EN10applesauce8dispatch2v15queueE_block_invoke(uint64_t a1)
{
  uint64_t v1;
  mach_port_t v2;
  uint64_t result;
  mach_msg_header_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_DWORD *)(v1 + 88);
  v4.msgh_bits = 0;
  v4.msgh_remote_port = 0;
  v4.msgh_local_port = v2;
  *(_QWORD *)&v4.msgh_voucher_port = 0;
  mach_msg(&v4, 2, 0, 0x28u, v2, 0, 0);
  atomic_store(0, (unsigned __int8 *)(v1 + 104));
  do
    result = caulk::concurrent::details::messenger_servicer::check_dequeue((caulk::concurrent::details::messenger_servicer *)v1);
  while ((result & 1) != 0);
  return result;
}

void caulk::concurrent::details::dispatch_receiver::~dispatch_receiver(caulk::concurrent::details::dispatch_receiver *this)
{
  caulk::concurrent::details::dispatch_receiver::~dispatch_receiver(this);
  JUMPOUT(0x20BCF9C08);
}

{
  ipc_space_t *v2;
  NSObject *v3;
  NSObject *v4;

  *(_QWORD *)this = &off_24BF2DFA0;
  dispatch_source_cancel(*((dispatch_source_t *)this + 12));
  dispatch_sync(*((dispatch_queue_t *)this + 10), &__block_literal_global);
  v2 = (ipc_space_t *)MEMORY[0x24BDAEC58];
  mach_port_mod_refs(*MEMORY[0x24BDAEC58], *((_DWORD *)this + 22), 1u, -1);
  mach_port_deallocate(*v2, *((_DWORD *)this + 22));
  v3 = *((_QWORD *)this + 12);
  if (v3)
    dispatch_release(v3);
  v4 = *((_QWORD *)this + 10);
  if (v4)
    dispatch_release(v4);
}

uint64_t caulk::concurrent::details::dispatch_receiver::messenger_signal_wakeup(uint64_t this)
{
  unsigned __int8 *v1;
  unsigned __int8 v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  v1 = (unsigned __int8 *)(this + 104);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(1u, v1));
  if ((v2 & 1) == 0)
  {
    v3 = 0x1C00000013;
    v4 = *(_DWORD *)(this + 88);
    v6 = 0;
    v5 = 0;
    return mach_msg((mach_msg_header_t *)&v3, 1, 0x1Cu, 0, 0, 0, 0);
  }
  return this;
}

uint64_t caulk::concurrent::details::dispatch_receiver::messenger_is_terminating_with_error(caulk::concurrent::details::dispatch_receiver *this)
{
  return 0;
}

void std::__shared_ptr_emplace<caulk::concurrent::details::dispatch_receiver>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2E540;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<caulk::concurrent::details::dispatch_receiver>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2E540;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BCF9C08);
}

uint64_t std::__shared_ptr_emplace<caulk::concurrent::details::dispatch_receiver>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void caulk::concurrent::messenger::~messenger(caulk::concurrent::details::messenger_servicer **this)
{
  caulk::concurrent::details::messenger_servicer::drain(*this);
  std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100]((uint64_t)this);
}

void caulk::ipc::synchronous_messenger::semaphore_sender::create_connection_info(caulk::ipc::synchronous_messenger::semaphore_sender *this@<X0>, _QWORD *a2@<X8>)
{
  xpc_object_t v4;
  caulk::mach::details *v5;
  caulk::mach::details *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  std::runtime_error *exception;
  std::runtime_error *v12;
  std::runtime_error *v13;
  std::runtime_error *v14;
  std::runtime_error *v15;
  xpc_object_t v16;
  xpc_object_t value;

  v4 = xpc_dictionary_create(0, 0, 0);
  *a2 = v4;
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "failed to allocate dictionary");
    __cxa_throw(exception, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  caulk::ipc::mapped_memory::create_xpc_object(this, &value);
  v5 = (caulk::mach::details *)value;
  if (!value)
  {
    v12 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v12, "failed to create payload object");
    __cxa_throw(v12, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  xpc_dictionary_set_value(v4, "payload", value);
  caulk::ipc::mapped_memory::create_xpc_object((caulk::ipc::synchronous_messenger::semaphore_sender *)((char *)this + 24), &v16);
  v6 = (caulk::mach::details *)v16;
  if (!v16)
  {
    v13 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v13, "failed to create control object");
    __cxa_throw(v13, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  xpc_dictionary_set_value(v4, "control", v16);
  v7 = (void *)xpc_mach_send_create();
  if (!v7)
  {
    v14 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v14, "failed to create send semaphore object");
    __cxa_throw(v14, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  xpc_dictionary_set_value(v4, "send semaphore", v7);
  v8 = (void *)xpc_mach_send_create();
  if (!v8)
  {
    v15 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v15, "failed to create receive semaphore object");
    __cxa_throw(v15, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  xpc_dictionary_set_value(v4, "receive semaphore", v8);
  os_release(v8);
  os_release(v7);
  caulk::mach::details::release_os_object(v6, v9);
  caulk::mach::details::release_os_object(v5, v10);
}

void sub_2065D7ACC(_Unwind_Exception *a1)
{
  caulk::mach::details *v1;
  caulk::mach::details *v2;
  caulk::mach::details *v3;
  caulk::mach::details *v4;
  void *v5;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  __cxa_free_exception(v5);
  caulk::mach::details::release_os_object(v4, v7);
  caulk::mach::details::release_os_object(v3, v8);
  caulk::mach::details::release_os_object(v2, v9);
  caulk::mach::details::release_os_object(v1, v10);
  _Unwind_Resume(a1);
}

void sub_2065D7B70()
{
  JUMPOUT(0x2065D7B58);
}

uint64_t caulk::ipc::synchronous_messenger::semaphore_sender::start(semaphore_t *this, double a2)
{
  unsigned int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v10;
  uint64_t v11;
  int v12;

  if (!caulk::ipc::synchronous_messenger::semaphore_sender::is_valid((caulk::ipc::synchronous_messenger::semaphore_sender *)this)
    || *((_BYTE *)this + 64)
    || (v4 = (unsigned int *)caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>((_QWORD *)this + 3),
        v5 = *v4,
        (_DWORD)v5))
  {
    v6 = 0;
    v7 = 0;
    v8 = 22;
  }
  else
  {
    v10 = v4;
    while (1)
    {
      v11 = caulk::mach::semaphore::timed_wait_or_error(this + 12, a2, v5);
      v12 = v11;
      if ((v11 & 0x100000000) == 0)
      {
        v6 = 0;
        v7 = v11 & 0xFFFFFF00;
        v8 = v11;
        return v7 | v8 | v6;
      }
      if (!(_BYTE)v11)
        break;
      v5 = v10[1];
      if ((_DWORD)v5 == 1)
      {
        v8 = 1;
        *v10 = 1;
        MEMORY[0x20BCFA1F0](this[14]);
        v7 = v12 & 0xFFFFFF00;
        *((_BYTE *)this + 64) = 1;
        v6 = 0x100000000;
        return v7 | v8 | v6;
      }
    }
    v8 = 0;
    v6 = v11 & 0x100000000;
    v7 = v11 & 0xFFFFFF00;
  }
  return v7 | v8 | v6;
}

BOOL caulk::ipc::synchronous_messenger::semaphore_sender::is_valid(caulk::ipc::synchronous_messenger::semaphore_sender *this)
{
  return *(_QWORD *)this
      && *((_QWORD *)this + 1)
      && *((_QWORD *)this + 3)
      && *((_QWORD *)this + 4)
      && *((_DWORD *)this + 12)
      && *((_DWORD *)this + 14) != 0;
}

uint64_t caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>(_QWORD *a1)
{
  uint64_t result;

  if (a1[1] > 7uLL)
    return *a1;
  _os_assert_log();
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t caulk::ipc::synchronous_messenger::semaphore_sender::send(semaphore_t *this, double a2)
{
  _DWORD *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!caulk::ipc::synchronous_messenger::semaphore_sender::is_valid((caulk::ipc::synchronous_messenger::semaphore_sender *)this)
    || !*((_BYTE *)this + 64))
  {
    goto LABEL_8;
  }
  v4 = (_DWORD *)caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>((_QWORD *)this + 3);
  if (*v4 != 1 || (v5 = v4[1], !(_DWORD)v5))
  {
    caulk::ipc::synchronous_messenger::semaphore_sender::reset_messaging((caulk::ipc::synchronous_messenger::semaphore_sender *)this, a2);
LABEL_8:
    v8 = 0;
    v9 = 0;
    LOBYTE(v7) = 22;
    return v8 | v9 | v7;
  }
  v6 = caulk::mach::semaphore::timed_wait_signal_or_error(this + 12, this + 14, a2, v5);
  v7 = v6;
  if (HIDWORD(v6))
  {
    v8 = 0x100000000;
    if ((_BYTE)v6)
      LOBYTE(v7) = 1;
    else
      v8 = v6 & 0x100000000;
    if ((_BYTE)v6)
      v9 = 0;
    else
      v9 = v6 & 0xFFFFFF00;
  }
  else
  {
    caulk::ipc::synchronous_messenger::semaphore_sender::reset_messaging((caulk::ipc::synchronous_messenger::semaphore_sender *)this, a2);
    v8 = v7 & 0x100000000;
    v9 = v7 & 0xFFFFFF00;
  }
  return v8 | v9 | v7;
}

void caulk::ipc::synchronous_messenger::semaphore_sender::reset_messaging(caulk::ipc::synchronous_messenger::semaphore_sender *this, double a2)
{
  _DWORD *v4;
  uint64_t v5;
  unint64_t v6;
  void *__p;
  char v8;

  v4 = (_DWORD *)caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>((_QWORD *)this + 3);
  *v4 = 0;
  MEMORY[0x20BCFA1F0](*((unsigned int *)this + 14));
  do
  {
    v6 = caulk::mach::semaphore::timed_wait_or_error((semaphore_t *)this + 12, a2, v5);
    if (!HIDWORD(v6))
      break;
    if (!(_BYTE)v6)
      break;
    v5 = v4[1];
  }
  while ((_DWORD)v5);
  *((_BYTE *)this + 64) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "semaphore_sender::reset_messaging: wait out the sender semaphore to clear things out for next time S-1");
  caulk::ipc::synchronous_messenger::details::drain_semaphore((semaphore_t *)this + 12);
  if (v8 < 0)
    operator delete(__p);
}

unint64_t caulk::ipc::synchronous_messenger::details::drain_semaphore(semaphore_t *this)
{
  char v2;
  void *v3;
  unint64_t result;
  BOOL v5;

  v2 = 0;
  v3 = &unk_2065DE000;
  do
  {
    result = caulk::mach::semaphore::timed_wait_or_error(this, 0.000001, (uint64_t)v3);
    v3 = (void *)HIDWORD(result);
    if (HIDWORD(result))
      v5 = v2 == 0;
    else
      v5 = 1;
    if (v5)
    {
      if (!v3)
        break;
      if (!v2)
        v2 = BYTE4(result);
      if (!v2)
        break;
    }
  }
  while ((_BYTE)result);
  return result;
}

uint64_t caulk::ipc::synchronous_messenger::semaphore_sender::resynch(caulk::ipc::synchronous_messenger::semaphore_sender *this)
{
  _DWORD *v2;
  unsigned int *v3;
  int v4;
  unsigned __int8 v5;
  uint64_t v6;
  uint64_t v7;
  void *__p;
  char v10;

  if (caulk::ipc::synchronous_messenger::semaphore_sender::is_valid(this) && *((_BYTE *)this + 64))
  {
    v2 = (_DWORD *)caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>((_QWORD *)this + 3);
    *v2 = 2;
    MEMORY[0x20BCFA1F0](*((unsigned int *)this + 14));
    v3 = (unsigned int *)((char *)this + 48);
    while (1)
    {
      do
        v4 = MEMORY[0x20BCFA220](*v3);
      while (v4 == 14);
      if (v4)
        break;
      if (v2[1] == 2)
      {
        *v2 = 1;
        MEMORY[0x20BCFA1F0](*((unsigned int *)this + 14));
        while (1)
        {
          do
            v4 = MEMORY[0x20BCFA220](*v3);
          while (v4 == 14);
          if (v4)
            break;
          if (v2[1] == 1)
          {
            std::string::basic_string[abi:ne180100]<0>(&__p, "semaphore_sender::resynch: wait out the sender semaphore to clear things out for next time S-1");
            caulk::ipc::synchronous_messenger::details::drain_semaphore((semaphore_t *)this + 12);
            if (v10 < 0)
              operator delete(__p);
            v5 = 0;
            v6 = 0;
            v7 = 0x100000000;
            return v6 | v7 | v5;
          }
        }
        break;
      }
    }
    v7 = 0;
    v5 = v4;
    v6 = v4 & 0xFFFFFF00;
  }
  else
  {
    v7 = 0;
    v6 = 0;
    v5 = 22;
  }
  return v6 | v7 | v5;
}

uint64_t caulk::ipc::synchronous_messenger::semaphore_sender::resynch(caulk::ipc::synchronous_messenger::semaphore_sender *this, double a2)
{
  _DWORD *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  void *__p;
  char v14;

  if (caulk::ipc::synchronous_messenger::semaphore_sender::is_valid(this) && *((_BYTE *)this + 64))
  {
    v4 = (_DWORD *)caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>((_QWORD *)this + 3);
    *v4 = 2;
    MEMORY[0x20BCFA1F0](*((unsigned int *)this + 14));
    while (1)
    {
      v6 = caulk::mach::semaphore::timed_wait_or_error((semaphore_t *)this + 12, a2, v5);
      v7 = v6;
      v8 = HIDWORD(v6);
      if (!HIDWORD(v6))
        goto LABEL_16;
      if (!(_BYTE)v6)
        break;
      v5 = v4[1];
      if ((_DWORD)v5 == 2)
      {
        *v4 = 1;
        MEMORY[0x20BCFA1F0](*((unsigned int *)this + 14));
        while (1)
        {
          v10 = caulk::mach::semaphore::timed_wait_or_error((semaphore_t *)this + 12, a2, v9);
          v7 = v10;
          v8 = HIDWORD(v10);
          if (!HIDWORD(v10))
            break;
          if (!(_BYTE)v10)
            goto LABEL_17;
          v9 = v4[1];
          if ((_DWORD)v9 == 1)
          {
            std::string::basic_string[abi:ne180100]<0>(&__p, "semaphore_sender::resynch: wait out the sender semaphore to clear things out for next time S-1");
            caulk::ipc::synchronous_messenger::details::drain_semaphore((semaphore_t *)this + 12);
            v11 = v7 & 0xFFFFFF00;
            if (v14 < 0)
              operator delete(__p);
            v8 = 0x100000000;
            LOBYTE(v7) = 1;
            return v11 | v8 | v7;
          }
        }
LABEL_16:
        v11 = v7 & 0xFFFFFF00;
        return v11 | v8 | v7;
      }
    }
LABEL_17:
    v11 = v7 & 0xFFFFFF00;
    v8 = v7 & 0x100000000;
    LOBYTE(v7) = 0;
  }
  else
  {
    v8 = 0;
    v11 = 0;
    LOBYTE(v7) = 22;
  }
  return v11 | v8 | v7;
}

void caulk::ipc::synchronous_messenger::semaphore_sender::stop(caulk::ipc::synchronous_messenger::semaphore_sender *this, double a2)
{
  if (caulk::ipc::synchronous_messenger::semaphore_sender::is_valid(this))
  {
    if (*((_BYTE *)this + 64))
      caulk::ipc::synchronous_messenger::semaphore_sender::reset_messaging(this, a2);
  }
}

void caulk::ipc::synchronous_messenger::semaphore_receiver::ingest_connection_info(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t value;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  xpc_object_t v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  xpc_object_t v16;
  void *v17;
  void *v18;
  xpc_object_t v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  std::runtime_error *exception;
  std::runtime_error *v25;
  std::runtime_error *v26;
  std::runtime_error *v27;
  std::runtime_error *v28;
  int v29;
  void *v30;
  xpc_object_t v31;
  void *v32;
  uint64_t v33;
  char v34;
  xpc_object_t v35;

  if (!*a2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "no connection info");
    goto LABEL_10;
  }
  if (MEMORY[0x20BCFA2BC]() != MEMORY[0x24BDACFA0])
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "no dictionary");
LABEL_10:
    __cxa_throw(exception, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  value = xpc_dictionary_get_value(*a2, "payload");
  v6 = caulk::mach::details::retain_os_object(value, v5);
  v35 = v6;
  if (!v6)
  {
    v25 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v25, "no payload");
    __cxa_throw(v25, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  caulk::ipc::mapped_memory::mapped_memory((uint64_t)&v32, &v35);
  v7 = *(void **)(a1 + 16);
  v8 = *(_QWORD *)(a1 + 24);
  v9 = v33;
  *(_QWORD *)(a1 + 16) = v32;
  *(_QWORD *)(a1 + 24) = v9;
  v32 = v7;
  v33 = v8;
  LOBYTE(v7) = *(_BYTE *)(a1 + 32);
  *(_BYTE *)(a1 + 32) = v34;
  v34 = (char)v7;
  caulk::ipc::mapped_memory::reset((caulk::ipc::mapped_memory *)&v32);
  v10 = xpc_dictionary_get_value(*a2, "control");
  v12 = caulk::mach::details::retain_os_object(v10, v11);
  v31 = v12;
  if (!v12)
  {
    v26 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v26, "no control");
    __cxa_throw(v26, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  caulk::ipc::mapped_memory::mapped_memory((uint64_t)&v32, &v31);
  v13 = *(void **)(a1 + 40);
  v14 = *(_QWORD *)(a1 + 48);
  v15 = v33;
  *(_QWORD *)(a1 + 40) = v32;
  *(_QWORD *)(a1 + 48) = v15;
  v32 = v13;
  v33 = v14;
  LOBYTE(v13) = *(_BYTE *)(a1 + 56);
  *(_BYTE *)(a1 + 56) = v34;
  v34 = (char)v13;
  caulk::ipc::mapped_memory::reset((caulk::ipc::mapped_memory *)&v32);
  v16 = xpc_dictionary_get_value(*a2, "send semaphore");
  v18 = caulk::mach::details::retain_os_object(v16, v17);
  v32 = v18;
  if (!v18)
  {
    v27 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v27, "no send semaphore");
    __cxa_throw(v27, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  caulk::ipc::synchronous_messenger::details::make_semaphore((uint64_t)&v30, &v32);
  caulk::mach::semaphore::operator=(a1 + 64, (int *)&v30);
  caulk::mach::semaphore::~semaphore((semaphore_t *)&v30);
  v19 = xpc_dictionary_get_value(*a2, "receive semaphore");
  v21 = caulk::mach::details::retain_os_object(v19, v20);
  v30 = v21;
  if (!v21)
  {
    v28 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v28, "no receive semaphore");
    __cxa_throw(v28, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  caulk::ipc::synchronous_messenger::details::make_semaphore((uint64_t)&v29, &v30);
  caulk::mach::semaphore::operator=(a1 + 72, &v29);
  caulk::mach::semaphore::~semaphore((semaphore_t *)&v29);
  os_release(v21);
  os_release(v18);
  caulk::mach::details::release_os_object((caulk::mach::details *)v12, v22);
  caulk::mach::details::release_os_object((caulk::mach::details *)v6, v23);
}

void sub_2065D8418(_Unwind_Exception *a1, void *a2)
{
  caulk::mach::details *v2;
  caulk::mach::details *v3;
  caulk::mach::details *v4;
  caulk::mach::details *v5;
  void *v7;
  void *v8;
  void *v9;

  caulk::mach::details::release_os_object(v5, a2);
  caulk::mach::details::release_os_object(v4, v7);
  caulk::mach::details::release_os_object(v3, v8);
  caulk::mach::details::release_os_object(v2, v9);
  _Unwind_Resume(a1);
}

uint64_t caulk::ipc::synchronous_messenger::details::make_semaphore(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  std::runtime_error *exception;

  if (!*a2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "no object");
    goto LABEL_6;
  }
  if (MEMORY[0x20BCFA2BC]() != MEMORY[0x24BDACFD8])
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "object is not a mach send right");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  result = xpc_mach_send_copy_right();
  *(_DWORD *)a1 = result;
  *(_BYTE *)(a1 + 4) = 0;
  return result;
}

void sub_2065D856C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t caulk::ipc::synchronous_messenger::semaphore_receiver::start(caulk::ipc::synchronous_messenger::semaphore_receiver *this, double a2, const caulk::thread::attributes *a3)
{
  uint64_t v3;
  void *v4;
  void (**v6)(caulk::mach::os_workgroup_managed *__hidden);
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v6 = &off_24BF2E088;
  v7 = 0u;
  v8 = 0u;
  v9 = 0u;
  v10 = 0;
  v3 = caulk::ipc::synchronous_messenger::semaphore_receiver::start((uint64_t)this, (uint64_t)a3, (uint64_t)&v6, a2);
  caulk::mach::details::release_os_object(0, v4);
  return v3;
}

uint64_t caulk::ipc::synchronous_messenger::semaphore_receiver::start(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  void *v8;
  __int128 v9;
  uint64_t v10;
  caulk::mach::details *v11;
  char v12;
  __int128 v13;
  __int128 v14;
  void *v15;
  void *v16;
  void *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  __int128 v22;
  uint64_t v23;
  char v24;
  semaphore_t semaphore;
  std::string __p;
  char v27;
  _BYTE v28[29];
  uint64_t v29;
  __int128 v30;
  semaphore_t *v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  semaphore_t *p_semaphore;
  void (**v36)(caulk::mach::os_workgroup_managed *__hidden);
  caulk::mach::details *v37;
  __int128 v38;
  _OWORD v39[2];
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  if (caulk::ipc::synchronous_messenger::semaphore_receiver::is_valid((caulk::ipc::synchronous_messenger::semaphore_receiver *)a1))
  {
    std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100](&__p, (__int128 *)a2);
    *(_OWORD *)v28 = *(_OWORD *)(a2 + 32);
    *(_QWORD *)&v28[16] = *(_QWORD *)(a2 + 48);
    *(_DWORD *)&v28[24] = 1;
    v28[28] = 1;
    *(_WORD *)(a1 + 184) = 0;
    LODWORD(v29) = 1;
    BYTE4(v29) = 0;
    caulk::mach::semaphore::semaphore(&semaphore);
    std::shared_ptr<caulk::ipc::synchronous_messenger::semaphore_receiver>::shared_ptr[abi:ne180100]<caulk::ipc::synchronous_messenger::semaphore_receiver,void>(&v33, *(_QWORD *)a1, *(std::__shared_weak_count **)(a1 + 8));
    *(double *)&v34 = a4;
    *((_QWORD *)&v34 + 1) = &v29;
    p_semaphore = &semaphore;
    v36 = &off_24BF2E088;
    v37 = (caulk::mach::details *)caulk::mach::details::retain_os_object(*(void **)(a3 + 8), v8);
    v9 = *(_OWORD *)(a3 + 32);
    v38 = *(_OWORD *)(a3 + 16);
    v39[0] = v9;
    *(_OWORD *)((char *)v39 + 9) = *(_OWORD *)(a3 + 41);
    v23 = 0;
    v24 = 0;
    v10 = operator new();
    v22 = v33;
    v33 = 0uLL;
    v30 = v34;
    v31 = p_semaphore;
    v11 = v37;
    v37 = 0;
    v40 = v38;
    v41 = v39[0];
    v42 = *(_QWORD *)&v39[1];
    v38 = 0u;
    memset(v39, 0, 25);
    v12 = BYTE8(v39[1]);
    std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100]((std::string *)v10, (__int128 *)&__p);
    *(_OWORD *)(v10 + 32) = *(_OWORD *)v28;
    *(_OWORD *)(v10 + 45) = *(_OWORD *)&v28[13];
    v13 = v30;
    *(_OWORD *)(v10 + 64) = v22;
    *(_OWORD *)(v10 + 80) = v13;
    *(_QWORD *)(v10 + 96) = v31;
    *(_QWORD *)(v10 + 104) = &off_24BF2E088;
    *(_QWORD *)(v10 + 112) = v11;
    *(_QWORD *)(v10 + 152) = v42;
    v14 = v40;
    *(_OWORD *)(v10 + 136) = v41;
    *(_OWORD *)(v10 + 120) = v14;
    v40 = 0u;
    v41 = 0u;
    v42 = 0;
    *(_BYTE *)(v10 + 160) = v12;
    v32 = v10;
    caulk::mach::details::release_os_object(0, v15);
    caulk::thread::start((uint64_t)&v23, v10, (void *(__cdecl *)(void *))caulk::thread_proxy<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup_managed)::$_0,std::tuple<>>>, (void *)v10);
    v32 = 0;
    std::unique_ptr<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup_managed)::$_0,std::tuple<>>>::~unique_ptr[abi:ne180100](&v32, v16);
    v36 = &off_24BF2E088;
    caulk::mach::details::release_os_object(v37, v17);
    v18 = (std::__shared_weak_count *)*((_QWORD *)&v33 + 1);
    if (*((_QWORD *)&v33 + 1))
    {
      v19 = (unint64_t *)(*((_QWORD *)&v33 + 1) + 8);
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    while (MEMORY[0x20BCFA220](semaphore) == 14)
      ;
    if (v23)
      std::terminate();
    caulk::mach::semaphore::~semaphore(&semaphore);
    if (v27 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    LODWORD(v29) = 22;
    BYTE4(v29) = 0;
  }
  return v29;
}

{
  void *v8;
  uint64_t v9;
  caulk::mach::details *v10;
  __int128 v11;
  void *v12;
  void *v13;
  void *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  semaphore_t *p_semaphore;
  void (**v23)(caulk::mach::os_workgroup *__hidden);
  caulk::mach::details *v24;
  uint64_t v25;
  char v26;
  semaphore_t semaphore;
  std::string __p;
  char v29;
  _BYTE v30[29];
  uint64_t v31;
  __int128 v32;
  semaphore_t *v33;
  uint64_t v34;

  if (caulk::ipc::synchronous_messenger::semaphore_receiver::is_valid((caulk::ipc::synchronous_messenger::semaphore_receiver *)a1))
  {
    std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100](&__p, (__int128 *)a2);
    *(_OWORD *)v30 = *(_OWORD *)(a2 + 32);
    *(_QWORD *)&v30[16] = *(_QWORD *)(a2 + 48);
    *(_DWORD *)&v30[24] = 1;
    v30[28] = 1;
    *(_WORD *)(a1 + 184) = 0;
    LODWORD(v31) = 1;
    BYTE4(v31) = 0;
    caulk::mach::semaphore::semaphore(&semaphore);
    std::shared_ptr<caulk::ipc::synchronous_messenger::semaphore_receiver>::shared_ptr[abi:ne180100]<caulk::ipc::synchronous_messenger::semaphore_receiver,void>(&v20, *(_QWORD *)a1, *(std::__shared_weak_count **)(a1 + 8));
    *(double *)&v21 = a4;
    *((_QWORD *)&v21 + 1) = &v31;
    p_semaphore = &semaphore;
    v23 = &off_24BF2E020;
    v24 = (caulk::mach::details *)caulk::mach::details::retain_os_object(*(void **)(a3 + 8), v8);
    v25 = 0;
    v26 = 0;
    v9 = operator new();
    v19 = v20;
    v20 = 0uLL;
    v32 = v21;
    v33 = p_semaphore;
    v10 = v24;
    v24 = 0;
    std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100]((std::string *)v9, (__int128 *)&__p);
    *(_OWORD *)(v9 + 32) = *(_OWORD *)v30;
    *(_OWORD *)(v9 + 45) = *(_OWORD *)&v30[13];
    v11 = v32;
    *(_OWORD *)(v9 + 64) = v19;
    *(_OWORD *)(v9 + 80) = v11;
    *(_QWORD *)(v9 + 96) = v33;
    *(_QWORD *)(v9 + 104) = &off_24BF2E020;
    *(_QWORD *)(v9 + 112) = v10;
    v34 = v9;
    caulk::mach::details::release_os_object(0, v12);
    caulk::thread::start((uint64_t)&v25, v9, (void *(__cdecl *)(void *))caulk::thread_proxy<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup)::$_0,std::tuple<>>>, (void *)v9);
    v34 = 0;
    std::unique_ptr<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup)::$_0,std::tuple<>>>::~unique_ptr[abi:ne180100](&v34, v13);
    v23 = &off_24BF2E020;
    caulk::mach::details::release_os_object(v24, v14);
    v15 = (std::__shared_weak_count *)*((_QWORD *)&v20 + 1);
    if (*((_QWORD *)&v20 + 1))
    {
      v16 = (unint64_t *)(*((_QWORD *)&v20 + 1) + 8);
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    while (MEMORY[0x20BCFA220](semaphore) == 14)
      ;
    if (v25)
      std::terminate();
    caulk::mach::semaphore::~semaphore(&semaphore);
    if (v29 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    LODWORD(v31) = 22;
    BYTE4(v31) = 0;
  }
  return v31;
}

void sub_2065D88A4(_Unwind_Exception *exception_object, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if ((_DWORD)a2)
  {
    std::unique_ptr<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup_managed)::$_0,std::tuple<>>>::~unique_ptr[abi:ne180100](&a25, a2);
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL caulk::ipc::synchronous_messenger::semaphore_receiver::is_valid(caulk::ipc::synchronous_messenger::semaphore_receiver *this)
{
  return *((_QWORD *)this + 2)
      && *((_QWORD *)this + 3)
      && *((_QWORD *)this + 5)
      && *((_QWORD *)this + 6)
      && *((_DWORD *)this + 16)
      && *((_DWORD *)this + 18) != 0;
}

_QWORD *std::shared_ptr<caulk::ipc::synchronous_messenger::semaphore_receiver>::shared_ptr[abi:ne180100]<caulk::ipc::synchronous_messenger::semaphore_receiver,void>(_QWORD *a1, uint64_t a2, std::__shared_weak_count *this)
{
  std::__shared_weak_count *v4;

  *a1 = a2;
  if (!this)
  {
    a1[1] = 0;
LABEL_5:
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  v4 = std::__shared_weak_count::lock(this);
  a1[1] = v4;
  if (!v4)
    goto LABEL_5;
  return a1;
}

uint64_t caulk::thread_proxy<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup_managed)::$_0,std::tuple<>>>(uint64_t a1)
{
  uint64_t v2;
  double v3;
  char *v4;
  unsigned int *v5;
  void *v6;
  __int128 v7;
  uint64_t v8;
  int v9;
  caulk::ipc::synchronous_messenger::semaphore_receiver *v10;
  uint64_t started;
  _BOOL4 v12;
  caulk::ipc::synchronous_messenger::semaphore_receiver *v13;
  uint64_t v14;
  void *v15;
  void *v16;
  uint64_t v18;
  int v19;
  char v20;
  void (**v21)(caulk::mach::os_workgroup_managed *__hidden);
  caulk::mach::details *v22;
  __int128 v23;
  _OWORD v24[2];
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v18 = a1;
  caulk::thread::attributes::apply_to_this_thread(a1);
  v2 = *(_QWORD *)(a1 + 64);
  v3 = *(double *)(a1 + 80);
  v4 = *(char **)(a1 + 88);
  v5 = *(unsigned int **)(a1 + 96);
  v21 = &off_24BF2E088;
  v22 = (caulk::mach::details *)caulk::mach::details::retain_os_object(*(void **)(a1 + 112), v6);
  v7 = *(_OWORD *)(a1 + 136);
  v23 = *(_OWORD *)(a1 + 120);
  v24[0] = v7;
  *(_OWORD *)((char *)v24 + 9) = *(_OWORD *)(a1 + 145);
  v8 = *(_QWORD *)(v2 + 112);
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 48))(v8);
  v9 = caulk::mach::os_workgroup_managed::join((caulk::mach::os_workgroup_managed *)&v21);
  started = caulk::ipc::synchronous_messenger::semaphore_receiver::start_handshake((caulk::ipc::synchronous_messenger::semaphore_receiver *)v2, v10, v3);
  v19 = started;
  v20 = BYTE4(started);
  caulk::expected<BOOL,int>::swap((char *)&v19, v4);
  if (v4[4])
  {
    caulk::expected<BOOL,int>::value((uint64_t)v4);
    v12 = *v4 != 0;
  }
  else
  {
    v12 = 0;
  }
  MEMORY[0x20BCFA1F0](*v5);
  if (v12)
    caulk::ipc::synchronous_messenger::semaphore_receiver::message_loop(v2, v13);
  if (*(_BYTE *)(v2 + 185))
  {
    if (v9)
      goto LABEL_13;
  }
  else
  {
    caulk::ipc::synchronous_messenger::semaphore_receiver::stop_handshake((caulk::ipc::synchronous_messenger::semaphore_receiver *)v2, v13);
    if (v9)
      goto LABEL_13;
  }
  caulk::mach::os_workgroup_managed::leave((caulk::mach::os_workgroup_managed *)&v21);
LABEL_13:
  v14 = *(_QWORD *)(v2 + 176);
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 48))(v14);
  MEMORY[0x20BCFA1F0](*(unsigned int *)(v2 + 80));
  v21 = &off_24BF2E088;
  caulk::mach::details::release_os_object(v22, v15);
  std::unique_ptr<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup_managed)::$_0,std::tuple<>>>::~unique_ptr[abi:ne180100](&v18, v16);
  return 0;
}

void sub_2065D8B3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x2065D8AE4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::unique_ptr<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup_managed)::$_0,std::tuple<>>>::~unique_ptr[abi:ne180100](uint64_t *a1, void *a2)
{
  uint64_t v3;

  v3 = *a1;
  *a1 = 0;
  if (v3)
  {
    *(_QWORD *)(v3 + 104) = &off_24BF2E088;
    caulk::mach::details::release_os_object(*(caulk::mach::details **)(v3 + 112), a2);
    std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](v3 + 64);
    if (*(_BYTE *)(v3 + 24) && *(char *)(v3 + 23) < 0)
      operator delete(*(void **)v3);
    MEMORY[0x20BCF9C08](v3, 0x10B2C406107703FLL);
  }
  return a1;
}

uint64_t caulk::ipc::synchronous_messenger::semaphore_receiver::start_handshake(caulk::ipc::synchronous_messenger::semaphore_receiver *this, caulk::ipc::synchronous_messenger::semaphore_receiver *a2, double a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v10;
  uint64_t v11;
  semaphore_t *v12;
  uint64_t v13;

  if (caulk::ipc::synchronous_messenger::semaphore_receiver::is_valid(this)
    && (v5 = caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>((_QWORD *)this + 5),
        !*(_DWORD *)(v5 + 4)))
  {
    v10 = (unsigned int *)v5;
    *(_DWORD *)(v5 + 4) = 1;
    MEMORY[0x20BCFA1F0](*((unsigned int *)this + 16));
    v12 = (semaphore_t *)((char *)this + 72);
    while (1)
    {
      v13 = caulk::mach::semaphore::timed_wait_or_error(v12, a3, v11);
      if ((v13 & 0x100000000) == 0)
      {
        v6 = 0;
        v7 = v13 & 0xFFFFFF00;
        v8 = v13;
        return v7 | v8 | v6;
      }
      if (!(_BYTE)v13)
        break;
      v11 = *v10;
      if ((_DWORD)v11 == 1)
      {
        v7 = v13 & 0xFFFFFF00;
        v6 = 0x100000000;
        v8 = 1;
        return v7 | v8 | v6;
      }
    }
    v8 = 0;
    v6 = v13 & 0x100000000;
    v7 = v13 & 0xFFFFFF00;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = 22;
  }
  return v7 | v8 | v6;
}

char *caulk::expected<BOOL,int>::swap(char *result, char *a2)
{
  BOOL v2;
  int v3;
  char v4;
  char v5;
  int v6;

  if (result[4])
    v2 = a2[4] == 0;
  else
    v2 = 1;
  if (!v2)
  {
    v4 = *result;
    *result = *a2;
    *a2 = v4;
    return result;
  }
  if (result[4])
  {
    if (!a2[4])
    {
      v3 = *(_DWORD *)a2;
      *a2 = *result;
      *(_DWORD *)result = v3;
      LOBYTE(v3) = result[4];
      result[4] = 0;
      a2[4] = v3;
      return result;
    }
  }
  else if (a2[4])
  {
    v5 = *a2;
    *(_DWORD *)a2 = *(_DWORD *)result;
    *result = v5;
    result[4] = a2[4];
    a2[4] = 0;
    return result;
  }
  v6 = *(_DWORD *)result;
  *(_DWORD *)result = *(_DWORD *)a2;
  *(_DWORD *)a2 = v6;
  return result;
}

uint64_t caulk::ipc::synchronous_messenger::semaphore_receiver::message_loop(uint64_t this, caulk::ipc::synchronous_messenger::semaphore_receiver *a2)
{
  uint64_t v2;
  char v3;
  _QWORD *v4;
  semaphore_t *v5;
  uint64_t v6;
  int *v7;
  int v8;
  _DWORD *v9;
  void *__p;
  char v11;

  if (!*(_BYTE *)(this + 184))
  {
    v2 = this;
    v3 = 0;
    v4 = (_QWORD *)(this + 40);
    v5 = (semaphore_t *)(this + 72);
    v6 = this + 16;
    while (1)
    {
      v7 = (int *)caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>(v4);
      if ((v3 & 1) != 0)
      {
        do
          this = MEMORY[0x20BCFA22C](*(unsigned int *)(v2 + 72), *(unsigned int *)(v2 + 64));
        while ((_DWORD)this == 14);
      }
      else
      {
        do
          this = MEMORY[0x20BCFA220](*v5);
        while ((_DWORD)this == 14);
      }
      if ((_DWORD)this || *(_BYTE *)(v2 + 184))
        return this;
      this = *(_QWORD *)(v2 + 144);
      if (!this)
        goto LABEL_13;
      v8 = *v7;
      if (*v7 == 1)
        break;
LABEL_14:
      switch(v8)
      {
        case 1:
          v3 = 1;
          break;
        case 2:
          this = caulk::ipc::synchronous_messenger::semaphore_receiver::is_valid((caulk::ipc::synchronous_messenger::semaphore_receiver *)v2);
          if ((_DWORD)this)
          {
            v9 = (_DWORD *)caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>(v4);
            v9[1] = 2;
            MEMORY[0x20BCFA1F0](*(unsigned int *)(v2 + 64));
            while (1)
            {
              do
                this = MEMORY[0x20BCFA220](*v5);
              while ((_DWORD)this == 14);
              if ((_DWORD)this)
                break;
              if (*v9 == 1)
              {
                std::string::basic_string[abi:ne180100]<0>(&__p, "semaphore_receiver::reynch_handshake: wait out the receiver semaphore to clear things out for next time R-1");
                caulk::ipc::synchronous_messenger::details::drain_semaphore(v5);
                if (v11 < 0)
                  operator delete(__p);
                v9[1] = 1;
                this = MEMORY[0x20BCFA1F0](*(unsigned int *)(v2 + 64));
                break;
              }
            }
          }
          v3 = 0;
          break;
        case 0:
          return this;
      }
      if (*(_BYTE *)(v2 + 184))
        return this;
    }
    this = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)this + 48))(this, v6);
LABEL_13:
    v8 = *v7;
    goto LABEL_14;
  }
  return this;
}

void sub_2065D8EF8(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x2065D8E50);
}

uint64_t caulk::ipc::synchronous_messenger::semaphore_receiver::stop_handshake(caulk::ipc::synchronous_messenger::semaphore_receiver *this, caulk::ipc::synchronous_messenger::semaphore_receiver *a2)
{
  uint64_t result;

  result = caulk::ipc::synchronous_messenger::semaphore_receiver::is_valid(this);
  if ((_DWORD)result)
  {
    result = caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>((_QWORD *)this + 5);
    if (*(_DWORD *)(result + 4) == 1)
    {
      *(_DWORD *)(result + 4) = 0;
      return MEMORY[0x20BCFA1F0](*((unsigned int *)this + 16));
    }
  }
  return result;
}

void sub_2065D916C(void *a1, void *a2)
{
  uint64_t v2;

  std::unique_ptr<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup)::$_0,std::tuple<>>>::~unique_ptr[abi:ne180100]((uint64_t *)(v2 - 72), a2);
  __clang_call_terminate(a1);
}

uint64_t caulk::thread_proxy<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup)::$_0,std::tuple<>>>(uint64_t a1)
{
  uint64_t v2;
  double v3;
  char *v4;
  unsigned int *v5;
  void *v6;
  uint64_t v7;
  caulk::ipc::synchronous_messenger::semaphore_receiver *v8;
  uint64_t started;
  _BOOL4 v10;
  caulk::ipc::synchronous_messenger::semaphore_receiver *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  uint64_t v16;
  void (**v17)(caulk::mach::os_workgroup *__hidden);
  caulk::mach::details *v18;
  int v19;
  char v20;
  void (***v21)(caulk::mach::os_workgroup *__hidden);
  os_workgroup_join_token_opaque_s v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v16 = a1;
  caulk::thread::attributes::apply_to_this_thread(a1);
  v2 = *(_QWORD *)(a1 + 64);
  v3 = *(double *)(a1 + 80);
  v4 = *(char **)(a1 + 88);
  v5 = *(unsigned int **)(a1 + 96);
  v17 = &off_24BF2E020;
  v18 = (caulk::mach::details *)caulk::mach::details::retain_os_object(*(void **)(a1 + 112), v6);
  v7 = *(_QWORD *)(v2 + 112);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7);
  v21 = &v17;
  memset(&v22, 0, sizeof(v22));
  v23 = caulk::mach::os_workgroup::join((caulk::mach::os_workgroup *)&v17, &v22);
  started = caulk::ipc::synchronous_messenger::semaphore_receiver::start_handshake((caulk::ipc::synchronous_messenger::semaphore_receiver *)v2, v8, v3);
  v19 = started;
  v20 = BYTE4(started);
  caulk::expected<BOOL,int>::swap((char *)&v19, v4);
  if (v4[4])
  {
    caulk::expected<BOOL,int>::value((uint64_t)v4);
    v10 = *v4 != 0;
  }
  else
  {
    v10 = 0;
  }
  MEMORY[0x20BCFA1F0](*v5);
  if (v10)
    caulk::ipc::synchronous_messenger::semaphore_receiver::message_loop(v2, v11);
  if (!*(_BYTE *)(v2 + 185))
    caulk::ipc::synchronous_messenger::semaphore_receiver::stop_handshake((caulk::ipc::synchronous_messenger::semaphore_receiver *)v2, v11);
  if (!v23)
    caulk::mach::os_workgroup::leave((uint64_t)v21[1], &v22);
  v12 = *(_QWORD *)(v2 + 176);
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 48))(v12);
  MEMORY[0x20BCFA1F0](*(unsigned int *)(v2 + 80));
  v17 = &off_24BF2E020;
  caulk::mach::details::release_os_object(v18, v13);
  std::unique_ptr<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup)::$_0,std::tuple<>>>::~unique_ptr[abi:ne180100](&v16, v14);
  return 0;
}

void sub_2065D9380(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x2065D9328);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::unique_ptr<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup)::$_0,std::tuple<>>>::~unique_ptr[abi:ne180100](uint64_t *a1, void *a2)
{
  uint64_t v3;

  v3 = *a1;
  *a1 = 0;
  if (v3)
  {
    *(_QWORD *)(v3 + 104) = &off_24BF2E020;
    caulk::mach::details::release_os_object(*(caulk::mach::details **)(v3 + 112), a2);
    std::shared_ptr<caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<void *,caulk::alloc::detail::tracked_block,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>>::~shared_ptr[abi:ne180100](v3 + 64);
    if (*(_BYTE *)(v3 + 24) && *(char *)(v3 + 23) < 0)
      operator delete(*(void **)v3);
    MEMORY[0x20BCF9C08](v3, 0x10B2C40C95379B2);
  }
  return a1;
}

uint64_t caulk::mach::os_workgroup::leave(uint64_t this, os_workgroup_join_token_opaque_s *a2)
{
  if (this)
    return os_workgroup_leave_self();
  return this;
}

void caulk::ipc::synchronous_messenger::semaphore_receiver::stop(caulk::ipc::synchronous_messenger::semaphore_receiver *this, double a2)
{
  uint64_t v4;
  uint64_t v5;
  void *__p;
  char v7;

  if (caulk::ipc::synchronous_messenger::semaphore_receiver::is_valid(this))
  {
    v4 = *((unsigned int *)this + 18);
    *((_BYTE *)this + 184) = 1;
    MEMORY[0x20BCFA1F0](v4);
    caulk::mach::semaphore::timed_wait_or_error((semaphore_t *)this + 20, a2, v5);
    std::string::basic_string[abi:ne180100]<0>(&__p, "semaphore_receiver::stop: wait out the receiver semaphore to clear things out for next time R-1");
    caulk::ipc::synchronous_messenger::details::drain_semaphore((semaphore_t *)this + 18);
    if (v7 < 0)
      operator delete(__p);
  }
}

void caulk::ipc::synchronous_messenger::semaphore_receiver::simulate_crash_for_testing(caulk::ipc::synchronous_messenger::semaphore_receiver *this, double a2)
{
  uint64_t v4;
  uint64_t v5;
  void *__p;
  char v7;

  if (caulk::ipc::synchronous_messenger::semaphore_receiver::is_valid(this))
  {
    v4 = *((unsigned int *)this + 18);
    *((_WORD *)this + 92) = 257;
    MEMORY[0x20BCFA1F0](v4);
    caulk::mach::semaphore::timed_wait_or_error((semaphore_t *)this + 20, a2, v5);
    std::string::basic_string[abi:ne180100]<0>(&__p, "semaphore_receiver::stop: wait out the receiver semaphore to clear things out for next time R-1");
    caulk::ipc::synchronous_messenger::details::drain_semaphore((semaphore_t *)this + 18);
    if (v7 < 0)
      operator delete(__p);
  }
}

void caulk::ipc::synchronous_messenger::eventlink_sender::create_connection_info(caulk::ipc::synchronous_messenger::eventlink_sender *this@<X0>, _QWORD *a2@<X8>)
{
  xpc_object_t v4;
  caulk::mach::details *v5;
  caulk::mach::details *v6;
  void *v7;
  void *v8;
  void *v9;
  std::runtime_error *exception;
  std::runtime_error *v11;
  std::runtime_error *v12;
  std::runtime_error *v13;
  std::runtime_error *v14;
  mach_port_name_t v15;
  xpc_object_t v16;
  xpc_object_t value;

  v4 = xpc_dictionary_create(0, 0, 0);
  *a2 = v4;
  if (!v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "failed to allocate dictionary");
    __cxa_throw(exception, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  caulk::ipc::mapped_memory::create_xpc_object(this, &value);
  v5 = (caulk::mach::details *)value;
  if (!value)
  {
    v11 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v11, "failed to create payload object");
    __cxa_throw(v11, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  xpc_dictionary_set_value(v4, "payload", value);
  caulk::ipc::mapped_memory::create_xpc_object((caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 24), &v16);
  v6 = (caulk::mach::details *)v16;
  if (!v16)
  {
    v12 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v12, "failed to create control object");
    __cxa_throw(v12, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  xpc_dictionary_set_value(v4, "control", v16);
  v15 = caulk::mach::os_eventlink::copy_mach_port((caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 48));
  if (!v15)
  {
    v13 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v13, "failed to create eventlink port");
    __cxa_throw(v13, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  v7 = (void *)xpc_mach_send_create();
  if (!v7)
  {
    v14 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v14, "failed to create eventlink object");
    __cxa_throw(v14, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  xpc_dictionary_set_value(v4, "eventlink", v7);
  os_release(v7);
  caulk::mach::mach_port::~mach_port(&v15);
  caulk::mach::details::release_os_object(v6, v8);
  caulk::mach::details::release_os_object(v5, v9);
}

void sub_2065D9798(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, mach_port_name_t a11)
{
  caulk::mach::details *v11;
  caulk::mach::details *v12;
  caulk::mach::details *v13;
  void *v14;
  void *v16;
  void *v17;
  void *v18;

  __cxa_free_exception(v14);
  caulk::mach::mach_port::~mach_port(&a11);
  caulk::mach::details::release_os_object(v13, v16);
  caulk::mach::details::release_os_object(v12, v17);
  caulk::mach::details::release_os_object(v11, v18);
  _Unwind_Resume(a1);
}

void caulk::mach::mach_port::~mach_port(mach_port_name_t *this)
{
  if (*this)
    mach_port_deallocate(*MEMORY[0x24BDAEC58], *this);
}

uint64_t caulk::ipc::synchronous_messenger::eventlink_sender::associate(caulk::ipc::synchronous_messenger::eventlink_sender *this)
{
  caulk::mach::os_eventlink *v1;
  uint64_t v2;

  if (*(_QWORD *)this
    && *((_QWORD *)this + 1)
    && *((_QWORD *)this + 3)
    && *((_QWORD *)this + 4)
    && (v2 = *((_QWORD *)this + 6), v1 = (caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 48), v2))
  {
    return caulk::mach::os_eventlink::associate(v1);
  }
  else
  {
    return 22;
  }
}

uint64_t caulk::ipc::synchronous_messenger::eventlink_sender::dissociate(caulk::ipc::synchronous_messenger::eventlink_sender *this)
{
  caulk::mach::os_eventlink *v1;
  uint64_t v2;

  if (*(_QWORD *)this
    && *((_QWORD *)this + 1)
    && *((_QWORD *)this + 3)
    && *((_QWORD *)this + 4)
    && (v2 = *((_QWORD *)this + 6), v1 = (caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 48), v2))
  {
    return caulk::mach::os_eventlink::dissociate(v1);
  }
  else
  {
    return 22;
  }
}

unint64_t caulk::ipc::synchronous_messenger::eventlink_sender::start(caulk::ipc::synchronous_messenger::eventlink_sender *this, double a2, int a3)
{
  _QWORD *v4;
  caulk::mach::os_eventlink *v5;
  _DWORD *v8;
  unint64_t v9;
  unsigned int v10;
  unsigned int v11;
  _DWORD *v13;
  unsigned int v14;
  unint64_t v15;
  unsigned int v16;
  unint64_t v17;

  if (*(_QWORD *)this
    && *((_QWORD *)this + 1)
    && (v4 = (_QWORD *)((char *)this + 24), *((_QWORD *)this + 3))
    && *((_QWORD *)this + 4)
    && (v5 = (caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 48), *((_QWORD *)this + 6))
    && !*((_BYTE *)this + 56)
    && (v8 = (_DWORD *)caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>(v4),
        !*v8))
  {
    v13 = v8;
    if (a3
      && (v14 = caulk::mach::os_eventlink::associate((caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 48))) != 0)
    {
      LOBYTE(v11) = v14;
      LOBYTE(v9) = 0;
      v10 = v14 >> 8;
    }
    else
    {
      while (1)
      {
        v15 = caulk::mach::os_eventlink::timed_wait_or_error((caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 48), a2);
        v16 = v15;
        v9 = HIDWORD(v15);
        if (!HIDWORD(v15))
          break;
        if (!(_BYTE)v15)
        {
          v10 = v15 >> 8;
          if (a3)
            caulk::mach::os_eventlink::dissociate(v5);
          LOBYTE(v11) = 0;
          return v11 | (v10 << 8) | ((unint64_t)v9 << 32);
        }
        if (v13[1] == 1)
        {
          *v13 = 1;
          caulk::mach::os_eventlink::signal_or_error((caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 48));
          v17 = caulk::mach::os_eventlink::timed_wait_or_error((caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 48), a2);
          v9 = HIDWORD(v17);
          if (HIDWORD(v17))
          {
            *((_BYTE *)this + 56) = 1;
            LOBYTE(v9) = 1;
            LOBYTE(v11) = 1;
            v10 = v16 >> 8;
          }
          else
          {
            v11 = v17;
            if (a3)
              caulk::mach::os_eventlink::dissociate((caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 48));
            v10 = v11 >> 8;
          }
          return v11 | (v10 << 8) | ((unint64_t)v9 << 32);
        }
      }
      LOBYTE(v11) = v15;
      v10 = v15 >> 8;
      if (a3)
        caulk::mach::os_eventlink::dissociate(v5);
      LOBYTE(v9) = 0;
    }
  }
  else
  {
    LOBYTE(v9) = 0;
    v10 = 0;
    LOBYTE(v11) = 22;
  }
  return v11 | (v10 << 8) | ((unint64_t)v9 << 32);
}

uint64_t caulk::ipc::synchronous_messenger::eventlink_sender::send(caulk::ipc::synchronous_messenger::eventlink_sender *this, double a2)
{
  uint64_t v2;
  _QWORD *v4;
  _DWORD *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;

  v2 = *(_QWORD *)this;
  if (!*(_QWORD *)this)
    goto LABEL_13;
  v2 = *((_QWORD *)this + 1);
  if (!v2)
    goto LABEL_13;
  v4 = (_QWORD *)((char *)this + 24);
  v2 = *((_QWORD *)this + 3);
  if (!v2)
    goto LABEL_13;
  v2 = *((_QWORD *)this + 4);
  if (!v2)
    goto LABEL_13;
  v2 = *((_QWORD *)this + 6);
  if (!v2)
    goto LABEL_13;
  if (!*((_BYTE *)this + 56))
  {
LABEL_12:
    v2 = 0;
LABEL_13:
    v9 = 0;
    LOBYTE(v8) = 22;
    return v2 | v9 | v8;
  }
  v6 = (_DWORD *)caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>(v4);
  if (*v6 != 1 || !v6[1])
  {
    caulk::ipc::synchronous_messenger::eventlink_sender::reset_messaging(this, a2);
    goto LABEL_12;
  }
  v7 = caulk::mach::os_eventlink::timed_wait_signal_or_error((caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 48), a2);
  v8 = v7;
  if (HIDWORD(v7))
  {
    v2 = 0x100000000;
    if ((_BYTE)v7)
      LOBYTE(v8) = 1;
    else
      v2 = v7 & 0x100000000;
    if ((_BYTE)v7)
      v9 = 0;
    else
      v9 = v7 & 0xFFFFFF00;
  }
  else
  {
    caulk::ipc::synchronous_messenger::eventlink_sender::reset_messaging(this, a2);
    v2 = v8 & 0x100000000;
    v9 = v8 & 0xFFFFFF00;
  }
  return v2 | v9 | v8;
}

void caulk::ipc::synchronous_messenger::eventlink_sender::reset_messaging(caulk::ipc::synchronous_messenger::eventlink_sender *this, double a2)
{
  _DWORD *v4;
  unint64_t v5;
  void *__p;
  char v7;

  v4 = (_DWORD *)caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>((_QWORD *)this + 3);
  *v4 = 0;
  caulk::mach::os_eventlink::signal_or_error((caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 48));
  do
    v5 = caulk::mach::os_eventlink::timed_wait_or_error((caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 48), a2);
  while (HIDWORD(v5) && (_BYTE)v5 && v4[1]);
  *((_BYTE *)this + 56) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "eventlink_sender::reset_messaging: wait out the eventlink to clear things out for next time S-1");
  caulk::ipc::synchronous_messenger::details::drain_eventlink((caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 48));
  if (v7 < 0)
    operator delete(__p);
}

unint64_t caulk::ipc::synchronous_messenger::details::drain_eventlink(caulk::mach::os_eventlink *this)
{
  char v2;
  unint64_t result;
  BOOL v4;

  v2 = 0;
  do
  {
    result = caulk::mach::os_eventlink::timed_wait_or_error(this, 0.000001);
    if (HIDWORD(result))
      v4 = v2 == 0;
    else
      v4 = 1;
    if (v4)
    {
      if (!HIDWORD(result))
        break;
      if (!v2)
        v2 = BYTE4(result);
      if (!v2)
        break;
    }
  }
  while ((_BYTE)result);
  return result;
}

uint64_t caulk::ipc::synchronous_messenger::eventlink_sender::resynch(caulk::ipc::synchronous_messenger::eventlink_sender *this)
{
  uint64_t v1;
  caulk::mach::os_eventlink *v2;
  _DWORD *v3;
  unint64_t v4;
  unint64_t v5;
  int v6;
  uint64_t v7;
  void *__p;
  char v10;

  v1 = *(_QWORD *)this;
  if (!*(_QWORD *)this)
    goto LABEL_17;
  v1 = *((_QWORD *)this + 1);
  if (!v1)
    goto LABEL_17;
  if (!*((_QWORD *)this + 3)
    || !*((_QWORD *)this + 4)
    || (v2 = (caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 48), !*((_QWORD *)this + 6))
    || !*((_BYTE *)this + 56))
  {
    v1 = 0;
LABEL_17:
    v7 = 0;
    LOBYTE(v6) = 22;
    return v7 | v1 | v6;
  }
  v3 = (_DWORD *)caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>((_QWORD *)this + 3);
  *v3 = 2;
  caulk::mach::os_eventlink::signal_or_error(v2);
  do
  {
    v4 = caulk::mach::os_eventlink::wait_or_error(v2);
    v1 = HIDWORD(v4);
    if (!HIDWORD(v4))
    {
      v6 = v4;
      goto LABEL_20;
    }
  }
  while (v3[1] != 2);
  *v3 = 1;
  caulk::mach::os_eventlink::signal_or_error(v2);
  while (1)
  {
    v5 = caulk::mach::os_eventlink::wait_or_error(v2);
    v6 = v5;
    v1 = HIDWORD(v5);
    if (!HIDWORD(v5))
      break;
    if (v3[1] == 1)
    {
      std::string::basic_string[abi:ne180100]<0>(&__p, "eventlink_sender::reset_messaging: wait out the sender eventlink to clear things out for next time S-1");
      v7 = v6 & 0xFFFFFF00;
      caulk::ipc::synchronous_messenger::details::drain_eventlink(v2);
      if (v10 < 0)
        operator delete(__p);
      LOBYTE(v6) = 0;
      v1 = 0x100000000;
      return v7 | v1 | v6;
    }
  }
LABEL_20:
  v7 = v6 & 0xFFFFFF00;
  return v7 | v1 | v6;
}

uint64_t caulk::ipc::synchronous_messenger::eventlink_sender::resynch(caulk::ipc::synchronous_messenger::eventlink_sender *this, double a2)
{
  uint64_t v2;
  caulk::mach::os_eventlink *v3;
  _DWORD *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  void *__p;
  char v12;

  v2 = *(_QWORD *)this;
  if (!*(_QWORD *)this)
    goto LABEL_19;
  v2 = *((_QWORD *)this + 1);
  if (!v2)
    goto LABEL_19;
  if (!*((_QWORD *)this + 3)
    || !*((_QWORD *)this + 4)
    || (v3 = (caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 48), !*((_QWORD *)this + 6))
    || !*((_BYTE *)this + 56))
  {
    v2 = 0;
LABEL_19:
    v9 = 0;
    LOBYTE(v7) = 22;
    return v9 | v2 | v7;
  }
  v5 = (_DWORD *)caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>((_QWORD *)this + 3);
  *v5 = 2;
  caulk::mach::os_eventlink::signal_or_error(v3);
  while (1)
  {
    v6 = caulk::mach::os_eventlink::timed_wait_or_error(v3, a2);
    v7 = v6;
    v2 = HIDWORD(v6);
    if (!HIDWORD(v6))
      goto LABEL_21;
    if (!(_BYTE)v6)
      break;
    if (v5[1] == 2)
    {
      *v5 = 1;
      caulk::mach::os_eventlink::signal_or_error(v3);
      while (1)
      {
        v8 = caulk::mach::os_eventlink::timed_wait_or_error(v3, a2);
        v7 = v8;
        v2 = HIDWORD(v8);
        if (!HIDWORD(v8))
          break;
        if (!(_BYTE)v8)
          goto LABEL_22;
        if (v5[1] == 1)
        {
          std::string::basic_string[abi:ne180100]<0>(&__p, "eventlink_sender::reset_messaging: wait out the sender semaphore to clear things out for next time S-1");
          v9 = v7 & 0xFFFFFF00;
          caulk::ipc::synchronous_messenger::details::drain_eventlink(v3);
          if (v12 < 0)
            operator delete(__p);
          v2 = 0x100000000;
          LOBYTE(v7) = 1;
          return v9 | v2 | v7;
        }
      }
LABEL_21:
      v9 = v7 & 0xFFFFFF00;
      return v9 | v2 | v7;
    }
  }
LABEL_22:
  v9 = v7 & 0xFFFFFF00;
  v2 = v7 & 0x100000000;
  LOBYTE(v7) = 0;
  return v9 | v2 | v7;
}

void caulk::ipc::synchronous_messenger::eventlink_sender::stop(caulk::ipc::synchronous_messenger::eventlink_sender *this, double a2, int a3)
{
  caulk::mach::os_eventlink *v3;

  if (*(_QWORD *)this)
  {
    if (*((_QWORD *)this + 1))
    {
      if (*((_QWORD *)this + 3))
      {
        if (*((_QWORD *)this + 4))
        {
          v3 = (caulk::ipc::synchronous_messenger::eventlink_sender *)((char *)this + 48);
          if (*((_QWORD *)this + 6))
          {
            if (*((_BYTE *)this + 56))
            {
              caulk::ipc::synchronous_messenger::eventlink_sender::reset_messaging(this, a2);
              if (a3)
                caulk::mach::os_eventlink::dissociate(v3);
            }
          }
        }
      }
    }
  }
}

void caulk::ipc::synchronous_messenger::eventlink_receiver::ingest_connection_info(uint64_t a1, uint64_t a2, xpc_object_t *a3)
{
  xpc_object_t value;
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  xpc_object_t v11;
  void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  xpc_object_t v17;
  void *v18;
  void *v19;
  void *v20;
  caulk::mach::details *v21;
  void *v22;
  void *v23;
  void *v24;
  std::runtime_error *exception;
  std::runtime_error *v26;
  std::runtime_error *v27;
  std::runtime_error *v28;
  std::runtime_error *v29;
  xpc_object_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  xpc_object_t v34;

  if (!*a3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "no connection info");
    goto LABEL_10;
  }
  if (MEMORY[0x20BCFA2BC]() != MEMORY[0x24BDACFA0])
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "no dictionary");
LABEL_10:
    __cxa_throw(exception, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  value = xpc_dictionary_get_value(*a3, "payload");
  v7 = caulk::mach::details::retain_os_object(value, v6);
  v34 = v7;
  if (!v7)
  {
    v26 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v26, "no payload");
    __cxa_throw(v26, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  caulk::ipc::mapped_memory::mapped_memory((uint64_t)&v31, &v34);
  v8 = *(_QWORD *)(a1 + 16);
  v9 = *(_QWORD *)(a1 + 24);
  v10 = v32;
  *(_QWORD *)(a1 + 16) = v31;
  *(_QWORD *)(a1 + 24) = v10;
  v31 = v8;
  v32 = v9;
  LOBYTE(v8) = *(_BYTE *)(a1 + 32);
  *(_BYTE *)(a1 + 32) = v33;
  v33 = v8;
  caulk::ipc::mapped_memory::reset((caulk::ipc::mapped_memory *)&v31);
  v11 = xpc_dictionary_get_value(*a3, "control");
  v13 = caulk::mach::details::retain_os_object(v11, v12);
  v30 = v13;
  if (!v13)
  {
    v27 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v27, "no control");
    __cxa_throw(v27, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  caulk::ipc::mapped_memory::mapped_memory((uint64_t)&v31, &v30);
  v14 = *(_QWORD *)(a1 + 40);
  v15 = *(_QWORD *)(a1 + 48);
  v16 = v32;
  *(_QWORD *)(a1 + 40) = v31;
  *(_QWORD *)(a1 + 48) = v16;
  v31 = v14;
  v32 = v15;
  LOBYTE(v14) = *(_BYTE *)(a1 + 56);
  *(_BYTE *)(a1 + 56) = v33;
  v33 = v14;
  caulk::ipc::mapped_memory::reset((caulk::ipc::mapped_memory *)&v31);
  v17 = xpc_dictionary_get_value(*a3, "eventlink");
  v19 = caulk::mach::details::retain_os_object(v17, v18);
  v20 = v19;
  if (!v19)
  {
    v28 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v28, "no eventlink");
    __cxa_throw(v28, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  if (MEMORY[0x20BCFA2BC](v19) != MEMORY[0x24BDACFD8])
  {
    v29 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v29, "object is not a mach send right");
    __cxa_throw(v29, MEMORY[0x24BEDB730], MEMORY[0x24BEDAB60]);
  }
  xpc_mach_send_copy_right();
  caulk::mach::os_eventlink::make(&v31);
  v21 = *(caulk::mach::details **)(a1 + 64);
  *(_QWORD *)(a1 + 64) = v31;
  caulk::mach::details::release_os_object(v21, v22);
  os_release(v20);
  caulk::mach::details::release_os_object((caulk::mach::details *)v13, v23);
  caulk::mach::details::release_os_object((caulk::mach::details *)v7, v24);
}

void sub_2065DA1D8(_Unwind_Exception *a1)
{
  caulk::mach::details *v1;
  caulk::mach::details *v2;
  void *v3;
  caulk::mach::details *v4;
  void *v6;
  void *v7;
  void *v8;

  __cxa_free_exception(v3);
  caulk::mach::details::release_os_object(v4, v6);
  caulk::mach::details::release_os_object(v2, v7);
  caulk::mach::details::release_os_object(v1, v8);
  _Unwind_Resume(a1);
}

uint64_t caulk::ipc::synchronous_messenger::eventlink_receiver::start(caulk::ipc::synchronous_messenger::eventlink_receiver *this, double a2, const caulk::thread::attributes *a3)
{
  uint64_t v3;
  void *v4;
  void (**v6)(caulk::mach::os_workgroup_managed *__hidden);
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v6 = &off_24BF2E088;
  v7 = 0u;
  v8 = 0u;
  v9 = 0u;
  v10 = 0;
  v3 = caulk::ipc::synchronous_messenger::eventlink_receiver::start((uint64_t)this, (uint64_t)a3, (uint64_t)&v6, a2);
  caulk::mach::details::release_os_object(0, v4);
  return v3;
}

uint64_t caulk::ipc::synchronous_messenger::eventlink_receiver::start(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  void *v8;
  __int128 v9;
  uint64_t v10;
  caulk::mach::details *v11;
  char v12;
  __int128 v13;
  __int128 v14;
  void *v15;
  void *v16;
  void *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  __int128 v22;
  uint64_t v23;
  char v24;
  semaphore_t semaphore;
  std::string __p;
  char v27;
  _BYTE v28[29];
  uint64_t v29;
  __int128 v30;
  semaphore_t *v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  semaphore_t *p_semaphore;
  void (**v36)(caulk::mach::os_workgroup_managed *__hidden);
  caulk::mach::details *v37;
  __int128 v38;
  _OWORD v39[2];
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 16)
    && *(_QWORD *)(a1 + 24)
    && *(_QWORD *)(a1 + 40)
    && *(_QWORD *)(a1 + 48)
    && *(_QWORD *)(a1 + 64))
  {
    std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100](&__p, (__int128 *)a2);
    *(_OWORD *)v28 = *(_OWORD *)(a2 + 32);
    *(_QWORD *)&v28[16] = *(_QWORD *)(a2 + 48);
    *(_DWORD *)&v28[24] = 1;
    v28[28] = 1;
    *(_WORD *)(a1 + 184) = 0;
    LODWORD(v29) = 1;
    BYTE4(v29) = 0;
    caulk::mach::semaphore::semaphore(&semaphore);
    std::shared_ptr<caulk::ipc::synchronous_messenger::semaphore_receiver>::shared_ptr[abi:ne180100]<caulk::ipc::synchronous_messenger::semaphore_receiver,void>(&v33, *(_QWORD *)a1, *(std::__shared_weak_count **)(a1 + 8));
    *(double *)&v34 = a4;
    *((_QWORD *)&v34 + 1) = &v29;
    p_semaphore = &semaphore;
    v36 = &off_24BF2E088;
    v37 = (caulk::mach::details *)caulk::mach::details::retain_os_object(*(void **)(a3 + 8), v8);
    v9 = *(_OWORD *)(a3 + 32);
    v38 = *(_OWORD *)(a3 + 16);
    v39[0] = v9;
    *(_OWORD *)((char *)v39 + 9) = *(_OWORD *)(a3 + 41);
    v23 = 0;
    v24 = 0;
    v10 = operator new();
    v22 = v33;
    v33 = 0uLL;
    v30 = v34;
    v31 = p_semaphore;
    v11 = v37;
    v37 = 0;
    v40 = v38;
    v41 = v39[0];
    v42 = *(_QWORD *)&v39[1];
    v38 = 0u;
    memset(v39, 0, 25);
    v12 = BYTE8(v39[1]);
    std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100]((std::string *)v10, (__int128 *)&__p);
    *(_OWORD *)(v10 + 32) = *(_OWORD *)v28;
    *(_OWORD *)(v10 + 45) = *(_OWORD *)&v28[13];
    v13 = v30;
    *(_OWORD *)(v10 + 64) = v22;
    *(_OWORD *)(v10 + 80) = v13;
    *(_QWORD *)(v10 + 96) = v31;
    *(_QWORD *)(v10 + 104) = &off_24BF2E088;
    *(_QWORD *)(v10 + 112) = v11;
    *(_QWORD *)(v10 + 152) = v42;
    v14 = v40;
    *(_OWORD *)(v10 + 136) = v41;
    *(_OWORD *)(v10 + 120) = v14;
    v40 = 0u;
    v41 = 0u;
    v42 = 0;
    *(_BYTE *)(v10 + 160) = v12;
    v32 = v10;
    caulk::mach::details::release_os_object(0, v15);
    caulk::thread::start((uint64_t)&v23, v10, (void *(__cdecl *)(void *))caulk::thread_proxy<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::eventlink_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup_managed)::$_0,std::tuple<>>>, (void *)v10);
    v32 = 0;
    std::unique_ptr<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup_managed)::$_0,std::tuple<>>>::~unique_ptr[abi:ne180100](&v32, v16);
    v36 = &off_24BF2E088;
    caulk::mach::details::release_os_object(v37, v17);
    v18 = (std::__shared_weak_count *)*((_QWORD *)&v33 + 1);
    if (*((_QWORD *)&v33 + 1))
    {
      v19 = (unint64_t *)(*((_QWORD *)&v33 + 1) + 8);
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    while (MEMORY[0x20BCFA220](semaphore) == 14)
      ;
    if (v23)
      std::terminate();
    caulk::mach::semaphore::~semaphore(&semaphore);
    if (v27 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    LODWORD(v29) = 22;
    BYTE4(v29) = 0;
  }
  return v29;
}

{
  void *v8;
  uint64_t v9;
  caulk::mach::details *v10;
  __int128 v11;
  void *v12;
  void *v13;
  void *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  semaphore_t *p_semaphore;
  void (**v23)(caulk::mach::os_workgroup *__hidden);
  caulk::mach::details *v24;
  uint64_t v25;
  char v26;
  semaphore_t semaphore;
  std::string __p;
  char v29;
  _BYTE v30[29];
  uint64_t v31;
  __int128 v32;
  semaphore_t *v33;
  uint64_t v34;

  if (*(_QWORD *)(a1 + 16)
    && *(_QWORD *)(a1 + 24)
    && *(_QWORD *)(a1 + 40)
    && *(_QWORD *)(a1 + 48)
    && *(_QWORD *)(a1 + 64))
  {
    std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100](&__p, (__int128 *)a2);
    *(_OWORD *)v30 = *(_OWORD *)(a2 + 32);
    *(_QWORD *)&v30[16] = *(_QWORD *)(a2 + 48);
    *(_DWORD *)&v30[24] = 1;
    v30[28] = 1;
    *(_WORD *)(a1 + 184) = 0;
    LODWORD(v31) = 1;
    BYTE4(v31) = 0;
    caulk::mach::semaphore::semaphore(&semaphore);
    std::shared_ptr<caulk::ipc::synchronous_messenger::semaphore_receiver>::shared_ptr[abi:ne180100]<caulk::ipc::synchronous_messenger::semaphore_receiver,void>(&v20, *(_QWORD *)a1, *(std::__shared_weak_count **)(a1 + 8));
    *(double *)&v21 = a4;
    *((_QWORD *)&v21 + 1) = &v31;
    p_semaphore = &semaphore;
    v23 = &off_24BF2E020;
    v24 = (caulk::mach::details *)caulk::mach::details::retain_os_object(*(void **)(a3 + 8), v8);
    v25 = 0;
    v26 = 0;
    v9 = operator new();
    v19 = v20;
    v20 = 0uLL;
    v32 = v21;
    v33 = p_semaphore;
    v10 = v24;
    v24 = 0;
    std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100]((std::string *)v9, (__int128 *)&__p);
    *(_OWORD *)(v9 + 32) = *(_OWORD *)v30;
    *(_OWORD *)(v9 + 45) = *(_OWORD *)&v30[13];
    v11 = v32;
    *(_OWORD *)(v9 + 64) = v19;
    *(_OWORD *)(v9 + 80) = v11;
    *(_QWORD *)(v9 + 96) = v33;
    *(_QWORD *)(v9 + 104) = &off_24BF2E020;
    *(_QWORD *)(v9 + 112) = v10;
    v34 = v9;
    caulk::mach::details::release_os_object(0, v12);
    caulk::thread::start((uint64_t)&v25, v9, (void *(__cdecl *)(void *))caulk::thread_proxy<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::eventlink_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup)::$_0,std::tuple<>>>, (void *)v9);
    v34 = 0;
    std::unique_ptr<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup)::$_0,std::tuple<>>>::~unique_ptr[abi:ne180100](&v34, v13);
    v23 = &off_24BF2E020;
    caulk::mach::details::release_os_object(v24, v14);
    v15 = (std::__shared_weak_count *)*((_QWORD *)&v20 + 1);
    if (*((_QWORD *)&v20 + 1))
    {
      v16 = (unint64_t *)(*((_QWORD *)&v20 + 1) + 8);
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    while (MEMORY[0x20BCFA220](semaphore) == 14)
      ;
    if (v25)
      std::terminate();
    caulk::mach::semaphore::~semaphore(&semaphore);
    if (v29 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    LODWORD(v31) = 22;
    BYTE4(v31) = 0;
  }
  return v31;
}

void sub_2065DA5A8(_Unwind_Exception *exception_object, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if ((_DWORD)a2)
  {
    std::unique_ptr<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup_managed)::$_0,std::tuple<>>>::~unique_ptr[abi:ne180100](&a25, a2);
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t caulk::thread_proxy<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::eventlink_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup_managed)::$_0,std::tuple<>>>(uint64_t a1)
{
  unint64_t v2;
  double v3;
  char *v4;
  unsigned int *v5;
  void *v6;
  __int128 v7;
  uint64_t v8;
  int v9;
  uint64_t started;
  _BOOL4 v11;
  caulk::ipc::synchronous_messenger::eventlink_receiver *v12;
  uint64_t v13;
  void *v14;
  void *v15;
  uint64_t v17;
  int v18;
  char v19;
  void (**v20)(caulk::mach::os_workgroup_managed *__hidden);
  caulk::mach::details *v21;
  __int128 v22;
  _OWORD v23[2];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v17 = a1;
  caulk::thread::attributes::apply_to_this_thread(a1);
  v2 = *(_QWORD *)(a1 + 64);
  v3 = *(double *)(a1 + 80);
  v4 = *(char **)(a1 + 88);
  v5 = *(unsigned int **)(a1 + 96);
  v20 = &off_24BF2E088;
  v21 = (caulk::mach::details *)caulk::mach::details::retain_os_object(*(void **)(a1 + 112), v6);
  v7 = *(_OWORD *)(a1 + 136);
  v22 = *(_OWORD *)(a1 + 120);
  v23[0] = v7;
  *(_OWORD *)((char *)v23 + 9) = *(_OWORD *)(a1 + 145);
  caulk::mach::os_eventlink::associate((caulk::mach::os_eventlink *)(v2 + 64));
  v8 = *(_QWORD *)(v2 + 104);
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 48))(v8);
  v9 = caulk::mach::os_workgroup_managed::join((caulk::mach::os_workgroup_managed *)&v20);
  started = caulk::ipc::synchronous_messenger::eventlink_receiver::start_handshake(v2, v3);
  v18 = started;
  v19 = BYTE4(started);
  caulk::expected<BOOL,int>::swap((char *)&v18, v4);
  if (v4[4])
  {
    caulk::expected<BOOL,int>::value((uint64_t)v4);
    v11 = *v4 != 0;
  }
  else
  {
    v11 = 0;
  }
  MEMORY[0x20BCFA1F0](*v5);
  if (v11)
    caulk::ipc::synchronous_messenger::eventlink_receiver::message_loop(v2, v12);
  if (*(_BYTE *)(v2 + 185))
  {
    if (v9)
      goto LABEL_13;
  }
  else
  {
    caulk::ipc::synchronous_messenger::eventlink_receiver::stop_handshake(v2);
    if (v9)
      goto LABEL_13;
  }
  caulk::mach::os_workgroup_managed::leave((caulk::mach::os_workgroup_managed *)&v20);
LABEL_13:
  v13 = *(_QWORD *)(v2 + 168);
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 48))(v13);
  caulk::mach::os_eventlink::dissociate((caulk::mach::os_eventlink *)(v2 + 64));
  MEMORY[0x20BCFA1F0](*(unsigned int *)(v2 + 72));
  v20 = &off_24BF2E088;
  caulk::mach::details::release_os_object(v21, v14);
  std::unique_ptr<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup_managed)::$_0,std::tuple<>>>::~unique_ptr[abi:ne180100](&v17, v15);
  return 0;
}

void sub_2065DA7DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x2065DA778);
  }
  _Unwind_Resume(exception_object);
}

uint64_t caulk::ipc::synchronous_messenger::eventlink_receiver::start_handshake(uint64_t a1, double a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  caulk::mach::os_eventlink *v5;
  BOOL v6;
  BOOL v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v16;
  uint64_t v17;

  v4 = *(_QWORD *)(a1 + 40);
  v2 = (_QWORD *)(a1 + 40);
  v3 = v4;
  v5 = (caulk::mach::os_eventlink *)(v2 + 3);
  if (*(v2 - 3))
    v6 = *(v2 - 2) == 0;
  else
    v6 = 1;
  v9 = v6 || v3 == 0 || v2[1] == 0 || v2[3] == 0;
  if (v9
    || (v11 = caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>(v2),
        *(_DWORD *)(v11 + 4)))
  {
    v12 = 0;
    v13 = 0;
    v14 = 22;
  }
  else
  {
    v16 = (_DWORD *)v11;
    *(_DWORD *)(v11 + 4) = 1;
    caulk::mach::os_eventlink::signal_or_error(v5);
    while (1)
    {
      v17 = caulk::mach::os_eventlink::timed_wait_or_error(v5, a2);
      if ((v17 & 0x100000000) == 0)
      {
        v12 = 0;
        v13 = v17 & 0xFFFFFF00;
        v14 = v17;
        return v13 | v14 | v12;
      }
      if (!(_BYTE)v17)
        break;
      if (*v16 == 1)
      {
        v13 = v17 & 0xFFFFFF00;
        caulk::mach::os_eventlink::signal_or_error(v5);
        v12 = 0x100000000;
        v14 = 1;
        return v13 | v14 | v12;
      }
    }
    v14 = 0;
    v12 = v17 & 0x100000000;
    v13 = v17 & 0xFFFFFF00;
  }
  return v13 | v14 | v12;
}

unint64_t caulk::ipc::synchronous_messenger::eventlink_receiver::message_loop(unint64_t this, caulk::ipc::synchronous_messenger::eventlink_receiver *a2)
{
  unint64_t v2;
  BOOL v3;
  _QWORD *v4;
  caulk::mach::os_eventlink *v5;
  unint64_t v6;
  int *v7;
  double v8;
  int v9;
  BOOL v10;
  BOOL v11;
  int v12;
  _DWORD *v13;
  int v14;
  unsigned __int8 v15;
  void *__p;
  char v17;

  if (!*(_BYTE *)(this + 184))
  {
    v2 = this;
    v3 = 0;
    v4 = (_QWORD *)(this + 40);
    v5 = (caulk::mach::os_eventlink *)(this + 64);
    v6 = this + 16;
    while (1)
    {
      v7 = (int *)caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>(v4);
      v14 = 1;
      v15 = 0;
      v8 = *(double *)(v2 + 176);
      if (!v3)
        break;
      this = caulk::mach::os_eventlink::timed_wait_signal_or_error(v5, v8);
      v9 = v15;
      if (HIDWORD(this))
        v10 = v15 == 0;
      else
        v10 = 1;
      if (!v10)
        goto LABEL_21;
      if (!HIDWORD(this))
        goto LABEL_19;
      if (v15)
        goto LABEL_23;
      LOBYTE(v14) = this;
      v9 = BYTE4(this);
      v15 = BYTE4(this);
LABEL_24:
      if (*(_BYTE *)(v2 + 184) || !v9)
        return this;
      this = caulk::expected<BOOL,int>::value((uint64_t)&v14);
      if (!(_BYTE)v14)
        goto LABEL_30;
      this = *(_QWORD *)(v2 + 136);
      if (!this)
        goto LABEL_30;
      v12 = *v7;
      if (*v7 == 1)
      {
        this = (*(uint64_t (**)(unint64_t, unint64_t))(*(_QWORD *)this + 48))(this, v6);
LABEL_30:
        v12 = *v7;
      }
      switch(v12)
      {
        case 1:
          this = caulk::expected<BOOL,int>::value((uint64_t)&v14);
          v3 = (_BYTE)v14 != 0;
          break;
        case 2:
          v3 = 0;
          if (*(_QWORD *)(v2 + 16)
            && *(_QWORD *)(v2 + 24)
            && *(_QWORD *)(v2 + 40)
            && *(_QWORD *)(v2 + 48)
            && *(_QWORD *)(v2 + 64))
          {
            v13 = (_DWORD *)caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>(v4);
            v13[1] = 2;
            caulk::mach::os_eventlink::signal_or_error(v5);
            while (1)
            {
              this = caulk::mach::os_eventlink::wait_or_error(v5);
              if (!HIDWORD(this))
                break;
              if (*v13 == 1)
              {
                std::string::basic_string[abi:ne180100]<0>(&__p, "eventlink_receiver::reynch_handshake: wait out the eventlink to clear things out for next time R-1");
                caulk::ipc::synchronous_messenger::details::drain_eventlink(v5);
                if (v17 < 0)
                  operator delete(__p);
                v13[1] = 1;
                this = caulk::mach::os_eventlink::signal_or_error(v5);
                break;
              }
            }
            v3 = 0;
          }
          break;
        case 0:
          return this;
      }
      if (*(_BYTE *)(v2 + 184))
        return this;
    }
    this = caulk::mach::os_eventlink::timed_wait_or_error(v5, v8);
    v9 = v15;
    if (HIDWORD(this))
      v11 = v15 == 0;
    else
      v11 = 1;
    if (v11)
    {
      if (HIDWORD(this))
      {
        if (!v15)
        {
          LOBYTE(v14) = this;
          v9 = BYTE4(this);
          v15 = BYTE4(this);
          goto LABEL_24;
        }
      }
      else
      {
LABEL_19:
        if (v9)
          return this;
      }
LABEL_23:
      v14 = this;
      goto LABEL_24;
    }
LABEL_21:
    LOBYTE(v14) = this;
    v9 = 1;
    goto LABEL_24;
  }
  return this;
}

void sub_2065DAB40(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x2065DAA5CLL);
}

uint64_t caulk::ipc::synchronous_messenger::eventlink_receiver::stop_handshake(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  uint64_t v3;
  caulk::mach::os_eventlink *v4;
  BOOL v5;

  v3 = *(_QWORD *)(a1 + 40);
  result = a1 + 40;
  v2 = v3;
  v4 = (caulk::mach::os_eventlink *)(result + 24);
  if (*(_QWORD *)(result - 24))
    v5 = *(_QWORD *)(result - 16) == 0;
  else
    v5 = 1;
  if (!v5 && v2 != 0 && *(_QWORD *)(result + 8) != 0 && *(_QWORD *)(result + 24) != 0)
  {
    result = caulk::ipc::mapped_memory::get_ptr<caulk::ipc::synchronous_messenger::details::flow_control>((_QWORD *)result);
    if (*(_DWORD *)(result + 4) == 1)
    {
      *(_DWORD *)(result + 4) = 0;
      return caulk::mach::os_eventlink::signal_or_error(v4);
    }
  }
  return result;
}

void sub_2065DADE4(void *a1, void *a2)
{
  uint64_t v2;

  std::unique_ptr<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup)::$_0,std::tuple<>>>::~unique_ptr[abi:ne180100]((uint64_t *)(v2 - 72), a2);
  __clang_call_terminate(a1);
}

uint64_t caulk::thread_proxy<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::eventlink_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup)::$_0,std::tuple<>>>(uint64_t a1)
{
  unint64_t v2;
  double v3;
  char *v4;
  unsigned int *v5;
  void *v6;
  uint64_t v7;
  uint64_t started;
  _BOOL4 v9;
  caulk::ipc::synchronous_messenger::eventlink_receiver *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  uint64_t v15;
  void (**v16)(caulk::mach::os_workgroup *__hidden);
  caulk::mach::details *v17;
  int v18;
  char v19;
  void (***v20)(caulk::mach::os_workgroup *__hidden);
  os_workgroup_join_token_opaque_s v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v15 = a1;
  caulk::thread::attributes::apply_to_this_thread(a1);
  v2 = *(_QWORD *)(a1 + 64);
  v3 = *(double *)(a1 + 80);
  v4 = *(char **)(a1 + 88);
  v5 = *(unsigned int **)(a1 + 96);
  v16 = &off_24BF2E020;
  v17 = (caulk::mach::details *)caulk::mach::details::retain_os_object(*(void **)(a1 + 112), v6);
  caulk::mach::os_eventlink::associate((caulk::mach::os_eventlink *)(v2 + 64));
  v7 = *(_QWORD *)(v2 + 104);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7);
  v20 = &v16;
  memset(&v21, 0, sizeof(v21));
  v22 = caulk::mach::os_workgroup::join((caulk::mach::os_workgroup *)&v16, &v21);
  started = caulk::ipc::synchronous_messenger::eventlink_receiver::start_handshake(v2, v3);
  v18 = started;
  v19 = BYTE4(started);
  caulk::expected<BOOL,int>::swap((char *)&v18, v4);
  if (v4[4])
  {
    caulk::expected<BOOL,int>::value((uint64_t)v4);
    v9 = *v4 != 0;
  }
  else
  {
    v9 = 0;
  }
  MEMORY[0x20BCFA1F0](*v5);
  if (v9)
    caulk::ipc::synchronous_messenger::eventlink_receiver::message_loop(v2, v10);
  if (!*(_BYTE *)(v2 + 185))
    caulk::ipc::synchronous_messenger::eventlink_receiver::stop_handshake(v2);
  if (!v22)
    caulk::mach::os_workgroup::leave((uint64_t)v20[1], &v21);
  v11 = *(_QWORD *)(v2 + 168);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 48))(v11);
  caulk::mach::os_eventlink::dissociate((caulk::mach::os_eventlink *)(v2 + 64));
  MEMORY[0x20BCFA1F0](*(unsigned int *)(v2 + 72));
  v16 = &off_24BF2E020;
  caulk::mach::details::release_os_object(v17, v12);
  std::unique_ptr<std::tuple<caulk::thread::attributes,caulk::ipc::synchronous_messenger::semaphore_receiver::start(double,caulk::thread::attributes const&,caulk::mach::os_workgroup)::$_0,std::tuple<>>>::~unique_ptr[abi:ne180100](&v15, v13);
  return 0;
}

void sub_2065DB014(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x2065DAFB0);
  }
  _Unwind_Resume(exception_object);
}

void caulk::ipc::synchronous_messenger::eventlink_receiver::stop(caulk::ipc::synchronous_messenger::eventlink_receiver *this, double a2)
{
  caulk::mach::os_eventlink *v2;
  void *__p;
  char v4;

  if (*((_QWORD *)this + 2))
  {
    if (*((_QWORD *)this + 3))
    {
      if (*((_QWORD *)this + 5))
      {
        if (*((_QWORD *)this + 6))
        {
          v2 = (caulk::ipc::synchronous_messenger::eventlink_receiver *)((char *)this + 64);
          if (*((_QWORD *)this + 8))
          {
            *((_BYTE *)this + 184) = 1;
            caulk::mach::semaphore::timed_wait_or_error((semaphore_t *)this + 18, a2, 1);
            std::string::basic_string[abi:ne180100]<0>(&__p, "eventlink_receiver::stop: wait out the eventlink to clear things out for next time R-1");
            caulk::ipc::synchronous_messenger::details::drain_eventlink(v2);
            if (v4 < 0)
              operator delete(__p);
          }
        }
      }
    }
  }
}

void caulk::ipc::synchronous_messenger::eventlink_receiver::simulate_crash_for_testing(caulk::ipc::synchronous_messenger::eventlink_receiver *this, double a2)
{
  caulk::mach::os_eventlink *v2;
  void *__p;
  char v4;

  if (*((_QWORD *)this + 2))
  {
    if (*((_QWORD *)this + 3))
    {
      if (*((_QWORD *)this + 5))
      {
        if (*((_QWORD *)this + 6))
        {
          v2 = (caulk::ipc::synchronous_messenger::eventlink_receiver *)((char *)this + 64);
          if (*((_QWORD *)this + 8))
          {
            *((_WORD *)this + 92) = 257;
            caulk::mach::semaphore::timed_wait_or_error((semaphore_t *)this + 18, a2, 257);
            std::string::basic_string[abi:ne180100]<0>(&__p, "eventlink_receiver::simulate_crash_for_testing: wait out the eventlink to clear things out for next time R-1");
            caulk::ipc::synchronous_messenger::details::drain_eventlink(v2);
            if (v4 < 0)
              operator delete(__p);
          }
        }
      }
    }
  }
}

void *caulk::alloc::malloc_allocator::allocate(caulk::alloc::malloc_allocator *this, size_t size, size_t alignment)
{
  void *memptr;

  if (alignment <= 0x10)
    return malloc_type_malloc(size, 0x8D4B67A0uLL);
  if (alignment > 0x1000)
    return malloc_type_valloc(size, 0xBAC9A18BuLL);
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, alignment, size, 0x68A64878uLL))
    return 0;
  else
    return memptr;
}

void caulk::alloc::malloc_allocator::deallocate(int a1, void *a2)
{
  free(a2);
}

_QWORD *caulk::alloc::malloc_allocator::describe(caulk::alloc::malloc_allocator *this, caulk::alloc::base_allocator::formatter *a2)
{
  caulk::alloc::base_allocator::formatter::emit_string(a2, "malloc_allocator @");
  caulk::alloc::base_allocator::formatter::check_line_start(a2);
  std::ostream::operator<<();
  return caulk::alloc::base_allocator::formatter::emit_string(a2, "\n");
}

void std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_1,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_1>,void ()(unsigned long,unsigned long)>::~__func()
{
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_1,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_1>,void ()(unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BF2D728;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_1,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_1>,void ()(unsigned long,unsigned long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BF2D728;
  a2[1] = v2;
  return result;
}

unint64_t *std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_1,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_1>,void ()(unsigned long,unsigned long)>::operator()(unint64_t *result, uint64_t a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unsigned __int8 *v6;
  unsigned __int8 v7;
  unsigned int *v8;
  unsigned int v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int v15;

  v3 = *a3;
  v4 = result[1];
  v5 = atomic_load((unint64_t *)(v4 + 160));
  if (v5 <= v3)
    return result;
  v6 = (unsigned __int8 *)(v4 + 112);
  do
    v7 = __ldaxr(v6);
  while (__stlxr(1u, v6));
  if ((v7 & 1) != 0)
    return result;
  result = **(unint64_t ***)(v4 + 104);
  v8 = (unsigned int *)(v4 + 96);
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 | 1, v8));
  if (v9)
  {
    __break(1u);
    return result;
  }
  v10 = v4 + 80;
  v11 = result + 1;
  v12 = result[1];
  atomic_store(v12, (unint64_t *)(v4 + 88));
  v13 = __ldaxr(result + 1);
  if (v13 != v12)
  {
    __clrex();
LABEL_13:
    while (1)
    {
      atomic_store(v13, (unint64_t *)(v4 + 88));
      v14 = __ldaxr(v11);
      if (v14 != v13)
        break;
      if (__stlxr(v10, v11))
        goto LABEL_17;
      v15 = 1;
LABEL_18:
      v13 = v14;
      if (v15)
        goto LABEL_19;
    }
    __clrex();
LABEL_17:
    v15 = 0;
    goto LABEL_18;
  }
  if (__stlxr(v10, v11))
    goto LABEL_13;
LABEL_19:
  __dmb(0xBu);
  return (unint64_t *)(*(uint64_t (**)(unint64_t *))(*result + 16))(result);
}

uint64_t std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_1,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_1>,void ()(unsigned long,unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc23page_cache_monitor_implC1ERNS0_18page_cache_monitorERNS_16shared_ptr_mutexINS_4mach11unfair_lockEEEmE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_1,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_1>,void ()(unsigned long,unsigned long)>::target_type()
{
}

_QWORD *std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0>,void ()(void)>::~__func(_QWORD *a1)
{
  std::__shared_weak_count *v2;

  *a1 = &off_24BF2D6D0;
  v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return a1;
}

void std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0>,void ()(void)>::~__func(_QWORD *a1)
{
  std::__shared_weak_count *v1;

  *a1 = &off_24BF2D6D0;
  v1 = (std::__shared_weak_count *)a1[2];
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
  JUMPOUT(0x20BCF9C08);
}

_QWORD *std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  result = operator new(0x18uLL);
  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *result = &off_24BF2D6D0;
  result[1] = v4;
  result[2] = v3;
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return result;
}

uint64_t std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0>,void ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  v3 = *(_QWORD *)(result + 8);
  v2 = *(_QWORD *)(result + 16);
  *a2 = &off_24BF2D6D0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 16);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  return result;
}

void std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0>,void ()(void)>::destroy_deallocate(_QWORD *__p)
{
  std::__shared_weak_count *v2;

  v2 = (std::__shared_weak_count *)__p[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  operator delete(__p);
}

void std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1;
  uint64_t **v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;

  caulk::lifetime_guard<caulk::alloc::page_cache_monitor,caulk::shared_ptr_mutex<caulk::mach::unfair_lock>>::weak_ref::lock(&v6, (uint64_t *)(a1 + 8));
  v1 = v6;
  if (v6)
  {
    os_unfair_lock_lock(*(os_unfair_lock_t *)(v6 + 24));
    v2 = *(uint64_t ***)(v1 + 40);
    if (v2)
      caulk::alloc::page_cache_monitor_impl::evaluate_reservations(v2);
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(v1 + 24));
  }
  v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_2065DB5DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v13;

  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v10 + 24));
  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN5caulk5alloc23page_cache_monitor_implC1ERNS0_18page_cache_monitorERNS_16shared_ptr_mutexINS_4mach11unfair_lockEEEmE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0,std::allocator<caulk::alloc::page_cache_monitor_impl::page_cache_monitor_impl(caulk::alloc::page_cache_monitor &,caulk::shared_ptr_mutex<caulk::mach::unfair_lock> &,unsigned long)::$_0>,void ()(void)>::target_type()
{
}

void std::__shared_ptr_emplace<caulk::details::lifetime_guard_base<caulk::alloc::page_cache_monitor>::control_block,std::allocator<caulk::details::lifetime_guard_base<caulk::alloc::page_cache_monitor>::control_block>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2E620;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<caulk::details::lifetime_guard_base<caulk::alloc::page_cache_monitor>::control_block,std::allocator<caulk::details::lifetime_guard_base<caulk::alloc::page_cache_monitor>::control_block>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2E620;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BCF9C08);
}

void std::__shared_ptr_emplace<caulk::details::lifetime_guard_base<caulk::alloc::page_cache_monitor>::control_block,std::allocator<caulk::details::lifetime_guard_base<caulk::alloc::page_cache_monitor>::control_block>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  std::__shared_weak_count *v5;

  __dmb(0xBu);
  v2 = *(_QWORD *)(a1 + 40);
  v3 = (unsigned int *)(v2 + 32);
  do
    v4 = __ldxr(v3);
  while (__stlxr(v4 + 1, v3));
  if ((v4 & 0x80000000) != 0)
    MEMORY[0x20BCFA1F0](*(unsigned int *)(v2 + 24));
  v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

void std::__shared_ptr_emplace<caulk::alloc::preallocation_reservation>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2E5E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<caulk::alloc::preallocation_reservation>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24BF2E5E8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BCF9C08);
}

void std::__shared_ptr_emplace<caulk::alloc::preallocation_reservation>::__on_zero_shared(_QWORD *a1)
{
  uint64_t v2;
  uint64_t **v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;

  caulk::lifetime_guard<caulk::alloc::page_cache_monitor,caulk::shared_ptr_mutex<caulk::mach::unfair_lock>>::weak_ref::lock(&v17, a1 + 5);
  v2 = v17;
  if (v17)
  {
    os_unfair_lock_lock(*(os_unfair_lock_t *)(v17 + 24));
    v3 = *(uint64_t ***)(v2 + 40);
    if (v3)
    {
      v4 = v3[21];
      v5 = v3[22];
      while (v4 != v5)
      {
        v6 = v4[1];
        if (!v6 || *(_QWORD *)(v6 + 8) == -1)
        {
          if (v4 != v5)
          {
            v7 = v4 + 2;
            if (v4 + 2 != v5)
            {
              do
              {
                v8 = v7[1];
                if (v8 && *(_QWORD *)(v8 + 8) != -1)
                {
                  v9 = *v7;
                  *v7 = 0;
                  v7[1] = 0;
                  v10 = (std::__shared_weak_count *)v4[1];
                  *v4 = v9;
                  v4[1] = v8;
                  if (v10)
                    std::__shared_weak_count::__release_weak(v10);
                  v4 += 2;
                }
                v7 += 2;
              }
              while (v7 != v5);
              v5 = v3[22];
            }
          }
          if (v4 != v5)
          {
            while (v5 != v4)
            {
              v11 = (std::__shared_weak_count *)*(v5 - 1);
              if (v11)
                std::__shared_weak_count::__release_weak(v11);
              v5 -= 2;
            }
            v3[22] = v4;
          }
          break;
        }
        v4 += 2;
      }
      caulk::alloc::page_cache_monitor_impl::evaluate_reservations(v3);
    }
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(v2 + 24));
  }
  v12 = v18;
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = (std::__shared_weak_count *)a1[6];
  if (v15)
    std::__shared_weak_count::__release_weak(v15);
  v16 = (std::__shared_weak_count *)a1[4];
  if (v16)
    std::__shared_weak_count::__release_weak(v16);
}

void sub_2065DB900(void *a1)
{
  uint64_t v1;

  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v1 + 24));
  __clang_call_terminate(a1);
}

uint64_t caulk::mach::semaphore::semaphore(uint64_t this, int a2)
{
  *(_DWORD *)this = a2;
  *(_BYTE *)(this + 4) = 0;
  return this;
}

{
  *(_DWORD *)this = a2;
  *(_BYTE *)(this + 4) = 0;
  return this;
}

uint64_t caulk::mach::semaphore::semaphore(uint64_t result, int *a2)
{
  int v2;

  *(_DWORD *)result = 0;
  *(_BYTE *)(result + 4) = 0;
  v2 = *a2;
  *a2 = 0;
  *(_DWORD *)result = v2;
  LOBYTE(v2) = *((_BYTE *)a2 + 4);
  *((_BYTE *)a2 + 4) = 0;
  *(_BYTE *)(result + 4) = v2;
  return result;
}

{
  int v2;

  *(_DWORD *)result = 0;
  *(_BYTE *)(result + 4) = 0;
  v2 = *a2;
  *a2 = 0;
  *(_DWORD *)result = v2;
  LOBYTE(v2) = *((_BYTE *)a2 + 4);
  *((_BYTE *)a2 + 4) = 0;
  *(_BYTE *)(result + 4) = v2;
  return result;
}

uint64_t caulk::mach::semaphore::operator=(uint64_t a1, int *a2)
{
  int v4;

  if (*(_BYTE *)(a1 + 4) && *(_DWORD *)a1)
    semaphore_destroy(*MEMORY[0x24BDAEC58], *(_DWORD *)a1);
  v4 = *a2;
  *a2 = 0;
  *(_DWORD *)a1 = v4;
  LOBYTE(v4) = *((_BYTE *)a2 + 4);
  *((_BYTE *)a2 + 4) = 0;
  *(_BYTE *)(a1 + 4) = v4;
  return a1;
}

BOOL caulk::mach::semaphore::signal(caulk::mach::semaphore *this)
{
  return MEMORY[0x20BCFA1F0](*(unsigned int *)this) == 0;
}

unint64_t caulk::mach::semaphore::signal_or_error(caulk::mach::semaphore *this)
{
  unsigned int v1;

  v1 = MEMORY[0x20BCFA1F0](*(unsigned int *)this);
  return v1 | ((unint64_t)(v1 == 0) << 32);
}

unint64_t caulk::mach::semaphore::signal_all_or_error(caulk::mach::semaphore *this)
{
  unsigned int v1;

  v1 = MEMORY[0x20BCFA1FC](*(unsigned int *)this);
  return v1 | ((unint64_t)(v1 == 0) << 32);
}

BOOL caulk::mach::semaphore::timed_wait@<W0>(semaphore_t *this@<X0>, double a2@<D0>, uint64_t a3@<X8>)
{
  unint64_t v4;
  mach_timespec_t v5;
  const char *v6;
  int v7;

  LODWORD(a3) = vcvtmd_u64_f64(a2);
  v4 = a3 | ((unint64_t)(int)((a2 - floor(a2)) * 1000000000.0) << 32);
  do
  {
    v5 = (mach_timespec_t)v4;
    v6 = (const char *)semaphore_timedwait(*this, v5);
  }
  while ((_DWORD)v6 == 14);
  v7 = (int)v6;
  if ((_DWORD)v6 == 49)
    return 0;
  caulk::mach::throw_if_mach_error((uint64_t)"semaphore::timed_wait failed", v6);
  return v7 == 0;
}

BOOL caulk::mach::semaphore::wait(caulk::mach::semaphore *this)
{
  int v2;

  do
    v2 = MEMORY[0x20BCFA220](*(unsigned int *)this);
  while (v2 == 14);
  return v2 == 0;
}

uint64_t caulk::mach::semaphore::wait_or_error(caulk::mach::semaphore *this)
{
  uint64_t result;

  do
    LODWORD(result) = MEMORY[0x20BCFA220](*(unsigned int *)this);
  while ((_DWORD)result == 14);
  if ((_DWORD)result)
    return result;
  else
    return 0x100000000;
}

BOOL caulk::mach::semaphore::timed_wait_signal@<W0>(semaphore_t *this@<X0>, semaphore_t *a2@<X1>, double a3@<D0>, uint64_t a4@<X8>)
{
  unint64_t v6;
  mach_timespec_t v7;
  const char *v8;
  int v9;

  LODWORD(a4) = vcvtmd_u64_f64(a3);
  v6 = a4 | ((unint64_t)(int)((a3 - floor(a3)) * 1000000000.0) << 32);
  do
  {
    v7 = (mach_timespec_t)v6;
    v8 = (const char *)semaphore_timedwait_signal(*this, *a2, v7);
  }
  while ((_DWORD)v8 == 14);
  v9 = (int)v8;
  if ((_DWORD)v8 == 49)
    return 0;
  caulk::mach::throw_if_mach_error((uint64_t)"semaphore::timed_wait_signal failed", v8);
  return v9 == 0;
}

uint64_t caulk::mach::semaphore::timed_wait_signal_or_error@<X0>(semaphore_t *this@<X0>, semaphore_t *a2@<X1>, double a3@<D0>, uint64_t a4@<X8>)
{
  unint64_t v6;
  mach_timespec_t v7;
  kern_return_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  int v13;
  unsigned int v14;

  LODWORD(a4) = vcvtmd_u64_f64(a3);
  v6 = a4 | ((unint64_t)(int)((a3 - floor(a3)) * 1000000000.0) << 32);
  do
  {
    v7 = (mach_timespec_t)v6;
    v8 = semaphore_timedwait_signal(*this, *a2, v7);
  }
  while (v8 == 14);
  v9 = 0x100000000;
  v10 = 0x100000000;
  v11 = v8 & 0xFFFFFF00;
  v12 = v8;
  if (v8 == 49)
    v12 = 0;
  else
    v10 = 0;
  if (v8 == 49)
    v11 = 0;
  if (v8)
  {
    v9 = v10;
    v13 = v12;
  }
  else
  {
    v13 = 1;
  }
  if (v8)
    v14 = v11;
  else
    v14 = 0;
  return v9 | v14 | v13;
}

BOOL caulk::mach::semaphore::wait_signal(caulk::mach::semaphore *this, caulk::mach::semaphore *a2)
{
  int v4;

  do
    v4 = MEMORY[0x20BCFA22C](*(unsigned int *)this, *(unsigned int *)a2);
  while (v4 == 14);
  return v4 == 0;
}

uint64_t caulk::mach::semaphore::wait_signal_or_error(caulk::mach::semaphore *this, caulk::mach::semaphore *a2)
{
  uint64_t result;

  do
    LODWORD(result) = MEMORY[0x20BCFA22C](*(unsigned int *)this, *(unsigned int *)a2);
  while ((_DWORD)result == 14);
  if ((_DWORD)result)
    return result;
  else
    return 0x100000000;
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x24BDBC298](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x24BDBC2A8](cf);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x24BDBC4D0](theString1, theString2, compareOptions);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x24BDBC558](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x24BDBC568](alloc, cStr, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x24BDBC610](theString, *(_QWORD *)&encoding);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x24BDAC780](exception_object);
}

const char *__cdecl std::runtime_error::what(const std::runtime_error *this)
{
  return (const char *)MEMORY[0x24BEDA978](this);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x24BEDAA60](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x24BEDAA70](this);
}

const char *__cdecl std::exception::what(const std::exception *this)
{
  return (const char *)MEMORY[0x24BEDAA88](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x24BEDAAA8](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x24BEDAB30](this, a2);
}

{
  return (std::runtime_error *)MEMORY[0x24BEDAB48](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::runtime_error *a2)
{
  return (std::runtime_error *)MEMORY[0x24BEDAB58](this, a2);
}

void std::runtime_error::~runtime_error(std::runtime_error *this)
{
  MEMORY[0x24BEDAB68](this);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x24BEDABB0](this);
}

void std::this_thread::sleep_for (const std::chrono::nanoseconds *__ns)
{
  MEMORY[0x24BEDABD8](__ns);
}

void std::string::__grow_by_and_replace(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add, const std::string::value_type *__p_new_stuff)
{
  MEMORY[0x24BEDAC08](this, __old_cap, __delta_cap, __old_sz, __n_copy, __n_del, __n_add, __p_new_stuff);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x24BEDAC40](this, __s, __n);
}

std::system_error *__cdecl std::system_error::system_error(std::system_error *this, int __ev, const std::error_category *__ecat, const char *__what_arg)
{
  return (std::system_error *)MEMORY[0x24BEDADB0](this, *(_QWORD *)&__ev, __ecat, __what_arg);
}

void std::system_error::~system_error(std::system_error *this)
{
  MEMORY[0x24BEDADC8](this);
}

uint64_t std::filebuf::open()
{
  return MEMORY[0x24BEDADD8]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x24BEDADF0]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x24BEDADF8]();
}

uint64_t std::ostream::put()
{
  return MEMORY[0x24BEDAEE0]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x24BEDAEE8]();
}

uint64_t std::ostream::write()
{
  return MEMORY[0x24BEDAEF0]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x24BEDAEF8]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x24BEDAF00]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x24BEDAF10]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x24BEDAF18]();
}

{
  return MEMORY[0x24BEDAF48]();
}

{
  return MEMORY[0x24BEDAF50]();
}

{
  return MEMORY[0x24BEDAF60]();
}

{
  return MEMORY[0x24BEDAF80]();
}

void std::error_category::~error_category(std::error_category *this)
{
  MEMORY[0x24BEDB028](this);
}

const std::error_category *std::generic_category(void)
{
  return (const std::error_category *)MEMORY[0x24BEDB0B8]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB180](this);
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x24BEDB188](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB190](this);
}

void std::pmr::memory_resource::~memory_resource(std::pmr::memory_resource *this)
{
  MEMORY[0x24BEDB1D8](this);
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x24BEDB448](this);
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
  MEMORY[0x24BEDB500](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x24BEDB518](this, __sb);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x24BEDB530](this, *(_QWORD *)&__state);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x24BEDB5E8]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x24BEDB608](retstr, *(_QWORD *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return (std::string *)MEMORY[0x24BEDB610](retstr, *(_QWORD *)&__val);
}

uint64_t std::operator+<char>()
{
  return MEMORY[0x24BEDB638]();
}

std::bad_alloc *__cdecl std::bad_alloc::bad_alloc(std::bad_alloc *this)
{
  return (std::bad_alloc *)MEMORY[0x24BEDB660](this);
}

void std::exception::~exception(std::exception *this)
{
  MEMORY[0x24BEDB688](this);
}

void std::terminate(void)
{
  MEMORY[0x24BEDB6C0]();
}

void operator delete(void *__p)
{
  off_24BF2BDB8(__p);
}

uint64_t operator delete()
{
  return off_24BF2BDC0();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_24BF2BDC8(__sz);
}

uint64_t operator new()
{
  return off_24BF2BDD0();
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x24BEDB8F8](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x24BEDB910](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x24BEDB928]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x24BEDB930](a1);
}

void __cxa_guard_abort(__guard *a1)
{
  MEMORY[0x24BEDB940](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x24BEDB948](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x24BEDB950](a1);
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x24BEDB960](a1, lptinfo, a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x24BDAC7D0]();
}

uint64_t _os_assert_log()
{
  return MEMORY[0x24BDACB40]();
}

uint64_t _os_crash()
{
  return MEMORY[0x24BDACB50]();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB80](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB88](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB90](dso, log, type, format, buf, *(_QWORD *)&size);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

void dispatch_assert_queue_not_V2(dispatch_queue_t queue)
{
  MEMORY[0x24BDADCB8](queue);
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x24BDADCD8](queue, context, work);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x24BDADDA8](identifier, flags);
}

const char *__cdecl dispatch_queue_get_label(dispatch_queue_t queue)
{
  return (const char *)MEMORY[0x24BDADEE0](queue);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x24BDADF10](object);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x24BDADF18](object);
}

void dispatch_retain(dispatch_object_t object)
{
  MEMORY[0x24BDADF20](object);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x24BDADF68](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x24BDADF70](type, handle, mask, queue);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x24BDADFB0](source, handler);
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
  MEMORY[0x24BDADFD0](source, start, interval, leeway);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADFE8](queue, block);
}

void dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x24BDADFF0](queue, context, work);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x24BDADFF8](when, delta);
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

pid_t getpid(void)
{
  return MEMORY[0x24BDAE6D0]();
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x24BDAEB30]();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return (char *)MEMORY[0x24BDAEB58](*(_QWORD *)&error_value);
}

mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
  return MEMORY[0x24BDAEB80](msg, *(_QWORD *)&option, *(_QWORD *)&send_size, *(_QWORD *)&rcv_size, *(_QWORD *)&rcv_name, *(_QWORD *)&timeout, *(_QWORD *)&notify);
}

kern_return_t mach_port_allocate(ipc_space_t task, mach_port_right_t right, mach_port_name_t *name)
{
  return MEMORY[0x24BDAEBA0](*(_QWORD *)&task, *(_QWORD *)&right, name);
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x24BDAEBB0](*(_QWORD *)&task, *(_QWORD *)&name);
}

kern_return_t mach_port_insert_right(ipc_space_t task, mach_port_name_t name, mach_port_t poly, mach_msg_type_name_t polyPoly)
{
  return MEMORY[0x24BDAEBE8](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&poly, *(_QWORD *)&polyPoly);
}

kern_return_t mach_port_mod_refs(ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  return MEMORY[0x24BDAEBF8](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&right, *(_QWORD *)&delta);
}

int madvise(void *a1, size_t a2, int a3)
{
  return MEMORY[0x24BDAED00](a1, a2, *(_QWORD *)&a3);
}

malloc_zone_t *__cdecl malloc_create_zone(vm_size_t start_size, unsigned int flags)
{
  return (malloc_zone_t *)MEMORY[0x24BDAED10](start_size, *(_QWORD *)&flags);
}

void malloc_destroy_zone(malloc_zone_t *zone)
{
  MEMORY[0x24BDAED28](zone);
}

const char *__cdecl malloc_get_zone_name(malloc_zone_t *zone)
{
  return (const char *)MEMORY[0x24BDAED30](zone);
}

void malloc_set_zone_name(malloc_zone_t *zone, const char *name)
{
  MEMORY[0x24BDAED58](zone, name);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED78](size, type_id);
}

int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return MEMORY[0x24BDAED80](memptr, alignment, size, type_id);
}

void *__cdecl malloc_type_valloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED90](size, type_id);
}

void *__cdecl malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAEDA0](zone, size, type_id);
}

void *__cdecl malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAEDA8](zone, alignment, size, type_id);
}

void *__cdecl malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAEDB8](zone, size, type_id);
}

void malloc_zone_free(malloc_zone_t *zone, void *ptr)
{
  MEMORY[0x24BDAEDC0](zone, ptr);
}

void malloc_zone_register(malloc_zone_t *zone)
{
  MEMORY[0x24BDAEDC8](zone);
}

void malloc_zone_unregister(malloc_zone_t *zone)
{
  MEMORY[0x24BDAEDD0](zone);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

int mlock(const void *a1, size_t a2)
{
  return MEMORY[0x24BDAEFA0](a1, a2);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x24BDAEFA8](a1, a2, *(_QWORD *)&a3, *(_QWORD *)&a4, *(_QWORD *)&a5, a6);
}

int mprotect(void *a1, size_t a2, int a3)
{
  return MEMORY[0x24BDAEFC8](a1, a2, *(_QWORD *)&a3);
}

int munlock(const void *a1, size_t a2)
{
  return MEMORY[0x24BDAEFE8](a1, a2);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x24BDAEFF0](a1, a2);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x24BDAF170](name, out_token, queue, handler);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x24BEDCF88]();
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x24BEDCFE8]();
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x24BEDD2A8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD2B0](a1);
}

uint64_t os_eventlink_activate()
{
  return MEMORY[0x24BDAF300]();
}

uint64_t os_eventlink_associate()
{
  return MEMORY[0x24BDAF308]();
}

uint64_t os_eventlink_create()
{
  return MEMORY[0x24BDAF318]();
}

uint64_t os_eventlink_create_with_port()
{
  return MEMORY[0x24BDAF320]();
}

uint64_t os_eventlink_disassociate()
{
  return MEMORY[0x24BDAF328]();
}

uint64_t os_eventlink_extract_remote_port()
{
  return MEMORY[0x24BDAF330]();
}

uint64_t os_eventlink_signal()
{
  return MEMORY[0x24BDAF338]();
}

uint64_t os_eventlink_signal_and_wait()
{
  return MEMORY[0x24BDAF340]();
}

uint64_t os_eventlink_signal_and_wait_until()
{
  return MEMORY[0x24BDAF348]();
}

uint64_t os_eventlink_wait()
{
  return MEMORY[0x24BDAF350]();
}

uint64_t os_eventlink_wait_until()
{
  return MEMORY[0x24BDAF358]();
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x24BDAF368](subsystem, category);
}

uint64_t os_log_pack_send()
{
  return MEMORY[0x24BDAF378]();
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x24BDAF398](oslog, type);
}

void os_release(void *object)
{
  MEMORY[0x24BDAF3F0](object);
}

void *__cdecl os_retain(void *object)
{
  return (void *)MEMORY[0x24BDAF3F8](object);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  MEMORY[0x24BDAF460](lock);
}

BOOL os_unfair_lock_trylock(os_unfair_lock_t lock)
{
  return MEMORY[0x24BDAF478](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x24BDAF488](lock);
}

uint64_t os_unfair_recursive_lock_lock_with_options()
{
  return MEMORY[0x24BDAF490]();
}

uint64_t os_unfair_recursive_lock_unlock()
{
  return MEMORY[0x24BDAF4A8]();
}

uint64_t os_workgroup_attr_set_flags()
{
  return MEMORY[0x24BDAF500]();
}

uint64_t os_workgroup_attr_set_interval_type()
{
  return MEMORY[0x24BDAF508]();
}

int os_workgroup_copy_port(os_workgroup_t wg, mach_port_t *mach_port_out)
{
  return MEMORY[0x24BDAF518](wg, mach_port_out);
}

uint64_t os_workgroup_create()
{
  return MEMORY[0x24BDAF520]();
}

os_workgroup_t os_workgroup_create_with_port(const char *name, mach_port_t mach_port)
{
  return (os_workgroup_t)MEMORY[0x24BDAF528](name, *(_QWORD *)&mach_port);
}

uint64_t os_workgroup_create_with_workload_id_and_port()
{
  return MEMORY[0x24BDAF530]();
}

uint64_t os_workgroup_interval_create()
{
  return MEMORY[0x24BDAF538]();
}

uint64_t os_workgroup_interval_create_with_workload_id()
{
  return MEMORY[0x24BDAF540]();
}

int os_workgroup_interval_finish(os_workgroup_interval_t wg, os_workgroup_interval_data_t data)
{
  return MEMORY[0x24BDAF548](wg, data);
}

int os_workgroup_interval_start(os_workgroup_interval_t wg, uint64_t start, uint64_t deadline, os_workgroup_interval_data_t data)
{
  return MEMORY[0x24BDAF550](wg, start, deadline, data);
}

int os_workgroup_interval_update(os_workgroup_interval_t wg, uint64_t deadline, os_workgroup_interval_data_t data)
{
  return MEMORY[0x24BDAF558](wg, deadline, data);
}

uint64_t os_workgroup_join_self()
{
  return MEMORY[0x24BDAF568]();
}

uint64_t os_workgroup_leave_self()
{
  return MEMORY[0x24BDAF578]();
}

void perror(const char *a1)
{
  MEMORY[0x24BDAF5A8](a1);
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return MEMORY[0x24BDAF6F8](*(_QWORD *)&pid, *(_QWORD *)&flavor, arg, buffer, *(_QWORD *)&buffersize);
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x24BDAF778](a1);
}

int pthread_attr_getschedparam(const pthread_attr_t *a1, sched_param *a2)
{
  return MEMORY[0x24BDAF780](a1, a2);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x24BDAF790](a1);
}

int pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class, int __relative_priority)
{
  return MEMORY[0x24BDAF798](__attr, *(_QWORD *)&__qos_class, *(_QWORD *)&__relative_priority);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x24BDAF7A0](a1, *(_QWORD *)&a2);
}

int pthread_attr_setschedparam(pthread_attr_t *a1, const sched_param *a2)
{
  return MEMORY[0x24BDAF7B0](a1, a2);
}

int pthread_attr_setschedpolicy(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x24BDAF7B8](a1, *(_QWORD *)&a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x24BDAF818](a1, a2, a3, a4);
}

int pthread_detach(pthread_t a1)
{
  return MEMORY[0x24BDAF820](a1);
}

int pthread_get_qos_class_np(pthread_t __pthread, qos_class_t *__qos_class, int *__relative_priority)
{
  return MEMORY[0x24BDAF838](__pthread, __qos_class, __relative_priority);
}

int pthread_getname_np(pthread_t a1, char *a2, size_t a3)
{
  return MEMORY[0x24BDAF850](a1, a2, a3);
}

int pthread_join(pthread_t a1, void **a2)
{
  return MEMORY[0x24BDAF880](a1, a2);
}

mach_port_t pthread_mach_thread_np(pthread_t a1)
{
  return MEMORY[0x24BDAF8A8](a1);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x24BDAF978]();
}

int pthread_set_qos_class_self_np(qos_class_t __qos_class, int __relative_priority)
{
  return MEMORY[0x24BDAF980](*(_QWORD *)&__qos_class, *(_QWORD *)&__relative_priority);
}

int pthread_setname_np(const char *a1)
{
  return MEMORY[0x24BDAF998](a1);
}

int sched_yield(void)
{
  return MEMORY[0x24BDAFC68]();
}

kern_return_t semaphore_create(task_t task, semaphore_t *semaphore, int policy, int value)
{
  return MEMORY[0x24BDAFCA8](*(_QWORD *)&task, semaphore, *(_QWORD *)&policy, *(_QWORD *)&value);
}

kern_return_t semaphore_destroy(task_t task, semaphore_t semaphore)
{
  return MEMORY[0x24BDAFCB0](*(_QWORD *)&task, *(_QWORD *)&semaphore);
}

kern_return_t semaphore_signal(semaphore_t semaphore)
{
  return MEMORY[0x24BDAFCB8](*(_QWORD *)&semaphore);
}

kern_return_t semaphore_signal_all(semaphore_t semaphore)
{
  return MEMORY[0x24BDAFCC0](*(_QWORD *)&semaphore);
}

kern_return_t semaphore_timedwait(semaphore_t semaphore, mach_timespec_t wait_time)
{
  return ((uint64_t (*)(_QWORD, _QWORD))MEMORY[0x24BDAFCC8])(*(_QWORD *)&semaphore, wait_time);
}

kern_return_t semaphore_timedwait_signal(semaphore_t wait_semaphore, semaphore_t signal_semaphore, mach_timespec_t wait_time)
{
  return ((uint64_t (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x24BDAFCD0])(*(_QWORD *)&wait_semaphore, *(_QWORD *)&signal_semaphore, wait_time);
}

kern_return_t semaphore_wait(semaphore_t semaphore)
{
  return MEMORY[0x24BDAFCD8](*(_QWORD *)&semaphore);
}

kern_return_t semaphore_wait_signal(semaphore_t wait_semaphore, semaphore_t signal_semaphore)
{
  return MEMORY[0x24BDAFCE0](*(_QWORD *)&wait_semaphore, *(_QWORD *)&signal_semaphore);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x24BDAFEE8](__s, *(_QWORD *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x24BDAFEF0](__s1, __s2);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x24BDB00F8](a1, *(_QWORD *)&a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x24BDB0100](a1, a2, a3, a4, a5);
}

kern_return_t thread_info(thread_inspect_t target_act, thread_flavor_t flavor, thread_info_t thread_info_out, mach_msg_type_number_t *thread_info_outCnt)
{
  return MEMORY[0x24BDB0210](*(_QWORD *)&target_act, *(_QWORD *)&flavor, thread_info_out, thread_info_outCnt);
}

kern_return_t thread_policy_set(thread_act_t thread, thread_policy_flavor_t flavor, thread_policy_t policy_info, mach_msg_type_number_t policy_infoCnt)
{
  return MEMORY[0x24BDB0220](*(_QWORD *)&thread, *(_QWORD *)&flavor, policy_info, *(_QWORD *)&policy_infoCnt);
}

kern_return_t vm_region_64(vm_map_read_t target_task, vm_address_t *address, vm_size_t *size, vm_region_flavor_t flavor, vm_region_info_t info, mach_msg_type_number_t *infoCnt, mach_port_t *object_name)
{
  return MEMORY[0x24BDB03F0](*(_QWORD *)&target_task, address, size, *(_QWORD *)&flavor, info, infoCnt, object_name);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x24BDB08C0](keys, values, count);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x24BDB0968](xdict, key);
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
  MEMORY[0x24BDB09E0](xdict, key, value);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x24BDB0A70](object);
}

uint64_t xpc_mach_send_copy_right()
{
  return MEMORY[0x24BDB0A90]();
}

uint64_t xpc_mach_send_create()
{
  return MEMORY[0x24BDB0A98]();
}

xpc_object_t xpc_shmem_create(void *region, size_t length)
{
  return (xpc_object_t)MEMORY[0x24BDB0B60](region, length);
}

size_t xpc_shmem_map(xpc_object_t xshmem, void **region)
{
  return MEMORY[0x24BDB0B70](xshmem, region);
}

