BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::tensor::ExtractOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::tensor::ExtractOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::ExtractOp::getAsmResultNames((uint64_t)&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ExtractOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ExtractOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ExtractOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::tensor::ExtractOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::tensor::ExtractOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::tensor::ExtractOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::tensor::ExtractOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "tensor.extract";
  v16[1] = 14;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int *v13;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::tensor::detail::ExtractOpGenericAdaptorBase::ExtractOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::tensor::ExtractOp::fold((uint64_t)&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8 || a2 - 4 == (unsigned int *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  const char *v209;
  unint64_t v210;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v198;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v210 = 104;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = v8[308];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>]";
      v210 = 97;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[423];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v210 = 86;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[340];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v210 = 95;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[312];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v210 = 99;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[314];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[21];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v32[27] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::tensor::ExtractOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)1))
    return 0;
  v6 = a1;
  if (!mlir::tensor::ExtractOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::tensor::ExtractOp::verify((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::tensor::ExtractOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.extract_slice", 20, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::ExtractSliceOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04CCC8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::tensor::ExtractSliceOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::tensor::ExtractSliceOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                    + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  mlir::MLIRContext *Context;
  uint64_t *v8;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::tensor::ExtractSliceOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::tensor::ExtractSliceOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::MLIRContext *Context;
  uint64_t *v6;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::memref::ReinterpretCastOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::memref::ReinterpretCastOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::getOpPropertyByteSize()
{
  return 40;
}

double mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[1];
    *(_QWORD *)(a3 + 32) = *((_QWORD *)a4 + 4);
    *(_OWORD *)a3 = v4;
    *(_OWORD *)(a3 + 16) = v5;
  }
  else
  {
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)&v4 = 0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  return *(double *)&v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::memref::ReinterpretCastOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::memref::ReinterpretCastOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  return a3[3] == a2[3] && a3[4] == a2[4];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::memref::ReinterpretCastOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::memref::ReinterpretCastOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::ExtractSliceOp::getAsmResultNames((uint64_t)&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::reifyResultShapes;
  v4 = &unk_25451B000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451B000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ReifyRankedShapedTypeOpInterface]";
      v15 = 88;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ReifyRankedShapedTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451B000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[171], v2);
}

uint64_t mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::reifyResultShapes(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::ExtractSliceOp::reifyResultShapes((mlir::memref::ReinterpretCastOp *)&v5, a3, a4);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0xD0uLL, 0x80040B342C78EuLL);
  *v2 = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getOffsetSizeAndStrideStartOperandIndex;
  v2[1] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getArrayAttrMaxRanks;
  v2[2] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getOffsets;
  v2[3] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getSizes;
  v2[4] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getStrides;
  v2[5] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getStaticOffsets;
  v2[6] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getStaticSizes;
  v2[7] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getStaticStrides;
  v2[8] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getMixedOffsets;
  v2[9] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getMixedSizes;
  v2[10] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getMixedStrides;
  v2[11] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::isDynamicOffset;
  v2[12] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::isDynamicSize;
  v2[13] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::isDynamicStride;
  v2[14] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getStaticOffset;
  v2[15] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getStaticSize;
  v2[16] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getStaticStride;
  v2[17] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getIndexOfDynamicOffset;
  v2[18] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getIndexOfDynamicSize;
  v2[19] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getIndexOfDynamicStride;
  v2[20] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getDynamicOffset;
  v2[21] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getDynamicSize;
  v2[22] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getDynamicStride;
  v2[23] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::isSameAs;
  v2[24] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::hasUnitStride;
  v2[25] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::hasZeroOffset;
  v4 = &unk_25451B000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451B000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OffsetSizeAndStrideOpInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OffsetSizeAndStrideOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451B000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[259], v2);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getOffsetSizeAndStrideStartOperandIndex()
{
  return 1;
}

unint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getArrayAttrMaxRanks(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v4;
  unint64_t v5;

  v4 = a2;
  v5 = *(_QWORD *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v4) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v5);
  return v2 | ((unint64_t)v2 << 32);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getOffsets(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::memref::ReinterpretCastOp::getOffsets((mlir::memref::ReinterpretCastOp *)&v3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getSizes(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::memref::ReinterpretCastOp::getSizes((mlir::memref::ReinterpretCastOp *)&v3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getStrides(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::memref::ReinterpretCastOp::getStrides((mlir::memref::ReinterpretCastOp *)&v3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getStaticOffsets(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::memref::ReinterpretCastOp::getStaticOffsets((mlir::memref::ReinterpretCastOp *)&v3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getStaticSizes(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::memref::ReinterpretCastOp::getStaticSizes((mlir::memref::ReinterpretCastOp *)&v3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getStaticStrides(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)&v3);
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getMixedOffsets(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  v2 = a1;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedOffsets((mlir::memref::ReinterpretCastOp *)&v2, a2);
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getMixedSizes(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  v2 = a1;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedSizes((mlir::memref::ReinterpretCastOp *)&v2, a2);
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getMixedStrides(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  v2 = a1;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedStrides((mlir::memref::ReinterpretCastOp *)&v2, a2);
}

BOOL mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::isDynamicOffset(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticOffsets((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3) == 0x8000000000000000;
}

BOOL mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::isDynamicSize(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticSizes((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3) == 0x8000000000000000;
}

BOOL mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::isDynamicStride(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3) == 0x8000000000000000;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getStaticOffset(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticOffsets((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getStaticSize(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticSizes((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getStaticStride(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getIndexOfDynamicOffset(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticOffsets;
  uint64_t v5;
  uint64_t v7;

  v7 = a2;
  StaticOffsets = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticOffsets((mlir::memref::ReinterpretCastOp *)&v7);
  return mlir::detail::getNumDynamicEntriesUpToIdx(StaticOffsets, v5, a3) + 1;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getIndexOfDynamicSize(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticSizes;
  uint64_t v5;
  int NumDynamicEntriesUpToIdx;
  int v7;
  uint64_t v9;

  v9 = a2;
  StaticSizes = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticSizes((mlir::memref::ReinterpretCastOp *)&v9);
  NumDynamicEntriesUpToIdx = mlir::detail::getNumDynamicEntriesUpToIdx(StaticSizes, v5, a3);
  mlir::memref::ReinterpretCastOp::getOffsets((mlir::memref::ReinterpretCastOp *)&v9);
  return (NumDynamicEntriesUpToIdx + v7 + 1);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getIndexOfDynamicStride(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticStrides;
  uint64_t v5;
  int NumDynamicEntriesUpToIdx;
  int v7;
  int v8;
  int v9;
  uint64_t v11;

  v11 = a2;
  StaticStrides = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)&v11);
  NumDynamicEntriesUpToIdx = mlir::detail::getNumDynamicEntriesUpToIdx(StaticStrides, v5, a3);
  mlir::memref::ReinterpretCastOp::getOffsets((mlir::memref::ReinterpretCastOp *)&v11);
  v8 = v7;
  mlir::memref::ReinterpretCastOp::getSizes((mlir::memref::ReinterpretCastOp *)&v11);
  return (v8 + v9 + NumDynamicEntriesUpToIdx + 1);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getDynamicOffset(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticOffsets;
  uint64_t v5;
  int NumDynamicEntriesUpToIdx;
  uint64_t v8;

  v8 = a2;
  StaticOffsets = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticOffsets((mlir::memref::ReinterpretCastOp *)&v8);
  NumDynamicEntriesUpToIdx = mlir::detail::getNumDynamicEntriesUpToIdx(StaticOffsets, v5, a3);
  return *(_QWORD *)(*(_QWORD *)(v8 + 72) + 32 * (NumDynamicEntriesUpToIdx + 1) + 24);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getDynamicSize(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticSizes;
  uint64_t v5;
  int NumDynamicEntriesUpToIdx;
  int v7;
  uint64_t v9;

  v9 = a2;
  StaticSizes = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticSizes((mlir::memref::ReinterpretCastOp *)&v9);
  NumDynamicEntriesUpToIdx = mlir::detail::getNumDynamicEntriesUpToIdx(StaticSizes, v5, a3);
  mlir::memref::ReinterpretCastOp::getOffsets((mlir::memref::ReinterpretCastOp *)&v9);
  return *(_QWORD *)(*(_QWORD *)(v9 + 72) + 32 * (NumDynamicEntriesUpToIdx + v7 + 1) + 24);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::getDynamicStride(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticStrides;
  uint64_t v5;
  int NumDynamicEntriesUpToIdx;
  int v7;
  int v8;
  int v9;
  uint64_t v11;

  v11 = a2;
  StaticStrides = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)&v11);
  NumDynamicEntriesUpToIdx = mlir::detail::getNumDynamicEntriesUpToIdx(StaticStrides, v5, a3);
  mlir::memref::ReinterpretCastOp::getOffsets((mlir::memref::ReinterpretCastOp *)&v11);
  v8 = v7;
  mlir::memref::ReinterpretCastOp::getSizes((mlir::memref::ReinterpretCastOp *)&v11);
  return *(_QWORD *)(*(_QWORD *)(v11 + 72) + 32 * (v8 + v9 + NumDynamicEntriesUpToIdx + 1) + 24);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::isSameAs(uint64_t a1, uint64_t InterfaceFor, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, _QWORD, _QWORD), uint64_t a6)
{
  uint64_t v10;

  v10 = InterfaceFor;
  if (InterfaceFor)
    InterfaceFor = mlir::OpInterface<mlir::OffsetSizeAndStrideOpInterface,mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits>::getInterfaceFor(InterfaceFor);
  return mlir::detail::sameOffsetsSizesAndStrides(v10, InterfaceFor, a3, a4, a5, a6);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::hasUnitStride(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t ConstantIntValue;
  char v6;
  BOOL v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v11;
  void *v12;
  unsigned int v13;
  _QWORD v14[5];

  v14[4] = *MEMORY[0x24BDAC8D0];
  v11 = a2;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedStrides((mlir::memref::ReinterpretCastOp *)&v11, (uint64_t)&v12);
  v2 = (uint64_t *)v12;
  if (!v13)
  {
    v8 = 1;
    if (v12 == v14)
      return v8;
    goto LABEL_15;
  }
  v3 = 8 * v13 - 8;
  do
  {
    v4 = *v2++;
    ConstantIntValue = mlir::getConstantIntValue(v4);
    if (v6)
      v7 = ConstantIntValue == 1;
    else
      v7 = 0;
    v8 = v7;
    v9 = (_DWORD)v8 != 1 || v3 == 0;
    v3 -= 8;
  }
  while (!v9);
  v2 = (uint64_t *)v12;
  if (v12 != v14)
LABEL_15:
    free(v2);
  return v8;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractSliceOp>::hasZeroOffset(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t ConstantIntValue;
  char v6;
  BOOL v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v11;
  void *v12;
  unsigned int v13;
  _QWORD v14[5];

  v14[4] = *MEMORY[0x24BDAC8D0];
  v11 = a2;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedOffsets((mlir::memref::ReinterpretCastOp *)&v11, (uint64_t)&v12);
  v2 = (uint64_t *)v12;
  if (!v13)
  {
    v8 = 1;
    if (v12 == v14)
      return v8;
    goto LABEL_15;
  }
  v3 = 8 * v13 - 8;
  do
  {
    v4 = *v2++;
    ConstantIntValue = mlir::getConstantIntValue(v4);
    if (v6)
      v7 = ConstantIntValue == 0;
    else
      v7 = 0;
    v8 = v7;
    v9 = (_DWORD)v8 != 1 || v3 == 0;
    v3 -= 8;
  }
  while (!v9);
  v2 = (uint64_t *)v12;
  if (v12 != v14)
LABEL_15:
    free(v2);
  return v8;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[80];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::ExtractSliceOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::tensor::ExtractSliceOp::fold(&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  uint64_t v36;
  unsigned __int8 v37;
  _QWORD *v38;
  uint64_t v39;
  unsigned __int8 v40;
  _QWORD *v41;
  int v56;
  int v57;
  unint64_t v58;
  unint64_t v59;
  const char *v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  int v65;
  int v66;
  unint64_t v67;
  unint64_t v68;
  const char *v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  int v74;
  int v75;
  unint64_t v76;
  unint64_t v77;
  const char *v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  int v83;
  int v84;
  unint64_t v85;
  unint64_t v86;
  const char *v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  int v92;
  int v93;
  unint64_t v94;
  unint64_t v95;
  const char *v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  int v101;
  int v102;
  unint64_t v103;
  unint64_t v104;
  const char *v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  int v110;
  int v111;
  unint64_t v112;
  unint64_t v113;
  const char *v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  int v119;
  int v120;
  unint64_t v121;
  unint64_t v122;
  const char *v123;
  unint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  int v128;
  int v129;
  unint64_t v130;
  unint64_t v131;
  const char *v132;
  unint64_t v133;
  uint64_t v134;
  unint64_t v135;
  uint64_t v136;
  int v137;
  int v138;
  unint64_t v139;
  unint64_t v140;
  const char *v141;
  unint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  int v146;
  int v147;
  unint64_t v148;
  unint64_t v149;
  const char *v150;
  unint64_t v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t v154;
  int v155;
  int v156;
  unint64_t v157;
  unint64_t v158;
  const char *v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  int v164;
  int v165;
  unint64_t v166;
  unint64_t v167;
  const char *v168;
  unint64_t v169;
  uint64_t v170;
  unint64_t v171;
  uint64_t v172;
  int v173;
  int v174;
  unint64_t v175;
  unint64_t v176;
  const char *v177;
  unint64_t v178;
  uint64_t v179;
  unint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  const char *v287;
  unint64_t v288;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v273 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v57 = v56;
    a1 = v273;
    if (v57)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v288 = 83;
      v58 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v58)
        v59 = v58;
      else
        v59 = v288;
      v60 = &v287[v59];
      v61 = v288 - v59;
      if (v288 - v59 >= 0x12)
        v62 = 18;
      else
        v62 = v288 - v59;
      v63 = v61 - v62;
      if (v63 >= v63 - 1)
        v64 = v63 - 1;
      else
        v64 = v63;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v60[v62], v64);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v273;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v260 = v3;
    v274 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v66 = v65;
    v3 = v260;
    a1 = v274;
    if (v66)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v288 = 81;
      v67 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v67)
        v68 = v67;
      else
        v68 = v288;
      v69 = &v287[v68];
      v70 = v288 - v68;
      if (v288 - v68 >= 0x12)
        v71 = 18;
      else
        v71 = v288 - v68;
      v72 = v70 - v71;
      if (v72 >= v72 - 1)
        v73 = v72 - 1;
      else
        v73 = v72;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v69[v71], v73);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v260;
      a1 = v274;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v261 = v3;
    v275 = a1;
    v248 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v248;
    v3 = v261;
    v75 = v74;
    a1 = v275;
    if (v75)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<Empty>]";
      v288 = 116;
      v76 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v76)
        v77 = v76;
      else
        v77 = v288;
      v78 = &v287[v77];
      v79 = v288 - v77;
      if (v288 - v77 >= 0x12)
        v80 = 18;
      else
        v80 = v288 - v77;
      v81 = v79 - v80;
      if (v81 >= v81 - 1)
        v82 = v81 - 1;
      else
        v82 = v81;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v78[v80], v82);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v248;
      v3 = v261;
      a1 = v275;
    }
  }
  v9 = v8[425];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v262 = v3;
    v276 = a1;
    v237 = v9;
    v249 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v237;
    v6 = v249;
    v84 = v83;
    v3 = v262;
    a1 = v276;
    if (v84)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v288 = 86;
      v85 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v85)
        v86 = v85;
      else
        v86 = v288;
      v87 = &v287[v86];
      v88 = v288 - v86;
      if (v288 - v86 >= 0x12)
        v89 = 18;
      else
        v89 = v288 - v86;
      v90 = v88 - v89;
      if (v90 >= v90 - 1)
        v91 = v90 - 1;
      else
        v91 = v90;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v87[v89], v91);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v237;
      v6 = v249;
      v3 = v262;
      a1 = v276;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v263 = v3;
    v277 = a1;
    v238 = v9;
    v250 = v6;
    v227 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v227;
    v9 = v238;
    v6 = v250;
    v93 = v92;
    v3 = v263;
    a1 = v277;
    if (v93)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>]";
      v288 = 97;
      v94 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v94)
        v95 = v94;
      else
        v95 = v288;
      v96 = &v287[v95];
      v97 = v288 - v95;
      if (v288 - v95 >= 0x12)
        v98 = 18;
      else
        v98 = v288 - v95;
      v99 = v97 - v98;
      if (v99 >= v99 - 1)
        v100 = v99 - 1;
      else
        v100 = v99;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v96[v98], v100);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v227;
      v9 = v238;
      v6 = v250;
      v3 = v263;
      a1 = v277;
    }
  }
  v15 = v14[423];
  v17 = &unk_25451B000;
  if ((v16 & 1) == 0)
  {
    v264 = v3;
    v278 = a1;
    v239 = v9;
    v251 = v6;
    v218 = v15;
    v228 = v12;
    v17 = (_QWORD *)&unk_25451B000;
    v15 = v218;
    v12 = v228;
    v9 = v239;
    v6 = v251;
    v102 = v101;
    v3 = v264;
    a1 = v278;
    if (v102)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      v288 = 96;
      v103 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v103)
        v104 = v103;
      else
        v104 = v288;
      v105 = &v287[v104];
      v106 = v288 - v104;
      if (v288 - v104 >= 0x12)
        v107 = 18;
      else
        v107 = v288 - v104;
      v108 = v106 - v107;
      if (v108 >= v108 - 1)
        v109 = v108 - 1;
      else
        v109 = v108;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v105[v107], v109);
      v17 = (_QWORD *)&unk_25451B000;
      v15 = v218;
      v12 = v228;
      v9 = v239;
      v6 = v251;
      v3 = v264;
      a1 = v278;
    }
  }
  v18 = v17[37];
  v20 = &unk_254519000;
  if ((v19 & 1) == 0)
  {
    v265 = v3;
    v279 = a1;
    v240 = v9;
    v252 = v6;
    v219 = v15;
    v229 = v12;
    v210 = v18;
    v20 = (_QWORD *)&unk_254519000;
    v18 = v210;
    v15 = v219;
    v12 = v229;
    v9 = v240;
    v6 = v252;
    v111 = v110;
    v3 = v265;
    a1 = v279;
    if (v111)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v288 = 84;
      v112 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v112)
        v113 = v112;
      else
        v113 = v288;
      v114 = &v287[v113];
      v115 = v288 - v113;
      if (v288 - v113 >= 0x12)
        v116 = 18;
      else
        v116 = v288 - v113;
      v117 = v115 - v116;
      if (v117 >= v117 - 1)
        v118 = v117 - 1;
      else
        v118 = v117;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v114[v116], v118);
      v20 = (_QWORD *)&unk_254519000;
      v18 = v210;
      v15 = v219;
      v12 = v229;
      v9 = v240;
      v6 = v252;
      v3 = v265;
      a1 = v279;
    }
  }
  v21 = v20[423];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v266 = v3;
    v280 = a1;
    v241 = v9;
    v253 = v6;
    v220 = v15;
    v230 = v12;
    v203 = v21;
    v211 = v18;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v203;
    v18 = v211;
    v15 = v220;
    v12 = v230;
    v9 = v241;
    v6 = v253;
    v120 = v119;
    v3 = v266;
    a1 = v280;
    if (v120)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v288 = 89;
      v121 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v121)
        v122 = v121;
      else
        v122 = v288;
      v123 = &v287[v122];
      v124 = v288 - v122;
      if (v288 - v122 >= 0x12)
        v125 = 18;
      else
        v125 = v288 - v122;
      v126 = v124 - v125;
      if (v126 >= v126 - 1)
        v127 = v126 - 1;
      else
        v127 = v126;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v123[v125], v127);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v203;
      v18 = v211;
      v15 = v220;
      v12 = v230;
      v9 = v241;
      v6 = v253;
      v3 = v266;
      a1 = v280;
    }
  }
  v24 = v23[310];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v267 = v3;
    v281 = a1;
    v242 = v9;
    v254 = v6;
    v221 = v15;
    v231 = v12;
    v204 = v21;
    v212 = v18;
    v197 = v24;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v197;
    v21 = v204;
    v18 = v212;
    v15 = v221;
    v12 = v231;
    v9 = v242;
    v6 = v254;
    v129 = v128;
    v3 = v267;
    a1 = v281;
    if (v129)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v288 = 86;
      v130 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v130)
        v131 = v130;
      else
        v131 = v288;
      v132 = &v287[v131];
      v133 = v288 - v131;
      if (v288 - v131 >= 0x12)
        v134 = 18;
      else
        v134 = v288 - v131;
      v135 = v133 - v134;
      if (v135 >= v135 - 1)
        v136 = v135 - 1;
      else
        v136 = v135;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v132[v134], v136);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v197;
      v21 = v204;
      v18 = v212;
      v15 = v221;
      v12 = v231;
      v9 = v242;
      v6 = v254;
      v3 = v267;
      a1 = v281;
    }
  }
  v27 = v26[340];
  v29 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v268 = v3;
    v282 = a1;
    v243 = v9;
    v255 = v6;
    v222 = v15;
    v232 = v12;
    v205 = v21;
    v213 = v18;
    v192 = v27;
    v198 = v24;
    v29 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v27 = v192;
    v24 = v198;
    v21 = v205;
    v18 = v213;
    v15 = v222;
    v12 = v232;
    v9 = v243;
    v6 = v255;
    v138 = v137;
    v3 = v268;
    a1 = v282;
    if (v138)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ReifyRankedShapedTypeOpInterface::Trait<Empty>]";
      v288 = 102;
      v139 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v139)
        v140 = v139;
      else
        v140 = v288;
      v141 = &v287[v140];
      v142 = v288 - v140;
      if (v288 - v140 >= 0x12)
        v143 = 18;
      else
        v143 = v288 - v140;
      v144 = v142 - v143;
      if (v144 >= v144 - 1)
        v145 = v144 - 1;
      else
        v145 = v144;
      mlir::detail::TypeIDResolver<mlir::ReifyRankedShapedTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ReifyRankedShapedTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v141[v143], v145);
      v29 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v27 = v192;
      v24 = v198;
      v21 = v205;
      v18 = v213;
      v15 = v222;
      v12 = v232;
      v9 = v243;
      v6 = v255;
      v3 = v268;
      a1 = v282;
    }
  }
  v30 = v29[168];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v269 = v3;
    v283 = a1;
    v244 = v9;
    v256 = v6;
    v223 = v15;
    v233 = v12;
    v206 = v21;
    v214 = v18;
    v193 = v27;
    v199 = v24;
    v188 = v30;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v188;
    v27 = v193;
    v24 = v199;
    v21 = v206;
    v18 = v214;
    v15 = v223;
    v12 = v233;
    v9 = v244;
    v6 = v256;
    v147 = v146;
    v3 = v269;
    a1 = v283;
    if (v147)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v288 = 95;
      v148 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v148)
        v149 = v148;
      else
        v149 = v288;
      v150 = &v287[v149];
      v151 = v288 - v149;
      if (v288 - v149 >= 0x12)
        v152 = 18;
      else
        v152 = v288 - v149;
      v153 = v151 - v152;
      if (v153 >= v153 - 1)
        v154 = v153 - 1;
      else
        v154 = v153;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v150[v152], v154);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v188;
      v27 = v193;
      v24 = v199;
      v21 = v206;
      v18 = v214;
      v15 = v223;
      v12 = v233;
      v9 = v244;
      v6 = v256;
      v3 = v269;
      a1 = v283;
    }
  }
  v33 = v32[312];
  v35 = &unk_25451A000;
  if ((v34 & 1) == 0)
  {
    v270 = v3;
    v284 = a1;
    v245 = v9;
    v257 = v6;
    v224 = v15;
    v234 = v12;
    v207 = v21;
    v215 = v18;
    v194 = v27;
    v200 = v24;
    v185 = v33;
    v189 = v30;
    v35 = (_QWORD *)&unk_25451A000;
    v33 = v185;
    v30 = v189;
    v27 = v194;
    v24 = v200;
    v21 = v207;
    v18 = v215;
    v15 = v224;
    v12 = v234;
    v9 = v245;
    v6 = v257;
    v156 = v155;
    v3 = v270;
    a1 = v284;
    if (v156)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v288 = 99;
      v157 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v157)
        v158 = v157;
      else
        v158 = v288;
      v159 = &v287[v158];
      v160 = v288 - v158;
      if (v288 - v158 >= 0x12)
        v161 = 18;
      else
        v161 = v288 - v158;
      v162 = v160 - v161;
      if (v162 >= v162 - 1)
        v163 = v162 - 1;
      else
        v163 = v162;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v159[v161], v163);
      v35 = (_QWORD *)&unk_25451A000;
      v33 = v185;
      v30 = v189;
      v27 = v194;
      v24 = v200;
      v21 = v207;
      v18 = v215;
      v15 = v224;
      v12 = v234;
      v9 = v245;
      v6 = v257;
      v3 = v270;
      a1 = v284;
    }
  }
  v36 = v35[314];
  v38 = &unk_25451A000;
  if ((v37 & 1) == 0)
  {
    v271 = v3;
    v285 = a1;
    v246 = v9;
    v258 = v6;
    v225 = v15;
    v235 = v12;
    v208 = v21;
    v216 = v18;
    v195 = v27;
    v201 = v24;
    v186 = v33;
    v190 = v30;
    v183 = v36;
    v38 = (_QWORD *)&unk_25451A000;
    v36 = v183;
    v33 = v186;
    v30 = v190;
    v27 = v195;
    v24 = v201;
    v21 = v208;
    v18 = v216;
    v15 = v225;
    v12 = v235;
    v9 = v246;
    v6 = v258;
    v165 = v164;
    v3 = v271;
    a1 = v285;
    if (v165)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v288 = 93;
      v166 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v166)
        v167 = v166;
      else
        v167 = v288;
      v168 = &v287[v167];
      v169 = v288 - v167;
      if (v288 - v167 >= 0x12)
        v170 = 18;
      else
        v170 = v288 - v167;
      v171 = v169 - v170;
      if (v171 >= v171 - 1)
        v172 = v171 - 1;
      else
        v172 = v171;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v168[v170], v172);
      v38 = (_QWORD *)&unk_25451A000;
      v36 = v183;
      v33 = v186;
      v30 = v190;
      v27 = v195;
      v24 = v201;
      v21 = v208;
      v18 = v216;
      v15 = v225;
      v12 = v235;
      v9 = v246;
      v6 = v258;
      v3 = v271;
      a1 = v285;
    }
  }
  v39 = v38[21];
  v41 = &unk_25451B000;
  if ((v40 & 1) == 0)
  {
    v272 = v3;
    v286 = a1;
    v247 = v9;
    v259 = v6;
    v226 = v15;
    v236 = v12;
    v209 = v21;
    v217 = v18;
    v196 = v27;
    v202 = v24;
    v187 = v33;
    v191 = v30;
    v182 = v39;
    v184 = v36;
    v41 = (_QWORD *)&unk_25451B000;
    v39 = v182;
    v36 = v184;
    v33 = v187;
    v30 = v191;
    v27 = v196;
    v24 = v202;
    v21 = v209;
    v18 = v217;
    v15 = v226;
    v12 = v236;
    v9 = v247;
    v6 = v259;
    v174 = v173;
    v3 = v272;
    a1 = v286;
    if (v174)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OffsetSizeAndStrideOpInterface::Trait<Empty>]";
      v288 = 100;
      v175 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v175)
        v176 = v175;
      else
        v176 = v288;
      v177 = &v287[v176];
      v178 = v288 - v176;
      if (v288 - v176 >= 0x12)
        v179 = 18;
      else
        v179 = v288 - v176;
      v180 = v178 - v179;
      if (v180 >= v180 - 1)
        v181 = v180 - 1;
      else
        v181 = v180;
      mlir::detail::TypeIDResolver<mlir::OffsetSizeAndStrideOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OffsetSizeAndStrideOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v177[v179], v181);
      v41 = (_QWORD *)&unk_25451B000;
      v39 = v182;
      v36 = v184;
      v33 = v187;
      v30 = v191;
      v27 = v196;
      v24 = v202;
      v21 = v209;
      v18 = v217;
      v15 = v226;
      v12 = v236;
      v9 = v247;
      v6 = v259;
      v3 = v272;
      a1 = v286;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v36 == a1
      || v39 == a1
      || v41[261] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;

  mlir::OpState::printOpName(a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::memref::SubViewOp::print((mlir::memref::SubViewOp *)&v7, a3);
}

BOOL mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::verifyInvariants(uint64_t *a1, mlir::Operation *a2)
{
  char v3;
  uint64_t *v5;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::tensor::ExtractSliceOp>,mlir::OpTrait::OneResult<mlir::tensor::ExtractSliceOp>,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::tensor::ExtractSliceOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::ExtractSliceOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::tensor::ExtractSliceOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::tensor::ExtractSliceOp>,mlir::OpTrait::OpInvariants<mlir::tensor::ExtractSliceOp>,mlir::BytecodeOpInterface::Trait<mlir::tensor::ExtractSliceOp>,mlir::OpAsmOpInterface::Trait<mlir::tensor::ExtractSliceOp>,mlir::ReifyRankedShapedTypeOpInterface::Trait<mlir::tensor::ExtractSliceOp>,mlir::ConditionallySpeculatable::Trait<mlir::tensor::ExtractSliceOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::tensor::ExtractSliceOp>,mlir::MemoryEffectOpInterface::Trait<mlir::tensor::ExtractSliceOp>,mlir::OffsetSizeAndStrideOpInterface::Trait<mlir::tensor::ExtractSliceOp>>(a1, a2))return 0;
  v5 = a1;
  mlir::tensor::ExtractSliceOp::verify((mlir::tensor::ExtractSliceOp *)&v5);
  return v3 != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::tensor::ExtractSliceOp>,mlir::OpTrait::OneResult<mlir::tensor::ExtractSliceOp>,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::tensor::ExtractSliceOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::ExtractSliceOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::tensor::ExtractSliceOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::tensor::ExtractSliceOp>,mlir::OpTrait::OpInvariants<mlir::tensor::ExtractSliceOp>,mlir::BytecodeOpInterface::Trait<mlir::tensor::ExtractSliceOp>,mlir::OpAsmOpInterface::Trait<mlir::tensor::ExtractSliceOp>,mlir::ReifyRankedShapedTypeOpInterface::Trait<mlir::tensor::ExtractSliceOp>,mlir::ConditionallySpeculatable::Trait<mlir::tensor::ExtractSliceOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::tensor::ExtractSliceOp>,mlir::MemoryEffectOpInterface::Trait<mlir::tensor::ExtractSliceOp>,mlir::OffsetSizeAndStrideOpInterface::Trait<mlir::tensor::ExtractSliceOp>>(uint64_t *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)1)
    && mlir::OpTrait::impl::verifyOperandSizeAttr((uint64_t)a1, "operandSegmentSizes", 0x13uLL)
    && (v6 = a1, mlir::tensor::ExtractSliceOp::verifyInvariantsImpl(&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OffsetSizeAndStrideOpInterface::Trait<mlir::memref::ReinterpretCastOp>>(a1) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::Op<mlir::tensor::ExtractSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::FromElementsOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::FromElementsOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::FromElementsOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.from_elements", 20, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::FromElementsOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04CD90;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                      + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::tensor::FromElementsOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::tensor::FromElementsOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                       + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::FromElementsOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::FromElementsOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::FromElementsOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::FromElementsOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::FromElementsOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::FromElementsOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::FromElementsOp::getAsmResultNames((uint64_t)&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::FromElementsOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::FromElementsOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::FromElementsOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::FromElementsOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::FromElementsOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::FromElementsOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::FromElementsOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  mlir::Operation *v13;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::tensor::detail::FromElementsOpGenericAdaptorBase::FromElementsOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::tensor::FromElementsOp::fold(&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8
    || (mlir::Operation *)((char *)a2 - 16) == (mlir::Operation *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    return v9 > 7;
  }
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  int v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  const char *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  const char *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  const char *v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  const char *v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  const char *v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  const char *v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  const char *v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  const char *v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  const char *v185;
  unint64_t v186;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v175 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v41 = v40;
    a1 = v175;
    if (v41)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v186 = 83;
      v42 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v42)
        v43 = v42;
      else
        v43 = v186;
      v44 = &v185[v43];
      v45 = v186 - v43;
      if (v186 - v43 >= 0x12)
        v46 = 18;
      else
        v46 = v186 - v43;
      v47 = v45 - v46;
      if (v47 >= v47 - 1)
        v48 = v47 - 1;
      else
        v48 = v47;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v44[v46], v48);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v175;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v166 = v3;
    v176 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v50 = v49;
    v3 = v166;
    a1 = v176;
    if (v50)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v186 = 81;
      v51 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v51)
        v52 = v51;
      else
        v52 = v186;
      v53 = &v185[v52];
      v54 = v186 - v52;
      if (v186 - v52 >= 0x12)
        v55 = 18;
      else
        v55 = v186 - v52;
      v56 = v54 - v55;
      if (v56 >= v56 - 1)
        v57 = v56 - 1;
      else
        v57 = v56;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v53[v55], v57);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v166;
      a1 = v176;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v167 = v3;
    v177 = a1;
    v158 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v158;
    v59 = v58;
    v3 = v167;
    a1 = v177;
    if (v59)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<Empty>]";
      v186 = 116;
      v60 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v60)
        v61 = v60;
      else
        v61 = v186;
      v62 = &v185[v61];
      v63 = v186 - v61;
      if (v186 - v61 >= 0x12)
        v64 = 18;
      else
        v64 = v186 - v61;
      v65 = v63 - v64;
      if (v65 >= v65 - 1)
        v66 = v65 - 1;
      else
        v66 = v65;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v62[v64], v66);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v158;
      v3 = v167;
      a1 = v177;
    }
  }
  v9 = v8[425];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v168 = v3;
    v178 = a1;
    v151 = v9;
    v159 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v151;
    v6 = v159;
    v68 = v67;
    v3 = v168;
    a1 = v178;
    if (v68)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v186 = 86;
      v69 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v69)
        v70 = v69;
      else
        v70 = v186;
      v71 = &v185[v70];
      v72 = v186 - v70;
      if (v186 - v70 >= 0x12)
        v73 = 18;
      else
        v73 = v186 - v70;
      v74 = v72 - v73;
      if (v74 >= v74 - 1)
        v75 = v74 - 1;
      else
        v75 = v74;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v71[v73], v75);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v151;
      v6 = v159;
      v3 = v168;
      a1 = v178;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v169 = v3;
    v179 = a1;
    v152 = v9;
    v160 = v6;
    v145 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v145;
    v9 = v152;
    v6 = v160;
    v77 = v76;
    v3 = v169;
    a1 = v179;
    if (v77)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicOperands<Empty>]";
      v186 = 88;
      v78 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v78)
        v79 = v78;
      else
        v79 = v186;
      v80 = &v185[v79];
      v81 = v186 - v79;
      if (v186 - v79 >= 0x12)
        v82 = 18;
      else
        v82 = v186 - v79;
      v83 = v81 - v82;
      if (v83 >= v83 - 1)
        v84 = v83 - 1;
      else
        v84 = v83;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v80[v82], v84);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v145;
      v9 = v152;
      v6 = v160;
      v3 = v169;
      a1 = v179;
    }
  }
  v15 = v14[73];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v170 = v3;
    v180 = a1;
    v153 = v9;
    v161 = v6;
    v140 = v15;
    v146 = v12;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v140;
    v12 = v146;
    v9 = v153;
    v6 = v161;
    v86 = v85;
    v3 = v170;
    a1 = v180;
    if (v86)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v186 = 84;
      v87 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v87)
        v88 = v87;
      else
        v88 = v186;
      v89 = &v185[v88];
      v90 = v186 - v88;
      if (v186 - v88 >= 0x12)
        v91 = 18;
      else
        v91 = v186 - v88;
      v92 = v90 - v91;
      if (v92 >= v92 - 1)
        v93 = v92 - 1;
      else
        v93 = v92;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v89[v91], v93);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v140;
      v12 = v146;
      v9 = v153;
      v6 = v161;
      v3 = v170;
      a1 = v180;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v171 = v3;
    v181 = a1;
    v154 = v9;
    v162 = v6;
    v141 = v15;
    v147 = v12;
    v136 = v18;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v136;
    v15 = v141;
    v12 = v147;
    v9 = v154;
    v6 = v162;
    v95 = v94;
    v3 = v171;
    a1 = v181;
    if (v95)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v186 = 86;
      v96 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v96)
        v97 = v96;
      else
        v97 = v186;
      v98 = &v185[v97];
      v99 = v186 - v97;
      if (v186 - v97 >= 0x12)
        v100 = 18;
      else
        v100 = v186 - v97;
      v101 = v99 - v100;
      if (v101 >= v101 - 1)
        v102 = v101 - 1;
      else
        v102 = v101;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v98[v100], v102);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v136;
      v15 = v141;
      v12 = v147;
      v9 = v154;
      v6 = v162;
      v3 = v171;
      a1 = v181;
    }
  }
  v21 = v20[340];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v172 = v3;
    v182 = a1;
    v155 = v9;
    v163 = v6;
    v142 = v15;
    v148 = v12;
    v133 = v21;
    v137 = v18;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v133;
    v18 = v137;
    v15 = v142;
    v12 = v148;
    v9 = v155;
    v6 = v163;
    v104 = v103;
    v3 = v172;
    a1 = v182;
    if (v104)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v186 = 95;
      v105 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v105)
        v106 = v105;
      else
        v106 = v186;
      v107 = &v185[v106];
      v108 = v186 - v106;
      if (v186 - v106 >= 0x12)
        v109 = 18;
      else
        v109 = v186 - v106;
      v110 = v108 - v109;
      if (v110 >= v110 - 1)
        v111 = v110 - 1;
      else
        v111 = v110;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v107[v109], v111);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v133;
      v18 = v137;
      v15 = v142;
      v12 = v148;
      v9 = v155;
      v6 = v163;
      v3 = v172;
      a1 = v182;
    }
  }
  v24 = v23[312];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v173 = v3;
    v183 = a1;
    v156 = v9;
    v164 = v6;
    v143 = v15;
    v149 = v12;
    v134 = v21;
    v138 = v18;
    v131 = v24;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v131;
    v21 = v134;
    v18 = v138;
    v15 = v143;
    v12 = v149;
    v9 = v156;
    v6 = v164;
    v113 = v112;
    v3 = v173;
    a1 = v183;
    if (v113)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v186 = 99;
      v114 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v114)
        v115 = v114;
      else
        v115 = v186;
      v116 = &v185[v115];
      v117 = v186 - v115;
      if (v186 - v115 >= 0x12)
        v118 = 18;
      else
        v118 = v186 - v115;
      v119 = v117 - v118;
      if (v119 >= v119 - 1)
        v120 = v119 - 1;
      else
        v120 = v119;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v116[v118], v120);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v131;
      v21 = v134;
      v18 = v138;
      v15 = v143;
      v12 = v149;
      v9 = v156;
      v6 = v164;
      v3 = v173;
      a1 = v183;
    }
  }
  v27 = v26[314];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v174 = v3;
    v184 = a1;
    v157 = v9;
    v165 = v6;
    v144 = v15;
    v150 = v12;
    v135 = v21;
    v139 = v18;
    v130 = v27;
    v132 = v24;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v130;
    v24 = v132;
    v21 = v135;
    v18 = v139;
    v15 = v144;
    v12 = v150;
    v9 = v157;
    v6 = v165;
    v122 = v121;
    v3 = v174;
    a1 = v184;
    if (v122)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v186 = 93;
      v123 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v123)
        v124 = v123;
      else
        v124 = v186;
      v125 = &v185[v124];
      v126 = v186 - v124;
      if (v186 - v124 >= 0x12)
        v127 = 18;
      else
        v127 = v186 - v124;
      v128 = v126 - v127;
      if (v128 >= v128 - 1)
        v129 = v128 - 1;
      else
        v129 = v128;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v125[v127], v129);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v130;
      v24 = v132;
      v21 = v135;
      v18 = v139;
      v15 = v144;
      v12 = v150;
      v9 = v157;
      v6 = v165;
      v3 = v174;
      a1 = v184;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v29[21] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::tensor::FromElementsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
  {
    return 0;
  }
  v6 = a1;
  return mlir::tensor::FromElementsOp::verifyInvariantsImpl((uint64_t **)&v6) != 0;
}

uint64_t mlir::Op<mlir::tensor::FromElementsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::GatherOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.gather", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::GatherOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04D628;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::tensor::GatherOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                       + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::tensor::GatherOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  char *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::tensor::GatherOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::tensor::GatherOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::tensor::GatherOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::tensor::GatherOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::tensor::GatherOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::tensor::GatherOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::GatherOp::getAsmResultNames((uint64_t)&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::GatherOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::GatherOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::GatherOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::GatherOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[56];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::tensor::detail::GatherOpGenericAdaptorBase::GatherOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::tensor::GatherOp::fold((uint64_t)&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  const char *v209;
  unint64_t v210;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v198;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<Empty>]";
      v210 = 116;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = v8[425];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v210 = 90;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[79];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v210 = 89;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[310];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v210 = 86;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[340];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v210 = 95;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[312];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v210 = 99;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[314];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v32[21] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::tensor::GatherOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
    return 0;
  v6 = a1;
  if (!mlir::tensor::GatherOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::tensor::GatherOp::verify((uint64_t **)&v6) != 0;
}

uint64_t mlir::Op<mlir::tensor::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::foldHook()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::tensor::GenerateOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::tensor::GenerateOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                       + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::GenerateOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::GenerateOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::GenerateOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::GenerateOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::GenerateOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::GenerateOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::GenerateOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::GenerateOp::getAsmResultNames((uint64_t)&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::GenerateOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::GenerateOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::GenerateOp>::reifyResultShapes;
  v4 = &unk_25451B000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451B000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ReifyRankedShapedTypeOpInterface]";
      v15 = 88;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ReifyRankedShapedTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451B000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[171], v2);
}

uint64_t mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::GenerateOp>::reifyResultShapes(uint64_t a1, uint64_t a2, mlir::IndexType **a3, uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::GenerateOp::reifyResultShapes((uint64_t)&v5, a3, a4);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  const char *v209;
  unint64_t v210;

  v2 = &unk_254519000;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = (_QWORD *)&unk_254519000;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneRegion<Empty>]";
      v210 = 81;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = (_QWORD *)&unk_254519000;
      a1 = v198;
    }
  }
  v3 = v2[415];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<Empty>]";
      v210 = 116;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = v8[425];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicOperands<Empty>]";
      v210 = 88;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[73];
  v17 = &unk_25451A000;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = (_QWORD *)&unk_25451A000;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SingleBlock<Empty>]";
      v210 = 83;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlock<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlock>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = (_QWORD *)&unk_25451A000;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[433];
  v20 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor:"
             ":YieldOp>::Impl<Empty>]";
      v210 = 130;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[184];
  v23 = &unk_254519000;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = (_QWORD *)&unk_254519000;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = (_QWORD *)&unk_254519000;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[423];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v210 = 86;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[340];
  v29 = &unk_25451B000;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = (_QWORD *)&unk_25451B000;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasRecursiveMemoryEffects<Empty>]";
      v210 = 97;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = (_QWORD *)&unk_25451B000;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[219];
  v32 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ReifyRankedShapedTypeOpInterface::Trait<Empty>]";
      v210 = 102;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::ReifyRankedShapedTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ReifyRankedShapedTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v32[168] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::tensor::GenerateOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyOneRegion(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::SingleBlock<mlir::memref::GenericAtomicRMWOp>::verifyTrait((uint64_t)a1))
    return 0;
  v6 = a1;
  if (!mlir::tensor::GenerateOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::tensor::GenerateOp::verify((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::tensor::GenerateOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::ReifyRankedShapedTypeOpInterface::Trait>::verifyRegionInvariants(uint64_t *a1)
{
  uint64_t *v3;

  if (!mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl<mlir::tensor::GenerateOp>::verifyRegionTrait((uint64_t)a1))
    return 0;
  v3 = a1;
  return mlir::tensor::GenerateOp::verifyRegions(&v3) != 0;
}

uint64_t mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl<mlir::tensor::GenerateOp>::verifyRegionTrait(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t AttrData;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  const void ***v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  Layer2TDMapper::SourceLayer *v22;
  uint64_t IsGraphInitialization;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v33;
  BOOL v34;
  char *v35;
  const void **v36;
  uint64_t v37;
  uint64_t v38;
  __int16 v39;
  _QWORD v40[4];
  __int16 v41;
  _QWORD v42[4];
  __int16 v43;
  _QWORD v44[4];
  __int16 v45;
  const void **v46[4];
  __int16 v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD *v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  v1 = *(_DWORD *)(a1 + 44) & 0x7FFFFF;
  if (!(_DWORD)v1)
    return 1;
  v3 = 0;
  v4 = a1 + 64;
  v5 = 24 * v1;
  while (1)
  {
    v6 = *(unsigned int *)(a1 + 44);
    if ((v6 & 0x7FFFFF) == 0)
      break;
    v7 = (_QWORD *)((char *)&v3[4 * *(unsigned int *)(a1 + 40)]
                  + ((v4 + 16 * ((v6 >> 23) & 1) + ((v6 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8));
    if (v7 != (_QWORD *)*v7)
      goto LABEL_8;
LABEL_3:
    v3 += 3;
    if ((_QWORD *)v5 == v3)
      return 1;
  }
  v7 = v3;
  if (v3 == (_QWORD *)*v3)
    goto LABEL_3;
LABEL_8:
  v8 = v7[1];
  if (v8)
    v9 = v8 - 8;
  else
    v9 = 0;
  ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v9 + 32));
  v11 = *(_QWORD *)(v10 + 48);
  if (*(_UNKNOWN **)(v11 + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::YieldOp,void>::id)
    goto LABEL_3;
  v41 = 1283;
  v40[0] = "expects regions to end with '";
  v40[2] = "tensor.yield";
  v40[3] = 12;
  v42[0] = v40;
  v42[2] = "', found '";
  v43 = 770;
  v48 = *(_QWORD *)(v11 + 8);
  AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v48);
  v44[0] = v42;
  v44[2] = AttrData;
  v44[3] = v13;
  v45 = 1282;
  v46[0] = (const void **)v44;
  v46[2] = (const void **)"'";
  v47 = 770;
  mlir::Operation::emitOpError((uint64_t *)a1, v46, (uint64_t)&v48);
  v14 = mlir::Diagnostic::attachNote(&v49, 0, 0);
  v15 = v14 + 16;
  v16 = *(_QWORD *)(v14 + 16);
  LODWORD(v36) = 3;
  v37 = (uint64_t)"in custom textual format, the absence of terminator implies '";
  v38 = 61;
  v17 = *(unsigned int *)(v14 + 24);
  v18 = &v36;
  if (v17 >= *(_DWORD *)(v14 + 28))
  {
    v33 = v17 + 1;
    v34 = v16 + 24 * v17 > (unint64_t)&v36;
    if (v16 <= (unint64_t)&v36 && v34)
    {
      v35 = (char *)&v36 - v16;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v15, (void *)(v14 + 32), v33, 24);
      v16 = *(_QWORD *)(v14 + 16);
      v18 = (const void ***)&v35[v16];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v15, (void *)(v14 + 32), v33, 24);
      v16 = *(_QWORD *)(v14 + 16);
      v18 = &v36;
    }
  }
  v19 = v16 + 24 * *(unsigned int *)(v14 + 24);
  v20 = *(_OWORD *)v18;
  *(_QWORD *)(v19 + 16) = v18[2];
  *(_OWORD *)v19 = v20;
  ++*(_DWORD *)(v14 + 24);
  v39 = 262;
  v36 = (const void **)"tensor.yield";
  v37 = 12;
  v21 = mlir::Diagnostic::operator<<(v14, &v36);
  v22 = (Layer2TDMapper::SourceLayer *)mlir::Diagnostic::operator<<(v21, 39);
  IsGraphInitialization = Layer2TDMapper::SourceLayer::IsGraphInitialization(v22);
  if (v48)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v48);
  if (v56)
  {
    v24 = __p;
    if (__p)
    {
      v25 = v55;
      v26 = __p;
      if (v55 != __p)
      {
        do
          v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        v26 = __p;
      }
      v55 = v24;
      operator delete(v26);
    }
    v27 = v52;
    if (v52)
    {
      v28 = v53;
      v29 = v52;
      if (v53 != v52)
      {
        do
        {
          v31 = *--v28;
          v30 = v31;
          *v28 = 0;
          if (v31)
            MEMORY[0x20BD002D4](v30, 0x1000C8077774924);
        }
        while (v28 != v27);
        v29 = v52;
      }
      v53 = v27;
      operator delete(v29);
    }
    if (v50 != &v51)
      free(v50);
  }
  return IsGraphInitialization;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::InsertOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.insert", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::InsertOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04D6F0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::tensor::InsertOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::InsertOp::getAsmResultNames((uint64_t)&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>::getDpsInitsMutable;
  v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DestinationStyleOpInterface]";
      v15 = 83;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[124], v2);
}

mlir::MutableOperandRange *mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>::getDpsInitsMutable@<X0>(uint64_t a1@<X1>, mlir::MutableOperandRange *a2@<X8>)
{
  mlir::OpOperand *DestMutable;
  uint64_t v5;

  v5 = a1;
  DestMutable = (mlir::OpOperand *)mlir::tensor::InsertOp::getDestMutable((mlir::tensor::InsertOp *)&v5);
  return mlir::MutableOperandRange::MutableOperandRange(a2, DestMutable);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::InsertOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::InsertOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::InsertOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::tensor::InsertOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::tensor::InsertOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::tensor::InsertOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::tensor::InsertOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "tensor.insert";
  v16[1] = 13;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int *v13;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::tensor::detail::InsertOpGenericAdaptorBase::InsertOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::tensor::InsertOp::fold((uint64_t)&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8 || a2 - 4 == (unsigned int *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  const char *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  const char *v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  unint64_t v86;
  unint64_t v87;
  const char *v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  const char *v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  unint64_t v104;
  unint64_t v105;
  const char *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unint64_t v113;
  unint64_t v114;
  const char *v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  unint64_t v122;
  unint64_t v123;
  const char *v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  int v129;
  int v130;
  unint64_t v131;
  unint64_t v132;
  const char *v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  unint64_t v140;
  unint64_t v141;
  const char *v142;
  unint64_t v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  int v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  const char *v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  const char *v234;
  unint64_t v235;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v222 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v49 = v48;
    a1 = v222;
    if (v49)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v235 = 83;
      v50 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v50)
        v51 = v50;
      else
        v51 = v235;
      v52 = &v234[v51];
      v53 = v235 - v51;
      if (v235 - v51 >= 0x12)
        v54 = 18;
      else
        v54 = v235 - v51;
      v55 = v53 - v54;
      if (v55 >= v55 - 1)
        v56 = v55 - 1;
      else
        v56 = v55;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v222;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v211 = v3;
    v223 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v58 = v57;
    v3 = v211;
    a1 = v223;
    if (v58)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v235 = 81;
      v59 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v59)
        v60 = v59;
      else
        v60 = v235;
      v61 = &v234[v60];
      v62 = v235 - v60;
      if (v235 - v60 >= 0x12)
        v63 = 18;
      else
        v63 = v235 - v60;
      v64 = v62 - v63;
      if (v64 >= v64 - 1)
        v65 = v64 - 1;
      else
        v65 = v64;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v211;
      a1 = v223;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v212 = v3;
    v224 = a1;
    v201 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v201;
    v3 = v212;
    v67 = v66;
    a1 = v224;
    if (v67)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<Empty>]";
      v235 = 116;
      v68 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v68)
        v69 = v68;
      else
        v69 = v235;
      v70 = &v234[v69];
      v71 = v235 - v69;
      if (v235 - v69 >= 0x12)
        v72 = 18;
      else
        v72 = v235 - v69;
      v73 = v71 - v72;
      if (v73 >= v73 - 1)
        v74 = v73 - 1;
      else
        v74 = v73;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v201;
      v3 = v212;
      a1 = v224;
    }
  }
  v9 = v8[425];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v213 = v3;
    v225 = a1;
    v202 = v6;
    v192 = v9;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v192;
    v6 = v202;
    v3 = v213;
    v76 = v75;
    a1 = v225;
    if (v76)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v235 = 86;
      v77 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v77)
        v78 = v77;
      else
        v78 = v235;
      v79 = &v234[v78];
      v80 = v235 - v78;
      if (v235 - v78 >= 0x12)
        v81 = 18;
      else
        v81 = v235 - v78;
      v82 = v80 - v81;
      if (v82 >= v82 - 1)
        v83 = v82 - 1;
      else
        v83 = v82;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v192;
      v6 = v202;
      v3 = v213;
      a1 = v225;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v214 = v3;
    v226 = a1;
    v203 = v6;
    v184 = v12;
    v193 = v9;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v184;
    v9 = v193;
    v6 = v203;
    v3 = v214;
    v85 = v84;
    a1 = v226;
    if (v85)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<2>::Impl<Empty>]";
      v235 = 97;
      v86 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v86)
        v87 = v86;
      else
        v87 = v235;
      v88 = &v234[v87];
      v89 = v235 - v87;
      if (v235 - v87 >= 0x12)
        v90 = 18;
      else
        v90 = v235 - v87;
      v91 = v89 - v90;
      if (v91 >= v91 - 1)
        v92 = v91 - 1;
      else
        v92 = v91;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v184;
      v9 = v193;
      v6 = v203;
      v3 = v214;
      a1 = v226;
    }
  }
  v15 = v14[431];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v215 = v3;
    v227 = a1;
    v204 = v6;
    v185 = v12;
    v194 = v9;
    v177 = v15;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v177;
    v12 = v185;
    v9 = v194;
    v6 = v204;
    v3 = v215;
    v94 = v93;
    a1 = v227;
    if (v94)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v235 = 84;
      v95 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v95)
        v96 = v95;
      else
        v96 = v235;
      v97 = &v234[v96];
      v98 = v235 - v96;
      if (v235 - v96 >= 0x12)
        v99 = 18;
      else
        v99 = v235 - v96;
      v100 = v98 - v99;
      if (v100 >= v100 - 1)
        v101 = v100 - 1;
      else
        v101 = v100;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v177;
      v12 = v185;
      v9 = v194;
      v6 = v204;
      v3 = v215;
      a1 = v227;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v216 = v3;
    v228 = a1;
    v205 = v6;
    v186 = v12;
    v195 = v9;
    v171 = v18;
    v178 = v15;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v171;
    v15 = v178;
    v12 = v186;
    v9 = v195;
    v6 = v205;
    v3 = v216;
    v103 = v102;
    a1 = v228;
    if (v103)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v235 = 86;
      v104 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v104)
        v105 = v104;
      else
        v105 = v235;
      v106 = &v234[v105];
      v107 = v235 - v105;
      if (v235 - v105 >= 0x12)
        v108 = 18;
      else
        v108 = v235 - v105;
      v109 = v107 - v108;
      if (v109 >= v109 - 1)
        v110 = v109 - 1;
      else
        v110 = v109;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v171;
      v15 = v178;
      v12 = v186;
      v9 = v195;
      v6 = v205;
      v3 = v216;
      a1 = v228;
    }
  }
  v21 = v20[340];
  v23 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v217 = v3;
    v229 = a1;
    v206 = v6;
    v187 = v12;
    v196 = v9;
    v172 = v18;
    v179 = v15;
    v166 = v21;
    v23 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v21 = v166;
    v18 = v172;
    v15 = v179;
    v12 = v187;
    v9 = v196;
    v6 = v206;
    v3 = v217;
    v112 = v111;
    a1 = v229;
    if (v112)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DestinationStyleOpInterface::Trait<Empty>]";
      v235 = 97;
      v113 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v113)
        v114 = v113;
      else
        v114 = v235;
      v115 = &v234[v114];
      v116 = v235 - v114;
      if (v235 - v114 >= 0x12)
        v117 = 18;
      else
        v117 = v235 - v114;
      v118 = v116 - v117;
      if (v118 >= v118 - 1)
        v119 = v118 - 1;
      else
        v119 = v118;
      mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DestinationStyleOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      v23 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v21 = v166;
      v18 = v172;
      v15 = v179;
      v12 = v187;
      v9 = v196;
      v6 = v206;
      v3 = v217;
      a1 = v229;
    }
  }
  v24 = v23[128];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v218 = v3;
    v230 = a1;
    v207 = v6;
    v188 = v12;
    v197 = v9;
    v173 = v18;
    v180 = v15;
    v162 = v24;
    v167 = v21;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v162;
    v21 = v167;
    v18 = v173;
    v15 = v180;
    v12 = v188;
    v9 = v197;
    v6 = v207;
    v3 = v218;
    v121 = v120;
    a1 = v230;
    if (v121)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v235 = 95;
      v122 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v122)
        v123 = v122;
      else
        v123 = v235;
      v124 = &v234[v123];
      v125 = v235 - v123;
      if (v235 - v123 >= 0x12)
        v126 = 18;
      else
        v126 = v235 - v123;
      v127 = v125 - v126;
      if (v127 >= v127 - 1)
        v128 = v127 - 1;
      else
        v128 = v127;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v162;
      v21 = v167;
      v18 = v173;
      v15 = v180;
      v12 = v188;
      v9 = v197;
      v6 = v207;
      v3 = v218;
      a1 = v230;
    }
  }
  v27 = v26[312];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v219 = v3;
    v231 = a1;
    v208 = v6;
    v189 = v12;
    v198 = v9;
    v174 = v18;
    v181 = v15;
    v163 = v24;
    v168 = v21;
    v159 = v27;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v159;
    v24 = v163;
    v21 = v168;
    v18 = v174;
    v15 = v181;
    v12 = v189;
    v9 = v198;
    v6 = v208;
    v3 = v219;
    v130 = v129;
    a1 = v231;
    if (v130)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v235 = 99;
      v131 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v131)
        v132 = v131;
      else
        v132 = v235;
      v133 = &v234[v132];
      v134 = v235 - v132;
      if (v235 - v132 >= 0x12)
        v135 = 18;
      else
        v135 = v235 - v132;
      v136 = v134 - v135;
      if (v136 >= v136 - 1)
        v137 = v136 - 1;
      else
        v137 = v136;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v159;
      v24 = v163;
      v21 = v168;
      v18 = v174;
      v15 = v181;
      v12 = v189;
      v9 = v198;
      v6 = v208;
      v3 = v219;
      a1 = v231;
    }
  }
  v30 = v29[314];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v220 = v3;
    v232 = a1;
    v209 = v6;
    v190 = v12;
    v199 = v9;
    v175 = v18;
    v182 = v15;
    v164 = v24;
    v169 = v21;
    v157 = v30;
    v160 = v27;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v157;
    v27 = v160;
    v24 = v164;
    v21 = v169;
    v18 = v175;
    v15 = v182;
    v12 = v190;
    v9 = v199;
    v6 = v209;
    v3 = v220;
    v139 = v138;
    a1 = v232;
    if (v139)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v235 = 93;
      v140 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v140)
        v141 = v140;
      else
        v141 = v235;
      v142 = &v234[v141];
      v143 = v235 - v141;
      if (v235 - v141 >= 0x12)
        v144 = 18;
      else
        v144 = v235 - v141;
      v145 = v143 - v144;
      if (v145 >= v145 - 1)
        v146 = v145 - 1;
      else
        v146 = v145;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v157;
      v27 = v160;
      v24 = v164;
      v21 = v169;
      v18 = v175;
      v15 = v182;
      v12 = v190;
      v9 = v199;
      v6 = v209;
      v3 = v220;
      a1 = v232;
    }
  }
  v33 = v32[21];
  v35 = &unk_25451A000;
  if ((v34 & 1) == 0)
  {
    v221 = v3;
    v233 = a1;
    v210 = v6;
    v191 = v12;
    v200 = v9;
    v176 = v18;
    v183 = v15;
    v165 = v24;
    v170 = v21;
    v158 = v30;
    v161 = v27;
    v156 = v33;
    v35 = (_QWORD *)&unk_25451A000;
    v33 = v156;
    v30 = v158;
    v27 = v161;
    v24 = v165;
    v21 = v170;
    v18 = v176;
    v15 = v183;
    v12 = v191;
    v9 = v200;
    v6 = v210;
    v3 = v221;
    v148 = v147;
    a1 = v233;
    if (v148)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v235 = 90;
      v149 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v149)
        v150 = v149;
      else
        v150 = v235;
      v151 = &v234[v150];
      v152 = v235 - v150;
      if (v235 - v150 >= 0x12)
        v153 = 18;
      else
        v153 = v235 - v150;
      v154 = v152 - v153;
      if (v154 >= v154 - 1)
        v155 = v154 - 1;
      else
        v155 = v154;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      v35 = (_QWORD *)&unk_25451A000;
      v33 = v156;
      v30 = v158;
      v27 = v161;
      v24 = v165;
      v21 = v170;
      v18 = v176;
      v15 = v183;
      v12 = v191;
      v9 = v200;
      v6 = v210;
      v3 = v221;
      a1 = v233;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v35[27] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::tensor::InsertOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)2))
    return 0;
  v6 = a1;
  if (!mlir::tensor::InsertOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::tensor::InsertOp::verify((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::tensor::InsertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;

  return mlir::detail::verifyDestinationStyleOpInterface(a1, a2)
      && mlir::detail::verifyInferredResultTypes(a1, v3) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::InsertSliceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.insert_slice", 19, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::InsertSliceOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04CC00;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::tensor::InsertSliceOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::tensor::InsertSliceOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                    + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  mlir::MLIRContext *Context;
  uint64_t *v8;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::tensor::InsertSliceOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::tensor::InsertSliceOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::MLIRContext *Context;
  uint64_t *v6;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::tensor::InsertSliceOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::memref::ReinterpretCastOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::getOpPropertyByteSize()
{
  return 48;
}

double mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::initProperties(uint64_t a1, uint64_t a2, _OWORD *a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[2];
    a3[1] = a4[1];
    a3[2] = v5;
    *a3 = v4;
  }
  else
  {
    *(_QWORD *)&v4 = 0;
    a3[1] = 0u;
    a3[2] = 0u;
    *a3 = 0u;
  }
  return *(double *)&v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::tensor::InsertSliceOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::tensor::InsertSliceOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a2 + 28) = *(_OWORD *)(a3 + 28);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::compareProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_QWORD *)a3 != *(_QWORD *)a2)
    return 0;
  if (*(_QWORD *)(a3 + 8) != *(_QWORD *)(a2 + 8))
    return 0;
  if (*(_QWORD *)(a3 + 16) != *(_QWORD *)(a2 + 16))
    return 0;
  return *(_QWORD *)(a3 + 24) == *(_QWORD *)(a2 + 24)
      && *(_QWORD *)(a3 + 32) == *(_QWORD *)(a2 + 32)
      && *(_DWORD *)(a3 + 40) == (unint64_t)*(unsigned int *)(a2 + 40);
}

unint64_t mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::tensor::InsertSliceOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::tensor::InsertSliceOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::InsertSliceOp::getAsmResultNames((uint64_t)&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::reifyResultShapes;
  v4 = &unk_25451B000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451B000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ReifyRankedShapedTypeOpInterface]";
      v15 = 88;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ReifyRankedShapedTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451B000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[171], v2);
}

uint64_t mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::reifyResultShapes(uint64_t a1, uint64_t a2, mlir::IndexType **a3, uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::InsertSliceOp::reifyResultShapes((uint64_t)&v5, a3, a4);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getDpsInitsMutable;
  v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DestinationStyleOpInterface]";
      v15 = 83;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[124], v2);
}

mlir::MutableOperandRange *mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getDpsInitsMutable@<X0>(uint64_t a1@<X1>, mlir::MutableOperandRange *a2@<X8>)
{
  mlir::OpOperand *DestMutable;
  uint64_t v5;

  v5 = a1;
  DestMutable = (mlir::OpOperand *)mlir::tensor::InsertSliceOp::getDestMutable((mlir::tensor::InsertSliceOp *)&v5);
  return mlir::MutableOperandRange::MutableOperandRange(a2, DestMutable);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::InsertSliceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0xD0uLL, 0x80040B342C78EuLL);
  *v2 = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getOffsetSizeAndStrideStartOperandIndex;
  v2[1] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getArrayAttrMaxRanks;
  v2[2] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getOffsets;
  v2[3] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getSizes;
  v2[4] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getStrides;
  v2[5] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getStaticOffsets;
  v2[6] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getStaticSizes;
  v2[7] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getStaticStrides;
  v2[8] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getMixedOffsets;
  v2[9] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getMixedSizes;
  v2[10] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getMixedStrides;
  v2[11] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::isDynamicOffset;
  v2[12] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::isDynamicSize;
  v2[13] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::isDynamicStride;
  v2[14] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getStaticOffset;
  v2[15] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getStaticSize;
  v2[16] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getStaticStride;
  v2[17] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getIndexOfDynamicOffset;
  v2[18] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getIndexOfDynamicSize;
  v2[19] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getIndexOfDynamicStride;
  v2[20] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getDynamicOffset;
  v2[21] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getDynamicSize;
  v2[22] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getDynamicStride;
  v2[23] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::isSameAs;
  v2[24] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::hasUnitStride;
  v2[25] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::hasZeroOffset;
  v4 = &unk_25451B000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451B000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OffsetSizeAndStrideOpInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OffsetSizeAndStrideOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451B000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[259], v2);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getOffsetSizeAndStrideStartOperandIndex()
{
  return 2;
}

unint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getArrayAttrMaxRanks(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v4;
  unint64_t v5;

  v4 = a2;
  v5 = *(_QWORD *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v4) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v5);
  return v2 | ((unint64_t)v2 << 32);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getOffsets(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::memref::ReinterpretCastOp::getSizes((mlir::memref::ReinterpretCastOp *)&v3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getSizes(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::memref::ReinterpretCastOp::getStrides((mlir::memref::ReinterpretCastOp *)&v3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getStrides(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::tensor::InsertSliceOp::getStrides((mlir::tensor::InsertSliceOp *)&v3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getStaticOffsets(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::memref::ReinterpretCastOp::getStaticOffsets((mlir::memref::ReinterpretCastOp *)&v3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getStaticSizes(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::memref::ReinterpretCastOp::getStaticSizes((mlir::memref::ReinterpretCastOp *)&v3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getStaticStrides(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)&v3);
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getMixedOffsets(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  v2 = a1;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedOffsets((mlir::memref::ReinterpretCastOp *)&v2, a2);
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getMixedSizes(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  v2 = a1;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedSizes((mlir::memref::ReinterpretCastOp *)&v2, a2);
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getMixedStrides(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  v2 = a1;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedStrides((mlir::memref::ReinterpretCastOp *)&v2, a2);
}

BOOL mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::isDynamicOffset(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticOffsets((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3) == 0x8000000000000000;
}

BOOL mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::isDynamicSize(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticSizes((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3) == 0x8000000000000000;
}

BOOL mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::isDynamicStride(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3) == 0x8000000000000000;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getStaticOffset(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticOffsets((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getStaticSize(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticSizes((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getStaticStride(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getIndexOfDynamicOffset(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticOffsets;
  uint64_t v5;
  uint64_t v7;

  v7 = a2;
  StaticOffsets = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticOffsets((mlir::memref::ReinterpretCastOp *)&v7);
  return mlir::detail::getNumDynamicEntriesUpToIdx(StaticOffsets, v5, a3) + 2;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getIndexOfDynamicSize(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticSizes;
  uint64_t v5;
  int NumDynamicEntriesUpToIdx;
  int v7;
  uint64_t v9;

  v9 = a2;
  StaticSizes = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticSizes((mlir::memref::ReinterpretCastOp *)&v9);
  NumDynamicEntriesUpToIdx = mlir::detail::getNumDynamicEntriesUpToIdx(StaticSizes, v5, a3);
  mlir::memref::ReinterpretCastOp::getSizes((mlir::memref::ReinterpretCastOp *)&v9);
  return (NumDynamicEntriesUpToIdx + v7 + 2);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getIndexOfDynamicStride(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticStrides;
  uint64_t v5;
  int NumDynamicEntriesUpToIdx;
  int v7;
  int v8;
  int v9;
  uint64_t v11;

  v11 = a2;
  StaticStrides = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)&v11);
  NumDynamicEntriesUpToIdx = mlir::detail::getNumDynamicEntriesUpToIdx(StaticStrides, v5, a3);
  mlir::memref::ReinterpretCastOp::getSizes((mlir::memref::ReinterpretCastOp *)&v11);
  v8 = v7;
  mlir::memref::ReinterpretCastOp::getStrides((mlir::memref::ReinterpretCastOp *)&v11);
  return (v8 + v9 + NumDynamicEntriesUpToIdx + 2);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getDynamicOffset(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticOffsets;
  uint64_t v5;
  int NumDynamicEntriesUpToIdx;
  uint64_t v8;

  v8 = a2;
  StaticOffsets = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticOffsets((mlir::memref::ReinterpretCastOp *)&v8);
  NumDynamicEntriesUpToIdx = mlir::detail::getNumDynamicEntriesUpToIdx(StaticOffsets, v5, a3);
  return *(_QWORD *)(*(_QWORD *)(v8 + 72) + 32 * (NumDynamicEntriesUpToIdx + 2) + 24);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getDynamicSize(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticSizes;
  uint64_t v5;
  int NumDynamicEntriesUpToIdx;
  int v7;
  uint64_t v9;

  v9 = a2;
  StaticSizes = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticSizes((mlir::memref::ReinterpretCastOp *)&v9);
  NumDynamicEntriesUpToIdx = mlir::detail::getNumDynamicEntriesUpToIdx(StaticSizes, v5, a3);
  mlir::memref::ReinterpretCastOp::getSizes((mlir::memref::ReinterpretCastOp *)&v9);
  return *(_QWORD *)(*(_QWORD *)(v9 + 72) + 32 * (NumDynamicEntriesUpToIdx + v7 + 2) + 24);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::getDynamicStride(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticStrides;
  uint64_t v5;
  int NumDynamicEntriesUpToIdx;
  int v7;
  int v8;
  int v9;
  uint64_t v11;

  v11 = a2;
  StaticStrides = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)&v11);
  NumDynamicEntriesUpToIdx = mlir::detail::getNumDynamicEntriesUpToIdx(StaticStrides, v5, a3);
  mlir::memref::ReinterpretCastOp::getSizes((mlir::memref::ReinterpretCastOp *)&v11);
  v8 = v7;
  mlir::memref::ReinterpretCastOp::getStrides((mlir::memref::ReinterpretCastOp *)&v11);
  return *(_QWORD *)(*(_QWORD *)(v11 + 72) + 32 * (v8 + v9 + NumDynamicEntriesUpToIdx + 2) + 24);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::isSameAs(uint64_t a1, uint64_t InterfaceFor, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, _QWORD, _QWORD), uint64_t a6)
{
  uint64_t v10;

  v10 = InterfaceFor;
  if (InterfaceFor)
    InterfaceFor = mlir::OpInterface<mlir::OffsetSizeAndStrideOpInterface,mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits>::getInterfaceFor(InterfaceFor);
  return mlir::detail::sameOffsetsSizesAndStrides(v10, InterfaceFor, a3, a4, a5, a6);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::hasUnitStride(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t ConstantIntValue;
  char v6;
  BOOL v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v11;
  void *v12;
  unsigned int v13;
  _QWORD v14[5];

  v14[4] = *MEMORY[0x24BDAC8D0];
  v11 = a2;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedStrides((mlir::memref::ReinterpretCastOp *)&v11, (uint64_t)&v12);
  v2 = (uint64_t *)v12;
  if (!v13)
  {
    v8 = 1;
    if (v12 == v14)
      return v8;
    goto LABEL_15;
  }
  v3 = 8 * v13 - 8;
  do
  {
    v4 = *v2++;
    ConstantIntValue = mlir::getConstantIntValue(v4);
    if (v6)
      v7 = ConstantIntValue == 1;
    else
      v7 = 0;
    v8 = v7;
    v9 = (_DWORD)v8 != 1 || v3 == 0;
    v3 -= 8;
  }
  while (!v9);
  v2 = (uint64_t *)v12;
  if (v12 != v14)
LABEL_15:
    free(v2);
  return v8;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::hasZeroOffset(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t ConstantIntValue;
  char v6;
  BOOL v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v11;
  void *v12;
  unsigned int v13;
  _QWORD v14[5];

  v14[4] = *MEMORY[0x24BDAC8D0];
  v11 = a2;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedOffsets((mlir::memref::ReinterpretCastOp *)&v11, (uint64_t)&v12);
  v2 = (uint64_t *)v12;
  if (!v13)
  {
    v8 = 1;
    if (v12 == v14)
      return v8;
    goto LABEL_15;
  }
  v3 = 8 * v13 - 8;
  do
  {
    v4 = *v2++;
    ConstantIntValue = mlir::getConstantIntValue(v4);
    if (v6)
      v7 = ConstantIntValue == 0;
    else
      v7 = 0;
    v8 = v7;
    v9 = (_DWORD)v8 != 1 || v3 == 0;
    v3 -= 8;
  }
  while (!v9);
  v2 = (uint64_t *)v12;
  if (v12 != v14)
LABEL_15:
    free(v2);
  return v8;
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedOffsets(mlir::memref::ReinterpretCastOp *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *StaticOffsets;
  unint64_t v5;
  unint64_t v6;
  uint64_t Sizes;
  unint64_t v8;
  unsigned int v9;
  _QWORD *v10;
  int v11;
  unsigned int v12;
  uint64_t Context;
  unint64_t v14[2];
  void *__src;
  unsigned int v16;
  int v17;
  _QWORD v18[7];

  v18[6] = *MEMORY[0x24BDAC8D0];
  Context = mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)a1 + 24));
  StaticOffsets = (uint64_t *)mlir::memref::ReinterpretCastOp::getStaticOffsets(a1);
  v6 = v5;
  Sizes = mlir::memref::ReinterpretCastOp::getSizes(a1);
  mlir::ValueRange::ValueRange(v14, Sizes, v8);
  mlir::getMixedValues(StaticOffsets, v6, v14[0], v14[1], (mlir::Builder *)&Context, (uint64_t)&__src);
  *(_QWORD *)a2 = a2 + 16;
  *(_QWORD *)(a2 + 8) = 0x400000000;
  v9 = v16;
  v10 = __src;
  if (v16 && &__src != (void **)a2)
  {
    if (__src == v18)
    {
      v12 = v16;
      if (v16 < 5
        || (llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v16, 8), v12 = v16, v10 = __src, v16))
      {
        memcpy(*(void **)a2, v10, 8 * v12);
        v10 = __src;
      }
      *(_DWORD *)(a2 + 8) = v9;
    }
    else
    {
      *(_QWORD *)a2 = __src;
      v11 = v17;
      *(_DWORD *)(a2 + 8) = v9;
      *(_DWORD *)(a2 + 12) = v11;
      __src = v18;
      v17 = 0;
      v10 = v18;
    }
    v16 = 0;
  }
  if (v10 != v18)
    free(v10);
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedSizes(mlir::memref::ReinterpretCastOp *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *StaticSizes;
  unint64_t v5;
  unint64_t v6;
  uint64_t Strides;
  unint64_t v8;
  unsigned int v9;
  _QWORD *v10;
  int v11;
  unsigned int v12;
  uint64_t Context;
  unint64_t v14[2];
  void *__src;
  unsigned int v16;
  int v17;
  _QWORD v18[7];

  v18[6] = *MEMORY[0x24BDAC8D0];
  Context = mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)a1 + 24));
  StaticSizes = (uint64_t *)mlir::memref::ReinterpretCastOp::getStaticSizes(a1);
  v6 = v5;
  Strides = mlir::memref::ReinterpretCastOp::getStrides(a1);
  mlir::ValueRange::ValueRange(v14, Strides, v8);
  mlir::getMixedValues(StaticSizes, v6, v14[0], v14[1], (mlir::Builder *)&Context, (uint64_t)&__src);
  *(_QWORD *)a2 = a2 + 16;
  *(_QWORD *)(a2 + 8) = 0x400000000;
  v9 = v16;
  v10 = __src;
  if (v16 && &__src != (void **)a2)
  {
    if (__src == v18)
    {
      v12 = v16;
      if (v16 < 5
        || (llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v16, 8), v12 = v16, v10 = __src, v16))
      {
        memcpy(*(void **)a2, v10, 8 * v12);
        v10 = __src;
      }
      *(_DWORD *)(a2 + 8) = v9;
    }
    else
    {
      *(_QWORD *)a2 = __src;
      v11 = v17;
      *(_DWORD *)(a2 + 8) = v9;
      *(_DWORD *)(a2 + 12) = v11;
      __src = v18;
      v17 = 0;
      v10 = v18;
    }
    v16 = 0;
  }
  if (v10 != v18)
    free(v10);
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedStrides(mlir::memref::ReinterpretCastOp *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *StaticStrides;
  unint64_t v5;
  unint64_t v6;
  uint64_t Strides;
  unint64_t v8;
  unsigned int v9;
  _QWORD *v10;
  int v11;
  unsigned int v12;
  uint64_t Context;
  unint64_t v14[2];
  void *__src;
  unsigned int v16;
  int v17;
  _QWORD v18[7];

  v18[6] = *MEMORY[0x24BDAC8D0];
  Context = mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)a1 + 24));
  StaticStrides = (uint64_t *)mlir::memref::ReinterpretCastOp::getStaticStrides(a1);
  v6 = v5;
  Strides = mlir::tensor::InsertSliceOp::getStrides(a1);
  mlir::ValueRange::ValueRange(v14, Strides, v8);
  mlir::getMixedValues(StaticStrides, v6, v14[0], v14[1], (mlir::Builder *)&Context, (uint64_t)&__src);
  *(_QWORD *)a2 = a2 + 16;
  *(_QWORD *)(a2 + 8) = 0x400000000;
  v9 = v16;
  v10 = __src;
  if (v16 && &__src != (void **)a2)
  {
    if (__src == v18)
    {
      v12 = v16;
      if (v16 < 5
        || (llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v16, 8), v12 = v16, v10 = __src, v16))
      {
        memcpy(*(void **)a2, v10, 8 * v12);
        v10 = __src;
      }
      *(_DWORD *)(a2 + 8) = v9;
    }
    else
    {
      *(_QWORD *)a2 = __src;
      v11 = v17;
      *(_DWORD *)(a2 + 8) = v9;
      *(_DWORD *)(a2 + 12) = v11;
      __src = v18;
      v17 = 0;
      v10 = v18;
    }
    v16 = 0;
  }
  if (v10 != v18)
    free(v10);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::tensor::InsertOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::tensor::InsertSliceOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::InsertSliceOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::tensor::InsertSliceOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::tensor::InsertOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "tensor.insert_slice";
  v16[1] = 19;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[88];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::InsertSliceOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::tensor::InsertSliceOp::fold(&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  uint64_t v36;
  unsigned __int8 v37;
  _QWORD *v38;
  uint64_t v39;
  unsigned __int8 v40;
  _QWORD *v41;
  uint64_t v42;
  unsigned __int8 v43;
  _QWORD *v44;
  uint64_t v45;
  unsigned __int8 v46;
  _QWORD *v47;
  int v64;
  int v65;
  unint64_t v66;
  unint64_t v67;
  const char *v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  int v73;
  int v74;
  unint64_t v75;
  unint64_t v76;
  const char *v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  int v82;
  int v83;
  unint64_t v84;
  unint64_t v85;
  const char *v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  int v91;
  int v92;
  unint64_t v93;
  unint64_t v94;
  const char *v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t v98;
  uint64_t v99;
  int v100;
  int v101;
  unint64_t v102;
  unint64_t v103;
  const char *v104;
  unint64_t v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  int v109;
  int v110;
  unint64_t v111;
  unint64_t v112;
  const char *v113;
  unint64_t v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  int v118;
  int v119;
  unint64_t v120;
  unint64_t v121;
  const char *v122;
  unint64_t v123;
  uint64_t v124;
  unint64_t v125;
  uint64_t v126;
  int v127;
  int v128;
  unint64_t v129;
  unint64_t v130;
  const char *v131;
  unint64_t v132;
  uint64_t v133;
  unint64_t v134;
  uint64_t v135;
  int v136;
  int v137;
  unint64_t v138;
  unint64_t v139;
  const char *v140;
  unint64_t v141;
  uint64_t v142;
  unint64_t v143;
  uint64_t v144;
  int v145;
  int v146;
  unint64_t v147;
  unint64_t v148;
  const char *v149;
  unint64_t v150;
  uint64_t v151;
  unint64_t v152;
  uint64_t v153;
  int v154;
  int v155;
  unint64_t v156;
  unint64_t v157;
  const char *v158;
  unint64_t v159;
  uint64_t v160;
  unint64_t v161;
  uint64_t v162;
  int v163;
  int v164;
  unint64_t v165;
  unint64_t v166;
  const char *v167;
  unint64_t v168;
  uint64_t v169;
  unint64_t v170;
  uint64_t v171;
  int v172;
  int v173;
  unint64_t v174;
  unint64_t v175;
  const char *v176;
  unint64_t v177;
  uint64_t v178;
  unint64_t v179;
  uint64_t v180;
  int v181;
  int v182;
  unint64_t v183;
  unint64_t v184;
  const char *v185;
  unint64_t v186;
  uint64_t v187;
  unint64_t v188;
  uint64_t v189;
  int v190;
  int v191;
  unint64_t v192;
  unint64_t v193;
  const char *v194;
  unint64_t v195;
  uint64_t v196;
  unint64_t v197;
  uint64_t v198;
  int v199;
  int v200;
  unint64_t v201;
  unint64_t v202;
  const char *v203;
  unint64_t v204;
  uint64_t v205;
  unint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  const char *v344;
  unint64_t v345;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v328 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v65 = v64;
    a1 = v328;
    if (v65)
    {
      v344 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v345 = 83;
      v66 = llvm::StringRef::find((uint64_t *)&v344, "DesiredTypeName = ", 0x12uLL, 0);
      if (v345 >= v66)
        v67 = v66;
      else
        v67 = v345;
      v68 = &v344[v67];
      v69 = v345 - v67;
      if (v345 - v67 >= 0x12)
        v70 = 18;
      else
        v70 = v345 - v67;
      v71 = v69 - v70;
      if (v71 >= v71 - 1)
        v72 = v71 - 1;
      else
        v72 = v71;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v68[v70], v72);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v328;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v313 = v3;
    v329 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v74 = v73;
    v3 = v313;
    a1 = v329;
    if (v74)
    {
      v344 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v345 = 81;
      v75 = llvm::StringRef::find((uint64_t *)&v344, "DesiredTypeName = ", 0x12uLL, 0);
      if (v345 >= v75)
        v76 = v75;
      else
        v76 = v345;
      v77 = &v344[v76];
      v78 = v345 - v76;
      if (v345 - v76 >= 0x12)
        v79 = 18;
      else
        v79 = v345 - v76;
      v80 = v78 - v79;
      if (v80 >= v80 - 1)
        v81 = v80 - 1;
      else
        v81 = v80;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v77[v79], v81);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v313;
      a1 = v329;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v314 = v3;
    v330 = a1;
    v299 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v299;
    v3 = v314;
    v83 = v82;
    a1 = v330;
    if (v83)
    {
      v344 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<Empty>]";
      v345 = 116;
      v84 = llvm::StringRef::find((uint64_t *)&v344, "DesiredTypeName = ", 0x12uLL, 0);
      if (v345 >= v84)
        v85 = v84;
      else
        v85 = v345;
      v86 = &v344[v85];
      v87 = v345 - v85;
      if (v345 - v85 >= 0x12)
        v88 = 18;
      else
        v88 = v345 - v85;
      v89 = v87 - v88;
      if (v89 >= v89 - 1)
        v90 = v89 - 1;
      else
        v90 = v89;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v86[v88], v90);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v299;
      v3 = v314;
      a1 = v330;
    }
  }
  v9 = v8[425];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v315 = v3;
    v331 = a1;
    v286 = v9;
    v300 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v286;
    v6 = v300;
    v92 = v91;
    v3 = v315;
    a1 = v331;
    if (v92)
    {
      v344 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v345 = 86;
      v93 = llvm::StringRef::find((uint64_t *)&v344, "DesiredTypeName = ", 0x12uLL, 0);
      if (v345 >= v93)
        v94 = v93;
      else
        v94 = v345;
      v95 = &v344[v94];
      v96 = v345 - v94;
      if (v345 - v94 >= 0x12)
        v97 = 18;
      else
        v97 = v345 - v94;
      v98 = v96 - v97;
      if (v98 >= v98 - 1)
        v99 = v98 - 1;
      else
        v99 = v98;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v95[v97], v99);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v286;
      v6 = v300;
      v3 = v315;
      a1 = v331;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v316 = v3;
    v332 = a1;
    v287 = v9;
    v301 = v6;
    v274 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v274;
    v9 = v287;
    v6 = v301;
    v3 = v316;
    v101 = v100;
    a1 = v332;
    if (v101)
    {
      v344 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<2>::Impl<Empty>]";
      v345 = 97;
      v102 = llvm::StringRef::find((uint64_t *)&v344, "DesiredTypeName = ", 0x12uLL, 0);
      if (v345 >= v102)
        v103 = v102;
      else
        v103 = v345;
      v104 = &v344[v103];
      v105 = v345 - v103;
      if (v345 - v103 >= 0x12)
        v106 = 18;
      else
        v106 = v345 - v103;
      v107 = v105 - v106;
      if (v107 >= v107 - 1)
        v108 = v107 - 1;
      else
        v108 = v107;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v104[v106], v108);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v274;
      v9 = v287;
      v6 = v301;
      v3 = v316;
      a1 = v332;
    }
  }
  v15 = v14[431];
  v17 = &unk_25451B000;
  if ((v16 & 1) == 0)
  {
    v317 = v3;
    v333 = a1;
    v288 = v9;
    v302 = v6;
    v275 = v12;
    v263 = v15;
    v17 = (_QWORD *)&unk_25451B000;
    v15 = v263;
    v12 = v275;
    v9 = v288;
    v6 = v302;
    v3 = v317;
    v110 = v109;
    a1 = v333;
    if (v110)
    {
      v344 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      v345 = 96;
      v111 = llvm::StringRef::find((uint64_t *)&v344, "DesiredTypeName = ", 0x12uLL, 0);
      if (v345 >= v111)
        v112 = v111;
      else
        v112 = v345;
      v113 = &v344[v112];
      v114 = v345 - v112;
      if (v345 - v112 >= 0x12)
        v115 = 18;
      else
        v115 = v345 - v112;
      v116 = v114 - v115;
      if (v116 >= v116 - 1)
        v117 = v116 - 1;
      else
        v117 = v116;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v113[v115], v117);
      v17 = (_QWORD *)&unk_25451B000;
      v15 = v263;
      v12 = v275;
      v9 = v288;
      v6 = v302;
      v3 = v317;
      a1 = v333;
    }
  }
  v18 = v17[37];
  v20 = &unk_254519000;
  if ((v19 & 1) == 0)
  {
    v318 = v3;
    v334 = a1;
    v289 = v9;
    v303 = v6;
    v276 = v12;
    v253 = v18;
    v264 = v15;
    v20 = (_QWORD *)&unk_254519000;
    v18 = v253;
    v15 = v264;
    v12 = v276;
    v9 = v289;
    v6 = v303;
    v3 = v318;
    v119 = v118;
    a1 = v334;
    if (v119)
    {
      v344 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v345 = 84;
      v120 = llvm::StringRef::find((uint64_t *)&v344, "DesiredTypeName = ", 0x12uLL, 0);
      if (v345 >= v120)
        v121 = v120;
      else
        v121 = v345;
      v122 = &v344[v121];
      v123 = v345 - v121;
      if (v345 - v121 >= 0x12)
        v124 = 18;
      else
        v124 = v345 - v121;
      v125 = v123 - v124;
      if (v125 >= v125 - 1)
        v126 = v125 - 1;
      else
        v126 = v125;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v122[v124], v126);
      v20 = (_QWORD *)&unk_254519000;
      v18 = v253;
      v15 = v264;
      v12 = v276;
      v9 = v289;
      v6 = v303;
      v3 = v318;
      a1 = v334;
    }
  }
  v21 = v20[423];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v319 = v3;
    v335 = a1;
    v290 = v9;
    v304 = v6;
    v277 = v12;
    v254 = v18;
    v265 = v15;
    v244 = v21;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v244;
    v18 = v254;
    v15 = v265;
    v12 = v277;
    v9 = v290;
    v6 = v304;
    v3 = v319;
    v128 = v127;
    a1 = v335;
    if (v128)
    {
      v344 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v345 = 89;
      v129 = llvm::StringRef::find((uint64_t *)&v344, "DesiredTypeName = ", 0x12uLL, 0);
      if (v345 >= v129)
        v130 = v129;
      else
        v130 = v345;
      v131 = &v344[v130];
      v132 = v345 - v130;
      if (v345 - v130 >= 0x12)
        v133 = 18;
      else
        v133 = v345 - v130;
      v134 = v132 - v133;
      if (v134 >= v134 - 1)
        v135 = v134 - 1;
      else
        v135 = v134;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v131[v133], v135);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v244;
      v18 = v254;
      v15 = v265;
      v12 = v277;
      v9 = v290;
      v6 = v304;
      v3 = v319;
      a1 = v335;
    }
  }
  v24 = v23[310];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v320 = v3;
    v336 = a1;
    v291 = v9;
    v305 = v6;
    v278 = v12;
    v255 = v18;
    v266 = v15;
    v236 = v24;
    v245 = v21;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v236;
    v21 = v245;
    v18 = v255;
    v15 = v266;
    v12 = v278;
    v9 = v291;
    v6 = v305;
    v3 = v320;
    v137 = v136;
    a1 = v336;
    if (v137)
    {
      v344 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v345 = 86;
      v138 = llvm::StringRef::find((uint64_t *)&v344, "DesiredTypeName = ", 0x12uLL, 0);
      if (v345 >= v138)
        v139 = v138;
      else
        v139 = v345;
      v140 = &v344[v139];
      v141 = v345 - v139;
      if (v345 - v139 >= 0x12)
        v142 = 18;
      else
        v142 = v345 - v139;
      v143 = v141 - v142;
      if (v143 >= v143 - 1)
        v144 = v143 - 1;
      else
        v144 = v143;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v140[v142], v144);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v236;
      v21 = v245;
      v18 = v255;
      v15 = v266;
      v12 = v278;
      v9 = v291;
      v6 = v305;
      v3 = v320;
      a1 = v336;
    }
  }
  v27 = v26[340];
  v29 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v321 = v3;
    v337 = a1;
    v292 = v9;
    v306 = v6;
    v279 = v12;
    v256 = v18;
    v267 = v15;
    v237 = v24;
    v246 = v21;
    v229 = v27;
    v29 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v27 = v229;
    v24 = v237;
    v21 = v246;
    v18 = v256;
    v15 = v267;
    v12 = v279;
    v9 = v292;
    v6 = v306;
    v3 = v321;
    v146 = v145;
    a1 = v337;
    if (v146)
    {
      v344 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ReifyRankedShapedTypeOpInterface::Trait<Empty>]";
      v345 = 102;
      v147 = llvm::StringRef::find((uint64_t *)&v344, "DesiredTypeName = ", 0x12uLL, 0);
      if (v345 >= v147)
        v148 = v147;
      else
        v148 = v345;
      v149 = &v344[v148];
      v150 = v345 - v148;
      if (v345 - v148 >= 0x12)
        v151 = 18;
      else
        v151 = v345 - v148;
      v152 = v150 - v151;
      if (v152 >= v152 - 1)
        v153 = v152 - 1;
      else
        v153 = v152;
      mlir::detail::TypeIDResolver<mlir::ReifyRankedShapedTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ReifyRankedShapedTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v149[v151], v153);
      v29 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v27 = v229;
      v24 = v237;
      v21 = v246;
      v18 = v256;
      v15 = v267;
      v12 = v279;
      v9 = v292;
      v6 = v306;
      v3 = v321;
      a1 = v337;
    }
  }
  v30 = v29[168];
  v32 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v322 = v3;
    v338 = a1;
    v293 = v9;
    v307 = v6;
    v280 = v12;
    v257 = v18;
    v268 = v15;
    v238 = v24;
    v247 = v21;
    v223 = v30;
    v230 = v27;
    v32 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v30 = v223;
    v27 = v230;
    v24 = v238;
    v21 = v247;
    v18 = v257;
    v15 = v268;
    v12 = v280;
    v9 = v293;
    v6 = v307;
    v3 = v322;
    v155 = v154;
    a1 = v338;
    if (v155)
    {
      v344 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DestinationStyleOpInterface::Trait<Empty>]";
      v345 = 97;
      v156 = llvm::StringRef::find((uint64_t *)&v344, "DesiredTypeName = ", 0x12uLL, 0);
      if (v345 >= v156)
        v157 = v156;
      else
        v157 = v345;
      v158 = &v344[v157];
      v159 = v345 - v157;
      if (v345 - v157 >= 0x12)
        v160 = 18;
      else
        v160 = v345 - v157;
      v161 = v159 - v160;
      if (v161 >= v161 - 1)
        v162 = v161 - 1;
      else
        v162 = v161;
      mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DestinationStyleOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v158[v160], v162);
      v32 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v30 = v223;
      v27 = v230;
      v24 = v238;
      v21 = v247;
      v18 = v257;
      v15 = v268;
      v12 = v280;
      v9 = v293;
      v6 = v307;
      v3 = v322;
      a1 = v338;
    }
  }
  v33 = v32[128];
  v35 = &unk_25451A000;
  if ((v34 & 1) == 0)
  {
    v323 = v3;
    v339 = a1;
    v294 = v9;
    v308 = v6;
    v281 = v12;
    v258 = v18;
    v269 = v15;
    v239 = v24;
    v248 = v21;
    v224 = v30;
    v231 = v27;
    v218 = v33;
    v35 = (_QWORD *)&unk_25451A000;
    v33 = v218;
    v30 = v224;
    v27 = v231;
    v24 = v239;
    v21 = v248;
    v18 = v258;
    v15 = v269;
    v12 = v281;
    v9 = v294;
    v6 = v308;
    v3 = v323;
    v164 = v163;
    a1 = v339;
    if (v164)
    {
      v344 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v345 = 95;
      v165 = llvm::StringRef::find((uint64_t *)&v344, "DesiredTypeName = ", 0x12uLL, 0);
      if (v345 >= v165)
        v166 = v165;
      else
        v166 = v345;
      v167 = &v344[v166];
      v168 = v345 - v166;
      if (v345 - v166 >= 0x12)
        v169 = 18;
      else
        v169 = v345 - v166;
      v170 = v168 - v169;
      if (v170 >= v170 - 1)
        v171 = v170 - 1;
      else
        v171 = v170;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v167[v169], v171);
      v35 = (_QWORD *)&unk_25451A000;
      v33 = v218;
      v30 = v224;
      v27 = v231;
      v24 = v239;
      v21 = v248;
      v18 = v258;
      v15 = v269;
      v12 = v281;
      v9 = v294;
      v6 = v308;
      v3 = v323;
      a1 = v339;
    }
  }
  v36 = v35[312];
  v38 = &unk_25451A000;
  if ((v37 & 1) == 0)
  {
    v324 = v3;
    v340 = a1;
    v295 = v9;
    v309 = v6;
    v282 = v12;
    v259 = v18;
    v270 = v15;
    v240 = v24;
    v249 = v21;
    v225 = v30;
    v232 = v27;
    v214 = v36;
    v219 = v33;
    v38 = (_QWORD *)&unk_25451A000;
    v36 = v214;
    v33 = v219;
    v30 = v225;
    v27 = v232;
    v24 = v240;
    v21 = v249;
    v18 = v259;
    v15 = v270;
    v12 = v282;
    v9 = v295;
    v6 = v309;
    v3 = v324;
    v173 = v172;
    a1 = v340;
    if (v173)
    {
      v344 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v345 = 99;
      v174 = llvm::StringRef::find((uint64_t *)&v344, "DesiredTypeName = ", 0x12uLL, 0);
      if (v345 >= v174)
        v175 = v174;
      else
        v175 = v345;
      v176 = &v344[v175];
      v177 = v345 - v175;
      if (v345 - v175 >= 0x12)
        v178 = 18;
      else
        v178 = v345 - v175;
      v179 = v177 - v178;
      if (v179 >= v179 - 1)
        v180 = v179 - 1;
      else
        v180 = v179;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v176[v178], v180);
      v38 = (_QWORD *)&unk_25451A000;
      v36 = v214;
      v33 = v219;
      v30 = v225;
      v27 = v232;
      v24 = v240;
      v21 = v249;
      v18 = v259;
      v15 = v270;
      v12 = v282;
      v9 = v295;
      v6 = v309;
      v3 = v324;
      a1 = v340;
    }
  }
  v39 = v38[314];
  v41 = &unk_25451A000;
  if ((v40 & 1) == 0)
  {
    v325 = v3;
    v341 = a1;
    v296 = v9;
    v310 = v6;
    v283 = v12;
    v260 = v18;
    v271 = v15;
    v241 = v24;
    v250 = v21;
    v226 = v30;
    v233 = v27;
    v215 = v36;
    v220 = v33;
    v211 = v39;
    v41 = (_QWORD *)&unk_25451A000;
    v39 = v211;
    v36 = v215;
    v33 = v220;
    v30 = v226;
    v27 = v233;
    v24 = v241;
    v21 = v250;
    v18 = v260;
    v15 = v271;
    v12 = v283;
    v9 = v296;
    v6 = v310;
    v3 = v325;
    v182 = v181;
    a1 = v341;
    if (v182)
    {
      v344 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v345 = 93;
      v183 = llvm::StringRef::find((uint64_t *)&v344, "DesiredTypeName = ", 0x12uLL, 0);
      if (v345 >= v183)
        v184 = v183;
      else
        v184 = v345;
      v185 = &v344[v184];
      v186 = v345 - v184;
      if (v345 - v184 >= 0x12)
        v187 = 18;
      else
        v187 = v345 - v184;
      v188 = v186 - v187;
      if (v188 >= v188 - 1)
        v189 = v188 - 1;
      else
        v189 = v188;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v185[v187], v189);
      v41 = (_QWORD *)&unk_25451A000;
      v39 = v211;
      v36 = v215;
      v33 = v220;
      v30 = v226;
      v27 = v233;
      v24 = v241;
      v21 = v250;
      v18 = v260;
      v15 = v271;
      v12 = v283;
      v9 = v296;
      v6 = v310;
      v3 = v325;
      a1 = v341;
    }
  }
  v42 = v41[21];
  v44 = &unk_25451B000;
  if ((v43 & 1) == 0)
  {
    v326 = v3;
    v342 = a1;
    v297 = v9;
    v311 = v6;
    v284 = v12;
    v261 = v18;
    v272 = v15;
    v242 = v24;
    v251 = v21;
    v227 = v30;
    v234 = v27;
    v216 = v36;
    v221 = v33;
    v209 = v42;
    v212 = v39;
    v44 = (_QWORD *)&unk_25451B000;
    v42 = v209;
    v39 = v212;
    v36 = v216;
    v33 = v221;
    v30 = v227;
    v27 = v234;
    v24 = v242;
    v21 = v251;
    v18 = v261;
    v15 = v272;
    v12 = v284;
    v9 = v297;
    v6 = v311;
    v3 = v326;
    v191 = v190;
    a1 = v342;
    if (v191)
    {
      v344 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OffsetSizeAndStrideOpInterface::Trait<Empty>]";
      v345 = 100;
      v192 = llvm::StringRef::find((uint64_t *)&v344, "DesiredTypeName = ", 0x12uLL, 0);
      if (v345 >= v192)
        v193 = v192;
      else
        v193 = v345;
      v194 = &v344[v193];
      v195 = v345 - v193;
      if (v345 - v193 >= 0x12)
        v196 = 18;
      else
        v196 = v345 - v193;
      v197 = v195 - v196;
      if (v197 >= v197 - 1)
        v198 = v197 - 1;
      else
        v198 = v197;
      mlir::detail::TypeIDResolver<mlir::OffsetSizeAndStrideOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OffsetSizeAndStrideOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v194[v196], v198);
      v44 = (_QWORD *)&unk_25451B000;
      v42 = v209;
      v39 = v212;
      v36 = v216;
      v33 = v221;
      v30 = v227;
      v27 = v234;
      v24 = v242;
      v21 = v251;
      v18 = v261;
      v15 = v272;
      v12 = v284;
      v9 = v297;
      v6 = v311;
      v3 = v326;
      a1 = v342;
    }
  }
  v45 = v44[261];
  v47 = &unk_25451A000;
  if ((v46 & 1) == 0)
  {
    v327 = v3;
    v343 = a1;
    v298 = v9;
    v312 = v6;
    v285 = v12;
    v262 = v18;
    v273 = v15;
    v243 = v24;
    v252 = v21;
    v228 = v30;
    v235 = v27;
    v217 = v36;
    v222 = v33;
    v210 = v42;
    v213 = v39;
    v208 = v45;
    v47 = (_QWORD *)&unk_25451A000;
    v45 = v208;
    v42 = v210;
    v39 = v213;
    v36 = v217;
    v33 = v222;
    v30 = v228;
    v27 = v235;
    v24 = v243;
    v21 = v252;
    v18 = v262;
    v15 = v273;
    v12 = v285;
    v9 = v298;
    v6 = v312;
    v3 = v327;
    v200 = v199;
    a1 = v343;
    if (v200)
    {
      v344 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v345 = 90;
      v201 = llvm::StringRef::find((uint64_t *)&v344, "DesiredTypeName = ", 0x12uLL, 0);
      if (v345 >= v201)
        v202 = v201;
      else
        v202 = v345;
      v203 = &v344[v202];
      v204 = v345 - v202;
      if (v345 - v202 >= 0x12)
        v205 = 18;
      else
        v205 = v345 - v202;
      v206 = v204 - v205;
      if (v206 >= v206 - 1)
        v207 = v206 - 1;
      else
        v207 = v206;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v203[v205], v207);
      v47 = (_QWORD *)&unk_25451A000;
      v45 = v208;
      v42 = v210;
      v39 = v213;
      v36 = v217;
      v33 = v222;
      v30 = v228;
      v27 = v235;
      v24 = v243;
      v21 = v252;
      v18 = v262;
      v15 = v273;
      v12 = v285;
      v9 = v298;
      v6 = v312;
      v3 = v327;
      a1 = v343;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v36 == a1
      || v39 == a1
      || v42 == a1
      || v45 == a1
      || v47[27] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;

  mlir::OpState::printOpName(a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::tensor::InsertSliceOp::print((mlir::tensor::InsertSliceOp *)&v7, a3);
}

BOOL mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t *a1, mlir::Operation *a2)
{
  char v3;
  uint64_t *v5;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::tensor::InsertSliceOp>,mlir::OpTrait::OneResult<mlir::tensor::InsertSliceOp>,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::tensor::InsertSliceOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::InsertSliceOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::tensor::InsertSliceOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::tensor::InsertSliceOp>,mlir::OpTrait::OpInvariants<mlir::tensor::InsertSliceOp>,mlir::BytecodeOpInterface::Trait<mlir::tensor::InsertSliceOp>,mlir::OpAsmOpInterface::Trait<mlir::tensor::InsertSliceOp>,mlir::ReifyRankedShapedTypeOpInterface::Trait<mlir::tensor::InsertSliceOp>,mlir::DestinationStyleOpInterface::Trait<mlir::tensor::InsertSliceOp>,mlir::ConditionallySpeculatable::Trait<mlir::tensor::InsertSliceOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::tensor::InsertSliceOp>,mlir::MemoryEffectOpInterface::Trait<mlir::tensor::InsertSliceOp>,mlir::OffsetSizeAndStrideOpInterface::Trait<mlir::tensor::InsertSliceOp>,mlir::InferTypeOpInterface::Trait<mlir::tensor::InsertSliceOp>>(a1, a2))return 0;
  v5 = a1;
  mlir::tensor::InsertSliceOp::verify((mlir::tensor::InsertSliceOp *)&v5);
  return v3 != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::tensor::InsertSliceOp>,mlir::OpTrait::OneResult<mlir::tensor::InsertSliceOp>,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::tensor::InsertSliceOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::InsertSliceOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::tensor::InsertSliceOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::tensor::InsertSliceOp>,mlir::OpTrait::OpInvariants<mlir::tensor::InsertSliceOp>,mlir::BytecodeOpInterface::Trait<mlir::tensor::InsertSliceOp>,mlir::OpAsmOpInterface::Trait<mlir::tensor::InsertSliceOp>,mlir::ReifyRankedShapedTypeOpInterface::Trait<mlir::tensor::InsertSliceOp>,mlir::DestinationStyleOpInterface::Trait<mlir::tensor::InsertSliceOp>,mlir::ConditionallySpeculatable::Trait<mlir::tensor::InsertSliceOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::tensor::InsertSliceOp>,mlir::MemoryEffectOpInterface::Trait<mlir::tensor::InsertSliceOp>,mlir::OffsetSizeAndStrideOpInterface::Trait<mlir::tensor::InsertSliceOp>,mlir::InferTypeOpInterface::Trait<mlir::tensor::InsertSliceOp>>(uint64_t *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)2)
    && mlir::OpTrait::impl::verifyOperandSizeAttr((uint64_t)a1, "operandSegmentSizes", 0x13uLL)
    && (v6 = a1, mlir::tensor::InsertSliceOp::verifyInvariantsImpl(&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OffsetSizeAndStrideOpInterface::Trait<mlir::memref::ReinterpretCastOp>>(a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::tensor::InsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;

  return mlir::detail::verifyDestinationStyleOpInterface(a1, a2)
      && mlir::detail::verifyInferredResultTypes(a1, v3) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::PackOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.pack", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::PackOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04D240;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  return mlir::tensor::PackOp::getCanonicalizationPatterns(a2);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::tensor::PackOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                    + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, size_t a4)
{
  mlir::MLIRContext *Context;
  _QWORD *v8;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::tensor::PackOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  _QWORD *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::tensor::PackOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::MLIRContext *Context;
  uint64_t *v6;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::tensor::PackOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::tensor::PackOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::getOpPropertyByteSize()
{
  return 40;
}

double mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[1];
    *(_QWORD *)(a3 + 32) = *((_QWORD *)a4 + 4);
    *(_OWORD *)a3 = v4;
    *(_OWORD *)(a3 + 16) = v5;
  }
  else
  {
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)&v4 = 0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::tensor::PackOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::tensor::PackOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  return a3[3] == a2[3] && a3[4] == a2[4];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::memref::ReinterpretCastOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::tensor::PackOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::PackOp::getAsmResultNames((uint64_t)&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::getDpsInitsMutable;
  v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DestinationStyleOpInterface]";
      v15 = 83;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[124], v2);
}

mlir::MutableOperandRange *mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::getDpsInitsMutable@<X0>(uint64_t a1@<X1>, mlir::MutableOperandRange *a2@<X8>)
{
  mlir::OpOperand *DestMutable;
  uint64_t v5;

  v5 = a1;
  DestMutable = (mlir::OpOperand *)mlir::tensor::InsertSliceOp::getDestMutable((mlir::tensor::InsertSliceOp *)&v5);
  return mlir::MutableOperandRange::MutableOperandRange(a2, DestMutable);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::PackOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::PackOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::PackOp>::getSpeculatability(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::tensor::PackOp::getSpeculatability((mlir::tensor::PackOp *)&v3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::reifyResultShapes;
  v4 = &unk_25451B000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451B000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ReifyRankedShapedTypeOpInterface]";
      v15 = 88;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ReifyRankedShapedTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451B000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[171], v2);
}

uint64_t mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::reifyResultShapes(uint64_t a1, uint64_t a2, mlir::IndexType **a3, uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::PackOp::reifyResultShapes(&v5, a3, a4);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::tensor::InsertOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::tensor::PackOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::PackOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::tensor::PackOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::tensor::InsertOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "tensor.pack";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[80];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::tensor::detail::PackOpGenericAdaptorBase::PackOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::tensor::PackOp::fold((uint64_t)&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  uint64_t v36;
  unsigned __int8 v37;
  uint64_t *v38;
  uint64_t v39;
  unsigned __int8 v40;
  _QWORD *v41;
  int v56;
  int v57;
  unint64_t v58;
  unint64_t v59;
  const char *v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  int v65;
  int v66;
  unint64_t v67;
  unint64_t v68;
  const char *v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  int v74;
  int v75;
  unint64_t v76;
  unint64_t v77;
  const char *v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  int v83;
  int v84;
  unint64_t v85;
  unint64_t v86;
  const char *v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  int v92;
  int v93;
  unint64_t v94;
  unint64_t v95;
  const char *v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  int v101;
  int v102;
  unint64_t v103;
  unint64_t v104;
  const char *v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  int v110;
  int v111;
  unint64_t v112;
  unint64_t v113;
  const char *v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  int v119;
  int v120;
  unint64_t v121;
  unint64_t v122;
  const char *v123;
  unint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  int v128;
  int v129;
  unint64_t v130;
  unint64_t v131;
  const char *v132;
  unint64_t v133;
  uint64_t v134;
  unint64_t v135;
  uint64_t v136;
  int v137;
  int v138;
  unint64_t v139;
  unint64_t v140;
  const char *v141;
  unint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  int v146;
  int v147;
  unint64_t v148;
  unint64_t v149;
  const char *v150;
  unint64_t v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t v154;
  int v155;
  int v156;
  unint64_t v157;
  unint64_t v158;
  const char *v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  int v164;
  int v165;
  unint64_t v166;
  unint64_t v167;
  const char *v168;
  unint64_t v169;
  uint64_t v170;
  unint64_t v171;
  uint64_t v172;
  int v173;
  int v174;
  unint64_t v175;
  unint64_t v176;
  const char *v177;
  unint64_t v178;
  uint64_t v179;
  unint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  const char *v287;
  unint64_t v288;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v273 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v57 = v56;
    a1 = v273;
    if (v57)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v288 = 83;
      v58 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v58)
        v59 = v58;
      else
        v59 = v288;
      v60 = &v287[v59];
      v61 = v288 - v59;
      if (v288 - v59 >= 0x12)
        v62 = 18;
      else
        v62 = v288 - v59;
      v63 = v61 - v62;
      if (v63 >= v63 - 1)
        v64 = v63 - 1;
      else
        v64 = v63;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v60[v62], v64);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v273;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v260 = v3;
    v274 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v66 = v65;
    v3 = v260;
    a1 = v274;
    if (v66)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v288 = 81;
      v67 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v67)
        v68 = v67;
      else
        v68 = v288;
      v69 = &v287[v68];
      v70 = v288 - v68;
      if (v288 - v68 >= 0x12)
        v71 = 18;
      else
        v71 = v288 - v68;
      v72 = v70 - v71;
      if (v72 >= v72 - 1)
        v73 = v72 - 1;
      else
        v73 = v72;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v69[v71], v73);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v260;
      a1 = v274;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v261 = v3;
    v275 = a1;
    v248 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v248;
    v3 = v261;
    v75 = v74;
    a1 = v275;
    if (v75)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<Empty>]";
      v288 = 116;
      v76 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v76)
        v77 = v76;
      else
        v77 = v288;
      v78 = &v287[v77];
      v79 = v288 - v77;
      if (v288 - v77 >= 0x12)
        v80 = 18;
      else
        v80 = v288 - v77;
      v81 = v79 - v80;
      if (v81 >= v81 - 1)
        v82 = v81 - 1;
      else
        v82 = v81;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v78[v80], v82);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v248;
      v3 = v261;
      a1 = v275;
    }
  }
  v9 = v8[425];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v262 = v3;
    v276 = a1;
    v237 = v9;
    v249 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v237;
    v6 = v249;
    v84 = v83;
    v3 = v262;
    a1 = v276;
    if (v84)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v288 = 86;
      v85 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v85)
        v86 = v85;
      else
        v86 = v288;
      v87 = &v287[v86];
      v88 = v288 - v86;
      if (v288 - v86 >= 0x12)
        v89 = 18;
      else
        v89 = v288 - v86;
      v90 = v88 - v89;
      if (v90 >= v90 - 1)
        v91 = v90 - 1;
      else
        v91 = v90;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v87[v89], v91);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v237;
      v6 = v249;
      v3 = v262;
      a1 = v276;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v263 = v3;
    v277 = a1;
    v238 = v9;
    v250 = v6;
    v227 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v227;
    v9 = v238;
    v6 = v250;
    v93 = v92;
    v3 = v263;
    a1 = v277;
    if (v93)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<2>::Impl<Empty>]";
      v288 = 97;
      v94 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v94)
        v95 = v94;
      else
        v95 = v288;
      v96 = &v287[v95];
      v97 = v288 - v95;
      if (v288 - v95 >= 0x12)
        v98 = 18;
      else
        v98 = v288 - v95;
      v99 = v97 - v98;
      if (v99 >= v99 - 1)
        v100 = v99 - 1;
      else
        v100 = v99;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v96[v98], v100);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v227;
      v9 = v238;
      v6 = v250;
      v3 = v263;
      a1 = v277;
    }
  }
  v15 = v14[431];
  v17 = &unk_25451B000;
  if ((v16 & 1) == 0)
  {
    v264 = v3;
    v278 = a1;
    v239 = v9;
    v251 = v6;
    v218 = v15;
    v228 = v12;
    v17 = (_QWORD *)&unk_25451B000;
    v15 = v218;
    v12 = v228;
    v9 = v239;
    v6 = v251;
    v102 = v101;
    v3 = v264;
    a1 = v278;
    if (v102)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      v288 = 96;
      v103 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v103)
        v104 = v103;
      else
        v104 = v288;
      v105 = &v287[v104];
      v106 = v288 - v104;
      if (v288 - v104 >= 0x12)
        v107 = 18;
      else
        v107 = v288 - v104;
      v108 = v106 - v107;
      if (v108 >= v108 - 1)
        v109 = v108 - 1;
      else
        v109 = v108;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v105[v107], v109);
      v17 = (_QWORD *)&unk_25451B000;
      v15 = v218;
      v12 = v228;
      v9 = v239;
      v6 = v251;
      v3 = v264;
      a1 = v278;
    }
  }
  v18 = v17[37];
  v20 = &unk_254519000;
  if ((v19 & 1) == 0)
  {
    v265 = v3;
    v279 = a1;
    v240 = v9;
    v252 = v6;
    v219 = v15;
    v229 = v12;
    v210 = v18;
    v20 = (_QWORD *)&unk_254519000;
    v18 = v210;
    v15 = v219;
    v12 = v229;
    v9 = v240;
    v6 = v252;
    v111 = v110;
    v3 = v265;
    a1 = v279;
    if (v111)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v288 = 84;
      v112 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v112)
        v113 = v112;
      else
        v113 = v288;
      v114 = &v287[v113];
      v115 = v288 - v113;
      if (v288 - v113 >= 0x12)
        v116 = 18;
      else
        v116 = v288 - v113;
      v117 = v115 - v116;
      if (v117 >= v117 - 1)
        v118 = v117 - 1;
      else
        v118 = v117;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v114[v116], v118);
      v20 = (_QWORD *)&unk_254519000;
      v18 = v210;
      v15 = v219;
      v12 = v229;
      v9 = v240;
      v6 = v252;
      v3 = v265;
      a1 = v279;
    }
  }
  v21 = v20[423];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v266 = v3;
    v280 = a1;
    v241 = v9;
    v253 = v6;
    v220 = v15;
    v230 = v12;
    v203 = v21;
    v211 = v18;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v203;
    v18 = v211;
    v15 = v220;
    v12 = v230;
    v9 = v241;
    v6 = v253;
    v120 = v119;
    v3 = v266;
    a1 = v280;
    if (v120)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v288 = 89;
      v121 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v121)
        v122 = v121;
      else
        v122 = v288;
      v123 = &v287[v122];
      v124 = v288 - v122;
      if (v288 - v122 >= 0x12)
        v125 = 18;
      else
        v125 = v288 - v122;
      v126 = v124 - v125;
      if (v126 >= v126 - 1)
        v127 = v126 - 1;
      else
        v127 = v126;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v123[v125], v127);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v203;
      v18 = v211;
      v15 = v220;
      v12 = v230;
      v9 = v241;
      v6 = v253;
      v3 = v266;
      a1 = v280;
    }
  }
  v24 = v23[310];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v267 = v3;
    v281 = a1;
    v242 = v9;
    v254 = v6;
    v221 = v15;
    v231 = v12;
    v204 = v21;
    v212 = v18;
    v197 = v24;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v197;
    v21 = v204;
    v18 = v212;
    v15 = v221;
    v12 = v231;
    v9 = v242;
    v6 = v254;
    v129 = v128;
    v3 = v267;
    a1 = v281;
    if (v129)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v288 = 86;
      v130 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v130)
        v131 = v130;
      else
        v131 = v288;
      v132 = &v287[v131];
      v133 = v288 - v131;
      if (v288 - v131 >= 0x12)
        v134 = 18;
      else
        v134 = v288 - v131;
      v135 = v133 - v134;
      if (v135 >= v135 - 1)
        v136 = v135 - 1;
      else
        v136 = v135;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v132[v134], v136);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v197;
      v21 = v204;
      v18 = v212;
      v15 = v221;
      v12 = v231;
      v9 = v242;
      v6 = v254;
      v3 = v267;
      a1 = v281;
    }
  }
  v27 = v26[340];
  v29 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v268 = v3;
    v282 = a1;
    v243 = v9;
    v255 = v6;
    v222 = v15;
    v232 = v12;
    v205 = v21;
    v213 = v18;
    v192 = v27;
    v198 = v24;
    v29 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v27 = v192;
    v24 = v198;
    v21 = v205;
    v18 = v213;
    v15 = v222;
    v12 = v232;
    v9 = v243;
    v6 = v255;
    v138 = v137;
    v3 = v268;
    a1 = v282;
    if (v138)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DestinationStyleOpInterface::Trait<Empty>]";
      v288 = 97;
      v139 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v139)
        v140 = v139;
      else
        v140 = v288;
      v141 = &v287[v140];
      v142 = v288 - v140;
      if (v288 - v140 >= 0x12)
        v143 = 18;
      else
        v143 = v288 - v140;
      v144 = v142 - v143;
      if (v144 >= v144 - 1)
        v145 = v144 - 1;
      else
        v145 = v144;
      mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DestinationStyleOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v141[v143], v145);
      v29 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v27 = v192;
      v24 = v198;
      v21 = v205;
      v18 = v213;
      v15 = v222;
      v12 = v232;
      v9 = v243;
      v6 = v255;
      v3 = v268;
      a1 = v282;
    }
  }
  v30 = v29[128];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v269 = v3;
    v283 = a1;
    v244 = v9;
    v256 = v6;
    v223 = v15;
    v233 = v12;
    v206 = v21;
    v214 = v18;
    v193 = v27;
    v199 = v24;
    v188 = v30;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v188;
    v27 = v193;
    v24 = v199;
    v21 = v206;
    v18 = v214;
    v15 = v223;
    v12 = v233;
    v9 = v244;
    v6 = v256;
    v147 = v146;
    v3 = v269;
    a1 = v283;
    if (v147)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v288 = 95;
      v148 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v148)
        v149 = v148;
      else
        v149 = v288;
      v150 = &v287[v149];
      v151 = v288 - v149;
      if (v288 - v149 >= 0x12)
        v152 = 18;
      else
        v152 = v288 - v149;
      v153 = v151 - v152;
      if (v153 >= v153 - 1)
        v154 = v153 - 1;
      else
        v154 = v153;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v150[v152], v154);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v188;
      v27 = v193;
      v24 = v199;
      v21 = v206;
      v18 = v214;
      v15 = v223;
      v12 = v233;
      v9 = v244;
      v6 = v256;
      v3 = v269;
      a1 = v283;
    }
  }
  v33 = v32[312];
  v35 = &unk_25451A000;
  if ((v34 & 1) == 0)
  {
    v270 = v3;
    v284 = a1;
    v245 = v9;
    v257 = v6;
    v224 = v15;
    v234 = v12;
    v207 = v21;
    v215 = v18;
    v194 = v27;
    v200 = v24;
    v185 = v33;
    v189 = v30;
    v35 = (_QWORD *)&unk_25451A000;
    v33 = v185;
    v30 = v189;
    v27 = v194;
    v24 = v200;
    v21 = v207;
    v18 = v215;
    v15 = v224;
    v12 = v234;
    v9 = v245;
    v6 = v257;
    v156 = v155;
    v3 = v270;
    a1 = v284;
    if (v156)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v288 = 93;
      v157 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v157)
        v158 = v157;
      else
        v158 = v288;
      v159 = &v287[v158];
      v160 = v288 - v158;
      if (v288 - v158 >= 0x12)
        v161 = 18;
      else
        v161 = v288 - v158;
      v162 = v160 - v161;
      if (v162 >= v162 - 1)
        v163 = v162 - 1;
      else
        v163 = v162;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v159[v161], v163);
      v35 = (_QWORD *)&unk_25451A000;
      v33 = v185;
      v30 = v189;
      v27 = v194;
      v24 = v200;
      v21 = v207;
      v18 = v215;
      v15 = v224;
      v12 = v234;
      v9 = v245;
      v6 = v257;
      v3 = v270;
      a1 = v284;
    }
  }
  v36 = v35[21];
  v38 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v37 & 1) == 0)
  {
    v271 = v3;
    v285 = a1;
    v246 = v9;
    v258 = v6;
    v225 = v15;
    v235 = v12;
    v208 = v21;
    v216 = v18;
    v195 = v27;
    v201 = v24;
    v186 = v33;
    v190 = v30;
    v183 = v36;
    v38 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v36 = v183;
    v33 = v186;
    v30 = v190;
    v27 = v195;
    v24 = v201;
    v21 = v208;
    v18 = v216;
    v15 = v225;
    v12 = v235;
    v9 = v246;
    v6 = v258;
    v165 = v164;
    v3 = v271;
    a1 = v285;
    if (v165)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ReifyRankedShapedTypeOpInterface::Trait<Empty>]";
      v288 = 102;
      v166 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v166)
        v167 = v166;
      else
        v167 = v288;
      v168 = &v287[v167];
      v169 = v288 - v167;
      if (v288 - v167 >= 0x12)
        v170 = 18;
      else
        v170 = v288 - v167;
      v171 = v169 - v170;
      if (v171 >= v171 - 1)
        v172 = v171 - 1;
      else
        v172 = v171;
      mlir::detail::TypeIDResolver<mlir::ReifyRankedShapedTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ReifyRankedShapedTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v168[v170], v172);
      v38 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v36 = v183;
      v33 = v186;
      v30 = v190;
      v27 = v195;
      v24 = v201;
      v21 = v208;
      v18 = v216;
      v15 = v225;
      v12 = v235;
      v9 = v246;
      v6 = v258;
      v3 = v271;
      a1 = v285;
    }
  }
  v39 = v38[168];
  v41 = &unk_25451A000;
  if ((v40 & 1) == 0)
  {
    v272 = v3;
    v286 = a1;
    v247 = v9;
    v259 = v6;
    v226 = v15;
    v236 = v12;
    v209 = v21;
    v217 = v18;
    v196 = v27;
    v202 = v24;
    v187 = v33;
    v191 = v30;
    v182 = v39;
    v184 = v36;
    v41 = (_QWORD *)&unk_25451A000;
    v39 = v182;
    v36 = v184;
    v33 = v187;
    v30 = v191;
    v27 = v196;
    v24 = v202;
    v21 = v209;
    v18 = v217;
    v15 = v226;
    v12 = v236;
    v9 = v247;
    v6 = v259;
    v174 = v173;
    v3 = v272;
    a1 = v286;
    if (v174)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v288 = 90;
      v175 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v175)
        v176 = v175;
      else
        v176 = v288;
      v177 = &v287[v176];
      v178 = v288 - v176;
      if (v288 - v176 >= 0x12)
        v179 = 18;
      else
        v179 = v288 - v176;
      v180 = v178 - v179;
      if (v180 >= v180 - 1)
        v181 = v180 - 1;
      else
        v181 = v180;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v177[v179], v181);
      v41 = (_QWORD *)&unk_25451A000;
      v39 = v182;
      v36 = v184;
      v33 = v187;
      v30 = v191;
      v27 = v196;
      v24 = v202;
      v21 = v209;
      v18 = v217;
      v15 = v226;
      v12 = v236;
      v9 = v247;
      v6 = v259;
      v3 = v272;
      a1 = v286;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v36 == a1
      || v39 == a1
      || v41[27] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;

  mlir::OpState::printOpName(a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::tensor::PackOp::print((mlir::tensor::PackOp *)&v7, a3);
}

BOOL mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::OpTrait::impl *v4;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::tensor::PackOp>,mlir::OpTrait::OneResult<mlir::tensor::PackOp>,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::tensor::PackOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::PackOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::tensor::PackOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::tensor::PackOp>,mlir::OpTrait::OpInvariants<mlir::tensor::PackOp>,mlir::BytecodeOpInterface::Trait<mlir::tensor::PackOp>,mlir::OpAsmOpInterface::Trait<mlir::tensor::PackOp>,mlir::DestinationStyleOpInterface::Trait<mlir::tensor::PackOp>,mlir::ConditionallySpeculatable::Trait<mlir::tensor::PackOp>,mlir::MemoryEffectOpInterface::Trait<mlir::tensor::PackOp>,mlir::ReifyRankedShapedTypeOpInterface::Trait<mlir::tensor::PackOp>,mlir::InferTypeOpInterface::Trait<mlir::tensor::PackOp>>(a1, a2))return 0;
  v4 = a1;
  return mlir::tensor::PackOp::verify((uint64_t **)&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::tensor::PackOp>,mlir::OpTrait::OneResult<mlir::tensor::PackOp>,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::tensor::PackOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::PackOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::tensor::PackOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::tensor::PackOp>,mlir::OpTrait::OpInvariants<mlir::tensor::PackOp>,mlir::BytecodeOpInterface::Trait<mlir::tensor::PackOp>,mlir::OpAsmOpInterface::Trait<mlir::tensor::PackOp>,mlir::DestinationStyleOpInterface::Trait<mlir::tensor::PackOp>,mlir::ConditionallySpeculatable::Trait<mlir::tensor::PackOp>,mlir::MemoryEffectOpInterface::Trait<mlir::tensor::PackOp>,mlir::ReifyRankedShapedTypeOpInterface::Trait<mlir::tensor::PackOp>,mlir::InferTypeOpInterface::Trait<mlir::tensor::PackOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)2)
    || !mlir::OpTrait::impl::verifyOperandSizeAttr((uint64_t)a1, "operandSegmentSizes", 0x13uLL))
  {
    return 0;
  }
  v6 = a1;
  return mlir::tensor::PackOp::verifyInvariantsImpl((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::tensor::PackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;

  return mlir::detail::verifyDestinationStyleOpInterface(a1, a2)
      && mlir::detail::verifyInferredResultTypes(a1, v3) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::PadOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.pad", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::PadOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04D0B0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::tensor::PadOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t *a2)@<X8>)
{
  *a1 = mlir::tensor::PadOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t *))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                     + 2);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                    + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                       + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::getInherentAttr(uint64_t a1, uint64_t a2, _WORD *a3, size_t a4)
{
  mlir::MLIRContext *Context;
  _QWORD *v8;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::tensor::PadOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  _WORD *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (_WORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::tensor::PadOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::MLIRContext *Context;
  uint64_t *v6;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::tensor::PadOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::tensor::PadOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::getOpPropertyByteSize()
{
  return 40;
}

double mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[1];
    *(_QWORD *)(a3 + 32) = *((_QWORD *)a4 + 4);
    *(_OWORD *)a3 = v4;
    *(_OWORD *)(a3 + 16) = v5;
  }
  else
  {
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)&v4 = 0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::tensor::PadOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::tensor::PadOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::compareProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_QWORD *)a3 != *(_QWORD *)a2)
    return 0;
  if (*(_QWORD *)(a3 + 8) != *(_QWORD *)(a2 + 8))
    return 0;
  if (*(_QWORD *)(a3 + 16) != *(_QWORD *)(a2 + 16))
    return 0;
  return *(_QWORD *)(a3 + 24) == *(_QWORD *)(a2 + 24)
      && *(_DWORD *)(a3 + 32) == (unint64_t)*(unsigned int *)(a2 + 32);
}

unint64_t mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::pdl_interp::CreateOperationOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::tensor::PadOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::PadOp::getAsmResultNames((uint64_t)&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::PadOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::PadOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::PadOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::PadOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[80];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::tensor::detail::PadOpGenericAdaptorBase::PadOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::tensor::PadOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  uint64_t v36;
  unsigned __int8 v37;
  _QWORD *v38;
  uint64_t v39;
  unsigned __int8 v40;
  _QWORD *v41;
  int v56;
  int v57;
  unint64_t v58;
  unint64_t v59;
  const char *v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  int v65;
  int v66;
  unint64_t v67;
  unint64_t v68;
  const char *v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  int v74;
  int v75;
  unint64_t v76;
  unint64_t v77;
  const char *v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  int v83;
  int v84;
  unint64_t v85;
  unint64_t v86;
  const char *v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  int v92;
  int v93;
  unint64_t v94;
  unint64_t v95;
  const char *v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  int v101;
  int v102;
  unint64_t v103;
  unint64_t v104;
  const char *v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  int v110;
  int v111;
  unint64_t v112;
  unint64_t v113;
  const char *v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  int v119;
  int v120;
  unint64_t v121;
  unint64_t v122;
  const char *v123;
  unint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  int v128;
  int v129;
  unint64_t v130;
  unint64_t v131;
  const char *v132;
  unint64_t v133;
  uint64_t v134;
  unint64_t v135;
  uint64_t v136;
  int v137;
  int v138;
  unint64_t v139;
  unint64_t v140;
  const char *v141;
  unint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  int v146;
  int v147;
  unint64_t v148;
  unint64_t v149;
  const char *v150;
  unint64_t v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t v154;
  int v155;
  int v156;
  unint64_t v157;
  unint64_t v158;
  const char *v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  int v164;
  int v165;
  unint64_t v166;
  unint64_t v167;
  const char *v168;
  unint64_t v169;
  uint64_t v170;
  unint64_t v171;
  uint64_t v172;
  int v173;
  int v174;
  unint64_t v175;
  unint64_t v176;
  const char *v177;
  unint64_t v178;
  uint64_t v179;
  unint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  const char *v287;
  unint64_t v288;

  v2 = &unk_254519000;
  if ((v1 & 1) == 0)
  {
    v273 = a1;
    v2 = (_QWORD *)&unk_254519000;
    v57 = v56;
    a1 = v273;
    if (v57)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneRegion<Empty>]";
      v288 = 81;
      v58 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v58)
        v59 = v58;
      else
        v59 = v288;
      v60 = &v287[v59];
      v61 = v288 - v59;
      if (v288 - v59 >= 0x12)
        v62 = 18;
      else
        v62 = v288 - v59;
      v63 = v61 - v62;
      if (v63 >= v63 - 1)
        v64 = v63 - 1;
      else
        v64 = v63;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v60[v62], v64);
      v2 = (_QWORD *)&unk_254519000;
      a1 = v273;
    }
  }
  v3 = v2[415];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v260 = v3;
    v274 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v66 = v65;
    v3 = v260;
    a1 = v274;
    if (v66)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v288 = 81;
      v67 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v67)
        v68 = v67;
      else
        v68 = v288;
      v69 = &v287[v68];
      v70 = v288 - v68;
      if (v288 - v68 >= 0x12)
        v71 = 18;
      else
        v71 = v288 - v68;
      v72 = v70 - v71;
      if (v72 >= v72 - 1)
        v73 = v72 - 1;
      else
        v73 = v72;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v69[v71], v73);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v260;
      a1 = v274;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v261 = v3;
    v275 = a1;
    v248 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v248;
    v3 = v261;
    v75 = v74;
    a1 = v275;
    if (v75)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<Empty>]";
      v288 = 116;
      v76 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v76)
        v77 = v76;
      else
        v77 = v288;
      v78 = &v287[v77];
      v79 = v288 - v77;
      if (v288 - v77 >= 0x12)
        v80 = 18;
      else
        v80 = v288 - v77;
      v81 = v79 - v80;
      if (v81 >= v81 - 1)
        v82 = v81 - 1;
      else
        v82 = v81;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v78[v80], v82);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v248;
      v3 = v261;
      a1 = v275;
    }
  }
  v9 = v8[425];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v262 = v3;
    v276 = a1;
    v237 = v9;
    v249 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v237;
    v6 = v249;
    v84 = v83;
    v3 = v262;
    a1 = v276;
    if (v84)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v288 = 86;
      v85 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v85)
        v86 = v85;
      else
        v86 = v288;
      v87 = &v287[v86];
      v88 = v288 - v86;
      if (v288 - v86 >= 0x12)
        v89 = 18;
      else
        v89 = v288 - v86;
      v90 = v88 - v89;
      if (v90 >= v90 - 1)
        v91 = v90 - 1;
      else
        v91 = v90;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v87[v89], v91);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v237;
      v6 = v249;
      v3 = v262;
      a1 = v276;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v263 = v3;
    v277 = a1;
    v238 = v9;
    v250 = v6;
    v227 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v227;
    v9 = v238;
    v6 = v250;
    v93 = v92;
    v3 = v263;
    a1 = v277;
    if (v93)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>]";
      v288 = 97;
      v94 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v94)
        v95 = v94;
      else
        v95 = v288;
      v96 = &v287[v95];
      v97 = v288 - v95;
      if (v288 - v95 >= 0x12)
        v98 = 18;
      else
        v98 = v288 - v95;
      v99 = v97 - v98;
      if (v99 >= v99 - 1)
        v100 = v99 - 1;
      else
        v100 = v99;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v96[v98], v100);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v227;
      v9 = v238;
      v6 = v250;
      v3 = v263;
      a1 = v277;
    }
  }
  v15 = v14[423];
  v17 = &unk_25451B000;
  if ((v16 & 1) == 0)
  {
    v264 = v3;
    v278 = a1;
    v239 = v9;
    v251 = v6;
    v218 = v15;
    v228 = v12;
    v17 = (_QWORD *)&unk_25451B000;
    v15 = v218;
    v12 = v228;
    v9 = v239;
    v6 = v251;
    v102 = v101;
    v3 = v264;
    a1 = v278;
    if (v102)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      v288 = 96;
      v103 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v103)
        v104 = v103;
      else
        v104 = v288;
      v105 = &v287[v104];
      v106 = v288 - v104;
      if (v288 - v104 >= 0x12)
        v107 = 18;
      else
        v107 = v288 - v104;
      v108 = v106 - v107;
      if (v108 >= v108 - 1)
        v109 = v108 - 1;
      else
        v109 = v108;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v105[v107], v109);
      v17 = (_QWORD *)&unk_25451B000;
      v15 = v218;
      v12 = v228;
      v9 = v239;
      v6 = v251;
      v3 = v264;
      a1 = v278;
    }
  }
  v18 = v17[37];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v265 = v3;
    v279 = a1;
    v240 = v9;
    v252 = v6;
    v219 = v15;
    v229 = v12;
    v210 = v18;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v210;
    v15 = v219;
    v12 = v229;
    v9 = v240;
    v6 = v252;
    v111 = v110;
    v3 = v265;
    a1 = v279;
    if (v111)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SingleBlock<Empty>]";
      v288 = 83;
      v112 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v112)
        v113 = v112;
      else
        v113 = v288;
      v114 = &v287[v113];
      v115 = v288 - v113;
      if (v288 - v113 >= 0x12)
        v116 = 18;
      else
        v116 = v288 - v113;
      v117 = v115 - v116;
      if (v117 >= v117 - 1)
        v118 = v117 - 1;
      else
        v118 = v117;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlock<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlock>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v114[v116], v118);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v210;
      v15 = v219;
      v12 = v229;
      v9 = v240;
      v6 = v252;
      v3 = v265;
      a1 = v279;
    }
  }
  v21 = v20[433];
  v23 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v266 = v3;
    v280 = a1;
    v241 = v9;
    v253 = v6;
    v220 = v15;
    v230 = v12;
    v203 = v21;
    v211 = v18;
    v23 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v21 = v203;
    v18 = v211;
    v15 = v220;
    v12 = v230;
    v9 = v241;
    v6 = v253;
    v120 = v119;
    v3 = v266;
    a1 = v280;
    if (v120)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor:"
             ":YieldOp>::Impl<Empty>]";
      v288 = 130;
      v121 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v121)
        v122 = v121;
      else
        v122 = v288;
      v123 = &v287[v122];
      v124 = v288 - v122;
      if (v288 - v122 >= 0x12)
        v125 = 18;
      else
        v125 = v288 - v122;
      v126 = v124 - v125;
      if (v126 >= v126 - 1)
        v127 = v126 - 1;
      else
        v127 = v126;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v123[v125], v127);
      v23 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v21 = v203;
      v18 = v211;
      v15 = v220;
      v12 = v230;
      v9 = v241;
      v6 = v253;
      v3 = v266;
      a1 = v280;
    }
  }
  v24 = v23[184];
  v26 = &unk_254519000;
  if ((v25 & 1) == 0)
  {
    v267 = v3;
    v281 = a1;
    v242 = v9;
    v254 = v6;
    v221 = v15;
    v231 = v12;
    v204 = v21;
    v212 = v18;
    v197 = v24;
    v26 = (_QWORD *)&unk_254519000;
    v24 = v197;
    v21 = v204;
    v18 = v212;
    v15 = v221;
    v12 = v231;
    v9 = v242;
    v6 = v254;
    v129 = v128;
    v3 = v267;
    a1 = v281;
    if (v129)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v288 = 84;
      v130 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v130)
        v131 = v130;
      else
        v131 = v288;
      v132 = &v287[v131];
      v133 = v288 - v131;
      if (v288 - v131 >= 0x12)
        v134 = 18;
      else
        v134 = v288 - v131;
      v135 = v133 - v134;
      if (v135 >= v135 - 1)
        v136 = v135 - 1;
      else
        v136 = v135;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v132[v134], v136);
      v26 = (_QWORD *)&unk_254519000;
      v24 = v197;
      v21 = v204;
      v18 = v212;
      v15 = v221;
      v12 = v231;
      v9 = v242;
      v6 = v254;
      v3 = v267;
      a1 = v281;
    }
  }
  v27 = v26[423];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v268 = v3;
    v282 = a1;
    v243 = v9;
    v255 = v6;
    v222 = v15;
    v232 = v12;
    v205 = v21;
    v213 = v18;
    v192 = v27;
    v198 = v24;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v192;
    v24 = v198;
    v21 = v205;
    v18 = v213;
    v15 = v222;
    v12 = v232;
    v9 = v243;
    v6 = v255;
    v138 = v137;
    v3 = v268;
    a1 = v282;
    if (v138)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v288 = 89;
      v139 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v139)
        v140 = v139;
      else
        v140 = v288;
      v141 = &v287[v140];
      v142 = v288 - v140;
      if (v288 - v140 >= 0x12)
        v143 = 18;
      else
        v143 = v288 - v140;
      v144 = v142 - v143;
      if (v144 >= v144 - 1)
        v145 = v144 - 1;
      else
        v145 = v144;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v141[v143], v145);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v192;
      v24 = v198;
      v21 = v205;
      v18 = v213;
      v15 = v222;
      v12 = v232;
      v9 = v243;
      v6 = v255;
      v3 = v268;
      a1 = v282;
    }
  }
  v30 = v29[310];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v269 = v3;
    v283 = a1;
    v244 = v9;
    v256 = v6;
    v223 = v15;
    v233 = v12;
    v206 = v21;
    v214 = v18;
    v193 = v27;
    v199 = v24;
    v188 = v30;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v188;
    v27 = v193;
    v24 = v199;
    v21 = v206;
    v18 = v214;
    v15 = v223;
    v12 = v233;
    v9 = v244;
    v6 = v256;
    v147 = v146;
    v3 = v269;
    a1 = v283;
    if (v147)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v288 = 86;
      v148 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v148)
        v149 = v148;
      else
        v149 = v288;
      v150 = &v287[v149];
      v151 = v288 - v149;
      if (v288 - v149 >= 0x12)
        v152 = 18;
      else
        v152 = v288 - v149;
      v153 = v151 - v152;
      if (v153 >= v153 - 1)
        v154 = v153 - 1;
      else
        v154 = v153;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v150[v152], v154);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v188;
      v27 = v193;
      v24 = v199;
      v21 = v206;
      v18 = v214;
      v15 = v223;
      v12 = v233;
      v9 = v244;
      v6 = v256;
      v3 = v269;
      a1 = v283;
    }
  }
  v33 = v32[340];
  v35 = &unk_25451A000;
  if ((v34 & 1) == 0)
  {
    v270 = v3;
    v284 = a1;
    v245 = v9;
    v257 = v6;
    v224 = v15;
    v234 = v12;
    v207 = v21;
    v215 = v18;
    v194 = v27;
    v200 = v24;
    v185 = v33;
    v189 = v30;
    v35 = (_QWORD *)&unk_25451A000;
    v33 = v185;
    v30 = v189;
    v27 = v194;
    v24 = v200;
    v21 = v207;
    v18 = v215;
    v15 = v224;
    v12 = v234;
    v9 = v245;
    v6 = v257;
    v156 = v155;
    v3 = v270;
    a1 = v284;
    if (v156)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v288 = 95;
      v157 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v157)
        v158 = v157;
      else
        v158 = v288;
      v159 = &v287[v158];
      v160 = v288 - v158;
      if (v288 - v158 >= 0x12)
        v161 = 18;
      else
        v161 = v288 - v158;
      v162 = v160 - v161;
      if (v162 >= v162 - 1)
        v163 = v162 - 1;
      else
        v163 = v162;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v159[v161], v163);
      v35 = (_QWORD *)&unk_25451A000;
      v33 = v185;
      v30 = v189;
      v27 = v194;
      v24 = v200;
      v21 = v207;
      v18 = v215;
      v15 = v224;
      v12 = v234;
      v9 = v245;
      v6 = v257;
      v3 = v270;
      a1 = v284;
    }
  }
  v36 = v35[312];
  v38 = &unk_25451A000;
  if ((v37 & 1) == 0)
  {
    v271 = v3;
    v285 = a1;
    v246 = v9;
    v258 = v6;
    v225 = v15;
    v235 = v12;
    v208 = v21;
    v216 = v18;
    v195 = v27;
    v201 = v24;
    v186 = v33;
    v190 = v30;
    v183 = v36;
    v38 = (_QWORD *)&unk_25451A000;
    v36 = v183;
    v33 = v186;
    v30 = v190;
    v27 = v195;
    v24 = v201;
    v21 = v208;
    v18 = v216;
    v15 = v225;
    v12 = v235;
    v9 = v246;
    v6 = v258;
    v165 = v164;
    v3 = v271;
    a1 = v285;
    if (v165)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v288 = 99;
      v166 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v166)
        v167 = v166;
      else
        v167 = v288;
      v168 = &v287[v167];
      v169 = v288 - v167;
      if (v288 - v167 >= 0x12)
        v170 = 18;
      else
        v170 = v288 - v167;
      v171 = v169 - v170;
      if (v171 >= v171 - 1)
        v172 = v171 - 1;
      else
        v172 = v171;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v168[v170], v172);
      v38 = (_QWORD *)&unk_25451A000;
      v36 = v183;
      v33 = v186;
      v30 = v190;
      v27 = v195;
      v24 = v201;
      v21 = v208;
      v18 = v216;
      v15 = v225;
      v12 = v235;
      v9 = v246;
      v6 = v258;
      v3 = v271;
      a1 = v285;
    }
  }
  v39 = v38[314];
  v41 = &unk_25451A000;
  if ((v40 & 1) == 0)
  {
    v272 = v3;
    v286 = a1;
    v247 = v9;
    v259 = v6;
    v226 = v15;
    v236 = v12;
    v209 = v21;
    v217 = v18;
    v196 = v27;
    v202 = v24;
    v187 = v33;
    v191 = v30;
    v182 = v39;
    v184 = v36;
    v41 = (_QWORD *)&unk_25451A000;
    v39 = v182;
    v36 = v184;
    v33 = v187;
    v30 = v191;
    v27 = v196;
    v24 = v202;
    v21 = v209;
    v18 = v217;
    v15 = v226;
    v12 = v236;
    v9 = v247;
    v6 = v259;
    v174 = v173;
    v3 = v272;
    a1 = v286;
    if (v174)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v288 = 93;
      v175 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v175)
        v176 = v175;
      else
        v176 = v288;
      v177 = &v287[v176];
      v178 = v288 - v176;
      if (v288 - v176 >= 0x12)
        v179 = 18;
      else
        v179 = v288 - v176;
      v180 = v178 - v179;
      if (v180 >= v180 - 1)
        v181 = v180 - 1;
      else
        v181 = v180;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v177[v179], v181);
      v41 = (_QWORD *)&unk_25451A000;
      v39 = v182;
      v36 = v184;
      v33 = v187;
      v30 = v191;
      v27 = v196;
      v24 = v202;
      v21 = v209;
      v18 = v217;
      v15 = v226;
      v12 = v236;
      v9 = v247;
      v6 = v259;
      v3 = v272;
      a1 = v286;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v36 == a1
      || v39 == a1
      || v41[21] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;

  mlir::OpState::printOpName(a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::tensor::PadOp::print((mlir::tensor::PadOp *)&v7, a3);
}

BOOL mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::OpTrait::impl *v4;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::OneRegion<mlir::tensor::PadOp>,mlir::OpTrait::OneResult<mlir::tensor::PadOp>,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::tensor::PadOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::PadOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::tensor::PadOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::tensor::PadOp>,mlir::OpTrait::SingleBlock<mlir::tensor::PadOp>,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl<mlir::tensor::PadOp>,mlir::OpTrait::OpInvariants<mlir::tensor::PadOp>,mlir::BytecodeOpInterface::Trait<mlir::tensor::PadOp>,mlir::OpAsmOpInterface::Trait<mlir::tensor::PadOp>,mlir::ConditionallySpeculatable::Trait<mlir::tensor::PadOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::tensor::PadOp>,mlir::MemoryEffectOpInterface::Trait<mlir::tensor::PadOp>>(a1, a2))return 0;
  v4 = a1;
  return mlir::tensor::PadOp::verify((uint64_t **)&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::OneRegion<mlir::tensor::PadOp>,mlir::OpTrait::OneResult<mlir::tensor::PadOp>,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::tensor::PadOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::PadOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::tensor::PadOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::tensor::PadOp>,mlir::OpTrait::SingleBlock<mlir::tensor::PadOp>,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl<mlir::tensor::PadOp>,mlir::OpTrait::OpInvariants<mlir::tensor::PadOp>,mlir::BytecodeOpInterface::Trait<mlir::tensor::PadOp>,mlir::OpAsmOpInterface::Trait<mlir::tensor::PadOp>,mlir::ConditionallySpeculatable::Trait<mlir::tensor::PadOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::tensor::PadOp>,mlir::MemoryEffectOpInterface::Trait<mlir::tensor::PadOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyOneRegion(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)1)
    || !mlir::OpTrait::impl::verifyOperandSizeAttr((uint64_t)a1, "operandSegmentSizes", 0x13uLL)
    || !mlir::OpTrait::SingleBlock<mlir::memref::GenericAtomicRMWOp>::verifyTrait((uint64_t)a1))
  {
    return 0;
  }
  v6 = a1;
  return mlir::tensor::PadOp::verifyInvariantsImpl((uint64_t **)&v6);
}

BOOL mlir::Op<mlir::tensor::PadOp,mlir::OpTrait::OneRegion,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants(uint64_t *a1)
{
  uint64_t *v3;

  if (!mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl<mlir::tensor::GenerateOp>::verifyRegionTrait((uint64_t)a1))
    return 0;
  v3 = a1;
  return mlir::tensor::PadOp::verifyRegions(&v3) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::foldHook()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::tensor::ParallelInsertSliceOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::tensor::ParallelInsertSliceOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                    + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                       + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  mlir::MLIRContext *Context;
  uint64_t *v8;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::tensor::ParallelInsertSliceOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::tensor::ParallelInsertSliceOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::MLIRContext *Context;
  uint64_t *v6;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::tensor::InsertSliceOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::memref::ReinterpretCastOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::getOpPropertyByteSize()
{
  return 48;
}

double mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::initProperties(uint64_t a1, uint64_t a2, _OWORD *a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[2];
    a3[1] = a4[1];
    a3[2] = v5;
    *a3 = v4;
  }
  else
  {
    *(_QWORD *)&v4 = 0;
    a3[1] = 0u;
    a3[2] = 0u;
    *a3 = 0u;
  }
  return *(double *)&v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::tensor::InsertSliceOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::tensor::InsertSliceOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a2 + 28) = *(_OWORD *)(a3 + 28);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::compareProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_QWORD *)a3 != *(_QWORD *)a2)
    return 0;
  if (*(_QWORD *)(a3 + 8) != *(_QWORD *)(a2 + 8))
    return 0;
  if (*(_QWORD *)(a3 + 16) != *(_QWORD *)(a2 + 16))
    return 0;
  return *(_QWORD *)(a3 + 24) == *(_QWORD *)(a2 + 24)
      && *(_QWORD *)(a3 + 32) == *(_QWORD *)(a2 + 32)
      && *(_DWORD *)(a3 + 40) == (unint64_t)*(unsigned int *)(a2 + 40);
}

unint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ParallelInsertSliceOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::tensor::InsertSliceOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::tensor::InsertSliceOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0xD0uLL, 0x80040B342C78EuLL);
  *v2 = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getOffsetSizeAndStrideStartOperandIndex;
  v2[1] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getArrayAttrMaxRanks;
  v2[2] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getOffsets;
  v2[3] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getSizes;
  v2[4] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getStrides;
  v2[5] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getStaticOffsets;
  v2[6] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getStaticSizes;
  v2[7] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getStaticStrides;
  v2[8] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getMixedOffsets;
  v2[9] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getMixedSizes;
  v2[10] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getMixedStrides;
  v2[11] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::isDynamicOffset;
  v2[12] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::isDynamicSize;
  v2[13] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::isDynamicStride;
  v2[14] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getStaticOffset;
  v2[15] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getStaticSize;
  v2[16] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getStaticStride;
  v2[17] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getIndexOfDynamicOffset;
  v2[18] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getIndexOfDynamicSize;
  v2[19] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getIndexOfDynamicStride;
  v2[20] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getDynamicOffset;
  v2[21] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getDynamicSize;
  v2[22] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getDynamicStride;
  v2[23] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::isSameAs;
  v2[24] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::hasUnitStride;
  v2[25] = mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::hasZeroOffset;
  v4 = &unk_25451B000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451B000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OffsetSizeAndStrideOpInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OffsetSizeAndStrideOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451B000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[259], v2);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getOffsetSizeAndStrideStartOperandIndex()
{
  return 1;
}

unint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getArrayAttrMaxRanks(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v4;
  unint64_t v5;

  v4 = a2;
  v5 = *(_QWORD *)(mlir::tensor::ParallelInsertSliceOp::getDest((mlir::tensor::ParallelInsertSliceOp *)&v4) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v5);
  return v2 | ((unint64_t)v2 << 32);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getOffsets(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::memref::ReinterpretCastOp::getSizes((mlir::memref::ReinterpretCastOp *)&v3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getSizes(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::memref::ReinterpretCastOp::getStrides((mlir::memref::ReinterpretCastOp *)&v3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getStrides(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::tensor::InsertSliceOp::getStrides((mlir::tensor::InsertSliceOp *)&v3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getStaticOffsets(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::memref::ReinterpretCastOp::getStaticOffsets((mlir::memref::ReinterpretCastOp *)&v3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getStaticSizes(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::memref::ReinterpretCastOp::getStaticSizes((mlir::memref::ReinterpretCastOp *)&v3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getStaticStrides(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)&v3);
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getMixedOffsets(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  v2 = a1;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedOffsets((mlir::memref::ReinterpretCastOp *)&v2, a2);
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getMixedSizes(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  v2 = a1;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedSizes((mlir::memref::ReinterpretCastOp *)&v2, a2);
}

void mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getMixedStrides(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  v2 = a1;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedStrides((mlir::memref::ReinterpretCastOp *)&v2, a2);
}

BOOL mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::isDynamicOffset(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticOffsets((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3) == 0x8000000000000000;
}

BOOL mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::isDynamicSize(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticSizes((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3) == 0x8000000000000000;
}

BOOL mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::isDynamicStride(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3) == 0x8000000000000000;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getStaticOffset(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticOffsets((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getStaticSize(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticSizes((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getStaticStride(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;

  v4 = a2;
  return *(_QWORD *)(mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)&v4) + 8 * a3);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getIndexOfDynamicOffset(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticOffsets;
  uint64_t v5;
  uint64_t v7;

  v7 = a2;
  StaticOffsets = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticOffsets((mlir::memref::ReinterpretCastOp *)&v7);
  return mlir::detail::getNumDynamicEntriesUpToIdx(StaticOffsets, v5, a3) + 1;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getIndexOfDynamicSize(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticSizes;
  uint64_t v5;
  int NumDynamicEntriesUpToIdx;
  int v7;
  uint64_t v9;

  v9 = a2;
  StaticSizes = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticSizes((mlir::memref::ReinterpretCastOp *)&v9);
  NumDynamicEntriesUpToIdx = mlir::detail::getNumDynamicEntriesUpToIdx(StaticSizes, v5, a3);
  mlir::memref::ReinterpretCastOp::getSizes((mlir::memref::ReinterpretCastOp *)&v9);
  return (NumDynamicEntriesUpToIdx + v7 + 1);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getIndexOfDynamicStride(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticStrides;
  uint64_t v5;
  int NumDynamicEntriesUpToIdx;
  int v7;
  int v8;
  int v9;
  uint64_t v11;

  v11 = a2;
  StaticStrides = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)&v11);
  NumDynamicEntriesUpToIdx = mlir::detail::getNumDynamicEntriesUpToIdx(StaticStrides, v5, a3);
  mlir::memref::ReinterpretCastOp::getSizes((mlir::memref::ReinterpretCastOp *)&v11);
  v8 = v7;
  mlir::memref::ReinterpretCastOp::getStrides((mlir::memref::ReinterpretCastOp *)&v11);
  return (v8 + v9 + NumDynamicEntriesUpToIdx + 1);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getDynamicOffset(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticOffsets;
  uint64_t v5;
  int NumDynamicEntriesUpToIdx;
  uint64_t v8;

  v8 = a2;
  StaticOffsets = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticOffsets((mlir::memref::ReinterpretCastOp *)&v8);
  NumDynamicEntriesUpToIdx = mlir::detail::getNumDynamicEntriesUpToIdx(StaticOffsets, v5, a3);
  return *(_QWORD *)(*(_QWORD *)(v8 + 72) + 32 * (NumDynamicEntriesUpToIdx + 1) + 24);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getDynamicSize(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticSizes;
  uint64_t v5;
  int NumDynamicEntriesUpToIdx;
  int v7;
  uint64_t v9;

  v9 = a2;
  StaticSizes = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticSizes((mlir::memref::ReinterpretCastOp *)&v9);
  NumDynamicEntriesUpToIdx = mlir::detail::getNumDynamicEntriesUpToIdx(StaticSizes, v5, a3);
  mlir::memref::ReinterpretCastOp::getSizes((mlir::memref::ReinterpretCastOp *)&v9);
  return *(_QWORD *)(*(_QWORD *)(v9 + 72) + 32 * (NumDynamicEntriesUpToIdx + v7 + 1) + 24);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::getDynamicStride(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int64x2_t *StaticStrides;
  uint64_t v5;
  int NumDynamicEntriesUpToIdx;
  int v7;
  int v8;
  int v9;
  uint64_t v11;

  v11 = a2;
  StaticStrides = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)&v11);
  NumDynamicEntriesUpToIdx = mlir::detail::getNumDynamicEntriesUpToIdx(StaticStrides, v5, a3);
  mlir::memref::ReinterpretCastOp::getSizes((mlir::memref::ReinterpretCastOp *)&v11);
  v8 = v7;
  mlir::memref::ReinterpretCastOp::getStrides((mlir::memref::ReinterpretCastOp *)&v11);
  return *(_QWORD *)(*(_QWORD *)(v11 + 72) + 32 * (v8 + v9 + NumDynamicEntriesUpToIdx + 1) + 24);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::isSameAs(uint64_t a1, uint64_t InterfaceFor, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, _QWORD, _QWORD), uint64_t a6)
{
  uint64_t v10;

  v10 = InterfaceFor;
  if (InterfaceFor)
    InterfaceFor = mlir::OpInterface<mlir::OffsetSizeAndStrideOpInterface,mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits>::getInterfaceFor(InterfaceFor);
  return mlir::detail::sameOffsetsSizesAndStrides(v10, InterfaceFor, a3, a4, a5, a6);
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::hasUnitStride(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t ConstantIntValue;
  char v6;
  BOOL v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v11;
  void *v12;
  unsigned int v13;
  _QWORD v14[5];

  v14[4] = *MEMORY[0x24BDAC8D0];
  v11 = a2;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedStrides((mlir::memref::ReinterpretCastOp *)&v11, (uint64_t)&v12);
  v2 = (uint64_t *)v12;
  if (!v13)
  {
    v8 = 1;
    if (v12 == v14)
      return v8;
    goto LABEL_15;
  }
  v3 = 8 * v13 - 8;
  do
  {
    v4 = *v2++;
    ConstantIntValue = mlir::getConstantIntValue(v4);
    if (v6)
      v7 = ConstantIntValue == 1;
    else
      v7 = 0;
    v8 = v7;
    v9 = (_DWORD)v8 != 1 || v3 == 0;
    v3 -= 8;
  }
  while (!v9);
  v2 = (uint64_t *)v12;
  if (v12 != v14)
LABEL_15:
    free(v2);
  return v8;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>::hasZeroOffset(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t ConstantIntValue;
  char v6;
  BOOL v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v11;
  void *v12;
  unsigned int v13;
  _QWORD v14[5];

  v14[4] = *MEMORY[0x24BDAC8D0];
  v11 = a2;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedOffsets((mlir::memref::ReinterpretCastOp *)&v11, (uint64_t)&v12);
  v2 = (uint64_t *)v12;
  if (!v13)
  {
    v8 = 1;
    if (v12 == v14)
      return v8;
    goto LABEL_15;
  }
  v3 = 8 * v13 - 8;
  do
  {
    v4 = *v2++;
    ConstantIntValue = mlir::getConstantIntValue(v4);
    if (v6)
      v7 = ConstantIntValue == 0;
    else
      v7 = 0;
    v8 = v7;
    v9 = (_DWORD)v8 != 1 || v3 == 0;
    v3 -= 8;
  }
  while (!v9);
  v2 = (uint64_t *)v12;
  if (v12 != v14)
LABEL_15:
    free(v2);
  return v8;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  int v32;
  int v33;
  unint64_t v34;
  unint64_t v35;
  const char *v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  int v41;
  int v42;
  unint64_t v43;
  unint64_t v44;
  const char *v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  int v50;
  int v51;
  unint64_t v52;
  unint64_t v53;
  const char *v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  int v59;
  int v60;
  unint64_t v61;
  unint64_t v62;
  const char *v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  int v68;
  int v69;
  unint64_t v70;
  unint64_t v71;
  const char *v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  int v77;
  int v78;
  unint64_t v79;
  unint64_t v80;
  const char *v81;
  unint64_t v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  int v86;
  int v87;
  unint64_t v88;
  unint64_t v89;
  const char *v90;
  unint64_t v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v94;
  int v95;
  int v96;
  unint64_t v97;
  unint64_t v98;
  const char *v99;
  unint64_t v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  const char *v140;
  unint64_t v141;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v132 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v33 = v32;
    a1 = v132;
    if (v33)
    {
      v140 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v141 = 83;
      v34 = llvm::StringRef::find((uint64_t *)&v140, "DesiredTypeName = ", 0x12uLL, 0);
      if (v141 >= v34)
        v35 = v34;
      else
        v35 = v141;
      v36 = &v140[v35];
      v37 = v141 - v35;
      if (v141 - v35 >= 0x12)
        v38 = 18;
      else
        v38 = v141 - v35;
      v39 = v37 - v38;
      if (v39 >= v39 - 1)
        v40 = v39 - 1;
      else
        v40 = v39;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v36[v38], v40);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v132;
    }
  }
  v3 = v2[13];
  v5 = &unk_254519000;
  if ((v4 & 1) == 0)
  {
    v133 = a1;
    v125 = v3;
    v5 = (_QWORD *)&unk_254519000;
    v3 = v125;
    v42 = v41;
    a1 = v133;
    if (v42)
    {
      v140 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      v141 = 83;
      v43 = llvm::StringRef::find((uint64_t *)&v140, "DesiredTypeName = ", 0x12uLL, 0);
      if (v141 >= v43)
        v44 = v43;
      else
        v44 = v141;
      v45 = &v140[v44];
      v46 = v141 - v44;
      if (v141 - v44 >= 0x12)
        v47 = 18;
      else
        v47 = v141 - v44;
      v48 = v46 - v47;
      if (v48 >= v48 - 1)
        v49 = v48 - 1;
      else
        v49 = v48;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v45[v47], v49);
      v5 = (_QWORD *)&unk_254519000;
      v3 = v125;
      a1 = v133;
    }
  }
  v6 = v5[417];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v134 = a1;
    v119 = v6;
    v126 = v3;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v119;
    v3 = v126;
    v51 = v50;
    a1 = v134;
    if (v51)
    {
      v140 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v141 = 86;
      v52 = llvm::StringRef::find((uint64_t *)&v140, "DesiredTypeName = ", 0x12uLL, 0);
      if (v141 >= v52)
        v53 = v52;
      else
        v53 = v141;
      v54 = &v140[v53];
      v55 = v141 - v53;
      if (v141 - v53 >= 0x12)
        v56 = 18;
      else
        v56 = v141 - v53;
      v57 = v55 - v56;
      if (v57 >= v57 - 1)
        v58 = v57 - 1;
      else
        v58 = v57;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v54[v56], v58);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v119;
      v3 = v126;
      a1 = v134;
    }
  }
  v9 = v8[419];
  v11 = &unk_25451A000;
  if ((v10 & 1) == 0)
  {
    v135 = a1;
    v120 = v6;
    v127 = v3;
    v114 = v9;
    v11 = (_QWORD *)&unk_25451A000;
    v9 = v114;
    v6 = v120;
    v3 = v127;
    v60 = v59;
    a1 = v135;
    if (v60)
    {
      v140 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<2>::Impl<Empty>]";
      v141 = 97;
      v61 = llvm::StringRef::find((uint64_t *)&v140, "DesiredTypeName = ", 0x12uLL, 0);
      if (v141 >= v61)
        v62 = v61;
      else
        v62 = v141;
      v63 = &v140[v62];
      v64 = v141 - v62;
      if (v141 - v62 >= 0x12)
        v65 = 18;
      else
        v65 = v141 - v62;
      v66 = v64 - v65;
      if (v66 >= v66 - 1)
        v67 = v66 - 1;
      else
        v67 = v66;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v63[v65], v67);
      v11 = (_QWORD *)&unk_25451A000;
      v9 = v114;
      v6 = v120;
      v3 = v127;
      a1 = v135;
    }
  }
  v12 = v11[431];
  v14 = &unk_25451B000;
  if ((v13 & 1) == 0)
  {
    v136 = a1;
    v121 = v6;
    v128 = v3;
    v110 = v12;
    v115 = v9;
    v14 = (_QWORD *)&unk_25451B000;
    v12 = v110;
    v9 = v115;
    v6 = v121;
    v3 = v128;
    v69 = v68;
    a1 = v136;
    if (v69)
    {
      v140 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      v141 = 96;
      v70 = llvm::StringRef::find((uint64_t *)&v140, "DesiredTypeName = ", 0x12uLL, 0);
      if (v141 >= v70)
        v71 = v70;
      else
        v71 = v141;
      v72 = &v140[v71];
      v73 = v141 - v71;
      if (v141 - v71 >= 0x12)
        v74 = 18;
      else
        v74 = v141 - v71;
      v75 = v73 - v74;
      if (v75 >= v75 - 1)
        v76 = v75 - 1;
      else
        v76 = v75;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v72[v74], v76);
      v14 = (_QWORD *)&unk_25451B000;
      v12 = v110;
      v9 = v115;
      v6 = v121;
      v3 = v128;
      a1 = v136;
    }
  }
  v15 = v14[37];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v137 = a1;
    v122 = v6;
    v129 = v3;
    v111 = v12;
    v116 = v9;
    v107 = v15;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v107;
    v12 = v111;
    v9 = v116;
    v6 = v122;
    v3 = v129;
    v78 = v77;
    a1 = v137;
    if (v78)
    {
      v140 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v141 = 84;
      v79 = llvm::StringRef::find((uint64_t *)&v140, "DesiredTypeName = ", 0x12uLL, 0);
      if (v141 >= v79)
        v80 = v79;
      else
        v80 = v141;
      v81 = &v140[v80];
      v82 = v141 - v80;
      if (v141 - v80 >= 0x12)
        v83 = 18;
      else
        v83 = v141 - v80;
      v84 = v82 - v83;
      if (v84 >= v84 - 1)
        v85 = v84 - 1;
      else
        v85 = v84;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v81[v83], v85);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v107;
      v12 = v111;
      v9 = v116;
      v6 = v122;
      v3 = v129;
      a1 = v137;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v138 = a1;
    v123 = v6;
    v130 = v3;
    v112 = v12;
    v117 = v9;
    v105 = v18;
    v108 = v15;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v105;
    v15 = v108;
    v12 = v112;
    v9 = v117;
    v6 = v123;
    v3 = v130;
    v87 = v86;
    a1 = v138;
    if (v87)
    {
      v140 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v141 = 89;
      v88 = llvm::StringRef::find((uint64_t *)&v140, "DesiredTypeName = ", 0x12uLL, 0);
      if (v141 >= v88)
        v89 = v88;
      else
        v89 = v141;
      v90 = &v140[v89];
      v91 = v141 - v89;
      if (v141 - v89 >= 0x12)
        v92 = 18;
      else
        v92 = v141 - v89;
      v93 = v91 - v92;
      if (v93 >= v93 - 1)
        v94 = v93 - 1;
      else
        v94 = v93;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v90[v92], v94);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v105;
      v15 = v108;
      v12 = v112;
      v9 = v117;
      v6 = v123;
      v3 = v130;
      a1 = v138;
    }
  }
  v21 = v20[310];
  v23 = &unk_25451B000;
  if ((v22 & 1) == 0)
  {
    v139 = a1;
    v124 = v6;
    v131 = v3;
    v113 = v12;
    v118 = v9;
    v106 = v18;
    v109 = v15;
    v104 = v21;
    v23 = (_QWORD *)&unk_25451B000;
    v21 = v104;
    v18 = v106;
    v15 = v109;
    v12 = v113;
    v9 = v118;
    v6 = v124;
    v3 = v131;
    v96 = v95;
    a1 = v139;
    if (v96)
    {
      v140 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OffsetSizeAndStrideOpInterface::Trait<Empty>]";
      v141 = 100;
      v97 = llvm::StringRef::find((uint64_t *)&v140, "DesiredTypeName = ", 0x12uLL, 0);
      if (v141 >= v97)
        v98 = v97;
      else
        v98 = v141;
      v99 = &v140[v98];
      v100 = v141 - v98;
      if (v141 - v98 >= 0x12)
        v101 = 18;
      else
        v101 = v141 - v98;
      v102 = v100 - v101;
      if (v102 >= v102 - 1)
        v103 = v102 - 1;
      else
        v103 = v102;
      mlir::detail::TypeIDResolver<mlir::OffsetSizeAndStrideOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OffsetSizeAndStrideOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v99[v101], v103);
      v23 = (_QWORD *)&unk_25451B000;
      v21 = v104;
      v18 = v106;
      v15 = v109;
      v12 = v113;
      v9 = v118;
      v6 = v124;
      v3 = v131;
      a1 = v139;
    }
  }
  return v3 == a1 || v6 == a1 || v9 == a1 || v12 == a1 || v15 == a1 || v18 == a1 || v21 == a1 || v23[261] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;

  mlir::OpState::printOpName(a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::tensor::InsertSliceOp::print((mlir::tensor::InsertSliceOp *)&v7, a3);
}

BOOL mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::verifyInvariants(uint64_t *a1, mlir::Operation *a2)
{
  uint64_t *v4;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::tensor::ParallelInsertSliceOp>,mlir::OpTrait::ZeroResults<mlir::tensor::ParallelInsertSliceOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::ParallelInsertSliceOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::tensor::ParallelInsertSliceOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::tensor::ParallelInsertSliceOp>,mlir::OpTrait::OpInvariants<mlir::tensor::ParallelInsertSliceOp>,mlir::BytecodeOpInterface::Trait<mlir::tensor::ParallelInsertSliceOp>,mlir::OffsetSizeAndStrideOpInterface::Trait<mlir::tensor::ParallelInsertSliceOp>>(a1, a2))return 0;
  v4 = a1;
  return mlir::tensor::ParallelInsertSliceOp::verify(&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::tensor::ParallelInsertSliceOp>,mlir::OpTrait::ZeroResults<mlir::tensor::ParallelInsertSliceOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::ParallelInsertSliceOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::tensor::ParallelInsertSliceOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::tensor::ParallelInsertSliceOp>,mlir::OpTrait::OpInvariants<mlir::tensor::ParallelInsertSliceOp>,mlir::BytecodeOpInterface::Trait<mlir::tensor::ParallelInsertSliceOp>,mlir::OffsetSizeAndStrideOpInterface::Trait<mlir::tensor::ParallelInsertSliceOp>>(uint64_t *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyZeroResults((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)2)
    && mlir::OpTrait::impl::verifyOperandSizeAttr((uint64_t)a1, "operandSegmentSizes", 0x13uLL)
    && (v6 = a1, mlir::tensor::ParallelInsertSliceOp::verifyInvariantsImpl(&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OffsetSizeAndStrideOpInterface::Trait<mlir::memref::ReinterpretCastOp>>(a1) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::Op<mlir::tensor::ParallelInsertSliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OffsetSizeAndStrideOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::RankOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.rank", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::RankOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04D308;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                      + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::tensor::RankOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::RankOp::getAsmResultNames(&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::RankOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::RankOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::RankOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>::inferReturnTypes(mlir::IndexType *a1, mlir::MLIRContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::memref::DimOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>::refineReturnTypes(mlir::IndexType *a1, mlir::MLIRContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::tensor::RankOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::RankOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::tensor::RankOp>::refineReturnTypes(mlir::IndexType *a1, mlir::MLIRContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::memref::DimOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "tensor.rank";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  mlir::Operation *v13;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::tensor::detail::RankOpGenericAdaptorBase::RankOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::memref::RankOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8
    || (mlir::Operation *)((char *)a2 - 16) == (mlir::Operation *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    return v9 > 7;
  }
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::memref::AtomicYieldOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyOneOperand(a1, v5))
  {
    return 0;
  }
  v7 = a1;
  return mlir::tensor::RankOp::verifyInvariantsImpl((uint64_t **)&v7);
}

BOOL mlir::Op<mlir::tensor::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ReshapeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ReshapeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ReshapeOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.reshape", 14, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::ReshapeOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04DA10;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::tensor::ReshapeOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ReshapeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ReshapeOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ReshapeOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ReshapeOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ReshapeOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ReshapeOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::memref::ReshapeOp::getAsmResultNames((uint64_t)&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ReshapeOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ReshapeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ReshapeOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ReshapeOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ReshapeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ReshapeOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ReshapeOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int *v13;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::tensor::detail::ReshapeOpGenericAdaptorBase::ReshapeOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::tensor::ReshapeOp::fold((uint64_t)&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8 || a2 - 4 == (unsigned int *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  int v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  const char *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  const char *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  const char *v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  const char *v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  const char *v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  const char *v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  const char *v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  const char *v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  const char *v185;
  unint64_t v186;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v175 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v41 = v40;
    a1 = v175;
    if (v41)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v186 = 83;
      v42 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v42)
        v43 = v42;
      else
        v43 = v186;
      v44 = &v185[v43];
      v45 = v186 - v43;
      if (v186 - v43 >= 0x12)
        v46 = 18;
      else
        v46 = v186 - v43;
      v47 = v45 - v46;
      if (v47 >= v47 - 1)
        v48 = v47 - 1;
      else
        v48 = v47;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v44[v46], v48);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v175;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v166 = v3;
    v176 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v50 = v49;
    v3 = v166;
    a1 = v176;
    if (v50)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v186 = 81;
      v51 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v51)
        v52 = v51;
      else
        v52 = v186;
      v53 = &v185[v52];
      v54 = v186 - v52;
      if (v186 - v52 >= 0x12)
        v55 = 18;
      else
        v55 = v186 - v52;
      v56 = v54 - v55;
      if (v56 >= v56 - 1)
        v57 = v56 - 1;
      else
        v57 = v56;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v53[v55], v57);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v166;
      a1 = v176;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v167 = v3;
    v177 = a1;
    v158 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v158;
    v59 = v58;
    v3 = v167;
    a1 = v177;
    if (v59)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<Empty>]";
      v186 = 110;
      v60 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v60)
        v61 = v60;
      else
        v61 = v186;
      v62 = &v185[v61];
      v63 = v186 - v61;
      if (v186 - v61 >= 0x12)
        v64 = 18;
      else
        v64 = v186 - v61;
      v65 = v63 - v64;
      if (v65 >= v65 - 1)
        v66 = v65 - 1;
      else
        v66 = v65;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v62[v64], v66);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v158;
      v3 = v167;
      a1 = v177;
    }
  }
  v9 = v8[421];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v168 = v3;
    v178 = a1;
    v151 = v9;
    v159 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v151;
    v6 = v159;
    v68 = v67;
    v3 = v168;
    a1 = v178;
    if (v68)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v186 = 86;
      v69 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v69)
        v70 = v69;
      else
        v70 = v186;
      v71 = &v185[v70];
      v72 = v186 - v70;
      if (v186 - v70 >= 0x12)
        v73 = 18;
      else
        v73 = v186 - v70;
      v74 = v72 - v73;
      if (v74 >= v74 - 1)
        v75 = v74 - 1;
      else
        v75 = v74;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v71[v73], v75);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v151;
      v6 = v159;
      v3 = v168;
      a1 = v178;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v169 = v3;
    v179 = a1;
    v152 = v9;
    v160 = v6;
    v145 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v145;
    v9 = v152;
    v6 = v160;
    v77 = v76;
    v3 = v169;
    a1 = v179;
    if (v77)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v186 = 90;
      v78 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v78)
        v79 = v78;
      else
        v79 = v186;
      v80 = &v185[v79];
      v81 = v186 - v79;
      if (v186 - v79 >= 0x12)
        v82 = 18;
      else
        v82 = v186 - v79;
      v83 = v81 - v82;
      if (v83 >= v83 - 1)
        v84 = v83 - 1;
      else
        v84 = v83;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v80[v82], v84);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v145;
      v9 = v152;
      v6 = v160;
      v3 = v169;
      a1 = v179;
    }
  }
  v15 = v14[79];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v170 = v3;
    v180 = a1;
    v153 = v9;
    v161 = v6;
    v140 = v15;
    v146 = v12;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v140;
    v12 = v146;
    v9 = v153;
    v6 = v161;
    v86 = v85;
    v3 = v170;
    a1 = v180;
    if (v86)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v186 = 84;
      v87 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v87)
        v88 = v87;
      else
        v88 = v186;
      v89 = &v185[v88];
      v90 = v186 - v88;
      if (v186 - v88 >= 0x12)
        v91 = 18;
      else
        v91 = v186 - v88;
      v92 = v90 - v91;
      if (v92 >= v92 - 1)
        v93 = v92 - 1;
      else
        v93 = v92;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v89[v91], v93);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v140;
      v12 = v146;
      v9 = v153;
      v6 = v161;
      v3 = v170;
      a1 = v180;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v171 = v3;
    v181 = a1;
    v154 = v9;
    v162 = v6;
    v141 = v15;
    v147 = v12;
    v136 = v18;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v136;
    v15 = v141;
    v12 = v147;
    v9 = v154;
    v6 = v162;
    v95 = v94;
    v3 = v171;
    a1 = v181;
    if (v95)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v186 = 86;
      v96 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v96)
        v97 = v96;
      else
        v97 = v186;
      v98 = &v185[v97];
      v99 = v186 - v97;
      if (v186 - v97 >= 0x12)
        v100 = 18;
      else
        v100 = v186 - v97;
      v101 = v99 - v100;
      if (v101 >= v101 - 1)
        v102 = v101 - 1;
      else
        v102 = v101;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v98[v100], v102);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v136;
      v15 = v141;
      v12 = v147;
      v9 = v154;
      v6 = v162;
      v3 = v171;
      a1 = v181;
    }
  }
  v21 = v20[340];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v172 = v3;
    v182 = a1;
    v155 = v9;
    v163 = v6;
    v142 = v15;
    v148 = v12;
    v133 = v21;
    v137 = v18;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v133;
    v18 = v137;
    v15 = v142;
    v12 = v148;
    v9 = v155;
    v6 = v163;
    v104 = v103;
    v3 = v172;
    a1 = v182;
    if (v104)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v186 = 95;
      v105 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v105)
        v106 = v105;
      else
        v106 = v186;
      v107 = &v185[v106];
      v108 = v186 - v106;
      if (v186 - v106 >= 0x12)
        v109 = 18;
      else
        v109 = v186 - v106;
      v110 = v108 - v109;
      if (v110 >= v110 - 1)
        v111 = v110 - 1;
      else
        v111 = v110;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v107[v109], v111);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v133;
      v18 = v137;
      v15 = v142;
      v12 = v148;
      v9 = v155;
      v6 = v163;
      v3 = v172;
      a1 = v182;
    }
  }
  v24 = v23[312];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v173 = v3;
    v183 = a1;
    v156 = v9;
    v164 = v6;
    v143 = v15;
    v149 = v12;
    v134 = v21;
    v138 = v18;
    v131 = v24;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v131;
    v21 = v134;
    v18 = v138;
    v15 = v143;
    v12 = v149;
    v9 = v156;
    v6 = v164;
    v113 = v112;
    v3 = v173;
    a1 = v183;
    if (v113)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v186 = 99;
      v114 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v114)
        v115 = v114;
      else
        v115 = v186;
      v116 = &v185[v115];
      v117 = v186 - v115;
      if (v186 - v115 >= 0x12)
        v118 = 18;
      else
        v118 = v186 - v115;
      v119 = v117 - v118;
      if (v119 >= v119 - 1)
        v120 = v119 - 1;
      else
        v120 = v119;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v116[v118], v120);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v131;
      v21 = v134;
      v18 = v138;
      v15 = v143;
      v12 = v149;
      v9 = v156;
      v6 = v164;
      v3 = v173;
      a1 = v183;
    }
  }
  v27 = v26[314];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v174 = v3;
    v184 = a1;
    v157 = v9;
    v165 = v6;
    v144 = v15;
    v150 = v12;
    v135 = v21;
    v139 = v18;
    v130 = v27;
    v132 = v24;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v130;
    v24 = v132;
    v21 = v135;
    v18 = v139;
    v15 = v144;
    v12 = v150;
    v9 = v157;
    v6 = v165;
    v122 = v121;
    v3 = v174;
    a1 = v184;
    if (v122)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v186 = 93;
      v123 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v123)
        v124 = v123;
      else
        v124 = v186;
      v125 = &v185[v124];
      v126 = v186 - v124;
      if (v186 - v124 >= 0x12)
        v127 = 18;
      else
        v127 = v186 - v124;
      v128 = v126 - v127;
      if (v128 >= v128 - 1)
        v129 = v128 - 1;
      else
        v129 = v128;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v125[v127], v129);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v130;
      v24 = v132;
      v21 = v135;
      v18 = v139;
      v15 = v144;
      v12 = v150;
      v9 = v157;
      v6 = v165;
      v3 = v174;
      a1 = v184;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v29[21] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::memref::ReshapeOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
    return 0;
  v6 = a1;
  if (!mlir::tensor::ReshapeOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::tensor::ReshapeOp::verify((uint64_t **)&v6) != 0;
}

uint64_t mlir::Op<mlir::tensor::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ScatterOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.scatter", 14, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::ScatterOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04DAD8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::tensor::ScatterOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::tensor::ScatterOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::tensor::ScatterOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::tensor::ScatterOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::tensor::ScatterOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::tensor::ScatterOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::tensor::ScatterOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::tensor::GatherOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::ScatterOp::getAsmResultNames((uint64_t)&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ScatterOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ScatterOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ScatterOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ScatterOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  const char *v209;
  unint64_t v210;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v198;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<Empty>]";
      v210 = 116;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = v8[425];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<3>::Impl<Empty>]";
      v210 = 90;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<3u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[149];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v210 = 89;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[310];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v210 = 86;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[340];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v210 = 95;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[312];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v210 = 99;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[314];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v32[21] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::tensor::ScatterOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)3))
    return 0;
  v6 = a1;
  if (!mlir::tensor::ScatterOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::tensor::ScatterOp::verify((uint64_t **)&v6) != 0;
}

uint64_t mlir::Op<mlir::tensor::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::SplatOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::SplatOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::SplatOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.splat", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::SplatOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04D498;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                      + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::tensor::SplatOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::SplatOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::SplatOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::SplatOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::SplatOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::SplatOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::SplatOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::SplatOp::getAsmResultNames(&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::SplatOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::SplatOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::SplatOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::SplatOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::SplatOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::SplatOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::SplatOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  mlir::Operation *v13;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::tensor::detail::SplatOpGenericAdaptorBase::SplatOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::tensor::SplatOp::fold(&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8
    || (mlir::Operation *)((char *)a2 - 16) == (mlir::Operation *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    return v9 > 7;
  }
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  int v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  const char *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  const char *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  const char *v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  const char *v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  const char *v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  const char *v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  const char *v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  const char *v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  const char *v185;
  unint64_t v186;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v175 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v41 = v40;
    a1 = v175;
    if (v41)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v186 = 83;
      v42 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v42)
        v43 = v42;
      else
        v43 = v186;
      v44 = &v185[v43];
      v45 = v186 - v43;
      if (v186 - v43 >= 0x12)
        v46 = 18;
      else
        v46 = v186 - v43;
      v47 = v45 - v46;
      if (v47 >= v47 - 1)
        v48 = v47 - 1;
      else
        v48 = v47;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v44[v46], v48);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v175;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v166 = v3;
    v176 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v50 = v49;
    v3 = v166;
    a1 = v176;
    if (v50)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v186 = 81;
      v51 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v51)
        v52 = v51;
      else
        v52 = v186;
      v53 = &v185[v52];
      v54 = v186 - v52;
      if (v186 - v52 >= 0x12)
        v55 = 18;
      else
        v55 = v186 - v52;
      v56 = v54 - v55;
      if (v56 >= v56 - 1)
        v57 = v56 - 1;
      else
        v57 = v56;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v53[v55], v57);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v166;
      a1 = v176;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v167 = v3;
    v177 = a1;
    v158 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v158;
    v59 = v58;
    v3 = v167;
    a1 = v177;
    if (v59)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<Empty>]";
      v186 = 116;
      v60 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v60)
        v61 = v60;
      else
        v61 = v186;
      v62 = &v185[v61];
      v63 = v186 - v61;
      if (v186 - v61 >= 0x12)
        v64 = 18;
      else
        v64 = v186 - v61;
      v65 = v63 - v64;
      if (v65 >= v65 - 1)
        v66 = v65 - 1;
      else
        v66 = v65;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v62[v64], v66);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v158;
      v3 = v167;
      a1 = v177;
    }
  }
  v9 = v8[425];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v168 = v3;
    v178 = a1;
    v151 = v9;
    v159 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v151;
    v6 = v159;
    v68 = v67;
    v3 = v168;
    a1 = v178;
    if (v68)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v186 = 86;
      v69 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v69)
        v70 = v69;
      else
        v70 = v186;
      v71 = &v185[v70];
      v72 = v186 - v70;
      if (v186 - v70 >= 0x12)
        v73 = 18;
      else
        v73 = v186 - v70;
      v74 = v72 - v73;
      if (v74 >= v74 - 1)
        v75 = v74 - 1;
      else
        v75 = v74;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v71[v73], v75);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v151;
      v6 = v159;
      v3 = v168;
      a1 = v178;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v169 = v3;
    v179 = a1;
    v152 = v9;
    v160 = v6;
    v145 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v145;
    v9 = v152;
    v6 = v160;
    v77 = v76;
    v3 = v169;
    a1 = v179;
    if (v77)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v186 = 82;
      v78 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v78)
        v79 = v78;
      else
        v79 = v186;
      v80 = &v185[v79];
      v81 = v186 - v79;
      if (v186 - v79 >= 0x12)
        v82 = 18;
      else
        v82 = v186 - v79;
      v83 = v81 - v82;
      if (v83 >= v83 - 1)
        v84 = v83 - 1;
      else
        v84 = v83;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v80[v82], v84);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v145;
      v9 = v152;
      v6 = v160;
      v3 = v169;
      a1 = v179;
    }
  }
  v15 = v14[19];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v170 = v3;
    v180 = a1;
    v153 = v9;
    v161 = v6;
    v140 = v15;
    v146 = v12;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v140;
    v12 = v146;
    v9 = v153;
    v6 = v161;
    v86 = v85;
    v3 = v170;
    a1 = v180;
    if (v86)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v186 = 84;
      v87 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v87)
        v88 = v87;
      else
        v88 = v186;
      v89 = &v185[v88];
      v90 = v186 - v88;
      if (v186 - v88 >= 0x12)
        v91 = 18;
      else
        v91 = v186 - v88;
      v92 = v90 - v91;
      if (v92 >= v92 - 1)
        v93 = v92 - 1;
      else
        v93 = v92;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v89[v91], v93);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v140;
      v12 = v146;
      v9 = v153;
      v6 = v161;
      v3 = v170;
      a1 = v180;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v171 = v3;
    v181 = a1;
    v154 = v9;
    v162 = v6;
    v141 = v15;
    v147 = v12;
    v136 = v18;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v136;
    v15 = v141;
    v12 = v147;
    v9 = v154;
    v6 = v162;
    v95 = v94;
    v3 = v171;
    a1 = v181;
    if (v95)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v186 = 86;
      v96 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v96)
        v97 = v96;
      else
        v97 = v186;
      v98 = &v185[v97];
      v99 = v186 - v97;
      if (v186 - v97 >= 0x12)
        v100 = 18;
      else
        v100 = v186 - v97;
      v101 = v99 - v100;
      if (v101 >= v101 - 1)
        v102 = v101 - 1;
      else
        v102 = v101;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v98[v100], v102);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v136;
      v15 = v141;
      v12 = v147;
      v9 = v154;
      v6 = v162;
      v3 = v171;
      a1 = v181;
    }
  }
  v21 = v20[340];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v172 = v3;
    v182 = a1;
    v155 = v9;
    v163 = v6;
    v142 = v15;
    v148 = v12;
    v133 = v21;
    v137 = v18;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v133;
    v18 = v137;
    v15 = v142;
    v12 = v148;
    v9 = v155;
    v6 = v163;
    v104 = v103;
    v3 = v172;
    a1 = v182;
    if (v104)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v186 = 95;
      v105 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v105)
        v106 = v105;
      else
        v106 = v186;
      v107 = &v185[v106];
      v108 = v186 - v106;
      if (v186 - v106 >= 0x12)
        v109 = 18;
      else
        v109 = v186 - v106;
      v110 = v108 - v109;
      if (v110 >= v110 - 1)
        v111 = v110 - 1;
      else
        v111 = v110;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v107[v109], v111);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v133;
      v18 = v137;
      v15 = v142;
      v12 = v148;
      v9 = v155;
      v6 = v163;
      v3 = v172;
      a1 = v182;
    }
  }
  v24 = v23[312];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v173 = v3;
    v183 = a1;
    v156 = v9;
    v164 = v6;
    v143 = v15;
    v149 = v12;
    v134 = v21;
    v138 = v18;
    v131 = v24;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v131;
    v21 = v134;
    v18 = v138;
    v15 = v143;
    v12 = v149;
    v9 = v156;
    v6 = v164;
    v113 = v112;
    v3 = v173;
    a1 = v183;
    if (v113)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v186 = 99;
      v114 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v114)
        v115 = v114;
      else
        v115 = v186;
      v116 = &v185[v115];
      v117 = v186 - v115;
      if (v186 - v115 >= 0x12)
        v118 = 18;
      else
        v118 = v186 - v115;
      v119 = v117 - v118;
      if (v119 >= v119 - 1)
        v120 = v119 - 1;
      else
        v120 = v119;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v116[v118], v120);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v131;
      v21 = v134;
      v18 = v138;
      v15 = v143;
      v12 = v149;
      v9 = v156;
      v6 = v164;
      v3 = v173;
      a1 = v183;
    }
  }
  v27 = v26[314];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v174 = v3;
    v184 = a1;
    v157 = v9;
    v165 = v6;
    v144 = v15;
    v150 = v12;
    v135 = v21;
    v139 = v18;
    v130 = v27;
    v132 = v24;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v130;
    v24 = v132;
    v21 = v135;
    v18 = v139;
    v15 = v144;
    v12 = v150;
    v9 = v157;
    v6 = v165;
    v122 = v121;
    v3 = v174;
    a1 = v184;
    if (v122)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v186 = 93;
      v123 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v123)
        v124 = v123;
      else
        v124 = v186;
      v125 = &v185[v124];
      v126 = v186 - v124;
      if (v186 - v124 >= 0x12)
        v127 = 18;
      else
        v127 = v186 - v124;
      v128 = v126 - v127;
      if (v128 >= v128 - 1)
        v129 = v128 - 1;
      else
        v129 = v128;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v125[v127], v129);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v130;
      v24 = v132;
      v21 = v135;
      v18 = v139;
      v15 = v144;
      v12 = v150;
      v9 = v157;
      v6 = v165;
      v3 = v174;
      a1 = v184;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v29[21] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::tensor::SplatOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyOneOperand(a1, v5))
  {
    return 0;
  }
  v7 = a1;
  return mlir::tensor::SplatOp::verifyInvariantsImpl((uint64_t **)&v7) != 0;
}

uint64_t mlir::Op<mlir::tensor::SplatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::UnPackOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.unpack", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::UnPackOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04D7B8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  return mlir::tensor::UnPackOp::getCanonicalizationPatterns(a2);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::tensor::UnPackOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                    + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::tensor::UnPackOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  char *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::tensor::UnPackOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::tensor::UnPackOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::tensor::PackOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::getOpPropertyByteSize()
{
  return 24;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;

  if (a4)
  {
    v4 = *a4;
    *(_QWORD *)(a3 + 16) = *((_QWORD *)a4 + 2);
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::tensor::UnPackOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::tensor::UnPackOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] == a2[1])
    return a3[2] == a2[2];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::memref::PrefetchOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::tensor::UnPackOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::UnPackOp::getAsmResultNames((uint64_t)&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::getDpsInitsMutable;
  v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DestinationStyleOpInterface]";
      v15 = 83;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[124], v2);
}

mlir::MutableOperandRange *mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::getDpsInitsMutable@<X0>(uint64_t a1@<X1>, mlir::MutableOperandRange *a2@<X8>)
{
  mlir::OpOperand *DestMutable;
  uint64_t v5;

  v5 = a1;
  DestMutable = (mlir::OpOperand *)mlir::tensor::InsertOp::getDestMutable((mlir::tensor::InsertOp *)&v5);
  return mlir::MutableOperandRange::MutableOperandRange(a2, DestMutable);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::UnPackOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::UnPackOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::UnPackOp>::getSpeculatability(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::tensor::UnPackOp::getSpeculatability((mlir::tensor::UnPackOp *)&v3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::reifyResultShapes;
  v4 = &unk_25451B000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451B000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ReifyRankedShapedTypeOpInterface]";
      v15 = 88;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ReifyRankedShapedTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451B000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[171], v2);
}

uint64_t mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::reifyResultShapes(uint64_t a1, uint64_t a2, mlir::IndexType **a3, uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::UnPackOp::reifyResultShapes(&v5, a3, a4);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::tensor::InsertOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::tensor::UnPackOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::UnPackOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::tensor::UnPackOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::tensor::InsertOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "tensor.unpack";
  v16[1] = 13;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[64];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::tensor::detail::UnPackOpGenericAdaptorBase::UnPackOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::tensor::UnPackOp::fold((uint64_t)&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  uint64_t *v35;
  uint64_t v36;
  unsigned __int8 v37;
  _QWORD *v38;
  int v52;
  int v53;
  unint64_t v54;
  unint64_t v55;
  const char *v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  unint64_t v63;
  unint64_t v64;
  const char *v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  int v70;
  int v71;
  unint64_t v72;
  unint64_t v73;
  const char *v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  unint64_t v81;
  unint64_t v82;
  const char *v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  int v88;
  int v89;
  unint64_t v90;
  unint64_t v91;
  const char *v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  unint64_t v99;
  unint64_t v100;
  const char *v101;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  int v106;
  int v107;
  unint64_t v108;
  unint64_t v109;
  const char *v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  int v115;
  int v116;
  unint64_t v117;
  unint64_t v118;
  const char *v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  int v124;
  int v125;
  unint64_t v126;
  unint64_t v127;
  const char *v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t v132;
  int v133;
  int v134;
  unint64_t v135;
  unint64_t v136;
  const char *v137;
  unint64_t v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  int v142;
  int v143;
  unint64_t v144;
  unint64_t v145;
  const char *v146;
  unint64_t v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  int v151;
  int v152;
  unint64_t v153;
  unint64_t v154;
  const char *v155;
  unint64_t v156;
  uint64_t v157;
  unint64_t v158;
  uint64_t v159;
  int v160;
  int v161;
  unint64_t v162;
  unint64_t v163;
  const char *v164;
  unint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  const char *v260;
  unint64_t v261;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v247 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v53 = v52;
    a1 = v247;
    if (v53)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v261 = 83;
      v54 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v54)
        v55 = v54;
      else
        v55 = v261;
      v56 = &v260[v55];
      v57 = v261 - v55;
      if (v261 - v55 >= 0x12)
        v58 = 18;
      else
        v58 = v261 - v55;
      v59 = v57 - v58;
      if (v59 >= v59 - 1)
        v60 = v59 - 1;
      else
        v60 = v59;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v56[v58], v60);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v247;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v235 = v3;
    v248 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v62 = v61;
    v3 = v235;
    a1 = v248;
    if (v62)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v261 = 81;
      v63 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v63)
        v64 = v63;
      else
        v64 = v261;
      v65 = &v260[v64];
      v66 = v261 - v64;
      if (v261 - v64 >= 0x12)
        v67 = 18;
      else
        v67 = v261 - v64;
      v68 = v66 - v67;
      if (v68 >= v68 - 1)
        v69 = v68 - 1;
      else
        v69 = v68;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v65[v67], v69);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v235;
      a1 = v248;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v236 = v3;
    v249 = a1;
    v224 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v224;
    v3 = v236;
    v71 = v70;
    a1 = v249;
    if (v71)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<Empty>]";
      v261 = 116;
      v72 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v72)
        v73 = v72;
      else
        v73 = v261;
      v74 = &v260[v73];
      v75 = v261 - v73;
      if (v261 - v73 >= 0x12)
        v76 = 18;
      else
        v76 = v261 - v73;
      v77 = v75 - v76;
      if (v77 >= v77 - 1)
        v78 = v77 - 1;
      else
        v78 = v77;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v74[v76], v78);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v224;
      v3 = v236;
      a1 = v249;
    }
  }
  v9 = v8[425];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v237 = v3;
    v250 = a1;
    v214 = v9;
    v225 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v214;
    v6 = v225;
    v80 = v79;
    v3 = v237;
    a1 = v250;
    if (v80)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v261 = 86;
      v81 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v81)
        v82 = v81;
      else
        v82 = v261;
      v83 = &v260[v82];
      v84 = v261 - v82;
      if (v261 - v82 >= 0x12)
        v85 = 18;
      else
        v85 = v261 - v82;
      v86 = v84 - v85;
      if (v86 >= v86 - 1)
        v87 = v86 - 1;
      else
        v87 = v86;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v83[v85], v87);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v214;
      v6 = v225;
      v3 = v237;
      a1 = v250;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v238 = v3;
    v251 = a1;
    v215 = v9;
    v226 = v6;
    v205 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v205;
    v9 = v215;
    v6 = v226;
    v89 = v88;
    v3 = v238;
    a1 = v251;
    if (v89)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<2>::Impl<Empty>]";
      v261 = 97;
      v90 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v90)
        v91 = v90;
      else
        v91 = v261;
      v92 = &v260[v91];
      v93 = v261 - v91;
      if (v261 - v91 >= 0x12)
        v94 = 18;
      else
        v94 = v261 - v91;
      v95 = v93 - v94;
      if (v95 >= v95 - 1)
        v96 = v95 - 1;
      else
        v96 = v95;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v92[v94], v96);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v205;
      v9 = v215;
      v6 = v226;
      v3 = v238;
      a1 = v251;
    }
  }
  v15 = v14[431];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v239 = v3;
    v252 = a1;
    v216 = v9;
    v227 = v6;
    v197 = v15;
    v206 = v12;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v197;
    v12 = v206;
    v9 = v216;
    v6 = v227;
    v98 = v97;
    v3 = v239;
    a1 = v252;
    if (v98)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v261 = 84;
      v99 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v99)
        v100 = v99;
      else
        v100 = v261;
      v101 = &v260[v100];
      v102 = v261 - v100;
      if (v261 - v100 >= 0x12)
        v103 = 18;
      else
        v103 = v261 - v100;
      v104 = v102 - v103;
      if (v104 >= v104 - 1)
        v105 = v104 - 1;
      else
        v105 = v104;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v101[v103], v105);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v197;
      v12 = v206;
      v9 = v216;
      v6 = v227;
      v3 = v239;
      a1 = v252;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v240 = v3;
    v253 = a1;
    v217 = v9;
    v228 = v6;
    v198 = v15;
    v207 = v12;
    v190 = v18;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v190;
    v15 = v198;
    v12 = v207;
    v9 = v217;
    v6 = v228;
    v107 = v106;
    v3 = v240;
    a1 = v253;
    if (v107)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v261 = 89;
      v108 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v108)
        v109 = v108;
      else
        v109 = v261;
      v110 = &v260[v109];
      v111 = v261 - v109;
      if (v261 - v109 >= 0x12)
        v112 = 18;
      else
        v112 = v261 - v109;
      v113 = v111 - v112;
      if (v113 >= v113 - 1)
        v114 = v113 - 1;
      else
        v114 = v113;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v110[v112], v114);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v190;
      v15 = v198;
      v12 = v207;
      v9 = v217;
      v6 = v228;
      v3 = v240;
      a1 = v253;
    }
  }
  v21 = v20[310];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v241 = v3;
    v254 = a1;
    v218 = v9;
    v229 = v6;
    v199 = v15;
    v208 = v12;
    v184 = v21;
    v191 = v18;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v184;
    v18 = v191;
    v15 = v199;
    v12 = v208;
    v9 = v218;
    v6 = v229;
    v116 = v115;
    v3 = v241;
    a1 = v254;
    if (v116)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v261 = 86;
      v117 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v117)
        v118 = v117;
      else
        v118 = v261;
      v119 = &v260[v118];
      v120 = v261 - v118;
      if (v261 - v118 >= 0x12)
        v121 = 18;
      else
        v121 = v261 - v118;
      v122 = v120 - v121;
      if (v122 >= v122 - 1)
        v123 = v122 - 1;
      else
        v123 = v122;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v119[v121], v123);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v184;
      v18 = v191;
      v15 = v199;
      v12 = v208;
      v9 = v218;
      v6 = v229;
      v3 = v241;
      a1 = v254;
    }
  }
  v24 = v23[340];
  v26 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v242 = v3;
    v255 = a1;
    v219 = v9;
    v230 = v6;
    v200 = v15;
    v209 = v12;
    v185 = v21;
    v192 = v18;
    v179 = v24;
    v26 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v24 = v179;
    v21 = v185;
    v18 = v192;
    v15 = v200;
    v12 = v209;
    v9 = v219;
    v6 = v230;
    v125 = v124;
    v3 = v242;
    a1 = v255;
    if (v125)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DestinationStyleOpInterface::Trait<Empty>]";
      v261 = 97;
      v126 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v126)
        v127 = v126;
      else
        v127 = v261;
      v128 = &v260[v127];
      v129 = v261 - v127;
      if (v261 - v127 >= 0x12)
        v130 = 18;
      else
        v130 = v261 - v127;
      v131 = v129 - v130;
      if (v131 >= v131 - 1)
        v132 = v131 - 1;
      else
        v132 = v131;
      mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DestinationStyleOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v128[v130], v132);
      v26 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v24 = v179;
      v21 = v185;
      v18 = v192;
      v15 = v200;
      v12 = v209;
      v9 = v219;
      v6 = v230;
      v3 = v242;
      a1 = v255;
    }
  }
  v27 = v26[128];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v243 = v3;
    v256 = a1;
    v220 = v9;
    v231 = v6;
    v201 = v15;
    v210 = v12;
    v186 = v21;
    v193 = v18;
    v175 = v27;
    v180 = v24;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v175;
    v24 = v180;
    v21 = v186;
    v18 = v193;
    v15 = v201;
    v12 = v210;
    v9 = v220;
    v6 = v231;
    v134 = v133;
    v3 = v243;
    a1 = v256;
    if (v134)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v261 = 95;
      v135 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v135)
        v136 = v135;
      else
        v136 = v261;
      v137 = &v260[v136];
      v138 = v261 - v136;
      if (v261 - v136 >= 0x12)
        v139 = 18;
      else
        v139 = v261 - v136;
      v140 = v138 - v139;
      if (v140 >= v140 - 1)
        v141 = v140 - 1;
      else
        v141 = v140;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v137[v139], v141);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v175;
      v24 = v180;
      v21 = v186;
      v18 = v193;
      v15 = v201;
      v12 = v210;
      v9 = v220;
      v6 = v231;
      v3 = v243;
      a1 = v256;
    }
  }
  v30 = v29[312];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v244 = v3;
    v257 = a1;
    v221 = v9;
    v232 = v6;
    v202 = v15;
    v211 = v12;
    v187 = v21;
    v194 = v18;
    v176 = v27;
    v181 = v24;
    v172 = v30;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v172;
    v27 = v176;
    v24 = v181;
    v21 = v187;
    v18 = v194;
    v15 = v202;
    v12 = v211;
    v9 = v221;
    v6 = v232;
    v143 = v142;
    v3 = v244;
    a1 = v257;
    if (v143)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v261 = 93;
      v144 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v144)
        v145 = v144;
      else
        v145 = v261;
      v146 = &v260[v145];
      v147 = v261 - v145;
      if (v261 - v145 >= 0x12)
        v148 = 18;
      else
        v148 = v261 - v145;
      v149 = v147 - v148;
      if (v149 >= v149 - 1)
        v150 = v149 - 1;
      else
        v150 = v149;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v146[v148], v150);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v172;
      v27 = v176;
      v24 = v181;
      v21 = v187;
      v18 = v194;
      v15 = v202;
      v12 = v211;
      v9 = v221;
      v6 = v232;
      v3 = v244;
      a1 = v257;
    }
  }
  v33 = v32[21];
  v35 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v34 & 1) == 0)
  {
    v245 = v3;
    v258 = a1;
    v222 = v9;
    v233 = v6;
    v203 = v15;
    v212 = v12;
    v188 = v21;
    v195 = v18;
    v177 = v27;
    v182 = v24;
    v170 = v33;
    v173 = v30;
    v35 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v33 = v170;
    v30 = v173;
    v27 = v177;
    v24 = v182;
    v21 = v188;
    v18 = v195;
    v15 = v203;
    v12 = v212;
    v9 = v222;
    v6 = v233;
    v152 = v151;
    v3 = v245;
    a1 = v258;
    if (v152)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ReifyRankedShapedTypeOpInterface::Trait<Empty>]";
      v261 = 102;
      v153 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v153)
        v154 = v153;
      else
        v154 = v261;
      v155 = &v260[v154];
      v156 = v261 - v154;
      if (v261 - v154 >= 0x12)
        v157 = 18;
      else
        v157 = v261 - v154;
      v158 = v156 - v157;
      if (v158 >= v158 - 1)
        v159 = v158 - 1;
      else
        v159 = v158;
      mlir::detail::TypeIDResolver<mlir::ReifyRankedShapedTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ReifyRankedShapedTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v155[v157], v159);
      v35 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v33 = v170;
      v30 = v173;
      v27 = v177;
      v24 = v182;
      v21 = v188;
      v18 = v195;
      v15 = v203;
      v12 = v212;
      v9 = v222;
      v6 = v233;
      v3 = v245;
      a1 = v258;
    }
  }
  v36 = v35[168];
  v38 = &unk_25451A000;
  if ((v37 & 1) == 0)
  {
    v246 = v3;
    v259 = a1;
    v223 = v9;
    v234 = v6;
    v204 = v15;
    v213 = v12;
    v189 = v21;
    v196 = v18;
    v178 = v27;
    v183 = v24;
    v171 = v33;
    v174 = v30;
    v169 = v36;
    v38 = (_QWORD *)&unk_25451A000;
    v36 = v169;
    v33 = v171;
    v30 = v174;
    v27 = v178;
    v24 = v183;
    v21 = v189;
    v18 = v196;
    v15 = v204;
    v12 = v213;
    v9 = v223;
    v6 = v234;
    v161 = v160;
    v3 = v246;
    a1 = v259;
    if (v161)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v261 = 90;
      v162 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v162)
        v163 = v162;
      else
        v163 = v261;
      v164 = &v260[v163];
      v165 = v261 - v163;
      if (v261 - v163 >= 0x12)
        v166 = 18;
      else
        v166 = v261 - v163;
      v167 = v165 - v166;
      if (v167 >= v167 - 1)
        v168 = v167 - 1;
      else
        v168 = v167;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v164[v166], v168);
      v38 = (_QWORD *)&unk_25451A000;
      v36 = v169;
      v33 = v171;
      v30 = v174;
      v27 = v178;
      v24 = v183;
      v21 = v189;
      v18 = v196;
      v15 = v204;
      v12 = v213;
      v9 = v223;
      v6 = v234;
      v3 = v246;
      a1 = v259;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v36 == a1
      || v38[27] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;

  mlir::OpState::printOpName(a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::tensor::UnPackOp::print((mlir::tensor::UnPackOp *)&v7, a3);
}

BOOL mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)2))
    return 0;
  v6 = a1;
  if (!mlir::tensor::UnPackOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::tensor::UnPackOp::verify((mlir::tensor::UnPackOp *)&v6) != 0;
}

BOOL mlir::Op<mlir::tensor::UnPackOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;

  return mlir::detail::verifyDestinationStyleOpInterface(a1, a2)
      && mlir::detail::verifyInferredResultTypes(a1, v3) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::YieldOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::YieldOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::tensor::YieldOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.yield", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::YieldOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04D560;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::foldHook()
{
  unsigned int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::tensor::YieldOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::YieldOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::YieldOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::YieldOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::YieldOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::YieldOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::YieldOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::tensor::YieldOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::tensor::YieldOp>::getMutableSuccessorOperands;
  v2[1] = mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::tensor::YieldOp>::getSuccessorRegions;
  v4 = &unk_254519000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_254519000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchTerminatorOpInterface]";
      v15 = 89;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_254519000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[393], v2);
}

double mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::tensor::YieldOp>::getMutableSuccessorOperands@<D0>(mlir::Operation *a1@<X1>, mlir::MutableOperandRange *a2@<X8>)
{
  mlir::Operation *v3;

  v3 = a1;
  return mlir::memref::AllocaScopeReturnOp::getMutableSuccessorOperands(&v3, a2);
}

uint64_t mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::tensor::YieldOp>::getSuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Block *v6;
  uint64_t ParentOp;
  uint64_t v9;
  mlir::Block *v10;
  unint64_t Parent;
  uint64_t v13;
  uint64_t v14;

  v6 = *(mlir::Block **)(a2 + 16);
  if (v6)
  {
    ParentOp = mlir::Block::getParentOp(v6);
    v9 = ParentOp;
    if (ParentOp)
      ParentOp = mlir::OpInterface<mlir::RegionBranchOpInterface,mlir::detail::RegionBranchOpInterfaceInterfaceTraits>::getInterfaceFor(ParentOp);
    v10 = *(mlir::Block **)(a2 + 16);
    v13 = v9;
    v14 = ParentOp;
    if (v10)
      Parent = mlir::Block::getParent(v10);
    else
      Parent = 0;
  }
  else
  {
    Parent = 0;
    v13 = 0;
    v14 = 0;
  }
  return mlir::BranchOpInterface::getSuccessorForOperands(&v13, Parent, a5);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  const char *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  const char *v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  unint64_t v86;
  unint64_t v87;
  const char *v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  const char *v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  unint64_t v104;
  unint64_t v105;
  const char *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unint64_t v113;
  unint64_t v114;
  const char *v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  unint64_t v122;
  unint64_t v123;
  const char *v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  int v129;
  int v130;
  unint64_t v131;
  unint64_t v132;
  const char *v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  unint64_t v140;
  unint64_t v141;
  const char *v142;
  unint64_t v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  int v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  const char *v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  const char *v234;
  unint64_t v235;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v222 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v49 = v48;
    a1 = v222;
    if (v49)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v235 = 83;
      v50 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v50)
        v51 = v50;
      else
        v51 = v235;
      v52 = &v234[v51];
      v53 = v235 - v51;
      if (v235 - v51 >= 0x12)
        v54 = 18;
      else
        v54 = v235 - v51;
      v55 = v53 - v54;
      if (v55 >= v55 - 1)
        v56 = v55 - 1;
      else
        v56 = v55;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v222;
    }
  }
  v3 = v2[13];
  v5 = &unk_254519000;
  if ((v4 & 1) == 0)
  {
    v211 = v3;
    v223 = a1;
    v5 = (_QWORD *)&unk_254519000;
    v58 = v57;
    v3 = v211;
    a1 = v223;
    if (v58)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      v235 = 83;
      v59 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v59)
        v60 = v59;
      else
        v60 = v235;
      v61 = &v234[v60];
      v62 = v235 - v60;
      if (v235 - v60 >= 0x12)
        v63 = 18;
      else
        v63 = v235 - v60;
      v64 = v62 - v63;
      if (v64 >= v64 - 1)
        v65 = v64 - 1;
      else
        v65 = v64;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      v5 = (_QWORD *)&unk_254519000;
      v3 = v211;
      a1 = v223;
    }
  }
  v6 = v5[417];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v212 = v3;
    v224 = a1;
    v201 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v201;
    v3 = v212;
    v67 = v66;
    a1 = v224;
    if (v67)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v235 = 86;
      v68 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v68)
        v69 = v68;
      else
        v69 = v235;
      v70 = &v234[v69];
      v71 = v235 - v69;
      if (v235 - v69 >= 0x12)
        v72 = 18;
      else
        v72 = v235 - v69;
      v73 = v71 - v72;
      if (v73 >= v73 - 1)
        v74 = v73 - 1;
      else
        v74 = v73;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v201;
      v3 = v212;
      a1 = v224;
    }
  }
  v9 = v8[419];
  v11 = &unk_25451A000;
  if ((v10 & 1) == 0)
  {
    v213 = v3;
    v225 = a1;
    v202 = v6;
    v192 = v9;
    v11 = (_QWORD *)&unk_25451A000;
    v9 = v192;
    v6 = v202;
    v3 = v213;
    v76 = v75;
    a1 = v225;
    if (v76)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v235 = 82;
      v77 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v77)
        v78 = v77;
      else
        v78 = v235;
      v79 = &v234[v78];
      v80 = v235 - v78;
      if (v235 - v78 >= 0x12)
        v81 = 18;
      else
        v81 = v235 - v78;
      v82 = v80 - v81;
      if (v82 >= v82 - 1)
        v83 = v82 - 1;
      else
        v83 = v82;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      v11 = (_QWORD *)&unk_25451A000;
      v9 = v192;
      v6 = v202;
      v3 = v213;
      a1 = v225;
    }
  }
  v12 = v11[19];
  v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v214 = v3;
    v226 = a1;
    v203 = v6;
    v184 = v12;
    v193 = v9;
    v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v12 = v184;
    v9 = v193;
    v6 = v203;
    v3 = v214;
    v85 = v84;
    a1 = v226;
    if (v85)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasParent<mlir::tensor::GenerateOp, mlir::t"
             "ensor::PadOp>::Impl<Empty>]";
      v235 = 134;
      v86 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v86)
        v87 = v86;
      else
        v87 = v235;
      v88 = &v234[v87];
      v89 = v235 - v87;
      if (v235 - v87 >= 0x12)
        v90 = 18;
      else
        v90 = v235 - v87;
      v91 = v89 - v90;
      if (v91 >= v91 - 1)
        v92 = v91 - 1;
      else
        v92 = v91;
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v12 = v184;
      v9 = v193;
      v6 = v203;
      v3 = v214;
      a1 = v226;
    }
  }
  v15 = v14[228];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v215 = v3;
    v227 = a1;
    v204 = v6;
    v185 = v12;
    v194 = v9;
    v177 = v15;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v177;
    v12 = v185;
    v9 = v194;
    v6 = v204;
    v3 = v215;
    v94 = v93;
    a1 = v227;
    if (v94)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v235 = 84;
      v95 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v95)
        v96 = v95;
      else
        v96 = v235;
      v97 = &v234[v96];
      v98 = v235 - v96;
      if (v235 - v96 >= 0x12)
        v99 = 18;
      else
        v99 = v235 - v96;
      v100 = v98 - v99;
      if (v100 >= v100 - 1)
        v101 = v100 - 1;
      else
        v101 = v100;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v177;
      v12 = v185;
      v9 = v194;
      v6 = v204;
      v3 = v215;
      a1 = v227;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v216 = v3;
    v228 = a1;
    v205 = v6;
    v186 = v12;
    v195 = v9;
    v171 = v18;
    v178 = v15;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v171;
    v15 = v178;
    v12 = v186;
    v9 = v195;
    v6 = v205;
    v3 = v216;
    v103 = v102;
    a1 = v228;
    if (v103)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v235 = 95;
      v104 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v104)
        v105 = v104;
      else
        v105 = v235;
      v106 = &v234[v105];
      v107 = v235 - v105;
      if (v235 - v105 >= 0x12)
        v108 = 18;
      else
        v108 = v235 - v105;
      v109 = v107 - v108;
      if (v109 >= v109 - 1)
        v110 = v109 - 1;
      else
        v110 = v109;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v171;
      v15 = v178;
      v12 = v186;
      v9 = v195;
      v6 = v205;
      v3 = v216;
      a1 = v228;
    }
  }
  v21 = v20[312];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v217 = v3;
    v229 = a1;
    v206 = v6;
    v187 = v12;
    v196 = v9;
    v172 = v18;
    v179 = v15;
    v166 = v21;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v166;
    v18 = v172;
    v15 = v179;
    v12 = v187;
    v9 = v196;
    v6 = v206;
    v3 = v217;
    v112 = v111;
    a1 = v229;
    if (v112)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v235 = 99;
      v113 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v113)
        v114 = v113;
      else
        v114 = v235;
      v115 = &v234[v114];
      v116 = v235 - v114;
      if (v235 - v114 >= 0x12)
        v117 = 18;
      else
        v117 = v235 - v114;
      v118 = v116 - v117;
      if (v118 >= v118 - 1)
        v119 = v118 - 1;
      else
        v119 = v118;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v166;
      v18 = v172;
      v15 = v179;
      v12 = v187;
      v9 = v196;
      v6 = v206;
      v3 = v217;
      a1 = v229;
    }
  }
  v24 = v23[314];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v218 = v3;
    v230 = a1;
    v207 = v6;
    v188 = v12;
    v197 = v9;
    v173 = v18;
    v180 = v15;
    v162 = v24;
    v167 = v21;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v162;
    v21 = v167;
    v18 = v173;
    v15 = v180;
    v12 = v188;
    v9 = v197;
    v6 = v207;
    v3 = v218;
    v121 = v120;
    a1 = v230;
    if (v121)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v235 = 93;
      v122 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v122)
        v123 = v122;
      else
        v123 = v235;
      v124 = &v234[v123];
      v125 = v235 - v123;
      if (v235 - v123 >= 0x12)
        v126 = 18;
      else
        v126 = v235 - v123;
      v127 = v125 - v126;
      if (v127 >= v127 - 1)
        v128 = v127 - 1;
      else
        v128 = v127;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v162;
      v21 = v167;
      v18 = v173;
      v15 = v180;
      v12 = v188;
      v9 = v197;
      v6 = v207;
      v3 = v218;
      a1 = v230;
    }
  }
  v27 = v26[21];
  v29 = &unk_25451B000;
  if ((v28 & 1) == 0)
  {
    v219 = v3;
    v231 = a1;
    v208 = v6;
    v189 = v12;
    v198 = v9;
    v174 = v18;
    v181 = v15;
    v163 = v24;
    v168 = v21;
    v159 = v27;
    v29 = (_QWORD *)&unk_25451B000;
    v27 = v159;
    v24 = v163;
    v21 = v168;
    v18 = v174;
    v15 = v181;
    v12 = v189;
    v9 = v198;
    v6 = v208;
    v3 = v219;
    v130 = v129;
    a1 = v231;
    if (v130)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchTerminatorOpInterface::Trait<Empty>]";
      v235 = 103;
      v131 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v131)
        v132 = v131;
      else
        v132 = v235;
      v133 = &v234[v132];
      v134 = v235 - v132;
      if (v235 - v132 >= 0x12)
        v135 = 18;
      else
        v135 = v235 - v132;
      v136 = v134 - v135;
      if (v136 >= v136 - 1)
        v137 = v136 - 1;
      else
        v137 = v136;
      mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchTerminatorOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      v29 = (_QWORD *)&unk_25451B000;
      v27 = v159;
      v24 = v163;
      v21 = v168;
      v18 = v174;
      v15 = v181;
      v12 = v189;
      v9 = v198;
      v6 = v208;
      v3 = v219;
      a1 = v231;
    }
  }
  v30 = v29[69];
  v32 = &unk_254519000;
  if ((v31 & 1) == 0)
  {
    v220 = v3;
    v232 = a1;
    v209 = v6;
    v190 = v12;
    v199 = v9;
    v175 = v18;
    v182 = v15;
    v164 = v24;
    v169 = v21;
    v157 = v30;
    v160 = v27;
    v32 = (_QWORD *)&unk_254519000;
    v30 = v157;
    v27 = v160;
    v24 = v164;
    v21 = v169;
    v18 = v175;
    v15 = v182;
    v12 = v190;
    v9 = v199;
    v6 = v209;
    v3 = v220;
    v139 = v138;
    a1 = v232;
    if (v139)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ReturnLike<Empty>]";
      v235 = 82;
      v140 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v140)
        v141 = v140;
      else
        v141 = v235;
      v142 = &v234[v141];
      v143 = v235 - v141;
      if (v235 - v141 >= 0x12)
        v144 = 18;
      else
        v144 = v235 - v141;
      v145 = v143 - v144;
      if (v145 >= v145 - 1)
        v146 = v145 - 1;
      else
        v146 = v145;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ReturnLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ReturnLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      v32 = (_QWORD *)&unk_254519000;
      v30 = v157;
      v27 = v160;
      v24 = v164;
      v21 = v169;
      v18 = v175;
      v15 = v182;
      v12 = v190;
      v9 = v199;
      v6 = v209;
      v3 = v220;
      a1 = v232;
    }
  }
  v33 = v32[401];
  v35 = &unk_25451A000;
  if ((v34 & 1) == 0)
  {
    v221 = v3;
    v233 = a1;
    v210 = v6;
    v191 = v12;
    v200 = v9;
    v176 = v18;
    v183 = v15;
    v165 = v24;
    v170 = v21;
    v158 = v30;
    v161 = v27;
    v156 = v33;
    v35 = (_QWORD *)&unk_25451A000;
    v33 = v156;
    v30 = v158;
    v27 = v161;
    v24 = v165;
    v21 = v170;
    v18 = v176;
    v15 = v183;
    v12 = v191;
    v9 = v200;
    v6 = v210;
    v3 = v221;
    v148 = v147;
    a1 = v233;
    if (v148)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsTerminator<Empty>]";
      v235 = 84;
      v149 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v149)
        v150 = v149;
      else
        v150 = v235;
      v151 = &v234[v150];
      v152 = v235 - v150;
      if (v235 - v150 >= 0x12)
        v153 = 18;
      else
        v153 = v235 - v150;
      v154 = v152 - v153;
      if (v154 >= v154 - 1)
        v155 = v154 - 1;
      else
        v155 = v154;
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      v35 = (_QWORD *)&unk_25451A000;
      v33 = v156;
      v30 = v158;
      v27 = v161;
      v24 = v165;
      v21 = v170;
      v18 = v176;
      v15 = v183;
      v12 = v191;
      v9 = v200;
      v6 = v210;
      v3 = v221;
      a1 = v233;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v35[223] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::memref::AtomicYieldOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::tensor::YieldOp>,mlir::OpTrait::ZeroResults<mlir::tensor::YieldOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::YieldOp>,mlir::OpTrait::OneOperand<mlir::tensor::YieldOp>,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl<mlir::tensor::YieldOp>,mlir::OpTrait::OpInvariants<mlir::tensor::YieldOp>,mlir::ConditionallySpeculatable::Trait<mlir::tensor::YieldOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::tensor::YieldOp>,mlir::MemoryEffectOpInterface::Trait<mlir::tensor::YieldOp>,mlir::RegionBranchTerminatorOpInterface::Trait<mlir::tensor::YieldOp>,mlir::OpTrait::ReturnLike<mlir::tensor::YieldOp>,mlir::OpTrait::IsTerminator<mlir::tensor::YieldOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::tensor::YieldOp>,mlir::OpTrait::ZeroResults<mlir::tensor::YieldOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::YieldOp>,mlir::OpTrait::OneOperand<mlir::tensor::YieldOp>,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl<mlir::tensor::YieldOp>,mlir::OpTrait::OpInvariants<mlir::tensor::YieldOp>,mlir::ConditionallySpeculatable::Trait<mlir::tensor::YieldOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::tensor::YieldOp>,mlir::MemoryEffectOpInterface::Trait<mlir::tensor::YieldOp>,mlir::RegionBranchTerminatorOpInterface::Trait<mlir::tensor::YieldOp>,mlir::OpTrait::ReturnLike<mlir::tensor::YieldOp>,mlir::OpTrait::IsTerminator<mlir::tensor::YieldOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;

  return mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
      && mlir::OpTrait::impl::verifyZeroResults(a1, v3)
      && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
      && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
      && mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl<mlir::tensor::YieldOp>::verifyTrait((uint64_t *)a1)
      && ZinIrConstData_specialization<half>::prepare()
      && mlir::OpTrait::impl::verifyIsTerminator(a1, v6) != 0;
}

uint64_t mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl<mlir::tensor::YieldOp>::verifyTrait(uint64_t *a1)
{
  mlir::Block *v2;
  uint64_t ParentOp;
  void *v4;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  char *v9;
  __int128 v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  const char **v16;
  uint64_t v17;
  __int128 v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v28;
  unint64_t v29;
  BOOL v30;
  int64_t v31;
  char *v32;
  const char *v33;
  const void **v34;
  __int16 v35;
  const char *v36[3];
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  _QWORD v40[3];
  void *v41;
  unsigned int v42;
  unsigned int v43;
  _BYTE v44[96];
  void *v45;
  _QWORD *v46;
  void *__p;
  _QWORD *v48;
  char v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  v2 = (mlir::Block *)a1[2];
  if (v2)
  {
    ParentOp = mlir::Block::getParentOp(v2);
    if (ParentOp)
    {
      v4 = *(void **)(*(_QWORD *)(ParentOp + 48) + 16);
      if (v4 == &mlir::detail::TypeIDResolver<mlir::tensor::GenerateOp,void>::id
        || v4 == &mlir::detail::TypeIDResolver<mlir::tensor::PadOp,void>::id)
      {
        return 1;
      }
    }
  }
  v35 = 257;
  mlir::Operation::emitOpError(a1, &v34, (uint64_t)v40);
  if (v40[0])
  {
    LODWORD(v37) = 3;
    *((_QWORD *)&v37 + 1) = "expects parent op ";
    *(_QWORD *)&v38 = 18;
    v7 = &v37;
    v8 = (char *)v41;
    if (v42 >= v43)
    {
      v28 = v42 + 1;
      if (v41 <= &v37 && (char *)v41 + 24 * v42 > (char *)&v37)
      {
        v31 = (char *)&v37 - (_BYTE *)v41;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v28, 24);
        v8 = (char *)v41;
        v7 = (__int128 *)((char *)v41 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v28, 24);
        v7 = &v37;
        v8 = (char *)v41;
      }
    }
    v9 = &v8[24 * v42];
    v10 = *v7;
    *((_QWORD *)v9 + 2) = *((_QWORD *)v7 + 2);
    *(_OWORD *)v9 = v10;
    ++v42;
  }
  v33 = "to be one of '";
  v11 = (_QWORD *)mlir::InFlightDiagnostic::append<char const*&>((uint64_t)v40, &v33);
  v12 = (uint64_t)v11;
  v37 = xmmword_24C0610C8;
  v38 = *(_OWORD *)&off_24C0610D8;
  if (*v11)
  {
    v36[0] = ", ";
    llvm::interleave<llvm::StringLiteral const*,mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(llvm::ArrayRef<llvm::StringLiteral> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(void)#1},void>((uint64_t)&v37, (uint64_t)&v39, (uint64_t)(v11 + 1), (uint64_t)(v11 + 1), v36);
    if (*(_QWORD *)v12)
    {
      v13 = v12 + 24;
      v14 = *(_QWORD *)(v12 + 24);
      LODWORD(v36[0]) = 3;
      v36[1] = "'";
      v36[2] = (const char *)1;
      v15 = *(unsigned int *)(v12 + 32);
      v16 = v36;
      if (v15 >= *(_DWORD *)(v12 + 36))
      {
        v29 = v15 + 1;
        v30 = v14 + 24 * v15 > (unint64_t)v36;
        if (v14 <= (unint64_t)v36 && v30)
        {
          v32 = (char *)v36 - v14;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v13, (void *)(v12 + 40), v29, 24);
          v14 = *(_QWORD *)(v12 + 24);
          v16 = (const char **)&v32[v14];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v13, (void *)(v12 + 40), v29, 24);
          v14 = *(_QWORD *)(v12 + 24);
          v16 = v36;
        }
      }
      v17 = v14 + 24 * *(unsigned int *)(v12 + 32);
      v18 = *(_OWORD *)v16;
      *(_QWORD *)(v17 + 16) = v16[2];
      *(_OWORD *)v17 = v18;
      ++*(_DWORD *)(v12 + 32);
    }
  }
  v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v12);
  if (v40[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v40);
  if (v49)
  {
    v19 = __p;
    if (__p)
    {
      v20 = v48;
      v21 = __p;
      if (v48 != __p)
      {
        do
          v20 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v20 - 1);
        while (v20 != v19);
        v21 = __p;
      }
      v48 = v19;
      operator delete(v21);
    }
    v22 = v45;
    if (v45)
    {
      v23 = v46;
      v24 = v45;
      if (v46 != v45)
      {
        do
        {
          v26 = *--v23;
          v25 = v26;
          *v23 = 0;
          if (v26)
            MEMORY[0x20BD002D4](v25, 0x1000C8077774924);
        }
        while (v23 != v22);
        v24 = v45;
      }
      v46 = v22;
      operator delete(v24);
    }
    if (v41 != v44)
      free(v41);
  }
  return v6;
}

uint64_t mlir::Op<mlir::tensor::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::tensor::GenerateOp,mlir::tensor::PadOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyRegionInvariants()
{
  return 1;
}

void `anonymous namespace'::TensorInlinerInterface::~TensorInlinerInterface(_anonymous_namespace_::TensorInlinerInterface *this)
{
  ZinIrHalH13g::~ZinIrHalH13g(this);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::TensorInlinerInterface::isLegalToInline()
{
  return 1;
}

{
  return 1;
}

ZinIrHalH13g *mlir::tensor::TensorDialect::materializeConstant(uint64_t a1, mlir::OpBuilder *a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  ZinIrHalH13g *result;
  _QWORD *v10;
  uint64_t v11;

  v11 = a4;
  result = mlir::arith::ConstantOp::materialize(a2, a3, a4, a5);
  if (!result)
  {
    if (mlir::complex::ConstantOp::isBuildableWith((uint64_t)a3, a4))
    {
      v10 = a3;
      return mlir::OpBuilder::create<mlir::complex::ConstantOp,mlir::Type &,mlir::ArrayAttr>(a2, a5, &v11, (uint64_t *)&v10);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

unint64_t mlir::tensor::getMixedSize(mlir::IndexType **a1, uint64_t a2, uint64_t a3, mlir::MLIRContext *a4)
{
  unsigned int v4;
  uint64_t v7;
  unint64_t v8;
  void *v9;
  uint64_t Value;
  unint64_t v12;
  mlir::MLIRContext *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  _BYTE v17[48];
  void *v18[2];
  _QWORD v19[2];

  v4 = a4;
  v19[1] = *MEMORY[0x24BDAC8D0];
  v13 = a4;
  v14 = a3;
  v12 = *(_QWORD *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8;
  v15 = v17;
  v16 = 0x600000000;
  if (*(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v12) + 8 * a4) != 0x8000000000000000)
  {
    Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v12);
    v8 = mlir::Builder::getIndexAttr(a1, *(mlir::MLIRContext **)(Value + 8 * v4)) & 0xFFFFFFFFFFFFFFFBLL;
    v9 = v15;
    if (v15 == v17)
      return v8;
LABEL_7:
    free(v9);
    return v8;
  }
  v18[0] = v19;
  v18[1] = (void *)0x100000000;
  mlir::OpBuilder::createOrFold<mlir::tensor::DimOp,mlir::Value &,long long &>((uint64_t)a1, (uint64_t)v18, a2, &v14, &v13);
  v7 = *(_QWORD *)v18[0];
  if (v18[0] != v19)
    free(v18[0]);
  v8 = v7 | 4;
  v9 = v15;
  if (v15 != v17)
    goto LABEL_7;
  return v8;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::EmptyOp,llvm::SmallVector<mlir::OpFoldResult,6u> &,mlir::Type>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  ZinIrHalH13g *v12;
  ZinIrHalH13g *v13;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  uint64_t v18[4];
  __int16 v19;
  _QWORD v20[39];

  v20[38] = *MEMORY[0x24BDAC8D0];
  v15 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.empty", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v19 = 1283;
    v18[2] = (uint64_t)"tensor.empty";
    v18[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v17 = 259;
    llvm::operator+(v18, (uint64_t *)&v16, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::tensor::EmptyOp::build(v11, (uint64_t)v20, *(uint64_t **)a3, *(unsigned int *)(a3 + 8), *a4, 0);
  v12 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v12 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::EmptyOp,void>::id)
    v13 = v12;
  else
    v13 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v13;
}

BOOL mlir::tensor::isSameTypeWithoutEncoding(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  const void *Value;
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  uint64_t v8;
  uint64_t RHS;
  uint64_t v11;
  uint64_t v12;

  if (*(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v2 = a1;
  else
    v2 = 0;
  v12 = v2;
  if (!v2)
    return a1 == a2;
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v3 = a2;
  else
    v3 = 0;
  v11 = v3;
  if (!v3)
    return 0;
  Value = (const void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v12);
  v6 = v5;
  v7 = (const void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v11);
  if (v6 != v8 || memcmp(Value, v7, 8 * v6))
    return 0;
  RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v12);
  return RHS == mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v11);
}

BOOL mlir::tensor::BitcastOp::areCastCompatible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  _BOOL8 result;
  unint64_t v9;
  unint64_t v10;
  void *v11;
  _QWORD *v13;
  void *v14;
  _QWORD *v16;
  BOOL v17;
  int IntOrFloatBitWidth;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD v21[5];

  result = 0;
  if (a2 == 1 && a4 == 1)
  {
    v21[3] = v4;
    v21[4] = v5;
    v9 = mlir::TypeRange::dereference_iterator(a1, 0);
    v10 = mlir::TypeRange::dereference_iterator(a3, 0);
    v11 = *(void **)(*(_QWORD *)v9 + 136);
    if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
      || v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
      v13 = (_QWORD *)v9;
    }
    else
    {
      v13 = 0;
    }
    v20 = v13;
    v14 = *(void **)(*(_QWORD *)v10 + 136);
    if (v14 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
      || v14 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
      v16 = (_QWORD *)v10;
    }
    else
    {
      v16 = 0;
    }
    v19 = v16;
    if (v13)
      v17 = v16 == 0;
    else
      v17 = 1;
    if (v17)
      return 0;
    v21[0] = mlir::TensorType::getElementType((mlir::TensorType *)&v20);
    IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)v21);
    v21[0] = mlir::TensorType::getElementType((mlir::TensorType *)&v19);
    return IntOrFloatBitWidth == mlir::Type::getIntOrFloatBitWidth((mlir::Type *)v21)
        && mlir::verifyCompatibleShape(v20, v19);
  }
  return result;
}

void mlir::tensor::BitcastOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  unint64_t v39;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v38, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"tensor.bitcast", 14, (__int16)v38, a2, 0, 0);
  *(_QWORD *)v4 = &off_24C029A40;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v38 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::ChainedTensorBitcast]";
  v39 = 93;
  v9 = llvm::StringRef::find((uint64_t *)&v38, "DesiredTypeName = ", 0x12uLL, 0);
  if (v39 >= v9)
    v10 = v9;
  else
    v10 = v39;
  v11 = &v38[v10];
  v12 = v39 - v10;
  if (v39 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v39 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    abort();
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_44;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_44:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
}

uint64_t mlir::tensor::preservesStaticInformation(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v5;
  uint64_t RHS;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *Value;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  if (*(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v2 = a1;
  else
    v2 = 0;
  v20 = v2;
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v3 = a2;
  else
    v3 = 0;
  v19 = v3;
  if (v2)
    v4 = v3 == 0;
  else
    v4 = 1;
  if (v4)
    return 0;
  RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v20);
  if (RHS == mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v19))
  {
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v20);
    v9 = v8;
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v19);
    if (v9 == v10)
    {
      Value = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v20);
      v13 = v12;
      v14 = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v19);
      v5 = 1;
      if (v13 && v15)
      {
        v16 = 8 * v15 - 8;
        v17 = 8 * v13 - 8;
        while (*Value == 0x8000000000000000 || *v14 != 0x8000000000000000)
        {
          v5 = 1;
          if (v17)
          {
            ++Value;
            ++v14;
            v18 = v16;
            v16 -= 8;
            v17 -= 8;
            if (v18)
              continue;
          }
          return v5;
        }
        return 0;
      }
      return v5;
    }
  }
  return 0;
}

uint64_t mlir::tensor::foldTensorCast(mlir::tensor *this, mlir::Operation *a2)
{
  uint64_t v2;
  char v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t DefiningOp;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v12;

  if ((*((_BYTE *)this + 46) & 0x80) != 0 && (v2 = *((unsigned int *)this + 17), (_DWORD)v2))
  {
    v3 = 0;
    v4 = (uint64_t *)*((_QWORD *)this + 9);
    v5 = 32 * v2;
    do
    {
      v12 = v4[3];
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v12);
      if (DefiningOp)
      {
        v7 = DefiningOp;
        if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id)
        {
          if (mlir::tensor::preservesStaticInformation(*(_QWORD *)(DefiningOp - 8) & 0xFFFFFFFFFFFFFFF8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
          {
            v8 = *(uint64_t **)(*(_QWORD *)(v7 + 72) + 24);
            v9 = (uint64_t *)v4[1];
            if (v9)
            {
              *v9 = *v4;
              if (*v4)
                *(_QWORD *)(*v4 + 8) = v4[1];
            }
            v4[3] = (uint64_t)v8;
            v10 = *v8;
            *v4 = *v8;
            v4[1] = (uint64_t)v8;
            if (v10)
              *(_QWORD *)(v10 + 8) = v4;
            *v8 = (uint64_t)v4;
            v3 = 1;
          }
        }
      }
      v4 += 4;
      v5 -= 32;
    }
    while (v5);
  }
  else
  {
    v3 = 0;
  }
  return v3 & 1;
}

BOOL mlir::tensor::CastOp::areCastCompatible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v4;
  _QWORD *v5;
  _BOOL8 result;
  unint64_t v9;
  unint64_t v10;
  void *v11;
  _QWORD *v13;
  void *v14;
  _QWORD *v16;
  BOOL v17;
  uint64_t ElementType;
  _QWORD *v19;
  _QWORD *v20[5];

  result = 0;
  if (a2 == 1 && a4 == 1)
  {
    v20[3] = v4;
    v20[4] = v5;
    v9 = mlir::TypeRange::dereference_iterator(a1, 0);
    v10 = mlir::TypeRange::dereference_iterator(a3, 0);
    v11 = *(void **)(*(_QWORD *)v9 + 136);
    if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
      || v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
      v13 = (_QWORD *)v9;
    }
    else
    {
      v13 = 0;
    }
    v20[0] = v13;
    v14 = *(void **)(*(_QWORD *)v10 + 136);
    if (v14 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
      || v14 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
      v16 = (_QWORD *)v10;
    }
    else
    {
      v16 = 0;
    }
    v19 = v16;
    if (v13)
      v17 = v16 == 0;
    else
      v17 = 1;
    if (!v17
      && (ElementType = mlir::TensorType::getElementType((mlir::TensorType *)v20),
          ElementType == mlir::TensorType::getElementType((mlir::TensorType *)&v19)))
    {
      return mlir::verifyCompatibleShape(v20[0], v19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void mlir::tensor::CastOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  const char *v45;
  unint64_t v46;
  uint64_t v47;
  const char *v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  const char *v72;
  unint64_t v73;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v72, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"tensor.cast", 11, (__int16)v72, a2, 0, 0);
  *(_QWORD *)v4 = &off_24C028F48;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v72 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::ChainedTensorCast]";
  v73 = 90;
  v9 = llvm::StringRef::find((uint64_t *)&v72, "DesiredTypeName = ", 0x12uLL, 0);
  if (v73 >= v9)
    v10 = v9;
  else
    v10 = v73;
  v11 = &v72[v10];
  v12 = v73 - v10;
  if (v73 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v73 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_78;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_79;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_82;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_82:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v72, 1);
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"tensor.cast", 11, (__int16)v72, a2, 0, 0);
  *(_QWORD *)v38 = &off_24C02A430;
  if (*(_QWORD *)(v38 + 72))
  {
    v39 = *(unsigned int *)(v38 + 88);
    if (v39 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v39, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  v72 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::TensorCastExtractSlice]";
  v73 = 95;
  v43 = llvm::StringRef::find((uint64_t *)&v72, "DesiredTypeName = ", 0x12uLL, 0);
  if (v73 >= v43)
    v44 = v43;
  else
    v44 = v73;
  v45 = &v72[v44];
  v46 = v73 - v44;
  if (v73 - v44 >= 0x12)
    v47 = 18;
  else
    v47 = v73 - v44;
  v48 = &v45[v47];
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *(_QWORD *)(v38 + 64) = v48;
  *(_QWORD *)(v38 + 72) = v49;
  v39 = *(unsigned int *)(v38 + 88);
  if (v39 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
LABEL_78:
    abort();
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (!v54)
  {
    v55 = 0;
    v56 = (uint64_t *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
    goto LABEL_74;
  }
  if (v54 >> 61)
LABEL_79:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v55 = (char *)operator new(8 * v54);
  v56 = (uint64_t *)&v55[8 * v51];
  v57 = &v55[8 * v54];
  *v56 = v38;
  v42 = (uint64_t)(v56 + 1);
  v58 = (char *)(v41 - v50);
  if (v41 != v50)
  {
LABEL_62:
    v59 = (unint64_t)(v58 - 8);
    if (v59 < 0x78
      || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v56
      && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
    {
      goto LABEL_83;
    }
    v60 = (v59 >> 3) + 1;
    v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
    v62 = &v41[-v61];
    v56 = (uint64_t *)((char *)v56 - v61);
    v63 = &v55[8 * v51 - 16];
    v64 = v41 - 16;
    v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v67 = *((_OWORD *)v64 - 1);
      v66 = *(_OWORD *)v64;
      *((_OWORD *)v64 - 1) = 0uLL;
      *(_OWORD *)v64 = 0uLL;
      *((_OWORD *)v63 - 1) = v67;
      *(_OWORD *)v63 = v66;
      v63 -= 32;
      v64 -= 32;
      v65 -= 4;
    }
    while (v65);
    v41 = v62;
    if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_83:
      do
      {
        v68 = *((_QWORD *)v41 - 1);
        v41 -= 8;
        *(_QWORD *)v41 = 0;
        *--v56 = v68;
      }
      while (v41 != v50);
    }
    v41 = (char *)a1[1];
    v69 = (char *)a1[2];
    a1[1] = v56;
    a1[2] = v42;
    a1[3] = v57;
    while (v69 != v41)
    {
      v71 = *((_QWORD *)v69 - 1);
      v69 -= 8;
      v70 = v71;
      *(_QWORD *)v69 = 0;
      if (v71)
        (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
    }
    goto LABEL_75;
  }
LABEL_74:
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
}

void mlir::tensor::DimOp::build(mlir::IndexType **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::IndexType *v6;
  mlir::MLIRContext *Context;
  mlir::MLIRContext *v8;
  unsigned int v9;
  uint64_t IndexType;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  mlir::IndexType *v17;
  unint64_t v18;
  unint64_t v19;
  void *__src;
  uint64_t v21;
  _QWORD v22[3];

  v22[2] = *MEMORY[0x24BDAC8D0];
  v15 = a4;
  v16 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v16, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v15, 1);
  __src = v22;
  v21 = 0x200000000;
  v6 = *a1;
  mlir::ValueRange::ValueRange(&v19, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v18, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if ((_DWORD)v21 != 1)
  {
    if (!(_DWORD)v21)
    {
      if (HIDWORD(v21))
      {
        v9 = 0;
LABEL_6:
        bzero((char *)__src + 8 * v9, 8 - 8 * v9);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v22, 1uLL, 8);
      v9 = v21;
      if ((_DWORD)v21 != 1)
        goto LABEL_6;
    }
LABEL_7:
    LODWORD(v21) = 1;
  }
  v17 = v6;
  IndexType = mlir::Builder::getIndexType(&v17, v8);
  *(_QWORD *)__src = IndexType;
  v11 = __src;
  v12 = v21;
  v13 = *(unsigned int *)(a2 + 72);
  v14 = v13 + v21;
  if (v14 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14, 8);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v12)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v13), v11, 8 * v12);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + v12;
  if (__src != v22)
    free(__src);
}

BOOL mlir::tensor::DimOp::getSpeculatability(mlir::tensor::DimOp *this)
{
  char v2;

  mlir::getConstantIntValue(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 56) | 4);
  if (!v2)
    return 0;
  if (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8)
                    + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    return (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) != 0;
  return 0;
}

unint64_t mlir::tensor::DimOp::fold(mlir::tensor **a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v4;
  uint64_t Int;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t DefiningOp;
  uint64_t v10;
  mlir::Operation *v11;
  uint64_t v12;
  uint64_t Value;
  uint64_t v14;
  void *v16;
  BOOL v17;
  mlir::IndexType *v18;
  uint64_t v19;
  mlir::Operation *v20;
  mlir::Operation *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  int64x2_t *v35;
  int64x2_t v36;
  int64x2_t v37;
  uint64_t v38;
  int64x2_t v39;
  uint64_t *v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  mlir::IndexType *Context;
  unsigned int v45;
  unint64_t v46;
  uint64_t v47;

  v2 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8);
  if (!v2)
    return 0;
  if (*(_UNKNOWN **)(*(_QWORD *)v2 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    v2 = 0;
  v47 = v2;
  if (!v2)
    return 0;
  v4 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)*a1 + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(_QWORD *)v4 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v4 = 0;
  v46 = v4;
  if (!v4)
    return 0;
  Int = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v47);
  if (Int < 0)
    return 0;
  v6 = Int;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v46);
  if (v6 >= v7)
    return 0;
  v8 = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v47);
  if (*(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v46) + 8 * v8) != 0x8000000000000000)
  {
    Context = (mlir::IndexType *)mlir::Attribute::getContext((mlir::tensor *)((char *)*a1 + 24));
    Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v46);
    v14 = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v47);
    return mlir::Builder::getIndexAttr(&Context, *(mlir::MLIRContext **)(Value + 8 * v14)) & 0xFFFFFFFFFFFFFFFBLL;
  }
  Context = *(mlir::IndexType **)(*((_QWORD *)*a1 + 9) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Context);
  v10 = DefiningOp;
  if (DefiningOp
    && *(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::GenerateOp,void>::id)
  {
    if (*(_DWORD *)(DefiningOp + 36))
      v23 = DefiningOp - 16;
    else
      v23 = 0;
    Context = (mlir::IndexType *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v23, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    if ((*(_BYTE *)(v10 + 46) & 0x80) != 0)
      v24 = *(_QWORD *)(v10 + 72);
    else
      v24 = 0;
    v25 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&Context);
    v27 = v26;
    v28 = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v47);
    if (v27 >= v28)
      v29 = v28;
    else
      v29 = v27;
    if (v29)
    {
      v30 = (v29 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v30 < 3)
      {
        v31 = 0;
        v32 = (uint64_t *)v25;
        goto LABEL_50;
      }
      v33 = v30 + 1;
      v34 = (v30 + 1) & 0x3FFFFFFFFFFFFFFCLL;
      v32 = (uint64_t *)(v25 + 8 * v34);
      v35 = (int64x2_t *)(v25 + 16);
      v36 = 0uLL;
      v37 = vdupq_n_s64(0x8000000000000000);
      v38 = v34;
      v39 = 0uLL;
      do
      {
        v36 = vsubq_s64(v36, vceqq_s64(v35[-1], v37));
        v39 = vsubq_s64(v39, vceqq_s64(*v35, v37));
        v35 += 2;
        v38 -= 4;
      }
      while (v38);
      v31 = vaddvq_s64(vaddq_s64(v39, v36));
      if (v33 != v34)
      {
LABEL_50:
        v40 = (uint64_t *)(v25 + 8 * v29);
        do
        {
          v41 = *v32++;
          if (v41 == 0x8000000000000000)
            ++v31;
        }
        while (v32 != v40);
      }
    }
    else
    {
      v31 = 0;
    }
    return *(_QWORD *)(v24 + 32 * v31 + 24) | 4;
  }
  mlir::IntegerAttr::getValue(&v47, (llvm::APInt *)&Context);
  if (v45 > 0x40)
  {
    v12 = *(_QWORD *)Context;
    MEMORY[0x20BD002D4]();
  }
  else
  {
    LODWORD(v12) = (_DWORD)Context;
  }
  if (v10)
  {
    v16 = *(void **)(*(_QWORD *)(v10 + 48) + 16);
    v17 = v16 == &mlir::detail::TypeIDResolver<mlir::tensor::ExtractSliceOp,void>::id;
    v18 = v16 == &mlir::detail::TypeIDResolver<mlir::tensor::ExtractSliceOp,void>::id ? (mlir::IndexType *)v10 : 0;
    Context = v18;
    if (v17)
    {
      v19 = *(_DWORD *)(v10 + 36) ? v10 - 16 : 0;
      v43 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v19, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v43);
      v21 = v20;
      v42 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)Context + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v42);
      if (v21 == v11
        && mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::ExtractSliceOp>::isDynamicSize((uint64_t)&Context, v12))
      {
        return mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::SubViewOp>::getDynamicSize((uint64_t)&Context, v12) | 4;
      }
    }
  }
  if (!mlir::tensor::foldTensorCast(*a1, v11))
    return 0;
  if (*((_DWORD *)*a1 + 9))
    v22 = (uint64_t)*a1 - 16;
  else
    v22 = 0;
  return mlir::detail::OpResultImpl::getNextResultAtOffset(v22, 0) | 4;
}

BOOL mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::ExtractSliceOp>::isDynamicSize(uint64_t a1, unsigned int a2)
{
  unint64_t v2;
  uint64_t v4;

  v2 = *(_QWORD *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)a1 + 44)))
    v2 = 0;
  v4 = *(_QWORD *)(v2 + 8);
  return *(_QWORD *)(mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v4)
                   + 8 * a2) == 0x8000000000000000;
}

void mlir::tensor::DimOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  const char *v45;
  unint64_t v46;
  uint64_t v47;
  const char *v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  const char *v72;
  unint64_t v73;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v72, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"tensor.dim", 10, (__int16)v72, a2, 0, 0);
  *(_QWORD *)v4 = &off_24C028560;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v72 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::DimOfCastOp]";
  v73 = 84;
  v9 = llvm::StringRef::find((uint64_t *)&v72, "DesiredTypeName = ", 0x12uLL, 0);
  if (v73 >= v9)
    v10 = v9;
  else
    v10 = v73;
  v11 = &v72[v10];
  v12 = v73 - v10;
  if (v73 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v73 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_78;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_79;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_82;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_82:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v72, 1);
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"tensor.dim", 10, (__int16)v72, a2, 0, 0);
  *(_QWORD *)v38 = &off_24C028960;
  if (*(_QWORD *)(v38 + 72))
  {
    v39 = *(unsigned int *)(v38 + 88);
    if (v39 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v39, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  v72 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::DimOfDestStyleOp]";
  v73 = 89;
  v43 = llvm::StringRef::find((uint64_t *)&v72, "DesiredTypeName = ", 0x12uLL, 0);
  if (v73 >= v43)
    v44 = v43;
  else
    v44 = v73;
  v45 = &v72[v44];
  v46 = v73 - v44;
  if (v73 - v44 >= 0x12)
    v47 = 18;
  else
    v47 = v73 - v44;
  v48 = &v45[v47];
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *(_QWORD *)(v38 + 64) = v48;
  *(_QWORD *)(v38 + 72) = v49;
  v39 = *(unsigned int *)(v38 + 88);
  if (v39 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
LABEL_78:
    abort();
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (!v54)
  {
    v55 = 0;
    v56 = (uint64_t *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
    goto LABEL_74;
  }
  if (v54 >> 61)
LABEL_79:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v55 = (char *)operator new(8 * v54);
  v56 = (uint64_t *)&v55[8 * v51];
  v57 = &v55[8 * v54];
  *v56 = v38;
  v42 = (uint64_t)(v56 + 1);
  v58 = (char *)(v41 - v50);
  if (v41 != v50)
  {
LABEL_62:
    v59 = (unint64_t)(v58 - 8);
    if (v59 < 0x78
      || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v56
      && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
    {
      goto LABEL_83;
    }
    v60 = (v59 >> 3) + 1;
    v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
    v62 = &v41[-v61];
    v56 = (uint64_t *)((char *)v56 - v61);
    v63 = &v55[8 * v51 - 16];
    v64 = v41 - 16;
    v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v67 = *((_OWORD *)v64 - 1);
      v66 = *(_OWORD *)v64;
      *((_OWORD *)v64 - 1) = 0uLL;
      *(_OWORD *)v64 = 0uLL;
      *((_OWORD *)v63 - 1) = v67;
      *(_OWORD *)v63 = v66;
      v63 -= 32;
      v64 -= 32;
      v65 -= 4;
    }
    while (v65);
    v41 = v62;
    if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_83:
      do
      {
        v68 = *((_QWORD *)v41 - 1);
        v41 -= 8;
        *(_QWORD *)v41 = 0;
        *--v56 = v68;
      }
      while (v41 != v50);
    }
    v41 = (char *)a1[1];
    v69 = (char *)a1[2];
    a1[1] = v56;
    a1[2] = v42;
    a1[3] = v57;
    while (v69 != v41)
    {
      v71 = *((_QWORD *)v69 - 1);
      v69 -= 8;
      v70 = v71;
      *(_QWORD *)v69 = 0;
      if (v71)
        (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
    }
    goto LABEL_75;
  }
LABEL_74:
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
}

void mlir::tensor::EmptyOp::build(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15[2];
  void *v16;
  uint64_t v17;
  _BYTE v18[48];
  void *v19;
  uint64_t v20;
  _QWORD v21[7];

  v21[6] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x600000000;
  v16 = v18;
  v17 = 0x600000000;
  mlir::dispatchIndexOpFoldResults(a3, a4, (uint64_t)&v16, (uint64_t)&v19);
  v9 = v19;
  v10 = v20;
  mlir::ValueRange::ValueRange(v15, (uint64_t)v16, v17);
  v11 = v15[0];
  v12 = v15[1];
  v13 = mlir::RankedTensorType::get((uint64_t)v9, v10, a5, a6);
  mlir::OperationState::addOperands(a2, v11, v12);
  v14 = *(unsigned int *)(a2 + 72);
  if (v14 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14 + 1, 8);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v14) = v13;
  ++*(_DWORD *)(a2 + 72);
  if (v16 != v18)
    free(v16);
  if (v19 != v21)
    free(v19);
}

uint64_t mlir::tensor::EmptyOp::verify(uint64_t **this)
{
  uint64_t v2;
  uint64_t Value;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  int64x2_t *v10;
  int64x2_t v11;
  int64x2_t v12;
  uint64_t v13;
  int64x2_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  char *v24;
  char *v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  int64x2_t *v35;
  int64x2_t v36;
  int64x2_t v37;
  uint64_t v38;
  int64x2_t v39;
  uint64_t v40;
  int *v41;
  char *v42;
  char *v43;
  __int128 v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  BOOL v57;
  int64_t v58;
  int64_t v59;
  int64_t v60;
  unint64_t v61;
  const void **v62;
  __int16 v63;
  int v64;
  const char *v65;
  uint64_t v66;
  _QWORD v67[3];
  void *v68;
  unsigned int v69;
  unsigned int v70;
  _BYTE v71[96];
  void *v72;
  _QWORD *v73;
  void *__p;
  _QWORD *v75;
  char v76;
  uint64_t v77;

  v77 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  v67[0] = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v67);
  if (!v4)
  {
    v6 = 0;
    goto LABEL_14;
  }
  v5 = (v4 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v5 >= 3)
  {
    v8 = v5 + 1;
    v9 = (v5 + 1) & 0x3FFFFFFFFFFFFFFCLL;
    v7 = (uint64_t *)(Value + 8 * v9);
    v10 = (int64x2_t *)(Value + 16);
    v11 = 0uLL;
    v12 = vdupq_n_s64(0x8000000000000000);
    v13 = v9;
    v14 = 0uLL;
    do
    {
      v11 = vsubq_s64(v11, vceqq_s64(v10[-1], v12));
      v14 = vsubq_s64(v14, vceqq_s64(*v10, v12));
      v10 += 2;
      v13 -= 4;
    }
    while (v13);
    v6 = vaddvq_s64(vaddq_s64(v14, v11));
    if (v8 == v9)
      goto LABEL_14;
  }
  else
  {
    v6 = 0;
    v7 = (uint64_t *)Value;
  }
  do
  {
    v15 = *v7++;
    if (v15 == 0x8000000000000000)
      ++v6;
  }
  while (v7 != (uint64_t *)(Value + 8 * v4));
LABEL_14:
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    if (v6 == *((_DWORD *)*this + 17))
      return 1;
  }
  else if (!v6)
  {
    return 1;
  }
  v62 = (const void **)"incorrect number of dynamic sizes, has ";
  v63 = 259;
  mlir::OpState::emitOpError(this, &v62, (uint64_t)v67);
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    v17 = (const char *)*((unsigned int *)*this + 17);
    if (!v67[0])
      goto LABEL_24;
  }
  else
  {
    v17 = 0;
    if (!v67[0])
      goto LABEL_24;
  }
  v64 = 5;
  v65 = v17;
  v18 = &v64;
  v19 = (char *)v68;
  if (v69 >= v70)
  {
    v54 = v69 + 1;
    if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
    {
      v58 = (char *)&v64 - (_BYTE *)v68;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v54, 24);
      v19 = (char *)v68;
      v18 = (int *)((char *)v68 + v58);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v54, 24);
      v18 = &v64;
      v19 = (char *)v68;
    }
  }
  v20 = &v19[24 * v69];
  v21 = *(_OWORD *)v18;
  *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
  *(_OWORD *)v20 = v21;
  v22 = ++v69;
  if (v67[0])
  {
    v64 = 3;
    v65 = ", expected ";
    v66 = 11;
    v23 = &v64;
    v24 = (char *)v68;
    if (v22 >= v70)
    {
      v56 = v22 + 1;
      v57 = (char *)v68 + 24 * v22 > (char *)&v64;
      if (v68 <= &v64 && v57)
      {
        v60 = (char *)&v64 - (_BYTE *)v68;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v56, 24);
        v24 = (char *)v68;
        v23 = (int *)((char *)v68 + v60);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v56, 24);
        v23 = &v64;
        v24 = (char *)v68;
      }
    }
    v25 = &v24[24 * v69];
    v26 = *(_OWORD *)v23;
    *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
    *(_OWORD *)v25 = v26;
    ++v69;
  }
LABEL_24:
  if (*((_DWORD *)*this + 9))
    v27 = (uint64_t)(*this - 2);
  else
    v27 = 0;
  v61 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  v28 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v61);
  if (v29)
  {
    v30 = (v29 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v30 < 3)
    {
      v31 = 0;
      v32 = (uint64_t *)v28;
      goto LABEL_34;
    }
    v33 = v30 + 1;
    v34 = (v30 + 1) & 0x3FFFFFFFFFFFFFFCLL;
    v32 = (uint64_t *)(v28 + 8 * v34);
    v35 = (int64x2_t *)(v28 + 16);
    v36 = 0uLL;
    v37 = vdupq_n_s64(0x8000000000000000);
    v38 = v34;
    v39 = 0uLL;
    do
    {
      v36 = vsubq_s64(v36, vceqq_s64(v35[-1], v37));
      v39 = vsubq_s64(v39, vceqq_s64(*v35, v37));
      v35 += 2;
      v38 -= 4;
    }
    while (v38);
    v31 = vaddvq_s64(vaddq_s64(v39, v36));
    if (v33 != v34)
    {
      do
      {
LABEL_34:
        v40 = *v32++;
        if (v40 == 0x8000000000000000)
          ++v31;
      }
      while (v32 != (uint64_t *)(v28 + 8 * v29));
    }
  }
  else
  {
    v31 = 0;
  }
  if (v67[0])
  {
    v64 = 2;
    v65 = (const char *)v31;
    v41 = &v64;
    v42 = (char *)v68;
    if (v69 >= v70)
    {
      v55 = v69 + 1;
      if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
      {
        v59 = (char *)&v64 - (_BYTE *)v68;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v55, 24);
        v42 = (char *)v68;
        v41 = (int *)((char *)v68 + v59);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v55, 24);
        v41 = &v64;
        v42 = (char *)v68;
      }
    }
    v43 = &v42[24 * v69];
    v44 = *(_OWORD *)v41;
    *((_QWORD *)v43 + 2) = *((_QWORD *)v41 + 2);
    *(_OWORD *)v43 = v44;
    ++v69;
  }
  v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v67);
  if (v67[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
  if (v76)
  {
    v45 = __p;
    if (__p)
    {
      v46 = v75;
      v47 = __p;
      if (v75 != __p)
      {
        do
          v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
        while (v46 != v45);
        v47 = __p;
      }
      v75 = v45;
      operator delete(v47);
    }
    v48 = v72;
    if (v72)
    {
      v49 = v73;
      v50 = v72;
      if (v73 != v72)
      {
        do
        {
          v52 = *--v49;
          v51 = v52;
          *v49 = 0;
          if (v52)
            MEMORY[0x20BD002D4](v51, 0x1000C8077774924);
        }
        while (v49 != v48);
        v50 = v72;
      }
      v73 = v48;
      operator delete(v50);
    }
    if (v68 != v71)
      free(v68);
  }
  return v16;
}

uint64_t mlir::tensor::EmptyOp::reifyResultShapes(uint64_t a1, mlir::IndexType **a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  char *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t Value;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v28;
  void *v29;
  uint64_t v30;
  _QWORD v31[7];

  v31[6] = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v6 = *(_QWORD *)a1 - 16;
  else
    v6 = 0;
  v28 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v28);
  v29 = v31;
  v30 = 0x600000000;
  if (v7)
  {
    v8 = v7;
    if (v7 < 7)
    {
      v9 = 0;
      v10 = v7;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v29, v31, v7, 8);
      v9 = v30;
      v10 = v8 - v30;
      if (v8 == v30)
        goto LABEL_10;
    }
    bzero((char *)v29 + 8 * v9, 8 * v10);
LABEL_10:
    LODWORD(v30) = v8;
  }
  v11 = *(unsigned int *)(a3 + 8);
  if (!(_DWORD)v11)
  {
    llvm::SmallVectorImpl<llvm::SmallVector<mlir::OpFoldResult,6u>>::append(a3, 1 - v11, (unint64_t)&v29);
LABEL_18:
    v15 = v29;
    if (v29 == v31)
      goto LABEL_20;
    goto LABEL_19;
  }
  if ((_DWORD)v11 == 1)
    goto LABEL_18;
  v12 = *(_QWORD **)a3;
  v13 = v11 << 6;
  do
  {
    v14 = *(char **)((char *)v12 + v13 - 64);
    if ((char *)v12 + v13 - 48 != v14)
      free(v14);
    v13 -= 64;
  }
  while (v13 != 64);
  *(_DWORD *)(a3 + 8) = 1;
  v15 = v29;
  if (v29 != v31)
LABEL_19:
    free(v15);
LABEL_20:
  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v16 = *(_QWORD *)a1 - 16;
  else
    v16 = 0;
  v29 = (void *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v29);
  if (v17 >= 1)
  {
    v18 = 0;
    v19 = 0;
    do
    {
      if (*(_DWORD *)(*(_QWORD *)a1 + 36))
        v25 = *(_QWORD *)a1 - 16;
      else
        v25 = 0;
      v29 = (void *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v25, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (*(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v29) + 8 * v19) == 0x8000000000000000)
      {
        v26 = v18++;
        v22 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 32 * v26 + 24) | 4;
      }
      else
      {
        if (*(_DWORD *)(*(_QWORD *)a1 + 36))
          v20 = *(_QWORD *)a1 - 16;
        else
          v20 = 0;
        v29 = (void *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v20, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
        Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v29);
        v22 = mlir::Builder::getIndexAttr(a2, *(mlir::MLIRContext **)(Value + 8 * v19)) & 0xFFFFFFFFFFFFFFFBLL;
      }
      *(_QWORD *)(**(_QWORD **)a3 + 8 * v19++) = v22;
      if (*(_DWORD *)(*(_QWORD *)a1 + 36))
        v23 = *(_QWORD *)a1 - 16;
      else
        v23 = 0;
      v29 = (void *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v23, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v29);
    }
    while (v19 < v24);
  }
  return 1;
}

uint64_t mlir::tensor::EmptyOp::getMixedSizes@<X0>(mlir::tensor::EmptyOp *this@<X0>, uint64_t a2@<X8>)
{
  void *v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t Value;
  uint64_t IndexAttr;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  mlir::IndexType *v20[4];

  v4 = (void *)(a2 + 16);
  *(_QWORD *)a2 = a2 + 16;
  *(_QWORD *)(a2 + 8) = 0x600000000;
  v20[0] = (mlir::IndexType *)mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)this + 24));
  memset(&v20[1], 0, 24);
  if (*(_DWORD *)(*(_QWORD *)this + 36))
    v5 = *(_QWORD *)this - 16;
  else
    v5 = 0;
  v19 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  result = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v19);
  if (v7 >= 1)
  {
    v8 = 0;
    v9 = 0;
    do
    {
      if (*(_DWORD *)(*(_QWORD *)this + 36))
        v17 = *(_QWORD *)this - 16;
      else
        v17 = 0;
      v19 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v17, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
      if (*(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v19) + 8 * v9) == 0x8000000000000000)
      {
        v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 32 * v8 + 24);
        v13 = *(unsigned int *)(a2 + 8);
        if (v13 >= *(unsigned int *)(a2 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a2, v4, v13 + 1, 8);
          v13 = *(unsigned int *)(a2 + 8);
        }
        ++v8;
        v14 = v18 | 4;
      }
      else
      {
        if (*(_DWORD *)(*(_QWORD *)this + 36))
          v10 = *(_QWORD *)this - 16;
        else
          v10 = 0;
        v19 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
        Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v19);
        IndexAttr = mlir::Builder::getIndexAttr(v20, *(mlir::MLIRContext **)(Value + 8 * v9));
        v13 = *(unsigned int *)(a2 + 8);
        if (v13 >= *(unsigned int *)(a2 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a2, v4, v13 + 1, 8);
          v13 = *(unsigned int *)(a2 + 8);
        }
        v14 = IndexAttr & 0xFFFFFFFFFFFFFFFBLL;
      }
      *(_QWORD *)(*(_QWORD *)a2 + 8 * v13) = v14;
      ++*(_DWORD *)(a2 + 8);
      ++v9;
      if (*(_DWORD *)(*(_QWORD *)this + 36))
        v15 = *(_QWORD *)this - 16;
      else
        v15 = 0;
      v19 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v15, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
      result = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v19);
    }
    while (v9 < v16);
  }
  return result;
}

void mlir::tensor::EmptyOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  const char *v45;
  unint64_t v46;
  uint64_t v47;
  const char *v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  const char *v82;
  unint64_t v83;
  char *v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  uint64_t *v90;
  char *v91;
  char *v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  const char *v106;
  unint64_t v107;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v106, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"tensor.cast", 11, (__int16)v106, a2, 0, 0);
  *(_QWORD *)v4 = &off_24C02A8E8;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v106 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldEmptyTensorWithCastOp]";
  v107 = 98;
  v9 = llvm::StringRef::find((uint64_t *)&v106, "DesiredTypeName = ", 0x12uLL, 0);
  if (v107 >= v9)
    v10 = v9;
  else
    v10 = v107;
  v11 = &v106[v10];
  v12 = v107 - v10;
  if (v107 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v107 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_116;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_117;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_120;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_120:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v106, 1);
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"tensor.dim", 10, (__int16)v106, a2, 0, 0);
  *(_QWORD *)v38 = &off_24C02A7B8;
  if (*(_QWORD *)(v38 + 72))
  {
    v39 = *(unsigned int *)(v38 + 88);
    if (v39 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v39, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  v106 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldEmptyTensorWithDimOp]";
  v107 = 97;
  v43 = llvm::StringRef::find((uint64_t *)&v106, "DesiredTypeName = ", 0x12uLL, 0);
  if (v107 >= v43)
    v44 = v43;
  else
    v44 = v107;
  v45 = &v106[v44];
  v46 = v107 - v44;
  if (v107 - v44 >= 0x12)
    v47 = 18;
  else
    v47 = v107 - v44;
  v48 = &v45[v47];
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *(_QWORD *)(v38 + 64) = v48;
  *(_QWORD *)(v38 + 72) = v49;
  v39 = *(unsigned int *)(v38 + 88);
  if (v39 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
    goto LABEL_116;
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (v54)
  {
    if (v54 >> 61)
      goto LABEL_117;
    v55 = (char *)operator new(8 * v54);
    v56 = (uint64_t *)&v55[8 * v51];
    v57 = &v55[8 * v54];
    *v56 = v38;
    v42 = (uint64_t)(v56 + 1);
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
  }
  else
  {
    v55 = 0;
    v56 = (uint64_t *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
    {
LABEL_62:
      v59 = (unint64_t)(v58 - 8);
      if (v59 < 0x78
        || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v56
        && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
      {
        goto LABEL_121;
      }
      v60 = (v59 >> 3) + 1;
      v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      v62 = &v41[-v61];
      v56 = (uint64_t *)((char *)v56 - v61);
      v63 = &v55[8 * v51 - 16];
      v64 = v41 - 16;
      v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v67 = *((_OWORD *)v64 - 1);
        v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      v41 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_121:
        do
        {
          v68 = *((_QWORD *)v41 - 1);
          v41 -= 8;
          *(_QWORD *)v41 = 0;
          *--v56 = v68;
        }
        while (v41 != v50);
      }
      v41 = (char *)a1[1];
      v69 = (char *)a1[2];
      a1[1] = v56;
      a1[2] = v42;
      a1[3] = v57;
      while (v69 != v41)
      {
        v71 = *((_QWORD *)v69 - 1);
        v69 -= 8;
        v70 = v71;
        *(_QWORD *)v69 = 0;
        if (v71)
          (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
      }
      goto LABEL_75;
    }
  }
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
  v72 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v106, 1);
  mlir::Pattern::Pattern(v72 + 8, (uint64_t)"tensor.empty", 12, (__int16)v106, a2, 0, 0);
  *(_QWORD *)v72 = &off_24C02B068;
  if (*(_QWORD *)(v72 + 72))
  {
    v73 = *(unsigned int *)(v72 + 88);
    if (v73 <= *(_DWORD *)(v72 + 92))
      goto LABEL_79;
LABEL_90:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v72 + 80, (void *)(v72 + 96), v73, 16);
    *(_DWORD *)(v72 + 88) = *(_DWORD *)(v72 + 88);
    v75 = (char *)a1[2];
    v74 = a1[3];
    if ((unint64_t)v75 < v74)
      goto LABEL_80;
    goto LABEL_91;
  }
  v106 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims]";
  v107 = 106;
  v77 = llvm::StringRef::find((uint64_t *)&v106, "DesiredTypeName = ", 0x12uLL, 0);
  if (v107 >= v77)
    v78 = v77;
  else
    v78 = v107;
  v79 = &v106[v78];
  v80 = v107 - v78;
  if (v107 - v78 >= 0x12)
    v81 = 18;
  else
    v81 = v107 - v78;
  v82 = &v79[v81];
  v83 = v80 - v81;
  if (v83 >= v83 - 1)
    --v83;
  *(_QWORD *)(v72 + 64) = v82;
  *(_QWORD *)(v72 + 72) = v83;
  v73 = *(unsigned int *)(v72 + 88);
  if (v73 > *(_DWORD *)(v72 + 92))
    goto LABEL_90;
LABEL_79:
  *(_DWORD *)(v72 + 88) = v73;
  v75 = (char *)a1[2];
  v74 = a1[3];
  if ((unint64_t)v75 < v74)
  {
LABEL_80:
    *(_QWORD *)v75 = v72;
    v76 = (uint64_t)(v75 + 8);
    goto LABEL_115;
  }
LABEL_91:
  v84 = (char *)a1[1];
  v85 = (v75 - v84) >> 3;
  v86 = v85 + 1;
  if ((unint64_t)(v85 + 1) >> 61)
LABEL_116:
    abort();
  v87 = v74 - (_QWORD)v84;
  if (v87 >> 2 > v86)
    v86 = v87 >> 2;
  if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
    v88 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v88 = v86;
  if (!v88)
  {
    v89 = 0;
    v90 = (uint64_t *)(8 * v85);
    v91 = 0;
    *(_QWORD *)(8 * v85) = v72;
    v76 = 8 * v85 + 8;
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
      goto LABEL_100;
    goto LABEL_112;
  }
  if (v88 >> 61)
LABEL_117:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v89 = (char *)operator new(8 * v88);
  v90 = (uint64_t *)&v89[8 * v85];
  v91 = &v89[8 * v88];
  *v90 = v72;
  v76 = (uint64_t)(v90 + 1);
  v92 = (char *)(v75 - v84);
  if (v75 != v84)
  {
LABEL_100:
    v93 = (unint64_t)(v92 - 8);
    if (v93 < 0x78
      || &v75[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v90
      && &v89[v75 - v84 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v75)
    {
      goto LABEL_122;
    }
    v94 = (v93 >> 3) + 1;
    v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
    v96 = &v75[-v95];
    v90 = (uint64_t *)((char *)v90 - v95);
    v97 = &v89[8 * v85 - 16];
    v98 = v75 - 16;
    v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v101 = *((_OWORD *)v98 - 1);
      v100 = *(_OWORD *)v98;
      *((_OWORD *)v98 - 1) = 0uLL;
      *(_OWORD *)v98 = 0uLL;
      *((_OWORD *)v97 - 1) = v101;
      *(_OWORD *)v97 = v100;
      v97 -= 32;
      v98 -= 32;
      v99 -= 4;
    }
    while (v99);
    v75 = v96;
    if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_122:
      do
      {
        v102 = *((_QWORD *)v75 - 1);
        v75 -= 8;
        *(_QWORD *)v75 = 0;
        *--v90 = v102;
      }
      while (v75 != v84);
    }
    v75 = (char *)a1[1];
    v103 = (char *)a1[2];
    a1[1] = v90;
    a1[2] = v76;
    a1[3] = v91;
    while (v103 != v75)
    {
      v105 = *((_QWORD *)v103 - 1);
      v103 -= 8;
      v104 = v105;
      *(_QWORD *)v103 = 0;
      if (v105)
        (*(void (**)(uint64_t))(*(_QWORD *)v104 + 8))(v104);
    }
    goto LABEL_113;
  }
LABEL_112:
  a1[1] = v90;
  a1[2] = v76;
  a1[3] = v91;
LABEL_113:
  if (v75)
    operator delete(v75);
LABEL_115:
  a1[2] = v76;
}

uint64_t mlir::tensor::ExtractOp::getAsmResultNames(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v4;
  uint64_t NextResultAtOffset;

  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v4 = *(_QWORD *)a1 - 16;
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return a2(a3, NextResultAtOffset, "extracted", 9);
}

uint64_t mlir::tensor::ExtractOp::verify(uint64_t **this)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const void **v13;
  __int16 v14;
  unint64_t v15;
  _QWORD v16[3];
  void *v17;
  uint64_t v18;
  void *v19;
  _QWORD *v20;
  void *__p;
  _QWORD *v22;
  char v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v15 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v15);
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    if (v2 == *((unsigned int *)*this + 17) - 1)
      return 1;
  }
  else if (v2 == -1)
  {
    return 1;
  }
  v13 = (const void **)"incorrect number of indices for extract_element";
  v14 = 259;
  mlir::OpState::emitOpError(this, &v13, (uint64_t)v16);
  v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v16);
  if (v16[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v16);
  if (v23)
  {
    v4 = __p;
    if (__p)
    {
      v5 = v22;
      v6 = __p;
      if (v22 != __p)
      {
        do
          v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
        while (v5 != v4);
        v6 = __p;
      }
      v22 = v4;
      operator delete(v6);
    }
    v7 = v19;
    if (v19)
    {
      v8 = v20;
      v9 = v19;
      if (v20 != v19)
      {
        do
        {
          v11 = *--v8;
          v10 = v11;
          *v8 = 0;
          if (v11)
            MEMORY[0x20BD002D4](v10, 0x1000C8077774924);
        }
        while (v8 != v7);
        v9 = v19;
      }
      v20 = v7;
      operator delete(v9);
    }
    if (v17 != &v18)
      free(v17);
  }
  return v3;
}

unint64_t mlir::tensor::ExtractOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  void *v6;
  int isSplat;
  uint64_t v8;
  uint64_t v9;
  uint64_t NumElements;
  _QWORD *v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t Int;
  uint64_t v15;
  uint64_t DefiningOp;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t FlattenedIndex;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  _QWORD *v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD v48[2];
  void *v49[2];
  _QWORD v50[10];

  v50[9] = *MEMORY[0x24BDAC8D0];
  v4 = *(uint64_t **)(a2 + 40);
  v5 = *v4;
  if (*v4)
  {
    if (mlir::DenseElementsAttr::classof(*v4))
      v6 = (void *)v5;
    else
      v6 = 0;
    v49[0] = v6;
    if (v6)
    {
      isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)v49);
      v8 = isSplat ? v5 : 0;
      v47 = v8;
      if ((isSplat & 1) != 0)
      {
        mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v47);
        ZinMirCacheTensors::ZinMirCacheTensors(v49, v47, 0);
        v9 = v47;
        NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v47);
        ZinMirCacheTensors::ZinMirCacheTensors(&v39, v9, NumElements);
        return mlir::DenseElementsAttr::AttributeElementIterator::operator*(v49) & 0xFFFFFFFFFFFFFFFBLL;
      }
    }
    v4 = *(uint64_t **)(a2 + 40);
  }
  v49[0] = v50;
  v49[1] = (void *)0x800000000;
  if (8 * *(_QWORD *)(a2 + 48) != 8)
  {
    v12 = (unint64_t *)(v4 + 1);
    v13 = 8 * ((8 * *(_QWORD *)(a2 + 48) - 8) >> 3);
    while (*v12 && *(_UNKNOWN **)(*(_QWORD *)*v12 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      v39 = *v12;
      Int = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v39);
      v15 = LODWORD(v49[1]);
      if (LODWORD(v49[1]) >= (unint64_t)HIDWORD(v49[1]))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v49, v50, LODWORD(v49[1]) + 1, 8);
        v15 = LODWORD(v49[1]);
      }
      *((_QWORD *)v49[0] + v15) = Int;
      ++LODWORD(v49[1]);
      ++v12;
      v13 -= 8;
      if (!v13)
        goto LABEL_19;
    }
    goto LABEL_40;
  }
LABEL_19:
  v39 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v39);
  if (DefiningOp)
  {
    v17 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
    v18 = v17 == &mlir::detail::TypeIDResolver<mlir::tensor::FromElementsOp,void>::id ? DefiningOp : 0;
    if (v17 == &mlir::detail::TypeIDResolver<mlir::tensor::FromElementsOp,void>::id)
    {
      v39 = *(_QWORD *)(DefiningOp - 8) & 0xFFFFFFFFFFFFFFF8;
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
      v21 = 0;
      v22 = v20 - 1;
      if ((((_DWORD)v20 - 1) & 0x80000000) == 0)
      {
        v23 = (v20 - 1);
        v24 = 1;
        do
        {
          if (v22 > v23)
            v24 *= *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39) + 8 * v23);
          v21 += v24 * *((_QWORD *)v49[0] + v23);
        }
        while (v23-- > 0);
      }
      if ((*(_BYTE *)(v18 + 46) & 0x80) != 0)
      {
        v11 = 0;
        if ((v21 & 0x80000000) == 0 && (signed int)v21 < *(_DWORD *)(v18 + 68))
          v11 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v18 + 72) + 32 * v21 + 24) | 4);
        goto LABEL_41;
      }
      goto LABEL_40;
    }
  }
  v11 = **(_QWORD ***)(a2 + 40);
  if (!v11)
    goto LABEL_41;
  if (mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v11 + 8))
  {
    v19 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v11 + 8);
    v45 = v11;
    v46 = v19;
    if (mlir::ElementsAttr::isValidIndex((uint64_t)v11, v19, (_QWORD *)v49[0], LODWORD(v49[1])))
    {
      mlir::ElementsAttr::getValues<mlir::Attribute>((uint64_t *)&v45, (uint64_t)&v39);
      FlattenedIndex = mlir::ElementsAttr::getFlattenedIndex(v44, (uint64_t)v49[0]);
      v27 = FlattenedIndex;
      LOWORD(v47) = v39;
      v28 = BYTE1(v39);
      if ((_BYTE)v39)
      {
        v29 = v40;
        v48[0] = v40;
        v30 = v41 + FlattenedIndex;
      }
      else
      {
        (*(void (**)(_QWORD *__return_ptr))(*(_QWORD *)v40 + 16))(v48);
        v28 = BYTE1(v47);
        v30 = v41 + v27;
        v48[1] = v41 + v27;
        if (!(_BYTE)v47)
        {
          v36 = v48[0];
          v48[0] = 0;
          if (BYTE1(v47))
            v37 = 0;
          else
            v37 = v41 + v27;
          v33 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v36 + 24))(v36, v37);
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
          if (!(_BYTE)v47)
          {
            v38 = v48[0];
            v48[0] = 0;
            if (v38)
              (*(void (**)(uint64_t))(*(_QWORD *)v38 + 8))(v38);
          }
          goto LABEL_50;
        }
        v29 = v48[0];
      }
      if (v28)
        v32 = 0;
      else
        v32 = v30;
      v33 = *(_QWORD *)(v29 + 8 * v32);
LABEL_50:
      if (!v42)
      {
        v34 = v43;
        v43 = 0;
        if (v34)
          (*(void (**)(uint64_t))(*(_QWORD *)v34 + 8))(v34);
      }
      v11 = (_QWORD *)(v33 & 0xFFFFFFFFFFFFFFFBLL);
      if (!(_BYTE)v39)
      {
        v35 = v40;
        v40 = 0;
        if (v35)
          (*(void (**)(uint64_t))(*(_QWORD *)v35 + 8))(v35);
      }
      goto LABEL_41;
    }
  }
  else
  {
    v45 = 0;
    v46 = 0;
  }
LABEL_40:
  v11 = 0;
LABEL_41:
  if (v49[0] != v50)
    free(v49[0]);
  return (unint64_t)v11;
}

void mlir::tensor::ExtractOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  unint64_t v39;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v38, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"tensor.extract", 14, (__int16)v38, a2, 0, 0);
  *(_QWORD *)v4 = &off_24C029E68;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v38 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::ExtractFromTensorCast]";
  v39 = 94;
  v9 = llvm::StringRef::find((uint64_t *)&v38, "DesiredTypeName = ", 0x12uLL, 0);
  if (v39 >= v9)
    v10 = v9;
  else
    v10 = v39;
  v11 = &v38[v10];
  v12 = v39 - v10;
  if (v39 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v39 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    abort();
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_44;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_44:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
}

uint64_t mlir::tensor::FromElementsOp::getAsmResultNames(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v4;
  uint64_t NextResultAtOffset;

  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v4 = *(_QWORD *)a1 - 16;
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return a2(a3, NextResultAtOffset, "from_elements", 13);
}

unint64_t mlir::tensor::FromElementsOp::fold(_QWORD *a1, uint64_t a2)
{
  unint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;

  v3 = *(unsigned int *)(a2 + 48);
  v4 = *(uint64_t **)(a2 + 40);
  if (*(_DWORD *)(a2 + 48))
  {
    v5 = 8 * v3;
    v6 = *(uint64_t **)(a2 + 40);
    while (*v6)
    {
      ++v6;
      v5 -= 8;
      if (!v5)
      {
        v6 = &v4[v3];
        break;
      }
    }
    if (v3 != v6 - v4)
      return 0;
  }
  v7 = (_QWORD *)(*(_QWORD *)(*a1 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v7)
    return mlir::DenseElementsAttr::get(0, 0, v4, v3) & 0xFFFFFFFFFFFFFFFBLL;
  v8 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v7 + 8);
  return mlir::DenseElementsAttr::get((uint64_t)v7, v8, *(uint64_t **)(a2 + 40), *(unsigned int *)(a2 + 48)) & 0xFFFFFFFFFFFFFFFBLL;
}

void mlir::tensor::FromElementsOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  unint64_t v39;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v38, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"tensor.extract", 14, (__int16)v38, a2, 0, 0);
  *(_QWORD *)v4 = &off_24C02AD50;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v38 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::ExtractElementFromIndexCast]";
  v39 = 100;
  v9 = llvm::StringRef::find((uint64_t *)&v38, "DesiredTypeName = ", 0x12uLL, 0);
  if (v39 >= v9)
    v10 = v9;
  else
    v10 = v39;
  v11 = &v38[v10];
  v12 = v39 - v10;
  if (v39 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v39 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    abort();
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_44;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_44:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
}

uint64_t mlir::tensor::GatherOp::getAsmResultNames(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v4;
  uint64_t NextResultAtOffset;

  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v4 = *(_QWORD *)a1 - 16;
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return a2(a3, NextResultAtOffset, "gather", 6);
}

uint64_t mlir::tensor::GatherOp::inferResultType(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, char a5)
{
  uint64_t v8;
  const void *Value;
  uint64_t v10;
  size_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t i;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t *v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t j;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t *v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t Values;
  void *v42;
  uint64_t v43;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  _BYTE v52[48];
  uint64_t RHS;
  uint64_t v54;
  void *v55;
  uint64_t v56;
  _QWORD v57[7];

  v57[6] = *MEMORY[0x24BDAC8D0];
  v45 = a2;
  v46 = a1;
  Value = (const void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v45);
  v10 = v8 - 1;
  v55 = v57;
  v56 = 0x600000000;
  v11 = 8 * (v8 - 1);
  if (v11 < 0x31)
  {
    v12 = 0;
    if (v8 == 1)
      goto LABEL_6;
    goto LABEL_5;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v57, (8 * v10) >> 3, 8);
  v12 = v56;
  if (v10)
  {
LABEL_5:
    memcpy((char *)v55 + 8 * v12, Value, v11);
    v12 = v56;
  }
LABEL_6:
  v13 = v12 + (v11 >> 3);
  LODWORD(v56) = v13;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v46);
  if (v14 + v13 > (unint64_t)HIDWORD(v56))
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v57, v14 + v13, 8);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v46);
  if (v15)
  {
    v16 = v15;
    if (a4)
    {
      v17 = &a3[a4];
      v18 = (8 * a4) >> 3;
      if ((a5 & 1) != 0)
      {
        for (i = 0; i != v16; ++i)
        {
          v22 = a3;
          v23 = v18;
          do
          {
            v24 = v23 >> 1;
            v25 = &v22[v23 >> 1];
            v27 = *v25;
            v26 = v25 + 1;
            v23 += ~(v23 >> 1);
            if (v27 < i)
              v22 = v26;
            else
              v23 = v24;
          }
          while (v23);
          if (v22 == v17 || i < *v22)
          {
            v20 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v46) + 8 * i);
            v21 = v56;
            if (v56 >= (unint64_t)HIDWORD(v56))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v57, v56 + 1, 8);
              v21 = v56;
            }
            *((_QWORD *)v55 + v21) = v20;
            LODWORD(v56) = v56 + 1;
          }
        }
        goto LABEL_42;
      }
      v31 = 0;
      while (1)
      {
        v32 = a3;
        v33 = v18;
        do
        {
          v34 = v33 >> 1;
          v35 = &v32[v33 >> 1];
          v37 = *v35;
          v36 = v35 + 1;
          v33 += ~(v33 >> 1);
          if (v37 < v31)
            v32 = v36;
          else
            v33 = v34;
        }
        while (v33);
        if (v32 == v17 || v31 < *v32)
        {
          v38 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v46) + 8 * v31);
          v39 = v56;
          if (v56 >= (unint64_t)HIDWORD(v56))
            goto LABEL_41;
        }
        else
        {
          v39 = v56;
          v38 = 1;
          if (v56 >= (unint64_t)HIDWORD(v56))
          {
LABEL_41:
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v57, v39 + 1, 8);
            v39 = v56;
          }
        }
        *((_QWORD *)v55 + v39) = v38;
        LODWORD(v56) = v56 + 1;
        if (++v31 == v16)
          goto LABEL_42;
      }
    }
    for (j = 0; j != v16; ++j)
    {
      v29 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v46) + 8 * j);
      v30 = v56;
      if (v56 >= (unint64_t)HIDWORD(v56))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v57, v56 + 1, 8);
        v30 = v56;
      }
      *((_QWORD *)v55 + v30) = v29;
      LODWORD(v56) = v56 + 1;
    }
  }
LABEL_42:
  v47 = v46;
  v48 = (void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v47);
  v49 = v40;
  v50 = v52;
  v51 = 0x600000000;
  RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v47);
  Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v47);
  v54 = Values;
  v48 = v55;
  v49 = v56;
  LODWORD(v51) = 0;
  if ((_DWORD)v56)
    v42 = v55;
  else
    v42 = v50;
  v43 = mlir::RankedTensorType::get((uint64_t)v42, v56, RHS, Values);
  if (v50 != v52)
    free(v50);
  if (v55 != v57)
    free(v55);
  return v43;
}

uint64_t mlir::tensor::GatherOp::verify(uint64_t **this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  char *v13;
  char *v14;
  __int128 v15;
  uint64_t v16;
  int *v17;
  char *v18;
  char *v19;
  __int128 v20;
  int *v21;
  char *v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  uint64_t v30;
  uint64_t NextResultAtOffset;
  int *v32;
  char *v33;
  char *v34;
  __int128 v35;
  uint64_t v36;
  int *v37;
  char *v38;
  char *v39;
  __int128 v40;
  _QWORD *v41;
  _QWORD *v42;
  void *v43;
  _QWORD *v44;
  _QWORD *v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  BOOL v53;
  unint64_t v54;
  BOOL v55;
  unint64_t v56;
  unint64_t v57;
  BOOL v58;
  int64_t v59;
  int64_t v60;
  int64_t v61;
  int64_t v62;
  int64_t v63;
  int64_t v64;
  const void **v65;
  __int16 v66;
  int v67;
  const char *v68;
  uint64_t v69;
  _QWORD v70[3];
  void *v71;
  unsigned int v72;
  unsigned int v73;
  _BYTE v74[96];
  void *v75;
  _QWORD *v76;
  void *__p;
  _QWORD *v78;
  char v79;
  uint64_t v80;

  v80 = *MEMORY[0x24BDAC8D0];
  v70[0] = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v70);
  v3 = v2;
  v70[0] = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v4 = (uint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v70);
  v6 = v5;
  if (!verifyGatherOrScatterDims(*this, v4, v5, v3, (const void **)"gather", (const char *)6, (const void **)"source", (const char *)6))return 0;
  v7 = mlir::tensor::GatherOp::inferResultType(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, v4, v6, 0);
  v8 = 1;
  v9 = mlir::tensor::GatherOp::inferResultType(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, v4, v6, 1);
  if (*((_DWORD *)*this + 9))
    v10 = (uint64_t)(*this - 2);
  else
    v10 = 0;
  if ((*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0) + 8) & 0xFFFFFFFFFFFFFFF8) != v7)
  {
    v11 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
    if ((*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0) + 8) & 0xFFFFFFFFFFFFFFF8) != v9)
    {
      v65 = (const void **)"result type mismatch: expected ";
      v66 = 259;
      mlir::OpState::emitOpError(this, &v65, (uint64_t)v70);
      if (v70[0])
      {
        v12 = &v67;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v67, v7);
        v13 = (char *)v71;
        if (v72 >= v73)
        {
          v50 = v72 + 1;
          if (v71 <= &v67 && (char *)v71 + 24 * v72 > (char *)&v67)
          {
            v59 = (char *)&v67 - (_BYTE *)v71;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v50, 24);
            v13 = (char *)v71;
            v12 = (int *)((char *)v71 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v50, 24);
            v12 = &v67;
            v13 = (char *)v71;
          }
        }
        v14 = &v13[24 * v72];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = *((_QWORD *)v12 + 2);
        *(_OWORD *)v14 = v15;
        v16 = ++v72;
        if (v70[0])
        {
          v67 = 3;
          v68 = " or its rank-reduced variant ";
          v69 = 29;
          v17 = &v67;
          v18 = (char *)v71;
          if (v16 >= v73)
          {
            v52 = v16 + 1;
            v53 = (char *)v71 + 24 * v16 > (char *)&v67;
            if (v71 <= &v67 && v53)
            {
              v61 = (char *)&v67 - (_BYTE *)v71;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v52, 24);
              v18 = (char *)v71;
              v17 = (int *)((char *)v71 + v61);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v52, 24);
              v17 = &v67;
              v18 = (char *)v71;
            }
          }
          v19 = &v18[24 * v72];
          v20 = *(_OWORD *)v17;
          *((_QWORD *)v19 + 2) = *((_QWORD *)v17 + 2);
          *(_OWORD *)v19 = v20;
          ++v72;
          if (v70[0])
          {
            v21 = &v67;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v67, v9);
            v22 = (char *)v71;
            if (v72 >= v73)
            {
              v56 = v72 + 1;
              if (v71 <= &v67 && (char *)v71 + 24 * v72 > (char *)&v67)
              {
                v63 = (char *)&v67 - (_BYTE *)v71;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v56, 24);
                v22 = (char *)v71;
                v21 = (int *)((char *)v71 + v63);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v56, 24);
                v21 = &v67;
                v22 = (char *)v71;
              }
            }
            v23 = &v22[24 * v72];
            v24 = *(_OWORD *)v21;
            *((_QWORD *)v23 + 2) = *((_QWORD *)v21 + 2);
            *(_OWORD *)v23 = v24;
            v25 = ++v72;
            if (v70[0])
            {
              v67 = 3;
              v68 = " (got: ";
              v69 = 7;
              v26 = &v67;
              v27 = (char *)v71;
              if (v25 >= v73)
              {
                v57 = v25 + 1;
                v58 = (char *)v71 + 24 * v25 > (char *)&v67;
                if (v71 <= &v67 && v58)
                {
                  v64 = (char *)&v67 - (_BYTE *)v71;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v57, 24);
                  v27 = (char *)v71;
                  v26 = (int *)((char *)v71 + v64);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v57, 24);
                  v26 = &v67;
                  v27 = (char *)v71;
                }
              }
              v28 = &v27[24 * v72];
              v29 = *(_OWORD *)v26;
              *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
              *(_OWORD *)v28 = v29;
              ++v72;
            }
          }
        }
      }
      if (*((_DWORD *)*this + 9))
        v30 = (uint64_t)(*this - 2);
      else
        v30 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v30, 0);
      if (v70[0])
      {
        v32 = &v67;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v67, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
        v33 = (char *)v71;
        if (v72 >= v73)
        {
          v51 = v72 + 1;
          if (v71 <= &v67 && (char *)v71 + 24 * v72 > (char *)&v67)
          {
            v60 = (char *)&v67 - (_BYTE *)v71;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v51, 24);
            v33 = (char *)v71;
            v32 = (int *)((char *)v71 + v60);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v51, 24);
            v32 = &v67;
            v33 = (char *)v71;
          }
        }
        v34 = &v33[24 * v72];
        v35 = *(_OWORD *)v32;
        *((_QWORD *)v34 + 2) = *((_QWORD *)v32 + 2);
        *(_OWORD *)v34 = v35;
        v36 = ++v72;
        if (v70[0])
        {
          v67 = 3;
          v68 = ")";
          v69 = 1;
          v37 = &v67;
          v38 = (char *)v71;
          if (v36 >= v73)
          {
            v54 = v36 + 1;
            v55 = (char *)v71 + 24 * v36 > (char *)&v67;
            if (v71 <= &v67 && v55)
            {
              v62 = (char *)&v67 - (_BYTE *)v71;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v54, 24);
              v38 = (char *)v71;
              v37 = (int *)((char *)v71 + v62);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v54, 24);
              v37 = &v67;
              v38 = (char *)v71;
            }
          }
          v39 = &v38[24 * v72];
          v40 = *(_OWORD *)v37;
          *((_QWORD *)v39 + 2) = *((_QWORD *)v37 + 2);
          *(_OWORD *)v39 = v40;
          ++v72;
        }
      }
      v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v70);
      if (v70[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v70);
      if (v79)
      {
        v41 = __p;
        if (__p)
        {
          v42 = v78;
          v43 = __p;
          if (v78 != __p)
          {
            do
              v42 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v42 - 1);
            while (v42 != v41);
            v43 = __p;
          }
          v78 = v41;
          operator delete(v43);
        }
        v44 = v75;
        if (v75)
        {
          v45 = v76;
          v46 = v75;
          if (v76 != v75)
          {
            do
            {
              v48 = *--v45;
              v47 = v48;
              *v45 = 0;
              if (v48)
                MEMORY[0x20BD002D4](v47, 0x1000C8077774924);
            }
            while (v45 != v44);
            v46 = v75;
          }
          v76 = v44;
          operator delete(v46);
        }
        if (v71 != v74)
          free(v71);
      }
    }
  }
  return v8;
}

uint64_t verifyGatherOrScatterDims(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, const void **a5, const char *a6, const void **a7, const char *a8)
{
  const void ***v10;
  char *v11;
  char *v12;
  __int128 v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  const void ***v27;
  char *v28;
  char *v29;
  __int128 v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t i;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const void ***v45;
  char *v46;
  char *v47;
  __int128 v48;
  _QWORD *v49;
  _QWORD *v50;
  void *v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  const void ***v55;
  char *v56;
  char *v57;
  __int128 v58;
  const void ***v59;
  char *v60;
  char *v61;
  __int128 v62;
  _QWORD *v63;
  _QWORD *v64;
  void *v65;
  _QWORD *v66;
  uint64_t v67;
  uint64_t v68;
  const void ***v69;
  char *v70;
  char *v71;
  __int128 v72;
  _QWORD *v73;
  _QWORD *v74;
  void *v75;
  _QWORD *v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  int64_t v87;
  int64_t v88;
  int64_t v89;
  int64_t v90;
  int64_t v91;
  int64_t v92;
  int64_t v93;
  const void **v94;
  const char *v95;
  uint64_t v96;
  __int16 v97;
  const void **v98;
  const char *v99;
  uint64_t v100;
  __int16 v101;
  uint64_t v102;
  _BYTE v103[16];
  void *v104;
  unsigned int v105;
  unsigned int v106;
  _BYTE v107[96];
  void *v108;
  _QWORD *v109;
  void *__p;
  _QWORD *v111;
  char v112;
  uint64_t v113;

  v113 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    if (a3 <= a4)
    {
      for (i = 0; i != a3; ++i)
      {
        v38 = a2[i];
        if (v38 < 0)
        {
          v101 = 261;
          v98 = a5;
          v99 = a6;
          mlir::Operation::emitOpError(a1, &v98, (uint64_t)&v102);
          if (v102)
          {
            LODWORD(v94) = 3;
            v95 = "_dims value must be non-negative";
            v96 = 32;
            v45 = &v94;
            v46 = (char *)v104;
            if (v105 >= v106)
            {
              v83 = v105 + 1;
              if (v104 <= &v94 && (char *)v104 + 24 * v105 > (char *)&v94)
              {
                v90 = (char *)&v94 - (_BYTE *)v104;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v107, v83, 24);
                v46 = (char *)v104;
                v45 = (const void ***)((char *)v104 + v90);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v107, v83, 24);
                v45 = &v94;
                v46 = (char *)v104;
              }
            }
            v47 = &v46[24 * v105];
            v48 = *(_OWORD *)v45;
            *((_QWORD *)v47 + 2) = v45[2];
            *(_OWORD *)v47 = v48;
            ++v105;
          }
          v18 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v102);
          if (v102)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v102);
          if (!v112)
            return v18;
          v49 = __p;
          if (__p)
          {
            v50 = v111;
            v51 = __p;
            if (v111 != __p)
            {
              do
                v50 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v50 - 1);
              while (v50 != v49);
              v51 = __p;
            }
            v111 = v49;
            operator delete(v51);
          }
          v22 = v108;
          if (!v108)
            goto LABEL_106;
          v52 = v109;
          v24 = v108;
          if (v109 == v108)
            goto LABEL_105;
          do
          {
            v54 = *--v52;
            v53 = v54;
            *v52 = 0;
            if (v54)
              MEMORY[0x20BD002D4](v53, 0x1000C8077774924);
          }
          while (v52 != v22);
          goto LABEL_104;
        }
        if (v38 >= a4)
        {
          v97 = 261;
          v94 = a5;
          v95 = a6;
          mlir::Operation::emitOpError(a1, &v94, (uint64_t)&v102);
          if (v102)
          {
            LODWORD(v98) = 3;
            v99 = "_dims value must be smaller than ";
            v100 = 33;
            v55 = &v98;
            v56 = (char *)v104;
            if (v105 >= v106)
            {
              v84 = v105 + 1;
              if (v104 <= &v98 && (char *)v104 + 24 * v105 > (char *)&v98)
              {
                v91 = (char *)&v98 - (_BYTE *)v104;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v107, v84, 24);
                v56 = (char *)v104;
                v55 = (const void ***)((char *)v104 + v91);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v107, v84, 24);
                v55 = &v98;
                v56 = (char *)v104;
              }
            }
            v57 = &v56[24 * v105];
            v58 = *(_OWORD *)v55;
            *((_QWORD *)v57 + 2) = v55[2];
            *(_OWORD *)v57 = v58;
            ++v105;
            if (v102)
            {
              v101 = 261;
              v98 = a7;
              v99 = a8;
              mlir::Diagnostic::operator<<((uint64_t)v103, &v98);
              if (v102)
              {
                LODWORD(v98) = 3;
                v99 = " rank";
                v100 = 5;
                v59 = &v98;
                v60 = (char *)v104;
                if (v105 >= v106)
                {
                  v85 = v105 + 1;
                  if (v104 <= &v98 && (char *)v104 + 24 * v105 > (char *)&v98)
                  {
                    v92 = (char *)&v98 - (_BYTE *)v104;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v107, v85, 24);
                    v60 = (char *)v104;
                    v59 = (const void ***)((char *)v104 + v92);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v107, v85, 24);
                    v59 = &v98;
                    v60 = (char *)v104;
                  }
                }
                v61 = &v60[24 * v105];
                v62 = *(_OWORD *)v59;
                *((_QWORD *)v61 + 2) = v59[2];
                *(_OWORD *)v61 = v62;
                ++v105;
              }
            }
          }
          v18 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v102);
          if (v102)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v102);
          if (!v112)
            return v18;
          v63 = __p;
          if (__p)
          {
            v64 = v111;
            v65 = __p;
            if (v111 != __p)
            {
              do
                v64 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v64 - 1);
              while (v64 != v63);
              v65 = __p;
            }
            v111 = v63;
            operator delete(v65);
          }
          v22 = v108;
          if (!v108)
            goto LABEL_106;
          v66 = v109;
          v24 = v108;
          if (v109 == v108)
            goto LABEL_105;
          do
          {
            v68 = *--v66;
            v67 = v68;
            *v66 = 0;
            if (v68)
              MEMORY[0x20BD002D4](v67, 0x1000C8077774924);
          }
          while (v66 != v22);
          goto LABEL_104;
        }
      }
      if (a3 < 2)
        return 1;
      v41 = *a2;
      v39 = a2 + 1;
      v40 = v41;
      v42 = a3 - 1;
      v18 = 1;
      while (1)
      {
        v44 = *v39++;
        v43 = v44;
        if (v40 >= v44)
          break;
        v40 = v43;
        if (!--v42)
          return v18;
      }
      v101 = 261;
      v98 = a5;
      v99 = a6;
      mlir::Operation::emitOpError(a1, &v98, (uint64_t)&v102);
      if (v102)
      {
        LODWORD(v94) = 3;
        v95 = "_dims values must be strictly increasing";
        v96 = 40;
        v69 = &v94;
        v70 = (char *)v104;
        if (v105 >= v106)
        {
          v86 = v105 + 1;
          if (v104 <= &v94 && (char *)v104 + 24 * v105 > (char *)&v94)
          {
            v93 = (char *)&v94 - (_BYTE *)v104;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v107, v86, 24);
            v70 = (char *)v104;
            v69 = (const void ***)((char *)v104 + v93);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v107, v86, 24);
            v69 = &v94;
            v70 = (char *)v104;
          }
        }
        v71 = &v70[24 * v105];
        v72 = *(_OWORD *)v69;
        *((_QWORD *)v71 + 2) = v69[2];
        *(_OWORD *)v71 = v72;
        ++v105;
      }
      v18 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v102);
      if (v102)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v102);
      if (!v112)
        return v18;
      v73 = __p;
      if (__p)
      {
        v74 = v111;
        v75 = __p;
        if (v111 != __p)
        {
          do
            v74 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v74 - 1);
          while (v74 != v73);
          v75 = __p;
        }
        v111 = v73;
        operator delete(v75);
      }
      v22 = v108;
      if (!v108)
        goto LABEL_106;
      v76 = v109;
      v24 = v108;
      if (v109 == v108)
        goto LABEL_105;
      do
      {
        v78 = *--v76;
        v77 = v78;
        *v76 = 0;
        if (v78)
          MEMORY[0x20BD002D4](v77, 0x1000C8077774924);
      }
      while (v76 != v22);
      goto LABEL_104;
    }
    v97 = 261;
    v94 = a5;
    v95 = a6;
    mlir::Operation::emitOpError(a1, &v94, (uint64_t)&v102);
    if (v102)
    {
      LODWORD(v98) = 3;
      v99 = "_dims overflow ";
      v100 = 15;
      v10 = &v98;
      v11 = (char *)v104;
      if (v105 >= v106)
      {
        v81 = v105 + 1;
        if (v104 <= &v98 && (char *)v104 + 24 * v105 > (char *)&v98)
        {
          v88 = (char *)&v98 - (_BYTE *)v104;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v107, v81, 24);
          v11 = (char *)v104;
          v10 = (const void ***)((char *)v104 + v88);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v107, v81, 24);
          v10 = &v98;
          v11 = (char *)v104;
        }
      }
      v12 = &v11[24 * v105];
      v13 = *(_OWORD *)v10;
      *((_QWORD *)v12 + 2) = v10[2];
      *(_OWORD *)v12 = v13;
      ++v105;
      if (v102)
      {
        v101 = 261;
        v98 = a7;
        v99 = a8;
        mlir::Diagnostic::operator<<((uint64_t)v103, &v98);
        if (v102)
        {
          LODWORD(v98) = 3;
          v99 = " rank";
          v100 = 5;
          v14 = &v98;
          v15 = (char *)v104;
          if (v105 >= v106)
          {
            v82 = v105 + 1;
            if (v104 <= &v98 && (char *)v104 + 24 * v105 > (char *)&v98)
            {
              v89 = (char *)&v98 - (_BYTE *)v104;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v107, v82, 24);
              v15 = (char *)v104;
              v14 = (const void ***)((char *)v104 + v89);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v107, v82, 24);
              v14 = &v98;
              v15 = (char *)v104;
            }
          }
          v16 = &v15[24 * v105];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = v14[2];
          *(_OWORD *)v16 = v17;
          ++v105;
        }
      }
    }
    v18 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v102);
    if (v102)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v102);
    if (v112)
    {
      v19 = __p;
      if (__p)
      {
        v20 = v111;
        v21 = __p;
        if (v111 != __p)
        {
          do
            v20 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v20 - 1);
          while (v20 != v19);
          v21 = __p;
        }
        v111 = v19;
        operator delete(v21);
      }
      v22 = v108;
      if (!v108)
        goto LABEL_106;
      v23 = v109;
      v24 = v108;
      if (v109 == v108)
      {
LABEL_105:
        v109 = v22;
        operator delete(v24);
LABEL_106:
        if (v104 != v107)
          free(v104);
        return v18;
      }
      do
      {
        v26 = *--v23;
        v25 = v26;
        *v23 = 0;
        if (v26)
          MEMORY[0x20BD002D4](v25, 0x1000C8077774924);
      }
      while (v23 != v22);
LABEL_104:
      v24 = v108;
      goto LABEL_105;
    }
  }
  else
  {
    v101 = 261;
    v98 = a5;
    v99 = a6;
    mlir::Operation::emitOpError(a1, &v98, (uint64_t)&v102);
    if (v102)
    {
      LODWORD(v94) = 3;
      v95 = "_dims must be non-empty";
      v96 = 23;
      v27 = &v94;
      v28 = (char *)v104;
      if (v105 >= v106)
      {
        v80 = v105 + 1;
        if (v104 <= &v94 && (char *)v104 + 24 * v105 > (char *)&v94)
        {
          v87 = (char *)&v94 - (_BYTE *)v104;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v107, v80, 24);
          v28 = (char *)v104;
          v27 = (const void ***)((char *)v104 + v87);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v107, v80, 24);
          v27 = &v94;
          v28 = (char *)v104;
        }
      }
      v29 = &v28[24 * v105];
      v30 = *(_OWORD *)v27;
      *((_QWORD *)v29 + 2) = v27[2];
      *(_OWORD *)v29 = v30;
      ++v105;
    }
    v18 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v102);
    if (v102)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v102);
    if (v112)
    {
      v31 = __p;
      if (__p)
      {
        v32 = v111;
        v33 = __p;
        if (v111 != __p)
        {
          do
            v32 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v32 - 1);
          while (v32 != v31);
          v33 = __p;
        }
        v111 = v31;
        operator delete(v33);
      }
      v22 = v108;
      if (!v108)
        goto LABEL_106;
      v34 = v109;
      v24 = v108;
      if (v109 == v108)
        goto LABEL_105;
      do
      {
        v36 = *--v34;
        v35 = v36;
        *v34 = 0;
        if (v36)
          MEMORY[0x20BD002D4](v35, 0x1000C8077774924);
      }
      while (v34 != v22);
      goto LABEL_104;
    }
  }
  return v18;
}

unint64_t mlir::tensor::GatherOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t NextResultAtOffset;
  unint64_t result;

  v3 = *(uint64_t **)(a2 + 56);
  v4 = *v3;
  if (*v3 && !mlir::DenseElementsAttr::classof(*v3))
    v4 = 0;
  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v5 = *(_QWORD *)a1 - 16;
  else
    v5 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  result = reshapeConstantSource(v4, (_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
  if (result <= 7)
    return 0;
  return result;
}

unint64_t reshapeConstantSource(unint64_t result, _QWORD *a2)
{
  _QWORD *Value;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;

  v7 = a2;
  v8 = result;
  if (result)
  {
    if (mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v8))
    {
      if (!mlir::TensorType::hasRank((mlir::TensorType *)&v7))
        return 0;
      Value = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v7);
      if (v3)
      {
        v4 = 8 * v3;
        while (*Value != 0x8000000000000000)
        {
          ++Value;
          v4 -= 8;
          if (!v4)
            goto LABEL_8;
        }
        return 0;
      }
LABEL_8:
      v5 = (uint64_t)v7;
      if (v7)
        v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v7 + 8);
      else
        v6 = 0;
      return mlir::DenseElementsAttr::reshape((uint64_t *)&v8, v5, v6) & 0xFFFFFFFFFFFFFFFBLL;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t mlir::tensor::InsertOp::getAsmResultNames(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v4;
  uint64_t NextResultAtOffset;

  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v4 = *(_QWORD *)a1 - 16;
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return a2(a3, NextResultAtOffset, "inserted", 8);
}

uint64_t mlir::tensor::InsertOp::verify(uint64_t **this)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const void **v13;
  __int16 v14;
  unint64_t v15;
  _QWORD v16[3];
  void *v17;
  uint64_t v18;
  void *v19;
  _QWORD *v20;
  void *__p;
  _QWORD *v22;
  char v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v15 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v15);
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    if (v2 == *((unsigned int *)*this + 17) - 2)
      return 1;
  }
  else if (v2 == -2)
  {
    return 1;
  }
  v13 = (const void **)"incorrect number of indices";
  v14 = 259;
  mlir::OpState::emitOpError(this, &v13, (uint64_t)v16);
  v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v16);
  if (v16[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v16);
  if (v23)
  {
    v4 = __p;
    if (__p)
    {
      v5 = v22;
      v6 = __p;
      if (v22 != __p)
      {
        do
          v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
        while (v5 != v4);
        v6 = __p;
      }
      v22 = v4;
      operator delete(v6);
    }
    v7 = v19;
    if (v19)
    {
      v8 = v20;
      v9 = v19;
      if (v20 != v19)
      {
        do
        {
          v11 = *--v8;
          v10 = v11;
          *v8 = 0;
          if (v11)
            MEMORY[0x20BD002D4](v10, 0x1000C8077774924);
        }
        while (v8 != v7);
        v9 = v19;
      }
      v20 = v7;
      operator delete(v9);
    }
    if (v17 != &v18)
      free(v17);
  }
  return v3;
}

unint64_t mlir::tensor::InsertOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  int isSplat;
  uint64_t v8;
  uint64_t v9;
  uint64_t NumElements;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;

  v2 = *(uint64_t **)(a2 + 40);
  v4 = *v2;
  v3 = v2[1];
  if (*v2)
    v5 = v3 == 0;
  else
    v5 = 1;
  if (v5)
    return 0;
  v6 = mlir::DenseElementsAttr::classof(v2[1]) ? v3 : 0;
  *(_QWORD *)&v14 = v6;
  if (!v6)
    return 0;
  isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v14);
  v8 = isSplat ? v3 : 0;
  v12 = v8;
  if (isSplat
    && (mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v12),
        ZinMirCacheTensors::ZinMirCacheTensors(&v14, v12, 0),
        v9 = v12,
        NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v12),
        ZinMirCacheTensors::ZinMirCacheTensors(&v13, v9, NumElements),
        v4 == mlir::DenseElementsAttr::AttributeElementIterator::operator*(&v14)))
  {
    return v3 & 0xFFFFFFFFFFFFFFFBLL;
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::tensor::GenerateOp::getAsmResultNames(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v4;
  uint64_t NextResultAtOffset;

  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v4 = *(_QWORD *)a1 - 16;
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return a2(a3, NextResultAtOffset, "generated", 9);
}

uint64_t mlir::tensor::GenerateOp::reifyResultShapes(uint64_t a1, mlir::IndexType **a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  char *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t i;
  uint64_t Value;
  unint64_t v20;
  uint64_t v21;
  unint64_t v23;
  void *v24;
  uint64_t v25;
  _QWORD v26[7];

  v26[6] = *MEMORY[0x24BDAC8D0];
  v23 = *(_QWORD *)(*(_QWORD *)a1 - 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v23);
  v24 = v26;
  v25 = 0x600000000;
  if (v6)
  {
    v7 = v6;
    if (v6 < 7)
    {
      v8 = 0;
      v9 = v6;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v24, v26, v6, 8);
      v8 = v25;
      v9 = v7 - v25;
      if (v7 == v25)
        goto LABEL_7;
    }
    bzero((char *)v24 + 8 * v8, 8 * v9);
LABEL_7:
    LODWORD(v25) = v7;
  }
  v10 = *(unsigned int *)(a3 + 8);
  if (!(_DWORD)v10)
  {
    llvm::SmallVectorImpl<llvm::SmallVector<mlir::OpFoldResult,6u>>::append(a3, 1 - v10, (unint64_t)&v24);
LABEL_15:
    v14 = v24;
    if (v24 == v26)
      goto LABEL_17;
    goto LABEL_16;
  }
  if ((_DWORD)v10 == 1)
    goto LABEL_15;
  v11 = *(_QWORD **)a3;
  v12 = v10 << 6;
  do
  {
    v13 = *(char **)((char *)v11 + v12 - 64);
    if ((char *)v11 + v12 - 48 != v13)
      free(v13);
    v12 -= 64;
  }
  while (v12 != 64);
  *(_DWORD *)(a3 + 8) = 1;
  v14 = v24;
  if (v24 != v26)
LABEL_16:
    free(v14);
LABEL_17:
  v24 = (void *)(*(_QWORD *)(*(_QWORD *)a1 - 8) & 0xFFFFFFFFFFFFFFF8);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v24);
  if (v15)
  {
    v16 = v15;
    v17 = 0;
    for (i = 0; i != v16; ++i)
    {
      v24 = (void *)(*(_QWORD *)(*(_QWORD *)a1 - 8) & 0xFFFFFFFFFFFFFFF8);
      if (*(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v24) + 8 * i) == 0x8000000000000000)
      {
        v21 = v17++;
        v20 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 32 * v21 + 24) | 4;
      }
      else
      {
        v24 = (void *)(*(_QWORD *)(*(_QWORD *)a1 - 8) & 0xFFFFFFFFFFFFFFF8);
        Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v24);
        v20 = mlir::Builder::getIndexAttr(a2, *(mlir::MLIRContext **)(Value + 8 * i)) & 0xFFFFFFFFFFFFFFFBLL;
      }
      *(_QWORD *)(**(_QWORD **)a3 + 8 * i) = v20;
    }
  }
  return 1;
}

uint64_t mlir::tensor::GenerateOp::verify(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t Value;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  int64x2_t *v11;
  int64x2_t v12;
  int64x2_t v13;
  uint64_t v14;
  int64x2_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  const char *v39;
  __int16 v40;
  unint64_t v41;
  void *v42;
  uint64_t v43;
  _BYTE v44[48];
  _QWORD v45[2];
  _WORD v46[24];
  _QWORD v47[3];
  void *v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v41 = *(*this - 1) & 0xFFFFFFFFFFFFFFF8;
  if ((*((_BYTE *)v2 + 46) & 0x80) != 0)
  {
    v3 = *((unsigned int *)v2 + 17);
    Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v41);
    if (v5)
      goto LABEL_3;
  }
  else
  {
    v3 = 0;
    Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v41);
    if (v5)
    {
LABEL_3:
      v6 = (v5 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v6 >= 3)
      {
        v9 = v6 + 1;
        v10 = (v6 + 1) & 0x3FFFFFFFFFFFFFFCLL;
        v8 = (uint64_t *)(Value + 8 * v10);
        v11 = (int64x2_t *)(Value + 16);
        v12 = 0uLL;
        v13 = vdupq_n_s64(0x8000000000000000);
        v14 = v10;
        v15 = 0uLL;
        do
        {
          v12 = vsubq_s64(v12, vceqq_s64(v11[-1], v13));
          v15 = vsubq_s64(v15, vceqq_s64(*v11, v13));
          v11 += 2;
          v14 -= 4;
        }
        while (v14);
        v7 = vaddvq_s64(vaddq_s64(v15, v12));
        if (v9 == v10)
          goto LABEL_11;
      }
      else
      {
        v7 = 0;
        v8 = (uint64_t *)Value;
      }
      do
      {
        v16 = *v8++;
        if (v16 == 0x8000000000000000)
          ++v7;
      }
      while (v8 != (uint64_t *)(Value + 8 * v5));
LABEL_11:
      if (v7 == v3)
        goto LABEL_12;
      goto LABEL_42;
    }
  }
  if (!v3)
  {
LABEL_12:
    v45[0] = v46;
    v45[1] = 0x600000000;
    v42 = v44;
    v43 = 0x600000000;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
    {
      operandsAndShape(v41, (*this)[9], *((unsigned int *)*this + 17), (uint64_t)v45, (uint64_t)&v42);
      v17 = v43;
      if ((_DWORD)v43)
        goto LABEL_14;
    }
    else
    {
      operandsAndShape(v41, 0, 0, (uint64_t)v45, (uint64_t)&v42);
      v17 = v43;
      if ((_DWORD)v43)
      {
LABEL_14:
        v18 = v42;
        v19 = 8 * v17;
        while (*v18 < 0x8000000000000001)
        {
          ++v18;
          v19 -= 8;
          if (!v19)
            goto LABEL_17;
        }
        v39 = "tensor dimensions must be non-negative";
        v40 = 259;
        mlir::OpState::emitError(this, (uint64_t)&v39, (uint64_t)v47);
        v20 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
        if (v47[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
        if (v54)
        {
          v22 = __p;
          if (__p)
          {
            v23 = v53;
            v24 = __p;
            if (v53 != __p)
            {
              do
                v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
              while (v23 != v22);
              v24 = __p;
            }
            v53 = v22;
            operator delete(v24);
          }
          v25 = v50;
          if (v50)
          {
            v26 = v51;
            v27 = v50;
            if (v51 != v50)
            {
              do
              {
                v29 = *--v26;
                v28 = v29;
                *v26 = 0;
                if (v29)
                  MEMORY[0x20BD002D4](v28, 0x1000C8077774924);
              }
              while (v26 != v25);
              v27 = v50;
            }
            v51 = v25;
            operator delete(v27);
          }
          if (v48 != v49)
            free(v48);
        }
LABEL_18:
        if (v42 != v44)
          free(v42);
        v21 = (void *)v45[0];
        if ((_WORD *)v45[0] == v46)
          return v20;
LABEL_59:
        free(v21);
        return v20;
      }
    }
LABEL_17:
    v20 = 1;
    goto LABEL_18;
  }
LABEL_42:
  v45[0] = "must have as many index operands as dynamic extents in the result type";
  v46[8] = 259;
  mlir::OpState::emitError(this, (uint64_t)v45, (uint64_t)v47);
  v20 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
  if (v47[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
  if (v54)
  {
    v30 = __p;
    if (__p)
    {
      v31 = v53;
      v32 = __p;
      if (v53 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v53 = v30;
      operator delete(v32);
    }
    v33 = v50;
    if (v50)
    {
      v34 = v51;
      v35 = v50;
      if (v51 != v50)
      {
        do
        {
          v37 = *--v34;
          v36 = v37;
          *v34 = 0;
          if (v37)
            MEMORY[0x20BD002D4](v36, 0x1000C8077774924);
        }
        while (v34 != v33);
        v35 = v50;
      }
      v51 = v33;
      operator delete(v35);
    }
    v21 = v48;
    if (v48 != v49)
      goto LABEL_59;
  }
  return v20;
}

void operandsAndShape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t Value;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t i;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t DefiningOp;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  unint64_t v23;
  void *v24;
  BOOL v25;
  BOOL v26;
  BOOL v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t **v37;
  uint64_t *v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  void *v42[2];
  _QWORD v43[2];

  v43[1] = *MEMORY[0x24BDAC8D0];
  v40 = a1;
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v40);
  if (v9)
  {
    v10 = (uint64_t *)Value;
    v11 = 0;
    v35 = (void *)(a5 + 16);
    v12 = (_DWORD *)(a4 + 8);
    v34 = (void *)(a4 + 16);
    for (i = 8 * v9; i; i -= 8)
    {
      while (1)
      {
        v14 = *v10;
        if (*v10 == 0x8000000000000000)
          break;
        v29 = *(unsigned int *)(a5 + 8);
        if (v29 >= *(unsigned int *)(a5 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a5, v35, v29 + 1, 8);
          v29 = *(unsigned int *)(a5 + 8);
        }
        *(_QWORD *)(*(_QWORD *)a5 + 8 * v29) = v14;
        ++*(_DWORD *)(a5 + 8);
        ++v10;
        i -= 8;
        if (!i)
          return;
      }
      v39 = 1;
      v38 = 0;
      v15 = a2 + 32 * v11;
      v17 = *(_QWORD *)(v15 + 24);
      v16 = (uint64_t *)(v15 + 24);
      v37 = &v38;
      v41 = v17;
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v41);
      if (!DefiningOp)
        goto LABEL_28;
      v19 = DefiningOp;
      if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
        goto LABEL_28;
      v36 = v11;
      v20 = a4;
      v21 = v12;
      v42[0] = v43;
      v42[1] = (void *)0x100000000;
      mlir::Operation::fold(v19, 0, 0, (uint64_t)v42);
      v22 = *(_QWORD *)v42[0];
      if (v42[0] != v43)
        free(v42[0]);
      v23 = v22 & 0xFFFFFFFFFFFFFFF8;
      v12 = v21;
      a4 = v20;
      v11 = v36;
      if (!v23)
        goto LABEL_28;
      v24 = *(void **)(*(_QWORD *)(*(_QWORD *)(v19 - 8) & 0xFFFFFFFFFFFFFFF8) + 136);
      v25 = v24 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
         || v24 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id;
      v26 = v25 || v24 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id;
      v27 = v26 || v24 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id;
      if (v27 && (mlir::detail::constant_int_value_binder::match((uint64_t *)&v37, v23) & 1) != 0)
      {
        if (v39 > 0x40)
          v28 = *v38;
        else
          v28 = (uint64_t)((_QWORD)v38 << -(uint64_t)v39) >> -(uint64_t)v39;
        v33 = *(unsigned int *)(a5 + 8);
        if (v33 >= *(unsigned int *)(a5 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a5, v35, v33 + 1, 8);
          v33 = *(unsigned int *)(a5 + 8);
        }
        *(_QWORD *)(*(_QWORD *)a5 + 8 * v33) = v28;
        ++*(_DWORD *)(a5 + 8);
        if (v39 < 0x41)
          goto LABEL_3;
      }
      else
      {
LABEL_28:
        v30 = *(unsigned int *)(a5 + 8);
        if (v30 >= *(unsigned int *)(a5 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a5, v35, v30 + 1, 8);
          v30 = *(unsigned int *)(a5 + 8);
        }
        *(_QWORD *)(*(_QWORD *)a5 + 8 * v30) = 0x8000000000000000;
        ++*(_DWORD *)(a5 + 8);
        v31 = *v16;
        v32 = *(unsigned int *)(a4 + 8);
        if (v32 >= *(unsigned int *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, v34, v32 + 1, 8);
          v32 = *(unsigned int *)(a4 + 8);
        }
        *(_QWORD *)(*(_QWORD *)a4 + 8 * v32) = v31;
        ++*v12;
        if (v39 < 0x41)
          goto LABEL_3;
      }
      if (v38)
        MEMORY[0x20BD002D4](v38, 0x1000C8000313F17);
LABEL_3:
      ++v11;
      ++v10;
    }
  }
}

uint64_t mlir::tensor::GenerateOp::verifyRegions(uint64_t **this)
{
  uint64_t *v2;
  uint64_t ArgumentTypes;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  ZinIrHalH13g **v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  const void **v40[4];
  __int16 v41;
  unint64_t v42;
  _QWORD v43[3];
  void *v44;
  uint64_t v45;
  void *v46;
  _QWORD *v47;
  void *__p;
  _QWORD *v49;
  char v50;
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v42 = *(*this - 1) & 0xFFFFFFFFFFFFFFF8;
  ArgumentTypes = mlir::Region::getArgumentTypes((mlir::Region *)((((unint64_t)&v2[2
                                                                                        * (((unint64_t)*((unsigned int *)v2 + 11) >> 23) & 1)
                                                                                        + 8]
                                                                  + (((unint64_t)*((unsigned int *)v2 + 11) >> 21) & 0x7F8)
                                                                  + 7) & 0xFFFFFFFFFFFFFFF8)
                                                                + 32 * *((unsigned int *)v2 + 10)));
  if (ArgumentTypes == v4)
  {
LABEL_5:
    v7 = *((unsigned int *)*this + 11);
    if ((v7 & 0x7FFFFF) != 0)
    {
      v8 = (_QWORD *)((((unint64_t)&(*this)[2 * ((v7 >> 23) & 1) + 8] + ((v7 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                    + 32 * *((unsigned int *)*this + 10));
      if ((_QWORD *)*v8 != v8)
        goto LABEL_7;
    }
    else
    {
      v8 = 0;
      if (MEMORY[0])
      {
LABEL_7:
        v9 = v8[1];
        if (v9)
          v10 = v9 - 8;
        else
          v10 = 0;
        v11 = (*(_QWORD *)(v10 + 56) - *(_QWORD *)(v10 + 48)) >> 3;
        mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v42);
        if (v12 == v11)
          goto LABEL_11;
        goto LABEL_45;
      }
    }
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v42);
    if (!v32)
    {
LABEL_11:
      v13 = *(_QWORD *)((((unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)
                                                   + 8]
                        + (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)
                        + 7) & 0xFFFFFFFFFFFFFFF8)
                      + 32 * *((unsigned int *)*this + 10)
                      + 8);
      if (v13)
        v14 = (ZinIrHalH13g **)(v13 - 8);
      else
        v14 = 0;
      mlir::Block::getTerminator(v14);
      v16 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v15 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
      if (v16 == mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v42))
        return 1;
      v41 = 259;
      mlir::OpState::emitOpError(this, v40, (uint64_t)v43);
      v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v43);
      if (v43[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v43);
      if (!v50)
        return v17;
      v18 = __p;
      if (__p)
      {
        v19 = v49;
        v20 = __p;
        if (v49 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v49 = v18;
        operator delete(v20);
      }
      v21 = v46;
      if (!v46)
        goto LABEL_61;
      v22 = v47;
      v23 = v46;
      if (v47 == v46)
      {
LABEL_60:
        v47 = v21;
        operator delete(v23);
LABEL_61:
        if (v44 != &v45)
          free(v44);
        return v17;
      }
      do
      {
        v25 = *--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
      }
      while (v22 != v21);
LABEL_59:
      v23 = v46;
      goto LABEL_60;
    }
LABEL_45:
    v40[0] = (const void **)"must have one body argument per input dimension";
    v41 = 259;
    mlir::OpState::emitError(this, (uint64_t)v40, (uint64_t)v43);
    v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v43);
    if (v43[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v43);
    if (!v50)
      return v17;
    v33 = __p;
    if (__p)
    {
      v34 = v49;
      v35 = __p;
      if (v49 != __p)
      {
        do
          v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
        while (v34 != v33);
        v35 = __p;
      }
      v49 = v33;
      operator delete(v35);
    }
    v21 = v46;
    if (!v46)
      goto LABEL_61;
    v36 = v47;
    v23 = v46;
    if (v47 == v46)
      goto LABEL_60;
    do
    {
      v38 = *--v36;
      v37 = v38;
      *v36 = 0;
      if (v38)
        MEMORY[0x20BD002D4](v37, 0x1000C8077774924);
    }
    while (v36 != v21);
    goto LABEL_59;
  }
  v5 = ArgumentTypes;
  v6 = v4;
  while (1)
  {
    v43[0] = *(_QWORD *)(*(_QWORD *)v5 + 8) & 0xFFFFFFFFFFFFFFF8;
    if (!mlir::Type::isIndex((mlir::Type *)v43))
      break;
    v5 += 8;
    if (v5 == v6)
      goto LABEL_5;
  }
  v40[0] = (const void **)"all body arguments must be index";
  v41 = 259;
  mlir::OpState::emitError(this, (uint64_t)v40, (uint64_t)v43);
  v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v43);
  if (v43[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v43);
  if (v50)
  {
    v26 = __p;
    if (__p)
    {
      v27 = v49;
      v28 = __p;
      if (v49 != __p)
      {
        do
          v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
        while (v27 != v26);
        v28 = __p;
      }
      v49 = v26;
      operator delete(v28);
    }
    v21 = v46;
    if (!v46)
      goto LABEL_61;
    v29 = v47;
    v23 = v46;
    if (v47 == v46)
      goto LABEL_60;
    do
    {
      v31 = *--v29;
      v30 = v31;
      *v29 = 0;
      if (v31)
        MEMORY[0x20BD002D4](v30, 0x1000C8077774924);
    }
    while (v29 != v21);
    goto LABEL_59;
  }
  return v17;
}

void mlir::tensor::GenerateOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  const char *v45;
  unint64_t v46;
  uint64_t v47;
  const char *v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  const char *v72;
  unint64_t v73;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v72, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"tensor.extract", 14, (__int16)v72, a2, 0, 0);
  *(_QWORD *)v4 = &off_24C02A890;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v72 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::ExtractFromTensorGenerate]";
  v73 = 98;
  v9 = llvm::StringRef::find((uint64_t *)&v72, "DesiredTypeName = ", 0x12uLL, 0);
  if (v73 >= v9)
    v10 = v9;
  else
    v10 = v73;
  v11 = &v72[v10];
  v12 = v73 - v10;
  if (v73 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v73 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_78;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_79;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_82;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_82:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v72, 1);
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"tensor.generate", 15, (__int16)v72, a2, 0, 0);
  *(_QWORD *)v38 = &off_24C029D20;
  if (*(_QWORD *)(v38 + 72))
  {
    v39 = *(unsigned int *)(v38 + 88);
    if (v39 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v39, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  v72 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::StaticTensorGenerate]";
  v73 = 93;
  v43 = llvm::StringRef::find((uint64_t *)&v72, "DesiredTypeName = ", 0x12uLL, 0);
  if (v73 >= v43)
    v44 = v43;
  else
    v44 = v73;
  v45 = &v72[v44];
  v46 = v73 - v44;
  if (v73 - v44 >= 0x12)
    v47 = 18;
  else
    v47 = v73 - v44;
  v48 = &v45[v47];
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *(_QWORD *)(v38 + 64) = v48;
  *(_QWORD *)(v38 + 72) = v49;
  v39 = *(unsigned int *)(v38 + 88);
  if (v39 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
LABEL_78:
    abort();
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (!v54)
  {
    v55 = 0;
    v56 = (uint64_t *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
    goto LABEL_74;
  }
  if (v54 >> 61)
LABEL_79:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v55 = (char *)operator new(8 * v54);
  v56 = (uint64_t *)&v55[8 * v51];
  v57 = &v55[8 * v54];
  *v56 = v38;
  v42 = (uint64_t)(v56 + 1);
  v58 = (char *)(v41 - v50);
  if (v41 != v50)
  {
LABEL_62:
    v59 = (unint64_t)(v58 - 8);
    if (v59 < 0x78
      || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v56
      && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
    {
      goto LABEL_83;
    }
    v60 = (v59 >> 3) + 1;
    v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
    v62 = &v41[-v61];
    v56 = (uint64_t *)((char *)v56 - v61);
    v63 = &v55[8 * v51 - 16];
    v64 = v41 - 16;
    v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v67 = *((_OWORD *)v64 - 1);
      v66 = *(_OWORD *)v64;
      *((_OWORD *)v64 - 1) = 0uLL;
      *(_OWORD *)v64 = 0uLL;
      *((_OWORD *)v63 - 1) = v67;
      *(_OWORD *)v63 = v66;
      v63 -= 32;
      v64 -= 32;
      v65 -= 4;
    }
    while (v65);
    v41 = v62;
    if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_83:
      do
      {
        v68 = *((_QWORD *)v41 - 1);
        v41 -= 8;
        *(_QWORD *)v41 = 0;
        *--v56 = v68;
      }
      while (v41 != v50);
    }
    v41 = (char *)a1[1];
    v69 = (char *)a1[2];
    a1[1] = v56;
    a1[2] = v42;
    a1[3] = v57;
    while (v69 != v41)
    {
      v71 = *((_QWORD *)v69 - 1);
      v69 -= 8;
      v70 = v71;
      *(_QWORD *)v69 = 0;
      if (v71)
        (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
    }
    goto LABEL_75;
  }
LABEL_74:
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
}

uint64_t mlir::tensor::RankOp::getAsmResultNames(_QWORD *a1, uint64_t (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  return a2(a3, *a1 - 16, "rank", 4);
}

uint64_t mlir::tensor::ReshapeOp::verify(uint64_t **this)
{
  uint64_t *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t ElementType;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  void *v20;
  _QWORD *Value;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t Shape;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD *v62;
  _QWORD *v63;
  void *v64;
  _QWORD *v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD *v69;
  _QWORD *v70;
  const void **v71[4];
  __int16 v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  uint64_t v76;
  void *v77;
  uint64_t v78;
  void *v79;
  _QWORD *v80;
  void *__p;
  _QWORD *v82;
  char v83;
  uint64_t v84;

  v84 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v74 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v3 = *((_DWORD *)v2 + 9);
  v4 = (uint64_t)(v2 - 2);
  if (v3)
    v5 = v4;
  else
    v5 = 0;
  v73 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  ElementType = mlir::TensorType::getElementType((mlir::TensorType *)&v74);
  if (ElementType != mlir::TensorType::getElementType((mlir::TensorType *)&v73))
  {
    v71[0] = (const void **)"element types of source and destination tensor types should be the same";
    v72 = 259;
    mlir::OpState::emitOpError(this, v71, (uint64_t)&v75);
    v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v75);
    if (v75)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v75);
    if (v83)
    {
      v8 = __p;
      if (__p)
      {
        v9 = v82;
        v10 = __p;
        if (v82 != __p)
        {
          do
            v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
          while (v9 != v8);
          v10 = __p;
        }
        v82 = v8;
        operator delete(v10);
      }
      v11 = v79;
      if (!v79)
        goto LABEL_93;
      v12 = v80;
      v13 = v79;
      if (v80 == v79)
      {
LABEL_92:
        v80 = v11;
        operator delete(v13);
LABEL_93:
        if (v77 != &v78)
          free(v77);
        return v7;
      }
      do
      {
        v15 = *--v12;
        v14 = v15;
        *v12 = 0;
        if (v15)
          MEMORY[0x20BD002D4](v14, 0x1000C8077774924);
      }
      while (v12 != v11);
LABEL_91:
      v13 = v79;
      goto LABEL_92;
    }
    return v7;
  }
  v75 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  v16 = *(_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v75);
  v17 = (_QWORD *)v73;
  v18 = (_QWORD *)v74;
  v19 = *(void **)(*(_QWORD *)v73 + 136);
  if (v19 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v17 = 0;
  v70 = v17;
  v20 = *(void **)(*(_QWORD *)v74 + 136);
  if (v20 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v18 = 0;
  v69 = v18;
  if (v19 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    return 1;
  if (v20 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    && mlir::TensorType::hasRank((mlir::TensorType *)&v70))
  {
    Value = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v70);
    if (v22)
    {
      v23 = 8 * v22;
      while (*Value != 0x8000000000000000)
      {
        ++Value;
        v23 -= 8;
        if (!v23)
          goto LABEL_31;
      }
      goto LABEL_61;
    }
LABEL_31:
    if (!mlir::TensorType::hasRank((mlir::TensorType *)&v69))
      goto LABEL_61;
    v24 = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69);
    if (v25)
    {
      v26 = 8 * v25;
      while (*v24 != 0x8000000000000000)
      {
        ++v24;
        v26 -= 8;
        if (!v26)
          goto LABEL_36;
      }
      goto LABEL_61;
    }
LABEL_36:
    v27 = v69;
    if (v69)
      v28 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v69 + 8);
    else
      v28 = 0;
    v75 = (unint64_t)v27;
    v76 = v28;
    Shape = mlir::ShapedType::getShape((mlir::ShapedType *)&v75);
    if (v30)
    {
      v31 = (v30 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v31)
      {
        v32 = v31 + 1;
        v33 = (v31 + 1) & 0x3FFFFFFFFFFFFFFELL;
        v34 = (uint64_t *)(Shape + 8 * v33);
        v35 = (_QWORD *)(Shape + 8);
        v36 = 1;
        v37 = v33;
        v38 = 1;
        do
        {
          v36 *= *(v35 - 1);
          v38 *= *v35;
          v35 += 2;
          v37 -= 2;
        }
        while (v37);
        v39 = v38 * v36;
        if (v32 == v33)
          goto LABEL_48;
      }
      else
      {
        v39 = 1;
        v34 = (uint64_t *)Shape;
      }
      do
      {
        v40 = *v34++;
        v39 *= v40;
      }
      while (v34 != (uint64_t *)(Shape + 8 * v30));
    }
    else
    {
      v39 = 1;
    }
LABEL_48:
    v41 = v70;
    if (v70)
      v42 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v70 + 8);
    else
      v42 = 0;
    v75 = (unint64_t)v41;
    v76 = v42;
    v43 = mlir::ShapedType::getShape((mlir::ShapedType *)&v75);
    if (!v44)
    {
      v53 = 1;
      goto LABEL_60;
    }
    v45 = (v44 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v45)
    {
      v46 = v45 + 1;
      v47 = (v45 + 1) & 0x3FFFFFFFFFFFFFFELL;
      v48 = (uint64_t *)(v43 + 8 * v47);
      v49 = (_QWORD *)(v43 + 8);
      v50 = 1;
      v51 = v47;
      v52 = 1;
      do
      {
        v50 *= *(v49 - 1);
        v52 *= *v49;
        v49 += 2;
        v51 -= 2;
      }
      while (v51);
      v53 = v52 * v50;
      if (v46 == v47)
      {
LABEL_60:
        if (v39 != v53)
        {
          v71[0] = (const void **)"source and destination tensor should have the same number of elements";
          v72 = 259;
          mlir::OpState::emitOpError(this, v71, (uint64_t)&v75);
          v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v75);
          mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v75);
          return v7;
        }
        goto LABEL_61;
      }
    }
    else
    {
      v53 = 1;
      v48 = (uint64_t *)v43;
    }
    do
    {
      v54 = *v48++;
      v53 *= v54;
    }
    while (v48 != (uint64_t *)(v43 + 8 * v44));
    goto LABEL_60;
  }
LABEL_61:
  if (v16 != 0x8000000000000000)
  {
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v70);
    if (v16 != v61)
    {
      v71[0] = (const void **)"length of shape operand differs from the result's tensor rank";
      v72 = 259;
      mlir::OpState::emitOpError(this, v71, (uint64_t)&v75);
      v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v75);
      if (v75)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v75);
      if (v83)
      {
        v62 = __p;
        if (__p)
        {
          v63 = v82;
          v64 = __p;
          if (v82 != __p)
          {
            do
              v63 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v63 - 1);
            while (v63 != v62);
            v64 = __p;
          }
          v82 = v62;
          operator delete(v64);
        }
        v11 = v79;
        if (!v79)
          goto LABEL_93;
        v65 = v80;
        v13 = v79;
        if (v80 == v79)
          goto LABEL_92;
        do
        {
          v67 = *--v65;
          v66 = v67;
          *v65 = 0;
          if (v67)
            MEMORY[0x20BD002D4](v66, 0x1000C8077774924);
        }
        while (v65 != v11);
        goto LABEL_91;
      }
      return v7;
    }
    return 1;
  }
  v71[0] = (const void **)"cannot use shape operand with dynamic length to reshape to statically-ranked tensor type";
  v72 = 259;
  mlir::OpState::emitOpError(this, v71, (uint64_t)&v75);
  v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v75);
  if (v75)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v75);
  if (v83)
  {
    v55 = __p;
    if (__p)
    {
      v56 = v82;
      v57 = __p;
      if (v82 != __p)
      {
        do
          v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
        while (v56 != v55);
        v57 = __p;
      }
      v82 = v55;
      operator delete(v57);
    }
    v11 = v79;
    if (!v79)
      goto LABEL_93;
    v58 = v80;
    v13 = v79;
    if (v80 == v79)
      goto LABEL_92;
    do
    {
      v60 = *--v58;
      v59 = v60;
      *v58 = 0;
      if (v60)
        MEMORY[0x20BD002D4](v59, 0x1000C8077774924);
    }
    while (v58 != v11);
    goto LABEL_91;
  }
  return v7;
}

unint64_t mlir::tensor::ReshapeOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t NextResultAtOffset;
  unint64_t result;

  v3 = *(uint64_t **)(a2 + 40);
  v4 = *v3;
  if (*v3 && !mlir::DenseElementsAttr::classof(*v3))
    v4 = 0;
  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v5 = *(_QWORD *)a1 - 16;
  else
    v5 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  result = reshapeConstantSource(v4, (_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
  if (result <= 7)
    return 0;
  return result;
}

uint64_t mlir::tensor::CollapseShapeOp::getAsmResultNames(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v4;
  uint64_t NextResultAtOffset;

  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v4 = *(_QWORD *)a1 - 16;
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return a2(a3, NextResultAtOffset, "collapsed", 9);
}

uint64_t mlir::tensor::ExpandShapeOp::getAsmResultNames(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v4;
  uint64_t NextResultAtOffset;

  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v4 = *(_QWORD *)a1 - 16;
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return a2(a3, NextResultAtOffset, "expanded", 8);
}

uint64_t mlir::tensor::ExpandShapeOp::getCorrespondingSourceDim(mlir::tensor::ExpandShapeOp *this, uint64_t a2)
{
  char *v3;
  uint64_t v4;
  char *v5;
  char *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  char *v14;
  void *v16;
  unsigned int v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  _QWORD v21[17];

  v21[16] = *MEMORY[0x24BDAC8D0];
  mlir::memref::CollapseShapeOp::getReassociationIndices(this, (uint64_t)&v16);
  v19 = v21;
  v20 = 0x400000000;
  if (v17)
  {
    llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=((uint64_t)&v19, (uint64_t)&v16);
    v3 = (char *)v16;
    if (!v17)
      goto LABEL_8;
    v4 = 32 * v17;
    do
    {
      v5 = *(char **)&v3[v4 - 32];
      if (&v3[v4 - 16] != v5)
        free(v5);
      v4 -= 32;
    }
    while (v4);
  }
  v3 = (char *)v16;
LABEL_8:
  if (v3 != (char *)&v18)
    free(v3);
  v6 = (char *)v19;
  if (!(_DWORD)v20)
  {
    v7 = 0;
    if (v19 == v21)
      return v7;
    goto LABEL_26;
  }
  v7 = 0;
  v8 = v19;
  while (1)
  {
    v9 = (_QWORD *)*v8;
    v10 = *((unsigned int *)v8 + 2);
    if ((_DWORD)v10)
    {
      v11 = 8 * v10;
      v12 = (_QWORD *)*v8;
      while (*v12 != a2)
      {
        ++v12;
        v11 -= 8;
        if (!v11)
        {
          v12 = &v9[v10];
          break;
        }
      }
    }
    else
    {
      v12 = (_QWORD *)*v8;
    }
    if (v10 != v12 - v9)
      break;
    ++v7;
    v8 += 4;
    if (v8 == (_QWORD *)((char *)v19 + 32 * v20))
    {
      v7 = ((v20 - 1) & 0x7FFFFFFFFFFFFFFLL) + 1;
      break;
    }
  }
  v13 = 32 * v20;
  do
  {
    v14 = *(char **)&v6[v13 - 32];
    if (&v6[v13 - 16] != v14)
      free(v14);
    v13 -= 32;
  }
  while (v13);
  v6 = (char *)v19;
  if (v19 != v21)
LABEL_26:
    free(v6);
  return v7;
}

void mlir::tensor::CollapseShapeOp::getReassociationExprs(mlir::tensor::CollapseShapeOp *this@<X0>, _QWORD *a2@<X8>)
{
  mlir::MLIRContext *Context;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  char *v10;
  void *v11;
  unsigned int v12;
  uint64_t v13;
  char *v14;
  unsigned int v15;
  _QWORD v16[9];

  v16[8] = *MEMORY[0x24BDAC8D0];
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)this + 24));
  mlir::memref::CollapseShapeOp::getReassociationIndices(this, (uint64_t)&v11);
  mlir::convertReassociationIndicesToExprs(Context, (unsigned int **)v11, v12, (uint64_t)&v14);
  *a2 = a2 + 2;
  a2[1] = 0x400000000;
  if (v15)
  {
    llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=((uint64_t)a2, (uint64_t)&v14);
    v5 = v14;
    if (!v15)
      goto LABEL_8;
    v6 = 32 * v15;
    do
    {
      v7 = *(char **)&v5[v6 - 32];
      if (&v5[v6 - 16] != v7)
        free(v7);
      v6 -= 32;
    }
    while (v6);
  }
  v5 = v14;
LABEL_8:
  if (v5 != (char *)v16)
    free(v5);
  v8 = (char *)v11;
  if (v12)
  {
    v9 = 32 * v12;
    do
    {
      v10 = *(char **)&v8[v9 - 32];
      if (&v8[v9 - 16] != v10)
        free(v10);
      v9 -= 32;
    }
    while (v9);
    v8 = (char *)v11;
  }
  if (v8 != (char *)&v13)
    free(v8);
}

uint64_t mlir::tensor::CollapseShapeOp::inferCollapsedType(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  uint64_t Value;
  unsigned int v6;
  uint64_t *v7;
  unsigned int Kind;
  unsigned int v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  void *v23;
  uint64_t v24;
  uint64_t RHS;
  uint64_t v26;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  _QWORD v32[5];

  v32[4] = *MEMORY[0x24BDAC8D0];
  v29 = a1;
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v29);
  v30 = v32;
  v31 = 0x400000000;
  if (a3 >= 5)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, a3, 8);
LABEL_4:
    v6 = 0;
    v7 = &a2[a3];
    while (1)
    {
      v28 = *a2;
      Kind = mlir::AffineExpr::getKind((mlir::AffineExpr *)&v28);
      v9 = Kind;
      if (Kind)
      {
        v10 = (_QWORD *)(Value + 8 * v6);
        v11 = 8 * Kind;
        v12 = v10;
        while (*v12 != 0x8000000000000000)
        {
          ++v12;
          v11 -= 8;
          if (!v11)
          {
            v12 = &v10[Kind];
            break;
          }
        }
        if (Kind == v12 - v10)
        {
          if (Kind < 2)
          {
            v13 = 0;
            goto LABEL_21;
          }
          v13 = 0;
          if (__CFADD__(v6, Kind - 1))
          {
LABEL_21:
            v14 = 1;
          }
          else
          {
            v14 = 1;
            if (!(((unint64_t)Kind - 1) >> 32))
            {
              v13 = Kind & 0xFFFFFFFE;
              v15 = v6;
              v16 = v13;
              v17 = 1;
              v18 = 1;
              do
              {
                v17 *= *(_QWORD *)(Value + 8 * v15);
                v18 *= *(_QWORD *)(Value + 8 * (v15 + 1));
                v15 += 2;
                v16 -= 2;
              }
              while (v16);
              v14 = v18 * v17;
              if (v13 == Kind)
                goto LABEL_24;
            }
          }
          v19 = v6 + v13;
          v20 = Kind - v13;
          do
          {
            v14 *= *(_QWORD *)(Value + 8 * v19++);
            --v20;
          }
          while (v20);
          goto LABEL_24;
        }
        v14 = 0x8000000000000000;
      }
      else
      {
        v14 = 1;
      }
LABEL_24:
      v21 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        v21 = v31;
      }
      *((_QWORD *)v30 + v21) = v14;
      v22 = v31 + 1;
      LODWORD(v31) = v31 + 1;
      v6 += v9;
      if (++a2 == v7)
        goto LABEL_29;
    }
  }
  if (a3)
    goto LABEL_4;
  v22 = v31;
LABEL_29:
  v23 = v30;
  v24 = v22;
  RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v29);
  v26 = mlir::RankedTensorType::get((uint64_t)v23, v24, RHS, 0);
  if (v30 != v32)
    free(v30);
  return v26;
}

uint64_t mlir::tensor::ExpandShapeOp::verify(uint64_t **this)
{
  uint64_t *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  _QWORD *v11;
  const void **v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  const void ***v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  const void ***v25;
  char *v26;
  char *v27;
  __int128 v28;
  char v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  const void ***v39;
  char *v40;
  char *v41;
  __int128 v42;
  uint64_t v43;
  const void ***v44;
  char *v45;
  char *v46;
  __int128 v47;
  const char *v48;
  const void ***v49;
  char *v50;
  char *v51;
  __int128 v52;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  void *v56;
  _QWORD *v57;
  _QWORD *v58;
  void *v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD *v62;
  _QWORD *v63;
  void *v64;
  _QWORD *v65;
  uint64_t v66;
  uint64_t v67;
  void *v68;
  _QWORD *v69;
  _QWORD *v70;
  void *v71;
  _QWORD *v72;
  uint64_t v73;
  uint64_t v74;
  const char *v75;
  const char *v76;
  char *v77;
  uint64_t v78;
  char *v79;
  _QWORD *Value;
  uint64_t v81;
  uint64_t v82;
  const void ***v83;
  char *v84;
  char *v85;
  __int128 v86;
  uint64_t v87;
  const void ***v88;
  char *v89;
  char *v90;
  __int128 v91;
  const char *v92;
  const void ***v93;
  char *v94;
  char *v95;
  __int128 v96;
  uint64_t v97;
  const void ***v98;
  char *v99;
  char *v100;
  __int128 v101;
  _QWORD *v102;
  _QWORD *v103;
  void *v104;
  _QWORD *v105;
  uint64_t v106;
  uint64_t v107;
  mlir::AffineMap *v108;
  unsigned int v109;
  const char *v110;
  const char *v111;
  uint64_t v112;
  uint64_t *v113;
  const void **v114;
  uint64_t v115;
  _QWORD *v116;
  _QWORD *v117;
  void *v118;
  _QWORD *v119;
  uint64_t v120;
  uint64_t v121;
  void *v122;
  char *v123;
  uint64_t v124;
  char *v125;
  uint64_t v126;
  uint64_t *v127;
  char *v128;
  char *v129;
  __int128 v130;
  uint64_t v131;
  uint64_t *v132;
  char *v133;
  char *v134;
  __int128 v135;
  uint64_t *v136;
  char *v137;
  char *v138;
  __int128 v139;
  _QWORD *v140;
  _QWORD *v141;
  void *v142;
  _QWORD *v143;
  _QWORD *v144;
  void *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t *v149;
  char *v150;
  char *v151;
  __int128 v152;
  uint64_t v153;
  uint64_t *v154;
  char *v155;
  char *v156;
  __int128 v157;
  _QWORD *v158;
  _QWORD *v159;
  void *v160;
  _QWORD *v161;
  _QWORD *v162;
  void *v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t *v166;
  char *v167;
  char *v168;
  __int128 v169;
  uint64_t v170;
  uint64_t *v171;
  char *v172;
  char *v173;
  __int128 v174;
  uint64_t v175;
  uint64_t *v176;
  char *v177;
  char *v178;
  __int128 v179;
  uint64_t v180;
  uint64_t *v181;
  char *v182;
  char *v183;
  __int128 v184;
  unsigned int NumDims;
  uint64_t *v186;
  char *v187;
  char *v188;
  __int128 v189;
  _QWORD *v190;
  _QWORD *v191;
  void *v192;
  _QWORD *v193;
  _QWORD *v194;
  void *v195;
  uint64_t v196;
  uint64_t v197;
  _QWORD *v198;
  uint64_t v199;
  uint64_t Shape;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t *v206;
  uint64_t v207;
  uint64_t *v208;
  void *v209;
  unint64_t v210;
  unint64_t v211;
  unint64_t v212;
  BOOL v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  BOOL v217;
  unint64_t v218;
  BOOL v219;
  unint64_t v220;
  unint64_t v221;
  unint64_t v222;
  unint64_t v223;
  unint64_t v224;
  BOOL v225;
  unint64_t v226;
  BOOL v227;
  unint64_t v228;
  unint64_t v229;
  unint64_t v230;
  unint64_t v231;
  BOOL v232;
  unint64_t v233;
  BOOL v234;
  unint64_t v235;
  BOOL v236;
  unint64_t v237;
  BOOL v238;
  int64_t v239;
  int64_t v240;
  int64_t v241;
  int64_t v242;
  int64_t v243;
  int64_t v244;
  int64_t v245;
  int64_t v246;
  int64_t v247;
  int64_t v248;
  int64_t v249;
  int64_t v250;
  int64_t v251;
  int64_t v252;
  int64_t v253;
  int64_t v254;
  int64_t v255;
  int64_t v256;
  int64_t v257;
  int64_t v258;
  unint64_t v259;
  unint64_t v260;
  uint64_t *v261;
  int v262;
  const void **v263;
  const char *v264;
  uint64_t v265;
  __int16 v266;
  const void **v267;
  _QWORD *v268;
  uint64_t *v269;
  uint64_t **v270;
  uint64_t *v271;
  uint64_t v272;
  const char *v273;
  uint64_t v274;
  mlir::AffineMap *v275;
  unsigned int v276;
  _BYTE v277[16];
  __int16 v278;
  void *v279;
  unsigned int v280;
  uint64_t v281;
  void *v282;
  unsigned int v283;
  unsigned int v284;
  _BYTE v285[96];
  void *v286;
  _QWORD *v287;
  void *__p;
  _QWORD *v289;
  char v290;
  uint64_t v291;

  v291 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v260 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v3 = *((_DWORD *)v2 + 9);
  v4 = (uint64_t)(v2 - 2);
  if (v3)
    v5 = v4;
  else
    v5 = 0;
  v259 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v260);
  v7 = v6;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v259);
  if (v7 >= v8)
  {
    v275 = (mlir::AffineMap *)"expected rank expansion, but found source rank ";
    v278 = 259;
    mlir::OpState::emitOpError(this, (const void ***)&v275, (uint64_t)&v279);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v260);
    if (v279)
    {
      LODWORD(v263) = 2;
      v264 = v38;
      v39 = &v263;
      v40 = (char *)v282;
      if (v283 >= v284)
      {
        v210 = v283 + 1;
        if (v282 <= &v263 && (char *)v282 + 24 * v283 > (char *)&v263)
        {
          v239 = (char *)&v263 - (_BYTE *)v282;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v210, 24);
          v40 = (char *)v282;
          v39 = (const void ***)((char *)v282 + v239);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v210, 24);
          v39 = &v263;
          v40 = (char *)v282;
        }
      }
      v41 = &v40[24 * v283];
      v42 = *(_OWORD *)v39;
      *((_QWORD *)v41 + 2) = v39[2];
      *(_OWORD *)v41 = v42;
      v43 = ++v283;
      if (v279)
      {
        LODWORD(v263) = 3;
        v264 = " >= result rank ";
        v265 = 16;
        v44 = &v263;
        v45 = (char *)v282;
        if (v43 >= v284)
        {
          v212 = v43 + 1;
          v213 = (char *)v282 + 24 * v43 > (char *)&v263;
          if (v282 <= &v263 && v213)
          {
            v241 = (char *)&v263 - (_BYTE *)v282;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v212, 24);
            v45 = (char *)v282;
            v44 = (const void ***)((char *)v282 + v241);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v212, 24);
            v44 = &v263;
            v45 = (char *)v282;
          }
        }
        v46 = &v45[24 * v283];
        v47 = *(_OWORD *)v44;
        *((_QWORD *)v46 + 2) = v44[2];
        *(_OWORD *)v46 = v47;
        ++v283;
      }
    }
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v259);
    if (v279)
    {
      LODWORD(v263) = 2;
      v264 = v48;
      v49 = &v263;
      v50 = (char *)v282;
      if (v283 >= v284)
      {
        v211 = v283 + 1;
        if (v282 <= &v263 && (char *)v282 + 24 * v283 > (char *)&v263)
        {
          v240 = (char *)&v263 - (_BYTE *)v282;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v211, 24);
          v50 = (char *)v282;
          v49 = (const void ***)((char *)v282 + v240);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v211, 24);
          v49 = &v263;
          v50 = (char *)v282;
        }
      }
      v51 = &v50[24 * v283];
      v52 = *(_OWORD *)v49;
      *((_QWORD *)v51 + 2) = v49[2];
      *(_OWORD *)v51 = v52;
      ++v283;
    }
    v53 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
    if (v279)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
    if (v290)
    {
      v54 = __p;
      if (__p)
      {
        v55 = v289;
        v56 = __p;
        if (v289 != __p)
        {
          do
            v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
          while (v55 != v54);
          v56 = __p;
        }
        v289 = v54;
        operator delete(v56);
      }
      v57 = v286;
      if (v286)
      {
        v58 = v287;
        v59 = v286;
        if (v287 != v286)
        {
          do
          {
            v61 = *--v58;
            v60 = v61;
            *v58 = 0;
            if (v61)
              MEMORY[0x20BD002D4](v60, 0x1000C8077774924);
          }
          while (v58 != v57);
          v59 = v286;
        }
        v287 = v57;
        operator delete(v59);
      }
      v68 = v282;
      if (v282 != v285)
        goto LABEL_189;
    }
    return v53;
  }
  v9 = *this;
  if (*((_DWORD *)*this + 9))
    v10 = (uint64_t)(*this - 2);
  else
    v10 = 0;
  v11 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v12 = (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v261 = v9;
  v268 = v11;
  v269 = v9;
  v267 = v12;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v268);
  v14 = v13;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v267);
  if (v14 < v15)
  {
    v275 = (mlir::AffineMap *)"expected the type ";
    v278 = 259;
    mlir::OpState::emitOpError(&v269, (const void ***)&v275, (uint64_t)&v279);
    if (v279)
    {
      v16 = &v263;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v263, (uint64_t)v268);
      v17 = (char *)v282;
      if (v283 >= v284)
      {
        v214 = v283 + 1;
        if (v282 <= &v263 && (char *)v282 + 24 * v283 > (char *)&v263)
        {
          v242 = (char *)&v263 - (_BYTE *)v282;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v214, 24);
          v17 = (char *)v282;
          v16 = (const void ***)((char *)v282 + v242);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v214, 24);
          v16 = &v263;
          v17 = (char *)v282;
        }
      }
      v18 = &v17[24 * v283];
      v19 = *(_OWORD *)v16;
      *((_QWORD *)v18 + 2) = v16[2];
      *(_OWORD *)v18 = v19;
      v20 = ++v283;
      if (v279)
      {
        LODWORD(v263) = 3;
        v264 = " to have higher rank than the type = ";
        v265 = 37;
        v21 = &v263;
        v22 = (char *)v282;
        if (v20 >= v284)
        {
          v216 = v20 + 1;
          v217 = (char *)v282 + 24 * v20 > (char *)&v263;
          if (v282 <= &v263 && v217)
          {
            v244 = (char *)&v263 - (_BYTE *)v282;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v216, 24);
            v22 = (char *)v282;
            v21 = (const void ***)((char *)v282 + v244);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v216, 24);
            v21 = &v263;
            v22 = (char *)v282;
          }
        }
        v23 = &v22[24 * v283];
        v24 = *(_OWORD *)v21;
        *((_QWORD *)v23 + 2) = v21[2];
        *(_OWORD *)v23 = v24;
        ++v283;
        if (v279)
        {
          v25 = &v263;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v263, (uint64_t)v267);
          v26 = (char *)v282;
          if (v283 >= v284)
          {
            v220 = v283 + 1;
            if (v282 <= &v263 && (char *)v282 + 24 * v283 > (char *)&v263)
            {
              v246 = (char *)&v263 - (_BYTE *)v282;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v220, 24);
              v26 = (char *)v282;
              v25 = (const void ***)((char *)v282 + v246);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v220, 24);
              v25 = &v263;
              v26 = (char *)v282;
            }
          }
          v27 = &v26[24 * v283];
          v28 = *(_OWORD *)v25;
          *((_QWORD *)v27 + 2) = v25[2];
          *(_OWORD *)v27 = v28;
          ++v283;
        }
      }
    }
    v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
    if (v279)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
    if (v290)
    {
      v30 = __p;
      if (__p)
      {
        v31 = v289;
        v32 = __p;
        if (v289 != __p)
        {
          do
            v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
          while (v31 != v30);
          v32 = __p;
        }
        v289 = v30;
        operator delete(v32);
      }
      v33 = v286;
      if (v286)
      {
        v34 = v287;
        v35 = v286;
        if (v287 == v286)
          goto LABEL_148;
        do
        {
          v37 = *--v34;
          v36 = v37;
          *v34 = 0;
          if (v37)
            MEMORY[0x20BD002D4](v36, 0x1000C8077774924);
        }
        while (v34 != v33);
LABEL_147:
        v35 = v286;
LABEL_148:
        v287 = v33;
        operator delete(v35);
        goto LABEL_149;
      }
      goto LABEL_149;
    }
    goto LABEL_151;
  }
  if (!v14)
  {
    v275 = (mlir::AffineMap *)"expected non-zero memref ranks";
    v278 = 259;
    mlir::OpState::emitOpError(&v269, (const void ***)&v275, (uint64_t)&v279);
    v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
    if (v279)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
    if (v290)
    {
      v69 = __p;
      if (__p)
      {
        v70 = v289;
        v71 = __p;
        if (v289 != __p)
        {
          do
            v70 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v70 - 1);
          while (v70 != v69);
          v71 = __p;
        }
        v289 = v69;
        operator delete(v71);
      }
      v33 = v286;
      if (v286)
      {
        v72 = v287;
        v35 = v286;
        if (v287 == v286)
          goto LABEL_148;
        do
        {
          v74 = *--v72;
          v73 = v74;
          *v72 = 0;
          if (v74)
            MEMORY[0x20BD002D4](v73, 0x1000C8077774924);
        }
        while (v72 != v33);
        goto LABEL_147;
      }
      goto LABEL_149;
    }
    goto LABEL_151;
  }
  if (v14 == v15)
  {
    v275 = (mlir::AffineMap *)"expected to collapse or expand dims";
    v278 = 259;
    mlir::OpState::emitOpError(&v269, (const void ***)&v275, (uint64_t)&v279);
    v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
    if (v279)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
    if (v290)
    {
      v62 = __p;
      if (__p)
      {
        v63 = v289;
        v64 = __p;
        if (v289 != __p)
        {
          do
            v63 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v63 - 1);
          while (v63 != v62);
          v64 = __p;
        }
        v289 = v62;
        operator delete(v64);
      }
      v33 = v286;
      if (v286)
      {
        v65 = v287;
        v35 = v286;
        if (v287 == v286)
          goto LABEL_148;
        do
        {
          v67 = *--v65;
          v66 = v67;
          *v65 = 0;
          if (v67)
            MEMORY[0x20BD002D4](v66, 0x1000C8077774924);
        }
        while (v65 != v33);
        goto LABEL_147;
      }
      goto LABEL_149;
    }
    goto LABEL_151;
  }
  if (v15)
  {
    v75 = (const char *)v15;
    v279 = (void *)v9[2 * (((unint64_t)*((unsigned int *)v9 + 11) >> 23) & 1) + 8];
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v279);
    if (v75 != v76)
    {
      v275 = (mlir::AffineMap *)"expected rank of the collapsed type(";
      v278 = 259;
      mlir::OpState::emitOpError(&v269, (const void ***)&v275, (uint64_t)&v279);
      if (v279)
      {
        LODWORD(v263) = 5;
        v264 = v75;
        v83 = &v263;
        v84 = (char *)v282;
        if (v283 >= v284)
        {
          v222 = v283 + 1;
          if (v282 <= &v263 && (char *)v282 + 24 * v283 > (char *)&v263)
          {
            v248 = (char *)&v263 - (_BYTE *)v282;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v222, 24);
            v84 = (char *)v282;
            v83 = (const void ***)((char *)v282 + v248);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v222, 24);
            v83 = &v263;
            v84 = (char *)v282;
          }
        }
        v85 = &v84[24 * v283];
        v86 = *(_OWORD *)v83;
        *((_QWORD *)v85 + 2) = v83[2];
        *(_OWORD *)v85 = v86;
        v87 = ++v283;
        if (v279)
        {
          LODWORD(v263) = 3;
          v264 = ") to be the number of reassociation maps(";
          v265 = 41;
          v88 = &v263;
          v89 = (char *)v282;
          if (v87 >= v284)
          {
            v224 = v87 + 1;
            v225 = (char *)v282 + 24 * v87 > (char *)&v263;
            if (v282 <= &v263 && v225)
            {
              v250 = (char *)&v263 - (_BYTE *)v282;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v224, 24);
              v89 = (char *)v282;
              v88 = (const void ***)((char *)v282 + v250);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v224, 24);
              v88 = &v263;
              v89 = (char *)v282;
            }
          }
          v90 = &v89[24 * v283];
          v91 = *(_OWORD *)v88;
          *((_QWORD *)v90 + 2) = v88[2];
          *(_OWORD *)v90 = v91;
          ++v283;
        }
      }
      v272 = v269[2 * (((unint64_t)*((unsigned int *)v269 + 11) >> 23) & 1) + 8];
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v272);
      if (v279)
      {
        LODWORD(v263) = 5;
        v264 = v92;
        v93 = &v263;
        v94 = (char *)v282;
        if (v283 >= v284)
        {
          v223 = v283 + 1;
          if (v282 <= &v263 && (char *)v282 + 24 * v283 > (char *)&v263)
          {
            v249 = (char *)&v263 - (_BYTE *)v282;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v223, 24);
            v94 = (char *)v282;
            v93 = (const void ***)((char *)v282 + v249);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v223, 24);
            v93 = &v263;
            v94 = (char *)v282;
          }
        }
        v95 = &v94[24 * v283];
        v96 = *(_OWORD *)v93;
        *((_QWORD *)v95 + 2) = v93[2];
        *(_OWORD *)v95 = v96;
        v97 = ++v283;
        if (v279)
        {
          LODWORD(v263) = 3;
          v264 = ")";
          v265 = 1;
          v98 = &v263;
          v99 = (char *)v282;
          if (v97 >= v284)
          {
            v226 = v97 + 1;
            v227 = (char *)v282 + 24 * v97 > (char *)&v263;
            if (v282 <= &v263 && v227)
            {
              v251 = (char *)&v263 - (_BYTE *)v282;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v226, 24);
              v99 = (char *)v282;
              v98 = (const void ***)((char *)v282 + v251);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v226, 24);
              v98 = &v263;
              v99 = (char *)v282;
            }
          }
          v100 = &v99[24 * v283];
          v101 = *(_OWORD *)v98;
          *((_QWORD *)v100 + 2) = v98[2];
          *(_OWORD *)v100 = v101;
          ++v283;
        }
      }
      v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
      if (v279)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
      if (v290)
      {
        v102 = __p;
        if (__p)
        {
          v103 = v289;
          v104 = __p;
          if (v289 != __p)
          {
            do
              v103 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v103 - 1);
            while (v103 != v102);
            v104 = __p;
          }
          v289 = v102;
          operator delete(v104);
        }
        v33 = v286;
        if (v286)
        {
          v105 = v287;
          v35 = v286;
          if (v287 == v286)
            goto LABEL_148;
          do
          {
            v107 = *--v105;
            v106 = v107;
            *v105 = 0;
            if (v107)
              MEMORY[0x20BD002D4](v106, 0x1000C8077774924);
          }
          while (v105 != v33);
          goto LABEL_147;
        }
        goto LABEL_149;
      }
      goto LABEL_151;
    }
    mlir::tensor::CollapseShapeOp::getReassociationExprs((mlir::tensor::CollapseShapeOp *)&v269, &v279);
    mlir::getSymbolLessAffineMaps((uint64_t)v279, v280, (uint64_t)&v275);
    v77 = (char *)v279;
    if (v280)
    {
      v78 = 32 * v280;
      do
      {
        v79 = *(char **)&v77[v78 - 32];
        if (&v77[v78 - 16] != v79)
          free(v79);
        v78 -= 32;
      }
      while (v78);
      v77 = (char *)v279;
    }
    if (v77 != (char *)&v281)
      free(v77);
    v108 = v275;
    v109 = v276;
    if (v276)
    {
      v110 = 0;
      v111 = (const char *)v14;
      v112 = 8 * v276;
      while (mlir::AffineMap::getNumDims(v108) == v14)
      {
        ++v110;
        v108 = (mlir::AffineMap *)((char *)v108 + 8);
        v112 -= 8;
        if (!v112)
        {
          v108 = v275;
          v109 = v276;
          goto LABEL_130;
        }
      }
      v263 = (const void **)"expected reassociation map #";
      v266 = 259;
      mlir::OpState::emitOpError(&v269, &v263, (uint64_t)&v279);
      if (v279)
      {
        LODWORD(v272) = 5;
        v273 = v110;
        v166 = &v272;
        v167 = (char *)v282;
        if (v283 >= v284)
        {
          v229 = v283 + 1;
          if (v282 <= &v272 && (char *)v282 + 24 * v283 > (char *)&v272)
          {
            v253 = (char *)&v272 - (_BYTE *)v282;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v229, 24);
            v167 = (char *)v282;
            v166 = (uint64_t *)((char *)v282 + v253);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v229, 24);
            v166 = &v272;
            v167 = (char *)v282;
          }
        }
        v168 = &v167[24 * v283];
        v169 = *(_OWORD *)v166;
        *((_QWORD *)v168 + 2) = v166[2];
        *(_OWORD *)v168 = v169;
        v170 = ++v283;
        if (v279)
        {
          LODWORD(v272) = 3;
          v273 = " of same rank as expanded memref(";
          v274 = 33;
          v171 = &v272;
          v172 = (char *)v282;
          if (v170 >= v284)
          {
            v233 = v170 + 1;
            v234 = (char *)v282 + 24 * v170 > (char *)&v272;
            if (v282 <= &v272 && v234)
            {
              v256 = (char *)&v272 - (_BYTE *)v282;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v233, 24);
              v172 = (char *)v282;
              v171 = (uint64_t *)((char *)v282 + v256);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v233, 24);
              v171 = &v272;
              v172 = (char *)v282;
            }
          }
          v173 = &v172[24 * v283];
          v174 = *(_OWORD *)v171;
          *((_QWORD *)v173 + 2) = v171[2];
          *(_OWORD *)v173 = v174;
          v175 = ++v283;
          if (v279)
          {
            LODWORD(v272) = 5;
            v273 = v111;
            v176 = &v272;
            v177 = (char *)v282;
            if (v175 >= v284)
            {
              v235 = v175 + 1;
              v236 = (char *)v282 + 24 * v175 > (char *)&v272;
              if (v282 <= &v272 && v236)
              {
                v257 = (char *)&v272 - (_BYTE *)v282;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v235, 24);
                v177 = (char *)v282;
                v176 = (uint64_t *)((char *)v282 + v257);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v235, 24);
                v176 = &v272;
                v177 = (char *)v282;
              }
            }
            v178 = &v177[24 * v283];
            v179 = *(_OWORD *)v176;
            *((_QWORD *)v178 + 2) = v176[2];
            *(_OWORD *)v178 = v179;
            v180 = ++v283;
            if (v279)
            {
              LODWORD(v272) = 3;
              v273 = "), but got ";
              v274 = 11;
              v181 = &v272;
              v182 = (char *)v282;
              if (v180 >= v284)
              {
                v237 = v180 + 1;
                v238 = (char *)v282 + 24 * v180 > (char *)&v272;
                if (v282 <= &v272 && v238)
                {
                  v258 = (char *)&v272 - (_BYTE *)v282;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v237, 24);
                  v182 = (char *)v282;
                  v181 = (uint64_t *)((char *)v282 + v258);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v237, 24);
                  v181 = &v272;
                  v182 = (char *)v282;
                }
              }
              v183 = &v182[24 * v283];
              v184 = *(_OWORD *)v181;
              *((_QWORD *)v183 + 2) = v181[2];
              *(_OWORD *)v183 = v184;
              ++v283;
            }
          }
        }
      }
      NumDims = mlir::AffineMap::getNumDims(v108);
      if (v279)
      {
        LODWORD(v272) = 5;
        v273 = (const char *)NumDims;
        v186 = &v272;
        v187 = (char *)v282;
        if (v283 >= v284)
        {
          v230 = v283 + 1;
          if (v282 <= &v272 && (char *)v282 + 24 * v283 > (char *)&v272)
          {
            v254 = (char *)&v272 - (_BYTE *)v282;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v230, 24);
            v187 = (char *)v282;
            v186 = (uint64_t *)((char *)v282 + v254);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v230, 24);
            v186 = &v272;
            v187 = (char *)v282;
          }
        }
        v188 = &v187[24 * v283];
        v189 = *(_OWORD *)v186;
        *((_QWORD *)v188 + 2) = v186[2];
        *(_OWORD *)v188 = v189;
        ++v283;
      }
      v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
      if (v279)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
      if (!v290)
        goto LABEL_252;
      v190 = __p;
      if (__p)
      {
        v191 = v289;
        v192 = __p;
        if (v289 != __p)
        {
          do
            v191 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v191 - 1);
          while (v191 != v190);
          v192 = __p;
        }
        v289 = v190;
        operator delete(v192);
      }
      v193 = v286;
      if (v286)
      {
        v194 = v287;
        v195 = v286;
        if (v287 != v286)
        {
          do
          {
            v197 = *--v194;
            v196 = v197;
            *v194 = 0;
            if (v197)
              MEMORY[0x20BD002D4](v196, 0x1000C8077774924);
          }
          while (v194 != v193);
          v195 = v286;
        }
        v287 = v193;
        operator delete(v195);
      }
      v209 = v282;
      if (v282 == v285)
      {
LABEL_252:
        v122 = v275;
        if (v275 != (mlir::AffineMap *)v277)
        {
LABEL_150:
          free(v122);
          goto LABEL_151;
        }
        goto LABEL_151;
      }
    }
    else
    {
LABEL_130:
      v262 = 0;
      if ((mlir::isReassociationValid(v108, v109, &v262) & 1) != 0)
      {
        v113 = v269;
        v114 = v267;
        if (v267)
          v115 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v267 + 8);
        else
          v115 = 0;
        v198 = v268;
        if (v268)
          v199 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v268 + 8);
        else
          v199 = 0;
        v271 = v113;
        v272 = (uint64_t)v198;
        v263 = v114;
        v264 = (const char *)v115;
        v273 = (const char *)v199;
        v270 = &v271;
        Shape = mlir::ShapedType::getShape((mlir::ShapedType *)&v263);
        v202 = v201;
        v203 = mlir::ShapedType::getShape((mlir::ShapedType *)&v272);
        v205 = v204;
        mlir::memref::CollapseShapeOp::getReassociationIndices((mlir::memref::CollapseShapeOp *)&v271, (uint64_t)&v279);
        v29 = mlir::reshapeLikeShapesAreCompatible((uint64_t (*)(uint64_t, _QWORD **))llvm::function_ref<mlir::LogicalResult ()(llvm::Twine const&)>::callback_fn<mlir::LogicalResult mlir::verifyReshapeLikeShapes<mlir::tensor::ExpandShapeOp>(mlir::tensor::ExpandShapeOp,mlir::ShapedType,mlir::ShapedType,BOOL)::{lambda(llvm::Twine const&)#1}>, (uint64_t)&v270, Shape, v202, v203, v205, (uint64_t)v279, v280, 1);
        v206 = (uint64_t *)v279;
        if (v280)
        {
          v207 = 4 * v280;
          do
          {
            v208 = (uint64_t *)v206[v207 - 4];
            if (&v206[v207 - 2] != v208)
              free(v208);
            v207 -= 4;
          }
          while (v207 * 8);
          v206 = (uint64_t *)v279;
        }
        if (v206 == &v281)
          goto LABEL_252;
        v209 = v206;
      }
      else
      {
        v263 = (const void **)"expected reassociation map #";
        v266 = 259;
        mlir::OpState::emitOpError(&v269, &v263, (uint64_t)&v279);
        if (v279)
        {
          LODWORD(v272) = 2;
          v273 = (const char *)v262;
          v149 = &v272;
          v150 = (char *)v282;
          if (v283 >= v284)
          {
            v228 = v283 + 1;
            if (v282 <= &v272 && (char *)v282 + 24 * v283 > (char *)&v272)
            {
              v252 = (char *)&v272 - (_BYTE *)v282;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v228, 24);
              v150 = (char *)v282;
              v149 = (uint64_t *)((char *)v282 + v252);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v228, 24);
              v149 = &v272;
              v150 = (char *)v282;
            }
          }
          v151 = &v150[24 * v283];
          v152 = *(_OWORD *)v149;
          *((_QWORD *)v151 + 2) = v149[2];
          *(_OWORD *)v151 = v152;
          v153 = ++v283;
          if (v279)
          {
            LODWORD(v272) = 3;
            v273 = " to be valid and contiguous";
            v274 = 27;
            v154 = &v272;
            v155 = (char *)v282;
            if (v153 >= v284)
            {
              v231 = v153 + 1;
              v232 = (char *)v282 + 24 * v153 > (char *)&v272;
              if (v282 <= &v272 && v232)
              {
                v255 = (char *)&v272 - (_BYTE *)v282;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v231, 24);
                v155 = (char *)v282;
                v154 = (uint64_t *)((char *)v282 + v255);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v231, 24);
                v154 = &v272;
                v155 = (char *)v282;
              }
            }
            v156 = &v155[24 * v283];
            v157 = *(_OWORD *)v154;
            *((_QWORD *)v156 + 2) = v154[2];
            *(_OWORD *)v156 = v157;
            ++v283;
          }
        }
        v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
        if (v279)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
        if (!v290)
          goto LABEL_252;
        v158 = __p;
        if (__p)
        {
          v159 = v289;
          v160 = __p;
          if (v289 != __p)
          {
            do
              v159 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v159 - 1);
            while (v159 != v158);
            v160 = __p;
          }
          v289 = v158;
          operator delete(v160);
        }
        v161 = v286;
        if (v286)
        {
          v162 = v287;
          v163 = v286;
          if (v287 != v286)
          {
            do
            {
              v165 = *--v162;
              v164 = v165;
              *v162 = 0;
              if (v165)
                MEMORY[0x20BD002D4](v164, 0x1000C8077774924);
            }
            while (v162 != v161);
            v163 = v286;
          }
          v287 = v161;
          operator delete(v163);
        }
        v209 = v282;
        if (v282 == v285)
          goto LABEL_252;
      }
    }
    free(v209);
    goto LABEL_252;
  }
  Value = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v268);
  if (v81)
  {
    v82 = 8 * v81;
    while (*Value == 1)
    {
      ++Value;
      v82 -= 8;
      if (!v82)
        goto LABEL_152;
    }
    v275 = (mlir::AffineMap *)"invalid to reshape tensor/memref with non-unit extent dimensions to zero-rank tensor/memref";
    v278 = 259;
    mlir::OpState::emitOpError(&v269, (const void ***)&v275, (uint64_t)&v279);
    v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
    if (v279)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
    if (v290)
    {
      v116 = __p;
      if (__p)
      {
        v117 = v289;
        v118 = __p;
        if (v289 != __p)
        {
          do
            v117 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v117 - 1);
          while (v117 != v116);
          v118 = __p;
        }
        v289 = v116;
        operator delete(v118);
      }
      v33 = v286;
      if (v286)
      {
        v119 = v287;
        v35 = v286;
        if (v287 == v286)
          goto LABEL_148;
        do
        {
          v121 = *--v119;
          v120 = v121;
          *v119 = 0;
          if (v121)
            MEMORY[0x20BD002D4](v120, 0x1000C8077774924);
        }
        while (v119 != v33);
        goto LABEL_147;
      }
LABEL_149:
      v122 = v282;
      if (v282 == v285)
        goto LABEL_151;
      goto LABEL_150;
    }
LABEL_151:
    if (!v29)
      return 0;
  }
LABEL_152:
  mlir::tensor::CollapseShapeOp::getReassociationExprs((mlir::tensor::CollapseShapeOp *)&v261, &v279);
  mlir::getSymbolLessAffineMaps((uint64_t)v279, v280, (uint64_t)&v275);
  v123 = (char *)v279;
  if (v280)
  {
    v124 = 32 * v280;
    do
    {
      v125 = *(char **)&v123[v124 - 32];
      if (&v123[v124 - 16] != v125)
        free(v125);
      v124 -= 32;
    }
    while (v124);
    v123 = (char *)v279;
  }
  if (v123 != (char *)&v281)
    free(v123);
  v126 = mlir::tensor::CollapseShapeOp::inferCollapsedType((uint64_t)v11, (uint64_t *)v275, v276);
  if (mlir::tensor::isSameTypeWithoutEncoding((uint64_t)v12, v126))
  {
    v53 = 1;
  }
  else
  {
    v263 = (const void **)"expected collapsed type to be ";
    v266 = 259;
    mlir::OpState::emitOpError(&v261, &v263, (uint64_t)&v279);
    if (v279)
    {
      v127 = &v272;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v272, v126);
      v128 = (char *)v282;
      if (v283 >= v284)
      {
        v215 = v283 + 1;
        if (v282 <= &v272 && (char *)v282 + 24 * v283 > (char *)&v272)
        {
          v243 = (char *)&v272 - (_BYTE *)v282;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v215, 24);
          v128 = (char *)v282;
          v127 = (uint64_t *)((char *)v282 + v243);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v215, 24);
          v127 = &v272;
          v128 = (char *)v282;
        }
      }
      v129 = &v128[24 * v283];
      v130 = *(_OWORD *)v127;
      *((_QWORD *)v129 + 2) = v127[2];
      *(_OWORD *)v129 = v130;
      v131 = ++v283;
      if (v279)
      {
        LODWORD(v272) = 3;
        v273 = ", but got ";
        v274 = 10;
        v132 = &v272;
        v133 = (char *)v282;
        if (v131 >= v284)
        {
          v218 = v131 + 1;
          v219 = (char *)v282 + 24 * v131 > (char *)&v272;
          if (v282 <= &v272 && v219)
          {
            v245 = (char *)&v272 - (_BYTE *)v282;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v218, 24);
            v133 = (char *)v282;
            v132 = (uint64_t *)((char *)v282 + v245);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v218, 24);
            v132 = &v272;
            v133 = (char *)v282;
          }
        }
        v134 = &v133[24 * v283];
        v135 = *(_OWORD *)v132;
        *((_QWORD *)v134 + 2) = v132[2];
        *(_OWORD *)v134 = v135;
        ++v283;
        if (v279)
        {
          v136 = &v272;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v272, (uint64_t)v12);
          v137 = (char *)v282;
          if (v283 >= v284)
          {
            v221 = v283 + 1;
            if (v282 <= &v272 && (char *)v282 + 24 * v283 > (char *)&v272)
            {
              v247 = (char *)&v272 - (_BYTE *)v282;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v221, 24);
              v137 = (char *)v282;
              v136 = (uint64_t *)((char *)v282 + v247);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v221, 24);
              v136 = &v272;
              v137 = (char *)v282;
            }
          }
          v138 = &v137[24 * v283];
          v139 = *(_OWORD *)v136;
          *((_QWORD *)v138 + 2) = v136[2];
          *(_OWORD *)v138 = v139;
          ++v283;
        }
      }
    }
    v53 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
    if (v279)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
    if (v290)
    {
      v140 = __p;
      if (__p)
      {
        v141 = v289;
        v142 = __p;
        if (v289 != __p)
        {
          do
            v141 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v141 - 1);
          while (v141 != v140);
          v142 = __p;
        }
        v289 = v140;
        operator delete(v142);
      }
      v143 = v286;
      if (v286)
      {
        v144 = v287;
        v145 = v286;
        if (v287 != v286)
        {
          do
          {
            v147 = *--v144;
            v146 = v147;
            *v144 = 0;
            if (v147)
              MEMORY[0x20BD002D4](v146, 0x1000C8077774924);
          }
          while (v144 != v143);
          v145 = v286;
        }
        v287 = v143;
        operator delete(v145);
      }
      if (v282 != v285)
        free(v282);
    }
  }
  v68 = v275;
  if (v275 != (mlir::AffineMap *)v277)
LABEL_189:
    free(v68);
  return v53;
}

uint64_t mlir::tensor::CollapseShapeOp::verify(uint64_t **this)
{
  uint64_t *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  const void **v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  const void ***v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  const void ***v25;
  char *v26;
  char *v27;
  __int128 v28;
  char v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  const void ***v39;
  char *v40;
  char *v41;
  __int128 v42;
  uint64_t v43;
  const void ***v44;
  char *v45;
  char *v46;
  __int128 v47;
  const char *v48;
  const void ***v49;
  char *v50;
  char *v51;
  __int128 v52;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  void *v56;
  _QWORD *v57;
  _QWORD *v58;
  void *v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD *v62;
  _QWORD *v63;
  void *v64;
  _QWORD *v65;
  uint64_t v66;
  uint64_t v67;
  void *v68;
  _QWORD *v69;
  _QWORD *v70;
  void *v71;
  _QWORD *v72;
  uint64_t v73;
  uint64_t v74;
  const char *v75;
  const char *v76;
  char *v77;
  uint64_t v78;
  char *v79;
  _QWORD *Value;
  uint64_t v81;
  uint64_t v82;
  const void ***v83;
  char *v84;
  char *v85;
  __int128 v86;
  uint64_t v87;
  const void ***v88;
  char *v89;
  char *v90;
  __int128 v91;
  const char *v92;
  const void ***v93;
  char *v94;
  char *v95;
  __int128 v96;
  uint64_t v97;
  const void ***v98;
  char *v99;
  char *v100;
  __int128 v101;
  _QWORD *v102;
  _QWORD *v103;
  void *v104;
  _QWORD *v105;
  uint64_t v106;
  uint64_t v107;
  mlir::AffineMap *v108;
  unsigned int v109;
  const char *v110;
  const char *v111;
  uint64_t v112;
  uint64_t *v113;
  const void **v114;
  uint64_t v115;
  _QWORD *v116;
  _QWORD *v117;
  void *v118;
  _QWORD *v119;
  uint64_t v120;
  uint64_t v121;
  void *v122;
  char *v123;
  uint64_t v124;
  char *v125;
  uint64_t v126;
  uint64_t *v127;
  char *v128;
  char *v129;
  __int128 v130;
  uint64_t v131;
  uint64_t *v132;
  char *v133;
  char *v134;
  __int128 v135;
  uint64_t *v136;
  char *v137;
  char *v138;
  __int128 v139;
  _QWORD *v140;
  _QWORD *v141;
  void *v142;
  _QWORD *v143;
  _QWORD *v144;
  void *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t *v149;
  char *v150;
  char *v151;
  __int128 v152;
  uint64_t v153;
  uint64_t *v154;
  char *v155;
  char *v156;
  __int128 v157;
  _QWORD *v158;
  _QWORD *v159;
  void *v160;
  _QWORD *v161;
  _QWORD *v162;
  void *v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t *v166;
  char *v167;
  char *v168;
  __int128 v169;
  uint64_t v170;
  uint64_t *v171;
  char *v172;
  char *v173;
  __int128 v174;
  uint64_t v175;
  uint64_t *v176;
  char *v177;
  char *v178;
  __int128 v179;
  uint64_t v180;
  uint64_t *v181;
  char *v182;
  char *v183;
  __int128 v184;
  unsigned int NumDims;
  uint64_t *v186;
  char *v187;
  char *v188;
  __int128 v189;
  _QWORD *v190;
  _QWORD *v191;
  void *v192;
  _QWORD *v193;
  _QWORD *v194;
  void *v195;
  uint64_t v196;
  uint64_t v197;
  _QWORD *v198;
  uint64_t v199;
  uint64_t Shape;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t *v206;
  uint64_t v207;
  uint64_t *v208;
  void *v209;
  unint64_t v210;
  unint64_t v211;
  unint64_t v212;
  BOOL v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  BOOL v217;
  unint64_t v218;
  BOOL v219;
  unint64_t v220;
  unint64_t v221;
  unint64_t v222;
  unint64_t v223;
  unint64_t v224;
  BOOL v225;
  unint64_t v226;
  BOOL v227;
  unint64_t v228;
  unint64_t v229;
  unint64_t v230;
  unint64_t v231;
  BOOL v232;
  unint64_t v233;
  BOOL v234;
  unint64_t v235;
  BOOL v236;
  unint64_t v237;
  BOOL v238;
  int64_t v239;
  int64_t v240;
  int64_t v241;
  int64_t v242;
  int64_t v243;
  int64_t v244;
  int64_t v245;
  int64_t v246;
  int64_t v247;
  int64_t v248;
  int64_t v249;
  int64_t v250;
  int64_t v251;
  int64_t v252;
  int64_t v253;
  int64_t v254;
  int64_t v255;
  int64_t v256;
  int64_t v257;
  int64_t v258;
  unint64_t v259;
  unint64_t v260;
  uint64_t *v261;
  int v262;
  const void **v263;
  const char *v264;
  uint64_t v265;
  __int16 v266;
  const void **v267;
  _QWORD *v268;
  uint64_t *v269;
  uint64_t **v270;
  uint64_t *v271;
  uint64_t v272;
  const char *v273;
  uint64_t v274;
  mlir::AffineMap *v275;
  unsigned int v276;
  _BYTE v277[16];
  __int16 v278;
  void *v279;
  unsigned int v280;
  uint64_t v281;
  void *v282;
  unsigned int v283;
  unsigned int v284;
  _BYTE v285[96];
  void *v286;
  _QWORD *v287;
  void *__p;
  _QWORD *v289;
  char v290;
  uint64_t v291;

  v291 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v260 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v3 = *((_DWORD *)v2 + 9);
  v4 = (uint64_t)(v2 - 2);
  if (v3)
    v5 = v4;
  else
    v5 = 0;
  v259 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v260);
  v7 = v6;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v259);
  if (v7 <= v8)
  {
    v275 = (mlir::AffineMap *)"expected rank reduction, but found source rank ";
    v278 = 259;
    mlir::OpState::emitOpError(this, (const void ***)&v275, (uint64_t)&v279);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v260);
    if (v279)
    {
      LODWORD(v263) = 2;
      v264 = v38;
      v39 = &v263;
      v40 = (char *)v282;
      if (v283 >= v284)
      {
        v210 = v283 + 1;
        if (v282 <= &v263 && (char *)v282 + 24 * v283 > (char *)&v263)
        {
          v239 = (char *)&v263 - (_BYTE *)v282;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v210, 24);
          v40 = (char *)v282;
          v39 = (const void ***)((char *)v282 + v239);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v210, 24);
          v39 = &v263;
          v40 = (char *)v282;
        }
      }
      v41 = &v40[24 * v283];
      v42 = *(_OWORD *)v39;
      *((_QWORD *)v41 + 2) = v39[2];
      *(_OWORD *)v41 = v42;
      v43 = ++v283;
      if (v279)
      {
        LODWORD(v263) = 3;
        v264 = " <= result rank ";
        v265 = 16;
        v44 = &v263;
        v45 = (char *)v282;
        if (v43 >= v284)
        {
          v212 = v43 + 1;
          v213 = (char *)v282 + 24 * v43 > (char *)&v263;
          if (v282 <= &v263 && v213)
          {
            v241 = (char *)&v263 - (_BYTE *)v282;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v212, 24);
            v45 = (char *)v282;
            v44 = (const void ***)((char *)v282 + v241);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v212, 24);
            v44 = &v263;
            v45 = (char *)v282;
          }
        }
        v46 = &v45[24 * v283];
        v47 = *(_OWORD *)v44;
        *((_QWORD *)v46 + 2) = v44[2];
        *(_OWORD *)v46 = v47;
        ++v283;
      }
    }
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v259);
    if (v279)
    {
      LODWORD(v263) = 2;
      v264 = v48;
      v49 = &v263;
      v50 = (char *)v282;
      if (v283 >= v284)
      {
        v211 = v283 + 1;
        if (v282 <= &v263 && (char *)v282 + 24 * v283 > (char *)&v263)
        {
          v240 = (char *)&v263 - (_BYTE *)v282;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v211, 24);
          v50 = (char *)v282;
          v49 = (const void ***)((char *)v282 + v240);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v211, 24);
          v49 = &v263;
          v50 = (char *)v282;
        }
      }
      v51 = &v50[24 * v283];
      v52 = *(_OWORD *)v49;
      *((_QWORD *)v51 + 2) = v49[2];
      *(_OWORD *)v51 = v52;
      ++v283;
    }
    v53 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
    if (v279)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
    if (v290)
    {
      v54 = __p;
      if (__p)
      {
        v55 = v289;
        v56 = __p;
        if (v289 != __p)
        {
          do
            v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
          while (v55 != v54);
          v56 = __p;
        }
        v289 = v54;
        operator delete(v56);
      }
      v57 = v286;
      if (v286)
      {
        v58 = v287;
        v59 = v286;
        if (v287 != v286)
        {
          do
          {
            v61 = *--v58;
            v60 = v61;
            *v58 = 0;
            if (v61)
              MEMORY[0x20BD002D4](v60, 0x1000C8077774924);
          }
          while (v58 != v57);
          v59 = v286;
        }
        v287 = v57;
        operator delete(v59);
      }
      v68 = v282;
      if (v282 != v285)
        goto LABEL_189;
    }
    return v53;
  }
  v9 = *this;
  v10 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (*((_DWORD *)*this + 9))
    v11 = (uint64_t)(*this - 2);
  else
    v11 = 0;
  v12 = (const void **)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v261 = v9;
  v268 = v10;
  v269 = v9;
  v267 = v12;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v268);
  v14 = v13;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v267);
  if (v14 < v15)
  {
    v275 = (mlir::AffineMap *)"expected the type ";
    v278 = 259;
    mlir::OpState::emitOpError(&v269, (const void ***)&v275, (uint64_t)&v279);
    if (v279)
    {
      v16 = &v263;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v263, (uint64_t)v268);
      v17 = (char *)v282;
      if (v283 >= v284)
      {
        v214 = v283 + 1;
        if (v282 <= &v263 && (char *)v282 + 24 * v283 > (char *)&v263)
        {
          v242 = (char *)&v263 - (_BYTE *)v282;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v214, 24);
          v17 = (char *)v282;
          v16 = (const void ***)((char *)v282 + v242);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v214, 24);
          v16 = &v263;
          v17 = (char *)v282;
        }
      }
      v18 = &v17[24 * v283];
      v19 = *(_OWORD *)v16;
      *((_QWORD *)v18 + 2) = v16[2];
      *(_OWORD *)v18 = v19;
      v20 = ++v283;
      if (v279)
      {
        LODWORD(v263) = 3;
        v264 = " to have higher rank than the type = ";
        v265 = 37;
        v21 = &v263;
        v22 = (char *)v282;
        if (v20 >= v284)
        {
          v216 = v20 + 1;
          v217 = (char *)v282 + 24 * v20 > (char *)&v263;
          if (v282 <= &v263 && v217)
          {
            v244 = (char *)&v263 - (_BYTE *)v282;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v216, 24);
            v22 = (char *)v282;
            v21 = (const void ***)((char *)v282 + v244);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v216, 24);
            v21 = &v263;
            v22 = (char *)v282;
          }
        }
        v23 = &v22[24 * v283];
        v24 = *(_OWORD *)v21;
        *((_QWORD *)v23 + 2) = v21[2];
        *(_OWORD *)v23 = v24;
        ++v283;
        if (v279)
        {
          v25 = &v263;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v263, (uint64_t)v267);
          v26 = (char *)v282;
          if (v283 >= v284)
          {
            v220 = v283 + 1;
            if (v282 <= &v263 && (char *)v282 + 24 * v283 > (char *)&v263)
            {
              v246 = (char *)&v263 - (_BYTE *)v282;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v220, 24);
              v26 = (char *)v282;
              v25 = (const void ***)((char *)v282 + v246);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v220, 24);
              v25 = &v263;
              v26 = (char *)v282;
            }
          }
          v27 = &v26[24 * v283];
          v28 = *(_OWORD *)v25;
          *((_QWORD *)v27 + 2) = v25[2];
          *(_OWORD *)v27 = v28;
          ++v283;
        }
      }
    }
    v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
    if (v279)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
    if (v290)
    {
      v30 = __p;
      if (__p)
      {
        v31 = v289;
        v32 = __p;
        if (v289 != __p)
        {
          do
            v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
          while (v31 != v30);
          v32 = __p;
        }
        v289 = v30;
        operator delete(v32);
      }
      v33 = v286;
      if (v286)
      {
        v34 = v287;
        v35 = v286;
        if (v287 == v286)
          goto LABEL_148;
        do
        {
          v37 = *--v34;
          v36 = v37;
          *v34 = 0;
          if (v37)
            MEMORY[0x20BD002D4](v36, 0x1000C8077774924);
        }
        while (v34 != v33);
LABEL_147:
        v35 = v286;
LABEL_148:
        v287 = v33;
        operator delete(v35);
        goto LABEL_149;
      }
      goto LABEL_149;
    }
    goto LABEL_151;
  }
  if (!v14)
  {
    v275 = (mlir::AffineMap *)"expected non-zero memref ranks";
    v278 = 259;
    mlir::OpState::emitOpError(&v269, (const void ***)&v275, (uint64_t)&v279);
    v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
    if (v279)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
    if (v290)
    {
      v69 = __p;
      if (__p)
      {
        v70 = v289;
        v71 = __p;
        if (v289 != __p)
        {
          do
            v70 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v70 - 1);
          while (v70 != v69);
          v71 = __p;
        }
        v289 = v69;
        operator delete(v71);
      }
      v33 = v286;
      if (v286)
      {
        v72 = v287;
        v35 = v286;
        if (v287 == v286)
          goto LABEL_148;
        do
        {
          v74 = *--v72;
          v73 = v74;
          *v72 = 0;
          if (v74)
            MEMORY[0x20BD002D4](v73, 0x1000C8077774924);
        }
        while (v72 != v33);
        goto LABEL_147;
      }
      goto LABEL_149;
    }
    goto LABEL_151;
  }
  if (v14 == v15)
  {
    v275 = (mlir::AffineMap *)"expected to collapse or expand dims";
    v278 = 259;
    mlir::OpState::emitOpError(&v269, (const void ***)&v275, (uint64_t)&v279);
    v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
    if (v279)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
    if (v290)
    {
      v62 = __p;
      if (__p)
      {
        v63 = v289;
        v64 = __p;
        if (v289 != __p)
        {
          do
            v63 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v63 - 1);
          while (v63 != v62);
          v64 = __p;
        }
        v289 = v62;
        operator delete(v64);
      }
      v33 = v286;
      if (v286)
      {
        v65 = v287;
        v35 = v286;
        if (v287 == v286)
          goto LABEL_148;
        do
        {
          v67 = *--v65;
          v66 = v67;
          *v65 = 0;
          if (v67)
            MEMORY[0x20BD002D4](v66, 0x1000C8077774924);
        }
        while (v65 != v33);
        goto LABEL_147;
      }
      goto LABEL_149;
    }
    goto LABEL_151;
  }
  if (v15)
  {
    v75 = (const char *)v15;
    v279 = (void *)v9[2 * (((unint64_t)*((unsigned int *)v9 + 11) >> 23) & 1) + 8];
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v279);
    if (v75 != v76)
    {
      v275 = (mlir::AffineMap *)"expected rank of the collapsed type(";
      v278 = 259;
      mlir::OpState::emitOpError(&v269, (const void ***)&v275, (uint64_t)&v279);
      if (v279)
      {
        LODWORD(v263) = 5;
        v264 = v75;
        v83 = &v263;
        v84 = (char *)v282;
        if (v283 >= v284)
        {
          v222 = v283 + 1;
          if (v282 <= &v263 && (char *)v282 + 24 * v283 > (char *)&v263)
          {
            v248 = (char *)&v263 - (_BYTE *)v282;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v222, 24);
            v84 = (char *)v282;
            v83 = (const void ***)((char *)v282 + v248);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v222, 24);
            v83 = &v263;
            v84 = (char *)v282;
          }
        }
        v85 = &v84[24 * v283];
        v86 = *(_OWORD *)v83;
        *((_QWORD *)v85 + 2) = v83[2];
        *(_OWORD *)v85 = v86;
        v87 = ++v283;
        if (v279)
        {
          LODWORD(v263) = 3;
          v264 = ") to be the number of reassociation maps(";
          v265 = 41;
          v88 = &v263;
          v89 = (char *)v282;
          if (v87 >= v284)
          {
            v224 = v87 + 1;
            v225 = (char *)v282 + 24 * v87 > (char *)&v263;
            if (v282 <= &v263 && v225)
            {
              v250 = (char *)&v263 - (_BYTE *)v282;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v224, 24);
              v89 = (char *)v282;
              v88 = (const void ***)((char *)v282 + v250);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v224, 24);
              v88 = &v263;
              v89 = (char *)v282;
            }
          }
          v90 = &v89[24 * v283];
          v91 = *(_OWORD *)v88;
          *((_QWORD *)v90 + 2) = v88[2];
          *(_OWORD *)v90 = v91;
          ++v283;
        }
      }
      v272 = v269[2 * (((unint64_t)*((unsigned int *)v269 + 11) >> 23) & 1) + 8];
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v272);
      if (v279)
      {
        LODWORD(v263) = 5;
        v264 = v92;
        v93 = &v263;
        v94 = (char *)v282;
        if (v283 >= v284)
        {
          v223 = v283 + 1;
          if (v282 <= &v263 && (char *)v282 + 24 * v283 > (char *)&v263)
          {
            v249 = (char *)&v263 - (_BYTE *)v282;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v223, 24);
            v94 = (char *)v282;
            v93 = (const void ***)((char *)v282 + v249);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v223, 24);
            v93 = &v263;
            v94 = (char *)v282;
          }
        }
        v95 = &v94[24 * v283];
        v96 = *(_OWORD *)v93;
        *((_QWORD *)v95 + 2) = v93[2];
        *(_OWORD *)v95 = v96;
        v97 = ++v283;
        if (v279)
        {
          LODWORD(v263) = 3;
          v264 = ")";
          v265 = 1;
          v98 = &v263;
          v99 = (char *)v282;
          if (v97 >= v284)
          {
            v226 = v97 + 1;
            v227 = (char *)v282 + 24 * v97 > (char *)&v263;
            if (v282 <= &v263 && v227)
            {
              v251 = (char *)&v263 - (_BYTE *)v282;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v226, 24);
              v99 = (char *)v282;
              v98 = (const void ***)((char *)v282 + v251);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v226, 24);
              v98 = &v263;
              v99 = (char *)v282;
            }
          }
          v100 = &v99[24 * v283];
          v101 = *(_OWORD *)v98;
          *((_QWORD *)v100 + 2) = v98[2];
          *(_OWORD *)v100 = v101;
          ++v283;
        }
      }
      v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
      if (v279)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
      if (v290)
      {
        v102 = __p;
        if (__p)
        {
          v103 = v289;
          v104 = __p;
          if (v289 != __p)
          {
            do
              v103 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v103 - 1);
            while (v103 != v102);
            v104 = __p;
          }
          v289 = v102;
          operator delete(v104);
        }
        v33 = v286;
        if (v286)
        {
          v105 = v287;
          v35 = v286;
          if (v287 == v286)
            goto LABEL_148;
          do
          {
            v107 = *--v105;
            v106 = v107;
            *v105 = 0;
            if (v107)
              MEMORY[0x20BD002D4](v106, 0x1000C8077774924);
          }
          while (v105 != v33);
          goto LABEL_147;
        }
        goto LABEL_149;
      }
      goto LABEL_151;
    }
    mlir::tensor::CollapseShapeOp::getReassociationExprs((mlir::tensor::CollapseShapeOp *)&v269, &v279);
    mlir::getSymbolLessAffineMaps((uint64_t)v279, v280, (uint64_t)&v275);
    v77 = (char *)v279;
    if (v280)
    {
      v78 = 32 * v280;
      do
      {
        v79 = *(char **)&v77[v78 - 32];
        if (&v77[v78 - 16] != v79)
          free(v79);
        v78 -= 32;
      }
      while (v78);
      v77 = (char *)v279;
    }
    if (v77 != (char *)&v281)
      free(v77);
    v108 = v275;
    v109 = v276;
    if (v276)
    {
      v110 = 0;
      v111 = (const char *)v14;
      v112 = 8 * v276;
      while (mlir::AffineMap::getNumDims(v108) == v14)
      {
        ++v110;
        v108 = (mlir::AffineMap *)((char *)v108 + 8);
        v112 -= 8;
        if (!v112)
        {
          v108 = v275;
          v109 = v276;
          goto LABEL_130;
        }
      }
      v263 = (const void **)"expected reassociation map #";
      v266 = 259;
      mlir::OpState::emitOpError(&v269, &v263, (uint64_t)&v279);
      if (v279)
      {
        LODWORD(v272) = 5;
        v273 = v110;
        v166 = &v272;
        v167 = (char *)v282;
        if (v283 >= v284)
        {
          v229 = v283 + 1;
          if (v282 <= &v272 && (char *)v282 + 24 * v283 > (char *)&v272)
          {
            v253 = (char *)&v272 - (_BYTE *)v282;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v229, 24);
            v167 = (char *)v282;
            v166 = (uint64_t *)((char *)v282 + v253);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v229, 24);
            v166 = &v272;
            v167 = (char *)v282;
          }
        }
        v168 = &v167[24 * v283];
        v169 = *(_OWORD *)v166;
        *((_QWORD *)v168 + 2) = v166[2];
        *(_OWORD *)v168 = v169;
        v170 = ++v283;
        if (v279)
        {
          LODWORD(v272) = 3;
          v273 = " of same rank as expanded memref(";
          v274 = 33;
          v171 = &v272;
          v172 = (char *)v282;
          if (v170 >= v284)
          {
            v233 = v170 + 1;
            v234 = (char *)v282 + 24 * v170 > (char *)&v272;
            if (v282 <= &v272 && v234)
            {
              v256 = (char *)&v272 - (_BYTE *)v282;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v233, 24);
              v172 = (char *)v282;
              v171 = (uint64_t *)((char *)v282 + v256);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v233, 24);
              v171 = &v272;
              v172 = (char *)v282;
            }
          }
          v173 = &v172[24 * v283];
          v174 = *(_OWORD *)v171;
          *((_QWORD *)v173 + 2) = v171[2];
          *(_OWORD *)v173 = v174;
          v175 = ++v283;
          if (v279)
          {
            LODWORD(v272) = 5;
            v273 = v111;
            v176 = &v272;
            v177 = (char *)v282;
            if (v175 >= v284)
            {
              v235 = v175 + 1;
              v236 = (char *)v282 + 24 * v175 > (char *)&v272;
              if (v282 <= &v272 && v236)
              {
                v257 = (char *)&v272 - (_BYTE *)v282;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v235, 24);
                v177 = (char *)v282;
                v176 = (uint64_t *)((char *)v282 + v257);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v235, 24);
                v176 = &v272;
                v177 = (char *)v282;
              }
            }
            v178 = &v177[24 * v283];
            v179 = *(_OWORD *)v176;
            *((_QWORD *)v178 + 2) = v176[2];
            *(_OWORD *)v178 = v179;
            v180 = ++v283;
            if (v279)
            {
              LODWORD(v272) = 3;
              v273 = "), but got ";
              v274 = 11;
              v181 = &v272;
              v182 = (char *)v282;
              if (v180 >= v284)
              {
                v237 = v180 + 1;
                v238 = (char *)v282 + 24 * v180 > (char *)&v272;
                if (v282 <= &v272 && v238)
                {
                  v258 = (char *)&v272 - (_BYTE *)v282;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v237, 24);
                  v182 = (char *)v282;
                  v181 = (uint64_t *)((char *)v282 + v258);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v237, 24);
                  v181 = &v272;
                  v182 = (char *)v282;
                }
              }
              v183 = &v182[24 * v283];
              v184 = *(_OWORD *)v181;
              *((_QWORD *)v183 + 2) = v181[2];
              *(_OWORD *)v183 = v184;
              ++v283;
            }
          }
        }
      }
      NumDims = mlir::AffineMap::getNumDims(v108);
      if (v279)
      {
        LODWORD(v272) = 5;
        v273 = (const char *)NumDims;
        v186 = &v272;
        v187 = (char *)v282;
        if (v283 >= v284)
        {
          v230 = v283 + 1;
          if (v282 <= &v272 && (char *)v282 + 24 * v283 > (char *)&v272)
          {
            v254 = (char *)&v272 - (_BYTE *)v282;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v230, 24);
            v187 = (char *)v282;
            v186 = (uint64_t *)((char *)v282 + v254);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v230, 24);
            v186 = &v272;
            v187 = (char *)v282;
          }
        }
        v188 = &v187[24 * v283];
        v189 = *(_OWORD *)v186;
        *((_QWORD *)v188 + 2) = v186[2];
        *(_OWORD *)v188 = v189;
        ++v283;
      }
      v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
      if (v279)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
      if (!v290)
        goto LABEL_252;
      v190 = __p;
      if (__p)
      {
        v191 = v289;
        v192 = __p;
        if (v289 != __p)
        {
          do
            v191 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v191 - 1);
          while (v191 != v190);
          v192 = __p;
        }
        v289 = v190;
        operator delete(v192);
      }
      v193 = v286;
      if (v286)
      {
        v194 = v287;
        v195 = v286;
        if (v287 != v286)
        {
          do
          {
            v197 = *--v194;
            v196 = v197;
            *v194 = 0;
            if (v197)
              MEMORY[0x20BD002D4](v196, 0x1000C8077774924);
          }
          while (v194 != v193);
          v195 = v286;
        }
        v287 = v193;
        operator delete(v195);
      }
      v209 = v282;
      if (v282 == v285)
      {
LABEL_252:
        v122 = v275;
        if (v275 != (mlir::AffineMap *)v277)
        {
LABEL_150:
          free(v122);
          goto LABEL_151;
        }
        goto LABEL_151;
      }
    }
    else
    {
LABEL_130:
      v262 = 0;
      if ((mlir::isReassociationValid(v108, v109, &v262) & 1) != 0)
      {
        v113 = v269;
        v114 = v267;
        if (v267)
          v115 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v267 + 8);
        else
          v115 = 0;
        v198 = v268;
        if (v268)
          v199 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v268 + 8);
        else
          v199 = 0;
        v271 = v113;
        v272 = (uint64_t)v198;
        v263 = v114;
        v264 = (const char *)v115;
        v273 = (const char *)v199;
        v270 = &v271;
        Shape = mlir::ShapedType::getShape((mlir::ShapedType *)&v263);
        v202 = v201;
        v203 = mlir::ShapedType::getShape((mlir::ShapedType *)&v272);
        v205 = v204;
        mlir::memref::CollapseShapeOp::getReassociationIndices((mlir::memref::CollapseShapeOp *)&v271, (uint64_t)&v279);
        v29 = mlir::reshapeLikeShapesAreCompatible((uint64_t (*)(uint64_t, _QWORD **))llvm::function_ref<mlir::LogicalResult ()(llvm::Twine const&)>::callback_fn<mlir::LogicalResult mlir::verifyReshapeLikeShapes<mlir::tensor::CollapseShapeOp>(mlir::tensor::CollapseShapeOp,mlir::ShapedType,mlir::ShapedType,BOOL)::{lambda(llvm::Twine const&)#1}>, (uint64_t)&v270, Shape, v202, v203, v205, (uint64_t)v279, v280, 0);
        v206 = (uint64_t *)v279;
        if (v280)
        {
          v207 = 4 * v280;
          do
          {
            v208 = (uint64_t *)v206[v207 - 4];
            if (&v206[v207 - 2] != v208)
              free(v208);
            v207 -= 4;
          }
          while (v207 * 8);
          v206 = (uint64_t *)v279;
        }
        if (v206 == &v281)
          goto LABEL_252;
        v209 = v206;
      }
      else
      {
        v263 = (const void **)"expected reassociation map #";
        v266 = 259;
        mlir::OpState::emitOpError(&v269, &v263, (uint64_t)&v279);
        if (v279)
        {
          LODWORD(v272) = 2;
          v273 = (const char *)v262;
          v149 = &v272;
          v150 = (char *)v282;
          if (v283 >= v284)
          {
            v228 = v283 + 1;
            if (v282 <= &v272 && (char *)v282 + 24 * v283 > (char *)&v272)
            {
              v252 = (char *)&v272 - (_BYTE *)v282;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v228, 24);
              v150 = (char *)v282;
              v149 = (uint64_t *)((char *)v282 + v252);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v228, 24);
              v149 = &v272;
              v150 = (char *)v282;
            }
          }
          v151 = &v150[24 * v283];
          v152 = *(_OWORD *)v149;
          *((_QWORD *)v151 + 2) = v149[2];
          *(_OWORD *)v151 = v152;
          v153 = ++v283;
          if (v279)
          {
            LODWORD(v272) = 3;
            v273 = " to be valid and contiguous";
            v274 = 27;
            v154 = &v272;
            v155 = (char *)v282;
            if (v153 >= v284)
            {
              v231 = v153 + 1;
              v232 = (char *)v282 + 24 * v153 > (char *)&v272;
              if (v282 <= &v272 && v232)
              {
                v255 = (char *)&v272 - (_BYTE *)v282;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v231, 24);
                v155 = (char *)v282;
                v154 = (uint64_t *)((char *)v282 + v255);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v231, 24);
                v154 = &v272;
                v155 = (char *)v282;
              }
            }
            v156 = &v155[24 * v283];
            v157 = *(_OWORD *)v154;
            *((_QWORD *)v156 + 2) = v154[2];
            *(_OWORD *)v156 = v157;
            ++v283;
          }
        }
        v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
        if (v279)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
        if (!v290)
          goto LABEL_252;
        v158 = __p;
        if (__p)
        {
          v159 = v289;
          v160 = __p;
          if (v289 != __p)
          {
            do
              v159 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v159 - 1);
            while (v159 != v158);
            v160 = __p;
          }
          v289 = v158;
          operator delete(v160);
        }
        v161 = v286;
        if (v286)
        {
          v162 = v287;
          v163 = v286;
          if (v287 != v286)
          {
            do
            {
              v165 = *--v162;
              v164 = v165;
              *v162 = 0;
              if (v165)
                MEMORY[0x20BD002D4](v164, 0x1000C8077774924);
            }
            while (v162 != v161);
            v163 = v286;
          }
          v287 = v161;
          operator delete(v163);
        }
        v209 = v282;
        if (v282 == v285)
          goto LABEL_252;
      }
    }
    free(v209);
    goto LABEL_252;
  }
  Value = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v268);
  if (v81)
  {
    v82 = 8 * v81;
    while (*Value == 1)
    {
      ++Value;
      v82 -= 8;
      if (!v82)
        goto LABEL_152;
    }
    v275 = (mlir::AffineMap *)"invalid to reshape tensor/memref with non-unit extent dimensions to zero-rank tensor/memref";
    v278 = 259;
    mlir::OpState::emitOpError(&v269, (const void ***)&v275, (uint64_t)&v279);
    v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
    if (v279)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
    if (v290)
    {
      v116 = __p;
      if (__p)
      {
        v117 = v289;
        v118 = __p;
        if (v289 != __p)
        {
          do
            v117 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v117 - 1);
          while (v117 != v116);
          v118 = __p;
        }
        v289 = v116;
        operator delete(v118);
      }
      v33 = v286;
      if (v286)
      {
        v119 = v287;
        v35 = v286;
        if (v287 == v286)
          goto LABEL_148;
        do
        {
          v121 = *--v119;
          v120 = v121;
          *v119 = 0;
          if (v121)
            MEMORY[0x20BD002D4](v120, 0x1000C8077774924);
        }
        while (v119 != v33);
        goto LABEL_147;
      }
LABEL_149:
      v122 = v282;
      if (v282 == v285)
        goto LABEL_151;
      goto LABEL_150;
    }
LABEL_151:
    if (!v29)
      return 0;
  }
LABEL_152:
  mlir::tensor::CollapseShapeOp::getReassociationExprs((mlir::tensor::CollapseShapeOp *)&v261, &v279);
  mlir::getSymbolLessAffineMaps((uint64_t)v279, v280, (uint64_t)&v275);
  v123 = (char *)v279;
  if (v280)
  {
    v124 = 32 * v280;
    do
    {
      v125 = *(char **)&v123[v124 - 32];
      if (&v123[v124 - 16] != v125)
        free(v125);
      v124 -= 32;
    }
    while (v124);
    v123 = (char *)v279;
  }
  if (v123 != (char *)&v281)
    free(v123);
  v126 = mlir::tensor::CollapseShapeOp::inferCollapsedType((uint64_t)v10, (uint64_t *)v275, v276);
  if (mlir::tensor::isSameTypeWithoutEncoding((uint64_t)v12, v126))
  {
    v53 = 1;
  }
  else
  {
    v263 = (const void **)"expected collapsed type to be ";
    v266 = 259;
    mlir::OpState::emitOpError(&v261, &v263, (uint64_t)&v279);
    if (v279)
    {
      v127 = &v272;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v272, v126);
      v128 = (char *)v282;
      if (v283 >= v284)
      {
        v215 = v283 + 1;
        if (v282 <= &v272 && (char *)v282 + 24 * v283 > (char *)&v272)
        {
          v243 = (char *)&v272 - (_BYTE *)v282;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v215, 24);
          v128 = (char *)v282;
          v127 = (uint64_t *)((char *)v282 + v243);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v215, 24);
          v127 = &v272;
          v128 = (char *)v282;
        }
      }
      v129 = &v128[24 * v283];
      v130 = *(_OWORD *)v127;
      *((_QWORD *)v129 + 2) = v127[2];
      *(_OWORD *)v129 = v130;
      v131 = ++v283;
      if (v279)
      {
        LODWORD(v272) = 3;
        v273 = ", but got ";
        v274 = 10;
        v132 = &v272;
        v133 = (char *)v282;
        if (v131 >= v284)
        {
          v218 = v131 + 1;
          v219 = (char *)v282 + 24 * v131 > (char *)&v272;
          if (v282 <= &v272 && v219)
          {
            v245 = (char *)&v272 - (_BYTE *)v282;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v218, 24);
            v133 = (char *)v282;
            v132 = (uint64_t *)((char *)v282 + v245);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v218, 24);
            v132 = &v272;
            v133 = (char *)v282;
          }
        }
        v134 = &v133[24 * v283];
        v135 = *(_OWORD *)v132;
        *((_QWORD *)v134 + 2) = v132[2];
        *(_OWORD *)v134 = v135;
        ++v283;
        if (v279)
        {
          v136 = &v272;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v272, (uint64_t)v12);
          v137 = (char *)v282;
          if (v283 >= v284)
          {
            v221 = v283 + 1;
            if (v282 <= &v272 && (char *)v282 + 24 * v283 > (char *)&v272)
            {
              v247 = (char *)&v272 - (_BYTE *)v282;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v221, 24);
              v137 = (char *)v282;
              v136 = (uint64_t *)((char *)v282 + v247);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v282, v285, v221, 24);
              v136 = &v272;
              v137 = (char *)v282;
            }
          }
          v138 = &v137[24 * v283];
          v139 = *(_OWORD *)v136;
          *((_QWORD *)v138 + 2) = v136[2];
          *(_OWORD *)v138 = v139;
          ++v283;
        }
      }
    }
    v53 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v279);
    if (v279)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v279);
    if (v290)
    {
      v140 = __p;
      if (__p)
      {
        v141 = v289;
        v142 = __p;
        if (v289 != __p)
        {
          do
            v141 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v141 - 1);
          while (v141 != v140);
          v142 = __p;
        }
        v289 = v140;
        operator delete(v142);
      }
      v143 = v286;
      if (v286)
      {
        v144 = v287;
        v145 = v286;
        if (v287 != v286)
        {
          do
          {
            v147 = *--v144;
            v146 = v147;
            *v144 = 0;
            if (v147)
              MEMORY[0x20BD002D4](v146, 0x1000C8077774924);
          }
          while (v144 != v143);
          v145 = v286;
        }
        v287 = v143;
        operator delete(v145);
      }
      if (v282 != v285)
        free(v282);
    }
  }
  v68 = v275;
  if (v275 != (mlir::AffineMap *)v277)
LABEL_189:
    free(v68);
  return v53;
}

void mlir::tensor::ExpandShapeOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  char *v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  const char *v46;
  unint64_t v47;
  uint64_t v48;
  const char *v49;
  unint64_t v50;
  char *v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  char *v56;
  uint64_t *v57;
  char *v58;
  char *v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;
  uint64_t v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  char *v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  const char *v81;
  unint64_t v82;
  uint64_t v83;
  const char *v84;
  unint64_t v85;
  char *v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  char *v91;
  uint64_t *v92;
  char *v93;
  char *v94;
  unint64_t v95;
  uint64_t v96;
  uint64_t v97;
  char *v98;
  char *v99;
  char *v100;
  uint64_t v101;
  __int128 v102;
  __int128 v103;
  uint64_t v104;
  char *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  unint64_t v110;
  unint64_t v111;
  char *v112;
  uint64_t v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  const char *v119;
  unint64_t v120;
  char *v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  unint64_t v125;
  char *v126;
  uint64_t *v127;
  char *v128;
  char *v129;
  unint64_t v130;
  uint64_t v131;
  uint64_t v132;
  char *v133;
  char *v134;
  char *v135;
  uint64_t v136;
  __int128 v137;
  __int128 v138;
  uint64_t v139;
  char *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  unint64_t v145;
  unint64_t v146;
  char *v147;
  uint64_t v148;
  unint64_t v149;
  unint64_t v150;
  const char *v151;
  unint64_t v152;
  uint64_t v153;
  const char *v154;
  unint64_t v155;
  char *v156;
  uint64_t v157;
  unint64_t v158;
  uint64_t v159;
  unint64_t v160;
  char *v161;
  uint64_t *v162;
  char *v163;
  char *v164;
  unint64_t v165;
  uint64_t v166;
  uint64_t v167;
  char *v168;
  char *v169;
  char *v170;
  uint64_t v171;
  __int128 v172;
  __int128 v173;
  uint64_t v174;
  char *v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  const char *v179;
  unint64_t v180;

  v178 = a2;
  mlir::RewritePatternSet::addImpl<mlir::ComposeReassociativeReshapeOps<mlir::tensor::ExpandShapeOp>,mlir::MLIRContext *&>(a1, 0, 0, &v178);
  mlir::RewritePatternSet::addImpl<mlir::ComposeExpandOfCollapseOp<mlir::tensor::ExpandShapeOp,mlir::tensor::CollapseShapeOp>,mlir::MLIRContext *&>(a1, 0, 0, &v178);
  v3 = operator new();
  v4 = v178;
  mlir::PatternBenefit::PatternBenefit(&v179, 1);
  mlir::Pattern::Pattern(v3 + 8, (uint64_t)"tensor.expand_shape", 19, (__int16)v179, v4, 0, 0);
  *(_QWORD *)v3 = &off_24C02A5A8;
  if (*(_QWORD *)(v3 + 72))
  {
    v5 = *(unsigned int *)(v3 + 88);
    if (v5 <= *(_DWORD *)(v3 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v3 + 80, (void *)(v3 + 96), v5, 16);
    *(_DWORD *)(v3 + 88) = *(_DWORD *)(v3 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v179 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldReshapeWithConstant<mlir::tensor::ExpandShapeOp>]";
  v180 = 125;
  v9 = llvm::StringRef::find((uint64_t *)&v179, "DesiredTypeName = ", 0x12uLL, 0);
  if (v180 >= v9)
    v10 = v9;
  else
    v10 = v180;
  v11 = &v179[v10];
  v12 = v180 - v10;
  if (v180 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v180 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v3 + 64) = v14;
  *(_QWORD *)(v3 + 72) = v15;
  v5 = *(unsigned int *)(v3 + 88);
  if (v5 > *(_DWORD *)(v3 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v3 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v3;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_192;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_193;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v3;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v3;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_196;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_196:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  v39 = v178;
  mlir::PatternBenefit::PatternBenefit(&v179, 1);
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"tensor.expand_shape", 19, (__int16)v179, v39, 0, 0);
  *(_QWORD *)v38 = &off_24C029B48;
  if (*(_QWORD *)(v38 + 72))
  {
    v40 = *(unsigned int *)(v38 + 88);
    if (v40 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v40, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v42 = (char *)a1[2];
    v41 = a1[3];
    if ((unint64_t)v42 < v41)
      goto LABEL_42;
    goto LABEL_53;
  }
  v179 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldReshapeWithSplat<mlir::tensor::ExpandShapeOp>]";
  v180 = 122;
  v44 = llvm::StringRef::find((uint64_t *)&v179, "DesiredTypeName = ", 0x12uLL, 0);
  if (v180 >= v44)
    v45 = v44;
  else
    v45 = v180;
  v46 = &v179[v45];
  v47 = v180 - v45;
  if (v180 - v45 >= 0x12)
    v48 = 18;
  else
    v48 = v180 - v45;
  v49 = &v46[v48];
  v50 = v47 - v48;
  if (v50 >= v50 - 1)
    --v50;
  *(_QWORD *)(v38 + 64) = v49;
  *(_QWORD *)(v38 + 72) = v50;
  v40 = *(unsigned int *)(v38 + 88);
  if (v40 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v40;
  v42 = (char *)a1[2];
  v41 = a1[3];
  if ((unint64_t)v42 < v41)
  {
LABEL_42:
    *(_QWORD *)v42 = v38;
    v43 = (uint64_t)(v42 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v51 = (char *)a1[1];
  v52 = (v42 - v51) >> 3;
  v53 = v52 + 1;
  if ((unint64_t)(v52 + 1) >> 61)
    goto LABEL_192;
  v54 = v41 - (_QWORD)v51;
  if (v54 >> 2 > v53)
    v53 = v54 >> 2;
  if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8)
    v55 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v55 = v53;
  if (v55)
  {
    if (v55 >> 61)
      goto LABEL_193;
    v56 = (char *)operator new(8 * v55);
    v57 = (uint64_t *)&v56[8 * v52];
    v58 = &v56[8 * v55];
    *v57 = v38;
    v43 = (uint64_t)(v57 + 1);
    v59 = (char *)(v42 - v51);
    if (v42 != v51)
      goto LABEL_62;
  }
  else
  {
    v56 = 0;
    v57 = (uint64_t *)(8 * v52);
    v58 = 0;
    *(_QWORD *)(8 * v52) = v38;
    v43 = 8 * v52 + 8;
    v59 = (char *)(v42 - v51);
    if (v42 != v51)
    {
LABEL_62:
      v60 = (unint64_t)(v59 - 8);
      if (v60 < 0x78
        || &v42[-(v60 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v57
        && &v56[v42 - v51 - (v60 & 0xFFFFFFFFFFFFFFF8) - 8] < v42)
      {
        goto LABEL_197;
      }
      v61 = (v60 >> 3) + 1;
      v62 = 8 * (v61 & 0x3FFFFFFFFFFFFFFCLL);
      v63 = &v42[-v62];
      v57 = (uint64_t *)((char *)v57 - v62);
      v64 = &v56[8 * v52 - 16];
      v65 = v42 - 16;
      v66 = v61 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v68 = *((_OWORD *)v65 - 1);
        v67 = *(_OWORD *)v65;
        *((_OWORD *)v65 - 1) = 0uLL;
        *(_OWORD *)v65 = 0uLL;
        *((_OWORD *)v64 - 1) = v68;
        *(_OWORD *)v64 = v67;
        v64 -= 32;
        v65 -= 32;
        v66 -= 4;
      }
      while (v66);
      v42 = v63;
      if (v61 != (v61 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_197:
        do
        {
          v69 = *((_QWORD *)v42 - 1);
          v42 -= 8;
          *(_QWORD *)v42 = 0;
          *--v57 = v69;
        }
        while (v42 != v51);
      }
      v42 = (char *)a1[1];
      v70 = (char *)a1[2];
      a1[1] = v57;
      a1[2] = v43;
      a1[3] = v58;
      while (v70 != v42)
      {
        v72 = *((_QWORD *)v70 - 1);
        v70 -= 8;
        v71 = v72;
        *(_QWORD *)v70 = 0;
        if (v72)
          (*(void (**)(uint64_t))(*(_QWORD *)v71 + 8))(v71);
      }
      goto LABEL_75;
    }
  }
  a1[1] = v57;
  a1[2] = v43;
  a1[3] = v58;
LABEL_75:
  if (v42)
    operator delete(v42);
LABEL_77:
  a1[2] = v43;
  v73 = operator new();
  v74 = v178;
  mlir::PatternBenefit::PatternBenefit(&v179, 1);
  mlir::Pattern::Pattern(v73 + 8, (uint64_t)"tensor.expand_shape", 19, (__int16)v179, v74, 0, 0);
  *(_QWORD *)v73 = &off_24C02ADA8;
  if (*(_QWORD *)(v73 + 72))
  {
    v75 = *(unsigned int *)(v73 + 88);
    if (v75 <= *(_DWORD *)(v73 + 92))
      goto LABEL_79;
LABEL_90:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v73 + 80, (void *)(v73 + 96), v75, 16);
    *(_DWORD *)(v73 + 88) = *(_DWORD *)(v73 + 88);
    v77 = (char *)a1[2];
    v76 = a1[3];
    if ((unint64_t)v77 < v76)
      goto LABEL_80;
    goto LABEL_91;
  }
  v179 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldReshapeWithFromElements<mlir::tenso"
         "r::ExpandShapeOp>]";
  v180 = 129;
  v79 = llvm::StringRef::find((uint64_t *)&v179, "DesiredTypeName = ", 0x12uLL, 0);
  if (v180 >= v79)
    v80 = v79;
  else
    v80 = v180;
  v81 = &v179[v80];
  v82 = v180 - v80;
  if (v180 - v80 >= 0x12)
    v83 = 18;
  else
    v83 = v180 - v80;
  v84 = &v81[v83];
  v85 = v82 - v83;
  if (v85 >= v85 - 1)
    --v85;
  *(_QWORD *)(v73 + 64) = v84;
  *(_QWORD *)(v73 + 72) = v85;
  v75 = *(unsigned int *)(v73 + 88);
  if (v75 > *(_DWORD *)(v73 + 92))
    goto LABEL_90;
LABEL_79:
  *(_DWORD *)(v73 + 88) = v75;
  v77 = (char *)a1[2];
  v76 = a1[3];
  if ((unint64_t)v77 < v76)
  {
LABEL_80:
    *(_QWORD *)v77 = v73;
    v78 = (uint64_t)(v77 + 8);
    goto LABEL_115;
  }
LABEL_91:
  v86 = (char *)a1[1];
  v87 = (v77 - v86) >> 3;
  v88 = v87 + 1;
  if ((unint64_t)(v87 + 1) >> 61)
    goto LABEL_192;
  v89 = v76 - (_QWORD)v86;
  if (v89 >> 2 > v88)
    v88 = v89 >> 2;
  if ((unint64_t)v89 >= 0x7FFFFFFFFFFFFFF8)
    v90 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v90 = v88;
  if (v90)
  {
    if (v90 >> 61)
      goto LABEL_193;
    v91 = (char *)operator new(8 * v90);
    v92 = (uint64_t *)&v91[8 * v87];
    v93 = &v91[8 * v90];
    *v92 = v73;
    v78 = (uint64_t)(v92 + 1);
    v94 = (char *)(v77 - v86);
    if (v77 != v86)
      goto LABEL_100;
  }
  else
  {
    v91 = 0;
    v92 = (uint64_t *)(8 * v87);
    v93 = 0;
    *(_QWORD *)(8 * v87) = v73;
    v78 = 8 * v87 + 8;
    v94 = (char *)(v77 - v86);
    if (v77 != v86)
    {
LABEL_100:
      v95 = (unint64_t)(v94 - 8);
      if (v95 < 0x78
        || &v77[-(v95 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v92
        && &v91[v77 - v86 - (v95 & 0xFFFFFFFFFFFFFFF8) - 8] < v77)
      {
        goto LABEL_198;
      }
      v96 = (v95 >> 3) + 1;
      v97 = 8 * (v96 & 0x3FFFFFFFFFFFFFFCLL);
      v98 = &v77[-v97];
      v92 = (uint64_t *)((char *)v92 - v97);
      v99 = &v91[8 * v87 - 16];
      v100 = v77 - 16;
      v101 = v96 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v103 = *((_OWORD *)v100 - 1);
        v102 = *(_OWORD *)v100;
        *((_OWORD *)v100 - 1) = 0uLL;
        *(_OWORD *)v100 = 0uLL;
        *((_OWORD *)v99 - 1) = v103;
        *(_OWORD *)v99 = v102;
        v99 -= 32;
        v100 -= 32;
        v101 -= 4;
      }
      while (v101);
      v77 = v98;
      if (v96 != (v96 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_198:
        do
        {
          v104 = *((_QWORD *)v77 - 1);
          v77 -= 8;
          *(_QWORD *)v77 = 0;
          *--v92 = v104;
        }
        while (v77 != v86);
      }
      v77 = (char *)a1[1];
      v105 = (char *)a1[2];
      a1[1] = v92;
      a1[2] = v78;
      a1[3] = v93;
      while (v105 != v77)
      {
        v107 = *((_QWORD *)v105 - 1);
        v105 -= 8;
        v106 = v107;
        *(_QWORD *)v105 = 0;
        if (v107)
          (*(void (**)(uint64_t))(*(_QWORD *)v106 + 8))(v106);
      }
      goto LABEL_113;
    }
  }
  a1[1] = v92;
  a1[2] = v78;
  a1[3] = v93;
LABEL_113:
  if (v77)
    operator delete(v77);
LABEL_115:
  a1[2] = v78;
  v108 = operator new();
  v109 = v178;
  mlir::PatternBenefit::PatternBenefit(&v179, 1);
  mlir::Pattern::Pattern(v108 + 8, (uint64_t)"tensor.dim", 10, (__int16)v179, v109, 0, 0);
  *(_QWORD *)v108 = &off_24C029AF0;
  if (*(_QWORD *)(v108 + 72))
  {
    v110 = *(unsigned int *)(v108 + 88);
    if (v110 <= *(_DWORD *)(v108 + 92))
      goto LABEL_117;
LABEL_128:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v108 + 80, (void *)(v108 + 96), v110, 16);
    *(_DWORD *)(v108 + 88) = *(_DWORD *)(v108 + 88);
    v112 = (char *)a1[2];
    v111 = a1[3];
    if ((unint64_t)v112 < v111)
      goto LABEL_118;
    goto LABEL_129;
  }
  v179 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldDimOfExpandShape]";
  v180 = 93;
  v114 = llvm::StringRef::find((uint64_t *)&v179, "DesiredTypeName = ", 0x12uLL, 0);
  if (v180 >= v114)
    v115 = v114;
  else
    v115 = v180;
  v116 = &v179[v115];
  v117 = v180 - v115;
  if (v180 - v115 >= 0x12)
    v118 = 18;
  else
    v118 = v180 - v115;
  v119 = &v116[v118];
  v120 = v117 - v118;
  if (v120 >= v120 - 1)
    --v120;
  *(_QWORD *)(v108 + 64) = v119;
  *(_QWORD *)(v108 + 72) = v120;
  v110 = *(unsigned int *)(v108 + 88);
  if (v110 > *(_DWORD *)(v108 + 92))
    goto LABEL_128;
LABEL_117:
  *(_DWORD *)(v108 + 88) = v110;
  v112 = (char *)a1[2];
  v111 = a1[3];
  if ((unint64_t)v112 < v111)
  {
LABEL_118:
    *(_QWORD *)v112 = v108;
    v113 = (uint64_t)(v112 + 8);
    goto LABEL_153;
  }
LABEL_129:
  v121 = (char *)a1[1];
  v122 = (v112 - v121) >> 3;
  v123 = v122 + 1;
  if ((unint64_t)(v122 + 1) >> 61)
    goto LABEL_192;
  v124 = v111 - (_QWORD)v121;
  if (v124 >> 2 > v123)
    v123 = v124 >> 2;
  if ((unint64_t)v124 >= 0x7FFFFFFFFFFFFFF8)
    v125 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v125 = v123;
  if (v125)
  {
    if (v125 >> 61)
      goto LABEL_193;
    v126 = (char *)operator new(8 * v125);
    v127 = (uint64_t *)&v126[8 * v122];
    v128 = &v126[8 * v125];
    *v127 = v108;
    v113 = (uint64_t)(v127 + 1);
    v129 = (char *)(v112 - v121);
    if (v112 != v121)
      goto LABEL_138;
  }
  else
  {
    v126 = 0;
    v127 = (uint64_t *)(8 * v122);
    v128 = 0;
    *(_QWORD *)(8 * v122) = v108;
    v113 = 8 * v122 + 8;
    v129 = (char *)(v112 - v121);
    if (v112 != v121)
    {
LABEL_138:
      v130 = (unint64_t)(v129 - 8);
      if (v130 < 0x78
        || &v112[-(v130 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v127
        && &v126[v112 - v121 - (v130 & 0xFFFFFFFFFFFFFFF8) - 8] < v112)
      {
        goto LABEL_199;
      }
      v131 = (v130 >> 3) + 1;
      v132 = 8 * (v131 & 0x3FFFFFFFFFFFFFFCLL);
      v133 = &v112[-v132];
      v127 = (uint64_t *)((char *)v127 - v132);
      v134 = &v126[8 * v122 - 16];
      v135 = v112 - 16;
      v136 = v131 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v138 = *((_OWORD *)v135 - 1);
        v137 = *(_OWORD *)v135;
        *((_OWORD *)v135 - 1) = 0uLL;
        *(_OWORD *)v135 = 0uLL;
        *((_OWORD *)v134 - 1) = v138;
        *(_OWORD *)v134 = v137;
        v134 -= 32;
        v135 -= 32;
        v136 -= 4;
      }
      while (v136);
      v112 = v133;
      if (v131 != (v131 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_199:
        do
        {
          v139 = *((_QWORD *)v112 - 1);
          v112 -= 8;
          *(_QWORD *)v112 = 0;
          *--v127 = v139;
        }
        while (v112 != v121);
      }
      v112 = (char *)a1[1];
      v140 = (char *)a1[2];
      a1[1] = v127;
      a1[2] = v113;
      a1[3] = v128;
      while (v140 != v112)
      {
        v142 = *((_QWORD *)v140 - 1);
        v140 -= 8;
        v141 = v142;
        *(_QWORD *)v140 = 0;
        if (v142)
          (*(void (**)(uint64_t))(*(_QWORD *)v141 + 8))(v141);
      }
      goto LABEL_151;
    }
  }
  a1[1] = v127;
  a1[2] = v113;
  a1[3] = v128;
LABEL_151:
  if (v112)
    operator delete(v112);
LABEL_153:
  a1[2] = v113;
  v143 = operator new();
  v144 = v178;
  mlir::PatternBenefit::PatternBenefit(&v179, 1);
  mlir::Pattern::Pattern(v143 + 8, (uint64_t)"tensor.dim", 10, (__int16)v179, v144, 0, 0);
  *(_QWORD *)v143 = &off_24C02A310;
  if (*(_QWORD *)(v143 + 72))
  {
    v145 = *(unsigned int *)(v143 + 88);
    if (v145 <= *(_DWORD *)(v143 + 92))
      goto LABEL_155;
LABEL_166:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v143 + 80, (void *)(v143 + 96), v145, 16);
    *(_DWORD *)(v143 + 88) = *(_DWORD *)(v143 + 88);
    v147 = (char *)a1[2];
    v146 = a1[3];
    if ((unint64_t)v147 < v146)
      goto LABEL_156;
    goto LABEL_167;
  }
  v179 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldDimOfCollapseShape]";
  v180 = 95;
  v149 = llvm::StringRef::find((uint64_t *)&v179, "DesiredTypeName = ", 0x12uLL, 0);
  if (v180 >= v149)
    v150 = v149;
  else
    v150 = v180;
  v151 = &v179[v150];
  v152 = v180 - v150;
  if (v180 - v150 >= 0x12)
    v153 = 18;
  else
    v153 = v180 - v150;
  v154 = &v151[v153];
  v155 = v152 - v153;
  if (v155 >= v155 - 1)
    --v155;
  *(_QWORD *)(v143 + 64) = v154;
  *(_QWORD *)(v143 + 72) = v155;
  v145 = *(unsigned int *)(v143 + 88);
  if (v145 > *(_DWORD *)(v143 + 92))
    goto LABEL_166;
LABEL_155:
  *(_DWORD *)(v143 + 88) = v145;
  v147 = (char *)a1[2];
  v146 = a1[3];
  if ((unint64_t)v147 < v146)
  {
LABEL_156:
    *(_QWORD *)v147 = v143;
    v148 = (uint64_t)(v147 + 8);
    goto LABEL_191;
  }
LABEL_167:
  v156 = (char *)a1[1];
  v157 = (v147 - v156) >> 3;
  v158 = v157 + 1;
  if ((unint64_t)(v157 + 1) >> 61)
LABEL_192:
    abort();
  v159 = v146 - (_QWORD)v156;
  if (v159 >> 2 > v158)
    v158 = v159 >> 2;
  if ((unint64_t)v159 >= 0x7FFFFFFFFFFFFFF8)
    v160 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v160 = v158;
  if (!v160)
  {
    v161 = 0;
    v162 = (uint64_t *)(8 * v157);
    v163 = 0;
    *(_QWORD *)(8 * v157) = v143;
    v148 = 8 * v157 + 8;
    v164 = (char *)(v147 - v156);
    if (v147 != v156)
      goto LABEL_176;
    goto LABEL_188;
  }
  if (v160 >> 61)
LABEL_193:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v161 = (char *)operator new(8 * v160);
  v162 = (uint64_t *)&v161[8 * v157];
  v163 = &v161[8 * v160];
  *v162 = v143;
  v148 = (uint64_t)(v162 + 1);
  v164 = (char *)(v147 - v156);
  if (v147 != v156)
  {
LABEL_176:
    v165 = (unint64_t)(v164 - 8);
    if (v165 < 0x78
      || &v147[-(v165 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v162
      && &v161[v147 - v156 - (v165 & 0xFFFFFFFFFFFFFFF8) - 8] < v147)
    {
      goto LABEL_200;
    }
    v166 = (v165 >> 3) + 1;
    v167 = 8 * (v166 & 0x3FFFFFFFFFFFFFFCLL);
    v168 = &v147[-v167];
    v162 = (uint64_t *)((char *)v162 - v167);
    v169 = &v161[8 * v157 - 16];
    v170 = v147 - 16;
    v171 = v166 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v173 = *((_OWORD *)v170 - 1);
      v172 = *(_OWORD *)v170;
      *((_OWORD *)v170 - 1) = 0uLL;
      *(_OWORD *)v170 = 0uLL;
      *((_OWORD *)v169 - 1) = v173;
      *(_OWORD *)v169 = v172;
      v169 -= 32;
      v170 -= 32;
      v171 -= 4;
    }
    while (v171);
    v147 = v168;
    if (v166 != (v166 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_200:
      do
      {
        v174 = *((_QWORD *)v147 - 1);
        v147 -= 8;
        *(_QWORD *)v147 = 0;
        *--v162 = v174;
      }
      while (v147 != v156);
    }
    v147 = (char *)a1[1];
    v175 = (char *)a1[2];
    a1[1] = v162;
    a1[2] = v148;
    a1[3] = v163;
    while (v175 != v147)
    {
      v177 = *((_QWORD *)v175 - 1);
      v175 -= 8;
      v176 = v177;
      *(_QWORD *)v175 = 0;
      if (v177)
        (*(void (**)(uint64_t))(*(_QWORD *)v176 + 8))(v176);
    }
    goto LABEL_189;
  }
LABEL_188:
  a1[1] = v162;
  a1[2] = v148;
  a1[3] = v163;
LABEL_189:
  if (v147)
    operator delete(v147);
LABEL_191:
  a1[2] = v148;
}

void mlir::tensor::CollapseShapeOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  char *v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  const char *v46;
  unint64_t v47;
  uint64_t v48;
  const char *v49;
  unint64_t v50;
  char *v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  char *v56;
  uint64_t *v57;
  char *v58;
  char *v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;
  uint64_t v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  char *v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  const char *v81;
  unint64_t v82;
  uint64_t v83;
  const char *v84;
  unint64_t v85;
  char *v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  char *v91;
  uint64_t *v92;
  char *v93;
  char *v94;
  unint64_t v95;
  uint64_t v96;
  uint64_t v97;
  char *v98;
  char *v99;
  char *v100;
  uint64_t v101;
  __int128 v102;
  __int128 v103;
  uint64_t v104;
  char *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  unint64_t v110;
  unint64_t v111;
  char *v112;
  uint64_t v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  const char *v119;
  unint64_t v120;
  char *v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  unint64_t v125;
  char *v126;
  uint64_t *v127;
  char *v128;
  char *v129;
  unint64_t v130;
  uint64_t v131;
  uint64_t v132;
  char *v133;
  char *v134;
  char *v135;
  uint64_t v136;
  __int128 v137;
  __int128 v138;
  uint64_t v139;
  char *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  const char *v144;
  unint64_t v145;

  v143 = a2;
  mlir::RewritePatternSet::addImpl<mlir::ComposeReassociativeReshapeOps<mlir::tensor::CollapseShapeOp>,mlir::MLIRContext *&>(a1, 0, 0, &v143);
  mlir::RewritePatternSet::addImpl<mlir::ComposeCollapseOfExpandOp<mlir::tensor::CollapseShapeOp,mlir::tensor::ExpandShapeOp,mlir::tensor::CastOp>,mlir::MLIRContext *&>(a1, 0, 0, &v143);
  v3 = operator new();
  v4 = v143;
  mlir::PatternBenefit::PatternBenefit(&v144, 1);
  mlir::Pattern::Pattern(v3 + 8, (uint64_t)"tensor.collapse_shape", 21, (__int16)v144, v4, 0, 0);
  *(_QWORD *)v3 = &off_24C02A600;
  if (*(_QWORD *)(v3 + 72))
  {
    v5 = *(unsigned int *)(v3 + 88);
    if (v5 <= *(_DWORD *)(v3 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v3 + 80, (void *)(v3 + 96), v5, 16);
    *(_DWORD *)(v3 + 88) = *(_DWORD *)(v3 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v144 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldReshapeWithConstant<mlir::tensor::C"
         "ollapseShapeOp>]";
  v145 = 127;
  v9 = llvm::StringRef::find((uint64_t *)&v144, "DesiredTypeName = ", 0x12uLL, 0);
  if (v145 >= v9)
    v10 = v9;
  else
    v10 = v145;
  v11 = &v144[v10];
  v12 = v145 - v10;
  if (v145 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v145 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v3 + 64) = v14;
  *(_QWORD *)(v3 + 72) = v15;
  v5 = *(unsigned int *)(v3 + 88);
  if (v5 > *(_DWORD *)(v3 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v3 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v3;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_154;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_155;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v3;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v3;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_158;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_158:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  v39 = v143;
  mlir::PatternBenefit::PatternBenefit(&v144, 1);
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"tensor.collapse_shape", 21, (__int16)v144, v39, 0, 0);
  *(_QWORD *)v38 = &off_24C029BA0;
  if (*(_QWORD *)(v38 + 72))
  {
    v40 = *(unsigned int *)(v38 + 88);
    if (v40 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v40, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v42 = (char *)a1[2];
    v41 = a1[3];
    if ((unint64_t)v42 < v41)
      goto LABEL_42;
    goto LABEL_53;
  }
  v144 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldReshapeWithSplat<mlir::tensor::CollapseShapeOp>]";
  v145 = 124;
  v44 = llvm::StringRef::find((uint64_t *)&v144, "DesiredTypeName = ", 0x12uLL, 0);
  if (v145 >= v44)
    v45 = v44;
  else
    v45 = v145;
  v46 = &v144[v45];
  v47 = v145 - v45;
  if (v145 - v45 >= 0x12)
    v48 = 18;
  else
    v48 = v145 - v45;
  v49 = &v46[v48];
  v50 = v47 - v48;
  if (v50 >= v50 - 1)
    --v50;
  *(_QWORD *)(v38 + 64) = v49;
  *(_QWORD *)(v38 + 72) = v50;
  v40 = *(unsigned int *)(v38 + 88);
  if (v40 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v40;
  v42 = (char *)a1[2];
  v41 = a1[3];
  if ((unint64_t)v42 < v41)
  {
LABEL_42:
    *(_QWORD *)v42 = v38;
    v43 = (uint64_t)(v42 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v51 = (char *)a1[1];
  v52 = (v42 - v51) >> 3;
  v53 = v52 + 1;
  if ((unint64_t)(v52 + 1) >> 61)
    goto LABEL_154;
  v54 = v41 - (_QWORD)v51;
  if (v54 >> 2 > v53)
    v53 = v54 >> 2;
  if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8)
    v55 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v55 = v53;
  if (v55)
  {
    if (v55 >> 61)
      goto LABEL_155;
    v56 = (char *)operator new(8 * v55);
    v57 = (uint64_t *)&v56[8 * v52];
    v58 = &v56[8 * v55];
    *v57 = v38;
    v43 = (uint64_t)(v57 + 1);
    v59 = (char *)(v42 - v51);
    if (v42 != v51)
      goto LABEL_62;
  }
  else
  {
    v56 = 0;
    v57 = (uint64_t *)(8 * v52);
    v58 = 0;
    *(_QWORD *)(8 * v52) = v38;
    v43 = 8 * v52 + 8;
    v59 = (char *)(v42 - v51);
    if (v42 != v51)
    {
LABEL_62:
      v60 = (unint64_t)(v59 - 8);
      if (v60 < 0x78
        || &v42[-(v60 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v57
        && &v56[v42 - v51 - (v60 & 0xFFFFFFFFFFFFFFF8) - 8] < v42)
      {
        goto LABEL_159;
      }
      v61 = (v60 >> 3) + 1;
      v62 = 8 * (v61 & 0x3FFFFFFFFFFFFFFCLL);
      v63 = &v42[-v62];
      v57 = (uint64_t *)((char *)v57 - v62);
      v64 = &v56[8 * v52 - 16];
      v65 = v42 - 16;
      v66 = v61 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v68 = *((_OWORD *)v65 - 1);
        v67 = *(_OWORD *)v65;
        *((_OWORD *)v65 - 1) = 0uLL;
        *(_OWORD *)v65 = 0uLL;
        *((_OWORD *)v64 - 1) = v68;
        *(_OWORD *)v64 = v67;
        v64 -= 32;
        v65 -= 32;
        v66 -= 4;
      }
      while (v66);
      v42 = v63;
      if (v61 != (v61 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_159:
        do
        {
          v69 = *((_QWORD *)v42 - 1);
          v42 -= 8;
          *(_QWORD *)v42 = 0;
          *--v57 = v69;
        }
        while (v42 != v51);
      }
      v42 = (char *)a1[1];
      v70 = (char *)a1[2];
      a1[1] = v57;
      a1[2] = v43;
      a1[3] = v58;
      while (v70 != v42)
      {
        v72 = *((_QWORD *)v70 - 1);
        v70 -= 8;
        v71 = v72;
        *(_QWORD *)v70 = 0;
        if (v72)
          (*(void (**)(uint64_t))(*(_QWORD *)v71 + 8))(v71);
      }
      goto LABEL_75;
    }
  }
  a1[1] = v57;
  a1[2] = v43;
  a1[3] = v58;
LABEL_75:
  if (v42)
    operator delete(v42);
LABEL_77:
  a1[2] = v43;
  v73 = operator new();
  v74 = v143;
  mlir::PatternBenefit::PatternBenefit(&v144, 1);
  mlir::Pattern::Pattern(v73 + 8, (uint64_t)"tensor.collapse_shape", 21, (__int16)v144, v74, 0, 0);
  *(_QWORD *)v73 = &off_24C02AE00;
  if (*(_QWORD *)(v73 + 72))
  {
    v75 = *(unsigned int *)(v73 + 88);
    if (v75 <= *(_DWORD *)(v73 + 92))
      goto LABEL_79;
LABEL_90:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v73 + 80, (void *)(v73 + 96), v75, 16);
    *(_DWORD *)(v73 + 88) = *(_DWORD *)(v73 + 88);
    v77 = (char *)a1[2];
    v76 = a1[3];
    if ((unint64_t)v77 < v76)
      goto LABEL_80;
    goto LABEL_91;
  }
  v144 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldReshapeWithFromElements<mlir::tenso"
         "r::CollapseShapeOp>]";
  v145 = 131;
  v79 = llvm::StringRef::find((uint64_t *)&v144, "DesiredTypeName = ", 0x12uLL, 0);
  if (v145 >= v79)
    v80 = v79;
  else
    v80 = v145;
  v81 = &v144[v80];
  v82 = v145 - v80;
  if (v145 - v80 >= 0x12)
    v83 = 18;
  else
    v83 = v145 - v80;
  v84 = &v81[v83];
  v85 = v82 - v83;
  if (v85 >= v85 - 1)
    --v85;
  *(_QWORD *)(v73 + 64) = v84;
  *(_QWORD *)(v73 + 72) = v85;
  v75 = *(unsigned int *)(v73 + 88);
  if (v75 > *(_DWORD *)(v73 + 92))
    goto LABEL_90;
LABEL_79:
  *(_DWORD *)(v73 + 88) = v75;
  v77 = (char *)a1[2];
  v76 = a1[3];
  if ((unint64_t)v77 < v76)
  {
LABEL_80:
    *(_QWORD *)v77 = v73;
    v78 = (uint64_t)(v77 + 8);
    goto LABEL_115;
  }
LABEL_91:
  v86 = (char *)a1[1];
  v87 = (v77 - v86) >> 3;
  v88 = v87 + 1;
  if ((unint64_t)(v87 + 1) >> 61)
    goto LABEL_154;
  v89 = v76 - (_QWORD)v86;
  if (v89 >> 2 > v88)
    v88 = v89 >> 2;
  if ((unint64_t)v89 >= 0x7FFFFFFFFFFFFFF8)
    v90 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v90 = v88;
  if (v90)
  {
    if (v90 >> 61)
      goto LABEL_155;
    v91 = (char *)operator new(8 * v90);
    v92 = (uint64_t *)&v91[8 * v87];
    v93 = &v91[8 * v90];
    *v92 = v73;
    v78 = (uint64_t)(v92 + 1);
    v94 = (char *)(v77 - v86);
    if (v77 != v86)
      goto LABEL_100;
  }
  else
  {
    v91 = 0;
    v92 = (uint64_t *)(8 * v87);
    v93 = 0;
    *(_QWORD *)(8 * v87) = v73;
    v78 = 8 * v87 + 8;
    v94 = (char *)(v77 - v86);
    if (v77 != v86)
    {
LABEL_100:
      v95 = (unint64_t)(v94 - 8);
      if (v95 < 0x78
        || &v77[-(v95 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v92
        && &v91[v77 - v86 - (v95 & 0xFFFFFFFFFFFFFFF8) - 8] < v77)
      {
        goto LABEL_160;
      }
      v96 = (v95 >> 3) + 1;
      v97 = 8 * (v96 & 0x3FFFFFFFFFFFFFFCLL);
      v98 = &v77[-v97];
      v92 = (uint64_t *)((char *)v92 - v97);
      v99 = &v91[8 * v87 - 16];
      v100 = v77 - 16;
      v101 = v96 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v103 = *((_OWORD *)v100 - 1);
        v102 = *(_OWORD *)v100;
        *((_OWORD *)v100 - 1) = 0uLL;
        *(_OWORD *)v100 = 0uLL;
        *((_OWORD *)v99 - 1) = v103;
        *(_OWORD *)v99 = v102;
        v99 -= 32;
        v100 -= 32;
        v101 -= 4;
      }
      while (v101);
      v77 = v98;
      if (v96 != (v96 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_160:
        do
        {
          v104 = *((_QWORD *)v77 - 1);
          v77 -= 8;
          *(_QWORD *)v77 = 0;
          *--v92 = v104;
        }
        while (v77 != v86);
      }
      v77 = (char *)a1[1];
      v105 = (char *)a1[2];
      a1[1] = v92;
      a1[2] = v78;
      a1[3] = v93;
      while (v105 != v77)
      {
        v107 = *((_QWORD *)v105 - 1);
        v105 -= 8;
        v106 = v107;
        *(_QWORD *)v105 = 0;
        if (v107)
          (*(void (**)(uint64_t))(*(_QWORD *)v106 + 8))(v106);
      }
      goto LABEL_113;
    }
  }
  a1[1] = v92;
  a1[2] = v78;
  a1[3] = v93;
LABEL_113:
  if (v77)
    operator delete(v77);
LABEL_115:
  a1[2] = v78;
  v108 = operator new();
  v109 = v143;
  mlir::PatternBenefit::PatternBenefit(&v144, 1);
  mlir::Pattern::Pattern(v108 + 8, (uint64_t)"tensor.collapse_shape", 21, (__int16)v144, v109, 0, 0);
  *(_QWORD *)v108 = &off_24C029A98;
  if (*(_QWORD *)(v108 + 72))
  {
    v110 = *(unsigned int *)(v108 + 88);
    if (v110 <= *(_DWORD *)(v108 + 92))
      goto LABEL_117;
LABEL_128:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v108 + 80, (void *)(v108 + 96), v110, 16);
    *(_DWORD *)(v108 + 88) = *(_DWORD *)(v108 + 88);
    v112 = (char *)a1[2];
    v111 = a1[3];
    if ((unint64_t)v112 < v111)
      goto LABEL_118;
    goto LABEL_129;
  }
  v144 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldCollapseOfCastOp]";
  v145 = 93;
  v114 = llvm::StringRef::find((uint64_t *)&v144, "DesiredTypeName = ", 0x12uLL, 0);
  if (v145 >= v114)
    v115 = v114;
  else
    v115 = v145;
  v116 = &v144[v115];
  v117 = v145 - v115;
  if (v145 - v115 >= 0x12)
    v118 = 18;
  else
    v118 = v145 - v115;
  v119 = &v116[v118];
  v120 = v117 - v118;
  if (v120 >= v120 - 1)
    --v120;
  *(_QWORD *)(v108 + 64) = v119;
  *(_QWORD *)(v108 + 72) = v120;
  v110 = *(unsigned int *)(v108 + 88);
  if (v110 > *(_DWORD *)(v108 + 92))
    goto LABEL_128;
LABEL_117:
  *(_DWORD *)(v108 + 88) = v110;
  v112 = (char *)a1[2];
  v111 = a1[3];
  if ((unint64_t)v112 < v111)
  {
LABEL_118:
    *(_QWORD *)v112 = v108;
    v113 = (uint64_t)(v112 + 8);
    goto LABEL_153;
  }
LABEL_129:
  v121 = (char *)a1[1];
  v122 = (v112 - v121) >> 3;
  v123 = v122 + 1;
  if ((unint64_t)(v122 + 1) >> 61)
LABEL_154:
    abort();
  v124 = v111 - (_QWORD)v121;
  if (v124 >> 2 > v123)
    v123 = v124 >> 2;
  if ((unint64_t)v124 >= 0x7FFFFFFFFFFFFFF8)
    v125 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v125 = v123;
  if (!v125)
  {
    v126 = 0;
    v127 = (uint64_t *)(8 * v122);
    v128 = 0;
    *(_QWORD *)(8 * v122) = v108;
    v113 = 8 * v122 + 8;
    v129 = (char *)(v112 - v121);
    if (v112 != v121)
      goto LABEL_138;
    goto LABEL_150;
  }
  if (v125 >> 61)
LABEL_155:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v126 = (char *)operator new(8 * v125);
  v127 = (uint64_t *)&v126[8 * v122];
  v128 = &v126[8 * v125];
  *v127 = v108;
  v113 = (uint64_t)(v127 + 1);
  v129 = (char *)(v112 - v121);
  if (v112 != v121)
  {
LABEL_138:
    v130 = (unint64_t)(v129 - 8);
    if (v130 < 0x78
      || &v112[-(v130 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v127
      && &v126[v112 - v121 - (v130 & 0xFFFFFFFFFFFFFFF8) - 8] < v112)
    {
      goto LABEL_161;
    }
    v131 = (v130 >> 3) + 1;
    v132 = 8 * (v131 & 0x3FFFFFFFFFFFFFFCLL);
    v133 = &v112[-v132];
    v127 = (uint64_t *)((char *)v127 - v132);
    v134 = &v126[8 * v122 - 16];
    v135 = v112 - 16;
    v136 = v131 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v138 = *((_OWORD *)v135 - 1);
      v137 = *(_OWORD *)v135;
      *((_OWORD *)v135 - 1) = 0uLL;
      *(_OWORD *)v135 = 0uLL;
      *((_OWORD *)v134 - 1) = v138;
      *(_OWORD *)v134 = v137;
      v134 -= 32;
      v135 -= 32;
      v136 -= 4;
    }
    while (v136);
    v112 = v133;
    if (v131 != (v131 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_161:
      do
      {
        v139 = *((_QWORD *)v112 - 1);
        v112 -= 8;
        *(_QWORD *)v112 = 0;
        *--v127 = v139;
      }
      while (v112 != v121);
    }
    v112 = (char *)a1[1];
    v140 = (char *)a1[2];
    a1[1] = v127;
    a1[2] = v113;
    a1[3] = v128;
    while (v140 != v112)
    {
      v142 = *((_QWORD *)v140 - 1);
      v140 -= 8;
      v141 = v142;
      *(_QWORD *)v140 = 0;
      if (v142)
        (*(void (**)(uint64_t))(*(_QWORD *)v141 + 8))(v141);
    }
    goto LABEL_151;
  }
LABEL_150:
  a1[1] = v127;
  a1[2] = v113;
  a1[3] = v128;
LABEL_151:
  if (v112)
    operator delete(v112);
LABEL_153:
  a1[2] = v113;
}

unint64_t mlir::tensor::ExpandShapeOp::fold(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t DefiningOp;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL4 v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v15;

  v2 = *a1;
  v3 = *(uint64_t **)(a2 + 48);
  v15 = *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (DefiningOp)
  {
    v5 = DefiningOp;
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CollapseShapeOp,void>::id)
    {
      v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
      v7 = *(_DWORD *)(v2 + 36) ? v2 - 16 : 0;
      if (v6 == (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
        return *(_QWORD *)(*(_QWORD *)(v5 + 72) + 24) | 4;
    }
  }
  v8 = *v3;
  if (!*v3)
    return 0;
  v9 = mlir::DenseElementsAttr::classof(*v3);
  v10 = v9 ? v8 : 0;
  v15 = v10;
  if (!v9)
    return 0;
  if (*(_DWORD *)(v2 + 36))
    v11 = v2 - 16;
  else
    v11 = 0;
  v12 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v12)
    v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v12 + 8);
  else
    v13 = 0;
  return mlir::DenseElementsAttr::reshape(&v15, (uint64_t)v12, v13) & 0xFFFFFFFFFFFFFFFBLL;
}

unint64_t mlir::tensor::CollapseShapeOp::fold(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t DefiningOp;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL4 v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v15;

  v2 = *a1;
  v3 = *(uint64_t **)(a2 + 48);
  v15 = *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (DefiningOp)
  {
    v5 = DefiningOp;
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::ExpandShapeOp,void>::id)
    {
      v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
      v7 = *(_DWORD *)(v2 + 36) ? v2 - 16 : 0;
      if (v6 == (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
        return *(_QWORD *)(*(_QWORD *)(v5 + 72) + 24) | 4;
    }
  }
  v8 = *v3;
  if (!*v3)
    return 0;
  v9 = mlir::DenseElementsAttr::classof(*v3);
  v10 = v9 ? v8 : 0;
  v15 = v10;
  if (!v9)
    return 0;
  if (*(_DWORD *)(v2 + 36))
    v11 = v2 - 16;
  else
    v11 = 0;
  v12 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v12)
    v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v12 + 8);
  else
    v13 = 0;
  return mlir::DenseElementsAttr::reshape(&v15, (uint64_t)v12, v13) & 0xFFFFFFFFFFFFFFFBLL;
}

uint64_t mlir::tensor::ExtractSliceOp::getAsmResultNames(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v4;
  uint64_t NextResultAtOffset;

  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v4 = *(_QWORD *)a1 - 16;
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return a2(a3, NextResultAtOffset, "extracted_slice", 15);
}

uint64_t mlir::tensor::ExtractSliceOp::inferResultType(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t RHS;
  uint64_t v15;
  uint64_t v17;
  void *v18[2];
  _BYTE v19[48];
  void *v20[2];
  _BYTE v21[48];
  void *v22[2];
  _BYTE v23[48];
  void *v24[2];
  _BYTE v25[48];
  _BYTE *v26;
  uint64_t v27;
  _BYTE v28[48];
  void *v29[2];
  _QWORD v30[8];

  v30[6] = *MEMORY[0x24BDAC8D0];
  v29[0] = v30;
  v29[1] = (void *)0x600000000;
  v26 = v28;
  v27 = 0x600000000;
  v24[0] = v25;
  v24[1] = (void *)0x600000000;
  v22[0] = v23;
  v22[1] = (void *)0x600000000;
  v20[0] = v21;
  v20[1] = (void *)0x600000000;
  v18[0] = v19;
  v18[1] = (void *)0x600000000;
  mlir::dispatchIndexOpFoldResults(a2, a3, (uint64_t)v22, (uint64_t)v29);
  mlir::dispatchIndexOpFoldResults(a4, a5, (uint64_t)v20, (uint64_t)&v26);
  mlir::dispatchIndexOpFoldResults(a6, a7, (uint64_t)v18, (uint64_t)v24);
  v12 = (uint64_t)v26;
  v13 = v27;
  v17 = a1;
  RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v17);
  v15 = mlir::RankedTensorType::get(v12, v13, RHS, 0);
  if (v18[0] != v19)
    free(v18[0]);
  if (v20[0] != v21)
    free(v20[0]);
  if (v22[0] != v23)
    free(v22[0]);
  if (v24[0] != v25)
    free(v24[0]);
  if (v26 != v28)
    free(v26);
  if (v29[0] != v30)
    free(v29[0]);
  return v15;
}

uint64_t mlir::tensor::ExtractSliceOp::inferCanonicalRankReducedResultType(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t RHS;
  int v10;
  int v11;
  uint64_t Value;
  uint64_t v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  void **v21;
  void **v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  _QWORD v27[7];

  v27[6] = *MEMORY[0x24BDAC8D0];
  v25 = a2;
  RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v25);
  v24 = mlir::RankedTensorType::get(a5, a6, RHS, 0);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v24);
  v11 = v10 - a1;
  if (v10 - a1 >= 1)
  {
    Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v24);
    v14 = v13;
    mlir::getPositionsOfShapeOne(v11, Value, v13, (unint64_t *)&v23);
    v25 = v27;
    v26 = 0x600000000;
    v15 = 0;
    if (v14)
    {
      v16 = 0;
      while (1)
      {
        if ((v23 & 1) != 0)
        {
          if (((1 << v16) & ((unint64_t)v23 >> 1) & ~(-1 << ((unint64_t)v23 >> 58))) == 0)
          {
LABEL_10:
            v17 = *(_QWORD *)(Value + 8 * v16);
            if (v15 >= HIDWORD(v26))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v15 + 1, 8);
              v15 = v26;
            }
            *((_QWORD *)v25 + v15) = v17;
            v15 = v26 + 1;
            LODWORD(v26) = v26 + 1;
          }
        }
        else if ((*((_QWORD *)*v23 + (v16 >> 6)) & (1 << v16)) == 0)
        {
          goto LABEL_10;
        }
        if (v14 == ++v16)
        {
          v18 = v25;
          goto LABEL_14;
        }
      }
    }
    v18 = v27;
LABEL_14:
    v19 = v15;
    v20 = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v24);
    v24 = mlir::RankedTensorType::get((uint64_t)v18, v19, v20, 0);
    if (v25 != v27)
      free(v25);
    v21 = v23;
    if ((v23 & 1) == 0 && v23)
    {
      if (*v23 != v23 + 2)
        free(*v23);
      MEMORY[0x20BD002F8](v21, 0x1080C40EF38A13ELL);
    }
  }
  return v24;
}

BOOL llvm::SmallBitVector::test(llvm::SmallBitVector *this, unsigned int a2)
{
  unint64_t v2;

  v2 = *(_QWORD *)this;
  if ((*(_QWORD *)this & 1) != 0)
    return ((1 << a2) & (v2 >> 1) & ~(-1 << (v2 >> 58))) != 0;
  else
    return (*(_QWORD *)(*(_QWORD *)v2 + 8 * (a2 >> 6)) & (1 << a2)) != 0;
}

uint64_t mlir::tensor::ExtractSliceOp::inferCanonicalRankReducedResultType(int a1, void *a2, uint64_t *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t a8)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v18[2];
  _BYTE v19[48];
  void *v20[2];
  _BYTE v21[48];
  void *v22[2];
  _BYTE v23[48];
  void *v24[2];
  _BYTE v25[48];
  _BYTE *v26;
  uint64_t v27;
  _BYTE v28[48];
  void *v29[2];
  _QWORD v30[8];

  v30[6] = *MEMORY[0x24BDAC8D0];
  v29[0] = v30;
  v29[1] = (void *)0x600000000;
  v26 = v28;
  v27 = 0x600000000;
  v24[0] = v25;
  v24[1] = (void *)0x600000000;
  v22[0] = v23;
  v22[1] = (void *)0x600000000;
  v20[0] = v21;
  v20[1] = (void *)0x600000000;
  v18[0] = v19;
  v18[1] = (void *)0x600000000;
  mlir::dispatchIndexOpFoldResults(a3, a4, (uint64_t)v22, (uint64_t)v29);
  mlir::dispatchIndexOpFoldResults(a5, a6, (uint64_t)v20, (uint64_t)&v26);
  mlir::dispatchIndexOpFoldResults(a7, a8, (uint64_t)v18, (uint64_t)v24);
  v16 = mlir::tensor::ExtractSliceOp::inferCanonicalRankReducedResultType(a1, a2, v14, v15, (uint64_t)v26, v27);
  if (v18[0] != v19)
    free(v18[0]);
  if (v20[0] != v21)
    free(v20[0]);
  if (v22[0] != v23)
    free(v22[0]);
  if (v24[0] != v25)
    free(v24[0]);
  if (v26 != v28)
    free(v26);
  if (v29[0] != v30)
    free(v29[0]);
  return v16;
}

void mlir::tensor::ExtractSliceOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t *a9, uint64_t a10, void *__src, uint64_t a12)
{
  uint64_t v18;
  uint64_t v19;
  uint64_t RHS;
  uint64_t DenseI64ArrayAttr;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26[2];
  unint64_t v27[2];
  unint64_t v28[2];
  void *v29;
  uint64_t v30;
  _BYTE v31[48];
  void *v32;
  uint64_t v33;
  _BYTE v34[48];
  void *v35;
  uint64_t v36;
  _BYTE v37[48];
  void *v38;
  uint64_t v39;
  _BYTE v40[48];
  _BYTE *v41;
  uint64_t v42;
  _BYTE v43[48];
  _QWORD *v44;
  uint64_t v45;
  _QWORD v46[8];

  v46[6] = *MEMORY[0x24BDAC8D0];
  v44 = v46;
  v45 = 0x600000000;
  v41 = v43;
  v42 = 0x600000000;
  v38 = v40;
  v39 = 0x600000000;
  v35 = v37;
  v36 = 0x600000000;
  v32 = v34;
  v33 = 0x600000000;
  v29 = v31;
  v30 = 0x600000000;
  mlir::dispatchIndexOpFoldResults(a5, a6, (uint64_t)&v35, (uint64_t)&v44);
  mlir::dispatchIndexOpFoldResults(a7, a8, (uint64_t)&v32, (uint64_t)&v41);
  mlir::dispatchIndexOpFoldResults(a9, a10, (uint64_t)&v29, (uint64_t)&v38);
  if (!a3)
  {
    v18 = (uint64_t)v41;
    v19 = v42;
    v25 = *(_QWORD *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8;
    RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v25);
    a3 = mlir::RankedTensorType::get(v18, v19, RHS, 0);
  }
  mlir::ValueRange::ValueRange(v28, (uint64_t)v35, v36);
  mlir::ValueRange::ValueRange(v27, (uint64_t)v32, v33);
  mlir::ValueRange::ValueRange(v26, (uint64_t)v29, v30);
  DenseI64ArrayAttr = mlir::Builder::getDenseI64ArrayAttr(a1, (uint64_t)v44, v45);
  v22 = mlir::Builder::getDenseI64ArrayAttr(a1, (uint64_t)v41, v42);
  v23 = mlir::Builder::getDenseI64ArrayAttr(a1, (uint64_t)v38, v39);
  mlir::tensor::ExtractSliceOp::build(v23, a2, a3, a4, v28[0], v28[1], v27[0], v27[1], v26[0], v26[1], DenseI64ArrayAttr, v22, v23);
  *(_QWORD *)(a2 + 192) = 0;
  v24 = *(unsigned int *)(a2 + 120);
  if (a12 + v24 > (unint64_t)*(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), a12 + v24, 16);
    LODWORD(v24) = *(_DWORD *)(a2 + 120);
  }
  if (a12)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 112) + 16 * v24), __src, 16 * a12);
    LODWORD(v24) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v24 + a12;
  if (v29 != v31)
    free(v29);
  if (v32 != v34)
    free(v32);
  if (v35 != v37)
    free(v35);
  if (v38 != v40)
    free(v38);
  if (v41 != v43)
    free(v41);
  if (v44 != v46)
    free(v44);
}

void mlir::tensor::ExtractSliceOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  _DWORD *v18;
  uint64_t v19;
  uint64_t v21;

  v21 = a4;
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  mlir::OperationState::addOperands(a2, a5, a6);
  mlir::OperationState::addOperands(a2, a7, a8);
  mlir::OperationState::addOperands(a2, a9, a10);
  v18 = (_DWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2);
  v18[6] = 1;
  v18[7] = a6;
  v18[8] = a8;
  v18[9] = a10;
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2) = a11;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a12;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a13;
  v19 = *(unsigned int *)(a2 + 72);
  if (v19 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v19 + 1, 8);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v19) = a3;
  ++*(_DWORD *)(a2 + 72);
}

void mlir::tensor::ExtractSliceOp::verify(mlir::tensor::ExtractSliceOp *this)
{
  unint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  int isRankReducedType;
  void *v12;
  unsigned int v13;
  uint64_t v14;
  void *v15;
  unsigned int v16;
  uint64_t v17;
  void *v18;
  unsigned int v19;
  _QWORD v20[5];

  v20[4] = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedOffsets(this, (uint64_t)&v18);
  v3 = (uint64_t *)v18;
  v4 = v19;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedSizes(this, (uint64_t)&v15);
  v5 = (uint64_t *)v15;
  v6 = v16;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedStrides(this, (uint64_t)&v12);
  v7 = (_QWORD *)mlir::tensor::ExtractSliceOp::inferResultType(v2, v3, v4, v5, v6, (uint64_t *)v12, v13);
  if (v12 != &v14)
    free(v12);
  if (v15 != &v17)
    free(v15);
  if (v18 != v20)
    free(v18);
  if (v7)
    v8 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v7 + 8);
  else
    v8 = 0;
  if (*(_DWORD *)(*(_QWORD *)this + 36))
    v9 = *(_QWORD *)this - 16;
  else
    v9 = 0;
  v10 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v10)
    mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v10 + 8);
  isRankReducedType = mlir::isRankReducedType(v7, v8, v10);
  produceSliceErrorMsg(isRankReducedType);
}

void produceSliceErrorMsg(int a1)
{
  __asm { BR              X11 }
}

uint64_t sub_207518B7C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, __int16 a13, int a14, __int16 a15, char a16, int a17, int a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,int a25,int a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,void *__p,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52)
{
  uint64_t *v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60;
  _QWORD *v61;
  _QWORD *v62;
  void *v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v67;
  int64_t v68;
  const char *v69;
  __int16 v70;
  int v71;
  const char *v72;
  uint64_t v73;
  _QWORD v74[3];
  int *v75;
  unsigned int v76;
  unsigned int v77;
  _BYTE v78[96];
  _QWORD *v79;
  _QWORD *v80;
  _QWORD *v81;
  _QWORD *v82;
  char v83;

  v69 = "expected rank to be smaller or equal to ";
  v70 = 259;
  mlir::Operation::emitError(v52, (uint64_t)&v69, (uint64_t)v74);
  if (v74[0])
  {
    v71 = 3;
    v72 = "the other rank. ";
    v73 = 16;
    v53 = &v71;
    v54 = v75;
    if (v76 >= v77)
    {
      v67 = v76 + 1;
      if (v75 <= &v71 && &v75[6 * v76] > &v71)
      {
        v68 = (char *)&v71 - (char *)v75;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v67, 24);
        v54 = v75;
        v53 = (int *)((char *)v75 + v68);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v67, 24);
        v53 = &v71;
        v54 = v75;
      }
    }
    v55 = &v54[6 * v76];
    v56 = *(_OWORD *)v53;
    *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
    *(_OWORD *)v55 = v56;
    ++v76;
  }
  v57 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v74);
  if (v74[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
  if (v83)
  {
    v58 = v81;
    if (v81)
    {
      v59 = v82;
      v60 = v81;
      if (v82 != v81)
      {
        do
          v59 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v59 - 1);
        while (v59 != v58);
        v60 = v81;
      }
      v82 = v58;
      operator delete(v60);
    }
    v61 = v79;
    if (v79)
    {
      v62 = v80;
      v63 = v79;
      if (v80 != v79)
      {
        do
        {
          v65 = *--v62;
          v64 = v65;
          *v62 = 0;
          if (v65)
            MEMORY[0x20BD002D4](v64, 0x1000C8077774924);
        }
        while (v62 != v61);
        v63 = v79;
      }
      v80 = v61;
      operator delete(v63);
    }
    if (v75 != (int *)v78)
      free(v75);
  }
  return v57;
}

void getDroppedDims(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  void *v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  uint64_t v19;
  uint64_t Int;
  unint64_t v21;

  if (a5 >= 0x3A)
  {
    v11 = operator new();
    v10 = v11;
    v12 = a5 + 63;
    v13 = (a5 + 63) >> 6;
    *(_QWORD *)v11 = v11 + 16;
    *(_DWORD *)(v11 + 12) = 6;
    if ((a5 + 63) < 0x1C0)
    {
      if (v12 < 0x40)
      {
LABEL_9:
        *(_DWORD *)(v10 + 8) = v13;
        *(_DWORD *)(v10 + 64) = a5;
        *a1 = v10;
        goto LABEL_10;
      }
      v14 = (void *)(v11 + 16);
      v15 = 8 * v13;
    }
    else
    {
      *(_DWORD *)(v11 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v11, (void *)(v11 + 16), v12 >> 6, 8);
      v14 = *(void **)v10;
      v15 = 8 * v13;
    }
    bzero(v14, v15);
    goto LABEL_9;
  }
  v10 = (a5 << 58) | 1;
  *a1 = v10;
  if (a5)
  {
LABEL_10:
    v16 = 0;
    v17 = 0;
    for (i = 8 * a5; i; i -= 8)
    {
      v19 = *(_QWORD *)(a4 + 8 * v17);
      if ((v19 & 4) != 0)
      {
        if (v16 == a3)
          goto LABEL_19;
      }
      else
      {
        v21 = v19 & 0xFFFFFFFFFFFFFFF8;
        Int = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v21);
        if (v16 == a3 || Int == 1 && *(_QWORD *)(a2 + 8 * v16) != 1)
        {
LABEL_19:
          if ((v10 & 1) != 0)
          {
            v10 = v10 & 0xFC00000000000000 | (2
                                              * (((v10 >> 1) & ~(-1 << (v10 >> 58)) | (1 << v17)) & ~(-1 << (v10 >> 58)))) | 1;
            *a1 = v10;
          }
          else
          {
            *(_QWORD *)(*(_QWORD *)v10 + 8 * (v17 >> 6)) |= 1 << v17;
          }
          goto LABEL_12;
        }
      }
      ++v16;
LABEL_12:
      ++v17;
    }
  }
}

uint64_t mlir::tensor::ExtractSliceOp::reifyResultShapes(mlir::memref::ReinterpretCastOp *a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  int v23;
  _QWORD *v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t Value;
  uint64_t v28;
  uint64_t v29;
  void **v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  void **v44;
  unint64_t v45;
  void *__dst;
  uint64_t v47;
  _BYTE v48[48];
  void *__src;
  uint64_t v50;
  _QWORD v51[5];

  v51[4] = *MEMORY[0x24BDAC8D0];
  v5 = a3[2];
  if ((_DWORD)v5)
  {
    if ((_DWORD)v5 == 1)
      goto LABEL_19;
    v6 = *(_QWORD *)a3;
    v7 = v5 << 6;
    do
    {
      v8 = *(void **)(v6 + v7 - 64);
      if ((void *)(v6 + v7 - 48) != v8)
        free(v8);
      v7 -= 64;
    }
    while (v7 != 64);
  }
  else
  {
    if (a3[3])
    {
      v9 = 0;
    }
    else
    {
      llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::OpFoldResult,6u>,false>::grow((uint64_t)a3, 1uLL);
      v9 = a3[2];
      if ((_DWORD)v9 == 1)
        goto LABEL_18;
    }
    v10 = *(_QWORD *)a3;
    v11 = *(_QWORD *)a3 + (v9 << 6);
    v12 = -v9 & 0x3FFFFFFFFFFFFFFLL;
    if (v12)
    {
      v13 = v12 + 1;
      v14 = (v12 + 1) & 0x7FFFFFFFFFFFFFELL;
      v15 = v11 + (v14 << 6);
      v16 = v11 + 80;
      v17 = v14;
      do
      {
        *(_QWORD *)(v16 - 80) = v16 - 64;
        *(_QWORD *)(v16 - 16) = v16;
        *(_QWORD *)(v16 - 72) = 0x600000000;
        *(_QWORD *)(v16 - 8) = 0x600000000;
        v16 += 128;
        v17 -= 2;
      }
      while (v17);
      if (v13 == v14)
        goto LABEL_18;
    }
    else
    {
      v15 = v11;
    }
    v18 = v15 + 16;
    do
    {
      v19 = v18 - 16;
      *(_QWORD *)(v18 - 16) = v18;
      *(_QWORD *)(v18 - 8) = 0x600000000;
      v18 += 64;
    }
    while (v19 != v10);
  }
LABEL_18:
  a3[2] = 1;
LABEL_19:
  v20 = *(_QWORD *)a3;
  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v21 = *(_QWORD *)a1 - 16;
  else
    v21 = 0;
  __dst = (void *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v21, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&__dst);
  if (v22 > *(unsigned int *)(v20 + 12))
    llvm::SmallVectorBase<unsigned int>::grow_pod(v20, (void *)(v20 + 16), v22, 8);
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedSizes(a1, (uint64_t)&__src);
  __dst = v48;
  v47 = 0x600000000;
  v23 = v50;
  v24 = __src;
  if ((_DWORD)v50)
  {
    if (__src == v51)
    {
      v25 = v50;
      if (v50 < 7
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v48, v50, 8),
            v25 = v50,
            v24 = __src,
            (_DWORD)v50))
      {
        memcpy(__dst, v24, 8 * v25);
        v24 = __src;
      }
      LODWORD(v47) = v23;
    }
    else
    {
      __dst = __src;
      v47 = v50;
      __src = v51;
      HIDWORD(v50) = 0;
      v24 = v51;
    }
    LODWORD(v50) = 0;
  }
  if (v24 != v51)
    free(v24);
  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v26 = *(_QWORD *)a1 - 16;
  else
    v26 = 0;
  v45 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v26, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v45);
  v29 = v28;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedSizes(a1, (uint64_t)&__src);
  getDroppedDims((unint64_t *)&v44, Value, v29, (uint64_t)__src, v50);
  if (__src != v51)
    free(__src);
  v30 = v44;
  if (!(_DWORD)v47)
  {
    if ((v44 & 1) != 0)
      goto LABEL_52;
    goto LABEL_48;
  }
  v31 = __dst;
  if ((v44 & 1) == 0)
  {
    v32 = 0;
    v33 = 8 * v47;
    do
    {
      if (((*((_QWORD *)*v30 + (v32 >> 6)) >> v32) & 1) == 0)
      {
        v34 = *(_QWORD *)a3;
        v35 = v31[v32];
        v36 = *(unsigned int *)(*(_QWORD *)a3 + 8);
        if (v36 >= *(unsigned int *)(*(_QWORD *)a3 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(*(_QWORD *)a3, (void *)(v34 + 16), v36 + 1, 8);
          v36 = *(unsigned int *)(v34 + 8);
        }
        *(_QWORD *)(*(_QWORD *)v34 + 8 * v36) = v35;
        ++*(_DWORD *)(v34 + 8);
      }
      ++v32;
      v33 -= 8;
    }
    while (v33);
LABEL_48:
    if (v30)
    {
      if (*v30 != v30 + 2)
        free(*v30);
      MEMORY[0x20BD002F8](v30, 0x1080C40EF38A13ELL);
    }
    goto LABEL_52;
  }
  v38 = 0;
  v39 = 8 * v47;
  v40 = ((unint64_t)v44 >> 1) & ~(-1 << ((unint64_t)v44 >> 58));
  do
  {
    if ((v40 & (1 << v38)) == 0)
    {
      v41 = *(_QWORD *)a3;
      v42 = v31[v38];
      v43 = *(unsigned int *)(*(_QWORD *)a3 + 8);
      if (v43 >= *(unsigned int *)(*(_QWORD *)a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(*(_QWORD *)a3, (void *)(v41 + 16), v43 + 1, 8);
        v43 = *(unsigned int *)(v41 + 8);
      }
      *(_QWORD *)(*(_QWORD *)v41 + 8 * v43) = v42;
      ++*(_DWORD *)(v41 + 8);
    }
    ++v38;
    v39 -= 8;
  }
  while (v39);
LABEL_52:
  if (__dst != v48)
    free(__dst);
  return 1;
}

void mlir::tensor::ExtractSliceOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  unint64_t v40;

  v38 = a2;
  mlir::RewritePatternSet::addImpl<mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp,SliceReturnTypeCanonicalizer,SliceCanonicalizer>,mlir::MLIRContext *&>(a1, 0, 0, &v38);
  v3 = operator new();
  v4 = v38;
  mlir::PatternBenefit::PatternBenefit(&v39, 1);
  mlir::Pattern::Pattern(v3 + 8, (uint64_t)"tensor.extract_slice", 20, (__int16)v39, v4, 0, 0);
  *(_QWORD *)v3 = &off_24C02A760;
  if (*(_QWORD *)(v3 + 72))
  {
    v5 = *(unsigned int *)(v3 + 88);
    if (v5 <= *(_DWORD *)(v3 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v3 + 80, (void *)(v3 + 96), v5, 16);
    *(_DWORD *)(v3 + 88) = *(_DWORD *)(v3 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v39 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::ExtractSliceOpCastFolder]";
  v40 = 97;
  v9 = llvm::StringRef::find((uint64_t *)&v39, "DesiredTypeName = ", 0x12uLL, 0);
  if (v40 >= v9)
    v10 = v9;
  else
    v10 = v40;
  v11 = &v39[v10];
  v12 = v40 - v10;
  if (v40 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v40 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v3 + 64) = v14;
  *(_QWORD *)(v3 + 72) = v15;
  v5 = *(unsigned int *)(v3 + 88);
  if (v5 > *(_DWORD *)(v3 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v3 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v3;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    abort();
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v3;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v3;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_44;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_44:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
}

unint64_t mlir::tensor::ExtractSliceOp::fold(uint64_t *a1, uint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t NextResultAtOffset;
  unint64_t result;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t DefiningOp;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t InterfaceFor;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;

  v3 = *(uint64_t **)(a2 + 80);
  v4 = *v3;
  if (*v3)
  {
    if (mlir::DenseElementsAttr::classof(*v3))
      v5 = v4;
    else
      v5 = 0;
    v24 = v5;
    if (v5)
    {
      if (!mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v24))
        v4 = 0;
    }
    else
    {
      v4 = 0;
    }
  }
  if (*(_DWORD *)(*a1 + 36))
    v6 = *a1 - 16;
  else
    v6 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
  result = reshapeConstantSource(v4, (_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
  if (result <= 7)
  {
    if (*(_DWORD *)(*a1 + 36))
      v10 = *a1 - 16;
    else
      v10 = 0;
    v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
    if (v9 != (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
    {
LABEL_18:
      v11 = *a1;
      v24 = *(_QWORD *)(*(_QWORD *)(v11 + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v24);
      if (!DefiningOp)
        return 0;
      v13 = DefiningOp;
      if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::tensor::InsertSliceOp,void>::id)
        return 0;
      v14 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
      v15 = *(_DWORD *)(v11 + 36) ? v11 - 16 : 0;
      if (v14 != (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v15, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
        return 0;
      InterfaceFor = mlir::OpInterface<mlir::OffsetSizeAndStrideOpInterface,mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits>::getInterfaceFor(v11);
      v17 = mlir::OpInterface<mlir::OffsetSizeAndStrideOpInterface,mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits>::getInterfaceFor(v13);
      if ((mlir::detail::sameOffsetsSizesAndStrides(v13, v17, v11, InterfaceFor, (uint64_t (*)(uint64_t, _QWORD, _QWORD))llvm::function_ref<BOOL ()(mlir::OpFoldResult,mlir::OpFoldResult)>::callback_fn<foldExtractAfterInsertSlice(mlir::tensor::ExtractSliceOp)::$_0>, (uint64_t)&v24) & 1) == 0)return 0;
      v18 = *(_QWORD *)(*(_QWORD *)(v13 + 72) + 24);
      if (v18)
        return v18 | 4;
      else
        return 0;
    }
    v19 = *a1;
    v20 = mlir::OpInterface<mlir::OffsetSizeAndStrideOpInterface,mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits>::getInterfaceFor(*a1);
    if (*(_DWORD *)(*a1 + 36))
      v21 = *a1 - 16;
    else
      v21 = 0;
    v22 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v21, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v22)
    {
      v23 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v22 + 8);
      if (!foldIdentityOffsetSizeAndStrideOpInterface(v19, v20, (uint64_t)v22, v23))
        goto LABEL_18;
    }
    else if (!foldIdentityOffsetSizeAndStrideOpInterface(v19, v20, 0, 0))
    {
      goto LABEL_18;
    }
    return *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24) | 4;
  }
  return result;
}

uint64_t foldIdentityOffsetSizeAndStrideOpInterface(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t ConstantIntValue;
  char v8;
  BOOL v9;
  int v10;
  BOOL v11;
  uint64_t v12;
  unsigned int v13;
  _BYTE *v14;
  unsigned int v15;
  _QWORD *v16;
  char v17;
  uint64_t *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char v34;
  BOOL v35;
  BOOL v36;
  _QWORD v37[2];
  _QWORD v38[2];
  _QWORD v39[2];
  void *__src;
  uint64_t v41;
  _BYTE v42[32];
  void *__dst;
  uint64_t v44;
  _BYTE v45[32];
  _QWORD *v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  v39[0] = a1;
  v39[1] = a2;
  v38[0] = a3;
  v38[1] = a4;
  mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
  mlir::OffsetSizeAndStrideOpInterface::getMixedOffsets((uint64_t *)&__dst, (mlir::OffsetSizeAndStrideOpInterface *)v39);
  v4 = (uint64_t *)__dst;
  if ((_DWORD)v44)
  {
    v5 = 8 * v44 - 8;
    do
    {
      v6 = *v4++;
      ConstantIntValue = mlir::getConstantIntValue(v6);
      if (v8)
        v9 = ConstantIntValue == 0;
      else
        v9 = 0;
      v10 = v9;
      v11 = v10 != 1 || v5 == 0;
      v5 -= 8;
    }
    while (!v11);
    v4 = (uint64_t *)__dst;
    if (__dst == v45)
      goto LABEL_16;
  }
  else
  {
    v10 = 1;
    if (__dst == v45)
      goto LABEL_16;
  }
  free(v4);
LABEL_16:
  if (!v10)
    return 0;
  v37[0] = mlir::ShapedType::getShape((mlir::ShapedType *)v38);
  v37[1] = v12;
  mlir::OffsetSizeAndStrideOpInterface::getMixedSizes((uint64_t *)&__src, (mlir::OffsetSizeAndStrideOpInterface *)v39);
  __dst = v45;
  v44 = 0x400000000;
  v13 = v41;
  v14 = __src;
  if ((_DWORD)v41)
  {
    if (__src == v42)
    {
      v15 = v41;
      if (v41 < 5
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v45, v41, 8),
            v15 = v41,
            v14 = __src,
            (_DWORD)v41))
      {
        memcpy(__dst, v14, 8 * v15);
        v14 = __src;
      }
      LODWORD(v44) = v13;
    }
    else
    {
      __dst = __src;
      v44 = v41;
      __src = v42;
      HIDWORD(v41) = 0;
      v14 = v42;
    }
    LODWORD(v41) = 0;
  }
  v16 = v37;
  v46 = v37;
  if (v14 != v42)
  {
    free(v14);
    v16 = v46;
    v13 = v44;
  }
  v17 = 0;
  v18 = (uint64_t *)__dst;
  if (v13)
  {
    v19 = v16[1];
    if (v19)
    {
      v20 = (_QWORD *)*v16;
      v21 = v13;
      v22 = 8 * v19 - 8;
      v23 = 8 * v21 - 8;
      do
      {
        v24 = mlir::getConstantIntValue(*v18);
        if (v25)
          v26 = v24 == *v20;
        else
          v26 = 0;
        v17 = !v26;
        if (!v26)
          break;
        if (!v23)
          break;
        ++v18;
        ++v20;
        v27 = v22;
        v22 -= 8;
        v23 -= 8;
      }
      while (v27);
      v18 = (uint64_t *)__dst;
    }
  }
  if (v18 != (uint64_t *)v45)
    free(v18);
  if ((v17 & 1) != 0)
    return 0;
  mlir::OffsetSizeAndStrideOpInterface::getMixedStrides((uint64_t *)&__dst, (mlir::OffsetSizeAndStrideOpInterface *)v39);
  v30 = (uint64_t *)__dst;
  if (!(_DWORD)v44)
  {
    v28 = 1;
    if (__dst == v45)
      return v28;
LABEL_64:
    free(v30);
    return v28;
  }
  v31 = 8 * v44 - 8;
  do
  {
    v32 = *v30++;
    v33 = mlir::getConstantIntValue(v32);
    if (v34)
      v35 = v33 == 1;
    else
      v35 = 0;
    v28 = v35;
    v36 = (_DWORD)v28 != 1 || v31 == 0;
    v31 -= 8;
  }
  while (!v36);
  v30 = (uint64_t *)__dst;
  if (__dst != v45)
    goto LABEL_64;
  return v28;
}

_QWORD *llvm::SmallVector<mlir::OpFoldResult,6u>::SmallVector(_QWORD *result, unint64_t a2, unint64_t *a3)
{
  _DWORD *v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  int64x2_t v9;
  int64x2_t *v10;
  unint64_t v11;

  v4 = result;
  v5 = result + 2;
  *result = result + 2;
  result[1] = 0x600000000;
  v6 = *a3;
  if (a2 >= 7)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, v5, a2, 8);
    v7 = (unint64_t *)(*(_QWORD *)v4 + 8 * (a2 & 0xFFFFFFFFFFFFFFFCLL));
    v8 = a2 & 3;
    v9 = vdupq_n_s64(v6);
    v10 = (int64x2_t *)(*(_QWORD *)v4 + 16);
    v11 = a2 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v10[-1] = v9;
      *v10 = v9;
      v10 += 2;
      v11 -= 4;
    }
    while (v11);
    if ((a2 & 0xFFFFFFFFFFFFFFFCLL) != a2)
    {
      do
      {
        *v7++ = v6;
        --v8;
      }
      while (v8);
    }
    goto LABEL_6;
  }
  if (!a2
    || (*v5 = v6, a2 == 1)
    || (result[3] = v6, a2 == 2)
    || (result[4] = v6, a2 == 3)
    || (result[5] = v6, a2 == 4)
    || (result[6] = v6, a2 == 5))
  {
LABEL_6:
    v4[2] = a2;
    return v4;
  }
  result[7] = v6;
  *((_DWORD *)result + 2) = a2;
  return result;
}

uint64_t mlir::tensor::InsertSliceOp::getAsmResultNames(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v4;
  uint64_t NextResultAtOffset;

  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v4 = *(_QWORD *)a1 - 16;
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return a2(a3, NextResultAtOffset, "inserted_slice", 14);
}

void mlir::tensor::InsertSliceOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t *a9, uint64_t a10, void *__src, uint64_t a12)
{
  unint64_t v17;
  uint64_t DenseI64ArrayAttr;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v24[2];
  unint64_t v25[2];
  unint64_t v26[2];
  void *v27;
  uint64_t v28;
  _BYTE v29[48];
  void *v30;
  uint64_t v31;
  _BYTE v32[48];
  void *v33;
  uint64_t v34;
  _BYTE v35[48];
  void *v36;
  uint64_t v37;
  _BYTE v38[48];
  _BYTE *v39;
  uint64_t v40;
  _BYTE v41[48];
  _QWORD *v42;
  uint64_t v43;
  _QWORD v44[8];

  v44[6] = *MEMORY[0x24BDAC8D0];
  v42 = v44;
  v43 = 0x600000000;
  v39 = v41;
  v40 = 0x600000000;
  v36 = v38;
  v37 = 0x600000000;
  v33 = v35;
  v34 = 0x600000000;
  v30 = v32;
  v31 = 0x600000000;
  v27 = v29;
  v28 = 0x600000000;
  mlir::dispatchIndexOpFoldResults(a5, a6, (uint64_t)&v33, (uint64_t)&v42);
  mlir::dispatchIndexOpFoldResults(a7, a8, (uint64_t)&v30, (uint64_t)&v39);
  mlir::dispatchIndexOpFoldResults(a9, a10, (uint64_t)&v27, (uint64_t)&v36);
  v17 = *(_QWORD *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v26, (uint64_t)v33, v34);
  mlir::ValueRange::ValueRange(v25, (uint64_t)v30, v31);
  mlir::ValueRange::ValueRange(v24, (uint64_t)v27, v28);
  DenseI64ArrayAttr = mlir::Builder::getDenseI64ArrayAttr(a1, (uint64_t)v42, v43);
  v19 = mlir::Builder::getDenseI64ArrayAttr(a1, (uint64_t)v39, v40);
  v20 = mlir::Builder::getDenseI64ArrayAttr(a1, (uint64_t)v36, v37);
  mlir::tensor::InsertSliceOp::build(v20, a2, v17, a3, a4, v26[0], v26[1], v21, v25[0], v25[1], v24[0], v24[1], DenseI64ArrayAttr, v19, v20);
  *(_QWORD *)(a2 + 192) = 0;
  v22 = *(unsigned int *)(a2 + 120);
  if (a12 + v22 > (unint64_t)*(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), a12 + v22, 16);
    LODWORD(v22) = *(_DWORD *)(a2 + 120);
  }
  if (a12)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 112) + 16 * v22), __src, 16 * a12);
    LODWORD(v22) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v22 + a12;
  if (v27 != v29)
    free(v27);
  if (v30 != v32)
    free(v30);
  if (v33 != v35)
    free(v33);
  if (v36 != v38)
    free(v36);
  if (v39 != v41)
    free(v39);
  if (v42 != v44)
    free(v42);
}

void mlir::tensor::InsertSliceOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;

  v21 = a5;
  v22 = a4;
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  mlir::OperationState::addOperands(a2, a6, a7);
  mlir::OperationState::addOperands(a2, a9, a10);
  mlir::OperationState::addOperands(a2, a11, a12);
  v18 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2);
  *(_QWORD *)(v18 + 24) = 0x100000001;
  *(_DWORD *)(v18 + 32) = a7;
  *(_DWORD *)(v18 + 36) = a10;
  *(_DWORD *)(v18 + 40) = a12;
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2) = a13;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a14;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a15;
  v19 = *(unsigned int *)(a2 + 72);
  if (v19 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v19 + 1, 8);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v19) = a3;
  ++*(_DWORD *)(a2 + 72);
}

void mlir::tensor::InsertSliceOp::verify(mlir::tensor::InsertSliceOp *this)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t RHS;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  int isRankReducedType;
  unint64_t v15;

  v2 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (*(_DWORD *)(*(_QWORD *)this + 36))
    v3 = *(_QWORD *)this - 16;
  else
    v3 = 0;
  v4 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v3, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  v15 = *(_QWORD *)(*(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64);
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v15);
  v5 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v5 = 0;
  v15 = *(_QWORD *)(v5 + 8);
  v6 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v15);
  v8 = v7;
  v9 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v9 = 0;
  v15 = *(_QWORD *)(v9 + 16);
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v15);
  v15 = v4;
  RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v15);
  v11 = (_QWORD *)mlir::RankedTensorType::get(v6, v8, RHS, 0);
  v12 = v11;
  if (!v11)
  {
    v13 = 0;
    if (!v2)
      goto LABEL_12;
    goto LABEL_10;
  }
  v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v11 + 8);
  if (v2)
LABEL_10:
    mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v2 + 8);
LABEL_12:
  isRankReducedType = mlir::isRankReducedType(v12, v13, v2);
  produceSliceErrorMsg(isRankReducedType);
}

uint64_t mlir::tensor::InsertSliceOp::fold(uint64_t *a1)
{
  _QWORD *Value;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t DefiningOp;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t InterfaceFor;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;

  v38 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (mlir::TensorType::hasRank((mlir::TensorType *)&v38))
  {
    Value = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v38);
    if (v3)
    {
      v4 = 8 * v3;
      while (*Value != 0x8000000000000000)
      {
        ++Value;
        v4 -= 8;
        if (!v4)
          goto LABEL_6;
      }
    }
    else
    {
LABEL_6:
      if (*(_DWORD *)(*a1 + 36))
        v5 = *a1 - 16;
      else
        v5 = 0;
      v37 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
      if (mlir::TensorType::hasRank((mlir::TensorType *)&v37))
      {
        v6 = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v37);
        if (v7)
        {
          v8 = 8 * v7;
          while (*v6 != 0x8000000000000000)
          {
            ++v6;
            v8 -= 8;
            if (!v8)
              goto LABEL_14;
          }
        }
        else
        {
LABEL_14:
          if (*(_DWORD *)(*a1 + 36))
            v10 = *a1 - 16;
          else
            v10 = 0;
          v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
          if (v9 == (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
          {
            v32 = *a1;
            InterfaceFor = mlir::OpInterface<mlir::OffsetSizeAndStrideOpInterface,mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits>::getInterfaceFor(*a1);
            v34 = *(_DWORD *)(*a1 + 36) ? *a1 - 16 : 0;
            v35 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v34, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
            v36 = v35 ? mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v35 + 8) : 0;
            if (foldIdentityOffsetSizeAndStrideOpInterface(v32, InterfaceFor, (uint64_t)v35, v36))
              return *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24) | 4;
          }
        }
      }
    }
  }
  v11 = *a1;
  if (*(_BYTE *)(*a1 + 47))
    v12 = *a1 + 80;
  else
    v12 = 0;
  v38 = *(_QWORD *)(*(_QWORD *)(v11 + 72) + 32 * *(unsigned int *)(v12 + 24) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v38);
  if (DefiningOp
    && (v14 = DefiningOp,
        *(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::InsertSliceOp,void>::id)
    && (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) == (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8)
    && (v15 = mlir::OpInterface<mlir::OffsetSizeAndStrideOpInterface,mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits>::getInterfaceFor(v11),
        v16 = mlir::OpInterface<mlir::OffsetSizeAndStrideOpInterface,mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits>::getInterfaceFor(v14),
        mlir::detail::sameOffsetsSizesAndStrides(v14, v16, v11, v15, (uint64_t (*)(uint64_t, _QWORD, _QWORD))llvm::function_ref<BOOL ()(mlir::OpFoldResult,mlir::OpFoldResult)>::callback_fn<foldInsertAfterInsertSlice(mlir::tensor::InsertSliceOp)::$_0>, (uint64_t)&v38)))
  {
    if (HIBYTE(*(_DWORD *)(v11 + 44)))
      v17 = v11 + 16 * (((unint64_t)*(unsigned int *)(v11 + 44) >> 23) & 1) + 64;
    else
      v17 = 0;
    v18 = (uint64_t *)(*(_QWORD *)(v11 + 72) + 32 * *(unsigned int *)(v17 + 24));
    if (*(_BYTE *)(v14 + 47))
      v19 = v14 + 80;
    else
      v19 = 0;
    v20 = *(uint64_t **)(*(_QWORD *)(v14 + 72) + 32 * *(unsigned int *)(v19 + 24) + 24);
    v21 = (uint64_t *)v18[1];
    if (v21)
    {
      *v21 = *v18;
      if (*v18)
        *(_QWORD *)(*v18 + 8) = v18[1];
    }
    v18[3] = (uint64_t)v20;
    v18[1] = (uint64_t)v20;
    v22 = *v20;
    *v18 = *v20;
    if (v22)
      *(_QWORD *)(v22 + 8) = v18;
    *v20 = (uint64_t)v18;
    if (*(_DWORD *)(*a1 + 36))
      v23 = *a1 - 16;
    else
      v23 = 0;
    return mlir::detail::OpResultImpl::getNextResultAtOffset(v23, 0) | 4;
  }
  else
  {
    v25 = *a1;
    v38 = *(_QWORD *)(*(_QWORD *)(v25 + 72) + 24);
    v26 = mlir::Value::getDefiningOp((mlir::Value *)&v38);
    if (v26
      && (v27 = v26,
          *(_UNKNOWN **)(*(_QWORD *)(v26 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::ExtractSliceOp,void>::id)
      && (*(_BYTE *)(v25 + 47) ? (v28 = v25 + 80) : (v28 = 0),
          *(_QWORD *)(*(_QWORD *)(v26 + 72) + 24) == *(_QWORD *)(*(_QWORD *)(v25 + 72)
                                                                 + 32 * *(unsigned int *)(v28 + 24)
                                                                 + 24)
       && (v29 = mlir::OpInterface<mlir::OffsetSizeAndStrideOpInterface,mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits>::getInterfaceFor(v25),
           v30 = mlir::OpInterface<mlir::OffsetSizeAndStrideOpInterface,mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits>::getInterfaceFor(v27),
           (mlir::detail::sameOffsetsSizesAndStrides(v27, v30, v25, v29, (uint64_t (*)(uint64_t, _QWORD, _QWORD))llvm::function_ref<BOOL ()(mlir::OpFoldResult,mlir::OpFoldResult)>::callback_fn<foldInsertAfterExtractSlice(mlir::tensor::InsertSliceOp)::$_0>, (uint64_t)&v38) & 1) != 0)))
    {
      v31 = *(_QWORD *)(*(_QWORD *)(v27 + 72) + 24);
      if (v31)
        return v31 | 4;
      else
        return 0;
    }
    else
    {
      return 0;
    }
  }
}

uint64_t mlir::tensor::InsertSliceOp::reifyResultShapes(uint64_t a1, mlir::IndexType **a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  mlir::MLIRContext *i;
  unint64_t MixedSize;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v30;
  void *v31;
  uint64_t v32;
  _QWORD v33[7];

  v33[6] = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v6 = *(_QWORD *)a1 - 16;
  else
    v6 = 0;
  v30 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v30);
  v31 = v33;
  v32 = 0x600000000;
  if (v7)
  {
    v8 = v7;
    if (v7 < 7)
    {
      v9 = 0;
      v10 = v7;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v31, v33, v7, 8);
      v9 = v32;
      v10 = v8 - v32;
      if (v8 == v32)
        goto LABEL_10;
    }
    bzero((char *)v31 + 8 * v9, 8 * v10);
LABEL_10:
    LODWORD(v32) = v8;
  }
  v11 = *(unsigned int *)(a3 + 8);
  if (!(_DWORD)v11)
  {
    llvm::SmallVectorImpl<llvm::SmallVector<mlir::OpFoldResult,6u>>::append(a3, 1 - v11, (unint64_t)&v31);
LABEL_18:
    v15 = v31;
    if (v31 == v33)
      goto LABEL_20;
    goto LABEL_19;
  }
  if ((_DWORD)v11 == 1)
    goto LABEL_18;
  v12 = *(_QWORD *)a3;
  v13 = v11 << 6;
  do
  {
    v14 = *(void **)(v12 + v13 - 64);
    if ((void *)(v12 + v13 - 48) != v14)
      free(v14);
    v13 -= 64;
  }
  while (v13 != 64);
  *(_DWORD *)(a3 + 8) = 1;
  v15 = v31;
  if (v31 != v33)
LABEL_19:
    free(v15);
LABEL_20:
  v16 = *(_QWORD *)(*(_QWORD *)a1 + 24);
  if (*(_BYTE *)(*(_QWORD *)a1 + 47))
    v17 = *(_QWORD *)a1 + 80;
  else
    v17 = 0;
  v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 32 * *(unsigned int *)(v17 + 24) + 24);
  v30 = *(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8;
  v31 = v33;
  v32 = 0x600000000;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v30);
  if (v19 >= 1)
  {
    for (i = 0; (uint64_t)i < v23; i = (mlir::MLIRContext *)((char *)i + 1))
    {
      MixedSize = mlir::tensor::getMixedSize(a2, v16, v18, i);
      v22 = v32;
      if (v32 >= (unint64_t)HIDWORD(v32))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v31, v33, v32 + 1, 8);
        v22 = v32;
      }
      *((_QWORD *)v31 + v22) = MixedSize;
      LODWORD(v32) = v32 + 1;
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v30);
    }
  }
  v24 = *(_QWORD *)a3;
  v25 = v31;
  if ((void **)v24 != &v31)
  {
    if (v31 != v33)
    {
      if (*(_QWORD *)v24 != v24 + 16)
      {
        free(*(void **)v24);
        v25 = v31;
      }
      *(_QWORD *)v24 = v25;
      *(_QWORD *)(v24 + 8) = v32;
      v31 = v33;
      HIDWORD(v32) = 0;
      goto LABEL_45;
    }
    v26 = v32;
    v27 = *(unsigned int *)(v24 + 8);
    if (v27 >= v32)
    {
      if ((_DWORD)v32)
        memmove(*(void **)v24, v33, 8 * v32);
      goto LABEL_44;
    }
    if (*(_DWORD *)(v24 + 12) >= v32)
    {
      if ((_DWORD)v27)
      {
        memmove(*(void **)v24, v33, 8 * v27);
        v28 = v32;
        if (v27 == v32)
        {
LABEL_44:
          *(_DWORD *)(v24 + 8) = v26;
LABEL_45:
          LODWORD(v32) = 0;
          v25 = v31;
          goto LABEL_46;
        }
      }
      else
      {
        v27 = 0;
        v28 = v32;
        if (!(_DWORD)v32)
          goto LABEL_44;
      }
    }
    else
    {
      *(_DWORD *)(v24 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v24, (void *)(v24 + 16), v26, 8);
      v27 = 0;
      v28 = v32;
      if (!(_DWORD)v32)
        goto LABEL_44;
    }
    memcpy((void *)(*(_QWORD *)v24 + 8 * v27), (char *)v31 + 8 * v27, 8 * v28 - 8 * v27);
    goto LABEL_44;
  }
LABEL_46:
  if (v25 != v33)
    free(v25);
  return 1;
}

void mlir::tensor::InsertSliceOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  const char *v45;
  unint64_t v46;
  uint64_t v47;
  const char *v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  const char *v82;
  unint64_t v83;
  char *v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  uint64_t *v90;
  char *v91;
  char *v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  const char *v106;
  unint64_t v107;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v106, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"tensor.insert_slice", 19, (__int16)v106, a2, 0, 0);
  *(_QWORD *)v4 = &off_24C02B0C0;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v106 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mli"
         "r::tensor::InsertSliceOp>]";
  v107 = 137;
  v9 = llvm::StringRef::find((uint64_t *)&v106, "DesiredTypeName = ", 0x12uLL, 0);
  if (v107 >= v9)
    v10 = v9;
  else
    v10 = v107;
  v11 = &v106[v10];
  v12 = v107 - v10;
  if (v107 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v107 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_116;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_117;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_120;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_120:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v106, 1);
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"tensor.insert_slice", 19, (__int16)v106, a2, 0, 0);
  *(_QWORD *)v38 = &off_24C02A658;
  if (*(_QWORD *)(v38 + 72))
  {
    v39 = *(unsigned int *)(v38 + 88);
    if (v39 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v39, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  v106 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp>]";
  v107 = 125;
  v43 = llvm::StringRef::find((uint64_t *)&v106, "DesiredTypeName = ", 0x12uLL, 0);
  if (v107 >= v43)
    v44 = v43;
  else
    v44 = v107;
  v45 = &v106[v44];
  v46 = v107 - v44;
  if (v107 - v44 >= 0x12)
    v47 = 18;
  else
    v47 = v107 - v44;
  v48 = &v45[v47];
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *(_QWORD *)(v38 + 64) = v48;
  *(_QWORD *)(v38 + 72) = v49;
  v39 = *(unsigned int *)(v38 + 88);
  if (v39 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
    goto LABEL_116;
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (v54)
  {
    if (v54 >> 61)
      goto LABEL_117;
    v55 = (char *)operator new(8 * v54);
    v56 = (uint64_t *)&v55[8 * v51];
    v57 = &v55[8 * v54];
    *v56 = v38;
    v42 = (uint64_t)(v56 + 1);
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
  }
  else
  {
    v55 = 0;
    v56 = (uint64_t *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
    {
LABEL_62:
      v59 = (unint64_t)(v58 - 8);
      if (v59 < 0x78
        || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v56
        && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
      {
        goto LABEL_121;
      }
      v60 = (v59 >> 3) + 1;
      v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      v62 = &v41[-v61];
      v56 = (uint64_t *)((char *)v56 - v61);
      v63 = &v55[8 * v51 - 16];
      v64 = v41 - 16;
      v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v67 = *((_OWORD *)v64 - 1);
        v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      v41 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_121:
        do
        {
          v68 = *((_QWORD *)v41 - 1);
          v41 -= 8;
          *(_QWORD *)v41 = 0;
          *--v56 = v68;
        }
        while (v41 != v50);
      }
      v41 = (char *)a1[1];
      v69 = (char *)a1[2];
      a1[1] = v56;
      a1[2] = v42;
      a1[3] = v57;
      while (v69 != v41)
      {
        v71 = *((_QWORD *)v69 - 1);
        v69 -= 8;
        v70 = v71;
        *(_QWORD *)v69 = 0;
        if (v71)
          (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
      }
      goto LABEL_75;
    }
  }
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
  v72 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v106, 1);
  mlir::Pattern::Pattern(v72 + 8, (uint64_t)"tensor.insert_slice", 19, (__int16)v106, a2, 0, 0);
  *(_QWORD *)v72 = &off_24C02AFB8;
  if (*(_QWORD *)(v72 + 72))
  {
    v73 = *(unsigned int *)(v72 + 88);
    if (v73 <= *(_DWORD *)(v72 + 92))
      goto LABEL_79;
LABEL_90:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v72 + 80, (void *)(v72 + 96), v73, 16);
    *(_DWORD *)(v72 + 88) = *(_DWORD *)(v72 + 88);
    v75 = (char *)a1[2];
    v74 = a1[3];
    if ((unint64_t)v75 < v74)
      goto LABEL_80;
    goto LABEL_91;
  }
  v106 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::t"
         "ensor::InsertSliceOp>]";
  v107 = 133;
  v77 = llvm::StringRef::find((uint64_t *)&v106, "DesiredTypeName = ", 0x12uLL, 0);
  if (v107 >= v77)
    v78 = v77;
  else
    v78 = v107;
  v79 = &v106[v78];
  v80 = v107 - v78;
  if (v107 - v78 >= 0x12)
    v81 = 18;
  else
    v81 = v107 - v78;
  v82 = &v79[v81];
  v83 = v80 - v81;
  if (v83 >= v83 - 1)
    --v83;
  *(_QWORD *)(v72 + 64) = v82;
  *(_QWORD *)(v72 + 72) = v83;
  v73 = *(unsigned int *)(v72 + 88);
  if (v73 > *(_DWORD *)(v72 + 92))
    goto LABEL_90;
LABEL_79:
  *(_DWORD *)(v72 + 88) = v73;
  v75 = (char *)a1[2];
  v74 = a1[3];
  if ((unint64_t)v75 < v74)
  {
LABEL_80:
    *(_QWORD *)v75 = v72;
    v76 = (uint64_t)(v75 + 8);
    goto LABEL_115;
  }
LABEL_91:
  v84 = (char *)a1[1];
  v85 = (v75 - v84) >> 3;
  v86 = v85 + 1;
  if ((unint64_t)(v85 + 1) >> 61)
LABEL_116:
    abort();
  v87 = v74 - (_QWORD)v84;
  if (v87 >> 2 > v86)
    v86 = v87 >> 2;
  if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
    v88 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v88 = v86;
  if (!v88)
  {
    v89 = 0;
    v90 = (uint64_t *)(8 * v85);
    v91 = 0;
    *(_QWORD *)(8 * v85) = v72;
    v76 = 8 * v85 + 8;
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
      goto LABEL_100;
    goto LABEL_112;
  }
  if (v88 >> 61)
LABEL_117:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v89 = (char *)operator new(8 * v88);
  v90 = (uint64_t *)&v89[8 * v85];
  v91 = &v89[8 * v88];
  *v90 = v72;
  v76 = (uint64_t)(v90 + 1);
  v92 = (char *)(v75 - v84);
  if (v75 != v84)
  {
LABEL_100:
    v93 = (unint64_t)(v92 - 8);
    if (v93 < 0x78
      || &v75[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v90
      && &v89[v75 - v84 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v75)
    {
      goto LABEL_122;
    }
    v94 = (v93 >> 3) + 1;
    v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
    v96 = &v75[-v95];
    v90 = (uint64_t *)((char *)v90 - v95);
    v97 = &v89[8 * v85 - 16];
    v98 = v75 - 16;
    v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v101 = *((_OWORD *)v98 - 1);
      v100 = *(_OWORD *)v98;
      *((_OWORD *)v98 - 1) = 0uLL;
      *(_OWORD *)v98 = 0uLL;
      *((_OWORD *)v97 - 1) = v101;
      *(_OWORD *)v97 = v100;
      v97 -= 32;
      v98 -= 32;
      v99 -= 4;
    }
    while (v99);
    v75 = v96;
    if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_122:
      do
      {
        v102 = *((_QWORD *)v75 - 1);
        v75 -= 8;
        *(_QWORD *)v75 = 0;
        *--v90 = v102;
      }
      while (v75 != v84);
    }
    v75 = (char *)a1[1];
    v103 = (char *)a1[2];
    a1[1] = v90;
    a1[2] = v76;
    a1[3] = v91;
    while (v103 != v75)
    {
      v105 = *((_QWORD *)v103 - 1);
      v103 -= 8;
      v104 = v105;
      *(_QWORD *)v103 = 0;
      if (v105)
        (*(void (**)(uint64_t))(*(_QWORD *)v104 + 8))(v104);
    }
    goto LABEL_113;
  }
LABEL_112:
  a1[1] = v90;
  a1[2] = v76;
  a1[3] = v91;
LABEL_113:
  if (v75)
    operator delete(v75);
LABEL_115:
  a1[2] = v76;
}

uint64_t mlir::tensor::PadOp::getAsmResultNames(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v4;
  uint64_t NextResultAtOffset;

  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v4 = *(_QWORD *)a1 - 16;
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return a2(a3, NextResultAtOffset, "padded", 6);
}

uint64_t mlir::tensor::PadOp::verify(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  char *v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  int *v30;
  char *v31;
  char *v32;
  __int128 v33;
  uint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  int *v43;
  char *v44;
  char *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  char *v49;
  char *v50;
  __int128 v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD *v56;
  _QWORD *v57;
  void *v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  int *v62;
  char *v63;
  char *v64;
  __int128 v65;
  uint64_t v66;
  int *v67;
  char *v68;
  char *v69;
  __int128 v70;
  int *v71;
  char *v72;
  char *v73;
  __int128 v74;
  _QWORD *v75;
  _QWORD *v76;
  void *v77;
  _QWORD *v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  BOOL v85;
  unint64_t v86;
  BOOL v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  BOOL v92;
  unint64_t v93;
  int64_t v94;
  int64_t v95;
  int64_t v96;
  int64_t v97;
  int64_t v98;
  int64_t v99;
  int64_t v100;
  int64_t v101;
  int64_t v102;
  _QWORD v103[4];
  __int16 v104;
  uint64_t v105;
  unint64_t v106;
  unint64_t v107;
  int v108;
  const char *v109;
  uint64_t v110;
  _QWORD v111[3];
  void *v112;
  unsigned int v113;
  unsigned int v114;
  _BYTE v115[96];
  void *v116;
  _QWORD *v117;
  void *__p;
  _QWORD *v119;
  char v120;
  uint64_t v121;

  v121 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v3 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v107 = v3;
  v4 = *((_DWORD *)v2 + 9);
  v5 = (uint64_t)(v2 - 2);
  if (v4)
    v6 = v5;
  else
    v6 = 0;
  v106 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  v7 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v7 = 0;
  v111[0] = *(_QWORD *)(v7 + 16);
  v8 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v111);
  v10 = v9;
  v11 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v11 = 0;
  v111[0] = *(_QWORD *)(v11 + 8);
  v12 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v111);
  v105 = mlir::tensor::PadOp::inferResultType(v3, v8, v10, v12, v13, 0, 0);
  if (v105)
  {
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v106);
    v15 = v14;
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v105);
    if (v15 == v16)
    {
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v107);
      if (v17 < 1)
        return 1;
      v18 = 0;
      v19 = 8 * v17;
      while (1)
      {
        v20 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v106) + v18);
        if (v20 != *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v105) + v18)
          && *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v105) + v18) != 0x8000000000000000)
        {
          break;
        }
        v18 += 8;
        if (v19 == v18)
          return 1;
      }
      v103[0] = "specified type ";
      v104 = 259;
      mlir::OpState::emitError(this, (uint64_t)v103, (uint64_t)v111);
      if (v111[0])
      {
        v21 = &v108;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v108, v106);
        v22 = (char *)v112;
        if (v113 >= v114)
        {
          v90 = v113 + 1;
          if (v112 <= &v108 && (char *)v112 + 24 * v113 > (char *)&v108)
          {
            v100 = (char *)&v108 - (_BYTE *)v112;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v90, 24);
            v22 = (char *)v112;
            v21 = (int *)((char *)v112 + v100);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v90, 24);
            v21 = &v108;
            v22 = (char *)v112;
          }
        }
        v23 = &v22[24 * v113];
        v24 = *(_OWORD *)v21;
        *((_QWORD *)v23 + 2) = *((_QWORD *)v21 + 2);
        *(_OWORD *)v23 = v24;
        v25 = ++v113;
        if (v111[0])
        {
          v108 = 3;
          v109 = " does not match the inferred type ";
          v110 = 34;
          v26 = &v108;
          v27 = (char *)v112;
          if (v25 >= v114)
          {
            v91 = v25 + 1;
            v92 = (char *)v112 + 24 * v25 > (char *)&v108;
            if (v112 <= &v108 && v92)
            {
              v101 = (char *)&v108 - (_BYTE *)v112;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v91, 24);
              v27 = (char *)v112;
              v26 = (int *)((char *)v112 + v101);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v91, 24);
              v26 = &v108;
              v27 = (char *)v112;
            }
          }
          v28 = &v27[24 * v113];
          v29 = *(_OWORD *)v26;
          *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
          *(_OWORD *)v28 = v29;
          ++v113;
          if (v111[0])
          {
            v30 = &v108;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v108, v105);
            v31 = (char *)v112;
            if (v113 >= v114)
            {
              v93 = v113 + 1;
              if (v112 <= &v108 && (char *)v112 + 24 * v113 > (char *)&v108)
              {
                v102 = (char *)&v108 - (_BYTE *)v112;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v93, 24);
                v31 = (char *)v112;
                v30 = (int *)((char *)v112 + v102);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v93, 24);
                v30 = &v108;
                v31 = (char *)v112;
              }
            }
            v32 = &v31[24 * v113];
            v33 = *(_OWORD *)v30;
            *((_QWORD *)v32 + 2) = *((_QWORD *)v30 + 2);
            *(_OWORD *)v32 = v33;
            ++v113;
          }
        }
      }
      v34 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v111);
      if (v111[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v111);
      if (v120)
      {
        v35 = __p;
        if (__p)
        {
          v36 = v119;
          v37 = __p;
          if (v119 != __p)
          {
            do
              v36 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v36 - 1);
            while (v36 != v35);
            v37 = __p;
          }
          v119 = v35;
          operator delete(v37);
        }
        v38 = v116;
        if (!v116)
          goto LABEL_81;
        v39 = v117;
        v40 = v116;
        if (v117 == v116)
        {
LABEL_80:
          v117 = v38;
          operator delete(v40);
LABEL_81:
          if (v112 != v115)
            free(v112);
          return v34;
        }
        do
        {
          v42 = *--v39;
          v41 = v42;
          *v39 = 0;
          if (v42)
            MEMORY[0x20BD002D4](v41, 0x1000C8077774924);
        }
        while (v39 != v38);
LABEL_79:
        v40 = v116;
        goto LABEL_80;
      }
    }
    else
    {
      v103[0] = "specified type ";
      v104 = 259;
      mlir::OpState::emitError(this, (uint64_t)v103, (uint64_t)v111);
      if (v111[0])
      {
        v62 = &v108;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v108, v106);
        v63 = (char *)v112;
        if (v113 >= v114)
        {
          v83 = v113 + 1;
          if (v112 <= &v108 && (char *)v112 + 24 * v113 > (char *)&v108)
          {
            v95 = (char *)&v108 - (_BYTE *)v112;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v83, 24);
            v63 = (char *)v112;
            v62 = (int *)((char *)v112 + v95);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v83, 24);
            v62 = &v108;
            v63 = (char *)v112;
          }
        }
        v64 = &v63[24 * v113];
        v65 = *(_OWORD *)v62;
        *((_QWORD *)v64 + 2) = *((_QWORD *)v62 + 2);
        *(_OWORD *)v64 = v65;
        v66 = ++v113;
        if (v111[0])
        {
          v108 = 3;
          v109 = " does not match the inferred type ";
          v110 = 34;
          v67 = &v108;
          v68 = (char *)v112;
          if (v66 >= v114)
          {
            v86 = v66 + 1;
            v87 = (char *)v112 + 24 * v66 > (char *)&v108;
            if (v112 <= &v108 && v87)
            {
              v97 = (char *)&v108 - (_BYTE *)v112;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v86, 24);
              v68 = (char *)v112;
              v67 = (int *)((char *)v112 + v97);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v86, 24);
              v67 = &v108;
              v68 = (char *)v112;
            }
          }
          v69 = &v68[24 * v113];
          v70 = *(_OWORD *)v67;
          *((_QWORD *)v69 + 2) = *((_QWORD *)v67 + 2);
          *(_OWORD *)v69 = v70;
          ++v113;
          if (v111[0])
          {
            v71 = &v108;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v108, v105);
            v72 = (char *)v112;
            if (v113 >= v114)
            {
              v89 = v113 + 1;
              if (v112 <= &v108 && (char *)v112 + 24 * v113 > (char *)&v108)
              {
                v99 = (char *)&v108 - (_BYTE *)v112;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v89, 24);
                v72 = (char *)v112;
                v71 = (int *)((char *)v112 + v99);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v89, 24);
                v71 = &v108;
                v72 = (char *)v112;
              }
            }
            v73 = &v72[24 * v113];
            v74 = *(_OWORD *)v71;
            *((_QWORD *)v73 + 2) = *((_QWORD *)v71 + 2);
            *(_OWORD *)v73 = v74;
            ++v113;
          }
        }
      }
      v34 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v111);
      if (v111[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v111);
      if (v120)
      {
        v75 = __p;
        if (__p)
        {
          v76 = v119;
          v77 = __p;
          if (v119 != __p)
          {
            do
              v76 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v76 - 1);
            while (v76 != v75);
            v77 = __p;
          }
          v119 = v75;
          operator delete(v77);
        }
        v38 = v116;
        if (!v116)
          goto LABEL_81;
        v78 = v117;
        v40 = v116;
        if (v117 == v116)
          goto LABEL_80;
        do
        {
          v80 = *--v78;
          v79 = v80;
          *v78 = 0;
          if (v80)
            MEMORY[0x20BD002D4](v79, 0x1000C8077774924);
        }
        while (v78 != v38);
        goto LABEL_79;
      }
    }
  }
  else
  {
    v103[0] = "failed to infer expectedType from sourceType ";
    v104 = 259;
    mlir::OpState::emitError(this, (uint64_t)v103, (uint64_t)v111);
    if (v111[0])
    {
      v43 = &v108;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v108, v107);
      v44 = (char *)v112;
      if (v113 >= v114)
      {
        v82 = v113 + 1;
        if (v112 <= &v108 && (char *)v112 + 24 * v113 > (char *)&v108)
        {
          v94 = (char *)&v108 - (_BYTE *)v112;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v82, 24);
          v44 = (char *)v112;
          v43 = (int *)((char *)v112 + v94);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v82, 24);
          v43 = &v108;
          v44 = (char *)v112;
        }
      }
      v45 = &v44[24 * v113];
      v46 = *(_OWORD *)v43;
      *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
      *(_OWORD *)v45 = v46;
      v47 = ++v113;
      if (v111[0])
      {
        v108 = 3;
        v109 = ", specified resultType is ";
        v110 = 26;
        v48 = &v108;
        v49 = (char *)v112;
        if (v47 >= v114)
        {
          v84 = v47 + 1;
          v85 = (char *)v112 + 24 * v47 > (char *)&v108;
          if (v112 <= &v108 && v85)
          {
            v96 = (char *)&v108 - (_BYTE *)v112;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v84, 24);
            v49 = (char *)v112;
            v48 = (int *)((char *)v112 + v96);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v84, 24);
            v48 = &v108;
            v49 = (char *)v112;
          }
        }
        v50 = &v49[24 * v113];
        v51 = *(_OWORD *)v48;
        *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
        *(_OWORD *)v50 = v51;
        ++v113;
        if (v111[0])
        {
          v52 = &v108;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v108, v106);
          v53 = (char *)v112;
          if (v113 >= v114)
          {
            v88 = v113 + 1;
            if (v112 <= &v108 && (char *)v112 + 24 * v113 > (char *)&v108)
            {
              v98 = (char *)&v108 - (_BYTE *)v112;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v88, 24);
              v53 = (char *)v112;
              v52 = (int *)((char *)v112 + v98);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v88, 24);
              v52 = &v108;
              v53 = (char *)v112;
            }
          }
          v54 = &v53[24 * v113];
          v55 = *(_OWORD *)v52;
          *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
          *(_OWORD *)v54 = v55;
          ++v113;
        }
      }
    }
    v34 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v111);
    if (v111[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v111);
    if (v120)
    {
      v56 = __p;
      if (__p)
      {
        v57 = v119;
        v58 = __p;
        if (v119 != __p)
        {
          do
            v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
          while (v57 != v56);
          v58 = __p;
        }
        v119 = v56;
        operator delete(v58);
      }
      v38 = v116;
      if (!v116)
        goto LABEL_81;
      v59 = v117;
      v40 = v116;
      if (v117 == v116)
        goto LABEL_80;
      do
      {
        v61 = *--v59;
        v60 = v61;
        *v59 = 0;
        if (v61)
          MEMORY[0x20BD002D4](v60, 0x1000C8077774924);
      }
      while (v59 != v38);
      goto LABEL_79;
    }
  }
  return v34;
}

uint64_t mlir::tensor::PadOp::inferResultType(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t RHS;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  _QWORD v26[5];

  v26[4] = *MEMORY[0x24BDAC8D0];
  v23 = a1;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v23);
  v14 = a3 == v13 && a5 == v13;
  if (!v14 || a7 && a7 != a5)
    return 0;
  v24 = v26;
  v25 = 0x400000000;
  if (!a5)
  {
    v20 = 0;
    v21 = v26;
    goto LABEL_24;
  }
  v17 = 0;
  do
  {
    if (*(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v23) + 8 * v17) == 0x8000000000000000
      || *(_QWORD *)(a2 + 8 * v17) == 0x8000000000000000
      || *(_QWORD *)(a4 + 8 * v17) == 0x8000000000000000)
    {
      if (a7)
      {
        v18 = *(_QWORD *)(a6 + 8 * v17);
        v19 = v25;
        if (v25 < (unint64_t)HIDWORD(v25))
          goto LABEL_19;
      }
      else
      {
        v18 = 0x8000000000000000;
        v19 = v25;
        if (v25 < (unint64_t)HIDWORD(v25))
          goto LABEL_19;
      }
    }
    else
    {
      v18 = *(_QWORD *)(a2 + 8 * v17)
          + *(_QWORD *)(a4 + 8 * v17)
          + *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v23) + 8 * v17);
      v19 = v25;
      if (v25 < (unint64_t)HIDWORD(v25))
        goto LABEL_19;
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v24, v26, v19 + 1, 8);
    v19 = v25;
LABEL_19:
    *((_QWORD *)v24 + v19) = v18;
    v20 = (v25 + 1);
    LODWORD(v25) = v25 + 1;
    ++v17;
  }
  while (a5 != v17);
  v21 = v24;
LABEL_24:
  RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v23);
  v15 = mlir::RankedTensorType::get((uint64_t)v21, v20, RHS, 0);
  if (v24 != v26)
    free(v24);
  return v15;
}

uint64_t mlir::tensor::PadOp::verifyRegions(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  mlir::Block *v11;
  uint64_t ArgumentTypes;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  char *v31;
  char *v32;
  __int128 v33;
  uint64_t v34;
  int *v35;
  char *v36;
  char *v37;
  __int128 v38;
  _QWORD *v39;
  _QWORD *v40;
  void *v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  int *v46;
  char *v47;
  char *v48;
  __int128 v49;
  uint64_t v50;
  int *v51;
  char *v52;
  char *v53;
  __int128 v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v64;
  unint64_t v65;
  BOOL v66;
  unint64_t v67;
  unint64_t v68;
  BOOL v69;
  int64_t v70;
  int64_t v71;
  int64_t v72;
  int64_t v73;
  unint64_t v74;
  const void **v75[4];
  __int16 v76;
  int v77;
  const char *v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  void *v82;
  unsigned int v83;
  unsigned int v84;
  _BYTE v85[96];
  void *v86;
  _QWORD *v87;
  void *__p;
  _QWORD *v89;
  char v90;
  uint64_t v91;

  v91 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v3 = *((unsigned int *)*this + 11);
  if ((v3 & 0x7FFFFF) != 0)
    v4 = (((unint64_t)&v2[2 * ((v3 >> 23) & 1) + 8] + ((v3 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)v2 + 10);
  else
    v4 = 0;
  v5 = *((_DWORD *)v2 + 9);
  v6 = (uint64_t)(v2 - 2);
  if (v5)
    v7 = v6;
  else
    v7 = 0;
  v80 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v80);
  v9 = v8;
  v10 = *(_QWORD *)(v4 + 8);
  if (v10)
    v11 = (mlir::Block *)(v10 - 8);
  else
    v11 = 0;
  if (((*((_QWORD *)v11 + 7) - *((_QWORD *)v11 + 6)) >> 3) != v8)
  {
    v75[0] = (const void **)"expected the block to have ";
    v76 = 259;
    mlir::OpState::emitError(this, (uint64_t)v75, (uint64_t)&v80);
    if (v80)
    {
      v77 = 5;
      v78 = (const char *)v9;
      v30 = &v77;
      v31 = (char *)v82;
      if (v83 >= v84)
      {
        v64 = v83 + 1;
        if (v82 <= &v77 && (char *)v82 + 24 * v83 > (char *)&v77)
        {
          v70 = (char *)&v77 - (_BYTE *)v82;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v82, v85, v64, 24);
          v31 = (char *)v82;
          v30 = (int *)((char *)v82 + v70);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v82, v85, v64, 24);
          v30 = &v77;
          v31 = (char *)v82;
        }
      }
      v32 = &v31[24 * v83];
      v33 = *(_OWORD *)v30;
      *((_QWORD *)v32 + 2) = *((_QWORD *)v30 + 2);
      *(_OWORD *)v32 = v33;
      v34 = ++v83;
      if (v80)
      {
        v77 = 3;
        v78 = " arguments";
        v79 = 10;
        v35 = &v77;
        v36 = (char *)v82;
        if (v34 >= v84)
        {
          v65 = v34 + 1;
          v66 = (char *)v82 + 24 * v34 > (char *)&v77;
          if (v82 <= &v77 && v66)
          {
            v71 = (char *)&v77 - (_BYTE *)v82;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v82, v85, v65, 24);
            v36 = (char *)v82;
            v35 = (int *)((char *)v82 + v71);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v82, v85, v65, 24);
            v35 = &v77;
            v36 = (char *)v82;
          }
        }
        v37 = &v36[24 * v83];
        v38 = *(_OWORD *)v35;
        *((_QWORD *)v37 + 2) = *((_QWORD *)v35 + 2);
        *(_OWORD *)v37 = v38;
        ++v83;
      }
    }
    v21 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v80);
    if (v80)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v80);
    if (!v90)
      return v21;
    v39 = __p;
    if (__p)
    {
      v40 = v89;
      v41 = __p;
      if (v89 != __p)
      {
        do
          v40 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v40 - 1);
        while (v40 != v39);
        v41 = __p;
      }
      v89 = v39;
      operator delete(v41);
    }
    v25 = v86;
    if (!v86)
      goto LABEL_52;
    v42 = v87;
    v27 = v86;
    if (v87 == v86)
      goto LABEL_51;
    do
    {
      v44 = *--v42;
      v43 = v44;
      *v42 = 0;
      if (v44)
        MEMORY[0x20BD002D4](v43, 0x1000C8077774924);
    }
    while (v42 != v25);
    goto LABEL_50;
  }
  ArgumentTypes = mlir::Block::getArgumentTypes(v11);
  if (ArgumentTypes == v13)
  {
LABEL_15:
    mlir::Block::getTerminator((ZinIrHalH13g **)v11);
    v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v17 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
    v19 = (_QWORD *)(*(*this - 1) & 0xFFFFFFFFFFFFFFF8);
    if (v19)
    {
      v20 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
      v80 = (unint64_t)v19;
      v81 = v20;
      if (v18 != mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v80))
      {
LABEL_17:
        v75[0] = (const void **)"expected yield type to match shape element type";
        v76 = 259;
        mlir::OpState::emitOpError(this, v75, (uint64_t)&v80);
        v21 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v80);
        if (v80)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v80);
        if (!v90)
          return v21;
        v22 = __p;
        if (__p)
        {
          v23 = v89;
          v24 = __p;
          if (v89 != __p)
          {
            do
              v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            v24 = __p;
          }
          v89 = v22;
          operator delete(v24);
        }
        v25 = v86;
        if (!v86)
          goto LABEL_52;
        v26 = v87;
        v27 = v86;
        if (v87 == v86)
        {
LABEL_51:
          v87 = v25;
          operator delete(v27);
LABEL_52:
          v45 = v82;
          if (v82 == v85)
            return v21;
LABEL_53:
          free(v45);
          return v21;
        }
        do
        {
          v29 = *--v26;
          v28 = v29;
          *v26 = 0;
          if (v29)
            MEMORY[0x20BD002D4](v28, 0x1000C8077774924);
        }
        while (v26 != v25);
LABEL_50:
        v27 = v86;
        goto LABEL_51;
      }
    }
    else
    {
      v80 = 0;
      v81 = 0;
      if (v18 != mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v80))
        goto LABEL_17;
    }
    return 1;
  }
  v14 = ArgumentTypes;
  v15 = v13;
  v16 = 0;
  while (1)
  {
    v74 = *(_QWORD *)(*(_QWORD *)v14 + 8) & 0xFFFFFFFFFFFFFFF8;
    if (!mlir::Type::isIndex((mlir::Type *)&v74))
      break;
    ++v16;
    v14 += 8;
    if (v14 == v15)
      goto LABEL_15;
  }
  v75[0] = (const void **)"expected block argument ";
  v76 = 259;
  mlir::OpState::emitOpError(this, v75, (uint64_t)&v80);
  if (v80)
  {
    v77 = 5;
    v78 = (const char *)(v16 + 1);
    v46 = &v77;
    v47 = (char *)v82;
    if (v83 >= v84)
    {
      v67 = v83 + 1;
      if (v82 <= &v77 && (char *)v82 + 24 * v83 > (char *)&v77)
      {
        v72 = (char *)&v77 - (_BYTE *)v82;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v82, v85, v67, 24);
        v47 = (char *)v82;
        v46 = (int *)((char *)v82 + v72);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v82, v85, v67, 24);
        v46 = &v77;
        v47 = (char *)v82;
      }
    }
    v48 = &v47[24 * v83];
    v49 = *(_OWORD *)v46;
    *((_QWORD *)v48 + 2) = *((_QWORD *)v46 + 2);
    *(_OWORD *)v48 = v49;
    v50 = ++v83;
    if (v80)
    {
      v77 = 3;
      v78 = " to be an index";
      v79 = 15;
      v51 = &v77;
      v52 = (char *)v82;
      if (v50 >= v84)
      {
        v68 = v50 + 1;
        v69 = (char *)v82 + 24 * v50 > (char *)&v77;
        if (v82 <= &v77 && v69)
        {
          v73 = (char *)&v77 - (_BYTE *)v82;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v82, v85, v68, 24);
          v52 = (char *)v82;
          v51 = (int *)((char *)v82 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v82, v85, v68, 24);
          v51 = &v77;
          v52 = (char *)v82;
        }
      }
      v53 = &v52[24 * v83];
      v54 = *(_OWORD *)v51;
      *((_QWORD *)v53 + 2) = *((_QWORD *)v51 + 2);
      *(_OWORD *)v53 = v54;
      ++v83;
    }
  }
  v21 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v80);
  if (v80)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v80);
  if (v90)
  {
    v55 = __p;
    if (__p)
    {
      v56 = v89;
      v57 = __p;
      if (v89 != __p)
      {
        do
          v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
        while (v56 != v55);
        v57 = __p;
      }
      v89 = v55;
      operator delete(v57);
    }
    v58 = v86;
    if (v86)
    {
      v59 = v87;
      v60 = v86;
      if (v87 != v86)
      {
        do
        {
          v62 = *--v59;
          v61 = v62;
          *v59 = 0;
          if (v62)
            MEMORY[0x20BD002D4](v61, 0x1000C8077774924);
        }
        while (v59 != v58);
        v60 = v86;
      }
      v87 = v58;
      operator delete(v60);
    }
    v45 = v82;
    if (v82 != v85)
      goto LABEL_53;
  }
  return v21;
}

void mlir::tensor::PadOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, void *__src, uint64_t a15)
{
  uint64_t v20;
  uint64_t DenseI64ArrayAttr;
  mlir::MLIRContext *v24;
  uint64_t v25;
  uint64_t UnitAttr;
  uint64_t v27;

  v20 = a3;
  if (!a3)
    v20 = mlir::tensor::PadOp::inferResultType(*(_QWORD *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8, a5, a6, a7, a8, 0, 0);
  DenseI64ArrayAttr = mlir::Builder::getDenseI64ArrayAttr(a1, a5, a6);
  v25 = mlir::Builder::getDenseI64ArrayAttr(a1, a7, a8);
  if (a13)
    UnitAttr = mlir::Builder::getUnitAttr(a1, v24);
  else
    UnitAttr = 0;
  mlir::tensor::PadOp::build(UnitAttr, a2, v20, a4, a9, a10, a11, a12, DenseI64ArrayAttr, v25, UnitAttr);
  *(_QWORD *)(a2 + 192) = 0;
  v27 = *(unsigned int *)(a2 + 120);
  if (a15 + v27 > (unint64_t)*(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), a15 + v27, 16);
    LODWORD(v27) = *(_DWORD *)(a2 + 120);
  }
  if (a15)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 112) + 16 * v27), __src, 16 * a15);
    LODWORD(v27) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v27 + a15;
}

void mlir::tensor::PadOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  _DWORD *v17;
  uint64_t v18;
  uint64_t v19;

  v19 = a4;
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  mlir::OperationState::addOperands(a2, a5, a6);
  mlir::OperationState::addOperands(a2, a7, a8);
  v17 = (_DWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties>((_QWORD *)a2);
  v17[6] = 1;
  v17[7] = a6;
  v17[8] = a8;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a9;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a10;
  if (a11)
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties>((_QWORD *)a2) = a11;
  mlir::OperationState::addRegion((mlir::OperationState *)a2);
  v18 = *(unsigned int *)(a2 + 72);
  if (v18 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v18 + 1, 8);
    LODWORD(v18) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v18) = a3;
  ++*(_DWORD *)(a2 + 72);
}

void mlir::tensor::PadOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t a8, char a9, void *__src, uint64_t a11)
{
  uint64_t v17;
  uint64_t DenseI64ArrayAttr;
  mlir::MLIRContext *v19;
  uint64_t v20;
  uint64_t UnitAttr;
  uint64_t v22;
  unint64_t v23[2];
  unint64_t v24[2];
  void *v25;
  uint64_t v26;
  _BYTE v27[32];
  void *v28;
  uint64_t v29;
  _BYTE v30[32];
  void *v31;
  uint64_t v32;
  _BYTE v33[32];
  _QWORD *v34;
  uint64_t v35;
  _QWORD v36[6];

  v36[4] = *MEMORY[0x24BDAC8D0];
  v17 = *(_QWORD *)(a4 + 8);
  v34 = v36;
  v35 = 0x400000000;
  v31 = v33;
  v32 = 0x400000000;
  v28 = v30;
  v29 = 0x400000000;
  v25 = v27;
  v26 = 0x400000000;
  mlir::dispatchIndexOpFoldResults(a5, a6, (uint64_t)&v34, (uint64_t)&v28);
  mlir::dispatchIndexOpFoldResults(a7, a8, (uint64_t)&v31, (uint64_t)&v25);
  if (!a3)
    a3 = mlir::tensor::PadOp::inferResultType(v17 & 0xFFFFFFFFFFFFFFF8, (uint64_t)v28, v29, (uint64_t)v25, v26, 0, 0);
  mlir::ValueRange::ValueRange(v24, (uint64_t)v34, v35);
  mlir::ValueRange::ValueRange(v23, (uint64_t)v31, v32);
  DenseI64ArrayAttr = mlir::Builder::getDenseI64ArrayAttr(a1, (uint64_t)v28, v29);
  v20 = mlir::Builder::getDenseI64ArrayAttr(a1, (uint64_t)v25, v26);
  if (a9)
    UnitAttr = mlir::Builder::getUnitAttr(a1, v19);
  else
    UnitAttr = 0;
  mlir::tensor::PadOp::build(UnitAttr, a2, a3, a4, v24[0], v24[1], v23[0], v23[1], DenseI64ArrayAttr, v20, UnitAttr);
  *(_QWORD *)(a2 + 192) = 0;
  v22 = *(unsigned int *)(a2 + 120);
  if (a11 + v22 > (unint64_t)*(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), a11 + v22, 16);
    LODWORD(v22) = *(_DWORD *)(a2 + 120);
  }
  if (a11)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 112) + 16 * v22), __src, 16 * a11);
    LODWORD(v22) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v22 + a11;
  if (v25 != v27)
    free(v25);
  if (v28 != v30)
    free(v28);
  if (v31 != v33)
    free(v31);
  if (v34 != v36)
    free(v34);
}

void mlir::tensor::PadOp::getPaddedDims(mlir::tensor::PadOp *this@<X0>, unint64_t *a2@<X8>)
{
  uint64_t v4;
  int v5;
  unint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  void *v10;
  size_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t ConstantIntValue;
  char v16;
  BOOL v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  BOOL v23;
  void *v24;
  unsigned int v25;
  _QWORD v26[7];

  v26[6] = *MEMORY[0x24BDAC8D0];
  v24 = (void *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v24);
  v5 = v4;
  if (v4 <= 0x39)
  {
    v6 = (v4 << 58) | 1;
    goto LABEL_9;
  }
  v7 = operator new();
  v6 = v7;
  v8 = v5 + 63;
  v9 = (v5 + 63) >> 6;
  *(_QWORD *)v7 = v7 + 16;
  *(_DWORD *)(v7 + 12) = 6;
  if ((v5 + 63) >= 0x1C0)
  {
    *(_DWORD *)(v7 + 8) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod(v7, (void *)(v7 + 16), v8 >> 6, 8);
    v10 = *(void **)v6;
    v11 = 8 * v9;
LABEL_7:
    bzero(v10, v11);
    goto LABEL_8;
  }
  if (v8 >= 0x40)
  {
    v10 = (void *)(v7 + 16);
    v11 = 8 * v9;
    goto LABEL_7;
  }
LABEL_8:
  *(_DWORD *)(v6 + 8) = v9;
  *(_DWORD *)(v6 + 64) = v5;
LABEL_9:
  *a2 = v6;
  mlir::tensor::PadOp::getMixedLowPad(this, (uint64_t)&v24);
  v12 = v24;
  if (v25)
  {
    v13 = 0;
    v14 = 8 * v25;
    do
    {
      ConstantIntValue = mlir::getConstantIntValue(v12[v13]);
      if (v16)
        v17 = ConstantIntValue == 0;
      else
        v17 = 0;
      if (!v17)
      {
        if ((v6 & 1) != 0)
        {
          v6 = v6 & 0xFC00000000000000 | (2
                                          * (((v6 >> 1) & ~(-1 << (v6 >> 58)) | (1 << v13)) & ~(-1 << (v6 >> 58)))) | 1;
          *a2 = v6;
        }
        else
        {
          *(_QWORD *)(*(_QWORD *)v6 + 8 * (v13 >> 6)) |= 1 << v13;
        }
      }
      ++v13;
      v14 -= 8;
    }
    while (v14);
    v12 = v24;
  }
  if (v12 != v26)
    free(v12);
  mlir::tensor::PadOp::getMixedHighPad(this, (uint64_t)&v24);
  v18 = v24;
  if (v25)
  {
    v19 = 0;
    v20 = 8 * v25;
    do
    {
      v21 = mlir::getConstantIntValue(v18[v19]);
      if (v22)
        v23 = v21 == 0;
      else
        v23 = 0;
      if (!v23)
      {
        if ((v6 & 1) != 0)
        {
          v6 = v6 & 0xFC00000000000000 | (2
                                          * (((v6 >> 1) & ~(-1 << (v6 >> 58)) | (1 << v19)) & ~(-1 << (v6 >> 58)))) | 1;
          *a2 = v6;
        }
        else
        {
          *(_QWORD *)(*(_QWORD *)v6 + 8 * (v19 >> 6)) |= 1 << v19;
        }
      }
      ++v19;
      v20 -= 8;
    }
    while (v20);
    v18 = v24;
  }
  if (v18 != v26)
    free(v18);
}

void mlir::tensor::PadOp::getMixedLowPad(mlir::tensor::PadOp *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4;
  uint64_t *v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t Context;
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v4 = 0;
  *(_QWORD *)&v21 = *(_QWORD *)(v4 + 16);
  v5 = (uint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v21);
  LODWORD(v7) = v6;
  v8 = *(unsigned int *)(*(_QWORD *)this + 44);
  if (HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v9 = *(_QWORD *)this + 16 * ((v8 >> 23) & 1) + 64;
  else
    v9 = 0;
  v10 = *(unsigned int *)(v9 + 24);
  v11 = *(_DWORD *)(v9 + 28);
  if ((v8 & 0x800000) != 0)
    v12 = *(_QWORD *)(*(_QWORD *)this + 72);
  else
    v12 = 0;
  mlir::ValueRange::ValueRange((unint64_t *)&v20, v12 + 32 * v10, (v11 + v10) - v10);
  v21 = v20;
  Context = mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)this + 24));
  *(_QWORD *)a2 = a2 + 16;
  *(_QWORD *)(a2 + 8) = 0x600000000;
  v7 = v7;
  if ((_DWORD)v7)
  {
    v13 = 0;
    do
    {
      v15 = *v5++;
      v14 = v15;
      if (v15 == 0x8000000000000000)
      {
        v16 = mlir::ValueRange::dereference_iterator(&v21, v13) | 4;
        v17 = *(unsigned int *)(a2 + 8);
        v18 = *(unsigned int *)(a2 + 12);
        ++v13;
      }
      else
      {
        v16 = mlir::Builder::getI64IntegerAttr((mlir::Builder *)&Context, v14) & 0xFFFFFFFFFFFFFFFBLL;
        v17 = *(unsigned int *)(a2 + 8);
        v18 = *(unsigned int *)(a2 + 12);
      }
      if (v17 >= v18)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v17 + 1, 8);
        v17 = *(unsigned int *)(a2 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a2 + 8 * v17) = v16;
      ++*(_DWORD *)(a2 + 8);
      --v7;
    }
    while (v7);
  }
}

void mlir::tensor::PadOp::getMixedHighPad(mlir::tensor::PadOp *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4;
  uint64_t *v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  _DWORD *v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t Context;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v4 = 0;
  *(_QWORD *)&v22 = *(_QWORD *)(v4 + 8);
  v5 = (uint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v22);
  LODWORD(v7) = v6;
  v8 = *(unsigned int *)(*(_QWORD *)this + 44);
  if (HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v9 = (_DWORD *)(*(_QWORD *)this + 16 * ((v8 >> 23) & 1) + 64);
  else
    v9 = 0;
  v10 = v9[6];
  v11 = v9[7];
  v12 = v9[8];
  if ((v8 & 0x800000) != 0)
    v13 = *(_QWORD *)(*(_QWORD *)this + 72);
  else
    v13 = 0;
  mlir::ValueRange::ValueRange((unint64_t *)&v21, v13 + 32 * (v11 + v10), (v12 + v11 + v10) - (unint64_t)(v11 + v10));
  v22 = v21;
  Context = mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)this + 24));
  *(_QWORD *)a2 = a2 + 16;
  *(_QWORD *)(a2 + 8) = 0x600000000;
  v7 = v7;
  if ((_DWORD)v7)
  {
    v14 = 0;
    do
    {
      v16 = *v5++;
      v15 = v16;
      if (v16 == 0x8000000000000000)
      {
        v17 = mlir::ValueRange::dereference_iterator(&v22, v14) | 4;
        v18 = *(unsigned int *)(a2 + 8);
        v19 = *(unsigned int *)(a2 + 12);
        ++v14;
      }
      else
      {
        v17 = mlir::Builder::getI64IntegerAttr((mlir::Builder *)&Context, v15) & 0xFFFFFFFFFFFFFFFBLL;
        v18 = *(unsigned int *)(a2 + 8);
        v19 = *(unsigned int *)(a2 + 12);
      }
      if (v18 >= v19)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v18 + 1, 8);
        v18 = *(unsigned int *)(a2 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a2 + 8 * v18) = v17;
      ++*(_DWORD *)(a2 + 8);
      --v7;
    }
    while (v7);
  }
}

void mlir::tensor::PadOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  const char *v45;
  unint64_t v46;
  uint64_t v47;
  const char *v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  const char *v82;
  unint64_t v83;
  char *v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  uint64_t *v90;
  char *v91;
  char *v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  char *v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  const char *v113;
  unint64_t v114;
  uint64_t v115;
  const char *v116;
  unint64_t v117;
  char *v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  char *v123;
  uint64_t *v124;
  char *v125;
  char *v126;
  unint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  char *v131;
  char *v132;
  uint64_t v133;
  __int128 v134;
  __int128 v135;
  uint64_t v136;
  char *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unint64_t v141;
  unint64_t v142;
  char *v143;
  uint64_t v144;
  unint64_t v145;
  unint64_t v146;
  const char *v147;
  unint64_t v148;
  uint64_t v149;
  const char *v150;
  unint64_t v151;
  char *v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  unint64_t v156;
  char *v157;
  uint64_t *v158;
  char *v159;
  char *v160;
  unint64_t v161;
  uint64_t v162;
  uint64_t v163;
  char *v164;
  char *v165;
  char *v166;
  uint64_t v167;
  __int128 v168;
  __int128 v169;
  uint64_t v170;
  char *v171;
  uint64_t v172;
  uint64_t v173;
  const char *v174;
  unint64_t v175;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v174, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"tensor.pad", 10, (__int16)v174, a2, 0, 0);
  *(_QWORD *)v4 = &off_24C029EC0;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v174 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldStaticZeroPadding]";
  v175 = 94;
  v9 = llvm::StringRef::find((uint64_t *)&v174, "DesiredTypeName = ", 0x12uLL, 0);
  if (v175 >= v9)
    v10 = v9;
  else
    v10 = v175;
  v11 = &v174[v10];
  v12 = v175 - v10;
  if (v175 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v175 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_192;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_193;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_196;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_196:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v174, 1);
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"tensor.pad", 10, (__int16)v174, a2, 0, 0);
  *(_QWORD *)v38 = &off_24C029BF8;
  if (*(_QWORD *)(v38 + 72))
  {
    v39 = *(unsigned int *)(v38 + 88);
    if (v39 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v39, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  v174 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldSourceTensorCast]";
  v175 = 93;
  v43 = llvm::StringRef::find((uint64_t *)&v174, "DesiredTypeName = ", 0x12uLL, 0);
  if (v175 >= v43)
    v44 = v43;
  else
    v44 = v175;
  v45 = &v174[v44];
  v46 = v175 - v44;
  if (v175 - v44 >= 0x12)
    v47 = 18;
  else
    v47 = v175 - v44;
  v48 = &v45[v47];
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *(_QWORD *)(v38 + 64) = v48;
  *(_QWORD *)(v38 + 72) = v49;
  v39 = *(unsigned int *)(v38 + 88);
  if (v39 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
    goto LABEL_192;
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (v54)
  {
    if (v54 >> 61)
      goto LABEL_193;
    v55 = (char *)operator new(8 * v54);
    v56 = (uint64_t *)&v55[8 * v51];
    v57 = &v55[8 * v54];
    *v56 = v38;
    v42 = (uint64_t)(v56 + 1);
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
  }
  else
  {
    v55 = 0;
    v56 = (uint64_t *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
    {
LABEL_62:
      v59 = (unint64_t)(v58 - 8);
      if (v59 < 0x78
        || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v56
        && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
      {
        goto LABEL_197;
      }
      v60 = (v59 >> 3) + 1;
      v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      v62 = &v41[-v61];
      v56 = (uint64_t *)((char *)v56 - v61);
      v63 = &v55[8 * v51 - 16];
      v64 = v41 - 16;
      v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v67 = *((_OWORD *)v64 - 1);
        v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      v41 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_197:
        do
        {
          v68 = *((_QWORD *)v41 - 1);
          v41 -= 8;
          *(_QWORD *)v41 = 0;
          *--v56 = v68;
        }
        while (v41 != v50);
      }
      v41 = (char *)a1[1];
      v69 = (char *)a1[2];
      a1[1] = v56;
      a1[2] = v42;
      a1[3] = v57;
      while (v69 != v41)
      {
        v71 = *((_QWORD *)v69 - 1);
        v69 -= 8;
        v70 = v71;
        *(_QWORD *)v69 = 0;
        if (v71)
          (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
      }
      goto LABEL_75;
    }
  }
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
  v72 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v174, 1);
  mlir::Pattern::Pattern(v72 + 8, (uint64_t)"tensor.pad", 10, (__int16)v174, a2, 0, 0);
  *(_QWORD *)v72 = &off_24C029C50;
  if (*(_QWORD *)(v72 + 72))
  {
    v73 = *(unsigned int *)(v72 + 88);
    if (v73 <= *(_DWORD *)(v72 + 92))
      goto LABEL_79;
LABEL_90:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v72 + 80, (void *)(v72 + 96), v73, 16);
    *(_DWORD *)(v72 + 88) = *(_DWORD *)(v72 + 88);
    v75 = (char *)a1[2];
    v74 = a1[3];
    if ((unint64_t)v75 < v74)
      goto LABEL_80;
    goto LABEL_91;
  }
  v174 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldTargetTensorCast]";
  v175 = 93;
  v77 = llvm::StringRef::find((uint64_t *)&v174, "DesiredTypeName = ", 0x12uLL, 0);
  if (v175 >= v77)
    v78 = v77;
  else
    v78 = v175;
  v79 = &v174[v78];
  v80 = v175 - v78;
  if (v175 - v78 >= 0x12)
    v81 = 18;
  else
    v81 = v175 - v78;
  v82 = &v79[v81];
  v83 = v80 - v81;
  if (v83 >= v83 - 1)
    --v83;
  *(_QWORD *)(v72 + 64) = v82;
  *(_QWORD *)(v72 + 72) = v83;
  v73 = *(unsigned int *)(v72 + 88);
  if (v73 > *(_DWORD *)(v72 + 92))
    goto LABEL_90;
LABEL_79:
  *(_DWORD *)(v72 + 88) = v73;
  v75 = (char *)a1[2];
  v74 = a1[3];
  if ((unint64_t)v75 < v74)
  {
LABEL_80:
    *(_QWORD *)v75 = v72;
    v76 = (uint64_t)(v75 + 8);
    goto LABEL_115;
  }
LABEL_91:
  v84 = (char *)a1[1];
  v85 = (v75 - v84) >> 3;
  v86 = v85 + 1;
  if ((unint64_t)(v85 + 1) >> 61)
    goto LABEL_192;
  v87 = v74 - (_QWORD)v84;
  if (v87 >> 2 > v86)
    v86 = v87 >> 2;
  if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
    v88 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v88 = v86;
  if (v88)
  {
    if (v88 >> 61)
      goto LABEL_193;
    v89 = (char *)operator new(8 * v88);
    v90 = (uint64_t *)&v89[8 * v85];
    v91 = &v89[8 * v88];
    *v90 = v72;
    v76 = (uint64_t)(v90 + 1);
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
      goto LABEL_100;
  }
  else
  {
    v89 = 0;
    v90 = (uint64_t *)(8 * v85);
    v91 = 0;
    *(_QWORD *)(8 * v85) = v72;
    v76 = 8 * v85 + 8;
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
    {
LABEL_100:
      v93 = (unint64_t)(v92 - 8);
      if (v93 < 0x78
        || &v75[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v90
        && &v89[v75 - v84 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v75)
      {
        goto LABEL_198;
      }
      v94 = (v93 >> 3) + 1;
      v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
      v96 = &v75[-v95];
      v90 = (uint64_t *)((char *)v90 - v95);
      v97 = &v89[8 * v85 - 16];
      v98 = v75 - 16;
      v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v101 = *((_OWORD *)v98 - 1);
        v100 = *(_OWORD *)v98;
        *((_OWORD *)v98 - 1) = 0uLL;
        *(_OWORD *)v98 = 0uLL;
        *((_OWORD *)v97 - 1) = v101;
        *(_OWORD *)v97 = v100;
        v97 -= 32;
        v98 -= 32;
        v99 -= 4;
      }
      while (v99);
      v75 = v96;
      if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_198:
        do
        {
          v102 = *((_QWORD *)v75 - 1);
          v75 -= 8;
          *(_QWORD *)v75 = 0;
          *--v90 = v102;
        }
        while (v75 != v84);
      }
      v75 = (char *)a1[1];
      v103 = (char *)a1[2];
      a1[1] = v90;
      a1[2] = v76;
      a1[3] = v91;
      while (v103 != v75)
      {
        v105 = *((_QWORD *)v103 - 1);
        v103 -= 8;
        v104 = v105;
        *(_QWORD *)v103 = 0;
        if (v105)
          (*(void (**)(uint64_t))(*(_QWORD *)v104 + 8))(v104);
      }
      goto LABEL_113;
    }
  }
  a1[1] = v90;
  a1[2] = v76;
  a1[3] = v91;
LABEL_113:
  if (v75)
    operator delete(v75);
LABEL_115:
  a1[2] = v76;
  v106 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v174, 1);
  mlir::Pattern::Pattern(v106 + 8, (uint64_t)"tensor.pad", 10, (__int16)v174, a2, 0, 0);
  *(_QWORD *)v106 = &off_24C02A368;
  if (*(_QWORD *)(v106 + 72))
  {
    v107 = *(unsigned int *)(v106 + 88);
    if (v107 <= *(_DWORD *)(v106 + 92))
      goto LABEL_117;
LABEL_128:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v106 + 80, (void *)(v106 + 96), v107, 16);
    *(_DWORD *)(v106 + 88) = *(_DWORD *)(v106 + 88);
    v109 = (char *)a1[2];
    v108 = a1[3];
    if ((unint64_t)v109 < v108)
      goto LABEL_118;
    goto LABEL_129;
  }
  v174 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldOrthogonalPaddings]";
  v175 = 95;
  v111 = llvm::StringRef::find((uint64_t *)&v174, "DesiredTypeName = ", 0x12uLL, 0);
  if (v175 >= v111)
    v112 = v111;
  else
    v112 = v175;
  v113 = &v174[v112];
  v114 = v175 - v112;
  if (v175 - v112 >= 0x12)
    v115 = 18;
  else
    v115 = v175 - v112;
  v116 = &v113[v115];
  v117 = v114 - v115;
  if (v117 >= v117 - 1)
    --v117;
  *(_QWORD *)(v106 + 64) = v116;
  *(_QWORD *)(v106 + 72) = v117;
  v107 = *(unsigned int *)(v106 + 88);
  if (v107 > *(_DWORD *)(v106 + 92))
    goto LABEL_128;
LABEL_117:
  *(_DWORD *)(v106 + 88) = v107;
  v109 = (char *)a1[2];
  v108 = a1[3];
  if ((unint64_t)v109 < v108)
  {
LABEL_118:
    *(_QWORD *)v109 = v106;
    v110 = (uint64_t)(v109 + 8);
    goto LABEL_153;
  }
LABEL_129:
  v118 = (char *)a1[1];
  v119 = (v109 - v118) >> 3;
  v120 = v119 + 1;
  if ((unint64_t)(v119 + 1) >> 61)
    goto LABEL_192;
  v121 = v108 - (_QWORD)v118;
  if (v121 >> 2 > v120)
    v120 = v121 >> 2;
  if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFF8)
    v122 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v122 = v120;
  if (v122)
  {
    if (v122 >> 61)
      goto LABEL_193;
    v123 = (char *)operator new(8 * v122);
    v124 = (uint64_t *)&v123[8 * v119];
    v125 = &v123[8 * v122];
    *v124 = v106;
    v110 = (uint64_t)(v124 + 1);
    v126 = (char *)(v109 - v118);
    if (v109 != v118)
      goto LABEL_138;
  }
  else
  {
    v123 = 0;
    v124 = (uint64_t *)(8 * v119);
    v125 = 0;
    *(_QWORD *)(8 * v119) = v106;
    v110 = 8 * v119 + 8;
    v126 = (char *)(v109 - v118);
    if (v109 != v118)
    {
LABEL_138:
      v127 = (unint64_t)(v126 - 8);
      if (v127 < 0x78
        || &v109[-(v127 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v124
        && &v123[v109 - v118 - (v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v109)
      {
        goto LABEL_199;
      }
      v128 = (v127 >> 3) + 1;
      v129 = 8 * (v128 & 0x3FFFFFFFFFFFFFFCLL);
      v130 = &v109[-v129];
      v124 = (uint64_t *)((char *)v124 - v129);
      v131 = &v123[8 * v119 - 16];
      v132 = v109 - 16;
      v133 = v128 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v135 = *((_OWORD *)v132 - 1);
        v134 = *(_OWORD *)v132;
        *((_OWORD *)v132 - 1) = 0uLL;
        *(_OWORD *)v132 = 0uLL;
        *((_OWORD *)v131 - 1) = v135;
        *(_OWORD *)v131 = v134;
        v131 -= 32;
        v132 -= 32;
        v133 -= 4;
      }
      while (v133);
      v109 = v130;
      if (v128 != (v128 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_199:
        do
        {
          v136 = *((_QWORD *)v109 - 1);
          v109 -= 8;
          *(_QWORD *)v109 = 0;
          *--v124 = v136;
        }
        while (v109 != v118);
      }
      v109 = (char *)a1[1];
      v137 = (char *)a1[2];
      a1[1] = v124;
      a1[2] = v110;
      a1[3] = v125;
      while (v137 != v109)
      {
        v139 = *((_QWORD *)v137 - 1);
        v137 -= 8;
        v138 = v139;
        *(_QWORD *)v137 = 0;
        if (v139)
          (*(void (**)(uint64_t))(*(_QWORD *)v138 + 8))(v138);
      }
      goto LABEL_151;
    }
  }
  a1[1] = v124;
  a1[2] = v110;
  a1[3] = v125;
LABEL_151:
  if (v109)
    operator delete(v109);
LABEL_153:
  a1[2] = v110;
  v140 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v174, 1);
  mlir::Pattern::Pattern(v140 + 8, (uint64_t)"tensor.pad", 10, (__int16)v174, a2, 0, 0);
  *(_QWORD *)v140 = &off_24C0292D0;
  if (*(_QWORD *)(v140 + 72))
  {
    v141 = *(unsigned int *)(v140 + 88);
    if (v141 <= *(_DWORD *)(v140 + 92))
      goto LABEL_155;
LABEL_166:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v140 + 80, (void *)(v140 + 96), v141, 16);
    *(_DWORD *)(v140 + 88) = *(_DWORD *)(v140 + 88);
    v143 = (char *)a1[2];
    v142 = a1[3];
    if ((unint64_t)v143 < v142)
      goto LABEL_156;
    goto LABEL_167;
  }
  v174 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldStaticPadding]";
  v175 = 90;
  v145 = llvm::StringRef::find((uint64_t *)&v174, "DesiredTypeName = ", 0x12uLL, 0);
  if (v175 >= v145)
    v146 = v145;
  else
    v146 = v175;
  v147 = &v174[v146];
  v148 = v175 - v146;
  if (v175 - v146 >= 0x12)
    v149 = 18;
  else
    v149 = v175 - v146;
  v150 = &v147[v149];
  v151 = v148 - v149;
  if (v151 >= v151 - 1)
    --v151;
  *(_QWORD *)(v140 + 64) = v150;
  *(_QWORD *)(v140 + 72) = v151;
  v141 = *(unsigned int *)(v140 + 88);
  if (v141 > *(_DWORD *)(v140 + 92))
    goto LABEL_166;
LABEL_155:
  *(_DWORD *)(v140 + 88) = v141;
  v143 = (char *)a1[2];
  v142 = a1[3];
  if ((unint64_t)v143 < v142)
  {
LABEL_156:
    *(_QWORD *)v143 = v140;
    v144 = (uint64_t)(v143 + 8);
    goto LABEL_191;
  }
LABEL_167:
  v152 = (char *)a1[1];
  v153 = (v143 - v152) >> 3;
  v154 = v153 + 1;
  if ((unint64_t)(v153 + 1) >> 61)
LABEL_192:
    abort();
  v155 = v142 - (_QWORD)v152;
  if (v155 >> 2 > v154)
    v154 = v155 >> 2;
  if ((unint64_t)v155 >= 0x7FFFFFFFFFFFFFF8)
    v156 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v156 = v154;
  if (!v156)
  {
    v157 = 0;
    v158 = (uint64_t *)(8 * v153);
    v159 = 0;
    *(_QWORD *)(8 * v153) = v140;
    v144 = 8 * v153 + 8;
    v160 = (char *)(v143 - v152);
    if (v143 != v152)
      goto LABEL_176;
    goto LABEL_188;
  }
  if (v156 >> 61)
LABEL_193:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v157 = (char *)operator new(8 * v156);
  v158 = (uint64_t *)&v157[8 * v153];
  v159 = &v157[8 * v156];
  *v158 = v140;
  v144 = (uint64_t)(v158 + 1);
  v160 = (char *)(v143 - v152);
  if (v143 != v152)
  {
LABEL_176:
    v161 = (unint64_t)(v160 - 8);
    if (v161 < 0x78
      || &v143[-(v161 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v158
      && &v157[v143 - v152 - (v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v143)
    {
      goto LABEL_200;
    }
    v162 = (v161 >> 3) + 1;
    v163 = 8 * (v162 & 0x3FFFFFFFFFFFFFFCLL);
    v164 = &v143[-v163];
    v158 = (uint64_t *)((char *)v158 - v163);
    v165 = &v157[8 * v153 - 16];
    v166 = v143 - 16;
    v167 = v162 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v169 = *((_OWORD *)v166 - 1);
      v168 = *(_OWORD *)v166;
      *((_OWORD *)v166 - 1) = 0uLL;
      *(_OWORD *)v166 = 0uLL;
      *((_OWORD *)v165 - 1) = v169;
      *(_OWORD *)v165 = v168;
      v165 -= 32;
      v166 -= 32;
      v167 -= 4;
    }
    while (v167);
    v143 = v164;
    if (v162 != (v162 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_200:
      do
      {
        v170 = *((_QWORD *)v143 - 1);
        v143 -= 8;
        *(_QWORD *)v143 = 0;
        *--v158 = v170;
      }
      while (v143 != v152);
    }
    v143 = (char *)a1[1];
    v171 = (char *)a1[2];
    a1[1] = v158;
    a1[2] = v144;
    a1[3] = v159;
    while (v171 != v143)
    {
      v173 = *((_QWORD *)v171 - 1);
      v171 -= 8;
      v172 = v173;
      *(_QWORD *)v171 = 0;
      if (v173)
        (*(void (**)(uint64_t))(*(_QWORD *)v172 + 8))(v172);
    }
    goto LABEL_189;
  }
LABEL_188:
  a1[1] = v158;
  a1[2] = v144;
  a1[3] = v159;
LABEL_189:
  if (v143)
    operator delete(v143);
LABEL_191:
  a1[2] = v144;
}

uint64_t mlir::tensor::PadOp::getConstantPaddingValue(mlir::tensor::PadOp *this)
{
  uint64_t v2;
  ZinIrHalH13g **v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t DefiningOp;
  uint64_t ParentBlock;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;

  v2 = *(_QWORD *)(((*(_QWORD *)this
                   + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(*(_QWORD *)this + 40)
                 + 8);
  if (v2)
    v3 = (ZinIrHalH13g **)(v2 - 8);
  else
    v3 = 0;
  mlir::Block::getTerminator(v3);
  v5 = 0;
  if (v4)
    v6 = *(_QWORD *)(*(_QWORD *)(v4 + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::tensor::YieldOp,void>::id;
  else
    v6 = 0;
  if (!v6)
    return v5;
  v5 = *(_QWORD *)(*(_QWORD *)(v4 + 72) + 24);
  v12 = v5;
  v13 = v5;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v13);
  if (DefiningOp)
  {
    if ((mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)) & 1) != 0)
      return v5;
  }
  ParentBlock = mlir::Value::getParentBlock((mlir::Value *)&v12);
  v9 = *(_QWORD *)(((*(_QWORD *)this
                   + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(*(_QWORD *)this + 40)
                 + 8);
  if (v9)
    v10 = v9 - 8;
  else
    v10 = 0;
  if (ParentBlock != v10)
    return v12;
  return 0;
}

uint64_t mlir::tensor::PadOp::fold(uint64_t a1)
{
  uint64_t v2;
  _QWORD *Value;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t NextResultAtOffset;
  uint64_t v8;
  unint64_t v10;

  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v2 = *(_QWORD *)a1 - 16;
  else
    v2 = 0;
  v10 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!mlir::TensorType::hasRank((mlir::TensorType *)&v10))
    return 0;
  Value = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v10);
  if (v4)
  {
    v5 = 8 * v4;
    while (*Value != 0x8000000000000000)
    {
      ++Value;
      v5 -= 8;
      if (!v5)
        goto LABEL_9;
    }
    return 0;
  }
LABEL_9:
  v6 = *(_DWORD *)(*(_QWORD *)a1 + 36) ? *(_QWORD *)a1 - 16 : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
  v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24);
  if ((*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8) != (*(_QWORD *)(v8 + 8) & 0xFFFFFFFFFFFFFFF8)
    || *(_QWORD *)(*(_QWORD *)a1 + 80))
  {
    return 0;
  }
  return v8 | 4;
}

void mlir::tensor::ParallelInsertSliceOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t *a9, uint64_t a10, void *__src, uint64_t a12)
{
  uint64_t DenseI64ArrayAttr;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v22[2];
  unint64_t v23[2];
  unint64_t v24[2];
  unint64_t v25[2];
  void *v26;
  uint64_t v27;
  _BYTE v28[48];
  void *v29;
  uint64_t v30;
  _BYTE v31[48];
  void *v32;
  uint64_t v33;
  _BYTE v34[48];
  void *v35;
  uint64_t v36;
  _BYTE v37[48];
  _BYTE *v38;
  uint64_t v39;
  _BYTE v40[48];
  _QWORD *v41;
  uint64_t v42;
  _QWORD v43[8];

  v43[6] = *MEMORY[0x24BDAC8D0];
  v41 = v43;
  v42 = 0x600000000;
  v38 = v40;
  v39 = 0x600000000;
  v35 = v37;
  v36 = 0x600000000;
  v32 = v34;
  v33 = 0x600000000;
  v29 = v31;
  v30 = 0x600000000;
  v26 = v28;
  v27 = 0x600000000;
  mlir::dispatchIndexOpFoldResults(a5, a6, (uint64_t)&v32, (uint64_t)&v41);
  mlir::dispatchIndexOpFoldResults(a7, a8, (uint64_t)&v29, (uint64_t)&v38);
  mlir::dispatchIndexOpFoldResults(a9, a10, (uint64_t)&v26, (uint64_t)&v35);
  mlir::ValueRange::ValueRange(v25, 0, 0);
  mlir::ValueRange::ValueRange(v24, (uint64_t)v32, v33);
  mlir::ValueRange::ValueRange(v23, (uint64_t)v29, v30);
  mlir::ValueRange::ValueRange(v22, (uint64_t)v26, v27);
  DenseI64ArrayAttr = mlir::Builder::getDenseI64ArrayAttr(a1, (uint64_t)v41, v42);
  v17 = mlir::Builder::getDenseI64ArrayAttr(a1, (uint64_t)v38, v39);
  v18 = mlir::Builder::getDenseI64ArrayAttr(a1, (uint64_t)v35, v36);
  mlir::tensor::ParallelInsertSliceOp::build(v18, a2, v25[0], v25[1], a3, a4, v24[0], v24[1], v23[0], v23[1], v22[0], v22[1], DenseI64ArrayAttr, v17, v18);
  *(_QWORD *)(a2 + 192) = 0;
  v19 = *(unsigned int *)(a2 + 120);
  if (a12 + v19 > (unint64_t)*(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), a12 + v19, 16);
    LODWORD(v19) = *(_DWORD *)(a2 + 120);
  }
  if (a12)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 112) + 16 * v19), __src, 16 * a12);
    LODWORD(v19) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v19 + a12;
  if (v26 != v28)
    free(v26);
  if (v29 != v31)
    free(v29);
  if (v32 != v34)
    free(v32);
  if (v35 != v37)
    free(v35);
  if (v38 != v40)
    free(v38);
  if (v41 != v43)
    free(v41);
}

void mlir::tensor::ParallelInsertSliceOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v24 = a6;
  v25 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v25, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v24, 1);
  mlir::OperationState::addOperands(a2, a7, a8);
  mlir::OperationState::addOperands(a2, a9, a10);
  mlir::OperationState::addOperands(a2, a11, a12);
  v20 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2);
  *(_QWORD *)(v20 + 24) = 0x100000001;
  *(_DWORD *)(v20 + 32) = a8;
  *(_DWORD *)(v20 + 36) = a10;
  *(_DWORD *)(v20 + 40) = a12;
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2) = a13;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a14;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a15;
  v21 = *(unsigned int *)(a2 + 72);
  if (a4 + v21 > (unint64_t)*(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), a4 + v21, 8);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  if (a4)
  {
    v22 = 0;
    v23 = *(_QWORD *)(a2 + 64) + 8 * v21;
    do
    {
      *(_QWORD *)(v23 + 8 * v22) = mlir::TypeRange::dereference_iterator(a3, v22);
      ++v22;
    }
    while (a4 != v22);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v21 + a4;
}

uint64_t mlir::tensor::ParallelInsertSliceOp::verify(uint64_t **this)
{
  mlir::Block *ParentOp;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t RHS;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  mlir::Block *v16;
  mlir::Operation *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  int isRankReducedType;
  uint64_t v28;
  const char *v30;
  __int16 v31;
  unint64_t v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  void *v36;
  _QWORD *v37;
  void *__p;
  _QWORD *v39;
  char v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  ParentOp = (mlir::Block *)(*this)[2];
  if (ParentOp)
    ParentOp = (mlir::Block *)mlir::Block::getParentOp(ParentOp);
  if (mlir::OpInterface<mlir::ParallelCombiningOpInterface,mlir::detail::ParallelCombiningOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)ParentOp))
  {
    v3 = (*this)[9];
    v4 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    v5 = (uint64_t)(*this + 10);
    if (!*((_BYTE *)*this + 47))
      v5 = 0;
    v6 = *(_QWORD *)(*(_QWORD *)(v3 + 32 * *(unsigned int *)(v5 + 24) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
    v32 = (*this)[10];
    mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v32);
    v7 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
    if (!HIBYTE(*((_DWORD *)*this + 11)))
      v7 = 0;
    v32 = *(_QWORD *)(v7 + 8);
    v8 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v32);
    v10 = v9;
    v11 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
    if (!HIBYTE(*((_DWORD *)*this + 11)))
      v11 = 0;
    v32 = *(_QWORD *)(v11 + 16);
    mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v32);
    v32 = v6;
    RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v32);
    v13 = (_QWORD *)mlir::RankedTensorType::get(v8, v10, RHS, 0);
    v14 = v13;
    if (v13)
    {
      v15 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v13 + 8);
      if (!v4)
      {
LABEL_31:
        isRankReducedType = mlir::isRankReducedType(v14, v15, v4);
        produceSliceErrorMsg(isRankReducedType);
        return v28;
      }
    }
    else
    {
      v15 = 0;
      if (!v4)
        goto LABEL_31;
    }
    mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v4 + 8);
    goto LABEL_31;
  }
  v30 = "expected ParallelCombiningOpInterface parent, got:";
  v31 = 259;
  mlir::OpState::emitError(this, (uint64_t)&v30, (uint64_t)&v32);
  v16 = (mlir::Block *)(*this)[2];
  if (!v16)
  {
    v17 = 0;
    if (!v32)
      goto LABEL_16;
    goto LABEL_15;
  }
  v17 = (mlir::Operation *)mlir::Block::getParentOp(v16);
  if (v32)
LABEL_15:
    mlir::Diagnostic::operator<<((mlir::Diagnostic *)&v33, v17);
LABEL_16:
  v18 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v32);
  if (v32)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v32);
  if (v40)
  {
    v19 = __p;
    if (__p)
    {
      v20 = v39;
      v21 = __p;
      if (v39 != __p)
      {
        do
          v20 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v20 - 1);
        while (v20 != v19);
        v21 = __p;
      }
      v39 = v19;
      operator delete(v21);
    }
    v22 = v36;
    if (v36)
    {
      v23 = v37;
      v24 = v36;
      if (v37 != v36)
      {
        do
        {
          v26 = *--v23;
          v25 = v26;
          *v23 = 0;
          if (v26)
            MEMORY[0x20BD002D4](v25, 0x1000C8077774924);
        }
        while (v23 != v22);
        v24 = v36;
      }
      v37 = v22;
      operator delete(v24);
    }
    if (v34 != &v35)
      free(v34);
  }
  return v18;
}

void mlir::tensor::ParallelInsertSliceOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  const char *v45;
  unint64_t v46;
  uint64_t v47;
  const char *v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  const char *v82;
  unint64_t v83;
  char *v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  uint64_t *v90;
  char *v91;
  char *v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  const char *v106;
  unint64_t v107;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v106, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"tensor.parallel_insert_slice", 28, (__int16)v106, a2, 0, 0);
  *(_QWORD *)v4 = &off_24C02B118;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v106 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mli"
         "r::tensor::ParallelInsertSliceOp>]";
  v107 = 145;
  v9 = llvm::StringRef::find((uint64_t *)&v106, "DesiredTypeName = ", 0x12uLL, 0);
  if (v107 >= v9)
    v10 = v9;
  else
    v10 = v107;
  v11 = &v106[v10];
  v12 = v107 - v10;
  if (v107 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v107 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_116;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_117;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_120;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_120:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v106, 1);
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"tensor.parallel_insert_slice", 28, (__int16)v106, a2, 0, 0);
  *(_QWORD *)v38 = &off_24C02A6B0;
  if (*(_QWORD *)(v38 + 72))
  {
    v39 = *(unsigned int *)(v38 + 88);
    if (v39 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v39, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  v106 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::P"
         "arallelInsertSliceOp>]";
  v107 = 133;
  v43 = llvm::StringRef::find((uint64_t *)&v106, "DesiredTypeName = ", 0x12uLL, 0);
  if (v107 >= v43)
    v44 = v43;
  else
    v44 = v107;
  v45 = &v106[v44];
  v46 = v107 - v44;
  if (v107 - v44 >= 0x12)
    v47 = 18;
  else
    v47 = v107 - v44;
  v48 = &v45[v47];
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *(_QWORD *)(v38 + 64) = v48;
  *(_QWORD *)(v38 + 72) = v49;
  v39 = *(unsigned int *)(v38 + 88);
  if (v39 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
    goto LABEL_116;
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (v54)
  {
    if (v54 >> 61)
      goto LABEL_117;
    v55 = (char *)operator new(8 * v54);
    v56 = (uint64_t *)&v55[8 * v51];
    v57 = &v55[8 * v54];
    *v56 = v38;
    v42 = (uint64_t)(v56 + 1);
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
  }
  else
  {
    v55 = 0;
    v56 = (uint64_t *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
    {
LABEL_62:
      v59 = (unint64_t)(v58 - 8);
      if (v59 < 0x78
        || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v56
        && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
      {
        goto LABEL_121;
      }
      v60 = (v59 >> 3) + 1;
      v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      v62 = &v41[-v61];
      v56 = (uint64_t *)((char *)v56 - v61);
      v63 = &v55[8 * v51 - 16];
      v64 = v41 - 16;
      v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v67 = *((_OWORD *)v64 - 1);
        v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      v41 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_121:
        do
        {
          v68 = *((_QWORD *)v41 - 1);
          v41 -= 8;
          *(_QWORD *)v41 = 0;
          *--v56 = v68;
        }
        while (v41 != v50);
      }
      v41 = (char *)a1[1];
      v69 = (char *)a1[2];
      a1[1] = v56;
      a1[2] = v42;
      a1[3] = v57;
      while (v69 != v41)
      {
        v71 = *((_QWORD *)v69 - 1);
        v69 -= 8;
        v70 = v71;
        *(_QWORD *)v69 = 0;
        if (v71)
          (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
      }
      goto LABEL_75;
    }
  }
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
  v72 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v106, 1);
  mlir::Pattern::Pattern(v72 + 8, (uint64_t)"tensor.parallel_insert_slice", 28, (__int16)v106, a2, 0, 0);
  *(_QWORD *)v72 = &off_24C02B010;
  if (*(_QWORD *)(v72 + 72))
  {
    v73 = *(unsigned int *)(v72 + 88);
    if (v73 <= *(_DWORD *)(v72 + 92))
      goto LABEL_79;
LABEL_90:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v72 + 80, (void *)(v72 + 96), v73, 16);
    *(_DWORD *)(v72 + 88) = *(_DWORD *)(v72 + 88);
    v75 = (char *)a1[2];
    v74 = a1[3];
    if ((unint64_t)v75 < v74)
      goto LABEL_80;
    goto LABEL_91;
  }
  v106 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::t"
         "ensor::ParallelInsertSliceOp>]";
  v107 = 141;
  v77 = llvm::StringRef::find((uint64_t *)&v106, "DesiredTypeName = ", 0x12uLL, 0);
  if (v107 >= v77)
    v78 = v77;
  else
    v78 = v107;
  v79 = &v106[v78];
  v80 = v107 - v78;
  if (v107 - v78 >= 0x12)
    v81 = 18;
  else
    v81 = v107 - v78;
  v82 = &v79[v81];
  v83 = v80 - v81;
  if (v83 >= v83 - 1)
    --v83;
  *(_QWORD *)(v72 + 64) = v82;
  *(_QWORD *)(v72 + 72) = v83;
  v73 = *(unsigned int *)(v72 + 88);
  if (v73 > *(_DWORD *)(v72 + 92))
    goto LABEL_90;
LABEL_79:
  *(_DWORD *)(v72 + 88) = v73;
  v75 = (char *)a1[2];
  v74 = a1[3];
  if ((unint64_t)v75 < v74)
  {
LABEL_80:
    *(_QWORD *)v75 = v72;
    v76 = (uint64_t)(v75 + 8);
    goto LABEL_115;
  }
LABEL_91:
  v84 = (char *)a1[1];
  v85 = (v75 - v84) >> 3;
  v86 = v85 + 1;
  if ((unint64_t)(v85 + 1) >> 61)
LABEL_116:
    abort();
  v87 = v74 - (_QWORD)v84;
  if (v87 >> 2 > v86)
    v86 = v87 >> 2;
  if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
    v88 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v88 = v86;
  if (!v88)
  {
    v89 = 0;
    v90 = (uint64_t *)(8 * v85);
    v91 = 0;
    *(_QWORD *)(8 * v85) = v72;
    v76 = 8 * v85 + 8;
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
      goto LABEL_100;
    goto LABEL_112;
  }
  if (v88 >> 61)
LABEL_117:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v89 = (char *)operator new(8 * v88);
  v90 = (uint64_t *)&v89[8 * v85];
  v91 = &v89[8 * v88];
  *v90 = v72;
  v76 = (uint64_t)(v90 + 1);
  v92 = (char *)(v75 - v84);
  if (v75 != v84)
  {
LABEL_100:
    v93 = (unint64_t)(v92 - 8);
    if (v93 < 0x78
      || &v75[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v90
      && &v89[v75 - v84 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v75)
    {
      goto LABEL_122;
    }
    v94 = (v93 >> 3) + 1;
    v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
    v96 = &v75[-v95];
    v90 = (uint64_t *)((char *)v90 - v95);
    v97 = &v89[8 * v85 - 16];
    v98 = v75 - 16;
    v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v101 = *((_OWORD *)v98 - 1);
      v100 = *(_OWORD *)v98;
      *((_OWORD *)v98 - 1) = 0uLL;
      *(_OWORD *)v98 = 0uLL;
      *((_OWORD *)v97 - 1) = v101;
      *(_OWORD *)v97 = v100;
      v97 -= 32;
      v98 -= 32;
      v99 -= 4;
    }
    while (v99);
    v75 = v96;
    if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_122:
      do
      {
        v102 = *((_QWORD *)v75 - 1);
        v75 -= 8;
        *(_QWORD *)v75 = 0;
        *--v90 = v102;
      }
      while (v75 != v84);
    }
    v75 = (char *)a1[1];
    v103 = (char *)a1[2];
    a1[1] = v90;
    a1[2] = v76;
    a1[3] = v91;
    while (v103 != v75)
    {
      v105 = *((_QWORD *)v103 - 1);
      v103 -= 8;
      v104 = v105;
      *(_QWORD *)v103 = 0;
      if (v105)
        (*(void (**)(uint64_t))(*(_QWORD *)v104 + 8))(v104);
    }
    goto LABEL_113;
  }
LABEL_112:
  a1[1] = v90;
  a1[2] = v76;
  a1[3] = v91;
LABEL_113:
  if (v75)
    operator delete(v75);
LABEL_115:
  a1[2] = v76;
}

uint64_t mlir::tensor::ScatterOp::getAsmResultNames(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v4;
  uint64_t NextResultAtOffset;

  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v4 = *(_QWORD *)a1 - 16;
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return a2(a3, NextResultAtOffset, "scatter", 7);
}

uint64_t mlir::tensor::ScatterOp::verify(uint64_t **this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  int *v23;
  char *v24;
  char *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  unint64_t v32;
  int *v33;
  char *v34;
  char *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  char *v39;
  char *v40;
  __int128 v41;
  _QWORD *v42;
  _QWORD *v43;
  void *v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  _QWORD *v51;
  void *v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v57;
  unint64_t v58;
  BOOL v59;
  unint64_t v60;
  unint64_t v61;
  BOOL v62;
  unint64_t v63;
  unint64_t v64;
  BOOL v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  int64_t v70;
  int64_t v71;
  const void **v72[4];
  __int16 v73;
  int v74;
  const char *v75;
  uint64_t v76;
  _QWORD v77[3];
  void *v78;
  unsigned int v79;
  unsigned int v80;
  _BYTE v81[96];
  void *v82;
  _QWORD *v83;
  void *__p;
  _QWORD *v85;
  char v86;
  uint64_t v87;

  v87 = *MEMORY[0x24BDAC8D0];
  v77[0] = *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v77);
  v3 = v2;
  v77[0] = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v4 = (uint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v77);
  v6 = v5;
  if (!verifyGatherOrScatterDims(*this, v4, v5, v3, (const void **)"scatter", (const char *)7, (const void **)"dest", (const char *)4))return 0;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v7 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v7 = 0;
  if (*(_QWORD *)(v7 + 8))
  {
    v8 = mlir::tensor::GatherOp::inferResultType(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, *(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8, v4, v6, 0);
    v9 = 1;
    v10 = mlir::tensor::GatherOp::inferResultType(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, *(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8, v4, v6, 1);
    v11 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
    if (v11 != v8 && v11 != v10)
    {
      v13 = v10;
      v72[0] = (const void **)"source type mismatch: expected ";
      v73 = 259;
      mlir::OpState::emitOpError(this, v72, (uint64_t)v77);
      if (v77[0])
      {
        v14 = &v74;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v74, v8);
        v15 = (char *)v78;
        if (v79 >= v80)
        {
          v57 = v79 + 1;
          if (v78 <= &v74 && (char *)v78 + 24 * v79 > (char *)&v74)
          {
            v66 = (char *)&v74 - (_BYTE *)v78;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v57, 24);
            v15 = (char *)v78;
            v14 = (int *)((char *)v78 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v57, 24);
            v14 = &v74;
            v15 = (char *)v78;
          }
        }
        v16 = &v15[24 * v79];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
        *(_OWORD *)v16 = v17;
        v18 = ++v79;
        if (v77[0])
        {
          v74 = 3;
          v75 = " or its rank-reduced variant ";
          v76 = 29;
          v19 = &v74;
          v20 = (char *)v78;
          if (v18 >= v80)
          {
            v58 = v18 + 1;
            v59 = (char *)v78 + 24 * v18 > (char *)&v74;
            if (v78 <= &v74 && v59)
            {
              v67 = (char *)&v74 - (_BYTE *)v78;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v58, 24);
              v20 = (char *)v78;
              v19 = (int *)((char *)v78 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v58, 24);
              v19 = &v74;
              v20 = (char *)v78;
            }
          }
          v21 = &v20[24 * v79];
          v22 = *(_OWORD *)v19;
          *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
          *(_OWORD *)v21 = v22;
          ++v79;
          if (v77[0])
          {
            v23 = &v74;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v74, v13);
            v24 = (char *)v78;
            if (v79 >= v80)
            {
              v60 = v79 + 1;
              if (v78 <= &v74 && (char *)v78 + 24 * v79 > (char *)&v74)
              {
                v68 = (char *)&v74 - (_BYTE *)v78;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v60, 24);
                v24 = (char *)v78;
                v23 = (int *)((char *)v78 + v68);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v60, 24);
                v23 = &v74;
                v24 = (char *)v78;
              }
            }
            v25 = &v24[24 * v79];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v79;
            if (v77[0])
            {
              v74 = 3;
              v75 = " (got: ";
              v76 = 7;
              v28 = &v74;
              v29 = (char *)v78;
              if (v27 >= v80)
              {
                v61 = v27 + 1;
                v62 = (char *)v78 + 24 * v27 > (char *)&v74;
                if (v78 <= &v74 && v62)
                {
                  v69 = (char *)&v74 - (_BYTE *)v78;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v61, 24);
                  v29 = (char *)v78;
                  v28 = (int *)((char *)v78 + v69);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v61, 24);
                  v28 = &v74;
                  v29 = (char *)v78;
                }
              }
              v30 = &v29[24 * v79];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              ++v79;
              if (v77[0])
              {
                v32 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
                v33 = &v74;
                mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v74, v32);
                v34 = (char *)v78;
                if (v79 >= v80)
                {
                  v63 = v79 + 1;
                  if (v78 <= &v74 && (char *)v78 + 24 * v79 > (char *)&v74)
                  {
                    v70 = (char *)&v74 - (_BYTE *)v78;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v63, 24);
                    v34 = (char *)v78;
                    v33 = (int *)((char *)v78 + v70);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v63, 24);
                    v33 = &v74;
                    v34 = (char *)v78;
                  }
                }
                v35 = &v34[24 * v79];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v79;
                if (v77[0])
                {
                  v74 = 3;
                  v75 = ")";
                  v76 = 1;
                  v38 = &v74;
                  v39 = (char *)v78;
                  if (v37 >= v80)
                  {
                    v64 = v37 + 1;
                    v65 = (char *)v78 + 24 * v37 > (char *)&v74;
                    if (v78 <= &v74 && v65)
                    {
                      v71 = (char *)&v74 - (_BYTE *)v78;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v64, 24);
                      v39 = (char *)v78;
                      v38 = (int *)((char *)v78 + v71);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v64, 24);
                      v38 = &v74;
                      v39 = (char *)v78;
                    }
                  }
                  v40 = &v39[24 * v79];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  ++v79;
                }
              }
            }
          }
        }
      }
      v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v77);
      if (v77[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v77);
      if (v86)
      {
        v42 = __p;
        if (__p)
        {
          v43 = v85;
          v44 = __p;
          if (v85 != __p)
          {
            do
              v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
            while (v43 != v42);
            v44 = __p;
          }
          v85 = v42;
          operator delete(v44);
        }
        v45 = v82;
        if (!v82)
          goto LABEL_54;
        v46 = v83;
        v47 = v82;
        if (v83 == v82)
        {
LABEL_53:
          v83 = v45;
          operator delete(v47);
LABEL_54:
          if (v78 != v81)
            free(v78);
          return v9;
        }
        do
        {
          v49 = *--v46;
          v48 = v49;
          *v46 = 0;
          if (v49)
            MEMORY[0x20BD002D4](v48, 0x1000C8077774924);
        }
        while (v46 != v45);
LABEL_52:
        v47 = v82;
        goto LABEL_53;
      }
    }
  }
  else
  {
    v72[0] = (const void **)"requires 'unique' attribute to be set";
    v73 = 259;
    mlir::OpState::emitOpError(this, v72, (uint64_t)v77);
    v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v77);
    if (v77[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v77);
    if (v86)
    {
      v50 = __p;
      if (__p)
      {
        v51 = v85;
        v52 = __p;
        if (v85 != __p)
        {
          do
            v51 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v51 - 1);
          while (v51 != v50);
          v52 = __p;
        }
        v85 = v50;
        operator delete(v52);
      }
      v45 = v82;
      if (!v82)
        goto LABEL_54;
      v53 = v83;
      v47 = v82;
      if (v83 == v82)
        goto LABEL_53;
      do
      {
        v55 = *--v53;
        v54 = v55;
        *v53 = 0;
        if (v55)
          MEMORY[0x20BD002D4](v54, 0x1000C8077774924);
      }
      while (v53 != v45);
      goto LABEL_52;
    }
  }
  return v9;
}

uint64_t mlir::tensor::SplatOp::getAsmResultNames(_QWORD *a1, uint64_t (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  return a2(a3, *a1 - 16, "splat", 5);
}

unint64_t mlir::tensor::SplatOp::fold(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v8[2];

  v8[1] = *MEMORY[0x24BDAC8D0];
  v2 = **(_QWORD **)(a2 + 40);
  if (!v2)
    return 0;
  v3 = *(void **)(*(_QWORD *)v2 + 136);
  if (v3 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
    && v3 != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    return 0;
  }
  v5 = (_QWORD *)(*(_QWORD *)(*a1 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
    v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  else
    v6 = 0;
  v8[0] = v2;
  return mlir::DenseElementsAttr::get((uint64_t)v5, v6, v8, 1uLL) & 0xFFFFFFFFFFFFFFFBLL;
}

uint64_t mlir::tensor::PackOp::getAsmResultNames(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v4;
  uint64_t NextResultAtOffset;

  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v4 = *(_QWORD *)a1 - 16;
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return a2(a3, NextResultAtOffset, "pack", 4);
}

uint64_t mlir::tensor::PackOp::reifyResultShapes(uint64_t *a1, mlir::IndexType **a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  mlir::MLIRContext *i;
  unint64_t MixedSize;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v31;
  void *v32;
  uint64_t v33;
  _QWORD v34[7];

  v34[6] = *MEMORY[0x24BDAC8D0];
  v5 = *a1;
  v6 = *a1 + 80;
  if (*(_BYTE *)(*a1 + 47))
    v7 = *a1 + 80;
  else
    v7 = 0;
  v32 = (void *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 72) + 32 * *(unsigned int *)(v7 + 24) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v32);
  v32 = v34;
  v33 = 0x600000000;
  if (v8)
  {
    v9 = v8;
    if (v8 < 7)
    {
      v10 = 0;
      v11 = v8;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v32, v34, v8, 8);
      v10 = v33;
      v11 = v9 - v33;
      if (v9 == v33)
        goto LABEL_10;
    }
    bzero((char *)v32 + 8 * v10, 8 * v11);
LABEL_10:
    LODWORD(v33) = v9;
  }
  v12 = *(unsigned int *)(a3 + 8);
  if (!(_DWORD)v12)
  {
    llvm::SmallVectorImpl<llvm::SmallVector<mlir::OpFoldResult,6u>>::append(a3, 1 - v12, (unint64_t)&v32);
LABEL_18:
    v16 = v32;
    if (v32 == v34)
      goto LABEL_20;
    goto LABEL_19;
  }
  if ((_DWORD)v12 == 1)
    goto LABEL_18;
  v13 = *(_QWORD *)a3;
  v14 = v12 << 6;
  do
  {
    v15 = *(void **)(v13 + v14 - 64);
    if ((void *)(v13 + v14 - 48) != v15)
      free(v15);
    v14 -= 64;
  }
  while (v14 != 64);
  *(_DWORD *)(a3 + 8) = 1;
  v16 = v32;
  if (v32 != v34)
LABEL_19:
    free(v16);
LABEL_20:
  v17 = *(_QWORD *)(v5 + 24);
  if (*(_BYTE *)(v5 + 47))
    v18 = v6;
  else
    v18 = 0;
  v19 = *(_QWORD *)(*(_QWORD *)(v5 + 72) + 32 * *(unsigned int *)(v18 + 24) + 24);
  v31 = *(_QWORD *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8;
  v32 = v34;
  v33 = 0x600000000;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v31);
  if (v20 >= 1)
  {
    for (i = 0; (uint64_t)i < v24; i = (mlir::MLIRContext *)((char *)i + 1))
    {
      MixedSize = mlir::tensor::getMixedSize(a2, v17, v19, i);
      v23 = v33;
      if (v33 >= (unint64_t)HIDWORD(v33))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v32, v34, v33 + 1, 8);
        v23 = v33;
      }
      *((_QWORD *)v32 + v23) = MixedSize;
      LODWORD(v33) = v33 + 1;
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v31);
    }
  }
  v25 = *(_QWORD *)a3;
  v26 = v32;
  if ((void **)v25 != &v32)
  {
    if (v32 != v34)
    {
      if (*(_QWORD *)v25 != v25 + 16)
      {
        free(*(void **)v25);
        v26 = v32;
      }
      *(_QWORD *)v25 = v26;
      *(_QWORD *)(v25 + 8) = v33;
      v32 = v34;
      HIDWORD(v33) = 0;
      goto LABEL_45;
    }
    v27 = v33;
    v28 = *(unsigned int *)(v25 + 8);
    if (v28 >= v33)
    {
      if ((_DWORD)v33)
        memmove(*(void **)v25, v34, 8 * v33);
      goto LABEL_44;
    }
    if (*(_DWORD *)(v25 + 12) >= v33)
    {
      if ((_DWORD)v28)
      {
        memmove(*(void **)v25, v34, 8 * v28);
        v29 = v33;
        if (v28 == v33)
        {
LABEL_44:
          *(_DWORD *)(v25 + 8) = v27;
LABEL_45:
          LODWORD(v33) = 0;
          v26 = v32;
          goto LABEL_46;
        }
      }
      else
      {
        v28 = 0;
        v29 = v33;
        if (!(_DWORD)v33)
          goto LABEL_44;
      }
    }
    else
    {
      *(_DWORD *)(v25 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v25, (void *)(v25 + 16), v27, 8);
      v28 = 0;
      v29 = v33;
      if (!(_DWORD)v33)
        goto LABEL_44;
    }
    memcpy((void *)(*(_QWORD *)v25 + 8 * v28), (char *)v32 + 8 * v28, 8 * v29 - 8 * v28);
    goto LABEL_44;
  }
LABEL_46:
  if (v26 != v34)
    free(v26);
  return 1;
}

void mlir::tensor::PackOp::getMixedTiles(mlir::tensor::PackOp *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t Context;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unsigned int v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v3 = *(_QWORD *)this;
  Context = mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)this + 24));
  *(_QWORD *)a2 = a2 + 16;
  *(_QWORD *)(a2 + 8) = 0x600000000;
  if (HIBYTE(*(_DWORD *)(v3 + 44)))
    v5 = v3 + 16 * (((unint64_t)*(unsigned int *)(v3 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = *(_QWORD *)(v5 + 16);
  v16 = Context;
  v17 = v6;
  v7 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v17);
  if (v8)
  {
    v9 = (uint64_t *)v7;
    v10 = 0;
    v11 = 8 * v8;
    do
    {
      if (*v9 == 0x8000000000000000)
      {
        if (*(_BYTE *)(v3 + 47))
          v12 = (_DWORD *)(v3 + 80);
        else
          v12 = 0;
        v13 = v10++;
        v14 = *(_QWORD *)(*(_QWORD *)(v3 + 72) + 32 * (v12[7] + v12[6] + v12[8]) + 32 * v13 + 24) | 4;
      }
      else
      {
        v14 = mlir::Builder::getI64IntegerAttr((mlir::Builder *)&v16, *v9) & 0xFFFFFFFFFFFFFFFBLL;
      }
      v15 = *(unsigned int *)(a2 + 8);
      if (v15 >= *(unsigned int *)(a2 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v15 + 1, 8);
        v15 = *(unsigned int *)(a2 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a2 + 8 * v15) = v14;
      ++*(_DWORD *)(a2 + 8);
      ++v9;
      v11 -= 8;
    }
    while (v11);
  }
}

void mlir::tensor::PackOp::getStaticTiles(mlir::tensor::PackOp *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  void *v4;
  unsigned int v5;
  uint64_t v6;
  void *v7[2];
  _QWORD v8[7];

  v8[6] = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)this;
  v7[0] = v8;
  v7[1] = (void *)0x600000000;
  *a2 = a2 + 2;
  a2[1] = 0x600000000;
  mlir::tensor::PackOp::getMixedTiles((mlir::tensor::PackOp *)&v3, (uint64_t)&v4);
  mlir::dispatchIndexOpFoldResults((uint64_t *)v4, v5, (uint64_t)v7, (uint64_t)a2);
  if (v4 != &v6)
    free(v4);
  if (v7[0] != v8)
    free(v7[0]);
}

uint64_t mlir::tensor::PackOp::verify(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  mlir::MLIRContext **v22;
  mlir::MLIRContext *v23;
  _QWORD *i;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  unint64_t v32;
  uint64_t *v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t RHS;
  llvm **p_DenseI64ArrayAttr;
  char *v40;
  char *v41;
  __int128 v42;
  uint64_t v43;
  llvm **v44;
  char *v45;
  char *v46;
  __int128 v47;
  unint64_t v48;
  llvm **v49;
  char *v50;
  char *v51;
  __int128 v52;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  void *v56;
  _QWORD *v57;
  _QWORD *v58;
  void *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t Value;
  _QWORD *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  int64_t ConstantIntValue;
  char v69;
  int v70;
  _QWORD *v71;
  _QWORD *v72;
  void *v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v78;
  unint64_t v79;
  BOOL v80;
  unint64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  mlir::MLIRContext *Context;
  unint64_t v86;
  llvm *DenseI64ArrayAttr;
  const char *v88;
  uint64_t v89;
  __int16 v90;
  uint64_t *v91;
  void *v92;
  uint64_t v93;
  void *v94;
  unsigned int v95;
  unsigned int v96;
  _BYTE v97[96];
  void *v98;
  _QWORD *v99;
  void *__p;
  _QWORD *v101;
  char v102;
  const void **v103;
  unsigned int v104;
  uint64_t v105;
  __int16 v106;
  uint64_t v107;

  v107 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v91 = *this;
  mlir::tensor::PackOp::getMixedTiles((mlir::tensor::PackOp *)&v91, (uint64_t)&v103);
  if (v104)
  {
    v3 = (uint64_t *)v103;
    v4 = 8 * v104;
    while (!mlir::isConstantIntValue(*v3, 0))
    {
      ++v3;
      v4 -= 8;
      if (!v4)
        goto LABEL_5;
    }
    DenseI64ArrayAttr = (llvm *)"invalid zero tile factor";
    v90 = 259;
    mlir::Operation::emitError(v2, (uint64_t)&DenseI64ArrayAttr, (uint64_t)&v92);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v92);
    if (v92)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v92);
    if (v102)
    {
      v12 = __p;
      if (__p)
      {
        v13 = v101;
        v14 = __p;
        if (v101 != __p)
        {
          do
            v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          v14 = __p;
        }
        v101 = v12;
        operator delete(v14);
      }
      v15 = v98;
      if (!v98)
        goto LABEL_53;
      v16 = v99;
      v17 = v98;
      if (v99 == v98)
        goto LABEL_52;
      do
      {
        v19 = *--v16;
        v18 = v19;
        *v16 = 0;
        if (v19)
          MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
      }
      while (v16 != v15);
      goto LABEL_51;
    }
    goto LABEL_55;
  }
LABEL_5:
  v86 = *(_QWORD *)(*(_QWORD *)(v2[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v86);
  v6 = v5;
  v92 = (void *)v2[2 * (((unint64_t)*((unsigned int *)v2 + 11) >> 23) & 1) + 8];
  v7 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v92);
  v9 = v8;
  if (HIBYTE(*((_DWORD *)v2 + 11)))
    v10 = (unint64_t)&v2[2 * (((unint64_t)*((unsigned int *)v2 + 11) >> 23) & 1) + 8];
  else
    v10 = 0;
  v92 = *(void **)(v10 + 8);
  if (!v92)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v2 + 3));
    DenseI64ArrayAttr = (llvm *)mlir::Builder::getDenseI64ArrayAttr(&Context, 0, 0);
    mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&DenseI64ArrayAttr);
    if (v9 > v6)
      goto LABEL_36;
LABEL_26:
    DenseI64ArrayAttr = 0;
    v88 = 0;
    LODWORD(v89) = 0;
    if (v9)
    {
      v20 = 8 * v9;
      v21 = 8 * v9;
      v22 = (mlir::MLIRContext **)v7;
      do
      {
        v23 = *v22++;
        Context = v23;
        llvm::DenseMapBase<llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::try_emplace<llvm::detail::DenseSetEmpty&>((uint64_t)&DenseI64ArrayAttr, (uint64_t *)&Context, (uint64_t)&v92);
        v21 -= 8;
      }
      while (v21);
      if (v9 == v88)
      {
        for (i = (_QWORD *)v7; (*i & 0x8000000000000000) == 0 && *i < (int64_t)v6; ++i)
        {
          v20 -= 8;
          if (!v20)
            llvm::deallocate_buffer(DenseI64ArrayAttr, (void *)(8 * v89));
        }
      }
      llvm::deallocate_buffer(DenseI64ArrayAttr, (void *)(8 * v89));
    }
    llvm::deallocate_buffer(0, 0);
  }
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v92);
  if (v9 <= v6)
    goto LABEL_26;
LABEL_36:
  DenseI64ArrayAttr = (llvm *)"invalid inner_dims_pos vector";
  v90 = 259;
  mlir::Operation::emitError(v2, (uint64_t)&DenseI64ArrayAttr, (uint64_t)&v92);
  v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v92);
  if (v92)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v92);
  if (v102)
  {
    v25 = __p;
    if (__p)
    {
      v26 = v101;
      v27 = __p;
      if (v101 != __p)
      {
        do
          v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        v27 = __p;
      }
      v101 = v25;
      operator delete(v27);
    }
    v15 = v98;
    if (!v98)
      goto LABEL_53;
    v28 = v99;
    v17 = v98;
    if (v99 == v98)
    {
LABEL_52:
      v99 = v15;
      operator delete(v17);
LABEL_53:
      if (v94 != v97)
        free(v94);
      goto LABEL_55;
    }
    do
    {
      v30 = *--v28;
      v29 = v30;
      *v28 = 0;
      if (v30)
        MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
    }
    while (v28 != v15);
LABEL_51:
    v17 = v98;
    goto LABEL_52;
  }
LABEL_55:
  if (v103 != (const void **)&v105)
    free(v103);
  if (!v11)
    return 0;
  v31 = *this;
  v32 = *((unsigned int *)*this + 11);
  v33 = &(*this)[2 * ((v32 >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v33 = 0;
  v34 = *((_DWORD *)v33 + 8);
  if ((v32 & 0x800000) != 0)
  {
    v35 = v31[9];
    if (!v34)
      goto LABEL_87;
  }
  else
  {
    v35 = 0;
    if (!v34)
      goto LABEL_87;
  }
  v36 = *(_QWORD *)(v35 + 32 * (*((_DWORD *)v33 + 7) + *((_DWORD *)v33 + 6)) + 24);
  if (v36)
  {
    v37 = *(_QWORD *)(v36 + 8) & 0xFFFFFFFFFFFFFFF8;
    v92 = (void *)(*(_QWORD *)(*(_QWORD *)(v31[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v37 != mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v92))
    {
      v103 = (const void **)"expected padding_value has ";
      v106 = 259;
      mlir::OpState::emitOpError(this, &v103, (uint64_t)&v92);
      Context = (mlir::MLIRContext *)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
      RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&Context);
      if (v92)
      {
        p_DenseI64ArrayAttr = &DenseI64ArrayAttr;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&DenseI64ArrayAttr, RHS);
        v40 = (char *)v94;
        if (v95 >= v96)
        {
          v78 = v95 + 1;
          if (v94 <= &DenseI64ArrayAttr && (char *)v94 + 24 * v95 > (char *)&DenseI64ArrayAttr)
          {
            v82 = (char *)&DenseI64ArrayAttr - (_BYTE *)v94;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v94, v97, v78, 24);
            v40 = (char *)v94;
            p_DenseI64ArrayAttr = (llvm **)((char *)v94 + v82);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v94, v97, v78, 24);
            p_DenseI64ArrayAttr = &DenseI64ArrayAttr;
            v40 = (char *)v94;
          }
        }
        v41 = &v40[24 * v95];
        v42 = *(_OWORD *)p_DenseI64ArrayAttr;
        *((_QWORD *)v41 + 2) = p_DenseI64ArrayAttr[2];
        *(_OWORD *)v41 = v42;
        v43 = ++v95;
        if (v92)
        {
          LODWORD(DenseI64ArrayAttr) = 3;
          v88 = " but got: ";
          v89 = 10;
          v44 = &DenseI64ArrayAttr;
          v45 = (char *)v94;
          if (v43 >= v96)
          {
            v79 = v43 + 1;
            v80 = (char *)v94 + 24 * v43 > (char *)&DenseI64ArrayAttr;
            if (v94 <= &DenseI64ArrayAttr && v80)
            {
              v83 = (char *)&DenseI64ArrayAttr - (_BYTE *)v94;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v94, v97, v79, 24);
              v45 = (char *)v94;
              v44 = (llvm **)((char *)v94 + v83);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v94, v97, v79, 24);
              v44 = &DenseI64ArrayAttr;
              v45 = (char *)v94;
            }
          }
          v46 = &v45[24 * v95];
          v47 = *(_OWORD *)v44;
          *((_QWORD *)v46 + 2) = v44[2];
          *(_OWORD *)v46 = v47;
          ++v95;
          if (v92)
          {
            v48 = *(_QWORD *)(v36 + 8) & 0xFFFFFFFFFFFFFFF8;
            v49 = &DenseI64ArrayAttr;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&DenseI64ArrayAttr, v48);
            v50 = (char *)v94;
            if (v95 >= v96)
            {
              v81 = v95 + 1;
              if (v94 <= &DenseI64ArrayAttr && (char *)v94 + 24 * v95 > (char *)&DenseI64ArrayAttr)
              {
                v84 = (char *)&DenseI64ArrayAttr - (_BYTE *)v94;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v94, v97, v81, 24);
                v50 = (char *)v94;
                v49 = (llvm **)((char *)v94 + v84);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v94, v97, v81, 24);
                v49 = &DenseI64ArrayAttr;
                v50 = (char *)v94;
              }
            }
            v51 = &v50[24 * v95];
            v52 = *(_OWORD *)v49;
            *((_QWORD *)v51 + 2) = v49[2];
            *(_OWORD *)v51 = v52;
            ++v95;
          }
        }
      }
      v53 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v92);
      if (v92)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v92);
      if (v102)
      {
        v54 = __p;
        if (__p)
        {
          v55 = v101;
          v56 = __p;
          if (v101 != __p)
          {
            do
              v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
            while (v55 != v54);
            v56 = __p;
          }
          v101 = v54;
          operator delete(v56);
        }
        v57 = v98;
        if (!v98)
          goto LABEL_117;
        v58 = v99;
        v59 = v98;
        if (v99 == v98)
        {
LABEL_116:
          v99 = v57;
          operator delete(v59);
LABEL_117:
          if (v94 != v97)
            free(v94);
          return v53;
        }
        do
        {
          v61 = *--v58;
          v60 = v61;
          *v58 = 0;
          if (v61)
            MEMORY[0x20BD002D4](v60, 0x1000C8077774924);
        }
        while (v58 != v57);
LABEL_115:
        v59 = v98;
        goto LABEL_116;
      }
      return v53;
    }
    return 1;
  }
LABEL_87:
  v103 = (const void **)(*(_QWORD *)(*(_QWORD *)(v31[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v103);
  v92 = (void *)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v63 = (_QWORD *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v92);
  v65 = v64;
  mlir::tensor::PackOp::getMixedTiles((mlir::tensor::PackOp *)this, (uint64_t)&v92);
  v66 = (uint64_t *)v92;
  if (v65)
  {
    v67 = 8 * v65;
    do
    {
      if (*(_QWORD *)(Value + 8 * *v63) != 0x8000000000000000)
      {
        ConstantIntValue = mlir::getConstantIntValue(*v66);
        if (v69)
        {
          if (*(_QWORD *)(Value + 8 * *v63) % ConstantIntValue)
          {
            v70 = 1;
            v66 = (uint64_t *)v92;
            if (v92 != &v93)
              goto LABEL_96;
            goto LABEL_97;
          }
        }
      }
      ++v63;
      ++v66;
      v67 -= 8;
    }
    while (v67);
    v70 = 0;
    v66 = (uint64_t *)v92;
    if (v92 == &v93)
      goto LABEL_97;
    goto LABEL_96;
  }
  v70 = 0;
  if (v92 != &v93)
LABEL_96:
    free(v66);
LABEL_97:
  if (!v70)
    return 1;
  v103 = (const void **)"invalid tile factor provided. Only full tiles are supported when padding_value is not set";
  v106 = 259;
  mlir::OpState::emitOpError(this, &v103, (uint64_t)&v92);
  v53 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v92);
  if (v92)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v92);
  if (v102)
  {
    v71 = __p;
    if (__p)
    {
      v72 = v101;
      v73 = __p;
      if (v101 != __p)
      {
        do
          v72 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v72 - 1);
        while (v72 != v71);
        v73 = __p;
      }
      v101 = v71;
      operator delete(v73);
    }
    v57 = v98;
    if (!v98)
      goto LABEL_117;
    v74 = v99;
    v59 = v98;
    if (v99 == v98)
      goto LABEL_116;
    do
    {
      v76 = *--v74;
      v75 = v76;
      *v74 = 0;
      if (v76)
        MEMORY[0x20BD002D4](v75, 0x1000C8077774924);
    }
    while (v74 != v57);
    goto LABEL_115;
  }
  return v53;
}

void getPackOpResultTypeShape(uint64_t a1, const void *a2, unint64_t a3, uint64_t *a4, uint64_t a5, _QWORD *a6, uint64_t a7, uint64_t a8, uint64_t *a9, uint64_t a10)
{
  void *v17;
  size_t v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  uint64_t v29;
  unint64_t v30;

  v17 = (void *)(a1 + 16);
  *(_QWORD *)a1 = a1 + 16;
  *(_QWORD *)(a1 + 8) = 0x600000000;
  v18 = 8 * a3;
  if (8 * a3 < 0x31)
  {
    v19 = 0;
    v20 = a10;
    if (!a3)
      goto LABEL_6;
    goto LABEL_5;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), a3, 8);
  v19 = *(_DWORD *)(a1 + 8);
  v20 = a10;
  if (a3)
  {
LABEL_5:
    memcpy((void *)(*(_QWORD *)a1 + 8 * v19), a2, v18);
    v19 = *(_DWORD *)(a1 + 8);
  }
LABEL_6:
  v21 = v19 + a3;
  *(_DWORD *)(a1 + 8) = v21;
  if (a7)
  {
    v22 = *(_QWORD *)a1;
    v23 = 8 * a7;
    v24 = a4;
    do
    {
      v26 = *(_QWORD *)(v22 + 8 * *a6);
      if (v26 != 0x8000000000000000)
      {
        v27 = *v24;
        v25 = 0x8000000000000000;
        if (*v24 != 0x8000000000000000)
        {
          if (v26)
            v28 = v26 < 1 == v27 > 0;
          else
            v28 = 1;
          if (v28)
          {
            v25 = v26 / v27;
          }
          else
          {
            if (v27 <= 0)
              v29 = v26 + 1;
            else
              v29 = v26 - 1;
            v25 = v29 / v27 + 1;
          }
        }
        *(_QWORD *)(v22 + 8 * *a6) = v25;
      }
      ++a6;
      ++v24;
      v23 -= 8;
    }
    while (v23);
  }
  if (v20)
  {
    mlir::applyPermutationToVector<long long,6u>(a1, a9);
    v21 = *(_DWORD *)(a1 + 8);
  }
  v30 = ((8 * a5) >> 3) + v21;
  if (v30 > *(unsigned int *)(a1 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, v17, v30, 8);
    v21 = *(_DWORD *)(a1 + 8);
  }
  if (a5)
  {
    memcpy((void *)(*(_QWORD *)a1 + 8 * v21), a4, 8 * a5);
    v21 = *(_DWORD *)(a1 + 8);
  }
  *(_DWORD *)(a1 + 8) = v21 + a5;
}

uint64_t mlir::tensor::PackOp::inferPackedType(uint64_t a1, uint64_t *a2, uint64_t a3, _QWORD *a4, uint64_t a5, uint64_t *a6, uint64_t a7)
{
  const void *Value;
  unint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t RHS;
  uint64_t v19;
  uint64_t v21;
  void *v22;
  unsigned int v23;
  _QWORD v24[7];

  v24[6] = *MEMORY[0x24BDAC8D0];
  v21 = a1;
  Value = (const void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v21);
  getPackOpResultTypeShape((uint64_t)&v22, Value, v14, a2, a3, a4, a5, v15, a6, a7);
  v16 = v22;
  v17 = v23;
  RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v21);
  v19 = mlir::RankedTensorType::get((uint64_t)v16, v17, RHS, 0);
  if (v22 != v24)
    free(v22);
  return v19;
}

uint64_t mlir::tensor::PackOp::getSpeculatability(mlir::tensor::PackOp *this)
{
  uint64_t v1;
  unint64_t v2;
  _DWORD *v3;
  int v4;
  uint64_t v5;

  v1 = *(_QWORD *)this;
  v2 = *(unsigned int *)(v1 + 44);
  v3 = (_DWORD *)(v1 + 16 * ((v2 >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(v1 + 44)))
    v3 = 0;
  v4 = v3[8];
  if ((v2 & 0x800000) != 0)
  {
    v5 = *(_QWORD *)(v1 + 72);
    if (!v4)
      return areTilesAndTiledDimsAllConstant<mlir::tensor::PackOp>(v1);
  }
  else
  {
    v5 = 0;
    if (!v4)
      return areTilesAndTiledDimsAllConstant<mlir::tensor::PackOp>(v1);
  }
  if (*(_QWORD *)(v5 + 32 * (v3[7] + v3[6]) + 24))
    return 1;
  return areTilesAndTiledDimsAllConstant<mlir::tensor::PackOp>(v1);
}

uint64_t areTilesAndTiledDimsAllConstant<mlir::tensor::PackOp>(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t Shape;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  _QWORD v16[2];
  uint64_t v17;
  void *v18;
  unsigned int v19;
  _QWORD v20[7];

  v20[6] = *MEMORY[0x24BDAC8D0];
  v17 = a1;
  if (*(_BYTE *)(a1 + 47))
    v1 = a1 + 80;
  else
    v1 = 0;
  v2 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 32 * *(unsigned int *)(v1 + 24) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v2)
    v3 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v2 + 8);
  else
    v3 = 0;
  v16[0] = v2;
  v16[1] = v3;
  mlir::tensor::PackOp::getMixedTiles((mlir::tensor::PackOp *)&v17, (uint64_t)&v18);
  Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v16);
  if (v5 <= v19)
    v6 = (_QWORD *)Shape;
  else
    v6 = (_QWORD *)(Shape + 8 * (v5 - v19));
  if (v5 >= v19)
    v7 = v19;
  else
    v7 = v5;
  v8 = v18;
  if (v7)
    v9 = v19 == 0;
  else
    v9 = 1;
  if (v9)
  {
    v12 = 1;
    if (v18 != v20)
LABEL_27:
      free(v8);
  }
  else
  {
    v10 = 8 * v19 - 8;
    v11 = 8 * v7 - 8;
    v12 = 1;
    while (1)
    {
      mlir::getConstantIntValue(*v8);
      if (!v13)
      {
        v12 = 0;
LABEL_26:
        v8 = v18;
        if (v18 == v20)
          return v12;
        goto LABEL_27;
      }
      if (*v6 == 0x8000000000000000)
        break;
      if (v11)
      {
        ++v6;
        ++v8;
        v14 = v10;
        v10 -= 8;
        v11 -= 8;
        if (v14)
          continue;
      }
      goto LABEL_26;
    }
    v12 = 0;
    v8 = v18;
    if (v18 != v20)
      goto LABEL_27;
  }
  return v12;
}

uint64_t mlir::tensor::PackOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t DefiningOp;
  uint64_t v5;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
  v5 = DefiningOp;
  if (!DefiningOp)
    return v5;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::tensor::UnPackOp,void>::id)
    return 0;
  if (*(_BYTE *)(a1 + 47))
    v7 = (unsigned int *)(a1 + 80);
  else
    v7 = 0;
  v8 = v7[6];
  v9 = *(_QWORD *)(a1 + 72);
  if ((*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) != (*(_QWORD *)(*(_QWORD *)(v9 + 32 * v8 + 24) + 8) & 0xFFFFFFFFFFFFFFF8)
    || v7[8] && *(_QWORD *)(v9 + 32 * (v8 + v7[7]) + 24)
    || !hasSameInnerOuterAttribute(a1, DefiningOp)
    || !haveSameTiles(a1, v5))
  {
    return 0;
  }
  v10 = *(_QWORD *)(*(_QWORD *)(v5 + 72) + 24);
  (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(_QWORD *)a2 + 24))(a2, a1, &v10, 1);
  return 1;
}

BOOL hasSameInnerOuterAttribute(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  const void *v5;
  uint64_t v6;
  uint64_t v7;
  const void *v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t *p_DenseI64ArrayAttr;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  const void *v17;
  uint64_t v18;
  uint64_t v19;
  mlir::MLIRContext *Context;
  uint64_t DenseI64ArrayAttr;
  uint64_t v22;

  v4 = a1 + 64;
  v22 = *(_QWORD *)(a1 + 64 + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1));
  v5 = (const void *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v22);
  v7 = v6;
  v22 = *(_QWORD *)(a2 + 64 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1));
  v8 = (const void *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v22);
  if (v7 != v9 || memcmp(v5, v8, 8 * v7))
    return 0;
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v11 = v4 + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1);
  else
    v11 = 0;
  v22 = *(_QWORD *)(v11 + 8);
  if (v22)
  {
    p_DenseI64ArrayAttr = &v22;
  }
  else
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
    DenseI64ArrayAttr = mlir::Builder::getDenseI64ArrayAttr(&Context, 0, 0);
    p_DenseI64ArrayAttr = &DenseI64ArrayAttr;
  }
  v13 = (const void *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)p_DenseI64ArrayAttr);
  v15 = v14;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v16 = a2 + 64 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1);
  else
    v16 = 0;
  v22 = *(_QWORD *)(v16 + 8);
  if (v22)
  {
    v17 = (const void *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v22);
    if (v15 == v18)
      return memcmp(v13, v17, 8 * v15) == 0;
    return 0;
  }
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  DenseI64ArrayAttr = mlir::Builder::getDenseI64ArrayAttr(&Context, 0, 0);
  v17 = (const void *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&DenseI64ArrayAttr);
  if (v15 != v19)
    return 0;
  return memcmp(v13, v17, 8 * v15) == 0;
}

BOOL haveSameTiles(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  char isEqualConstantIntOrValue;
  _BOOL8 v6;
  void *v7;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  int v12;
  _BYTE v13[48];
  void *v14;
  unsigned int v15;
  _QWORD v16[7];

  v16[6] = *MEMORY[0x24BDAC8D0];
  v9 = a2;
  v10 = a1;
  mlir::tensor::PackOp::getMixedTiles((mlir::tensor::PackOp *)&v10, (uint64_t)&v14);
  mlir::tensor::UnPackOp::getMixedTiles((mlir::tensor::UnPackOp *)&v9, (uint64_t)&v11);
  v2 = v15;
  if (v15 != v12)
    goto LABEL_9;
  if (v15)
  {
    if (mlir::isEqualConstantIntOrValue(*(_QWORD *)v14, *(_QWORD *)v11))
    {
      v3 = 1;
      do
      {
        v4 = v3;
        if (v2 == v3)
          break;
        isEqualConstantIntOrValue = mlir::isEqualConstantIntOrValue(*((_QWORD *)v14 + v3), *((_QWORD *)v11 + v3));
        v3 = v4 + 1;
      }
      while ((isEqualConstantIntOrValue & 1) != 0);
      v6 = v4 >= v2;
      v7 = v11;
      if (v11 == v13)
        goto LABEL_11;
      goto LABEL_10;
    }
LABEL_9:
    v6 = 0;
    v7 = v11;
    if (v11 == v13)
      goto LABEL_11;
    goto LABEL_10;
  }
  v6 = 1;
  v7 = v11;
  if (v11 != v13)
LABEL_10:
    free(v7);
LABEL_11:
  if (v14 != v16)
    free(v14);
  return v6;
}

unint64_t mlir::tensor::PackOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t NextResultAtOffset;
  unint64_t result;

  v3 = *(uint64_t **)(a2 + 80);
  v4 = *v3;
  if (*v3 && !mlir::DenseElementsAttr::classof(*v3))
    v4 = 0;
  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v5 = *(_QWORD *)a1 - 16;
  else
    v5 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  result = reshapeConstantSource(v4, (_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
  if (result <= 7)
    return 0;
  return result;
}

uint64_t mlir::tensor::UnPackOp::getAsmResultNames(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v4;
  uint64_t NextResultAtOffset;

  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v4 = *(_QWORD *)a1 - 16;
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return a2(a3, NextResultAtOffset, "unpack", 6);
}

uint64_t mlir::tensor::UnPackOp::reifyResultShapes(uint64_t *a1, mlir::IndexType **a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  mlir::MLIRContext *i;
  unint64_t MixedSize;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v28;
  void *v29;
  uint64_t v30;
  _QWORD v31[7];

  v31[6] = *MEMORY[0x24BDAC8D0];
  v5 = *a1;
  v29 = (void *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a1 + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v29);
  v29 = v31;
  v30 = 0x600000000;
  if (v6)
  {
    v7 = v6;
    if (v6 < 7)
    {
      v8 = 0;
      v9 = v6;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v29, v31, v6, 8);
      v8 = v30;
      v9 = v7 - v30;
      if (v7 == v30)
        goto LABEL_7;
    }
    bzero((char *)v29 + 8 * v8, 8 * v9);
LABEL_7:
    LODWORD(v30) = v7;
  }
  v10 = *(unsigned int *)(a3 + 8);
  if (!(_DWORD)v10)
  {
    llvm::SmallVectorImpl<llvm::SmallVector<mlir::OpFoldResult,6u>>::append(a3, 1 - v10, (unint64_t)&v29);
LABEL_15:
    v14 = v29;
    if (v29 == v31)
      goto LABEL_17;
    goto LABEL_16;
  }
  if ((_DWORD)v10 == 1)
    goto LABEL_15;
  v11 = *(_QWORD *)a3;
  v12 = v10 << 6;
  do
  {
    v13 = *(void **)(v11 + v12 - 64);
    if ((void *)(v11 + v12 - 48) != v13)
      free(v13);
    v12 -= 64;
  }
  while (v12 != 64);
  *(_DWORD *)(a3 + 8) = 1;
  v14 = v29;
  if (v29 != v31)
LABEL_16:
    free(v14);
LABEL_17:
  v15 = *(_QWORD *)(v5 + 24);
  v16 = *(_QWORD *)(*(_QWORD *)(v5 + 72) + 56);
  v28 = *(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8;
  v29 = v31;
  v30 = 0x600000000;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v28);
  if (v17 >= 1)
  {
    for (i = 0; (uint64_t)i < v21; i = (mlir::MLIRContext *)((char *)i + 1))
    {
      MixedSize = mlir::tensor::getMixedSize(a2, v15, v16, i);
      v20 = v30;
      if (v30 >= (unint64_t)HIDWORD(v30))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v29, v31, v30 + 1, 8);
        v20 = v30;
      }
      *((_QWORD *)v29 + v20) = MixedSize;
      LODWORD(v30) = v30 + 1;
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v28);
    }
  }
  v22 = *(_QWORD *)a3;
  v23 = v29;
  if ((void **)v22 != &v29)
  {
    if (v29 != v31)
    {
      if (*(_QWORD *)v22 != v22 + 16)
      {
        free(*(void **)v22);
        v23 = v29;
      }
      *(_QWORD *)v22 = v23;
      *(_QWORD *)(v22 + 8) = v30;
      v29 = v31;
      HIDWORD(v30) = 0;
      goto LABEL_39;
    }
    v24 = v30;
    v25 = *(unsigned int *)(v22 + 8);
    if (v25 >= v30)
    {
      if ((_DWORD)v30)
        memmove(*(void **)v22, v31, 8 * v30);
      goto LABEL_38;
    }
    if (*(_DWORD *)(v22 + 12) >= v30)
    {
      if ((_DWORD)v25)
      {
        memmove(*(void **)v22, v31, 8 * v25);
        v26 = v30;
        if (v25 == v30)
        {
LABEL_38:
          *(_DWORD *)(v22 + 8) = v24;
LABEL_39:
          LODWORD(v30) = 0;
          v23 = v29;
          goto LABEL_40;
        }
      }
      else
      {
        v25 = 0;
        v26 = v30;
        if (!(_DWORD)v30)
          goto LABEL_38;
      }
    }
    else
    {
      *(_DWORD *)(v22 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v22, (void *)(v22 + 16), v24, 8);
      v25 = 0;
      v26 = v30;
      if (!(_DWORD)v30)
        goto LABEL_38;
    }
    memcpy((void *)(*(_QWORD *)v22 + 8 * v25), (char *)v29 + 8 * v25, 8 * v26 - 8 * v25);
    goto LABEL_38;
  }
LABEL_40:
  if (v23 != v31)
    free(v23);
  return 1;
}

void mlir::tensor::UnPackOp::getMixedTiles(mlir::tensor::UnPackOp *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t Context;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v3 = *(_QWORD *)this;
  Context = mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)this + 24));
  *(_QWORD *)a2 = a2 + 16;
  *(_QWORD *)(a2 + 8) = 0x600000000;
  if (HIBYTE(*(_DWORD *)(v3 + 44)))
    v5 = v3 + 16 * (((unint64_t)*(unsigned int *)(v3 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = *(_QWORD *)(v5 + 16);
  v15 = Context;
  v16 = v6;
  v7 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v16);
  if (v8)
  {
    v9 = (uint64_t *)v7;
    v10 = 0;
    v11 = 8 * v8;
    do
    {
      if (*v9 == 0x8000000000000000)
      {
        v12 = *(_QWORD *)(v3 + 72) + 32 * v10++;
        v13 = *(_QWORD *)(v12 + 88) | 4;
      }
      else
      {
        v13 = mlir::Builder::getI64IntegerAttr((mlir::Builder *)&v15, *v9) & 0xFFFFFFFFFFFFFFFBLL;
      }
      v14 = *(unsigned int *)(a2 + 8);
      if (v14 >= *(unsigned int *)(a2 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v14 + 1, 8);
        v14 = *(unsigned int *)(a2 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a2 + 8 * v14) = v13;
      ++*(_DWORD *)(a2 + 8);
      ++v9;
      v11 -= 8;
    }
    while (v11);
  }
}

uint64_t mlir::tensor::UnPackOp::verify(mlir::tensor::UnPackOp *this)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void **v21;
  void *v22;
  _QWORD *i;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v31;
  uint64_t v32;
  void *Context;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  _QWORD *v38;
  void *__p;
  _QWORD *v40;
  char v41;
  uint64_t *v42;
  unsigned int v43;
  uint64_t v44;
  llvm *DenseI64ArrayAttr;
  uint64_t v46;
  unsigned int v47;
  __int16 v48;
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)this;
  v32 = *(_QWORD *)this;
  mlir::tensor::UnPackOp::getMixedTiles((mlir::tensor::UnPackOp *)&v32, (uint64_t)&v42);
  if (v43)
  {
    v2 = v42;
    v3 = 8 * v43;
    while (!mlir::isConstantIntValue(*v2, 0))
    {
      ++v2;
      v3 -= 8;
      if (!v3)
        goto LABEL_5;
    }
    DenseI64ArrayAttr = (llvm *)"invalid zero tile factor";
    v48 = 259;
    mlir::Operation::emitError((uint64_t *)v1, (uint64_t)&DenseI64ArrayAttr, (uint64_t)&v34);
    v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v34);
    if (v34)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v34);
    if (v41)
    {
      v11 = __p;
      if (__p)
      {
        v12 = v40;
        v13 = __p;
        if (v40 != __p)
        {
          do
            v12 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v12 - 1);
          while (v12 != v11);
          v13 = __p;
        }
        v40 = v11;
        operator delete(v13);
      }
      v14 = v37;
      if (!v37)
        goto LABEL_53;
      v15 = v38;
      v16 = v37;
      if (v38 == v37)
        goto LABEL_52;
      do
      {
        v18 = *--v15;
        v17 = v18;
        *v15 = 0;
        if (v18)
          MEMORY[0x20BD002D4](v17, 0x1000C8077774924);
      }
      while (v15 != v14);
      goto LABEL_51;
    }
    goto LABEL_55;
  }
LABEL_5:
  v31 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v31);
  v5 = v4;
  v34 = *(void **)(v1 + 64 + 16 * (((unint64_t)*(unsigned int *)(v1 + 44) >> 23) & 1));
  v6 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v34);
  v8 = v7;
  if (HIBYTE(*(_DWORD *)(v1 + 44)))
    v9 = v1 + 64 + 16 * (((unint64_t)*(unsigned int *)(v1 + 44) >> 23) & 1);
  else
    v9 = 0;
  v34 = *(void **)(v9 + 8);
  if (!v34)
  {
    Context = (void *)mlir::Attribute::getContext((mlir::Attribute *)(v1 + 24));
    DenseI64ArrayAttr = (llvm *)mlir::Builder::getDenseI64ArrayAttr((mlir::MLIRContext **)&Context, 0, 0);
    mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&DenseI64ArrayAttr);
    if (v8 > v5)
      goto LABEL_36;
LABEL_26:
    DenseI64ArrayAttr = 0;
    v46 = 0;
    v47 = 0;
    if (v8)
    {
      v19 = 8 * v8;
      v20 = 8 * v8;
      v21 = (void **)v6;
      do
      {
        v22 = *v21++;
        Context = v22;
        llvm::DenseMapBase<llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::try_emplace<llvm::detail::DenseSetEmpty&>((uint64_t)&DenseI64ArrayAttr, (uint64_t *)&Context, (uint64_t)&v34);
        v20 -= 8;
      }
      while (v20);
      if (v8 == v46)
      {
        for (i = (_QWORD *)v6; (*i & 0x8000000000000000) == 0 && *i < (int64_t)v5; ++i)
        {
          v19 -= 8;
          if (!v19)
            llvm::deallocate_buffer(DenseI64ArrayAttr, (void *)(8 * v47));
        }
      }
      llvm::deallocate_buffer(DenseI64ArrayAttr, (void *)(8 * v47));
    }
    llvm::deallocate_buffer(0, 0);
  }
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v34);
  if (v8 <= v5)
    goto LABEL_26;
LABEL_36:
  DenseI64ArrayAttr = (llvm *)"invalid inner_dims_pos vector";
  v48 = 259;
  mlir::Operation::emitError((uint64_t *)v1, (uint64_t)&DenseI64ArrayAttr, (uint64_t)&v34);
  v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v34);
  if (v34)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v34);
  if (v41)
  {
    v24 = __p;
    if (__p)
    {
      v25 = v40;
      v26 = __p;
      if (v40 != __p)
      {
        do
          v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        v26 = __p;
      }
      v40 = v24;
      operator delete(v26);
    }
    v14 = v37;
    if (!v37)
      goto LABEL_53;
    v27 = v38;
    v16 = v37;
    if (v38 == v37)
    {
LABEL_52:
      v38 = v14;
      operator delete(v16);
LABEL_53:
      if (v35 != &v36)
        free(v35);
      goto LABEL_55;
    }
    do
    {
      v29 = *--v27;
      v28 = v29;
      *v27 = 0;
      if (v29)
        MEMORY[0x20BD002D4](v28, 0x1000C8077774924);
    }
    while (v27 != v14);
LABEL_51:
    v16 = v37;
    goto LABEL_52;
  }
LABEL_55:
  if (v42 != &v44)
    free(v42);
  return v10;
}

uint64_t mlir::tensor::UnPackOp::getSpeculatability(mlir::tensor::UnPackOp *this)
{
  return areTilesAndTiledDimsAllConstant<mlir::tensor::UnPackOp>(*(_QWORD *)this);
}

uint64_t areTilesAndTiledDimsAllConstant<mlir::tensor::UnPackOp>(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t Shape;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  _QWORD *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  _QWORD v15[2];
  uint64_t v16;
  void *v17;
  unsigned int v18;
  _QWORD v19[7];

  v19[6] = *MEMORY[0x24BDAC8D0];
  v16 = a1;
  v1 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v1)
    v2 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v1 + 8);
  else
    v2 = 0;
  v15[0] = v1;
  v15[1] = v2;
  mlir::tensor::UnPackOp::getMixedTiles((mlir::tensor::UnPackOp *)&v16, (uint64_t)&v17);
  Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v15);
  if (v4 <= v18)
    v5 = (_QWORD *)Shape;
  else
    v5 = (_QWORD *)(Shape + 8 * (v4 - v18));
  if (v4 >= v18)
    v6 = v18;
  else
    v6 = v4;
  v7 = v17;
  if (v6)
    v8 = v18 == 0;
  else
    v8 = 1;
  if (v8)
  {
    v11 = 1;
    if (v17 != v19)
LABEL_24:
      free(v7);
  }
  else
  {
    v9 = 8 * v18 - 8;
    v10 = 8 * v6 - 8;
    v11 = 1;
    while (1)
    {
      mlir::getConstantIntValue(*v7);
      if (!v12)
      {
        v11 = 0;
LABEL_23:
        v7 = v17;
        if (v17 == v19)
          return v11;
        goto LABEL_24;
      }
      if (*v5 == 0x8000000000000000)
        break;
      if (v10)
      {
        ++v5;
        ++v7;
        v13 = v9;
        v9 -= 8;
        v10 -= 8;
        if (v13)
          continue;
      }
      goto LABEL_23;
    }
    v11 = 0;
    v7 = v17;
    if (v17 != v19)
      goto LABEL_24;
  }
  return v11;
}

uint64_t mlir::tensor::UnPackOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t DefiningOp;
  uint64_t v5;
  uint64_t InterfaceFor;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  unsigned int *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24[2];
  void *v25;
  _QWORD v26[4];

  v26[3] = *MEMORY[0x24BDAC8D0];
  v24[0] = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v24);
  if (DefiningOp
    && (v5 = DefiningOp,
        *(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::PackOp,void>::id))
  {
    if (*(_BYTE *)(DefiningOp + 47))
      v18 = (unsigned int *)(DefiningOp + 80);
    else
      v18 = 0;
    v19 = v18[6];
    v20 = *(_QWORD *)(DefiningOp + 72);
    if ((*(_QWORD *)(*(_QWORD *)(v20 + 32 * v19 + 24) + 8) & 0xFFFFFFFFFFFFFFF8) == (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8)
      && (!v18[8] || !*(_QWORD *)(v20 + 32 * (v19 + v18[7]) + 24))
      && hasSameInnerOuterAttribute(DefiningOp, a1)
      && haveSameTiles(v5, a1))
    {
      v24[0] = *(_QWORD *)(*(_QWORD *)(v5 + 72) + 24);
      v7 = 1;
      (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(_QWORD *)a2 + 24))(a2, a1, v24, 1);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v24[0] = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 56);
    InterfaceFor = mlir::Value::getDefiningOp((mlir::Value *)v24);
    v7 = InterfaceFor;
    if (InterfaceFor)
    {
      if (!mlir::OpInterface<mlir::DestinationStyleOpInterface,mlir::detail::DestinationStyleOpInterfaceInterfaceTraits>::getInterfaceFor(InterfaceFor))
      {
        v7 = 0;
        v22 = 0;
        v23 = 0;
        return v7;
      }
      InterfaceFor = mlir::OpInterface<mlir::DestinationStyleOpInterface,mlir::detail::DestinationStyleOpInterfaceInterfaceTraits>::getInterfaceFor(v7);
    }
    v22 = v7;
    v23 = InterfaceFor;
    if (v7)
    {
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 56);
      mlir::DestinationStyleOpInterface::getDpsInitsMutable(v24, (mlir::DestinationStyleOpInterface *)&v22);
      v9 = mlir::MutableOperandRange::operator mlir::OperandRange((unsigned int *)v24);
      if (v25 != v26)
        free(v25);
      v10 = *(_QWORD *)(v8 + 8) & 7;
      if (v8 && v10 == 6)
        v10 = (*(_DWORD *)(v8 + 16) + 6);
      v11 = *(uint64_t **)(v9 + 32 * v10 + 24);
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 72))(a2, a1);
      mlir::MutableOperandRange::MutableOperandRange((mlir::MutableOperandRange *)v24, (mlir::OpOperand *)(*(_QWORD *)(a1 + 72) + 32));
      v12 = mlir::MutableOperandRange::operator mlir::OperandRange((unsigned int *)v24);
      v14 = v13;
      if (v25 != v26)
        free(v25);
      v24[0] = v12;
      v24[1] = v14;
      v15 = (uint64_t *)(*(_QWORD *)(a1 + 72)
                      + 32 * mlir::OperandRange::getBeginOperandIndex((mlir::OperandRange *)v24));
      v16 = (uint64_t *)v15[1];
      if (v16)
      {
        *v16 = *v15;
        if (*v15)
          *(_QWORD *)(*v15 + 8) = v15[1];
      }
      v15[3] = (uint64_t)v11;
      v15[1] = (uint64_t)v11;
      v17 = *v11;
      *v15 = *v11;
      if (v17)
        *(_QWORD *)(v17 + 8) = v15;
      *v11 = (uint64_t)v15;
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 80))(a2, a1);
      return 1;
    }
  }
  return v7;
}

unint64_t mlir::tensor::UnPackOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t NextResultAtOffset;
  unint64_t result;

  v3 = *(uint64_t **)(a2 + 64);
  v4 = *v3;
  if (*v3 && !mlir::DenseElementsAttr::classof(*v3))
    v4 = 0;
  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v5 = *(_QWORD *)a1 - 16;
  else
    v5 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  result = reshapeConstantSource(v4, (_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
  if (result <= 7)
    return 0;
  return result;
}

void mlir::tensor::TensorDialect::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 32);
  mlir::RewritePatternSet::addImpl<FoldTensorCastProducerOp,mlir::MLIRContext *>(a2, 0, 0, &v2);
}

BOOL mlir::tensor::BitcastOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::tensor::__mlir_ods_local_type_constraint_TensorOps0(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))return 0;
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::tensor::__mlir_ods_local_type_constraint_TensorOps0(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::tensor::__mlir_ods_local_type_constraint_TensorOps0(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v6;
  void *v7;
  uint64_t v9;
  int *v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  int *v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  int *v21;
  char *v22;
  char *v23;
  __int128 v24;
  int *v25;
  char *v26;
  char *v27;
  __int128 v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v38;
  unint64_t v39;
  BOOL v40;
  unint64_t v41;
  BOOL v42;
  unint64_t v43;
  int64_t v44;
  int64_t v45;
  int64_t v46;
  int64_t v47;
  const void **v48[4];
  __int16 v49;
  int v50;
  const char *v51;
  uint64_t v52;
  _QWORD v53[3];
  void *v54;
  unsigned int v55;
  unsigned int v56;
  _BYTE v57[96];
  void *v58;
  _QWORD *v59;
  void *__p;
  _QWORD *v61;
  char v62;
  uint64_t v63;

  v63 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)a2;
  v7 = *(void **)(*(_QWORD *)a2 + 136);
  if (v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v7 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v53[0] = a2;
    v53[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v6 + 8);
    mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v53);
    return 1;
  }
  else
  {
    v49 = 261;
    v48[0] = a3;
    v48[1] = a4;
    mlir::Operation::emitOpError(a1, v48, (uint64_t)v53);
    if (v53[0])
    {
      v50 = 3;
      v51 = " #";
      v52 = 2;
      v11 = &v50;
      v12 = (char *)v54;
      if (v55 >= v56)
      {
        v38 = v55 + 1;
        if (v54 <= &v50 && (char *)v54 + 24 * v55 > (char *)&v50)
        {
          v44 = (char *)&v50 - (_BYTE *)v54;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v38, 24);
          v12 = (char *)v54;
          v11 = (int *)((char *)v54 + v44);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v38, 24);
          v11 = &v50;
          v12 = (char *)v54;
        }
      }
      v13 = &v12[24 * v55];
      v14 = *(_OWORD *)v11;
      *((_QWORD *)v13 + 2) = *((_QWORD *)v11 + 2);
      *(_OWORD *)v13 = v14;
      v15 = ++v55;
      if (v53[0])
      {
        v50 = 5;
        v51 = (const char *)a5;
        v16 = &v50;
        v17 = (char *)v54;
        if (v15 >= v56)
        {
          v39 = v15 + 1;
          v40 = (char *)v54 + 24 * v15 > (char *)&v50;
          if (v54 <= &v50 && v40)
          {
            v45 = (char *)&v50 - (_BYTE *)v54;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v39, 24);
            v17 = (char *)v54;
            v16 = (int *)((char *)v54 + v45);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v39, 24);
            v16 = &v50;
            v17 = (char *)v54;
          }
        }
        v18 = &v17[24 * v55];
        v19 = *(_OWORD *)v16;
        *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
        *(_OWORD *)v18 = v19;
        v20 = ++v55;
        if (v53[0])
        {
          v50 = 3;
          v51 = " must be tensor of any type values, but got ";
          v52 = 44;
          v21 = &v50;
          v22 = (char *)v54;
          if (v20 >= v56)
          {
            v41 = v20 + 1;
            v42 = (char *)v54 + 24 * v20 > (char *)&v50;
            if (v54 <= &v50 && v42)
            {
              v46 = (char *)&v50 - (_BYTE *)v54;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v41, 24);
              v22 = (char *)v54;
              v21 = (int *)((char *)v54 + v46);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v41, 24);
              v21 = &v50;
              v22 = (char *)v54;
            }
          }
          v23 = &v22[24 * v55];
          v24 = *(_OWORD *)v21;
          *((_QWORD *)v23 + 2) = *((_QWORD *)v21 + 2);
          *(_OWORD *)v23 = v24;
          ++v55;
          if (v53[0])
          {
            v25 = &v50;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v50, a2);
            v26 = (char *)v54;
            if (v55 >= v56)
            {
              v43 = v55 + 1;
              if (v54 <= &v50 && (char *)v54 + 24 * v55 > (char *)&v50)
              {
                v47 = (char *)&v50 - (_BYTE *)v54;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v43, 24);
                v26 = (char *)v54;
                v25 = (int *)((char *)v54 + v47);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v43, 24);
                v25 = &v50;
                v26 = (char *)v54;
              }
            }
            v27 = &v26[24 * v55];
            v28 = *(_OWORD *)v25;
            *((_QWORD *)v27 + 2) = *((_QWORD *)v25 + 2);
            *(_OWORD *)v27 = v28;
            ++v55;
          }
        }
      }
    }
    v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v53);
    if (v53[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v53);
    if (v62)
    {
      v29 = __p;
      if (__p)
      {
        v30 = v61;
        v31 = __p;
        if (v61 != __p)
        {
          do
            v30 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v30 - 1);
          while (v30 != v29);
          v31 = __p;
        }
        v61 = v29;
        operator delete(v31);
      }
      v32 = v58;
      if (v58)
      {
        v33 = v59;
        v34 = v58;
        if (v59 != v58)
        {
          do
          {
            v36 = *--v33;
            v35 = v36;
            *v33 = 0;
            if (v36)
              MEMORY[0x20BD002D4](v35, 0x1000C8077774924);
          }
          while (v33 != v32);
          v34 = v58;
        }
        v59 = v32;
        operator delete(v34);
      }
      if (v54 != v57)
        free(v54);
    }
  }
  return v9;
}

BOOL mlir::tensor::BitcastOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v7[2];
  uint64_t v8[2];
  uint64_t v9;
  _QWORD v10[4];
  _QWORD __src[4];
  __int16 v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  memset(v10, 0, 24);
  v8[0] = (uint64_t)v10;
  v8[1] = 1;
  v9 = 0;
  v7[0] = &v9;
  v7[1] = 1;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v10, 1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  __src[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::TensorType>(a1, __src))
    return 0;
  v9 = __src[0];
  v12 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 368))(a1, "to", 2, __src))return 0;
  v6 = 0;
  if (!mlir::AsmParser::parseType<mlir::TensorType>(a1, &v6))
    return 0;
  __src[0] = v6;
  mlir::OperationState::addTypes(a2, __src, 1);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v8, v7, v4, a2 + 16) != 0;
}

BOOL mlir::tensor::CastOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v7[2];
  uint64_t v8[2];
  uint64_t v9;
  _QWORD v10[4];
  _QWORD __src[4];
  __int16 v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  memset(v10, 0, 24);
  v8[0] = (uint64_t)v10;
  v8[1] = 1;
  v9 = 0;
  v7[0] = &v9;
  v7[1] = 1;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v10, 1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  __src[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::TensorType>(a1, __src))
    return 0;
  v9 = __src[0];
  v12 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 368))(a1, "to", 2, __src))return 0;
  v6 = 0;
  if (!mlir::AsmParser::parseType<mlir::TensorType>(a1, &v6))
    return 0;
  __src[0] = v6;
  mlir::OperationState::addTypes(a2, __src, 1);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v8, v7, v4, a2 + 16) != 0;
}

uint64_t mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::CollapseShapeOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "tensor.collapse_shape", 21, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::tensor::CollapseShapeOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::ArrayAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  uint64_t *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::Properties]";
        v15 = 117;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v5[230];
    return a1[32];
  }
  return result;
}

BOOL mlir::tensor::CollapseShapeOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  const void **v16;
  __int16 v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD *v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v18[0] = v2;
    if (mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps4(v3, (const void **)"reassociation", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v18)&& mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))
    {
      if (*((_DWORD *)*this + 9))
        v4 = (uint64_t)(*this - 2);
      else
        v4 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
      return mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v16 = (const void **)"requires attribute 'reassociation'";
    v17 = 259;
    mlir::OpState::emitOpError(this, &v16, (uint64_t)v18);
    v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
    if (v18[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
    if (v25)
    {
      v7 = __p;
      if (__p)
      {
        v8 = v24;
        v9 = __p;
        if (v24 != __p)
        {
          do
            v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
          while (v8 != v7);
          v9 = __p;
        }
        v24 = v7;
        operator delete(v9);
      }
      v10 = v21;
      if (v21)
      {
        v11 = v22;
        v12 = v21;
        if (v22 != v21)
        {
          do
          {
            v14 = *--v11;
            v13 = v14;
            *v11 = 0;
            if (v14)
              MEMORY[0x20BD002D4](v13, 0x1000C8077774924);
          }
          while (v11 != v10);
          v12 = v21;
        }
        v22 = v10;
        operator delete(v12);
      }
      if (v19 != &v20)
        free(v19);
    }
  }
  return v6;
}

uint64_t mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v6;
  int *v8;
  char *v9;
  char *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  int *v22;
  char *v23;
  char *v24;
  __int128 v25;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v36;
  unint64_t v37;
  BOOL v38;
  unint64_t v39;
  BOOL v40;
  unint64_t v41;
  int64_t v42;
  int64_t v43;
  int64_t v44;
  int64_t v45;
  const void **v46[4];
  __int16 v47;
  int v48;
  const char *v49;
  uint64_t v50;
  _QWORD v51[3];
  void *v52;
  unsigned int v53;
  unsigned int v54;
  _BYTE v55[96];
  void *v56;
  _QWORD *v57;
  void *__p;
  _QWORD *v59;
  char v60;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)a2;
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v51[0] = a2;
    v51[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v6 + 8);
    mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v51);
    return 1;
  }
  else
  {
    v47 = 261;
    v46[0] = a3;
    v46[1] = a4;
    mlir::Operation::emitOpError(a1, v46, (uint64_t)v51);
    if (v51[0])
    {
      v48 = 3;
      v49 = " #";
      v50 = 2;
      v8 = &v48;
      v9 = (char *)v52;
      if (v53 >= v54)
      {
        v36 = v53 + 1;
        if (v52 <= &v48 && (char *)v52 + 24 * v53 > (char *)&v48)
        {
          v42 = (char *)&v48 - (_BYTE *)v52;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, v36, 24);
          v9 = (char *)v52;
          v8 = (int *)((char *)v52 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, v36, 24);
          v8 = &v48;
          v9 = (char *)v52;
        }
      }
      v10 = &v9[24 * v53];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v53;
      if (v51[0])
      {
        v48 = 5;
        v49 = (const char *)a5;
        v13 = &v48;
        v14 = (char *)v52;
        if (v12 >= v54)
        {
          v37 = v12 + 1;
          v38 = (char *)v52 + 24 * v12 > (char *)&v48;
          if (v52 <= &v48 && v38)
          {
            v43 = (char *)&v48 - (_BYTE *)v52;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, v37, 24);
            v14 = (char *)v52;
            v13 = (int *)((char *)v52 + v43);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, v37, 24);
            v13 = &v48;
            v14 = (char *)v52;
          }
        }
        v15 = &v14[24 * v53];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v53;
        if (v51[0])
        {
          v48 = 3;
          v49 = " must be ranked tensor of any type values, but got ";
          v50 = 51;
          v18 = &v48;
          v19 = (char *)v52;
          if (v17 >= v54)
          {
            v39 = v17 + 1;
            v40 = (char *)v52 + 24 * v17 > (char *)&v48;
            if (v52 <= &v48 && v40)
            {
              v44 = (char *)&v48 - (_BYTE *)v52;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, v39, 24);
              v19 = (char *)v52;
              v18 = (int *)((char *)v52 + v44);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, v39, 24);
              v18 = &v48;
              v19 = (char *)v52;
            }
          }
          v20 = &v19[24 * v53];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          ++v53;
          if (v51[0])
          {
            v22 = &v48;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v48, a2);
            v23 = (char *)v52;
            if (v53 >= v54)
            {
              v41 = v53 + 1;
              if (v52 <= &v48 && (char *)v52 + 24 * v53 > (char *)&v48)
              {
                v45 = (char *)&v48 - (_BYTE *)v52;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, v41, 24);
                v23 = (char *)v52;
                v22 = (int *)((char *)v52 + v45);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, v41, 24);
                v22 = &v48;
                v23 = (char *)v52;
              }
            }
            v24 = &v23[24 * v53];
            v25 = *(_OWORD *)v22;
            *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
            *(_OWORD *)v24 = v25;
            ++v53;
          }
        }
      }
    }
    v26 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v51);
    if (v51[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v51);
    if (v60)
    {
      v27 = __p;
      if (__p)
      {
        v28 = v59;
        v29 = __p;
        if (v59 != __p)
        {
          do
            v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
          while (v28 != v27);
          v29 = __p;
        }
        v59 = v27;
        operator delete(v29);
      }
      v30 = v56;
      if (v56)
      {
        v31 = v57;
        v32 = v56;
        if (v57 != v56)
        {
          do
          {
            v34 = *--v31;
            v33 = v34;
            *v31 = 0;
            if (v34)
              MEMORY[0x20BD002D4](v33, 0x1000C8077774924);
          }
          while (v31 != v30);
          v32 = v56;
        }
        v57 = v30;
        operator delete(v32);
      }
      if (v52 != v55)
        free(v52);
    }
  }
  return v26;
}

BOOL mlir::tensor::CollapseShapeOp::parse(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  mlir::NoneType **v5;
  mlir::MLIRContext *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15[2];
  uint64_t v16;
  _QWORD v17[4];
  _QWORD __src[4];
  __int16 v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  v14 = 0;
  v16 = 0;
  v13[0] = &v16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v17, 1))
    return 0;
  v5 = (mlir::NoneType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  v7 = mlir::NoneType::get(*v5, v6);
  if (!mlir::AsmParser::parseAttribute<mlir::ArrayAttr>(a1, &v14, v7))
    return 0;
  if (v14)
  {
    v8 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::Properties>(a2);
    *v8 = v14;
  }
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
    return 0;
  v9 = a2[1];
  __src[0] = a1;
  __src[1] = &v12;
  __src[2] = a2;
  v10 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(_QWORD **)(v9 + 96));
  if (v10)
  {
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps4(v10, (const void **)"reassociation", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::CollapseShapeOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  __src[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, __src))
    return 0;
  v16 = __src[0];
  v19 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 368))(a1, "into", 4, __src))return 0;
  v12 = 0;
  if (!mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, &v12))
    return 0;
  __src[0] = v12;
  mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, (uint64_t)(a2 + 2)) != 0;
}

uint64_t mlir::tensor::detail::DimOpGenericAdaptorBase::DimOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  v5 = a2[11];
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "tensor.dim", 10, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::tensor::DimOp::getSourceMutable(mlir::tensor::DimOp *this)
{
  return *(_QWORD *)(*(_QWORD *)this + 72);
}

BOOL mlir::tensor::DimOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  mlir::MemoryMapperInterface *v9;
  unint64_t *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t v14;
  unint64_t *v15;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  unint64_t *v20;
  char *v21;
  char *v22;
  __int128 v23;
  unint64_t *v24;
  char *v25;
  char *v26;
  __int128 v27;
  char v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t NextResultAtOffset;
  unint64_t v40;
  unint64_t v41;
  BOOL v42;
  unint64_t v43;
  BOOL v44;
  unint64_t v45;
  int64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  const void **v50;
  uint64_t v51;
  __int16 v52;
  unint64_t v53;
  unint64_t v54;
  const char *v55;
  uint64_t v56;
  _QWORD v57[3];
  void *v58;
  unsigned int v59;
  unsigned int v60;
  _BYTE v61[96];
  void *v62;
  _QWORD *v63;
  void *__p;
  _QWORD *v65;
  char v66;
  uint64_t v67;

  v67 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v3 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v4 = *(_QWORD *)v3;
  v5 = *(void **)(*(_QWORD *)v3 + 136);
  if (v5 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v8 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v4 + 8);
    v57[0] = v3;
    v9 = (mlir::MemoryMapperInterface *)v57;
    goto LABEL_30;
  }
  if (v5 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v50 = (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    v51 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v4 + 8);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v50))
    {
      v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v3 + 8);
      v54 = v3;
      v55 = (const char *)v6;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v54);
      if (v7 >= 1)
      {
        v8 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v3 + 8);
        v53 = v3;
        v9 = (mlir::MemoryMapperInterface *)&v53;
LABEL_30:
        *((_QWORD *)v9 + 1) = v8;
        mlir::MemoryMapperInterface::getOperandRange(v9);
        goto LABEL_36;
      }
    }
  }
  v52 = 261;
  v50 = (const void **)"operand";
  v51 = 7;
  mlir::Operation::emitOpError(v2, &v50, (uint64_t)v57);
  if (v57[0])
  {
    LODWORD(v54) = 3;
    v55 = " #";
    v56 = 2;
    v10 = &v54;
    v11 = (char *)v58;
    if (v59 >= v60)
    {
      v40 = v59 + 1;
      if (v58 <= &v54 && (char *)v58 + 24 * v59 > (char *)&v54)
      {
        v46 = (char *)&v54 - (_BYTE *)v58;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v61, v40, 24);
        v11 = (char *)v58;
        v10 = (unint64_t *)((char *)v58 + v46);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v61, v40, 24);
        v10 = &v54;
        v11 = (char *)v58;
      }
    }
    v12 = &v11[24 * v59];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = v10[2];
    *(_OWORD *)v12 = v13;
    v14 = ++v59;
    if (v57[0])
    {
      LODWORD(v54) = 5;
      v55 = 0;
      v15 = &v54;
      v16 = (char *)v58;
      if (v14 >= v60)
      {
        v41 = v14 + 1;
        v42 = (char *)v58 + 24 * v14 > (char *)&v54;
        if (v58 <= &v54 && v42)
        {
          v47 = (char *)&v54 - (_BYTE *)v58;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v61, v41, 24);
          v16 = (char *)v58;
          v15 = (unint64_t *)((char *)v58 + v47);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v61, v41, 24);
          v15 = &v54;
          v16 = (char *)v58;
        }
      }
      v17 = &v16[24 * v59];
      v18 = *(_OWORD *)v15;
      *((_QWORD *)v17 + 2) = v15[2];
      *(_OWORD *)v17 = v18;
      v19 = ++v59;
      if (v57[0])
      {
        LODWORD(v54) = 3;
        v55 = " must be non-0-ranked or unranked tensor, but got ";
        v56 = 50;
        v20 = &v54;
        v21 = (char *)v58;
        if (v19 >= v60)
        {
          v43 = v19 + 1;
          v44 = (char *)v58 + 24 * v19 > (char *)&v54;
          if (v58 <= &v54 && v44)
          {
            v48 = (char *)&v54 - (_BYTE *)v58;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v61, v43, 24);
            v21 = (char *)v58;
            v20 = (unint64_t *)((char *)v58 + v48);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v61, v43, 24);
            v20 = &v54;
            v21 = (char *)v58;
          }
        }
        v22 = &v21[24 * v59];
        v23 = *(_OWORD *)v20;
        *((_QWORD *)v22 + 2) = v20[2];
        *(_OWORD *)v22 = v23;
        ++v59;
        if (v57[0])
        {
          v24 = &v54;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v54, v3);
          v25 = (char *)v58;
          if (v59 >= v60)
          {
            v45 = v59 + 1;
            if (v58 <= &v54 && (char *)v58 + 24 * v59 > (char *)&v54)
            {
              v49 = (char *)&v54 - (_BYTE *)v58;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v61, v45, 24);
              v25 = (char *)v58;
              v24 = (unint64_t *)((char *)v58 + v49);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v61, v45, 24);
              v24 = &v54;
              v25 = (char *)v58;
            }
          }
          v26 = &v25[24 * v59];
          v27 = *(_OWORD *)v24;
          *((_QWORD *)v26 + 2) = v24[2];
          *(_OWORD *)v26 = v27;
          ++v59;
        }
      }
    }
  }
  v28 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v57);
  if (v57[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v57);
  if (v66)
  {
    v29 = __p;
    if (__p)
    {
      v30 = v65;
      v31 = __p;
      if (v65 != __p)
      {
        do
          v30 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v30 - 1);
        while (v30 != v29);
        v31 = __p;
      }
      v65 = v29;
      operator delete(v31);
    }
    v32 = v62;
    if (v62)
    {
      v33 = v63;
      v34 = v62;
      if (v63 != v62)
      {
        do
        {
          v36 = *--v33;
          v35 = v36;
          *v33 = 0;
          if (v36)
            MEMORY[0x20BD002D4](v35, 0x1000C8077774924);
        }
        while (v33 != v32);
        v34 = v62;
      }
      v63 = v32;
      operator delete(v34);
    }
    if (v58 != v61)
      free(v58);
  }
  if (!v28)
    return 0;
LABEL_36:
  if (!mlir::memref::__mlir_ods_local_type_constraint_MemRefOps9(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))return 0;
  if (*((_DWORD *)*this + 9))
    v37 = (uint64_t)(*this - 2);
  else
    v37 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v37, 0);
  return mlir::memref::__mlir_ods_local_type_constraint_MemRefOps9(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

BOOL mlir::tensor::DimOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  mlir::IndexType **v5;
  mlir::MLIRContext *v6;
  uint64_t v7;
  uint64_t __src;
  _QWORD v10[2];
  uint64_t v11[2];
  uint64_t v12;
  _QWORD v13[4];
  _QWORD v14[5];

  v14[4] = *MEMORY[0x24BDAC8D0];
  memset(v14, 0, 24);
  v11[0] = (uint64_t)v14;
  v11[1] = 1;
  memset(v13, 0, 24);
  v12 = 0;
  v10[0] = &v12;
  v10[1] = 1;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v14, 1))
    return 0;
  if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1)
    && ((*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1),
        (*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v13, 1))
    && (*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1)
    && (__src = 0, mlir::AsmParser::parseType<mlir::TensorType>(a1, &__src))
    && (v12 = __src,
        v5 = (mlir::IndexType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1),
        __src = mlir::Builder::getIndexType(v5, v6),
        mlir::OperationState::addTypes(a2, &__src, 1),
        v7 = a2 + 16,
        mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v11, v10, v4, v7)))
  {
    return (*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v13, __src, v7) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::tensor::EmptyOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t NextResultAtOffset;

  v2 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0 && (v3 = *((unsigned int *)v2 + 17), (_DWORD)v3))
  {
    v4 = 0;
    v5 = v2[9] + 24;
    while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v5 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v4))
    {
      ++v4;
      v5 += 32;
      if (v3 == v4)
      {
        v2 = *this;
        goto LABEL_7;
      }
    }
    return 0;
  }
  else
  {
LABEL_7:
    v6 = *((_DWORD *)v2 + 9);
    v7 = v2 - 2;
    if (v6)
      v8 = (uint64_t)v7;
    else
      v8 = 0;
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0);
    return mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
  }
}

uint64_t mlir::tensor::EmptyOp::parse(uint64_t a1, uint64_t a2)
{
  mlir::IndexType **v4;
  mlir::MLIRContext *v5;
  uint64_t IndexType;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t __src;
  void *v14;
  uint64_t v15;
  _QWORD v16[17];

  v16[16] = *MEMORY[0x24BDAC8D0];
  v14 = v16;
  v15 = 0x400000000;
  if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 264))(a1))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    if ((*(unsigned __int8 (**)(uint64_t, void **, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, &v14, 0, 1, 0xFFFFFFFFLL))
    {
      if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 280))(a1))
      {
        (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
        if ((*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
        {
          if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
          {
            v12 = 0;
            if (mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, &v12))
            {
              __src = v12;
              v4 = (mlir::IndexType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
              IndexType = mlir::Builder::getIndexType(v4, v5);
              v7 = 1;
              mlir::OperationState::addTypes(a2, &__src, 1);
              if (!(_DWORD)v15)
                goto LABEL_13;
              v8 = a2 + 16;
              v9 = (char *)v14;
              v10 = 32 * v15;
              while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v9, IndexType, v8))
              {
                v9 += 32;
                v7 = 1;
                v10 -= 32;
                if (!v10)
                  goto LABEL_13;
              }
            }
          }
        }
      }
    }
  }
  v7 = 0;
LABEL_13:
  if (v14 != v16)
    free(v14);
  return v7;
}

void mlir::tensor::EmptyOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  mlir::Operation *v6;
  uint64_t v7;
  uint64_t v8;
  llvm::raw_ostream *v9;
  llvm::raw_ostream *v10;
  _BYTE *v11;
  mlir::Operation *v12;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v15;
  llvm::raw_ostream *v16;
  _BYTE *v17;
  llvm::raw_ostream *v18;
  _BYTE *v19;
  llvm::raw_ostream *v20;
  _BYTE *v21;
  uint64_t v22;
  uint64_t NextResultAtOffset;
  unint64_t AttrDictionary;
  void *v25;
  uint64_t v26;
  _QWORD v27[5];

  v27[4] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "(", 1uLL);
    v6 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
      goto LABEL_3;
  }
  else
  {
    *v5 = 40;
    ++*((_QWORD *)v4 + 4);
    v6 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
    {
LABEL_3:
      v7 = *((unsigned int *)v6 + 17);
      v8 = *((_QWORD *)v6 + 9);
      goto LABEL_4;
    }
  }
  v8 = 0;
  v7 = 0;
LABEL_4:
  v9 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v25 = ", ";
  v26 = 2;
  llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v8, 0, v8, v7, (uint64_t)a2, v9, (uint64_t)&v25);
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (_BYTE *)*((_QWORD *)v10 + 4);
  if (*((_BYTE **)v10 + 3) == v11)
  {
    llvm::raw_ostream::write(v10, ")", 1uLL);
  }
  else
  {
    *v11 = 41;
    ++*((_QWORD *)v10 + 4);
  }
  v25 = v27;
  v26 = 0x200000000;
  v12 = *this;
  if (*((_BYTE *)*this + 47))
  {
    AttrDictionary = mlir::Operation::getAttrDictionary(v12);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::Operation *)((char *)v12 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v15, v25, v26);
  v16 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v17 = (_BYTE *)*((_QWORD *)v16 + 4);
  if ((unint64_t)v17 >= *((_QWORD *)v16 + 3))
  {
    llvm::raw_ostream::write(v16, 32);
  }
  else
  {
    *((_QWORD *)v16 + 4) = v17 + 1;
    *v17 = 32;
  }
  v18 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v19 = (_BYTE *)*((_QWORD *)v18 + 4);
  if (*((_BYTE **)v18 + 3) == v19)
  {
    llvm::raw_ostream::write(v18, ":", 1uLL);
  }
  else
  {
    *v19 = 58;
    ++*((_QWORD *)v18 + 4);
  }
  v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v21 = (_BYTE *)*((_QWORD *)v20 + 4);
  if ((unint64_t)v21 >= *((_QWORD *)v20 + 3))
  {
    llvm::raw_ostream::write(v20, 32);
  }
  else
  {
    *((_QWORD *)v20 + 4) = v21 + 1;
    *v21 = 32;
  }
  if (*((_DWORD *)*this + 9))
    v22 = (uint64_t)*this - 16;
  else
    v22 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v22, 0);
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v25 != v27)
    free(v25);
}

uint64_t mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::ExpandShapeOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "tensor.expand_shape", 19, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::tensor::ExpandShapeOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::ArrayAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  uint64_t *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::Properties]";
        v15 = 115;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v5[232];
    return a1[32];
  }
  return result;
}

BOOL mlir::tensor::ExpandShapeOp::parse(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  mlir::NoneType **v5;
  mlir::MLIRContext *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15[2];
  uint64_t v16;
  _QWORD v17[4];
  _QWORD __src[4];
  __int16 v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  v14 = 0;
  v16 = 0;
  v13[0] = &v16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v17, 1))
    return 0;
  v5 = (mlir::NoneType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  v7 = mlir::NoneType::get(*v5, v6);
  if (!mlir::AsmParser::parseAttribute<mlir::ArrayAttr>(a1, &v14, v7))
    return 0;
  if (v14)
  {
    v8 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::Properties>(a2);
    *v8 = v14;
  }
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
    return 0;
  v9 = a2[1];
  __src[0] = a1;
  __src[1] = &v12;
  __src[2] = a2;
  v10 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(_QWORD **)(v9 + 96));
  if (v10)
  {
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps4(v10, (const void **)"reassociation", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::ExpandShapeOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  __src[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, __src))
    return 0;
  v16 = __src[0];
  v19 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 368))(a1, "into", 4, __src))return 0;
  v12 = 0;
  if (!mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, &v12))
    return 0;
  __src[0] = v12;
  mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, (uint64_t)(a2 + 2)) != 0;
}

uint64_t mlir::tensor::detail::ExtractOpGenericAdaptorBase::ExtractOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  v5 = a2[11];
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "tensor.extract", 14, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::tensor::ExtractOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  uint64_t v11;

  v11 = a4;
  mlir::OperationState::addOperands(a2, (uint64_t)&v11, 1);
  mlir::OperationState::addOperands(a2, a5, a6);
  v10 = *(unsigned int *)(a2 + 72);
  if (v10 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v10 + 1, 8);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v10) = a3;
  ++*(_DWORD *)(a2 + 72);
}

void mlir::tensor::ExtractOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::MLIRContext *Context;
  unsigned int v9;
  uint64_t ElementType;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  __int128 v18;
  void *__src;
  uint64_t v20;
  _BYTE v21[16];
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v15 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v15, 1);
  mlir::OperationState::addOperands(a2, a4, a5);
  __src = v21;
  v20 = 0x200000000;
  mlir::ValueRange::ValueRange((unint64_t *)&v18, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v17, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v22 = v18;
  if ((_DWORD)v20 != 1)
  {
    if (!(_DWORD)v20)
    {
      if (HIDWORD(v20))
      {
        v9 = 0;
LABEL_6:
        bzero((char *)__src + 8 * v9, 8 - 8 * v9);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v21, 1uLL, 8);
      v9 = v20;
      if ((_DWORD)v20 != 1)
        goto LABEL_6;
    }
LABEL_7:
    LODWORD(v20) = 1;
  }
  v16 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v22, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  ElementType = mlir::TensorType::getElementType((mlir::TensorType *)&v16);
  *(_QWORD *)__src = ElementType;
  v11 = __src;
  v12 = v20;
  v13 = *(unsigned int *)(a2 + 72);
  v14 = v13 + v20;
  if (v14 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14, 8);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v12)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v13), v11, 8 * v12);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + v12;
  if (__src != v21)
    free(__src);
}

uint64_t mlir::tensor::ExtractOp::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  unint64_t v14;
  _QWORD v15[3];

  v15[2] = *MEMORY[0x24BDAC8D0];
  v15[0] = a4;
  v15[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  v14 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v15, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  **(_QWORD **)a11 = mlir::TensorType::getElementType((mlir::TensorType *)&v14);
  return 1;
}

uint64_t mlir::tensor::ExtractOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t ElementType;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  const void **v23;
  __int16 v24;
  _QWORD v25[3];
  void *v26;
  uint64_t v27;
  void *v28;
  _QWORD *v29;
  void *__p;
  _QWORD *v31;
  char v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  if (!mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))return 0;
  v2 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) == 0)
  {
    v4 = -1;
    v5 = 32;
LABEL_5:
    v6 = 0;
    v7 = v5 + 24;
    while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v7 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, (int)v6 + 1))
    {
      ++v6;
      v7 += 32;
      if (v4 == v6)
      {
        v2 = *this;
        goto LABEL_9;
      }
    }
    return 0;
  }
  v3 = *((unsigned int *)v2 + 17);
  v4 = v3 - 1;
  if (v3 != 1)
  {
    v5 = v2[9] + 32;
    goto LABEL_5;
  }
LABEL_9:
  v8 = *((_DWORD *)v2 + 9);
  v9 = v2 - 2;
  if (v8)
    v10 = (uint64_t)v9;
  else
    v10 = 0;
  mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0);
  v25[0] = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  ElementType = mlir::TensorType::getElementType((mlir::TensorType *)v25);
  if (*((_DWORD *)*this + 9))
    v12 = (uint64_t)(*this - 2);
  else
    v12 = 0;
  if (ElementType == (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v12, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
    return 1;
  v23 = (const void **)"failed to verify that result type matches element type of tensor";
  v24 = 259;
  mlir::OpState::emitOpError(this, &v23, (uint64_t)v25);
  v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v25);
  if (v25[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v25);
  if (v32)
  {
    v14 = __p;
    if (__p)
    {
      v15 = v31;
      v16 = __p;
      if (v31 != __p)
      {
        do
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
        while (v15 != v14);
        v16 = __p;
      }
      v31 = v14;
      operator delete(v16);
    }
    v17 = v28;
    if (v28)
    {
      v18 = v29;
      v19 = v28;
      if (v29 != v28)
      {
        do
        {
          v21 = *--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
            MEMORY[0x20BD002D4](v20, 0x1000C8077774924);
        }
        while (v18 != v17);
        v19 = v28;
      }
      v29 = v17;
      operator delete(v19);
    }
    if (v26 != &v27)
      free(v26);
  }
  return v13;
}

uint64_t mlir::tensor::ExtractOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  mlir::IndexType **v12;
  mlir::MLIRContext *v13;
  uint64_t IndexType;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  _QWORD v19[4];
  __int16 v20;
  uint64_t v21;
  _QWORD v22[2];
  uint64_t v23[2];
  _QWORD __src[24];
  uint64_t v25;
  _BYTE *v26;
  uint64_t v27;
  _BYTE v28[128];
  _QWORD v29[5];

  v29[4] = *MEMORY[0x24BDAC8D0];
  memset(v29, 0, 24);
  v23[0] = (uint64_t)v29;
  v23[1] = 1;
  v25 = 0;
  v26 = v28;
  v27 = 0x400000000;
  v22[0] = &v25;
  v22[1] = 1;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v29, 1))
  {
    if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 296))(a1))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
      if ((*(unsigned __int8 (**)(uint64_t, _BYTE **, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, &v26, 0, 1, 0xFFFFFFFFLL))
      {
        if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 312))(a1))
        {
          (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
          if ((*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
          {
            if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
            {
              __src[0] = 0;
              if (mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, __src))
              {
                v5 = __src[0];
                v25 = __src[0];
                v21 = __src[0];
                if (*(_UNKNOWN **)(*(_QWORD *)__src[0] + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
                {
                  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
                  v20 = 257;
                  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(__src, a1, v6, v19);
                  v7 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)__src, "'tensor' must be ranked tensor of any type values, but got ");
                  v8 = mlir::InFlightDiagnostic::append<mlir::Type &>(v7, &v21);
                  v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v8);
                  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)__src);
                  v10 = v26;
                  if (v26 == v28)
                    return v9;
                  goto LABEL_19;
                }
                v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)__src[0] + 8);
                __src[0] = v5;
                __src[1] = v11;
                mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)__src);
                v12 = (mlir::IndexType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
                IndexType = mlir::Builder::getIndexType(v12, v13);
                v19[0] = v25;
                __src[0] = mlir::TensorType::getElementType((mlir::TensorType *)v19);
                mlir::OperationState::addTypes(a2, __src, 1);
                v15 = a2 + 16;
                if (mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v23, v22, v4, v15))
                {
                  if (!(_DWORD)v27)
                  {
                    v9 = 1;
                    v10 = v26;
                    if (v26 == v28)
                      return v9;
                    goto LABEL_19;
                  }
                  v16 = v26;
                  v17 = 32 * v27;
                  v9 = 1;
                  while ((*(unsigned __int8 (**)(uint64_t, _BYTE *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v16, IndexType, v15))
                  {
                    v16 += 32;
                    v17 -= 32;
                    if (!v17)
                      goto LABEL_18;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v9 = 0;
LABEL_18:
  v10 = v26;
  if (v26 != v28)
LABEL_19:
    free(v10);
  return v9;
}

void mlir::tensor::ExtractOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  llvm::raw_ostream *v6;
  _BYTE *v7;
  mlir::Operation *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  llvm::raw_ostream *v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  mlir::Operation *v16;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v19;
  llvm::raw_ostream *v20;
  _BYTE *v21;
  llvm::raw_ostream *v22;
  _BYTE *v23;
  llvm::raw_ostream *v24;
  _BYTE *v25;
  unint64_t AttrDictionary;
  void *v27;
  uint64_t v28;
  _QWORD v29[5];

  v29[4] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 24));
  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v7 = (_BYTE *)*((_QWORD *)v6 + 4);
  if (*((_BYTE **)v6 + 3) == v7)
  {
    llvm::raw_ostream::write(v6, "[", 1uLL);
    v8 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
      goto LABEL_6;
  }
  else
  {
    *v7 = 91;
    ++*((_QWORD *)v6 + 4);
    v8 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
    {
LABEL_6:
      v9 = *((unsigned int *)v8 + 17);
      v10 = *((_QWORD *)v8 + 9);
      v11 = v9 - 1;
      goto LABEL_7;
    }
  }
  v10 = 0;
  v11 = -1;
LABEL_7:
  v12 = v10 + 32;
  v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v27 = ", ";
  v28 = 2;
  llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v12, 0, v12, v11, (uint64_t)a2, v13, (uint64_t)&v27);
  v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)v14 + 4);
  if (*((_BYTE **)v14 + 3) == v15)
  {
    llvm::raw_ostream::write(v14, "]", 1uLL);
  }
  else
  {
    *v15 = 93;
    ++*((_QWORD *)v14 + 4);
  }
  v27 = v29;
  v28 = 0x200000000;
  v16 = *this;
  if (*((_BYTE *)*this + 47))
  {
    AttrDictionary = mlir::Operation::getAttrDictionary(v16);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::Operation *)((char *)v16 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v19, v27, v28);
  v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v21 = (_BYTE *)*((_QWORD *)v20 + 4);
  if ((unint64_t)v21 >= *((_QWORD *)v20 + 3))
  {
    llvm::raw_ostream::write(v20, 32);
  }
  else
  {
    *((_QWORD *)v20 + 4) = v21 + 1;
    *v21 = 32;
  }
  v22 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v23 = (_BYTE *)*((_QWORD *)v22 + 4);
  if (*((_BYTE **)v22 + 3) == v23)
  {
    llvm::raw_ostream::write(v22, ":", 1uLL);
  }
  else
  {
    *v23 = 58;
    ++*((_QWORD *)v22 + 4);
  }
  v24 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v25 = (_BYTE *)*((_QWORD *)v24 + 4);
  if ((unint64_t)v25 >= *((_QWORD *)v24 + 3))
  {
    llvm::raw_ostream::write(v24, 32);
  }
  else
  {
    *((_QWORD *)v24 + 4) = v25 + 1;
    *v25 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(*(_QWORD *)(*((_QWORD *)*this + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v27 != v29)
    free(v27);
}

uint64_t mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::ExtractSliceOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t Context;
  unint64_t v12[3];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v12, v7, v6);
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v5;
  v9 = *(_OWORD *)(v5 + 16);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(v5 + 32);
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)v12;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "tensor.extract_slice", 20, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::tensor::ExtractSliceOp::getInherentAttr(mlir::MLIRContext *a1, uint64_t *a2, char *__s1, size_t __n)
{
  uint64_t result;

  result = 0;
  switch(__n)
  {
    case 0xCuLL:
      if (memcmp(__s1, "static_sizes", __n))
        goto LABEL_11;
      return a2[1];
    case 0xDuLL:
    case 0xFuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      goto LABEL_11;
    case 0xEuLL:
      if (*(_QWORD *)__s1 == 0x6F5F636974617473 && *(_QWORD *)(__s1 + 6) == 0x7374657366666F5FLL)
      {
        result = *a2;
      }
      else if (!memcmp(__s1, "static_strides", __n))
      {
        result = a2[2];
      }
      else
      {
LABEL_11:
        result = 0;
      }
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n))
        goto LABEL_11;
      goto LABEL_13;
    case 0x15uLL:
      if (memcmp(__s1, "operand_segment_sizes", __n))
        goto LABEL_11;
LABEL_13:
      result = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 3), 4);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::tensor::ExtractSliceOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, _QWORD *a4)
{
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;

  v5 = (_QWORD *)result;
  switch(a3)
  {
    case 0xCuLL:
      result = memcmp(__s1, "static_sizes", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
          if ((_DWORD)result)
            v10 = a4;
          else
            v10 = 0;
          v5[1] = v10;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0xEuLL:
      if (*(_QWORD *)__s1 == 0x6F5F636974617473 && *(_QWORD *)(__s1 + 6) == 0x7374657366666F5FLL)
      {
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
          if ((_DWORD)result)
            v11 = a4;
          else
            v11 = 0;
          *v5 = v11;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      else
      {
        result = memcmp(__s1, "static_strides", a3);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
            if ((_DWORD)result)
              v7 = a4;
            else
              v7 = 0;
            v5[2] = v7;
          }
          else
          {
            v5[2] = 0;
          }
        }
      }
      break;
    case 0x13uLL:
      result = memcmp(__s1, "operandSegmentSizes", a3);
      if (!(_DWORD)result)
        goto LABEL_17;
      break;
    case 0x15uLL:
      result = memcmp(__s1, "operand_segment_sizes", a3);
      if (!(_DWORD)result)
      {
LABEL_17:
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          v8 = (_DWORD)result ? a4 : 0;
          v12 = v8;
          if ((_DWORD)result)
          {
            result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v12);
            if (result == 4)
            {
              result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v12);
              if (v9)
                result = (uint64_t)memmove(v5 + 3, (const void *)result, 4 * v9);
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::tensor::ExtractSliceOp::readProperties(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD *v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v3 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>(a2);
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) <= 5)
  {
    v17 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v17))
      return 0;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v17) >= 5)
    {
      v15 = "size mismatch for operand/result_segment_size";
      v16 = 259;
      (*(void (**)(_QWORD *__return_ptr, uint64_t, const char **))(*(_QWORD *)a1 + 16))(v18, a1, &v15);
      if (v18[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
      if (v25)
      {
        v4 = __p;
        if (__p)
        {
          v5 = v24;
          v6 = __p;
          if (v24 != __p)
          {
            do
              v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
            while (v5 != v4);
            v6 = __p;
          }
          v24 = v4;
          operator delete(v6);
        }
        v7 = v21;
        if (v21)
        {
          v8 = v22;
          v9 = v21;
          if (v22 != v21)
          {
            do
            {
              v11 = *--v8;
              v10 = v11;
              *v8 = 0;
              if (v11)
                MEMORY[0x20BD002D4](v10, 0x1000C8077774924);
            }
            while (v8 != v7);
            v9 = v21;
          }
          v22 = v7;
          operator delete(v9);
        }
        if (v19 != &v20)
          free(v19);
      }
      return 0;
    }
    v12 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v17);
    if (v13)
      memmove(v3 + 3, v12, 4 * v13);
  }
  return mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3)&& mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3 + 2)&& ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) < 6|| mlir::DialectBytecodeReader::readSparseArray<int>(a1, (_DWORD *)v3 + 6, (const char *)4));
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new();
    *(_OWORD *)v3 = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_QWORD *)(v3 + 32) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties]";
        v15 = 116;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[234];
    return a1[32];
  }
  return result;
}

void mlir::tensor::ExtractSliceOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  _DWORD *v22;
  uint64_t DenseI64ArrayAttr;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v28;

  v28 = a4;
  mlir::OperationState::addOperands(a2, (uint64_t)&v28, 1);
  mlir::OperationState::addOperands(a2, a5, a6);
  mlir::OperationState::addOperands(a2, a7, a8);
  mlir::OperationState::addOperands(a2, a9, a10);
  v22 = (_DWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2);
  v22[6] = 1;
  v22[7] = a6;
  v22[8] = a8;
  v22[9] = a10;
  DenseI64ArrayAttr = mlir::Builder::getDenseI64ArrayAttr(a1, a11, a12);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2) = DenseI64ArrayAttr;
  v24 = mlir::Builder::getDenseI64ArrayAttr(a1, a13, a14);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = v24;
  v25 = mlir::Builder::getDenseI64ArrayAttr(a1, a15, a16);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = v25;
  v26 = *(unsigned int *)(a2 + 72);
  if (v26 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v26 + 1, 8);
    LODWORD(v26) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v26) = a3;
  ++*(_DWORD *)(a2 + 72);
}

BOOL mlir::tensor::ExtractSliceOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t ODSOperands;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t NextResultAtOffset;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  void *v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  const void **v49[4];
  __int16 v50;
  _QWORD v51[3];
  void *v52;
  uint64_t v53;
  void *v54;
  _QWORD *v55;
  void *__p;
  _QWORD *v57;
  char v58;
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_QWORD **)v3;
  if (!*(_QWORD *)v3)
  {
    v49[0] = (const void **)"requires attribute 'static_offsets'";
    v50 = 259;
    mlir::OpState::emitOpError(this, v49, (uint64_t)v51);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v51);
    if (v51[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v51);
    if (!v58)
      return v27;
    v28 = __p;
    if (__p)
    {
      v29 = v57;
      v30 = __p;
      if (v57 != __p)
      {
        do
          v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
        while (v29 != v28);
        v30 = __p;
      }
      v57 = v28;
      operator delete(v30);
    }
    v31 = v54;
    if (v54)
    {
      v32 = v55;
      v33 = v54;
      if (v55 == v54)
        goto LABEL_77;
      do
      {
        v35 = *--v32;
        v34 = v35;
        *v32 = 0;
        if (v35)
          MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
      }
      while (v32 != v31);
LABEL_76:
      v33 = v54;
LABEL_77:
      v55 = v31;
      operator delete(v33);
    }
LABEL_78:
    if (v52 != &v53)
      free(v52);
    return v27;
  }
  v5 = *(_QWORD **)(v3 + 8);
  if (!v5)
  {
    v49[0] = (const void **)"requires attribute 'static_sizes'";
    v50 = 259;
    mlir::OpState::emitOpError(this, v49, (uint64_t)v51);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v51);
    if (v51[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v51);
    if (!v58)
      return v27;
    v36 = __p;
    if (__p)
    {
      v37 = v57;
      v38 = __p;
      if (v57 != __p)
      {
        do
          v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
        while (v37 != v36);
        v38 = __p;
      }
      v57 = v36;
      operator delete(v38);
    }
    v31 = v54;
    if (v54)
    {
      v39 = v55;
      v33 = v54;
      if (v55 == v54)
        goto LABEL_77;
      do
      {
        v41 = *--v39;
        v40 = v41;
        *v39 = 0;
        if (v41)
          MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
      }
      while (v39 != v31);
      goto LABEL_76;
    }
    goto LABEL_78;
  }
  v6 = *(_QWORD **)(v3 + 16);
  if (!v6)
  {
    v49[0] = (const void **)"requires attribute 'static_strides'";
    v50 = 259;
    mlir::OpState::emitOpError(this, v49, (uint64_t)v51);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v51);
    if (v51[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v51);
    if (!v58)
      return v27;
    v42 = __p;
    if (__p)
    {
      v43 = v57;
      v44 = __p;
      if (v57 != __p)
      {
        do
          v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
        while (v43 != v42);
        v44 = __p;
      }
      v57 = v42;
      operator delete(v44);
    }
    v31 = v54;
    if (v54)
    {
      v45 = v55;
      v33 = v54;
      if (v55 == v54)
        goto LABEL_77;
      do
      {
        v47 = *--v45;
        v46 = v47;
        *v45 = 0;
        if (v47)
          MEMORY[0x20BD002D4](v46, 0x1000C8077774924);
      }
      while (v45 != v31);
      goto LABEL_76;
    }
    goto LABEL_78;
  }
  v51[0] = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v4, (const void **)"static_offsets", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v51))return 0;
  v51[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v5, (const void **)"static_sizes", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v51))return 0;
  v51[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v6, (const void **)"static_strides", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v51))return 0;
  v7 = *((unsigned int *)*this + 11);
  v8 = (uint64_t)&(*this)[2 * ((v7 >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v8 = 0;
  v9 = *(unsigned int *)(v8 + 24);
  if ((v7 & 0x800000) != 0)
  {
    v10 = (*this)[9];
    if ((_DWORD)v9)
      goto LABEL_14;
  }
  else
  {
    v10 = 0;
    if ((_DWORD)v9)
    {
LABEL_14:
      v11 = 0;
      v12 = v10 + 24;
      while (mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(*(_QWORD *)v12 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v11))
      {
        ++v11;
        v12 += 32;
        if (v9 == v11)
          goto LABEL_17;
      }
      return 0;
    }
  }
LABEL_17:
  ODSOperands = mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 1u);
  if (v14)
  {
    v15 = v14;
    v16 = ODSOperands + 24;
    while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v16 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v9))
    {
      LODWORD(v9) = v9 + 1;
      v16 += 32;
      if (!--v15)
        goto LABEL_21;
    }
    return 0;
  }
LABEL_21:
  v17 = mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 2u);
  if (v18)
  {
    v19 = v18;
    v20 = v17 + 24;
    while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v20 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v9))
    {
      LODWORD(v9) = v9 + 1;
      v20 += 32;
      if (!--v19)
        goto LABEL_25;
    }
    return 0;
  }
LABEL_25:
  v21 = mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 3u);
  if (v22)
  {
    v23 = v22;
    v24 = v21 + 24;
    while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v24 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v9))
    {
      LODWORD(v9) = v9 + 1;
      v24 += 32;
      if (!--v23)
        goto LABEL_29;
    }
    return 0;
  }
LABEL_29:
  if (*((_DWORD *)*this + 9))
    v25 = (uint64_t)(*this - 2);
  else
    v25 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v25, 0);
  return mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::tensor::ExtractSliceOp::parse(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  _DWORD *v12;
  mlir::IndexType **v13;
  mlir::MLIRContext *v14;
  uint64_t IndexType;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v26;
  _QWORD v27[2];
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31[2];
  uint64_t v32;
  void *v33;
  uint64_t v34;
  _BYTE v35[128];
  void *v36;
  uint64_t v37;
  _BYTE v38[128];
  void *v39;
  uint64_t v40;
  _BYTE v41[128];
  _QWORD v42[4];
  uint64_t __src[4];
  __int16 v44;
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  memset(v42, 0, 24);
  v31[0] = (uint64_t)v42;
  v31[1] = 1;
  v39 = v41;
  v40 = 0x400000000;
  v29 = 0;
  v30 = 0;
  v36 = v38;
  v37 = 0x400000000;
  v32 = 0;
  v33 = v35;
  v34 = 0x400000000;
  v27[1] = 1;
  v28 = 0;
  v27[0] = &v32;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v42, 1))
    goto LABEL_25;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  __src[0] = 0;
  if (!mlir::parseDynamicIndexList(a1, (uint64_t)&v39, &v30, __src, 0, 2))
    goto LABEL_25;
  v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>(a2);
  *v5 = v30;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  __src[0] = 0;
  if (!mlir::parseDynamicIndexList(a1, (uint64_t)&v36, &v29, __src, 0, 2))
    goto LABEL_25;
  v6 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>(a2);
  *(_QWORD *)(v6 + 8) = v29;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  __src[0] = 0;
  if (!mlir::parseDynamicIndexList(a1, (uint64_t)&v33, &v28, __src, 0, 2))
    goto LABEL_25;
  v7 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>(a2);
  *(_QWORD *)(v7 + 16) = v28;
  v26 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
    goto LABEL_25;
  v8 = a2[1];
  __src[0] = a1;
  __src[1] = (uint64_t)&v26;
  __src[2] = (uint64_t)a2;
  if (!mlir::memref::ReinterpretCastOp::verifyInherentAttrs(v8, (uint64_t)(a2 + 14), (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::ExtractSliceOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))goto LABEL_25;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    goto LABEL_25;
  __src[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, __src))
    goto LABEL_25;
  v32 = __src[0];
  v44 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 368))(a1, "to", 2, __src))goto LABEL_25;
  v26 = 0;
  if (!mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, &v26))
    goto LABEL_25;
  __src[0] = v26;
  v9 = v40;
  v10 = v37;
  v11 = v34;
  v12 = (_DWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>(a2);
  v12[6] = 1;
  v12[7] = v9;
  v12[8] = v10;
  v12[9] = v11;
  v13 = (mlir::IndexType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  IndexType = mlir::Builder::getIndexType(v13, v14);
  mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
  v16 = (uint64_t)(a2 + 2);
  if (!mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v31, v27, v4, v16))goto LABEL_25;
  if ((_DWORD)v40)
  {
    v17 = (char *)v39;
    v18 = 32 * v40;
    while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v17, IndexType, v16))
    {
      v17 += 32;
      v18 -= 32;
      if (!v18)
        goto LABEL_16;
    }
LABEL_25:
    v23 = 0;
LABEL_26:
    v24 = v33;
    if (v33 != v35)
      goto LABEL_27;
    goto LABEL_28;
  }
LABEL_16:
  if ((_DWORD)v37)
  {
    v19 = (char *)v36;
    v20 = 32 * v37;
    while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v19, IndexType, v16))
    {
      v19 += 32;
      v20 -= 32;
      if (!v20)
        goto LABEL_20;
    }
    goto LABEL_25;
  }
LABEL_20:
  if ((_DWORD)v34)
  {
    v21 = (char *)v33;
    v22 = 32 * v34;
    v23 = 1;
    while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v21, IndexType, v16))
    {
      v21 += 32;
      v22 -= 32;
      if (!v22)
        goto LABEL_26;
    }
    goto LABEL_25;
  }
  v23 = 1;
  v24 = v33;
  if (v33 != v35)
LABEL_27:
    free(v24);
LABEL_28:
  if (v36 != v38)
    free(v36);
  if (v39 != v41)
    free(v39);
  return v23;
}

uint64_t mlir::tensor::detail::FromElementsOpGenericAdaptorBase::FromElementsOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "tensor.from_elements", 20, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::tensor::FromElementsOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;
  uint64_t v4;
  uint64_t *Value;
  uint64_t v6;
  unint64_t NumElements;
  uint64_t v8;
  void *RHS;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  int64x2_t v14;
  int64x2_t *v15;
  unint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const void **v21;
  uint64_t *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  BOOL v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  const void **v37;
  uint64_t v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41[2];
  unint64_t v42;
  unint64_t v43;
  void *v44;
  unsigned int v45;
  int v46;
  void *v47;
  void *v48;
  uint64_t v49;
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  if (!mlir::tensor::__mlir_ods_local_type_constraint_TensorOps7(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0))return 0;
  if (*((_DWORD *)*this + 9))
    v4 = (uint64_t)(*this - 2);
  else
    v4 = 0;
  v43 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  Value = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v43);
  NumElements = mlir::ShapedType::getNumElements(Value, v6);
  if (*((_DWORD *)*this + 9))
    v8 = (uint64_t)(*this - 2);
  else
    v8 = 0;
  v42 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  RHS = (void *)mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v42);
  v10 = (unint64_t)RHS;
  v44 = &v47;
  v46 = 2;
  if (NumElements < 3)
  {
    if (NumElements)
    {
      v47 = RHS;
      if (NumElements != 1)
        v48 = RHS;
    }
  }
  else
  {
    v45 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, &v47, NumElements, 8);
    if (NumElements == 3)
    {
      v11 = 3;
      v12 = (unint64_t *)v44;
    }
    else
    {
      v12 = (unint64_t *)((char *)v44 + 8 * (NumElements & 0xFFFFFFFFFFFFFFFCLL));
      v11 = NumElements & 3;
      v14 = vdupq_n_s64(v10);
      v15 = (int64x2_t *)((char *)v44 + 16);
      v16 = NumElements & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v15[-1] = v14;
        *v15 = v14;
        v15 += 2;
        v16 -= 4;
      }
      while (v16);
      if (NumElements == (NumElements & 0xFFFFFFFFFFFFFFFCLL))
        goto LABEL_22;
    }
    do
    {
      *v12++ = v10;
      --v11;
    }
    while (v11);
  }
LABEL_22:
  v45 = NumElements;
  v17 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    v18 = *((unsigned int *)v17 + 17);
    v19 = v17[9];
  }
  else
  {
    v19 = 0;
    v18 = 0;
  }
  v41[0] = v19;
  v41[1] = v18;
  mlir::OperandRange::getTypes(v41, (uint64_t *)&v37);
  if (v39 - v38 != v45)
  {
    v26 = 0;
    goto LABEL_34;
  }
  if (v45)
  {
    v20 = 8 * v45 - 8;
    v21 = &v37[4 * v38 + 3];
    v22 = (uint64_t *)v44;
    do
    {
      v23 = *v21;
      v21 += 4;
      v24 = v23[1];
      v25 = *v22++;
      v26 = v25 == (v24 & 0xFFFFFFFFFFFFFFF8);
      v27 = v25 != (v24 & 0xFFFFFFFFFFFFFFF8) || v20 == 0;
      v20 -= 8;
    }
    while (!v27);
LABEL_34:
    if (v44 == &v47)
      goto LABEL_36;
    goto LABEL_35;
  }
  v26 = 1;
  if (v44 != &v47)
LABEL_35:
    free(v44);
LABEL_36:
  if (v26)
    return 1;
  v37 = (const void **)"failed to verify that operand types match result element type";
  v40 = 259;
  mlir::OpState::emitOpError(this, &v37, (uint64_t)&v44);
  v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v28 = __p;
    if (__p)
    {
      v29 = v53;
      v30 = __p;
      if (v53 != __p)
      {
        do
          v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
        while (v29 != v28);
        v30 = __p;
      }
      v53 = v28;
      operator delete(v30);
    }
    v31 = v50;
    if (v50)
    {
      v32 = v51;
      v33 = v50;
      if (v51 != v50)
      {
        do
        {
          v35 = *--v32;
          v34 = v35;
          *v32 = 0;
          if (v35)
            MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
        }
        while (v32 != v31);
        v33 = v50;
      }
      v51 = v31;
      operator delete(v33);
    }
    if (v48 != &v49)
      free(v48);
  }
  return v13;
}

uint64_t mlir::tensor::__mlir_ods_local_type_constraint_TensorOps7(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  _QWORD *Shape;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  int *v21;
  char *v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  int *v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  const void **v53;
  uint64_t v54;
  __int16 v55;
  int v56;
  const char *v57;
  uint64_t v58;
  _QWORD v59[3];
  void *v60;
  unsigned int v61;
  unsigned int v62;
  _BYTE v63[96];
  void *v64;
  _QWORD *v65;
  void *__p;
  _QWORD *v67;
  char v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  v10 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v59[0] = a2;
    v59[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v59))
    {
      Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)v59);
      if (!v12)
      {
LABEL_7:
        v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
        v53 = a2;
        v54 = v14;
        mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v53);
        return 1;
      }
      v13 = 8 * v12;
      while (*Shape != 0x8000000000000000)
      {
        ++Shape;
        v13 -= 8;
        if (!v13)
          goto LABEL_7;
      }
    }
  }
  v55 = 261;
  v53 = a3;
  v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v59);
  if (v59[0])
  {
    v56 = 3;
    v57 = " #";
    v58 = 2;
    v16 = &v56;
    v17 = (char *)v60;
    if (v61 >= v62)
    {
      v43 = v61 + 1;
      if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
      {
        v49 = (char *)&v56 - (_BYTE *)v60;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v43, 24);
        v17 = (char *)v60;
        v16 = (int *)((char *)v60 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v43, 24);
        v16 = &v56;
        v17 = (char *)v60;
      }
    }
    v18 = &v17[24 * v61];
    v19 = *(_OWORD *)v16;
    *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
    *(_OWORD *)v18 = v19;
    v20 = ++v61;
    if (v59[0])
    {
      v56 = 5;
      v57 = (const char *)a5;
      v21 = &v56;
      v22 = (char *)v60;
      if (v20 >= v62)
      {
        v44 = v20 + 1;
        v45 = (char *)v60 + 24 * v20 > (char *)&v56;
        if (v60 <= &v56 && v45)
        {
          v50 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v44, 24);
          v22 = (char *)v60;
          v21 = (int *)((char *)v60 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v44, 24);
          v21 = &v56;
          v22 = (char *)v60;
        }
      }
      v23 = &v22[24 * v61];
      v24 = *(_OWORD *)v21;
      *((_QWORD *)v23 + 2) = *((_QWORD *)v21 + 2);
      *(_OWORD *)v23 = v24;
      v25 = ++v61;
      if (v59[0])
      {
        v56 = 3;
        v57 = " must be statically shaped tensor of any type values, but got ";
        v58 = 62;
        v26 = &v56;
        v27 = (char *)v60;
        if (v25 >= v62)
        {
          v46 = v25 + 1;
          v47 = (char *)v60 + 24 * v25 > (char *)&v56;
          if (v60 <= &v56 && v47)
          {
            v51 = (char *)&v56 - (_BYTE *)v60;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v46, 24);
            v27 = (char *)v60;
            v26 = (int *)((char *)v60 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v46, 24);
            v26 = &v56;
            v27 = (char *)v60;
          }
        }
        v28 = &v27[24 * v61];
        v29 = *(_OWORD *)v26;
        *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
        *(_OWORD *)v28 = v29;
        ++v61;
        if (v59[0])
        {
          v30 = &v56;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v56, (uint64_t)a2);
          v31 = (char *)v60;
          if (v61 >= v62)
          {
            v48 = v61 + 1;
            if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
            {
              v52 = (char *)&v56 - (_BYTE *)v60;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
              v31 = (char *)v60;
              v30 = (int *)((char *)v60 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
              v30 = &v56;
              v31 = (char *)v60;
            }
          }
          v32 = &v31[24 * v61];
          v33 = *(_OWORD *)v30;
          *((_QWORD *)v32 + 2) = *((_QWORD *)v30 + 2);
          *(_OWORD *)v32 = v33;
          ++v61;
        }
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v59);
  if (v59[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
  if (v68)
  {
    v34 = __p;
    if (__p)
    {
      v35 = v67;
      v36 = __p;
      if (v67 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v67 = v34;
      operator delete(v36);
    }
    v37 = v64;
    if (v64)
    {
      v38 = v65;
      v39 = v64;
      if (v65 != v64)
      {
        do
        {
          v41 = *--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
        }
        while (v38 != v37);
        v39 = v64;
      }
      v65 = v37;
      operator delete(v39);
    }
    if (v60 != v63)
      free(v60);
  }
  return v15;
}

uint64_t mlir::tensor::FromElementsOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *Shape;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *Value;
  uint64_t v13;
  unint64_t NumElements;
  void *RHS;
  unint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  __int128 v25;
  char *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  int64x2_t v39;
  int64x2_t *v40;
  unint64_t v41;
  char v42;
  unint64_t v43;
  unint64_t v44;
  int64_t v45;
  int64_t v46;
  _QWORD v47[4];
  __int16 v48;
  _QWORD v49[3];
  void *v50;
  uint64_t v51;
  void *v52;
  void *v53;
  unsigned int v54;
  unsigned int v55;
  _BYTE v56[96];
  void *v57;
  _QWORD *v58;
  void *__p;
  _QWORD *v60;
  char v61;
  uint64_t v62[2];
  _QWORD v63[17];

  v63[16] = *MEMORY[0x24BDAC8D0];
  v62[0] = (uint64_t)v63;
  v62[1] = 0x400000000;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, v62, 0, 1, 0xFFFFFFFFLL)|| ((*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1), !(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))|| !(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1)|| (v50 = 0, !mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, &v50)))
  {
    v19 = 0;
    v20 = (void *)v62[0];
    if ((_QWORD *)v62[0] == v63)
      return v19;
    goto LABEL_42;
  }
  v5 = v50;
  if (*(_UNKNOWN **)(*(_QWORD *)v50 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || (v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v50 + 8),
        v50 = v5,
        v51 = v6,
        !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v50)))
  {
LABEL_18:
    v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v48 = 257;
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(&v50, a1, v21, v47);
    if (v50)
    {
      LODWORD(v49[0]) = 3;
      v49[1] = "'result' must be statically shaped tensor of any type values, but got ";
      v49[2] = 70;
      v22 = (char *)v49;
      v23 = (char *)v53;
      if (v54 >= v55)
      {
        v43 = v54 + 1;
        if (v53 <= v49 && (char *)v53 + 24 * v54 > (char *)v49)
        {
          v45 = (char *)v49 - (_BYTE *)v53;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v53, v56, v43, 24);
          v23 = (char *)v53;
          v22 = (char *)v53 + v45;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v53, v56, v43, 24);
          v22 = (char *)v49;
          v23 = (char *)v53;
        }
      }
      v24 = &v23[24 * v54];
      v25 = *(_OWORD *)v22;
      *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
      *(_OWORD *)v24 = v25;
      ++v54;
      if (v50)
      {
        v26 = (char *)v49;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)v49, (uint64_t)v5);
        v27 = (char *)v53;
        if (v54 >= v55)
        {
          v44 = v54 + 1;
          if (v53 <= v49 && (char *)v53 + 24 * v54 > (char *)v49)
          {
            v46 = (char *)v49 - (_BYTE *)v53;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v53, v56, v44, 24);
            v27 = (char *)v53;
            v26 = (char *)v53 + v46;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v53, v56, v44, 24);
            v26 = (char *)v49;
            v27 = (char *)v53;
          }
        }
        v28 = &v27[24 * v54];
        v29 = *(_OWORD *)v26;
        *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
        *(_OWORD *)v28 = v29;
        ++v54;
      }
    }
    v19 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v50);
    if (v50)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v50);
    if (v61)
    {
      v30 = __p;
      if (__p)
      {
        v31 = v60;
        v32 = __p;
        if (v60 != __p)
        {
          do
            v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
          while (v31 != v30);
          v32 = __p;
        }
        v60 = v30;
        operator delete(v32);
      }
      v33 = v57;
      if (v57)
      {
        v34 = v58;
        v35 = v57;
        if (v58 != v57)
        {
          do
          {
            v37 = *--v34;
            v36 = v37;
            *v34 = 0;
            if (v37)
              MEMORY[0x20BD002D4](v36, 0x1000C8077774924);
          }
          while (v34 != v33);
          v35 = v57;
        }
        v58 = v33;
        operator delete(v35);
      }
      if (v53 != v56)
        free(v53);
    }
    v20 = (void *)v62[0];
    if ((_QWORD *)v62[0] != v63)
      goto LABEL_42;
    return v19;
  }
  Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v50);
  if (v8)
  {
    v9 = 8 * v8;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v9 -= 8;
      if (!v9)
        goto LABEL_11;
    }
    goto LABEL_18;
  }
LABEL_11:
  v10 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  v47[0] = v5;
  v47[1] = v10;
  mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v47);
  v11 = *(unsigned int *)(a2 + 72);
  if (v11 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v11) = v5;
  ++*(_DWORD *)(a2 + 72);
  v47[0] = v5;
  Value = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v47);
  NumElements = mlir::ShapedType::getNumElements(Value, v13);
  v49[0] = v5;
  RHS = (void *)mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)v49);
  v16 = (unint64_t)RHS;
  v50 = &v52;
  HIDWORD(v51) = 2;
  if (NumElements < 3)
  {
    if (NumElements)
    {
      v52 = RHS;
      if (NumElements != 1)
        v53 = RHS;
    }
  }
  else
  {
    LODWORD(v51) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, &v52, NumElements, 8);
    if (NumElements == 3)
    {
      v17 = 3;
      v18 = (unint64_t *)v50;
      do
      {
LABEL_50:
        *v18++ = v16;
        --v17;
      }
      while (v17);
      goto LABEL_51;
    }
    v18 = (unint64_t *)((char *)v50 + 8 * (NumElements & 0xFFFFFFFFFFFFFFFCLL));
    v17 = NumElements & 3;
    v39 = vdupq_n_s64(v16);
    v40 = (int64x2_t *)((char *)v50 + 16);
    v41 = NumElements & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v40[-1] = v39;
      *v40 = v39;
      v40 += 2;
      v41 -= 4;
    }
    while (v41);
    if (NumElements != (NumElements & 0xFFFFFFFFFFFFFFFCLL))
      goto LABEL_50;
  }
LABEL_51:
  LODWORD(v51) = NumElements;
  v42 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>(a1, v62, (uint64_t)&v50, v4, a2 + 16);
  if (v50 != &v52)
    free(v50);
  v19 = v42 != 0;
  v20 = (void *)v62[0];
  if ((_QWORD *)v62[0] != v63)
LABEL_42:
    free(v20);
  return v19;
}

void mlir::tensor::FromElementsOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  mlir::Operation *v6;
  uint64_t v7;
  uint64_t v8;
  llvm::raw_ostream *v9;
  mlir::Operation *v10;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  llvm::raw_ostream *v16;
  _BYTE *v17;
  llvm::raw_ostream *v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t NextResultAtOffset;
  unint64_t AttrDictionary;
  void *v23;
  uint64_t v24;
  _QWORD v25[5];

  v25[4] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  v6 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    v7 = *((unsigned int *)v6 + 17);
    v8 = *((_QWORD *)v6 + 9);
  }
  else
  {
    v8 = 0;
    v7 = 0;
  }
  v9 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v23 = ", ";
  v24 = 2;
  llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v8, 0, v8, v7, (uint64_t)a2, v9, (uint64_t)&v23);
  v23 = v25;
  v24 = 0x200000000;
  v10 = *this;
  if (*((_BYTE *)*this + 47))
  {
    AttrDictionary = mlir::Operation::getAttrDictionary(v10);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::Operation *)((char *)v10 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v13, v23, v24);
  v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)v14 + 4);
  if ((unint64_t)v15 >= *((_QWORD *)v14 + 3))
  {
    llvm::raw_ostream::write(v14, 32);
  }
  else
  {
    *((_QWORD *)v14 + 4) = v15 + 1;
    *v15 = 32;
  }
  v16 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v17 = (_BYTE *)*((_QWORD *)v16 + 4);
  if (*((_BYTE **)v16 + 3) == v17)
  {
    llvm::raw_ostream::write(v16, ":", 1uLL);
  }
  else
  {
    *v17 = 58;
    ++*((_QWORD *)v16 + 4);
  }
  v18 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v19 = (_BYTE *)*((_QWORD *)v18 + 4);
  if ((unint64_t)v19 >= *((_QWORD *)v18 + 3))
  {
    llvm::raw_ostream::write(v18, 32);
  }
  else
  {
    *((_QWORD *)v18 + 4) = v19 + 1;
    *v19 = 32;
  }
  if (*((_DWORD *)*this + 9))
    v20 = (uint64_t)*this - 16;
  else
    v20 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, 0);
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v23 != v25)
    free(v23);
}

uint64_t mlir::tensor::detail::GatherOpGenericAdaptorBase::GatherOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _OWORD *v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  uint64_t Context;
  unint64_t v11[3];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_OWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v11;
  *(_OWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 40) = v8;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "tensor.gather", 13, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::tensor::GatherOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  char *v13;
  char *v14;
  __int128 v15;
  int *v16;
  char *v17;
  char *v18;
  __int128 v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  char *v39;
  char *v40;
  __int128 v41;
  _QWORD *v42;
  _QWORD *v43;
  void *v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  int *v48;
  char *v49;
  char *v50;
  __int128 v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD *v56;
  _QWORD *v57;
  void *v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  int64_t v69;
  int64_t v70;
  int64_t v71;
  int64_t v72;
  int64_t v73;
  int64_t v74;
  uint64_t v75;
  int v76;
  const char *v77;
  uint64_t v78;
  _QWORD v79[3];
  void *v80;
  unsigned int v81;
  unsigned int v82;
  _BYTE v83[96];
  void *v84;
  _QWORD *v85;
  void *__p;
  _QWORD *v87;
  char v88;
  uint64_t v89;

  v89 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v77 = "expected DictionaryAttr to set properties";
      v78 = 41;
      v28 = &v76;
      v29 = (char *)v80;
      if (v81 >= v82)
      {
        v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v69 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          v29 = (char *)v80;
          v28 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          v28 = &v76;
          v29 = (char *)v80;
        }
      }
      v30 = &v29[24 * v81];
      v31 = *(_OWORD *)v28;
      *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
      *(_OWORD *)v30 = v31;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
    if (!v88)
      return 0;
    v32 = __p;
    if (__p)
    {
      v33 = v87;
      v34 = __p;
      if (v87 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v87 = v32;
      operator delete(v34);
    }
    v23 = v84;
    if (!v84)
      goto LABEL_79;
    v35 = v85;
    v25 = v84;
    if (v85 == v84)
      goto LABEL_78;
    do
    {
      v37 = *--v35;
      v36 = v37;
      *v35 = 0;
      if (v37)
        MEMORY[0x20BD002D4](v36, 0x1000C8077774924);
    }
    while (v35 != v23);
    goto LABEL_77;
  }
  v8 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v75, "gather_dims", 0xBuLL);
  if (!v8)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v77 = "expected key entry for gather_dims in DictionaryAttr to set Properties.";
      v78 = 71;
      v38 = &v76;
      v39 = (char *)v80;
      if (v81 >= v82)
      {
        v64 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v70 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
          v39 = (char *)v80;
          v38 = (int *)((char *)v80 + v70);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
          v38 = &v76;
          v39 = (char *)v80;
        }
      }
      v40 = &v39[24 * v81];
      v41 = *(_OWORD *)v38;
      *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
      *(_OWORD *)v40 = v41;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
    if (!v88)
      return 0;
    v42 = __p;
    if (__p)
    {
      v43 = v87;
      v44 = __p;
      if (v87 != __p)
      {
        do
          v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
        while (v43 != v42);
        v44 = __p;
      }
      v87 = v42;
      operator delete(v44);
    }
    v23 = v84;
    if (!v84)
      goto LABEL_79;
    v45 = v85;
    v25 = v84;
    if (v85 == v84)
      goto LABEL_78;
    do
    {
      v47 = *--v45;
      v46 = v47;
      *v45 = 0;
      if (v47)
        MEMORY[0x20BD002D4](v46, 0x1000C8077774924);
    }
    while (v45 != v23);
    goto LABEL_77;
  }
  v9 = (uint64_t)v8;
  if (!mlir::detail::DenseArrayAttrImpl<long long>::classof(v8))
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v78 = 56;
      v48 = &v76;
      v49 = (char *)v80;
      if (v81 >= v82)
      {
        v65 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v71 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
          v49 = (char *)v80;
          v48 = (int *)((char *)v80 + v71);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
          v48 = &v76;
          v49 = (char *)v80;
        }
      }
      v50 = &v49[24 * v81];
      v51 = *(_OWORD *)v48;
      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
      *(_OWORD *)v50 = v51;
      ++v81;
      if (v79[0])
      {
        v52 = &v76;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
        v53 = (char *)v80;
        if (v81 >= v82)
        {
          v66 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            v72 = (char *)&v76 - (_BYTE *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
            v53 = (char *)v80;
            v52 = (int *)((char *)v80 + v72);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
            v52 = &v76;
            v53 = (char *)v80;
          }
        }
        v54 = &v53[24 * v81];
        v55 = *(_OWORD *)v52;
        *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
        *(_OWORD *)v54 = v55;
        ++v81;
        if (v79[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88)
      return 0;
    v56 = __p;
    if (__p)
    {
      v57 = v87;
      v58 = __p;
      if (v87 != __p)
      {
        do
          v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        v58 = __p;
      }
      v87 = v56;
      operator delete(v58);
    }
    v23 = v84;
    if (!v84)
      goto LABEL_79;
    v59 = v85;
    v25 = v84;
    if (v85 == v84)
      goto LABEL_78;
    do
    {
      v61 = *--v59;
      v60 = v61;
      *v59 = 0;
      if (v61)
        MEMORY[0x20BD002D4](v60, 0x1000C8077774924);
    }
    while (v59 != v23);
    goto LABEL_77;
  }
  *a1 = v9;
  v10 = mlir::DictionaryAttr::get((uint64_t)&v75, "unique", 6uLL);
  if (!v10)
    return 1;
  v11 = v10;
  if (*(_UNKNOWN **)(*(_QWORD *)v10 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    a1[1] = v10;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    v76 = 3;
    v78 = 51;
    v12 = &v76;
    v13 = (char *)v80;
    if (v81 >= v82)
    {
      v67 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        v73 = (char *)&v76 - (_BYTE *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
        v13 = (char *)v80;
        v12 = (int *)((char *)v80 + v73);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
        v12 = &v76;
        v13 = (char *)v80;
      }
    }
    v14 = &v13[24 * v81];
    v15 = *(_OWORD *)v12;
    *((_QWORD *)v14 + 2) = *((_QWORD *)v12 + 2);
    *(_OWORD *)v14 = v15;
    ++v81;
    if (v79[0])
    {
      v16 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v11);
      v17 = (char *)v80;
      if (v81 >= v82)
      {
        v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v74 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          v17 = (char *)v80;
          v16 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          v16 = &v76;
          v17 = (char *)v80;
        }
      }
      v18 = &v17[24 * v81];
      v19 = *(_OWORD *)v16;
      *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
      *(_OWORD *)v18 = v19;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
  }
  if (v88)
  {
    v20 = __p;
    if (__p)
    {
      v21 = v87;
      v22 = __p;
      if (v87 != __p)
      {
        do
          v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
        while (v21 != v20);
        v22 = __p;
      }
      v87 = v20;
      operator delete(v22);
    }
    v23 = v84;
    if (!v84)
      goto LABEL_79;
    v24 = v85;
    v25 = v84;
    if (v85 == v84)
    {
LABEL_78:
      v85 = v23;
      operator delete(v25);
LABEL_79:
      if (v80 != v83)
        free(v80);
      return 0;
    }
    do
    {
      v27 = *--v24;
      v26 = v27;
      *v24 = 0;
      if (v27)
        MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
    }
    while (v24 != v23);
LABEL_77:
    v25 = v84;
    goto LABEL_78;
  }
  return 0;
}

uint64_t mlir::tensor::GatherOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  mlir::MLIRContext *v10;
  uint64_t DictionaryAttr;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t *v17;
  mlir::DictionaryAttr *v18;
  void *v19;
  uint64_t v20;
  _QWORD v21[7];

  v21[6] = *MEMORY[0x24BDAC8D0];
  v18 = a1;
  v19 = v21;
  v20 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"gather_dims", 11, *a2);
    v5 = v4;
    v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      v6 = v20;
    }
    v7 = (uint64_t *)((char *)v19 + 16 * v6);
    *v7 = NamedAttr;
    v7[1] = v5;
    v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      v10 = (mlir::MLIRContext *)v19;
      if (v8)
        goto LABEL_6;
LABEL_13:
      DictionaryAttr = 0;
      if (v10 == (mlir::MLIRContext *)v21)
        return DictionaryAttr;
      goto LABEL_7;
    }
  }
  else
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_5;
  }
  v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"unique", 6, v9);
  v15 = v14;
  v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    v16 = v20;
  }
  v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *v17 = v13;
  v17[1] = v15;
  v8 = v20 + 1;
  LODWORD(v20) = v8;
  v10 = (mlir::MLIRContext *)v19;
  if (!v8)
    goto LABEL_13;
LABEL_6:
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  v10 = (mlir::MLIRContext *)v19;
  if (v19 != v21)
LABEL_7:
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::tensor::GatherOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  if (__n == 6)
  {
    if (memcmp(__s1, "unique", 6uLL))
      return 0;
    return a2[1];
  }
  else
  {
    if (__n != 11)
      return 0;
    if (*(_QWORD *)__s1 != 0x645F726568746167 || *(_QWORD *)(__s1 + 3) != 0x736D69645F726568)
      return 0;
    return *a2;
  }
}

uint64_t mlir::tensor::GatherOp::setInherentAttr(uint64_t result, char *__s1, uint64_t a3, _QWORD *a4)
{
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;

  v5 = (_QWORD *)result;
  if (a3 == 6)
  {
    result = memcmp(__s1, "unique", 6uLL);
    if (!(_DWORD)result)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
          v7 = a4;
        else
          v7 = 0;
        v5[1] = v7;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (a3 == 11 && *(_QWORD *)__s1 == 0x645F726568746167 && *(_QWORD *)(__s1 + 3) == 0x736D69645F726568)
  {
    if (a4)
    {
      result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
      if ((_DWORD)result)
        v8 = a4;
      else
        v8 = 0;
      *v5 = v8;
    }
    else
    {
      *(_QWORD *)result = 0;
    }
  }
  return result;
}

void mlir::tensor::GatherOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"gather_dims", 11, *a2);
  v5 = a2[1];
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"unique", 6, v5);
}

BOOL mlir::tensor::GatherOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  _BOOL8 result;

  v8 = (_QWORD *)mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v8, (const void **)"gather_dims", (const char *)0xB, a3, a4))
  {
    v9 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v9, (const void **)"unique", (const char *)6, a3, a4))
    {
      return 1;
    }
  }
  return result;
}

BOOL mlir::tensor::GatherOp::readProperties(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;

  v3 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::GatherOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::tensor::detail::GatherOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  uint64_t *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::GatherOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::GatherOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::GatherOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::GatherOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::tensor::detail::GatherOpGenericAdaptorBase::Properties]";
        v15 = 110;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::tensor::detail::GatherOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v5[236];
    return a1[32];
  }
  return result;
}

uint64_t mlir::tensor::GatherOp::writeProperties(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;

  if (HIBYTE(*(_DWORD *)(*(_QWORD *)a1 + 44)))
    v3 = (_QWORD *)(*(_QWORD *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1) + 64);
  else
    v3 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, *v3);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, v3[1]);
}

BOOL mlir::tensor::GatherOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t NextResultAtOffset;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  const void **v18;
  __int16 v19;
  _QWORD v20[3];
  void *v21;
  uint64_t v22;
  void *v23;
  _QWORD *v24;
  void *__p;
  _QWORD *v26;
  char v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_QWORD **)v3;
  if (*(_QWORD *)v3)
  {
    v5 = *(_QWORD *)(v3 + 8);
    v20[0] = v2;
    if (mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v4, (const void **)"gather_dims", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20)&& (v20[0] = *this, mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"unique", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20))&& mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)&& mlir::tensor::__mlir_ods_local_type_constraint_TensorOps8(
                            *this,
                            *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8,
                            (const void **)"operand",
                            (const void **)7,
                            1u))
    {
      if (*((_DWORD *)*this + 9))
        v6 = (uint64_t)(*this - 2);
      else
        v6 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
      return mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v18 = (const void **)"requires attribute 'gather_dims'";
    v19 = 259;
    mlir::OpState::emitOpError(this, &v18, (uint64_t)v20);
    v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v20);
    if (v20[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v20);
    if (v27)
    {
      v9 = __p;
      if (__p)
      {
        v10 = v26;
        v11 = __p;
        if (v26 != __p)
        {
          do
            v10 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v10 - 1);
          while (v10 != v9);
          v11 = __p;
        }
        v26 = v9;
        operator delete(v11);
      }
      v12 = v23;
      if (v23)
      {
        v13 = v24;
        v14 = v23;
        if (v24 != v23)
        {
          do
          {
            v16 = *--v13;
            v15 = v16;
            *v13 = 0;
            if (v16)
              MEMORY[0x20BD002D4](v15, 0x1000C8077774924);
          }
          while (v13 != v12);
          v14 = v23;
        }
        v24 = v12;
        operator delete(v14);
      }
      if (v21 != &v22)
        free(v21);
    }
  }
  return v8;
}

uint64_t mlir::tensor::__mlir_ods_local_type_constraint_TensorOps8(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v10;
  uint64_t v11;
  int *v12;
  char *v13;
  char *v14;
  __int128 v15;
  uint64_t v16;
  int *v17;
  char *v18;
  char *v19;
  __int128 v20;
  uint64_t v21;
  int *v22;
  char *v23;
  char *v24;
  __int128 v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v39;
  unint64_t v40;
  BOOL v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  int64_t v45;
  int64_t v46;
  int64_t v47;
  int64_t v48;
  const void **v49[4];
  __int16 v50;
  int v51;
  const char *v52;
  uint64_t v53;
  _QWORD v54[3];
  void *v55;
  unsigned int v56;
  unsigned int v57;
  _BYTE v58[96];
  void *v59;
  _QWORD *v60;
  void *__p;
  _QWORD *v62;
  char v63;
  uint64_t v64;

  v64 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)a2;
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v54[0] = a2;
    v54[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v49[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v54);
    if (mlir::Type::isSignlessIntOrIndex((mlir::Type *)v49))
      return 1;
  }
  v50 = 261;
  v49[0] = a3;
  v49[1] = a4;
  mlir::Operation::emitOpError(a1, v49, (uint64_t)v54);
  if (v54[0])
  {
    v51 = 3;
    v52 = " #";
    v53 = 2;
    v12 = &v51;
    v13 = (char *)v55;
    if (v56 >= v57)
    {
      v39 = v56 + 1;
      if (v55 <= &v51 && (char *)v55 + 24 * v56 > (char *)&v51)
      {
        v45 = (char *)&v51 - (_BYTE *)v55;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v39, 24);
        v13 = (char *)v55;
        v12 = (int *)((char *)v55 + v45);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v39, 24);
        v12 = &v51;
        v13 = (char *)v55;
      }
    }
    v14 = &v13[24 * v56];
    v15 = *(_OWORD *)v12;
    *((_QWORD *)v14 + 2) = *((_QWORD *)v12 + 2);
    *(_OWORD *)v14 = v15;
    v16 = ++v56;
    if (v54[0])
    {
      v51 = 5;
      v52 = (const char *)a5;
      v17 = &v51;
      v18 = (char *)v55;
      if (v16 >= v57)
      {
        v40 = v16 + 1;
        v41 = (char *)v55 + 24 * v16 > (char *)&v51;
        if (v55 <= &v51 && v41)
        {
          v46 = (char *)&v51 - (_BYTE *)v55;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v40, 24);
          v18 = (char *)v55;
          v17 = (int *)((char *)v55 + v46);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v40, 24);
          v17 = &v51;
          v18 = (char *)v55;
        }
      }
      v19 = &v18[24 * v56];
      v20 = *(_OWORD *)v17;
      *((_QWORD *)v19 + 2) = *((_QWORD *)v17 + 2);
      *(_OWORD *)v19 = v20;
      v21 = ++v56;
      if (v54[0])
      {
        v51 = 3;
        v52 = " must be ranked tensor of signless integer or index values, but got ";
        v53 = 68;
        v22 = &v51;
        v23 = (char *)v55;
        if (v21 >= v57)
        {
          v42 = v21 + 1;
          v43 = (char *)v55 + 24 * v21 > (char *)&v51;
          if (v55 <= &v51 && v43)
          {
            v47 = (char *)&v51 - (_BYTE *)v55;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v42, 24);
            v23 = (char *)v55;
            v22 = (int *)((char *)v55 + v47);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v42, 24);
            v22 = &v51;
            v23 = (char *)v55;
          }
        }
        v24 = &v23[24 * v56];
        v25 = *(_OWORD *)v22;
        *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
        *(_OWORD *)v24 = v25;
        ++v56;
        if (v54[0])
        {
          v26 = &v51;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v51, a2);
          v27 = (char *)v55;
          if (v56 >= v57)
          {
            v44 = v56 + 1;
            if (v55 <= &v51 && (char *)v55 + 24 * v56 > (char *)&v51)
            {
              v48 = (char *)&v51 - (_BYTE *)v55;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v44, 24);
              v27 = (char *)v55;
              v26 = (int *)((char *)v55 + v48);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v44, 24);
              v26 = &v51;
              v27 = (char *)v55;
            }
          }
          v28 = &v27[24 * v56];
          v29 = *(_OWORD *)v26;
          *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
          *(_OWORD *)v28 = v29;
          ++v56;
        }
      }
    }
  }
  v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v54);
  if (v54[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v54);
  if (v63)
  {
    v30 = __p;
    if (__p)
    {
      v31 = v62;
      v32 = __p;
      if (v62 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v62 = v30;
      operator delete(v32);
    }
    v33 = v59;
    if (v59)
    {
      v34 = v60;
      v35 = v59;
      if (v60 != v59)
      {
        do
        {
          v37 = *--v34;
          v36 = v37;
          *v34 = 0;
          if (v37)
            MEMORY[0x20BD002D4](v36, 0x1000C8077774924);
        }
        while (v34 != v33);
        v35 = v59;
      }
      v60 = v33;
      operator delete(v35);
    }
    if (v55 != v58)
      free(v55);
  }
  return v11;
}

BOOL mlir::tensor::GatherOp::parse(uint64_t *a1, _QWORD *a2)
{
  _QWORD *v4;
  mlir::UnitAttr **v5;
  mlir::MLIRContext *v6;
  uint64_t UnitAttr;
  uint64_t v8;
  uint64_t v9;
  void *Results;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t Inputs;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[2];
  _QWORD v19[2];
  uint64_t *v20;
  uint64_t *v21;
  _QWORD *v22;
  __int16 v23;
  _QWORD v24[4];
  _QWORD v25[5];

  v25[4] = *MEMORY[0x24BDAC8D0];
  memset(v25, 0, 24);
  v19[0] = v25;
  v19[1] = 1;
  memset(v24, 0, 24);
  v18[0] = v24;
  v18[1] = 1;
  v16 = 0;
  v17 = 0;
  Inputs = 0;
  (*(void (**)(uint64_t *))(*a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t *, _QWORD *, uint64_t))(*a1 + 672))(a1, v25, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t *))(*a1 + 296))(a1))
    return 0;
  (*(void (**)(uint64_t *))(*a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t *, _QWORD *, uint64_t))(*a1 + 672))(a1, v24, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t *))(*a1 + 312))(a1))
    return 0;
  v23 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t *, const char *, uint64_t, uint64_t **))(*a1 + 368))(a1, "gather_dims", 11, &v20)|| !(*(unsigned __int8 (**)(uint64_t *))(*a1 + 264))(a1)|| !mlir::AsmParser::parseCustomAttributeWithFallback<mlir::detail::DenseArrayAttrImpl<long long>>((uint64_t)a1, &v17, 0))
  {
    return 0;
  }
  if (v17)
  {
    v4 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::GatherOpGenericAdaptorBase::Properties>(a2);
    *v4 = v17;
  }
  if (!(*(unsigned __int8 (**)(uint64_t *))(*a1 + 280))(a1))
    return 0;
  if ((*(unsigned __int8 (**)(uint64_t *, const char *, uint64_t))(*a1 + 376))(a1, "unique", 6))
  {
    v5 = (mlir::UnitAttr **)(*(uint64_t (**)(uint64_t *))(*a1 + 32))(a1);
    UnitAttr = mlir::Builder::getUnitAttr(v5, v6);
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::tensor::detail::GatherOpGenericAdaptorBase::Properties>(a2)
              + 8) = UnitAttr;
  }
  v14 = (*(uint64_t (**)(uint64_t *))(*a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t *, _QWORD *))(*a1 + 456))(a1, a2 + 14))
    return 0;
  v8 = a2[1];
  v20 = a1;
  v21 = &v14;
  v22 = a2;
  if (!mlir::tensor::GatherOp::verifyInherentAttrs(v8, (uint64_t)(a2 + 14), (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::GatherOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v20))return 0;
  if (!(*(unsigned __int8 (**)(uint64_t *))(*a1 + 104))(a1))
    return 0;
  v14 = 0;
  if (!mlir::AsmParser::parseType<mlir::FunctionType>((uint64_t)a1, &v14))
    return 0;
  Inputs = mlir::FunctionType::getInputs((mlir::FunctionType *)&v14);
  v16 = v9;
  Results = (void *)mlir::FunctionType::getResults((mlir::FunctionType *)&v14);
  mlir::OperationState::addTypes((uint64_t)a2, Results, v11);
  v20 = v19;
  v21 = v18;
  v12 = (*(uint64_t (**)(uint64_t *))(*a1 + 16))(a1);
  return mlir::OpAsmParser::resolveOperands<llvm::detail::concat_range<mlir::OpAsmParser::UnresolvedOperand const,llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &>,llvm::ArrayRef<mlir::Type> &>((uint64_t)a1, &v20, &Inputs, v12, (uint64_t)(a2 + 2)) != 0;
}

uint64_t mlir::AsmParser::parseCustomAttributeWithFallback<mlir::detail::DenseArrayAttrImpl<long long>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  _QWORD *v21;
  _QWORD v22[3];
  void *v23;
  uint64_t v24;
  void *v25;
  _QWORD *v26;
  void *__p;
  _QWORD *v28;
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v21 = 0;
  v22[0] = a1;
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD **, uint64_t, BOOL (*)(mlir::AsmParser **, uint64_t *), _QWORD *))(*(_QWORD *)a1 + 416))(a1, &v21, a3, _ZN4llvm12function_refIFN4mlir11ParseResultERNS1_9AttributeENS1_4TypeEEE11callback_fnIZNS1_9AsmParser32parseCustomAttributeWithFallbackINS1_6detail18DenseArrayAttrImplIxEEEENSt3__19enable_ifIXsr23detect_has_parse_methodIT_EE5valueES2_E4typeERSG_S5_EUlS4_S5_E_EES2_lS4_S5_, v22))return 0;
  v7 = v21;
  if (mlir::detail::DenseArrayAttrImpl<long long>::classof(v21))
    v8 = v7;
  else
    v8 = 0;
  *a2 = v8;
  if (v8)
    return 1;
  v19 = "invalid kind of attribute specified";
  v20 = 259;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v22, a1, v6, &v19);
  v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v22);
  if (v22[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v22);
  if (v29)
  {
    v11 = __p;
    if (__p)
    {
      v12 = v28;
      v13 = __p;
      if (v28 != __p)
      {
        do
          v12 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v12 - 1);
        while (v12 != v11);
        v13 = __p;
      }
      v28 = v11;
      operator delete(v13);
    }
    v14 = v25;
    if (v25)
    {
      v15 = v26;
      v16 = v25;
      if (v26 != v25)
      {
        do
        {
          v18 = *--v15;
          v17 = v18;
          *v15 = 0;
          if (v18)
            MEMORY[0x20BD002D4](v17, 0x1000C8077774924);
        }
        while (v15 != v14);
        v16 = v25;
      }
      v26 = v14;
      operator delete(v16);
    }
    if (v23 != &v24)
      free(v23);
  }
  return v9;
}

void mlir::tensor::GatherOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  llvm::raw_ostream *v6;
  _BYTE *v7;
  llvm::raw_ostream *v8;
  _BYTE *v9;
  llvm::raw_ostream *v10;
  _BYTE *v11;
  llvm::raw_ostream *v12;
  uint64_t v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  _QWORD *v16;
  uint64_t v17;
  llvm::raw_ostream *v18;
  _BYTE *v19;
  unint64_t v20;
  llvm::raw_ostream *v21;
  _BYTE *v22;
  llvm::raw_ostream *v23;
  uint64_t v24;
  mlir::Operation *v25;
  mlir::ArrayAttr *v26;
  uint64_t Value;
  uint64_t v28;
  llvm::raw_ostream *v29;
  _BYTE *v30;
  llvm::raw_ostream *v31;
  _BYTE *v32;
  llvm::raw_ostream *v33;
  _BYTE *v34;
  mlir::Operation *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40[4];
  uint64_t v41[4];
  uint64_t v42[2];
  void *v43;
  uint64_t v44;
  _QWORD v45[5];

  v45[4] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 24));
  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v7 = (_BYTE *)*((_QWORD *)v6 + 4);
  if (*((_BYTE **)v6 + 3) == v7)
  {
    llvm::raw_ostream::write(v6, "[", 1uLL);
  }
  else
  {
    *v7 = 91;
    ++*((_QWORD *)v6 + 4);
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 56));
  v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v9 = (_BYTE *)*((_QWORD *)v8 + 4);
  if (*((_BYTE **)v8 + 3) == v9)
  {
    llvm::raw_ostream::write(v8, "]", 1uLL);
  }
  else
  {
    *v9 = 93;
    ++*((_QWORD *)v8 + 4);
  }
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (_BYTE *)*((_QWORD *)v10 + 4);
  if ((unint64_t)v11 >= *((_QWORD *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }
  else
  {
    *((_QWORD *)v10 + 4) = v11 + 1;
    *v11 = 32;
  }
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = *((_QWORD *)v12 + 4);
  if ((unint64_t)(*((_QWORD *)v12 + 3) - v13) > 0xA)
  {
    *(_DWORD *)(v13 + 7) = 1936550244;
    *(_QWORD *)v13 = *(_QWORD *)"gather_dims";
    *((_QWORD *)v12 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v12, "gather_dims", 0xBuLL);
  }
  v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)v14 + 4);
  if (*((_BYTE **)v14 + 3) == v15)
  {
    llvm::raw_ostream::write(v14, "(", 1uLL);
  }
  else
  {
    *v15 = 40;
    ++*((_QWORD *)v14 + 4);
  }
  v43 = (void *)*((_QWORD *)*this + 2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8);
  if (!(*(unsigned __int8 (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 104))(a2))
  {
    v16 = (_QWORD *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v17 = (*(uint64_t (**)(_QWORD *))(*v16 + 80))(v16) + v16[4] - v16[2];
    mlir::detail::DenseArrayAttrImpl<long long>::print((llvm::raw_ostream *)&v43, (uint64_t)a2);
    if (v17 == (*(uint64_t (**)(_QWORD *))(*v16 + 80))(v16) + v16[4] - v16[2])
      (*(void (**)(mlir::OpAsmPrinter *, void *))(*(_QWORD *)a2 + 40))(a2, v43);
  }
  v18 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v19 = (_BYTE *)*((_QWORD *)v18 + 4);
  if (*((_BYTE **)v18 + 3) == v19)
  {
    llvm::raw_ostream::write(v18, ")", 1uLL);
  }
  else
  {
    *v19 = 41;
    ++*((_QWORD *)v18 + 4);
  }
  v20 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v20 = 0;
  if (*(_QWORD *)(v20 + 8))
  {
    v21 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v22 = (_BYTE *)*((_QWORD *)v21 + 4);
    if ((unint64_t)v22 >= *((_QWORD *)v21 + 3))
    {
      llvm::raw_ostream::write(v21, 32);
    }
    else
    {
      *((_QWORD *)v21 + 4) = v22 + 1;
      *v22 = 32;
    }
    v23 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v24 = *((_QWORD *)v23 + 4);
    if ((unint64_t)(*((_QWORD *)v23 + 3) - v24) > 5)
    {
      *(_WORD *)(v24 + 4) = 25973;
      *(_DWORD *)v24 = 1902734965;
      *((_QWORD *)v23 + 4) += 6;
    }
    else
    {
      llvm::raw_ostream::write(v23, "unique", 6uLL);
    }
  }
  v43 = v45;
  v45[0] = "gather_dims";
  v45[1] = 11;
  v45[2] = "unique";
  v45[3] = 6;
  v44 = 0x200000002;
  mlir::Attribute::getContext((mlir::Operation *)((char *)*this + 24));
  v25 = *this;
  if (*((_BYTE *)*this + 47))
  {
    v41[0] = mlir::Operation::getAttrDictionary(v25);
    v26 = (mlir::ArrayAttr *)v41;
  }
  else
  {
    v26 = (mlir::Operation *)((char *)v25 + 56);
  }
  Value = mlir::ArrayAttr::getValue(v26);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v28, v43, v44);
  v29 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v30 = (_BYTE *)*((_QWORD *)v29 + 4);
  if ((unint64_t)v30 >= *((_QWORD *)v29 + 3))
  {
    llvm::raw_ostream::write(v29, 32);
  }
  else
  {
    *((_QWORD *)v29 + 4) = v30 + 1;
    *v30 = 32;
  }
  v31 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v32 = (_BYTE *)*((_QWORD *)v31 + 4);
  if (*((_BYTE **)v31 + 3) == v32)
  {
    llvm::raw_ostream::write(v31, ":", 1uLL);
  }
  else
  {
    *v32 = 58;
    ++*((_QWORD *)v31 + 4);
  }
  v33 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v34 = (_BYTE *)*((_QWORD *)v33 + 4);
  if ((unint64_t)v34 >= *((_QWORD *)v33 + 3))
  {
    llvm::raw_ostream::write(v33, 32);
  }
  else
  {
    *((_QWORD *)v33 + 4) = v34 + 1;
    *v34 = 32;
  }
  v35 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    v36 = *((_QWORD *)v35 + 9);
    v37 = *((unsigned int *)v35 + 17);
  }
  else
  {
    v36 = 0;
    v37 = 0;
  }
  v40[0] = v36;
  v40[1] = v37;
  mlir::OperandRange::getTypes(v40, v41);
  v38 = *((unsigned int *)*this + 9);
  v39 = (uint64_t)*this - 16;
  if (!(_DWORD)v38)
    v39 = 0;
  v42[0] = v39;
  v42[1] = v38;
  mlir::OperandRange::getTypes(v42, v40);
  mlir::AsmPrinter::printFunctionalType<mlir::ValueTypeRange<mlir::OperandRange>,mlir::ValueTypeRange<mlir::ResultRange>>((uint64_t)a2, v41, v40);
  if (v43 != v45)
    free(v43);
}

BOOL mlir::tensor::GenerateOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t NextResultAtOffset;

  v2 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0 && (v3 = *((unsigned int *)v2 + 17), (_DWORD)v3))
  {
    v4 = 0;
    v5 = v2[9] + 24;
    while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v5 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v4))
    {
      ++v4;
      v5 += 32;
      if (v3 == v4)
      {
        v2 = *this;
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    v6 = *((_DWORD *)v2 + 9);
    v7 = v2 - 2;
    if (v6)
      v8 = (uint64_t)v7;
    else
      v8 = 0;
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0);
    if (mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0))return mlir::scf::__mlir_ods_local_region_constraint_SCFOps1(*this, (((unint64_t)&(*this)[2* (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)+ 8]+ (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)*this + 10), (uint64_t)"body", 4, 0) != 0;
  }
  return 0;
}

uint64_t mlir::tensor::GenerateOp::parse(uint64_t a1, uint64_t a2)
{
  mlir::Region *v4;
  _QWORD *v5;
  uint64_t v6;
  mlir::IndexType **v7;
  mlir::MLIRContext *v8;
  uint64_t IndexType;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  mlir::Region *v15;
  uint64_t v17;
  mlir::Region *v18;
  void *v19;
  uint64_t v20;
  _QWORD v21[17];

  v21[16] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  v4 = (mlir::Region *)operator new();
  *(_QWORD *)v4 = v4;
  *((_QWORD *)v4 + 1) = v4;
  *((_QWORD *)v4 + 2) = 0;
  v18 = v4;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void **, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, &v19, 0, 1, 0xFFFFFFFFLL))goto LABEL_13;
  if (!(*(unsigned __int8 (**)(uint64_t, mlir::Region *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 744))(a1, v4, 0, 0, 0))goto LABEL_13;
  v5 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  mlir::impl::ensureRegionTerminator(v4, v5, *(_QWORD *)a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t))llvm::function_ref<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>::callback_fn<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>, (uint64_t)mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl<mlir::tensor::GenerateOp>::buildTerminator);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    goto LABEL_13;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    goto LABEL_13;
  v17 = 0;
  if (!mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, &v17))
    goto LABEL_13;
  v6 = v17;
  mlir::OperationState::addRegion(a2, (unint64_t)&v18);
  v7 = (mlir::IndexType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  IndexType = mlir::Builder::getIndexType(v7, v8);
  v10 = *(unsigned int *)(a2 + 72);
  if (v10 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v10 + 1, 8);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v10) = v6;
  ++*(_DWORD *)(a2 + 72);
  if ((_DWORD)v20)
  {
    v11 = a2 + 16;
    v12 = (char *)v19;
    v13 = 32 * v20;
    v14 = 1;
    while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v12, IndexType, v11))
    {
      v12 += 32;
      v13 -= 32;
      if (!v13)
        goto LABEL_14;
    }
LABEL_13:
    v14 = 0;
LABEL_14:
    v15 = v18;
    v18 = 0;
    if (v15)
      goto LABEL_15;
    goto LABEL_16;
  }
  v14 = 1;
  v15 = v18;
  v18 = 0;
  if (v15)
  {
LABEL_15:
    mlir::Region::~Region(v15);
    MEMORY[0x20BD002F8]();
  }
LABEL_16:
  if (v19 != v21)
    free(v19);
  return v14;
}

void mlir::tensor::GenerateOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  mlir::Operation *v6;
  uint64_t v7;
  uint64_t v8;
  llvm::raw_ostream *v9;
  llvm::raw_ostream *v10;
  _BYTE *v11;
  _QWORD *v12;
  uint64_t v13;
  ZinIrHalH13g **v14;
  mlir::Operation *v15;
  mlir::Operation *v16;
  _BOOL8 v17;
  mlir::Operation *v18;
  mlir::ArrayAttr *v19;
  uint64_t Value;
  uint64_t v21;
  llvm::raw_ostream *v22;
  _BYTE *v23;
  llvm::raw_ostream *v24;
  _BYTE *v25;
  llvm::raw_ostream *v26;
  _BYTE *v27;
  uint64_t v28;
  uint64_t NextResultAtOffset;
  unint64_t v30;
  void *AttrDictionary;
  uint64_t v32;
  _QWORD v33[5];

  v33[4] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  v6 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    v7 = *((unsigned int *)v6 + 17);
    v8 = *((_QWORD *)v6 + 9);
  }
  else
  {
    v8 = 0;
    v7 = 0;
  }
  v9 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  AttrDictionary = ", ";
  v32 = 2;
  llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v8, 0, v8, v7, (uint64_t)a2, v9, (uint64_t)&AttrDictionary);
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (_BYTE *)*((_QWORD *)v10 + 4);
  if ((unint64_t)v11 >= *((_QWORD *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }
  else
  {
    *((_QWORD *)v10 + 4) = v11 + 1;
    *v11 = 32;
  }
  v12 = (_QWORD *)((((unint64_t)*this
                   + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)
                   + (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *((unsigned int *)*this + 10));
  v17 = (_QWORD *)*v12 == v12
     || ((v13 = v12[1]) != 0 ? (v14 = (ZinIrHalH13g **)(v13 - 8)) : (v14 = 0),
         (mlir::Block::getTerminator(v14), !v15)
      || (v16 = v15,
          AttrDictionary = (void *)mlir::Operation::getAttrDictionary(v15),
          mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&AttrDictionary))
      || (*((_BYTE *)v16 + 46) & 0x80) != 0 && *((_DWORD *)v16 + 17))
     || *((_DWORD *)v16 + 9) != 0;
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t, uint64_t, _BOOL8, _QWORD))(*(_QWORD *)a2 + 224))(a2, (((unint64_t)*this+ 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)+ (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)*this + 10), 1, v17, 0);
  AttrDictionary = v33;
  v32 = 0x200000000;
  v18 = *this;
  if (*((_BYTE *)*this + 47))
  {
    v30 = mlir::Operation::getAttrDictionary(v18);
    v19 = (mlir::ArrayAttr *)&v30;
  }
  else
  {
    v19 = (mlir::Operation *)((char *)v18 + 56);
  }
  Value = mlir::ArrayAttr::getValue(v19);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v21, AttrDictionary, v32);
  v22 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v23 = (_BYTE *)*((_QWORD *)v22 + 4);
  if ((unint64_t)v23 >= *((_QWORD *)v22 + 3))
  {
    llvm::raw_ostream::write(v22, 32);
  }
  else
  {
    *((_QWORD *)v22 + 4) = v23 + 1;
    *v23 = 32;
  }
  v24 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v25 = (_BYTE *)*((_QWORD *)v24 + 4);
  if (*((_BYTE **)v24 + 3) == v25)
  {
    llvm::raw_ostream::write(v24, ":", 1uLL);
  }
  else
  {
    *v25 = 58;
    ++*((_QWORD *)v24 + 4);
  }
  v26 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v27 = (_BYTE *)*((_QWORD *)v26 + 4);
  if ((unint64_t)v27 >= *((_QWORD *)v26 + 3))
  {
    llvm::raw_ostream::write(v26, 32);
  }
  else
  {
    *((_QWORD *)v26 + 4) = v27 + 1;
    *v27 = 32;
  }
  if (*((_DWORD *)*this + 9))
    v28 = (uint64_t)*this - 16;
  else
    v28 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v28, 0);
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
  if (AttrDictionary != v33)
    free(AttrDictionary);
}

uint64_t mlir::tensor::detail::InsertOpGenericAdaptorBase::InsertOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  v5 = a2[11];
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "tensor.insert", 13, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::tensor::InsertOp::getDestMutable(mlir::tensor::InsertOp *this)
{
  return *(_QWORD *)(*(_QWORD *)this + 72) + 32;
}

uint64_t mlir::tensor::InsertOp::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x24BDAC8D0];
  v14[0] = a4;
  v14[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(_QWORD **)a11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 1) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::tensor::InsertOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t NextResultAtOffset;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  const void **v30[4];
  __int16 v31;
  _QWORD v32[3];
  void *v33;
  uint64_t v34;
  void *v35;
  _QWORD *v36;
  void *__p;
  _QWORD *v38;
  char v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  if (!mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))return 0;
  v2 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) == 0)
  {
    v4 = -2;
    v5 = 64;
LABEL_5:
    v6 = 0;
    v7 = v5 + 24;
    while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v7 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, (int)v6 + 2))
    {
      ++v6;
      v7 += 32;
      if (v4 == v6)
      {
        v2 = *this;
        goto LABEL_9;
      }
    }
    return 0;
  }
  v3 = *((unsigned int *)v2 + 17);
  v4 = v3 - 2;
  if (v3 != 2)
  {
    v5 = v2[9] + 64;
    goto LABEL_5;
  }
LABEL_9:
  v8 = *((_DWORD *)v2 + 9);
  v9 = v2 - 2;
  v10 = v8 ? (uint64_t)v9 : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0);
  if (!mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0))return 0;
  if (*((_DWORD *)*this + 9))
    v13 = (uint64_t)(*this - 2);
  else
    v13 = 0;
  v12 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (v12 == (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v13, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    v32[0] = *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
    if (mlir::TensorType::getElementType((mlir::TensorType *)v32) == (*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
      return 1;
    v30[0] = (const void **)"failed to verify that scalar type matches element type of dest";
    v31 = 259;
    mlir::OpState::emitOpError(this, v30, (uint64_t)v32);
    v14 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v32);
    if (v32[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v32);
    if (v39)
    {
      v23 = __p;
      if (__p)
      {
        v24 = v38;
        v25 = __p;
        if (v38 != __p)
        {
          do
            v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
          while (v24 != v23);
          v25 = __p;
        }
        v38 = v23;
        operator delete(v25);
      }
      v18 = v35;
      if (!v35)
        goto LABEL_49;
      v26 = v36;
      v20 = v35;
      if (v36 == v35)
        goto LABEL_48;
      do
      {
        v28 = *--v26;
        v27 = v28;
        *v26 = 0;
        if (v28)
          MEMORY[0x20BD002D4](v27, 0x1000C8077774924);
      }
      while (v26 != v18);
      goto LABEL_47;
    }
  }
  else
  {
    v30[0] = (const void **)"failed to verify that result type matches type of dest";
    v31 = 259;
    mlir::OpState::emitOpError(this, v30, (uint64_t)v32);
    v14 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v32);
    if (v32[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v32);
    if (v39)
    {
      v15 = __p;
      if (__p)
      {
        v16 = v38;
        v17 = __p;
        if (v38 != __p)
        {
          do
            v16 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v16 - 1);
          while (v16 != v15);
          v17 = __p;
        }
        v38 = v15;
        operator delete(v17);
      }
      v18 = v35;
      if (!v35)
        goto LABEL_49;
      v19 = v36;
      v20 = v35;
      if (v36 == v35)
      {
LABEL_48:
        v36 = v18;
        operator delete(v20);
LABEL_49:
        if (v33 != &v34)
          free(v33);
        return v14;
      }
      do
      {
        v22 = *--v19;
        v21 = v22;
        *v19 = 0;
        if (v22)
          MEMORY[0x20BD002D4](v21, 0x1000C8077774924);
      }
      while (v19 != v18);
LABEL_47:
      v20 = v35;
      goto LABEL_48;
    }
  }
  return v14;
}

uint64_t mlir::tensor::InsertOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  mlir::IndexType **v12;
  mlir::MLIRContext *v13;
  uint64_t IndexType;
  uint64_t ElementType;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  _WORD v20[20];
  uint64_t v21;
  _QWORD v22[2];
  uint64_t v23[2];
  _QWORD v24[4];
  __int16 v25;
  uint64_t __src;
  void *v27;
  uint64_t v28;
  _BYTE v29[128];
  _QWORD v30[4];
  _QWORD v31[5];

  v31[4] = *MEMORY[0x24BDAC8D0];
  memset(v31, 0, 24);
  memset(v30, 0, 24);
  v23[0] = (uint64_t)v30;
  v23[1] = 1;
  __src = 0;
  v27 = v29;
  v28 = 0x400000000;
  v22[0] = &__src;
  v22[1] = 1;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v31, 1))
  {
    v25 = 257;
    if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 368))(a1, "into", 4, v24))
    {
      v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
      if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v30, 1))
      {
        if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 296))(a1))
        {
          (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
          if ((*(unsigned __int8 (**)(uint64_t, void **, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, &v27, 0, 1, 0xFFFFFFFFLL))
          {
            if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 312))(a1))
            {
              (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
              if ((*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
              {
                if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
                {
                  v24[0] = 0;
                  if (mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, v24))
                  {
                    v5 = v24[0];
                    __src = v24[0];
                    v21 = v24[0];
                    if (*(_UNKNOWN **)(*(_QWORD *)v24[0] + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
                    {
                      v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
                      v20[16] = 257;
                      (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, _WORD *))(*(_QWORD *)a1 + 24))(v24, a1, v6, v20);
                      v7 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v24, "'dest' must be ranked tensor of any type values, but got ");
                      v8 = mlir::InFlightDiagnostic::append<mlir::Type &>(v7, &v21);
                      v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v8);
                      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v24);
                      v10 = v27;
                      if (v27 == v29)
                        return v9;
                      goto LABEL_22;
                    }
                    v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v24[0] + 8);
                    v24[0] = v5;
                    v24[1] = v11;
                    mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v24);
                    v12 = (mlir::IndexType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
                    IndexType = mlir::Builder::getIndexType(v12, v13);
                    mlir::OperationState::addTypes(a2, &__src, 1);
                    v24[0] = __src;
                    ElementType = mlir::TensorType::getElementType((mlir::TensorType *)v24);
                    v16 = a2 + 16;
                    if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v31, ElementType, v16))
                    {
                      if (mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v23, v22, v4, v16))
                      {
                        if (!(_DWORD)v28)
                        {
                          v9 = 1;
                          v10 = v27;
                          if (v27 == v29)
                            return v9;
                          goto LABEL_22;
                        }
                        v17 = (char *)v27;
                        v18 = 32 * v28;
                        v9 = 1;
                        while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v17, IndexType, v16))
                        {
                          v17 += 32;
                          v18 -= 32;
                          if (!v18)
                            goto LABEL_21;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v9 = 0;
LABEL_21:
  v10 = v27;
  if (v27 != v29)
LABEL_22:
    free(v10);
  return v9;
}

void mlir::tensor::InsertOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  llvm::raw_ostream *v6;
  _BYTE *v7;
  llvm::raw_ostream *v8;
  _DWORD *v9;
  llvm::raw_ostream *v10;
  _BYTE *v11;
  llvm::raw_ostream *v12;
  _BYTE *v13;
  mlir::Operation *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  llvm::raw_ostream *v19;
  llvm::raw_ostream *v20;
  _BYTE *v21;
  mlir::Operation *v22;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v25;
  llvm::raw_ostream *v26;
  _BYTE *v27;
  llvm::raw_ostream *v28;
  _BYTE *v29;
  llvm::raw_ostream *v30;
  _BYTE *v31;
  unint64_t AttrDictionary;
  void *v33;
  uint64_t v34;
  _QWORD v35[5];

  v35[4] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 24));
  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v7 = (_BYTE *)*((_QWORD *)v6 + 4);
  if ((unint64_t)v7 >= *((_QWORD *)v6 + 3))
  {
    llvm::raw_ostream::write(v6, 32);
  }
  else
  {
    *((_QWORD *)v6 + 4) = v7 + 1;
    *v7 = 32;
  }
  v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v9 = (_DWORD *)*((_QWORD *)v8 + 4);
  if (*((_QWORD *)v8 + 3) - (_QWORD)v9 > 3uLL)
  {
    *v9 = 1869901417;
    *((_QWORD *)v8 + 4) += 4;
  }
  else
  {
    llvm::raw_ostream::write(v8, "into", 4uLL);
  }
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (_BYTE *)*((_QWORD *)v10 + 4);
  if ((unint64_t)v11 >= *((_QWORD *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }
  else
  {
    *((_QWORD *)v10 + 4) = v11 + 1;
    *v11 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 56));
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)v12 + 4);
  if (*((_BYTE **)v12 + 3) == v13)
  {
    llvm::raw_ostream::write(v12, "[", 1uLL);
    v14 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
      goto LABEL_15;
  }
  else
  {
    *v13 = 91;
    ++*((_QWORD *)v12 + 4);
    v14 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
    {
LABEL_15:
      v15 = *((unsigned int *)v14 + 17);
      v16 = *((_QWORD *)v14 + 9);
      v17 = v15 - 2;
      goto LABEL_16;
    }
  }
  v16 = 0;
  v17 = -2;
LABEL_16:
  v18 = v16 + 64;
  v19 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v33 = ", ";
  v34 = 2;
  llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v18, 0, v18, v17, (uint64_t)a2, v19, (uint64_t)&v33);
  v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v21 = (_BYTE *)*((_QWORD *)v20 + 4);
  if (*((_BYTE **)v20 + 3) == v21)
  {
    llvm::raw_ostream::write(v20, "]", 1uLL);
  }
  else
  {
    *v21 = 93;
    ++*((_QWORD *)v20 + 4);
  }
  v33 = v35;
  v34 = 0x200000000;
  v22 = *this;
  if (*((_BYTE *)*this + 47))
  {
    AttrDictionary = mlir::Operation::getAttrDictionary(v22);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::Operation *)((char *)v22 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v25, v33, v34);
  v26 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v27 = (_BYTE *)*((_QWORD *)v26 + 4);
  if ((unint64_t)v27 >= *((_QWORD *)v26 + 3))
  {
    llvm::raw_ostream::write(v26, 32);
  }
  else
  {
    *((_QWORD *)v26 + 4) = v27 + 1;
    *v27 = 32;
  }
  v28 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v29 = (_BYTE *)*((_QWORD *)v28 + 4);
  if (*((_BYTE **)v28 + 3) == v29)
  {
    llvm::raw_ostream::write(v28, ":", 1uLL);
  }
  else
  {
    *v29 = 58;
    ++*((_QWORD *)v28 + 4);
  }
  v30 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v31 = (_BYTE *)*((_QWORD *)v30 + 4);
  if ((unint64_t)v31 >= *((_QWORD *)v30 + 3))
  {
    llvm::raw_ostream::write(v30, 32);
  }
  else
  {
    *((_QWORD *)v30 + 4) = v31 + 1;
    *v31 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(*(_QWORD *)(*((_QWORD *)*this + 9) + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v33 != v35)
    free(v33);
}

uint64_t mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::InsertSliceOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  __int128 *v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t Context;
  unint64_t v12[3];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (__int128 *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v12, v7, v6);
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *v5;
  v9 = v5[1];
  *(_OWORD *)(a1 + 56) = v5[2];
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)v12;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "tensor.insert_slice", 19, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::tensor::InsertSliceOp::getStrides(mlir::tensor::InsertSliceOp *this)
{
  unint64_t v1;
  _DWORD *v2;
  uint64_t v3;

  v1 = *(unsigned int *)(*(_QWORD *)this + 44);
  if (HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v2 = (_DWORD *)(*(_QWORD *)this + 16 * ((v1 >> 23) & 1) + 64);
  else
    v2 = 0;
  if ((v1 & 0x800000) != 0)
    v3 = *(_QWORD *)(*(_QWORD *)this + 72);
  else
    v3 = 0;
  return v3 + 32 * (v2[9] + v2[8] + v2[7] + v2[6]);
}

uint64_t mlir::tensor::InsertSliceOp::getDestMutable(mlir::tensor::InsertSliceOp *this)
{
  unint64_t v1;

  if (HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  else
    v1 = 0;
  return *(_QWORD *)(*(_QWORD *)this + 72) + 32 * *(unsigned int *)(v1 + 24);
}

BOOL mlir::tensor::InsertSliceOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  int *v16;
  char *v17;
  char *v18;
  __int128 v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  char *v39;
  char *v40;
  __int128 v41;
  int *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD *v56;
  _QWORD *v57;
  void *v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  int *v62;
  char *v63;
  char *v64;
  __int128 v65;
  int *v66;
  char *v67;
  char *v68;
  __int128 v69;
  _QWORD *v70;
  _QWORD *v71;
  void *v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  int *v76;
  char *v77;
  char *v78;
  __int128 v79;
  _QWORD *v80;
  _QWORD *v81;
  void *v82;
  _QWORD *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  int64_t v95;
  int64_t v96;
  int64_t v97;
  int64_t v98;
  int64_t v99;
  int64_t v100;
  int64_t v101;
  int64_t v102;
  _QWORD *v103;
  uint64_t v104;
  int v105;
  const char *v106;
  uint64_t v107;
  _QWORD v108[3];
  void *v109;
  unsigned int v110;
  unsigned int v111;
  _BYTE v112[96];
  void *v113;
  _QWORD *v114;
  void *__p;
  _QWORD *v116;
  char v117;
  uint64_t v118;

  v118 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v104 = v6;
  if (!v6)
  {
    a3(v108, a4);
    if (v108[0])
    {
      v105 = 3;
      v106 = "expected DictionaryAttr to set properties";
      v107 = 41;
      v16 = &v105;
      v17 = (char *)v109;
      if (v110 >= v111)
      {
        v87 = v110 + 1;
        if (v109 <= &v105 && (char *)v109 + 24 * v110 > (char *)&v105)
        {
          v95 = (char *)&v105 - (_BYTE *)v109;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v87, 24);
          v17 = (char *)v109;
          v16 = (int *)((char *)v109 + v95);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v87, 24);
          v16 = &v105;
          v17 = (char *)v109;
        }
      }
      v18 = &v17[24 * v110];
      v19 = *(_OWORD *)v16;
      *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
      *(_OWORD *)v18 = v19;
      ++v110;
      if (v108[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v108);
    }
    if (!v117)
      return 0;
    v20 = __p;
    if (__p)
    {
      v21 = v116;
      v22 = __p;
      if (v116 != __p)
      {
        do
          v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
        while (v21 != v20);
        v22 = __p;
      }
      v116 = v20;
      operator delete(v22);
    }
    v23 = v113;
    if (!v113)
      goto LABEL_117;
    v24 = v114;
    v25 = v113;
    if (v114 == v113)
    {
LABEL_116:
      v114 = v23;
      operator delete(v25);
LABEL_117:
      if (v109 != v112)
        free(v109);
      return 0;
    }
    do
    {
      v27 = *--v24;
      v26 = v27;
      *v24 = 0;
      if (v27)
        MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
    }
    while (v24 != v23);
LABEL_115:
    v25 = v113;
    goto LABEL_116;
  }
  v8 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v104, "static_offsets", 0xEuLL);
  if (!v8)
  {
    a3(v108, a4);
    if (v108[0])
    {
      v105 = 3;
      v106 = "expected key entry for static_offsets in DictionaryAttr to set Properties.";
      v107 = 74;
      v28 = &v105;
      v29 = (char *)v109;
      if (v110 >= v111)
      {
        v88 = v110 + 1;
        if (v109 <= &v105 && (char *)v109 + 24 * v110 > (char *)&v105)
        {
          v96 = (char *)&v105 - (_BYTE *)v109;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v88, 24);
          v29 = (char *)v109;
          v28 = (int *)((char *)v109 + v96);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v88, 24);
          v28 = &v105;
          v29 = (char *)v109;
        }
      }
      v30 = &v29[24 * v110];
      v31 = *(_OWORD *)v28;
      *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
      *(_OWORD *)v30 = v31;
      ++v110;
      if (v108[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v108);
    }
    if (!v117)
      return 0;
    v32 = __p;
    if (__p)
    {
      v33 = v116;
      v34 = __p;
      if (v116 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v116 = v32;
      operator delete(v34);
    }
    v23 = v113;
    if (!v113)
      goto LABEL_117;
    v35 = v114;
    v25 = v113;
    if (v114 == v113)
      goto LABEL_116;
    do
    {
      v37 = *--v35;
      v36 = v37;
      *v35 = 0;
      if (v37)
        MEMORY[0x20BD002D4](v36, 0x1000C8077774924);
    }
    while (v35 != v23);
    goto LABEL_115;
  }
  v9 = (uint64_t)v8;
  if (!mlir::detail::DenseArrayAttrImpl<long long>::classof(v8))
  {
    a3(v108, a4);
    if (v108[0])
    {
      v105 = 3;
      v107 = 59;
      v38 = &v105;
      v39 = (char *)v109;
      if (v110 >= v111)
      {
        v89 = v110 + 1;
        if (v109 <= &v105 && (char *)v109 + 24 * v110 > (char *)&v105)
        {
          v97 = (char *)&v105 - (_BYTE *)v109;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v89, 24);
          v39 = (char *)v109;
          v38 = (int *)((char *)v109 + v97);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v89, 24);
          v38 = &v105;
          v39 = (char *)v109;
        }
      }
      v40 = &v39[24 * v110];
      v41 = *(_OWORD *)v38;
      *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
      *(_OWORD *)v40 = v41;
      ++v110;
      if (v108[0])
      {
        v42 = &v105;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v105, v9);
        v43 = (char *)v109;
        if (v110 >= v111)
        {
          v90 = v110 + 1;
          if (v109 <= &v105 && (char *)v109 + 24 * v110 > (char *)&v105)
          {
            v98 = (char *)&v105 - (_BYTE *)v109;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v90, 24);
            v43 = (char *)v109;
            v42 = (int *)((char *)v109 + v98);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v90, 24);
            v42 = &v105;
            v43 = (char *)v109;
          }
        }
        v44 = &v43[24 * v110];
        v45 = *(_OWORD *)v42;
        *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
        *(_OWORD *)v44 = v45;
        ++v110;
        if (v108[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v108);
      }
    }
    if (!v117)
      return 0;
    v46 = __p;
    if (__p)
    {
      v47 = v116;
      v48 = __p;
      if (v116 != __p)
      {
        do
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        v48 = __p;
      }
      v116 = v46;
      operator delete(v48);
    }
    v23 = v113;
    if (!v113)
      goto LABEL_117;
    v49 = v114;
    v25 = v113;
    if (v114 == v113)
      goto LABEL_116;
    do
    {
      v51 = *--v49;
      v50 = v51;
      *v49 = 0;
      if (v51)
        MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
    }
    while (v49 != v23);
    goto LABEL_115;
  }
  *a1 = v9;
  v10 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v104, "static_sizes", 0xCuLL);
  if (!v10)
  {
    a3(v108, a4);
    if (v108[0])
    {
      v105 = 3;
      v106 = "expected key entry for static_sizes in DictionaryAttr to set Properties.";
      v107 = 72;
      v52 = &v105;
      v53 = (char *)v109;
      if (v110 >= v111)
      {
        v91 = v110 + 1;
        if (v109 <= &v105 && (char *)v109 + 24 * v110 > (char *)&v105)
        {
          v99 = (char *)&v105 - (_BYTE *)v109;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v91, 24);
          v53 = (char *)v109;
          v52 = (int *)((char *)v109 + v99);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v91, 24);
          v52 = &v105;
          v53 = (char *)v109;
        }
      }
      v54 = &v53[24 * v110];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
      *(_OWORD *)v54 = v55;
      ++v110;
      if (v108[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v108);
    }
    if (!v117)
      return 0;
    v56 = __p;
    if (__p)
    {
      v57 = v116;
      v58 = __p;
      if (v116 != __p)
      {
        do
          v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        v58 = __p;
      }
      v116 = v56;
      operator delete(v58);
    }
    v23 = v113;
    if (!v113)
      goto LABEL_117;
    v59 = v114;
    v25 = v113;
    if (v114 == v113)
      goto LABEL_116;
    do
    {
      v61 = *--v59;
      v60 = v61;
      *v59 = 0;
      if (v61)
        MEMORY[0x20BD002D4](v60, 0x1000C8077774924);
    }
    while (v59 != v23);
    goto LABEL_115;
  }
  v11 = (uint64_t)v10;
  if (!mlir::detail::DenseArrayAttrImpl<long long>::classof(v10))
  {
    a3(v108, a4);
    if (v108[0])
    {
      v105 = 3;
      v107 = 57;
      v62 = &v105;
      v63 = (char *)v109;
      if (v110 >= v111)
      {
        v92 = v110 + 1;
        if (v109 <= &v105 && (char *)v109 + 24 * v110 > (char *)&v105)
        {
          v100 = (char *)&v105 - (_BYTE *)v109;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v92, 24);
          v63 = (char *)v109;
          v62 = (int *)((char *)v109 + v100);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v92, 24);
          v62 = &v105;
          v63 = (char *)v109;
        }
      }
      v64 = &v63[24 * v110];
      v65 = *(_OWORD *)v62;
      *((_QWORD *)v64 + 2) = *((_QWORD *)v62 + 2);
      *(_OWORD *)v64 = v65;
      ++v110;
      if (v108[0])
      {
        v66 = &v105;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v105, v11);
        v67 = (char *)v109;
        if (v110 >= v111)
        {
          v93 = v110 + 1;
          if (v109 <= &v105 && (char *)v109 + 24 * v110 > (char *)&v105)
          {
            v101 = (char *)&v105 - (_BYTE *)v109;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v93, 24);
            v67 = (char *)v109;
            v66 = (int *)((char *)v109 + v101);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v93, 24);
            v66 = &v105;
            v67 = (char *)v109;
          }
        }
        v68 = &v67[24 * v110];
        v69 = *(_OWORD *)v66;
        *((_QWORD *)v68 + 2) = *((_QWORD *)v66 + 2);
        *(_OWORD *)v68 = v69;
        ++v110;
        if (v108[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v108);
      }
    }
    if (!v117)
      return 0;
    v70 = __p;
    if (__p)
    {
      v71 = v116;
      v72 = __p;
      if (v116 != __p)
      {
        do
          v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
        while (v71 != v70);
        v72 = __p;
      }
      v116 = v70;
      operator delete(v72);
    }
    v23 = v113;
    if (!v113)
      goto LABEL_117;
    v73 = v114;
    v25 = v113;
    if (v114 == v113)
      goto LABEL_116;
    do
    {
      v75 = *--v73;
      v74 = v75;
      *v73 = 0;
      if (v75)
        MEMORY[0x20BD002D4](v74, 0x1000C8077774924);
    }
    while (v73 != v23);
    goto LABEL_115;
  }
  a1[1] = v11;
  v12 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v104, "static_strides", 0xEuLL);
  v103 = v12;
  if (!v12)
  {
    a3(v108, a4);
    if (v108[0])
    {
      v105 = 3;
      v106 = "expected key entry for static_strides in DictionaryAttr to set Properties.";
      v107 = 74;
      v76 = &v105;
      v77 = (char *)v109;
      if (v110 >= v111)
      {
        v94 = v110 + 1;
        if (v109 <= &v105 && (char *)v109 + 24 * v110 > (char *)&v105)
        {
          v102 = (char *)&v105 - (_BYTE *)v109;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v94, 24);
          v77 = (char *)v109;
          v76 = (int *)((char *)v109 + v102);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v94, 24);
          v76 = &v105;
          v77 = (char *)v109;
        }
      }
      v78 = &v77[24 * v110];
      v79 = *(_OWORD *)v76;
      *((_QWORD *)v78 + 2) = *((_QWORD *)v76 + 2);
      *(_OWORD *)v78 = v79;
      ++v110;
      if (v108[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v108);
    }
    if (!v117)
      return 0;
    v80 = __p;
    if (__p)
    {
      v81 = v116;
      v82 = __p;
      if (v116 != __p)
      {
        do
          v81 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v81 - 1);
        while (v81 != v80);
        v82 = __p;
      }
      v116 = v80;
      operator delete(v82);
    }
    v23 = v113;
    if (!v113)
      goto LABEL_117;
    v83 = v114;
    v25 = v113;
    if (v114 == v113)
      goto LABEL_116;
    do
    {
      v85 = *--v83;
      v84 = v85;
      *v83 = 0;
      if (v85)
        MEMORY[0x20BD002D4](v84, 0x1000C8077774924);
    }
    while (v83 != v23);
    goto LABEL_115;
  }
  v13 = v12;
  if (!mlir::detail::DenseArrayAttrImpl<long long>::classof(v12))
  {
    a3(v108, a4);
    mlir::InFlightDiagnostic::append<mlir::Attribute>(v86, (uint64_t *)&v103);
LABEL_122:
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v108);
    return 0;
  }
  a1[2] = (uint64_t)v13;
  v14 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v104, "operandSegmentSizes", 0x13uLL);
  if (!v14)
  {
    v14 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v104, "operand_segment_sizes", 0x15uLL);
    if (!v14)
    {
      a3(v108, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v108, "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.");
      goto LABEL_122;
    }
  }
  return mlir::convertFromAttribute(a1 + 3, (const char *)5, v14, a3, a4) != 0;
}

uint64_t mlir::tensor::InsertSliceOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  BOOL v27;
  uint64_t v28;
  uint64_t DictionaryAttr;
  void *v30;
  mlir::DictionaryAttr *v32;
  void *v33;
  uint64_t v34;
  _QWORD v35[7];

  v35[6] = *MEMORY[0x24BDAC8D0];
  v32 = a1;
  v33 = v35;
  v34 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v32, (uint64_t)"static_offsets", 14, *a2);
    v6 = v5;
    v7 = v34;
    if (v34 >= HIDWORD(v34))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v33, v35, v34 + 1, 16);
      v7 = v34;
    }
    v8 = (uint64_t *)((char *)v33 + 16 * v7);
    *v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v34) = v34 + 1;
  }
  v9 = a2[1];
  if (v9)
  {
    v10 = mlir::Builder::getNamedAttr(&v32, (uint64_t)"static_sizes", 12, v9);
    v12 = v11;
    v13 = v34;
    if (v34 >= HIDWORD(v34))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v33, v35, v34 + 1, 16);
      v13 = v34;
    }
    v14 = (uint64_t *)((char *)v33 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    LODWORD(v34) = v34 + 1;
  }
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v32, (uint64_t)"static_strides", 14, v15);
    v18 = v17;
    v19 = v34;
    if (v34 >= HIDWORD(v34))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v33, v35, v34 + 1, 16);
      v19 = v34;
    }
    v20 = (uint64_t *)((char *)v33 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    LODWORD(v34) = v34 + 1;
  }
  v21 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 3), 5);
  v22 = mlir::Builder::getNamedAttr(&v32, (uint64_t)"operandSegmentSizes", 19, v21);
  v24 = v23;
  v25 = v34;
  if (v34 >= HIDWORD(v34))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v33, v35, v34 + 1, 16);
    v25 = v34;
  }
  v26 = (uint64_t *)((char *)v33 + 16 * v25);
  *v26 = v22;
  v26[1] = v24;
  v27 = __CFADD__((_DWORD)v34, 1);
  v28 = (v34 + 1);
  LODWORD(v34) = v34 + 1;
  if (v27)
  {
    DictionaryAttr = 0;
    v30 = v33;
    if (v33 == v35)
      return DictionaryAttr;
    goto LABEL_20;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v32, (mlir::MLIRContext *)v33, v28);
  v30 = v33;
  if (v33 != v35)
LABEL_20:
    free(v30);
  return DictionaryAttr;
}

unint64_t mlir::tensor::InsertSliceOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1;
  unsigned __int8 v2;
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v18;
  int v19;
  unint64_t v20;
  int v21;
  int v22;
  unint64_t v23;
  int v24;
  int v25;
  unint64_t v26;
  int v27;
  int v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t *v34;
  unint64_t *v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;

  v1 = *a1;
  v3 = &unk_254519000;
  if ((v2 & 1) == 0)
  {
    v30 = *a1;
    v33 = a1;
    v3 = &unk_254519000;
    v19 = v18;
    v1 = v30;
    a1 = v33;
    if (v19)
    {
      v20 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v20 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v20;
      v1 = v30;
      a1 = v33;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v4 = HIDWORD(v1);
  v5 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v1) ^ HIDWORD(v1));
  v40 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
  v6 = a1[1];
  if ((v4 & 1) == 0)
  {
    v31 = a1[1];
    v34 = a1;
    v3 = &unk_254519000;
    v22 = v21;
    v6 = v31;
    a1 = v34;
    if (v22)
    {
      v23 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v23 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v23;
      v6 = v31;
      a1 = v34;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v7 = HIDWORD(v6);
  v8 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v6) ^ HIDWORD(v6));
  v39 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) >> 47));
  v9 = a1[2];
  if ((v7 & 1) == 0)
  {
    v32 = a1[2];
    v35 = a1;
    v3 = &unk_254519000;
    v25 = v24;
    v9 = v32;
    a1 = v35;
    if (v25)
    {
      v26 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v26 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v26;
      v9 = v32;
      a1 = v35;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v10 = HIDWORD(v9);
  v11 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v9) ^ HIDWORD(v9));
  v38 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) ^ ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) >> 47));
  if ((v10 & 1) == 0)
  {
    v36 = a1;
    v3 = &unk_254519000;
    v28 = v27;
    a1 = v36;
    if (v28)
    {
      v29 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v29 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v29;
      v3 = (_QWORD *)&unk_254519000;
      a1 = v36;
    }
  }
  v12 = v3[373];
  v13 = a1[4];
  v14 = 0x9AE16A3B2F90404FLL * *(unint64_t *)((char *)a1 + 36);
  v15 = __ROR8__(0xB492B66FBE98F273 * a1[3] - v13, 43)
      - 0x3C5A37A36834CED9 * *(unint64_t *)((char *)a1 + 28)
      + __ROR8__(v14 ^ v12, 30);
  v16 = v12 + __ROR8__(v13 ^ 0xC949D7C7509E6557, 20) - 0x4B6D499041670D8DLL * a1[3] - v14 + 20;
  v37 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v16 ^ ((0x9DDFEA08EB382D69 * (v15 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v15 ^ v16)))) ^ ((0x9DDFEA08EB382D69 * (v16 ^ ((0x9DDFEA08EB382D69 * (v15 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v15 ^ v16)))) >> 47));
  return llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>(&v40, (uint64_t *)&v39, (uint64_t *)&v38, (uint64_t *)&v37);
}

uint64_t mlir::tensor::InsertSliceOp::getInherentAttr(mlir::MLIRContext *a1, uint64_t *a2, char *__s1, size_t __n)
{
  uint64_t result;

  result = 0;
  switch(__n)
  {
    case 0xCuLL:
      if (memcmp(__s1, "static_sizes", __n))
        goto LABEL_11;
      return a2[1];
    case 0xDuLL:
    case 0xFuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      goto LABEL_11;
    case 0xEuLL:
      if (*(_QWORD *)__s1 == 0x6F5F636974617473 && *(_QWORD *)(__s1 + 6) == 0x7374657366666F5FLL)
      {
        result = *a2;
      }
      else if (!memcmp(__s1, "static_strides", __n))
      {
        result = a2[2];
      }
      else
      {
LABEL_11:
        result = 0;
      }
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n))
        goto LABEL_11;
      goto LABEL_13;
    case 0x15uLL:
      if (memcmp(__s1, "operand_segment_sizes", __n))
        goto LABEL_11;
LABEL_13:
      result = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 3), 5);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::tensor::InsertSliceOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, _QWORD *a4)
{
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;

  v5 = (_QWORD *)result;
  switch(a3)
  {
    case 0xCuLL:
      result = memcmp(__s1, "static_sizes", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
          if ((_DWORD)result)
            v10 = a4;
          else
            v10 = 0;
          v5[1] = v10;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0xEuLL:
      if (*(_QWORD *)__s1 == 0x6F5F636974617473 && *(_QWORD *)(__s1 + 6) == 0x7374657366666F5FLL)
      {
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
          if ((_DWORD)result)
            v11 = a4;
          else
            v11 = 0;
          *v5 = v11;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      else
      {
        result = memcmp(__s1, "static_strides", a3);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
            if ((_DWORD)result)
              v7 = a4;
            else
              v7 = 0;
            v5[2] = v7;
          }
          else
          {
            v5[2] = 0;
          }
        }
      }
      break;
    case 0x13uLL:
      result = memcmp(__s1, "operandSegmentSizes", a3);
      if (!(_DWORD)result)
        goto LABEL_17;
      break;
    case 0x15uLL:
      result = memcmp(__s1, "operand_segment_sizes", a3);
      if (!(_DWORD)result)
      {
LABEL_17:
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          v8 = (_DWORD)result ? a4 : 0;
          v12 = v8;
          if ((_DWORD)result)
          {
            result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v12);
            if (result == 5)
            {
              result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v12);
              if (v9)
                result = (uint64_t)memmove(v5 + 3, (const void *)result, 4 * v9);
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::tensor::InsertSliceOp::populateInherentAttrs(mlir::MLIRContext *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"static_offsets", 14, *a2);
  v6 = a2[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"static_sizes", 12, v6);
  v7 = a2[2];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"static_strides", 14, v7);
  v8 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 3), 5);
  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v8);
}

BOOL mlir::tensor::InsertSliceOp::readProperties(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD *v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v3 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>(a2);
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) <= 5)
  {
    v17 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v17))
      return 0;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v17) >= 6)
    {
      v15 = "size mismatch for operand/result_segment_size";
      v16 = 259;
      (*(void (**)(_QWORD *__return_ptr, uint64_t, const char **))(*(_QWORD *)a1 + 16))(v18, a1, &v15);
      if (v18[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
      if (v25)
      {
        v4 = __p;
        if (__p)
        {
          v5 = v24;
          v6 = __p;
          if (v24 != __p)
          {
            do
              v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
            while (v5 != v4);
            v6 = __p;
          }
          v24 = v4;
          operator delete(v6);
        }
        v7 = v21;
        if (v21)
        {
          v8 = v22;
          v9 = v21;
          if (v22 != v21)
          {
            do
            {
              v11 = *--v8;
              v10 = v11;
              *v8 = 0;
              if (v11)
                MEMORY[0x20BD002D4](v10, 0x1000C8077774924);
            }
            while (v8 != v7);
            v9 = v21;
          }
          v22 = v7;
          operator delete(v9);
        }
        if (v19 != &v20)
          free(v19);
      }
      return 0;
    }
    v12 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v17);
    if (v13)
      memmove(v3 + 3, v12, 4 * v13);
  }
  return mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3)&& mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3 + 2)&& ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) < 6|| mlir::DialectBytecodeReader::readSparseArray<int>(a1, (_DWORD *)v3 + 6, (const char *)5));
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  uint64_t *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_OWORD *)operator new();
    *v3 = 0u;
    v3[1] = 0u;
    *(_OWORD *)((char *)v3 + 28) = 0u;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties]";
        v15 = 115;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[238];
    return a1[32];
  }
  return result;
}

uint64_t mlir::tensor::InsertSliceOp::writeProperties(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  mlir::MLIRContext *Context;
  uint64_t v6;
  uint64_t result;

  if (HIBYTE(*(_DWORD *)(*(_QWORD *)a1 + 44)))
    v4 = *(_QWORD *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1) + 64;
  else
    v4 = 0;
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2) <= 5)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)a1 + 24));
    v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 24, 5);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, v6);
  }
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, *(_QWORD *)v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, *(_QWORD *)(v4 + 8));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, *(_QWORD *)(v4 + 16));
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2);
  if (result >= 6)
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 24), 5);
  return result;
}

void mlir::tensor::InsertSliceOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  uint64_t v22;
  uint64_t DenseI64ArrayAttr;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v28;
  uint64_t v29;

  v28 = a5;
  v29 = a4;
  mlir::OperationState::addOperands(a2, (uint64_t)&v29, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v28, 1);
  mlir::OperationState::addOperands(a2, a6, a7);
  mlir::OperationState::addOperands(a2, a9, a10);
  mlir::OperationState::addOperands(a2, a11, a12);
  v22 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2);
  *(_QWORD *)(v22 + 24) = 0x100000001;
  *(_DWORD *)(v22 + 32) = a7;
  *(_DWORD *)(v22 + 36) = a10;
  *(_DWORD *)(v22 + 40) = a12;
  DenseI64ArrayAttr = mlir::Builder::getDenseI64ArrayAttr(a1, a13, a14);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2) = DenseI64ArrayAttr;
  v24 = mlir::Builder::getDenseI64ArrayAttr(a1, a15, a16);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = v24;
  v25 = mlir::Builder::getDenseI64ArrayAttr(a1, a17, a18);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = v25;
  v26 = *(unsigned int *)(a2 + 72);
  if (v26 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v26 + 1, 8);
    LODWORD(v26) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v26) = a3;
  ++*(_DWORD *)(a2 + 72);
}

uint64_t mlir::tensor::InsertSliceOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t ODSOperands;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t NextResultAtOffset;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  void *v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  const void **v55[4];
  __int16 v56;
  _QWORD v57[3];
  void *v58;
  uint64_t v59;
  void *v60;
  _QWORD *v61;
  void *__p;
  _QWORD *v63;
  char v64;
  uint64_t v65;

  v65 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_QWORD **)v3;
  if (!*(_QWORD *)v3)
  {
    v55[0] = (const void **)"requires attribute 'static_offsets'";
    v56 = 259;
    mlir::OpState::emitOpError(this, v55, (uint64_t)v57);
    v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v57);
    if (v57[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v57);
    if (!v64)
      return v31;
    v34 = __p;
    if (__p)
    {
      v35 = v63;
      v36 = __p;
      if (v63 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v63 = v34;
      operator delete(v36);
    }
    v37 = v60;
    if (v60)
    {
      v38 = v61;
      v39 = v60;
      if (v61 == v60)
        goto LABEL_86;
      do
      {
        v41 = *--v38;
        v40 = v41;
        *v38 = 0;
        if (v41)
          MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
      }
      while (v38 != v37);
LABEL_85:
      v39 = v60;
LABEL_86:
      v61 = v37;
      operator delete(v39);
    }
LABEL_87:
    if (v58 != &v59)
      free(v58);
    return v31;
  }
  v5 = *(_QWORD **)(v3 + 8);
  if (!v5)
  {
    v55[0] = (const void **)"requires attribute 'static_sizes'";
    v56 = 259;
    mlir::OpState::emitOpError(this, v55, (uint64_t)v57);
    v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v57);
    if (v57[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v57);
    if (!v64)
      return v31;
    v42 = __p;
    if (__p)
    {
      v43 = v63;
      v44 = __p;
      if (v63 != __p)
      {
        do
          v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
        while (v43 != v42);
        v44 = __p;
      }
      v63 = v42;
      operator delete(v44);
    }
    v37 = v60;
    if (v60)
    {
      v45 = v61;
      v39 = v60;
      if (v61 == v60)
        goto LABEL_86;
      do
      {
        v47 = *--v45;
        v46 = v47;
        *v45 = 0;
        if (v47)
          MEMORY[0x20BD002D4](v46, 0x1000C8077774924);
      }
      while (v45 != v37);
      goto LABEL_85;
    }
    goto LABEL_87;
  }
  v6 = *(_QWORD **)(v3 + 16);
  if (!v6)
  {
    v55[0] = (const void **)"requires attribute 'static_strides'";
    v56 = 259;
    mlir::OpState::emitOpError(this, v55, (uint64_t)v57);
    v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v57);
    if (v57[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v57);
    if (!v64)
      return v31;
    v48 = __p;
    if (__p)
    {
      v49 = v63;
      v50 = __p;
      if (v63 != __p)
      {
        do
          v49 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v49 - 1);
        while (v49 != v48);
        v50 = __p;
      }
      v63 = v48;
      operator delete(v50);
    }
    v37 = v60;
    if (v60)
    {
      v51 = v61;
      v39 = v60;
      if (v61 == v60)
        goto LABEL_86;
      do
      {
        v53 = *--v51;
        v52 = v53;
        *v51 = 0;
        if (v53)
          MEMORY[0x20BD002D4](v52, 0x1000C8077774924);
      }
      while (v51 != v37);
      goto LABEL_85;
    }
    goto LABEL_87;
  }
  v57[0] = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v4, (const void **)"static_offsets", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v57))return 0;
  v57[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v5, (const void **)"static_sizes", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v57))return 0;
  v57[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v6, (const void **)"static_strides", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v57))return 0;
  v7 = *((unsigned int *)*this + 11);
  v8 = (uint64_t)&(*this)[2 * ((v7 >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v8 = 0;
  v9 = *(unsigned int *)(v8 + 24);
  if ((v7 & 0x800000) != 0)
  {
    v10 = (*this)[9];
    if ((_DWORD)v9)
      goto LABEL_14;
  }
  else
  {
    v10 = 0;
    if ((_DWORD)v9)
    {
LABEL_14:
      v11 = 0;
      v12 = v10 + 24;
      while (mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(*(_QWORD *)v12 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v11))
      {
        ++v11;
        v12 += 32;
        if (v9 == v11)
          goto LABEL_17;
      }
      return 0;
    }
  }
LABEL_17:
  ODSOperands = mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 1u);
  if (v14)
  {
    v15 = v14;
    v16 = ODSOperands + 24;
    while (mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(*(_QWORD *)v16 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v9))
    {
      LODWORD(v9) = v9 + 1;
      v16 += 32;
      if (!--v15)
        goto LABEL_21;
    }
    return 0;
  }
LABEL_21:
  v17 = mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 2u);
  if (v18)
  {
    v19 = v18;
    v20 = v17 + 24;
    while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v20 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v9))
    {
      LODWORD(v9) = v9 + 1;
      v20 += 32;
      if (!--v19)
        goto LABEL_25;
    }
    return 0;
  }
LABEL_25:
  v21 = mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 3u);
  if (v22)
  {
    v23 = v22;
    v24 = v21 + 24;
    while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v24 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v9))
    {
      LODWORD(v9) = v9 + 1;
      v24 += 32;
      if (!--v23)
        goto LABEL_29;
    }
    return 0;
  }
LABEL_29:
  v25 = mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 4u);
  if (v26)
  {
    v27 = v26;
    v28 = v25 + 24;
    while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v28 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v9))
    {
      LODWORD(v9) = v9 + 1;
      v28 += 32;
      if (!--v27)
        goto LABEL_33;
    }
    return 0;
  }
LABEL_33:
  v29 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v29, 0);
  if (!mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0))return 0;
  v31 = 1;
  v32 = *(_QWORD *)(*(_QWORD *)(mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 1u)+ 24)+ 8) & 0xFFFFFFFFFFFFFFF8;
  if (*((_DWORD *)*this + 9))
    v33 = (uint64_t)(*this - 2);
  else
    v33 = 0;
  if (v32 != (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v33, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    v55[0] = (const void **)"failed to verify that expected result type to match dest type";
    v56 = 259;
    mlir::OpState::emitOpError(this, v55, (uint64_t)v57);
    v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v57);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v57);
  }
  return v31;
}

uint64_t mlir::tensor::InsertSliceOp::parse(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  mlir::IndexType **v21;
  mlir::MLIRContext *v22;
  uint64_t IndexType;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  _QWORD v32[4];
  __int16 v33;
  uint64_t v34;
  _QWORD v35[2];
  _QWORD v36[2];
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40[2];
  uint64_t v41[2];
  uint64_t v42;
  _QWORD *v43;
  _QWORD *v44;
  __int16 v45;
  uint64_t __src;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  _BYTE v50[128];
  void *v51;
  uint64_t v52;
  _BYTE v53[128];
  void *v54;
  uint64_t v55;
  _BYTE v56[128];
  _QWORD v57[4];
  _QWORD v58[6];

  v58[4] = *MEMORY[0x24BDAC8D0];
  memset(v58, 0, 24);
  v41[0] = (uint64_t)v58;
  v41[1] = 1;
  memset(v57, 0, 24);
  v40[0] = (uint64_t)v57;
  v40[1] = 1;
  v54 = v56;
  v55 = 0x400000000;
  v38 = 0;
  v39 = 0;
  v51 = v53;
  v52 = 0x400000000;
  v47 = 0;
  v48 = v50;
  v49 = 0x400000000;
  v36[1] = 1;
  v37 = 0;
  v35[1] = 1;
  v36[0] = &v47;
  __src = 0;
  v35[0] = &__src;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v58, 1))
    goto LABEL_31;
  v45 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 368))(a1, "into", 4, &v42))goto LABEL_31;
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v57, 1))
    goto LABEL_31;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v42 = 0;
  if (!mlir::parseDynamicIndexList(a1, (uint64_t)&v54, &v39, &v42, 0, 2))
    goto LABEL_31;
  v6 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>(a2);
  *v6 = v39;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v42 = 0;
  if (!mlir::parseDynamicIndexList(a1, (uint64_t)&v51, &v38, &v42, 0, 2))
    goto LABEL_31;
  v7 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>(a2);
  *(_QWORD *)(v7 + 8) = v38;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v42 = 0;
  if (!mlir::parseDynamicIndexList(a1, (uint64_t)&v48, &v37, &v42, 0, 2))
    goto LABEL_31;
  v8 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>(a2);
  *(_QWORD *)(v8 + 16) = v37;
  v32[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
    goto LABEL_31;
  v9 = a2[1];
  v42 = a1;
  v43 = v32;
  v44 = a2;
  if (!mlir::memref::ReinterpretCastOp::verifyInherentAttrs(v9, (uint64_t)(a2 + 14), (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::InsertSliceOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v42))goto LABEL_31;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    goto LABEL_31;
  v42 = 0;
  if (!mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, &v42))
    goto LABEL_31;
  v47 = v42;
  v45 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 368))(a1, "into", 4, &v42))goto LABEL_31;
  v42 = 0;
  if (!mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, &v42))
    goto LABEL_31;
  __src = v42;
  v10 = v55;
  v11 = v52;
  v12 = v49;
  v13 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>(a2);
  *(_QWORD *)(v13 + 24) = 0x100000001;
  *(_DWORD *)(v13 + 32) = v10;
  *(_DWORD *)(v13 + 36) = v11;
  *(_DWORD *)(v13 + 40) = v12;
  v14 = __src;
  v34 = __src;
  if (*(_UNKNOWN **)(*(_QWORD *)__src + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v33 = 257;
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(&v42, a1, v15, v32);
    v16 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)&v42, "'dest' must be ranked tensor of any type values, but got ");
    v17 = mlir::InFlightDiagnostic::append<mlir::Type &>(v16, &v34);
    v18 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v17);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v42);
    v19 = v48;
    if (v48 == v50)
      goto LABEL_34;
LABEL_33:
    free(v19);
    goto LABEL_34;
  }
  v20 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)__src + 8);
  v42 = v14;
  v43 = (_QWORD *)v20;
  mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v42);
  v21 = (mlir::IndexType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  IndexType = mlir::Builder::getIndexType(v21, v22);
  mlir::OperationState::addTypes((uint64_t)a2, &__src, 1);
  v24 = (uint64_t)(a2 + 2);
  if (!mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v41, v36, v4, v24)|| !mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v40, v35, v5, v24))
  {
    goto LABEL_31;
  }
  if ((_DWORD)v55)
  {
    v25 = (char *)v54;
    v26 = 32 * v55;
    while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v25, IndexType, v24))
    {
      v25 += 32;
      v26 -= 32;
      if (!v26)
        goto LABEL_22;
    }
LABEL_31:
    v18 = 0;
LABEL_32:
    v19 = v48;
    if (v48 != v50)
      goto LABEL_33;
    goto LABEL_34;
  }
LABEL_22:
  if ((_DWORD)v52)
  {
    v27 = (char *)v51;
    v28 = 32 * v52;
    while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v27, IndexType, v24))
    {
      v27 += 32;
      v28 -= 32;
      if (!v28)
        goto LABEL_26;
    }
    goto LABEL_31;
  }
LABEL_26:
  if ((_DWORD)v49)
  {
    v29 = (char *)v48;
    v30 = 32 * v49;
    v18 = 1;
    while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v29, IndexType, v24))
    {
      v29 += 32;
      v30 -= 32;
      if (!v30)
        goto LABEL_32;
    }
    goto LABEL_31;
  }
  v18 = 1;
  v19 = v48;
  if (v48 != v50)
    goto LABEL_33;
LABEL_34:
  if (v51 != v53)
    free(v51);
  if (v54 != v56)
    free(v54);
  return v18;
}

void mlir::tensor::InsertSliceOp::print(mlir::tensor::InsertSliceOp *this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  llvm::raw_ostream *v6;
  _BYTE *v7;
  llvm::raw_ostream *v8;
  _DWORD *v9;
  llvm::raw_ostream *v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  void **v15;
  _DWORD *v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  llvm::raw_ostream *v27;
  _BYTE *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  llvm::raw_ostream *v39;
  _BYTE *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  _QWORD *v53;
  mlir::Operation *v54;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v57;
  llvm::raw_ostream *v58;
  _BYTE *v59;
  llvm::raw_ostream *v60;
  _BYTE *v61;
  llvm::raw_ostream *v62;
  _BYTE *v63;
  llvm::raw_ostream *v64;
  _BYTE *v65;
  llvm::raw_ostream *v66;
  _DWORD *v67;
  llvm::raw_ostream *v68;
  _BYTE *v69;
  uint64_t v70;
  unint64_t AttrDictionary;
  void *v72;
  uint64_t v73;
  _QWORD v74[4];
  unint64_t v75[2];
  unint64_t v76[2];
  unint64_t v77[3];

  v77[2] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 24));
  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v7 = (_BYTE *)*((_QWORD *)v6 + 4);
  if ((unint64_t)v7 >= *((_QWORD *)v6 + 3))
  {
    llvm::raw_ostream::write(v6, 32);
  }
  else
  {
    *((_QWORD *)v6 + 4) = v7 + 1;
    *v7 = 32;
  }
  v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v9 = (_DWORD *)*((_QWORD *)v8 + 4);
  if (*((_QWORD *)v8 + 3) - (_QWORD)v9 > 3uLL)
  {
    *v9 = 1869901417;
    *((_QWORD *)v8 + 4) += 4;
  }
  else
  {
    llvm::raw_ostream::write(v8, "into", 4uLL);
  }
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (_BYTE *)*((_QWORD *)v10 + 4);
  if ((unint64_t)v11 >= *((_QWORD *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }
  else
  {
    *((_QWORD *)v10 + 4) = v11 + 1;
    *v11 = 32;
  }
  if (*(_BYTE *)(*(_QWORD *)this + 47))
    v12 = *(_QWORD *)this + 80;
  else
    v12 = 0;
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 32 * *(unsigned int *)(v12 + 24) + 24));
  v13 = *(_QWORD *)this;
  v14 = *(unsigned int *)(*(_QWORD *)this + 44);
  v15 = (void **)(*(_QWORD *)this + 16 * ((v14 >> 23) & 1) + 64);
  if (HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v16 = (_DWORD *)(*(_QWORD *)this + 16 * ((v14 >> 23) & 1) + 64);
  else
    v16 = 0;
  v17 = v16[6];
  v18 = v16[7];
  v19 = v16[8];
  if ((v14 & 0x800000) != 0)
    v20 = *(_QWORD *)(v13 + 72);
  else
    v20 = 0;
  v21 = (v18 + v17);
  v22 = v20 + 32 * v21;
  v23 = (v19 + v21) - v21;
  v72 = *v15;
  v24 = (unint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v72);
  v26 = v25;
  mlir::ValueRange::ValueRange(v77, 0, 0);
  mlir::printDynamicIndexList((uint64_t)a2, v13, v22, v23, v24, v26, v77[0], v77[1], 0, 0, 2);
  v27 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v28 = (_BYTE *)*((_QWORD *)v27 + 4);
  if ((unint64_t)v28 >= *((_QWORD *)v27 + 3))
  {
    llvm::raw_ostream::write(v27, 32);
  }
  else
  {
    *((_QWORD *)v27 + 4) = v28 + 1;
    *v28 = 32;
  }
  v29 = *(_QWORD *)this;
  v30 = *(unsigned int *)(*(_QWORD *)this + 44);
  v31 = *(_QWORD *)this + 16 * ((v30 >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v31 = 0;
  if ((v30 & 0x800000) != 0)
    v32 = *(_QWORD *)(v29 + 72);
  else
    v32 = 0;
  v33 = (*(_DWORD *)(v31 + 28) + *(_DWORD *)(v31 + 24) + *(_DWORD *)(v31 + 32));
  v34 = v32 + 32 * v33;
  v35 = (*(_DWORD *)(v31 + 36) + v33) - v33;
  v72 = *(void **)(v31 + 8);
  v36 = (unint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v72);
  v38 = v37;
  mlir::ValueRange::ValueRange(v76, 0, 0);
  mlir::printDynamicIndexList((uint64_t)a2, v29, v34, v35, v36, v38, v76[0], v76[1], 0, 0, 2);
  v39 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v40 = (_BYTE *)*((_QWORD *)v39 + 4);
  if ((unint64_t)v40 >= *((_QWORD *)v39 + 3))
  {
    llvm::raw_ostream::write(v39, 32);
  }
  else
  {
    *((_QWORD *)v39 + 4) = v40 + 1;
    *v40 = 32;
  }
  v41 = *(_QWORD *)this;
  v42 = *(unsigned int *)(*(_QWORD *)this + 44);
  v43 = *(_QWORD *)this + 16 * ((v42 >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v43 = 0;
  if ((v42 & 0x800000) != 0)
    v44 = *(_QWORD *)(v41 + 72);
  else
    v44 = 0;
  v45 = (*(_DWORD *)(v43 + 28) + *(_DWORD *)(v43 + 24) + *(_DWORD *)(v43 + 32) + *(_DWORD *)(v43 + 36));
  v46 = v44 + 32 * v45;
  v47 = (*(_DWORD *)(v43 + 40) + v45) - v45;
  v72 = *(void **)(v43 + 16);
  v48 = (unint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v72);
  v50 = v49;
  mlir::ValueRange::ValueRange(v75, 0, 0);
  mlir::printDynamicIndexList((uint64_t)a2, v41, v46, v47, v48, v50, v75[0], v75[1], 0, 0, 2);
  v72 = v74;
  v74[0] = "operandSegmentSizes";
  v74[1] = 19;
  v74[2] = "static_offsets";
  v74[3] = 14;
  v73 = 0x200000002;
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v74, 3uLL, 16);
  v51 = (char *)v72 + 16 * v73;
  *v51 = "static_sizes";
  v51[1] = 12;
  v52 = (v73 + 1);
  LODWORD(v73) = v52;
  if (v52 >= HIDWORD(v73))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v74, v52 + 1, 16);
    LODWORD(v52) = v73;
  }
  v53 = (char *)v72 + 16 * v52;
  *v53 = "static_strides";
  v53[1] = 14;
  LODWORD(v73) = v73 + 1;
  v54 = *(mlir::Operation **)this;
  if (*(_BYTE *)(*(_QWORD *)this + 47))
  {
    AttrDictionary = mlir::Operation::getAttrDictionary(v54);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::Operation *)((char *)v54 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v57, v72, v73);
  v58 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v59 = (_BYTE *)*((_QWORD *)v58 + 4);
  if ((unint64_t)v59 >= *((_QWORD *)v58 + 3))
  {
    llvm::raw_ostream::write(v58, 32);
  }
  else
  {
    *((_QWORD *)v58 + 4) = v59 + 1;
    *v59 = 32;
  }
  v60 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v61 = (_BYTE *)*((_QWORD *)v60 + 4);
  if (*((_BYTE **)v60 + 3) == v61)
  {
    llvm::raw_ostream::write(v60, ":", 1uLL);
  }
  else
  {
    *v61 = 58;
    ++*((_QWORD *)v60 + 4);
  }
  v62 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v63 = (_BYTE *)*((_QWORD *)v62 + 4);
  if ((unint64_t)v63 >= *((_QWORD *)v62 + 3))
  {
    llvm::raw_ostream::write(v62, 32);
  }
  else
  {
    *((_QWORD *)v62 + 4) = v63 + 1;
    *v63 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v64 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v65 = (_BYTE *)*((_QWORD *)v64 + 4);
  if ((unint64_t)v65 >= *((_QWORD *)v64 + 3))
  {
    llvm::raw_ostream::write(v64, 32);
  }
  else
  {
    *((_QWORD *)v64 + 4) = v65 + 1;
    *v65 = 32;
  }
  v66 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v67 = (_DWORD *)*((_QWORD *)v66 + 4);
  if (*((_QWORD *)v66 + 3) - (_QWORD)v67 > 3uLL)
  {
    *v67 = 1869901417;
    *((_QWORD *)v66 + 4) += 4;
  }
  else
  {
    llvm::raw_ostream::write(v66, "into", 4uLL);
  }
  v68 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v69 = (_BYTE *)*((_QWORD *)v68 + 4);
  if ((unint64_t)v69 >= *((_QWORD *)v68 + 3))
  {
    llvm::raw_ostream::write(v68, 32);
  }
  else
  {
    *((_QWORD *)v68 + 4) = v69 + 1;
    *v69 = 32;
  }
  if (*(_BYTE *)(*(_QWORD *)this + 47))
    v70 = *(_QWORD *)this + 80;
  else
    v70 = 0;
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 32 * *(unsigned int *)(v70 + 24) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v72 != v74)
    free(v72);
}

uint64_t mlir::tensor::detail::PackOpGenericAdaptorBase::PackOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t Context;
  unint64_t v12[3];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v12, v7, v6);
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v5;
  v9 = *(_OWORD *)(v5 + 16);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(v5 + 32);
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)v12;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "tensor.pack", 11, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::tensor::PackOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  int *v16;
  char *v17;
  char *v18;
  __int128 v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  char *v39;
  char *v40;
  __int128 v41;
  int *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  int *v56;
  char *v57;
  char *v58;
  __int128 v59;
  _QWORD *v60;
  _QWORD *v61;
  void *v62;
  _QWORD *v63;
  uint64_t v64;
  uint64_t v65;
  int *v66;
  char *v67;
  char *v68;
  __int128 v69;
  _QWORD *v70;
  _QWORD *v71;
  void *v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  int *v76;
  char *v77;
  char *v78;
  __int128 v79;
  int *v80;
  char *v81;
  char *v82;
  __int128 v83;
  _QWORD *v84;
  _QWORD *v85;
  void *v86;
  _QWORD *v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  int64_t v99;
  int64_t v100;
  int64_t v101;
  int64_t v102;
  int64_t v103;
  int64_t v104;
  int64_t v105;
  int64_t v106;
  int64_t v107;
  uint64_t v108;
  int v109;
  const char *v110;
  uint64_t v111;
  _QWORD v112[3];
  void *v113;
  unsigned int v114;
  unsigned int v115;
  _BYTE v116[96];
  void *v117;
  _QWORD *v118;
  void *__p;
  _QWORD *v120;
  char v121;
  uint64_t v122;

  v122 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v108 = v6;
  if (!v6)
  {
    a3(v112, a4);
    if (v112[0])
    {
      v109 = 3;
      v110 = "expected DictionaryAttr to set properties";
      v111 = 41;
      v16 = &v109;
      v17 = (char *)v113;
      if (v114 >= v115)
      {
        v90 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v99 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v90, 24);
          v17 = (char *)v113;
          v16 = (int *)((char *)v113 + v99);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v90, 24);
          v16 = &v109;
          v17 = (char *)v113;
        }
      }
      v18 = &v17[24 * v114];
      v19 = *(_OWORD *)v16;
      *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
      *(_OWORD *)v18 = v19;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v20 = __p;
    if (__p)
    {
      v21 = v120;
      v22 = __p;
      if (v120 != __p)
      {
        do
          v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
        while (v21 != v20);
        v22 = __p;
      }
      v120 = v20;
      operator delete(v22);
    }
    v23 = v117;
    if (!v117)
      goto LABEL_120;
    v24 = v118;
    v25 = v117;
    if (v118 == v117)
    {
LABEL_119:
      v118 = v23;
      operator delete(v25);
LABEL_120:
      if (v113 != v116)
        free(v113);
      return 0;
    }
    do
    {
      v27 = *--v24;
      v26 = v27;
      *v24 = 0;
      if (v27)
        MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
    }
    while (v24 != v23);
LABEL_118:
    v25 = v117;
    goto LABEL_119;
  }
  v8 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v108, "inner_dims_pos", 0xEuLL);
  if (!v8)
  {
    a3(v112, a4);
    if (v112[0])
    {
      v109 = 3;
      v110 = "expected key entry for inner_dims_pos in DictionaryAttr to set Properties.";
      v111 = 74;
      v28 = &v109;
      v29 = (char *)v113;
      if (v114 >= v115)
      {
        v91 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v100 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
          v29 = (char *)v113;
          v28 = (int *)((char *)v113 + v100);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
          v28 = &v109;
          v29 = (char *)v113;
        }
      }
      v30 = &v29[24 * v114];
      v31 = *(_OWORD *)v28;
      *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
      *(_OWORD *)v30 = v31;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v32 = __p;
    if (__p)
    {
      v33 = v120;
      v34 = __p;
      if (v120 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v120 = v32;
      operator delete(v34);
    }
    v23 = v117;
    if (!v117)
      goto LABEL_120;
    v35 = v118;
    v25 = v117;
    if (v118 == v117)
      goto LABEL_119;
    do
    {
      v37 = *--v35;
      v36 = v37;
      *v35 = 0;
      if (v37)
        MEMORY[0x20BD002D4](v36, 0x1000C8077774924);
    }
    while (v35 != v23);
    goto LABEL_118;
  }
  v9 = (uint64_t)v8;
  if (!mlir::detail::DenseArrayAttrImpl<long long>::classof(v8))
  {
    a3(v112, a4);
    if (v112[0])
    {
      v109 = 3;
      v111 = 59;
      v38 = &v109;
      v39 = (char *)v113;
      if (v114 >= v115)
      {
        v92 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v101 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
          v39 = (char *)v113;
          v38 = (int *)((char *)v113 + v101);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
          v38 = &v109;
          v39 = (char *)v113;
        }
      }
      v40 = &v39[24 * v114];
      v41 = *(_OWORD *)v38;
      *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
      *(_OWORD *)v40 = v41;
      ++v114;
      if (v112[0])
      {
        v42 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v9);
        v43 = (char *)v113;
        if (v114 >= v115)
        {
          v93 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            v102 = (char *)&v109 - (_BYTE *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
            v43 = (char *)v113;
            v42 = (int *)((char *)v113 + v102);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
            v42 = &v109;
            v43 = (char *)v113;
          }
        }
        v44 = &v43[24 * v114];
        v45 = *(_OWORD *)v42;
        *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
        *(_OWORD *)v44 = v45;
        ++v114;
        if (v112[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121)
      return 0;
    v46 = __p;
    if (__p)
    {
      v47 = v120;
      v48 = __p;
      if (v120 != __p)
      {
        do
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        v48 = __p;
      }
      v120 = v46;
      operator delete(v48);
    }
    v23 = v117;
    if (!v117)
      goto LABEL_120;
    v49 = v118;
    v25 = v117;
    if (v118 == v117)
      goto LABEL_119;
    do
    {
      v51 = *--v49;
      v50 = v51;
      *v49 = 0;
      if (v51)
        MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
    }
    while (v49 != v23);
    goto LABEL_118;
  }
  *a1 = v9;
  v10 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v108, "outer_dims_perm", 0xFuLL);
  if (!v10)
    goto LABEL_10;
  v11 = (uint64_t)v10;
  if (!mlir::detail::DenseArrayAttrImpl<long long>::classof(v10))
  {
    a3(v112, a4);
    if (v112[0])
    {
      v109 = 3;
      v111 = 60;
      v52 = &v109;
      v53 = (char *)v113;
      if (v114 >= v115)
      {
        v94 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v103 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
          v53 = (char *)v113;
          v52 = (int *)((char *)v113 + v103);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
          v52 = &v109;
          v53 = (char *)v113;
        }
      }
      v54 = &v53[24 * v114];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
      *(_OWORD *)v54 = v55;
      ++v114;
      if (v112[0])
      {
        v56 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v11);
        v57 = (char *)v113;
        if (v114 >= v115)
        {
          v97 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            v106 = (char *)&v109 - (_BYTE *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
            v57 = (char *)v113;
            v56 = (int *)((char *)v113 + v106);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
            v56 = &v109;
            v57 = (char *)v113;
          }
        }
        v58 = &v57[24 * v114];
        v59 = *(_OWORD *)v56;
        *((_QWORD *)v58 + 2) = *((_QWORD *)v56 + 2);
        *(_OWORD *)v58 = v59;
        ++v114;
        if (v112[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121)
      return 0;
    v60 = __p;
    if (__p)
    {
      v61 = v120;
      v62 = __p;
      if (v120 != __p)
      {
        do
          v61 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v61 - 1);
        while (v61 != v60);
        v62 = __p;
      }
      v120 = v60;
      operator delete(v62);
    }
    v23 = v117;
    if (!v117)
      goto LABEL_120;
    v63 = v118;
    v25 = v117;
    if (v118 == v117)
      goto LABEL_119;
    do
    {
      v65 = *--v63;
      v64 = v65;
      *v63 = 0;
      if (v65)
        MEMORY[0x20BD002D4](v64, 0x1000C8077774924);
    }
    while (v63 != v23);
    goto LABEL_118;
  }
  a1[1] = v11;
LABEL_10:
  v12 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v108, "static_inner_tiles", 0x12uLL);
  if (!v12)
  {
    a3(v112, a4);
    if (v112[0])
    {
      v109 = 3;
      v110 = "expected key entry for static_inner_tiles in DictionaryAttr to set Properties.";
      v111 = 78;
      v66 = &v109;
      v67 = (char *)v113;
      if (v114 >= v115)
      {
        v95 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v104 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
          v67 = (char *)v113;
          v66 = (int *)((char *)v113 + v104);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
          v66 = &v109;
          v67 = (char *)v113;
        }
      }
      v68 = &v67[24 * v114];
      v69 = *(_OWORD *)v66;
      *((_QWORD *)v68 + 2) = *((_QWORD *)v66 + 2);
      *(_OWORD *)v68 = v69;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v70 = __p;
    if (__p)
    {
      v71 = v120;
      v72 = __p;
      if (v120 != __p)
      {
        do
          v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
        while (v71 != v70);
        v72 = __p;
      }
      v120 = v70;
      operator delete(v72);
    }
    v23 = v117;
    if (!v117)
      goto LABEL_120;
    v73 = v118;
    v25 = v117;
    if (v118 == v117)
      goto LABEL_119;
    do
    {
      v75 = *--v73;
      v74 = v75;
      *v73 = 0;
      if (v75)
        MEMORY[0x20BD002D4](v74, 0x1000C8077774924);
    }
    while (v73 != v23);
    goto LABEL_118;
  }
  v13 = (uint64_t)v12;
  if (!mlir::detail::DenseArrayAttrImpl<long long>::classof(v12))
  {
    a3(v112, a4);
    if (v112[0])
    {
      v109 = 3;
      v111 = 63;
      v76 = &v109;
      v77 = (char *)v113;
      if (v114 >= v115)
      {
        v96 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v105 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          v77 = (char *)v113;
          v76 = (int *)((char *)v113 + v105);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          v76 = &v109;
          v77 = (char *)v113;
        }
      }
      v78 = &v77[24 * v114];
      v79 = *(_OWORD *)v76;
      *((_QWORD *)v78 + 2) = *((_QWORD *)v76 + 2);
      *(_OWORD *)v78 = v79;
      ++v114;
      if (v112[0])
      {
        v80 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v13);
        v81 = (char *)v113;
        if (v114 >= v115)
        {
          v98 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            v107 = (char *)&v109 - (_BYTE *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
            v81 = (char *)v113;
            v80 = (int *)((char *)v113 + v107);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
            v80 = &v109;
            v81 = (char *)v113;
          }
        }
        v82 = &v81[24 * v114];
        v83 = *(_OWORD *)v80;
        *((_QWORD *)v82 + 2) = *((_QWORD *)v80 + 2);
        *(_OWORD *)v82 = v83;
        ++v114;
        if (v112[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121)
      return 0;
    v84 = __p;
    if (__p)
    {
      v85 = v120;
      v86 = __p;
      if (v120 != __p)
      {
        do
          v85 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v85 - 1);
        while (v85 != v84);
        v86 = __p;
      }
      v120 = v84;
      operator delete(v86);
    }
    v23 = v117;
    if (!v117)
      goto LABEL_120;
    v87 = v118;
    v25 = v117;
    if (v118 == v117)
      goto LABEL_119;
    do
    {
      v89 = *--v87;
      v88 = v89;
      *v87 = 0;
      if (v89)
        MEMORY[0x20BD002D4](v88, 0x1000C8077774924);
    }
    while (v87 != v23);
    goto LABEL_118;
  }
  a1[2] = v13;
  v14 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v108, "operandSegmentSizes", 0x13uLL);
  if (v14 || (v14 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v108, "operand_segment_sizes", 0x15uLL)) != 0)
  {
    if (mlir::convertFromAttribute(a1 + 3, (const char *)4, v14, a3, a4))
      return 1;
  }
  else
  {
    a3(v112, a4);
    mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.");
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v112);
  }
  return 0;
}

uint64_t mlir::tensor::PackOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  BOOL v27;
  uint64_t v28;
  uint64_t DictionaryAttr;
  void *v30;
  mlir::DictionaryAttr *v32;
  void *v33;
  uint64_t v34;
  _QWORD v35[7];

  v35[6] = *MEMORY[0x24BDAC8D0];
  v32 = a1;
  v33 = v35;
  v34 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v32, (uint64_t)"inner_dims_pos", 14, *a2);
    v6 = v5;
    v7 = v34;
    if (v34 >= HIDWORD(v34))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v33, v35, v34 + 1, 16);
      v7 = v34;
    }
    v8 = (uint64_t *)((char *)v33 + 16 * v7);
    *v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v34) = v34 + 1;
  }
  v9 = a2[1];
  if (v9)
  {
    v10 = mlir::Builder::getNamedAttr(&v32, (uint64_t)"outer_dims_perm", 15, v9);
    v12 = v11;
    v13 = v34;
    if (v34 >= HIDWORD(v34))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v33, v35, v34 + 1, 16);
      v13 = v34;
    }
    v14 = (uint64_t *)((char *)v33 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    LODWORD(v34) = v34 + 1;
  }
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v32, (uint64_t)"static_inner_tiles", 18, v15);
    v18 = v17;
    v19 = v34;
    if (v34 >= HIDWORD(v34))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v33, v35, v34 + 1, 16);
      v19 = v34;
    }
    v20 = (uint64_t *)((char *)v33 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    LODWORD(v34) = v34 + 1;
  }
  v21 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 3), 4);
  v22 = mlir::Builder::getNamedAttr(&v32, (uint64_t)"operandSegmentSizes", 19, v21);
  v24 = v23;
  v25 = v34;
  if (v34 >= HIDWORD(v34))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v33, v35, v34 + 1, 16);
    v25 = v34;
  }
  v26 = (uint64_t *)((char *)v33 + 16 * v25);
  *v26 = v22;
  v26[1] = v24;
  v27 = __CFADD__((_DWORD)v34, 1);
  v28 = (v34 + 1);
  LODWORD(v34) = v34 + 1;
  if (v27)
  {
    DictionaryAttr = 0;
    v30 = v33;
    if (v33 == v35)
      return DictionaryAttr;
    goto LABEL_20;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v32, (mlir::MLIRContext *)v33, v28);
  v30 = v33;
  if (v33 != v35)
LABEL_20:
    free(v30);
  return DictionaryAttr;
}

uint64_t mlir::tensor::PackOp::getInherentAttr(mlir::MLIRContext *a1, _QWORD *a2, _QWORD *__s1, size_t __n)
{
  uint64_t result;

  result = 0;
  switch(__n)
  {
    case 0xEuLL:
      if (*__s1 != 0x69645F72656E6E69 || *(_QWORD *)((char *)__s1 + 6) != 0x736F705F736D6964)
        goto LABEL_13;
      return *a2;
    case 0xFuLL:
      if (memcmp(__s1, "outer_dims_perm", __n))
        goto LABEL_13;
      return a2[1];
    case 0x10uLL:
    case 0x11uLL:
    case 0x14uLL:
      goto LABEL_13;
    case 0x12uLL:
      if (memcmp(__s1, "static_inner_tiles", __n))
        goto LABEL_13;
      result = a2[2];
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n))
        goto LABEL_13;
      goto LABEL_15;
    case 0x15uLL:
      if (!memcmp(__s1, "operand_segment_sizes", __n))
LABEL_15:
        result = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 3), 4);
      else
LABEL_13:
        result = 0;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::tensor::PackOp::setInherentAttr(uint64_t result, _QWORD *__s1, size_t a3, _QWORD *a4)
{
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;

  v5 = (_QWORD *)result;
  switch(a3)
  {
    case 0xEuLL:
      if (*__s1 == 0x69645F72656E6E69 && *(_QWORD *)((char *)__s1 + 6) == 0x736F705F736D6964)
      {
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
          if ((_DWORD)result)
            v11 = a4;
          else
            v11 = 0;
          *v5 = v11;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xFuLL:
      result = memcmp(__s1, "outer_dims_perm", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
          if ((_DWORD)result)
            v7 = a4;
          else
            v7 = 0;
          v5[1] = v7;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x12uLL:
      result = memcmp(__s1, "static_inner_tiles", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v5[2] = v8;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    case 0x13uLL:
      result = memcmp(__s1, "operandSegmentSizes", a3);
      if (!(_DWORD)result)
        goto LABEL_22;
      break;
    case 0x15uLL:
      result = memcmp(__s1, "operand_segment_sizes", a3);
      if (!(_DWORD)result)
      {
LABEL_22:
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          v9 = (_DWORD)result ? a4 : 0;
          v12 = v9;
          if ((_DWORD)result)
          {
            result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v12);
            if (result == 4)
            {
              result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v12);
              if (v10)
                result = (uint64_t)memmove(v5 + 3, (const void *)result, 4 * v10);
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::tensor::PackOp::populateInherentAttrs(mlir::MLIRContext *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"inner_dims_pos", 14, *a2);
  v6 = a2[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"outer_dims_perm", 15, v6);
  v7 = a2[2];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"static_inner_tiles", 18, v7);
  v8 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 3), 4);
  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v8);
}

BOOL mlir::tensor::PackOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _BOOL8 result;

  v8 = (_QWORD *)mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v8, (const void **)"inner_dims_pos", (const char *)0xE, a3, a4))
  {
    v9 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v9, (const void **)"outer_dims_perm", (const char *)0xF, a3, a4))
    {
      v10 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v10, (const void **)"static_inner_tiles", (const char *)0x12, a3, a4))
      {
        return 1;
      }
    }
  }
  return result;
}

BOOL mlir::tensor::PackOp::readProperties(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD *v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v3 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PackOpGenericAdaptorBase::Properties>(a2);
  if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3))
    return 0;
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) <= 5)
  {
    v17 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v17))
      return 0;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v17) >= 5)
    {
      v15 = "size mismatch for operand/result_segment_size";
      v16 = 259;
      (*(void (**)(_QWORD *__return_ptr, uint64_t, const char **))(*(_QWORD *)a1 + 16))(v18, a1, &v15);
      if (v18[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
      if (v25)
      {
        v4 = __p;
        if (__p)
        {
          v5 = v24;
          v6 = __p;
          if (v24 != __p)
          {
            do
              v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
            while (v5 != v4);
            v6 = __p;
          }
          v24 = v4;
          operator delete(v6);
        }
        v7 = v21;
        if (v21)
        {
          v8 = v22;
          v9 = v21;
          if (v22 != v21)
          {
            do
            {
              v11 = *--v8;
              v10 = v11;
              *v8 = 0;
              if (v11)
                MEMORY[0x20BD002D4](v10, 0x1000C8077774924);
            }
            while (v8 != v7);
            v9 = v21;
          }
          v22 = v7;
          operator delete(v9);
        }
        if (v19 != &v20)
          free(v19);
      }
      return 0;
    }
    v12 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v17);
    if (v13)
      memmove(v3 + 3, v12, 4 * v13);
  }
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3 + 2)&& ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) < 6|| mlir::DialectBytecodeReader::readSparseArray<int>(a1, (_DWORD *)v3 + 6, (const char *)4));
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PackOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new();
    *(_OWORD *)v3 = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_QWORD *)(v3 + 32) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::PackOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PackOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::PackOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PackOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::tensor::detail::PackOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::tensor::detail::PackOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[240];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  _BOOL4 v5;
  _QWORD *v6;
  uint64_t v7;
  const void ***v9;
  char *v10;
  char *v11;
  __int128 v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  const void ***v17;
  char *v18;
  char *v19;
  __int128 v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  int64_t v36;
  int64_t v37;
  int64_t v38;
  _WORD v39[20];
  _QWORD *v40;
  const void **v41;
  unint64_t v42;
  uint64_t v43;
  __int16 v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  unsigned int v48;
  unsigned int v49;
  _BYTE v50[96];
  void *v51;
  _QWORD *v52;
  void *__p;
  _QWORD *v54;
  char v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  v40 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD **))(*(_QWORD *)a1 + 56))(a1, &v40))
    return 0;
  v4 = v40;
  if (!v40)
    return 1;
  v5 = mlir::detail::DenseArrayAttrImpl<long long>::classof(v40);
  v6 = v5 ? v4 : 0;
  *a2 = v6;
  if (v5)
    return 1;
  v39[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v45, a1, v39);
  if (v45)
  {
    LODWORD(v41) = 3;
    v42 = (unint64_t)"expected ";
    v43 = 9;
    v9 = &v41;
    v10 = (char *)v47;
    if (v48 >= v49)
    {
      v33 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        v36 = (char *)&v41 - (_BYTE *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v33, 24);
        v10 = (char *)v47;
        v9 = (const void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v33, 24);
        v9 = &v41;
        v10 = (char *)v47;
      }
    }
    v11 = &v10[24 * v48];
    v12 = *(_OWORD *)v9;
    *((_QWORD *)v11 + 2) = v9[2];
    *(_OWORD *)v11 = v12;
    ++v48;
  }
  v41 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::detail::DenseArrayAttrImpl<int64_t>]";
  v42 = 91;
  v13 = llvm::StringRef::find((uint64_t *)&v41, "DesiredTypeName = ", 0x12uLL, 0);
  if (v45)
  {
    if (v42 >= v13)
      v14 = v13;
    else
      v14 = v42;
    v15 = 18;
    if (v42 - v14 < 0x12)
      v15 = v42 - v14;
    v16 = v42 - v14 - v15;
    if (v16 >= v16 - 1)
      --v16;
    v44 = 261;
    v41 = (const void **)((char *)v41 + v14 + v15);
    v42 = v16;
    mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
    if (v45)
    {
      LODWORD(v41) = 3;
      v42 = (unint64_t)", but got: ";
      v43 = 11;
      v17 = &v41;
      v18 = (char *)v47;
      if (v48 >= v49)
      {
        v34 = v48 + 1;
        if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
        {
          v37 = (char *)&v41 - (_BYTE *)v47;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
          v18 = (char *)v47;
          v17 = (const void ***)((char *)v47 + v37);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
          v17 = &v41;
          v18 = (char *)v47;
        }
      }
      v19 = &v18[24 * v48];
      v20 = *(_OWORD *)v17;
      *((_QWORD *)v19 + 2) = v17[2];
      *(_OWORD *)v19 = v20;
      ++v48;
      if (v45)
      {
        v21 = &v41;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v41, (uint64_t)v40);
        v22 = (char *)v47;
        if (v48 >= v49)
        {
          v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            v38 = (char *)&v41 - (_BYTE *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            v22 = (char *)v47;
            v21 = (const void ***)((char *)v47 + v38);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            v21 = &v41;
            v22 = (char *)v47;
          }
        }
        v23 = &v22[24 * v48];
        v24 = *(_OWORD *)v21;
        *((_QWORD *)v23 + 2) = v21[2];
        *(_OWORD *)v23 = v24;
        ++v48;
      }
    }
  }
  v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  if (v55)
  {
    v25 = __p;
    if (__p)
    {
      v26 = v54;
      v27 = __p;
      if (v54 != __p)
      {
        do
          v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        v27 = __p;
      }
      v54 = v25;
      operator delete(v27);
    }
    v28 = v51;
    if (v51)
    {
      v29 = v52;
      v30 = v51;
      if (v52 != v51)
      {
        do
        {
          v32 = *--v29;
          v31 = v32;
          *v29 = 0;
          if (v32)
            MEMORY[0x20BD002D4](v31, 0x1000C8077774924);
        }
        while (v29 != v28);
        v30 = v51;
      }
      v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50)
      free(v47);
  }
  return v7;
}

uint64_t mlir::tensor::PackOp::writeProperties(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  mlir::MLIRContext *Context;
  uint64_t v6;
  uint64_t result;

  if (HIBYTE(*(_DWORD *)(*(_QWORD *)a1 + 44)))
    v4 = *(_QWORD *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1) + 64;
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, *(_QWORD *)v4);
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2) <= 5)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)a1 + 24));
    v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 24, 4);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, v6);
  }
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 8));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, *(_QWORD *)(v4 + 16));
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2);
  if (result >= 6)
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 24), 4);
  return result;
}

uint64_t mlir::tensor::PackOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  uint64_t ODSOperands;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  unint64_t v20;
  int v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t NextResultAtOffset;
  unint64_t v50;
  uint64_t v51;
  uint64_t v53;
  unsigned int v54;
  const void **v55[4];
  __int16 v56;
  _QWORD v57[3];
  void *v58;
  uint64_t v59;
  void *v60;
  _QWORD *v61;
  void *__p;
  _QWORD *v63;
  char v64;
  uint64_t v65;

  v65 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_QWORD **)v3;
  if (!*(_QWORD *)v3)
  {
    v55[0] = (const void **)"requires attribute 'inner_dims_pos'";
    v56 = 259;
    mlir::OpState::emitOpError(this, v55, (uint64_t)v57);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v57);
    if (v57[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v57);
    if (!v64)
      return v27;
    v28 = __p;
    if (__p)
    {
      v29 = v63;
      v30 = __p;
      if (v63 != __p)
      {
        do
          v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
        while (v29 != v28);
        v30 = __p;
      }
      v63 = v28;
      operator delete(v30);
    }
    v31 = v60;
    if (v60)
    {
      v32 = v61;
      v33 = v60;
      if (v61 == v60)
        goto LABEL_51;
      do
      {
        v35 = *--v32;
        v34 = v35;
        *v32 = 0;
        if (v35)
          MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
      }
      while (v32 != v31);
LABEL_50:
      v33 = v60;
LABEL_51:
      v61 = v31;
      operator delete(v33);
    }
LABEL_52:
    if (v58 != &v59)
      free(v58);
    return v27;
  }
  v5 = *(_QWORD **)(v3 + 16);
  if (!v5)
  {
    v55[0] = (const void **)"requires attribute 'static_inner_tiles'";
    v56 = 259;
    mlir::OpState::emitOpError(this, v55, (uint64_t)v57);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v57);
    if (v57[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v57);
    if (!v64)
      return v27;
    v36 = __p;
    if (__p)
    {
      v37 = v63;
      v38 = __p;
      if (v63 != __p)
      {
        do
          v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
        while (v37 != v36);
        v38 = __p;
      }
      v63 = v36;
      operator delete(v38);
    }
    v31 = v60;
    if (v60)
    {
      v39 = v61;
      v33 = v60;
      if (v61 == v60)
        goto LABEL_51;
      do
      {
        v41 = *--v39;
        v40 = v41;
        *v39 = 0;
        if (v41)
          MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
      }
      while (v39 != v31);
      goto LABEL_50;
    }
    goto LABEL_52;
  }
  v6 = *(_QWORD **)(v3 + 8);
  v57[0] = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v6, (const void **)"outer_dims_perm", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v57))return 0;
  v57[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v4, (const void **)"inner_dims_pos", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v57))return 0;
  v57[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v5, (const void **)"static_inner_tiles", (const char *)0x12, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v57))return 0;
  v54 = 0;
  v7 = *((unsigned int *)*this + 11);
  v8 = (uint64_t)&(*this)[2 * ((v7 >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v8 = 0;
  v9 = *(unsigned int *)(v8 + 24);
  if ((v7 & 0x800000) != 0)
  {
    v10 = (*this)[9];
    if ((_DWORD)v9)
      goto LABEL_13;
  }
  else
  {
    v10 = 0;
    if ((_DWORD)v9)
    {
LABEL_13:
      v11 = 0;
      v12 = v10 + 24;
      while (1)
      {
        v13 = *this;
        v14 = *(_QWORD *)(*(_QWORD *)v12 + 8) & 0xFFFFFFFFFFFFFFF8;
        v54 = v11 + 1;
        if (!mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(v13, v14, (const void **)"operand", (const void **)7, v11))return 0;
        ++v11;
        v12 += 32;
        if (v9 == v11)
        {
          ODSOperands = mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 1u);
          if (!v16)
            goto LABEL_56;
          goto LABEL_17;
        }
      }
    }
  }
  LODWORD(v11) = 0;
  ODSOperands = mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 1u);
  if (v16)
  {
LABEL_17:
    v17 = v16;
    v18 = ODSOperands + 24;
    while (1)
    {
      v19 = *this;
      v20 = *(_QWORD *)(*(_QWORD *)v18 + 8) & 0xFFFFFFFFFFFFFFF8;
      v21 = v11 + 1;
      v54 = v11 + 1;
      if (!mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(v19, v20, (const void **)"operand", (const void **)7, v11))return 0;
      v18 += 32;
      LODWORD(v11) = v11 + 1;
      if (!--v17)
      {
        mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 2u);
        v23 = v22;
        if (v22 < 2)
          goto LABEL_57;
        goto LABEL_21;
      }
    }
  }
LABEL_56:
  v21 = v11;
  mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 2u);
  v23 = v42;
  if (v42 >= 2)
  {
LABEL_21:
    v55[0] = (const void **)"operand group starting at #";
    v56 = 259;
    mlir::OpState::emitOpError(this, v55, (uint64_t)v57);
    v24 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v57, &v54);
    v25 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v24, " requires 0 or 1 element, but found ");
    v53 = v23;
    v26 = (_QWORD *)mlir::InFlightDiagnostic::operator<<<unsigned long>(v25, &v53);
LABEL_70:
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v26);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v57);
    return v27;
  }
LABEL_57:
  v43 = mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 3u);
  if (v44)
  {
    v45 = v44;
    v46 = v21 + v23;
    v47 = v43 + 24;
    while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v47 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v46))
    {
      ++v46;
      v47 += 32;
      if (!--v45)
        goto LABEL_61;
    }
    return 0;
  }
LABEL_61:
  v48 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v48, 0);
  if (!mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0))return 0;
  v27 = 1;
  v50 = *(_QWORD *)(*(_QWORD *)(mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 1u)+ 24)+ 8) & 0xFFFFFFFFFFFFFFF8;
  if (*((_DWORD *)*this + 9))
    v51 = (uint64_t)(*this - 2);
  else
    v51 = 0;
  if (v50 != (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v51, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    v55[0] = (const void **)"failed to verify that result type matches type of dest";
    v56 = 259;
    mlir::OpState::emitOpError(this, v55, (uint64_t)v57);
    v26 = v57;
    goto LABEL_70;
  }
  return v27;
}

uint64_t mlir::tensor::PackOp::getCanonicalizationPatterns(uint64_t *a1)
{
  __int16 v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t result;
  _QWORD *v6;
  _QWORD *v7;
  __int16 v8;
  _QWORD *v9;

  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  v2 = v8;
  v3 = *a1;
  v4 = (_QWORD *)operator new();
  result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"tensor.pack", 11, v2, v3, 0, 0);
  *v4 = &off_24C05E228;
  v4[12] = mlir::tensor::PackOp::canonicalize;
  v9 = v4;
  v6 = (_QWORD *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    v9 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::tensor::PackOp::parse(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned __int16 v6;
  uint64_t *v7;
  char *v8;
  char *v9;
  __int128 v10;
  unsigned __int16 v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  mlir::IndexType **v27;
  mlir::MLIRContext *v28;
  uint64_t v29;
  _QWORD *v30;
  char *v31;
  uint64_t v32;
  unint64_t v34;
  int64_t v35;
  uint64_t IndexType;
  _QWORD v37[4];
  __int16 v38;
  uint64_t v39;
  _QWORD v40[2];
  _QWORD v41[2];
  uint64_t v42[2];
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46[2];
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  __int16 v50;
  uint64_t __src;
  uint64_t v52;
  void *v53[4];
  void *v54;
  uint64_t v55;
  _BYTE v56[128];
  void *v57[2];
  uint64_t v58;
  void *v59;
  uint64_t v60;
  _BYTE v61[128];
  _QWORD v62[6];

  v62[4] = *MEMORY[0x24BDAC8D0];
  memset(v62, 0, 24);
  v46[0] = (uint64_t)v62;
  v46[1] = 1;
  v59 = v61;
  v60 = 0x400000000;
  v57[0] = &v58;
  v57[1] = (void *)0x100000000;
  v44 = 0;
  v45 = 0;
  v54 = v56;
  v55 = 0x400000000;
  v42[1] = 1;
  v43 = 0;
  memset(v53, 0, 24);
  v41[1] = 1;
  v42[0] = (uint64_t)v53;
  __src = 0;
  v52 = 0;
  v40[1] = 1;
  v41[0] = &v52;
  v40[0] = &__src;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v62, 1))
    goto LABEL_47;
  if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "padding_value", 13))
  {
    if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 264))(a1))
      goto LABEL_47;
    v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    v47 = 0;
    v48 = 0;
    v49 = 0;
    v6 = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(*(_QWORD *)a1 + 680))(a1, &v47, 1);
    if (v6 >= 0x100u)
    {
      if (!(_BYTE)v6)
        goto LABEL_47;
      v7 = &v47;
      v8 = (char *)v59;
      if (v60 >= HIDWORD(v60))
      {
        v34 = v60 + 1;
        if (v59 <= &v47 && (char *)v59 + 32 * v60 > (char *)&v47)
        {
          v35 = (char *)&v47 - (_BYTE *)v59;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v61, v34, 32);
          v8 = (char *)v59;
          v7 = (uint64_t *)((char *)v59 + v35);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v61, v34, 32);
          v7 = &v47;
          v8 = (char *)v59;
        }
      }
      v9 = &v8[32 * v60];
      v10 = *((_OWORD *)v7 + 1);
      *(_OWORD *)v9 = *(_OWORD *)v7;
      *((_OWORD *)v9 + 1) = v10;
      LODWORD(v60) = v60 + 1;
    }
    if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
      goto LABEL_47;
    v47 = 0;
    v11 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 520))(a1, &v47);
    if (v11 >= 0x100u)
    {
      if (!(_BYTE)v11)
        goto LABEL_47;
      llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back((uint64_t)v57, v47);
    }
    if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 280))(a1))
      goto LABEL_47;
  }
  else
  {
    v5 = 0;
  }
  if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "outer_dims_perm", 15))
  {
    if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1)
      || !mlir::AsmParser::parseCustomAttributeWithFallback<mlir::detail::DenseArrayAttrImpl<long long>>(a1, &v45, 0))
    {
      goto LABEL_47;
    }
    if (v45)
    {
      v12 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PackOpGenericAdaptorBase::Properties>(a2);
      *(_QWORD *)(v12 + 8) = v45;
    }
  }
  v50 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 368))(a1, "inner_dims_pos", 14, &v47)|| !(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1)|| !mlir::AsmParser::parseCustomAttributeWithFallback<mlir::detail::DenseArrayAttrImpl<long long>>(a1, &v44, 0))
  {
    goto LABEL_47;
  }
  if (v44)
  {
    v13 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PackOpGenericAdaptorBase::Properties>(a2);
    *v13 = v44;
  }
  v50 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 368))(a1, "inner_tiles", 11, &v47))goto LABEL_47;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1))
    goto LABEL_47;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v47 = 0;
  if (!mlir::parseDynamicIndexList(a1, (uint64_t)&v54, &v43, &v47, 0, 2))
    goto LABEL_47;
  v14 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PackOpGenericAdaptorBase::Properties>(a2);
  *(_QWORD *)(v14 + 16) = v43;
  v50 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 368))(a1, "into", 4, &v47))goto LABEL_47;
  v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void **, uint64_t))(*(_QWORD *)a1 + 672))(a1, v53, 1))
    goto LABEL_47;
  v37[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
    goto LABEL_47;
  v16 = a2[1];
  v47 = a1;
  v48 = v37;
  v49 = a2;
  if (!mlir::tensor::PackOp::verifyInherentAttrs(v16, (uint64_t)(a2 + 14), (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::PackOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v47))goto LABEL_47;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    goto LABEL_47;
  v47 = 0;
  if (!mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, &v47))
    goto LABEL_47;
  v52 = v47;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1))
    goto LABEL_47;
  v47 = 0;
  if (!mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, &v47))
    goto LABEL_47;
  __src = v47;
  v17 = v60;
  v18 = v55;
  v19 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PackOpGenericAdaptorBase::Properties>(a2);
  *(_QWORD *)(v19 + 24) = 0x100000001;
  *(_DWORD *)(v19 + 32) = v17;
  *(_DWORD *)(v19 + 36) = v18;
  v20 = __src;
  v39 = __src;
  if (*(_UNKNOWN **)(*(_QWORD *)__src + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v38 = 257;
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(&v47, a1, v21, v37);
    v22 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)&v47, "'dest' must be ranked tensor of any type values, but got ");
    v23 = mlir::InFlightDiagnostic::append<mlir::Type &>(v22, &v39);
    v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v23);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v47);
    v25 = v54;
    if (v54 == v56)
      goto LABEL_50;
    goto LABEL_49;
  }
  v26 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)__src + 8);
  v47 = v20;
  v48 = (_QWORD *)v26;
  mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v47);
  v27 = (mlir::IndexType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  IndexType = mlir::Builder::getIndexType(v27, v28);
  mlir::OperationState::addTypes((uint64_t)a2, &__src, 1);
  if (!mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v46, v41, v4, (uint64_t)(a2 + 2)))goto LABEL_47;
  v29 = v15;
  v30 = a2 + 2;
  if (!mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v42, v40, v29, (uint64_t)(a2 + 2))|| !mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>(a1, (uint64_t *)&v59, (uint64_t)v57, v5, (uint64_t)(a2 + 2)))
  {
    goto LABEL_47;
  }
  if (!(_DWORD)v55)
  {
    v24 = 1;
    v25 = v54;
    if (v54 == v56)
      goto LABEL_50;
LABEL_49:
    free(v25);
    goto LABEL_50;
  }
  v31 = (char *)v54;
  v32 = 32 * v55;
  v24 = 1;
  while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 696))(a1, v31, IndexType, v30))
  {
    v31 += 32;
    v32 -= 32;
    if (!v32)
      goto LABEL_48;
  }
LABEL_47:
  v24 = 0;
LABEL_48:
  v25 = v54;
  if (v54 != v56)
    goto LABEL_49;
LABEL_50:
  if (v57[0] != &v58)
    free(v57[0]);
  if (v59 != v61)
    free(v59);
  return v24;
}

void mlir::tensor::PackOp::print(mlir::tensor::PackOp *this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unint64_t v6;
  _DWORD *v7;
  int v8;
  uint64_t v9;
  llvm::raw_ostream *v10;
  _BYTE *v11;
  llvm::raw_ostream *v12;
  void *v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  unint64_t v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  llvm::raw_ostream *v20;
  _BYTE *v21;
  llvm::raw_ostream *v22;
  _BYTE *v23;
  llvm::raw_ostream *v24;
  _BYTE *v25;
  uint64_t v26;
  unint64_t v27;
  _DWORD *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  llvm::raw_ostream *v32;
  _BYTE *v33;
  unint64_t v34;
  llvm::raw_ostream *v35;
  _BYTE *v36;
  llvm::raw_ostream *v37;
  void *v38;
  llvm::raw_ostream *v39;
  _BYTE *v40;
  llvm::raw_ostream *v41;
  _BYTE *v42;
  llvm::raw_ostream *v43;
  _BYTE *v44;
  unint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  llvm::raw_ostream *v48;
  _BYTE *v49;
  llvm::raw_ostream *v50;
  void *v51;
  llvm::raw_ostream *v52;
  _BYTE *v53;
  llvm::raw_ostream *v54;
  _BYTE *v55;
  llvm::raw_ostream *v56;
  _BYTE *v57;
  _QWORD *v58;
  uint64_t v59;
  llvm::raw_ostream *v60;
  _BYTE *v61;
  llvm::raw_ostream *v62;
  uint64_t v63;
  llvm::raw_ostream *v64;
  _BYTE *v65;
  llvm::raw_ostream *v66;
  _BYTE *v67;
  llvm::raw_ostream *v68;
  _BYTE *v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t *v77;
  uint64_t v78;
  uint64_t v79;
  llvm::raw_ostream *v80;
  _BYTE *v81;
  llvm::raw_ostream *v82;
  _DWORD *v83;
  llvm::raw_ostream *v84;
  _BYTE *v85;
  uint64_t v86;
  _QWORD *v87;
  uint64_t v88;
  _QWORD *v89;
  unint64_t v90;
  uint64_t v91;
  mlir::Operation *v92;
  mlir::ArrayAttr *p_Context;
  unsigned int v94;
  _QWORD *v95;
  uint64_t Value;
  uint64_t v97;
  llvm::raw_ostream *v98;
  _BYTE *v99;
  llvm::raw_ostream *v100;
  _BYTE *v101;
  llvm::raw_ostream *v102;
  _BYTE *v103;
  llvm::raw_ostream *v104;
  _BYTE *v105;
  llvm::raw_ostream *v106;
  _WORD *v107;
  llvm::raw_ostream *v108;
  _BYTE *v109;
  uint64_t v110;
  mlir::MLIRContext *Context;
  void *v112;
  uint64_t v113;
  _QWORD v114[4];
  unint64_t v115[3];

  v115[2] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 24));
  v6 = *(unsigned int *)(*(_QWORD *)this + 44);
  v7 = (_DWORD *)(*(_QWORD *)this + 16 * ((v6 >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v7 = 0;
  v8 = v7[8];
  if ((v6 & 0x800000) != 0)
  {
    v9 = *(_QWORD *)(*(_QWORD *)this + 72);
    if (!v8)
      goto LABEL_42;
  }
  else
  {
    v9 = 0;
    if (!v8)
      goto LABEL_42;
  }
  if (!*(_QWORD *)(v9 + 32 * (v7[7] + v7[6]) + 24))
    goto LABEL_42;
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (_BYTE *)*((_QWORD *)v10 + 4);
  if ((unint64_t)v11 >= *((_QWORD *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }
  else
  {
    *((_QWORD *)v10 + 4) = v11 + 1;
    *v11 = 32;
  }
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (void *)*((_QWORD *)v12 + 4);
  if (*((_QWORD *)v12 + 3) - (_QWORD)v13 > 0xCuLL)
  {
    qmemcpy(v13, "padding_value", 13);
    *((_QWORD *)v12 + 4) += 13;
  }
  else
  {
    llvm::raw_ostream::write(v12, "padding_value", 0xDuLL);
  }
  v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)v14 + 4);
  if (*((_BYTE **)v14 + 3) == v15)
  {
    llvm::raw_ostream::write(v14, "(", 1uLL);
  }
  else
  {
    *v15 = 40;
    ++*((_QWORD *)v14 + 4);
  }
  v16 = *(unsigned int *)(*(_QWORD *)this + 44);
  v17 = (_DWORD *)(*(_QWORD *)this + 16 * ((v16 >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v17 = 0;
  v18 = v17[8];
  if ((v16 & 0x800000) != 0)
  {
    v19 = *(_QWORD *)(*(_QWORD *)this + 72);
    if (!v18)
      goto LABEL_24;
  }
  else
  {
    v19 = 0;
    if (!v18)
      goto LABEL_24;
  }
  if (*(_QWORD *)(v19 + 32 * (v17[7] + v17[6]) + 24))
    (*(void (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 160))(a2);
LABEL_24:
  v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v21 = (_BYTE *)*((_QWORD *)v20 + 4);
  if ((unint64_t)v21 >= *((_QWORD *)v20 + 3))
  {
    llvm::raw_ostream::write(v20, 32);
  }
  else
  {
    *((_QWORD *)v20 + 4) = v21 + 1;
    *v21 = 32;
  }
  v22 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v23 = (_BYTE *)*((_QWORD *)v22 + 4);
  if (*((_BYTE **)v22 + 3) == v23)
  {
    llvm::raw_ostream::write(v22, ":", 1uLL);
  }
  else
  {
    *v23 = 58;
    ++*((_QWORD *)v22 + 4);
  }
  v24 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v25 = (_BYTE *)*((_QWORD *)v24 + 4);
  if ((unint64_t)v25 >= *((_QWORD *)v24 + 3))
  {
    llvm::raw_ostream::write(v24, 32);
  }
  else
  {
    *((_QWORD *)v24 + 4) = v25 + 1;
    *v25 = 32;
  }
  v26 = *(_QWORD *)this;
  v27 = *(unsigned int *)(*(_QWORD *)this + 44);
  v28 = (_DWORD *)(*(_QWORD *)this + 16 * ((v27 >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v28 = 0;
  v29 = v28[8];
  if ((v27 & 0x800000) != 0)
  {
    v30 = *(_QWORD *)(v26 + 72);
    if (v29)
      goto LABEL_37;
  }
  else
  {
    v30 = 0;
    if (v29)
    {
LABEL_37:
      v31 = (v28[7] + v28[6]);
      if (*(_QWORD *)(v30 + 32 * v31 + 24))
        (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v26 + 72) + 32 * v31 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  v32 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v33 = (_BYTE *)*((_QWORD *)v32 + 4);
  if (*((_BYTE **)v32 + 3) == v33)
  {
    llvm::raw_ostream::write(v32, ")", 1uLL);
  }
  else
  {
    *v33 = 41;
    ++*((_QWORD *)v32 + 4);
  }
LABEL_42:
  v34 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v34 = 0;
  if (*(_QWORD *)(v34 + 8))
  {
    v35 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v36 = (_BYTE *)*((_QWORD *)v35 + 4);
    if ((unint64_t)v36 >= *((_QWORD *)v35 + 3))
    {
      llvm::raw_ostream::write(v35, 32);
    }
    else
    {
      *((_QWORD *)v35 + 4) = v36 + 1;
      *v36 = 32;
    }
    v37 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v38 = (void *)*((_QWORD *)v37 + 4);
    if (*((_QWORD *)v37 + 3) - (_QWORD)v38 > 0xEuLL)
    {
      qmemcpy(v38, "outer_dims_perm", 15);
      *((_QWORD *)v37 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(v37, "outer_dims_perm", 0xFuLL);
    }
    v39 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v40 = (_BYTE *)*((_QWORD *)v39 + 4);
    if ((unint64_t)v40 >= *((_QWORD *)v39 + 3))
    {
      llvm::raw_ostream::write(v39, 32);
    }
    else
    {
      *((_QWORD *)v39 + 4) = v40 + 1;
      *v40 = 32;
    }
    v41 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v42 = (_BYTE *)*((_QWORD *)v41 + 4);
    if (*((_BYTE **)v41 + 3) == v42)
    {
      llvm::raw_ostream::write(v41, "=", 1uLL);
    }
    else
    {
      *v42 = 61;
      ++*((_QWORD *)v41 + 4);
    }
    v43 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v44 = (_BYTE *)*((_QWORD *)v43 + 4);
    if ((unint64_t)v44 >= *((_QWORD *)v43 + 3))
    {
      llvm::raw_ostream::write(v43, 32);
    }
    else
    {
      *((_QWORD *)v43 + 4) = v44 + 1;
      *v44 = 32;
    }
    v45 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
    if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
      v45 = 0;
    v112 = *(void **)(v45 + 8);
    if (!(*(unsigned __int8 (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 104))(a2))
    {
      v46 = (_QWORD *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
      v47 = (*(uint64_t (**)(_QWORD *))(*v46 + 80))(v46) + v46[4] - v46[2];
      mlir::detail::DenseArrayAttrImpl<long long>::print((llvm::raw_ostream *)&v112, (uint64_t)a2);
      if (v47 == (*(uint64_t (**)(_QWORD *))(*v46 + 80))(v46) + v46[4] - v46[2])
        (*(void (**)(mlir::OpAsmPrinter *, void *))(*(_QWORD *)a2 + 40))(a2, v112);
    }
  }
  v48 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v49 = (_BYTE *)*((_QWORD *)v48 + 4);
  if ((unint64_t)v49 >= *((_QWORD *)v48 + 3))
  {
    llvm::raw_ostream::write(v48, 32);
  }
  else
  {
    *((_QWORD *)v48 + 4) = v49 + 1;
    *v49 = 32;
  }
  v50 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v51 = (void *)*((_QWORD *)v50 + 4);
  if (*((_QWORD *)v50 + 3) - (_QWORD)v51 > 0xDuLL)
  {
    qmemcpy(v51, "inner_dims_pos", 14);
    *((_QWORD *)v50 + 4) += 14;
  }
  else
  {
    llvm::raw_ostream::write(v50, "inner_dims_pos", 0xEuLL);
  }
  v52 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v53 = (_BYTE *)*((_QWORD *)v52 + 4);
  if ((unint64_t)v53 >= *((_QWORD *)v52 + 3))
  {
    llvm::raw_ostream::write(v52, 32);
  }
  else
  {
    *((_QWORD *)v52 + 4) = v53 + 1;
    *v53 = 32;
  }
  v54 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v55 = (_BYTE *)*((_QWORD *)v54 + 4);
  if (*((_BYTE **)v54 + 3) == v55)
  {
    llvm::raw_ostream::write(v54, "=", 1uLL);
  }
  else
  {
    *v55 = 61;
    ++*((_QWORD *)v54 + 4);
  }
  v56 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v57 = (_BYTE *)*((_QWORD *)v56 + 4);
  if ((unint64_t)v57 >= *((_QWORD *)v56 + 3))
  {
    llvm::raw_ostream::write(v56, 32);
  }
  else
  {
    *((_QWORD *)v56 + 4) = v57 + 1;
    *v57 = 32;
  }
  v112 = *(void **)(*(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64);
  if (!(*(unsigned __int8 (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 104))(a2))
  {
    v58 = (_QWORD *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v59 = (*(uint64_t (**)(_QWORD *))(*v58 + 80))(v58) + v58[4] - v58[2];
    mlir::detail::DenseArrayAttrImpl<long long>::print((llvm::raw_ostream *)&v112, (uint64_t)a2);
    if (v59 == (*(uint64_t (**)(_QWORD *))(*v58 + 80))(v58) + v58[4] - v58[2])
      (*(void (**)(mlir::OpAsmPrinter *, void *))(*(_QWORD *)a2 + 40))(a2, v112);
  }
  v60 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v61 = (_BYTE *)*((_QWORD *)v60 + 4);
  if ((unint64_t)v61 >= *((_QWORD *)v60 + 3))
  {
    llvm::raw_ostream::write(v60, 32);
  }
  else
  {
    *((_QWORD *)v60 + 4) = v61 + 1;
    *v61 = 32;
  }
  v62 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v63 = *((_QWORD *)v62 + 4);
  if ((unint64_t)(*((_QWORD *)v62 + 3) - v63) > 0xA)
  {
    *(_DWORD *)(v63 + 7) = 1936026729;
    *(_QWORD *)v63 = *(_QWORD *)"inner_tiles";
    *((_QWORD *)v62 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v62, "inner_tiles", 0xBuLL);
  }
  v64 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v65 = (_BYTE *)*((_QWORD *)v64 + 4);
  if ((unint64_t)v65 >= *((_QWORD *)v64 + 3))
  {
    llvm::raw_ostream::write(v64, 32);
  }
  else
  {
    *((_QWORD *)v64 + 4) = v65 + 1;
    *v65 = 32;
  }
  v66 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v67 = (_BYTE *)*((_QWORD *)v66 + 4);
  if (*((_BYTE **)v66 + 3) == v67)
  {
    llvm::raw_ostream::write(v66, "=", 1uLL);
  }
  else
  {
    *v67 = 61;
    ++*((_QWORD *)v66 + 4);
  }
  v68 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v69 = (_BYTE *)*((_QWORD *)v68 + 4);
  if ((unint64_t)v69 >= *((_QWORD *)v68 + 3))
  {
    llvm::raw_ostream::write(v68, 32);
  }
  else
  {
    *((_QWORD *)v68 + 4) = v69 + 1;
    *v69 = 32;
  }
  v70 = *(_QWORD *)this;
  v71 = *(unsigned int *)(*(_QWORD *)this + 44);
  v72 = *(_QWORD *)this + 16 * ((v71 >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v72 = 0;
  if ((v71 & 0x800000) != 0)
    v73 = *(_QWORD *)(v70 + 72);
  else
    v73 = 0;
  v74 = (*(_DWORD *)(v72 + 28) + *(_DWORD *)(v72 + 24) + *(_DWORD *)(v72 + 32));
  v75 = v73 + 32 * v74;
  v76 = (*(_DWORD *)(v72 + 36) + v74) - v74;
  v112 = *(void **)(v72 + 16);
  v77 = (unint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v112);
  v79 = v78;
  mlir::ValueRange::ValueRange(v115, 0, 0);
  mlir::printDynamicIndexList((uint64_t)a2, v70, v75, v76, v77, v79, v115[0], v115[1], 0, 0, 2);
  v80 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v81 = (_BYTE *)*((_QWORD *)v80 + 4);
  if ((unint64_t)v81 >= *((_QWORD *)v80 + 3))
  {
    llvm::raw_ostream::write(v80, 32);
  }
  else
  {
    *((_QWORD *)v80 + 4) = v81 + 1;
    *v81 = 32;
  }
  v82 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v83 = (_DWORD *)*((_QWORD *)v82 + 4);
  if (*((_QWORD *)v82 + 3) - (_QWORD)v83 > 3uLL)
  {
    *v83 = 1869901417;
    *((_QWORD *)v82 + 4) += 4;
  }
  else
  {
    llvm::raw_ostream::write(v82, "into", 4uLL);
  }
  v84 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v85 = (_BYTE *)*((_QWORD *)v84 + 4);
  if ((unint64_t)v85 >= *((_QWORD *)v84 + 3))
  {
    llvm::raw_ostream::write(v84, 32);
  }
  else
  {
    *((_QWORD *)v84 + 4) = v85 + 1;
    *v85 = 32;
  }
  if (*(_BYTE *)(*(_QWORD *)this + 47))
    v86 = *(_QWORD *)this + 80;
  else
    v86 = 0;
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 32 * *(unsigned int *)(v86 + 24) + 24));
  v112 = v114;
  v114[0] = "operandSegmentSizes";
  v114[1] = 19;
  v114[2] = "outer_dims_perm";
  v114[3] = 15;
  v113 = 0x200000002;
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v114, 3uLL, 16);
  v87 = (char *)v112 + 16 * v113;
  *v87 = "inner_dims_pos";
  v87[1] = 14;
  v88 = (v113 + 1);
  LODWORD(v113) = v88;
  if (v88 >= HIDWORD(v113))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v114, v88 + 1, 16);
    LODWORD(v88) = v113;
  }
  v89 = (char *)v112 + 16 * v88;
  *v89 = "static_inner_tiles";
  v89[1] = 18;
  LODWORD(v113) = v113 + 1;
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)this + 24));
  v90 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v90 = 0;
  v91 = *(_QWORD *)(v90 + 8);
  if (v91 && v91 == mlir::Builder::getDenseI64ArrayAttr(&Context, 0, 0))
  {
    v94 = v113;
    if (v113 >= HIDWORD(v113))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v114, v113 + 1, 16);
      v94 = v113;
    }
    v95 = (char *)v112 + 16 * v94;
    *v95 = "outer_dims_perm";
    v95[1] = 15;
    LODWORD(v113) = v113 + 1;
    v92 = *(mlir::Operation **)this;
    if (!*(_BYTE *)(*(_QWORD *)this + 47))
      goto LABEL_121;
  }
  else
  {
    v92 = *(mlir::Operation **)this;
    if (!*(_BYTE *)(*(_QWORD *)this + 47))
    {
LABEL_121:
      p_Context = (mlir::Operation *)((char *)v92 + 56);
      goto LABEL_126;
    }
  }
  Context = (mlir::MLIRContext *)mlir::Operation::getAttrDictionary(v92);
  p_Context = (mlir::ArrayAttr *)&Context;
LABEL_126:
  Value = mlir::ArrayAttr::getValue(p_Context);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v97, v112, v113);
  v98 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v99 = (_BYTE *)*((_QWORD *)v98 + 4);
  if ((unint64_t)v99 >= *((_QWORD *)v98 + 3))
  {
    llvm::raw_ostream::write(v98, 32);
  }
  else
  {
    *((_QWORD *)v98 + 4) = v99 + 1;
    *v99 = 32;
  }
  v100 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v101 = (_BYTE *)*((_QWORD *)v100 + 4);
  if (*((_BYTE **)v100 + 3) == v101)
  {
    llvm::raw_ostream::write(v100, ":", 1uLL);
  }
  else
  {
    *v101 = 58;
    ++*((_QWORD *)v100 + 4);
  }
  v102 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v103 = (_BYTE *)*((_QWORD *)v102 + 4);
  if ((unint64_t)v103 >= *((_QWORD *)v102 + 3))
  {
    llvm::raw_ostream::write(v102, 32);
  }
  else
  {
    *((_QWORD *)v102 + 4) = v103 + 1;
    *v103 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v104 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v105 = (_BYTE *)*((_QWORD *)v104 + 4);
  if ((unint64_t)v105 >= *((_QWORD *)v104 + 3))
  {
    llvm::raw_ostream::write(v104, 32);
  }
  else
  {
    *((_QWORD *)v104 + 4) = v105 + 1;
    *v105 = 32;
  }
  v106 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v107 = (_WORD *)*((_QWORD *)v106 + 4);
  if (*((_QWORD *)v106 + 3) - (_QWORD)v107 > 1uLL)
  {
    *v107 = 15917;
    *((_QWORD *)v106 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v106, "->", 2uLL);
  }
  v108 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v109 = (_BYTE *)*((_QWORD *)v108 + 4);
  if ((unint64_t)v109 >= *((_QWORD *)v108 + 3))
  {
    llvm::raw_ostream::write(v108, 32);
  }
  else
  {
    *((_QWORD *)v108 + 4) = v109 + 1;
    *v109 = 32;
  }
  if (*(_BYTE *)(*(_QWORD *)this + 47))
    v110 = *(_QWORD *)this + 80;
  else
    v110 = 0;
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 32 * *(unsigned int *)(v110 + 24) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v112 != v114)
    free(v112);
}

uint64_t mlir::tensor::detail::PadOpGenericAdaptorBase::PadOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t Context;
  unint64_t v12[3];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v12, v7, v6);
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v5;
  v9 = *(_OWORD *)(v5 + 16);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(v5 + 32);
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)v12;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "tensor.pad", 10, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::tensor::PadOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v40;
  int *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  int *v56;
  char *v57;
  char *v58;
  __int128 v59;
  _QWORD *v60;
  _QWORD *v61;
  void *v62;
  _QWORD *v63;
  uint64_t v64;
  uint64_t v65;
  int *v66;
  char *v67;
  char *v68;
  __int128 v69;
  _QWORD *v70;
  _QWORD *v71;
  void *v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  int *v76;
  char *v77;
  char *v78;
  __int128 v79;
  int *v80;
  char *v81;
  char *v82;
  __int128 v83;
  _QWORD *v84;
  _QWORD *v85;
  void *v86;
  _QWORD *v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  int64_t v99;
  int64_t v100;
  int64_t v101;
  int64_t v102;
  int64_t v103;
  int64_t v104;
  int64_t v105;
  int64_t v106;
  int64_t v107;
  uint64_t v108;
  int v109;
  const char *v110;
  uint64_t v111;
  _QWORD v112[3];
  void *v113;
  unsigned int v114;
  unsigned int v115;
  _BYTE v116[96];
  void *v117;
  _QWORD *v118;
  void *__p;
  _QWORD *v120;
  char v121;
  uint64_t v122;

  v122 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v108 = v6;
  if (!v6)
  {
    a3(v112, a4);
    if (v112[0])
    {
      v109 = 3;
      v110 = "expected DictionaryAttr to set properties";
      v111 = 41;
      v26 = &v109;
      v27 = (char *)v113;
      if (v114 >= v115)
      {
        v90 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v99 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v90, 24);
          v27 = (char *)v113;
          v26 = (int *)((char *)v113 + v99);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v90, 24);
          v26 = &v109;
          v27 = (char *)v113;
        }
      }
      v28 = &v27[24 * v114];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v30 = __p;
    if (__p)
    {
      v31 = v120;
      v32 = __p;
      if (v120 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v120 = v30;
      operator delete(v32);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_120;
    v33 = v118;
    v23 = v117;
    if (v118 == v117)
    {
LABEL_119:
      v118 = v21;
      operator delete(v23);
LABEL_120:
      if (v113 != v116)
        free(v113);
      return 0;
    }
    do
    {
      v35 = *--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
    }
    while (v33 != v21);
LABEL_118:
    v23 = v117;
    goto LABEL_119;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v108, "nofold", 6uLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v112, a4);
      if (v112[0])
      {
        v109 = 3;
        v111 = 51;
        v10 = &v109;
        v11 = (char *)v113;
        if (v114 >= v115)
        {
          v91 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            v100 = (char *)&v109 - (_BYTE *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
            v11 = (char *)v113;
            v10 = (int *)((char *)v113 + v100);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
            v10 = &v109;
            v11 = (char *)v113;
          }
        }
        v12 = &v11[24 * v114];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
        *(_OWORD *)v12 = v13;
        ++v114;
        if (v112[0])
        {
          v14 = &v109;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v9);
          v15 = (char *)v113;
          if (v114 >= v115)
          {
            v92 = v114 + 1;
            if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
            {
              v101 = (char *)&v109 - (_BYTE *)v113;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
              v15 = (char *)v113;
              v14 = (int *)((char *)v113 + v101);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
              v14 = &v109;
              v15 = (char *)v113;
            }
          }
          v16 = &v15[24 * v114];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
          *(_OWORD *)v16 = v17;
          ++v114;
          if (v112[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
        }
      }
      if (!v121)
        return 0;
      v18 = __p;
      if (__p)
      {
        v19 = v120;
        v20 = __p;
        if (v120 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v120 = v18;
        operator delete(v20);
      }
      v21 = v117;
      if (!v117)
        goto LABEL_120;
      v22 = v118;
      v23 = v117;
      if (v118 == v117)
        goto LABEL_119;
      do
      {
        v25 = *--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
      }
      while (v22 != v21);
      goto LABEL_118;
    }
    *a1 = v8;
  }
  v36 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v108, "static_high", 0xBuLL);
  if (!v36)
  {
    a3(v112, a4);
    if (v112[0])
    {
      v109 = 3;
      v110 = "expected key entry for static_high in DictionaryAttr to set Properties.";
      v111 = 71;
      v42 = &v109;
      v43 = (char *)v113;
      if (v114 >= v115)
      {
        v93 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v102 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
          v43 = (char *)v113;
          v42 = (int *)((char *)v113 + v102);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
          v42 = &v109;
          v43 = (char *)v113;
        }
      }
      v44 = &v43[24 * v114];
      v45 = *(_OWORD *)v42;
      *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
      *(_OWORD *)v44 = v45;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v46 = __p;
    if (__p)
    {
      v47 = v120;
      v48 = __p;
      if (v120 != __p)
      {
        do
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        v48 = __p;
      }
      v120 = v46;
      operator delete(v48);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_120;
    v49 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_119;
    do
    {
      v51 = *--v49;
      v50 = v51;
      *v49 = 0;
      if (v51)
        MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
    }
    while (v49 != v21);
    goto LABEL_118;
  }
  v37 = (uint64_t)v36;
  if (!mlir::detail::DenseArrayAttrImpl<long long>::classof(v36))
  {
    a3(v112, a4);
    if (v112[0])
    {
      v109 = 3;
      v111 = 56;
      v52 = &v109;
      v53 = (char *)v113;
      if (v114 >= v115)
      {
        v94 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v103 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
          v53 = (char *)v113;
          v52 = (int *)((char *)v113 + v103);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
          v52 = &v109;
          v53 = (char *)v113;
        }
      }
      v54 = &v53[24 * v114];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
      *(_OWORD *)v54 = v55;
      ++v114;
      if (v112[0])
      {
        v56 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v37);
        v57 = (char *)v113;
        if (v114 >= v115)
        {
          v95 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            v104 = (char *)&v109 - (_BYTE *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
            v57 = (char *)v113;
            v56 = (int *)((char *)v113 + v104);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
            v56 = &v109;
            v57 = (char *)v113;
          }
        }
        v58 = &v57[24 * v114];
        v59 = *(_OWORD *)v56;
        *((_QWORD *)v58 + 2) = *((_QWORD *)v56 + 2);
        *(_OWORD *)v58 = v59;
        ++v114;
        if (v112[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121)
      return 0;
    v60 = __p;
    if (__p)
    {
      v61 = v120;
      v62 = __p;
      if (v120 != __p)
      {
        do
          v61 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v61 - 1);
        while (v61 != v60);
        v62 = __p;
      }
      v120 = v60;
      operator delete(v62);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_120;
    v63 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_119;
    do
    {
      v65 = *--v63;
      v64 = v65;
      *v63 = 0;
      if (v65)
        MEMORY[0x20BD002D4](v64, 0x1000C8077774924);
    }
    while (v63 != v21);
    goto LABEL_118;
  }
  a1[1] = v37;
  v38 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v108, "static_low", 0xAuLL);
  if (!v38)
  {
    a3(v112, a4);
    if (v112[0])
    {
      v109 = 3;
      v110 = "expected key entry for static_low in DictionaryAttr to set Properties.";
      v111 = 70;
      v66 = &v109;
      v67 = (char *)v113;
      if (v114 >= v115)
      {
        v96 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v105 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          v67 = (char *)v113;
          v66 = (int *)((char *)v113 + v105);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          v66 = &v109;
          v67 = (char *)v113;
        }
      }
      v68 = &v67[24 * v114];
      v69 = *(_OWORD *)v66;
      *((_QWORD *)v68 + 2) = *((_QWORD *)v66 + 2);
      *(_OWORD *)v68 = v69;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v70 = __p;
    if (__p)
    {
      v71 = v120;
      v72 = __p;
      if (v120 != __p)
      {
        do
          v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
        while (v71 != v70);
        v72 = __p;
      }
      v120 = v70;
      operator delete(v72);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_120;
    v73 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_119;
    do
    {
      v75 = *--v73;
      v74 = v75;
      *v73 = 0;
      if (v75)
        MEMORY[0x20BD002D4](v74, 0x1000C8077774924);
    }
    while (v73 != v21);
    goto LABEL_118;
  }
  v39 = (uint64_t)v38;
  if (!mlir::detail::DenseArrayAttrImpl<long long>::classof(v38))
  {
    a3(v112, a4);
    if (v112[0])
    {
      v109 = 3;
      v111 = 55;
      v76 = &v109;
      v77 = (char *)v113;
      if (v114 >= v115)
      {
        v97 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v106 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
          v77 = (char *)v113;
          v76 = (int *)((char *)v113 + v106);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
          v76 = &v109;
          v77 = (char *)v113;
        }
      }
      v78 = &v77[24 * v114];
      v79 = *(_OWORD *)v76;
      *((_QWORD *)v78 + 2) = *((_QWORD *)v76 + 2);
      *(_OWORD *)v78 = v79;
      ++v114;
      if (v112[0])
      {
        v80 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v39);
        v81 = (char *)v113;
        if (v114 >= v115)
        {
          v98 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            v107 = (char *)&v109 - (_BYTE *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
            v81 = (char *)v113;
            v80 = (int *)((char *)v113 + v107);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
            v80 = &v109;
            v81 = (char *)v113;
          }
        }
        v82 = &v81[24 * v114];
        v83 = *(_OWORD *)v80;
        *((_QWORD *)v82 + 2) = *((_QWORD *)v80 + 2);
        *(_OWORD *)v82 = v83;
        ++v114;
        if (v112[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121)
      return 0;
    v84 = __p;
    if (__p)
    {
      v85 = v120;
      v86 = __p;
      if (v120 != __p)
      {
        do
          v85 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v85 - 1);
        while (v85 != v84);
        v86 = __p;
      }
      v120 = v84;
      operator delete(v86);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_120;
    v87 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_119;
    do
    {
      v89 = *--v87;
      v88 = v89;
      *v87 = 0;
      if (v89)
        MEMORY[0x20BD002D4](v88, 0x1000C8077774924);
    }
    while (v87 != v21);
    goto LABEL_118;
  }
  a1[2] = v39;
  v40 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v108, "operandSegmentSizes", 0x13uLL);
  if (v40 || (v40 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v108, "operand_segment_sizes", 0x15uLL)) != 0)
  {
    if (mlir::convertFromAttribute(a1 + 3, (const char *)3, v40, a3, a4))
      return 1;
  }
  else
  {
    a3(v112, a4);
    mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.");
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v112);
  }
  return 0;
}

uint64_t mlir::tensor::PadOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  BOOL v27;
  uint64_t v28;
  uint64_t DictionaryAttr;
  void *v30;
  mlir::DictionaryAttr *v32;
  void *v33;
  uint64_t v34;
  _QWORD v35[7];

  v35[6] = *MEMORY[0x24BDAC8D0];
  v32 = a1;
  v33 = v35;
  v34 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v32, (uint64_t)"nofold", 6, *a2);
    v6 = v5;
    v7 = v34;
    if (v34 >= HIDWORD(v34))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v33, v35, v34 + 1, 16);
      v7 = v34;
    }
    v8 = (uint64_t *)((char *)v33 + 16 * v7);
    *v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v34) = v34 + 1;
  }
  v9 = a2[1];
  if (v9)
  {
    v10 = mlir::Builder::getNamedAttr(&v32, (uint64_t)"static_high", 11, v9);
    v12 = v11;
    v13 = v34;
    if (v34 >= HIDWORD(v34))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v33, v35, v34 + 1, 16);
      v13 = v34;
    }
    v14 = (uint64_t *)((char *)v33 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    LODWORD(v34) = v34 + 1;
  }
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v32, (uint64_t)"static_low", 10, v15);
    v18 = v17;
    v19 = v34;
    if (v34 >= HIDWORD(v34))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v33, v35, v34 + 1, 16);
      v19 = v34;
    }
    v20 = (uint64_t *)((char *)v33 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    LODWORD(v34) = v34 + 1;
  }
  v21 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 3), 3);
  v22 = mlir::Builder::getNamedAttr(&v32, (uint64_t)"operandSegmentSizes", 19, v21);
  v24 = v23;
  v25 = v34;
  if (v34 >= HIDWORD(v34))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v33, v35, v34 + 1, 16);
    v25 = v34;
  }
  v26 = (uint64_t *)((char *)v33 + 16 * v25);
  *v26 = v22;
  v26[1] = v24;
  v27 = __CFADD__((_DWORD)v34, 1);
  v28 = (v34 + 1);
  LODWORD(v34) = v34 + 1;
  if (v27)
  {
    DictionaryAttr = 0;
    v30 = v33;
    if (v33 == v35)
      return DictionaryAttr;
    goto LABEL_20;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v32, (mlir::MLIRContext *)v33, v28);
  v30 = v33;
  if (v33 != v35)
LABEL_20:
    free(v30);
  return DictionaryAttr;
}

uint64_t mlir::tensor::PadOp::getInherentAttr(mlir::MLIRContext *a1, _QWORD *a2, _WORD *__s1, size_t __n)
{
  uint64_t result;

  result = 0;
  switch(__n)
  {
    case 6uLL:
      if (*(_DWORD *)__s1 != 1868984174 || __s1[2] != 25708)
        goto LABEL_13;
      return *a2;
    case 7uLL:
    case 8uLL:
    case 9uLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      goto LABEL_13;
    case 0xAuLL:
      if (memcmp(__s1, "static_low", __n))
        goto LABEL_13;
      result = a2[2];
      break;
    case 0xBuLL:
      if (memcmp(__s1, "static_high", __n))
        goto LABEL_13;
      result = a2[1];
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n))
        goto LABEL_13;
      goto LABEL_15;
    case 0x15uLL:
      if (!memcmp(__s1, "operand_segment_sizes", __n))
LABEL_15:
        result = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 3), 3);
      else
LABEL_13:
        result = 0;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::tensor::PadOp::setInherentAttr(uint64_t result, _WORD *__s1, size_t a3, _QWORD *a4)
{
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;

  v5 = (_QWORD *)result;
  switch(a3)
  {
    case 6uLL:
      if (*(_DWORD *)__s1 == 1868984174 && __s1[2] == 25708)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          *(_QWORD *)result = v11;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xAuLL:
      result = memcmp(__s1, "static_low", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
          if ((_DWORD)result)
            v7 = a4;
          else
            v7 = 0;
          v5[2] = v7;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    case 0xBuLL:
      result = memcmp(__s1, "static_high", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v5[1] = v8;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x13uLL:
      result = memcmp(__s1, "operandSegmentSizes", a3);
      if (!(_DWORD)result)
        goto LABEL_22;
      break;
    case 0x15uLL:
      result = memcmp(__s1, "operand_segment_sizes", a3);
      if (!(_DWORD)result)
      {
LABEL_22:
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          v9 = (_DWORD)result ? a4 : 0;
          v12 = v9;
          if ((_DWORD)result)
          {
            result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v12);
            if (result == 3)
            {
              result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v12);
              if (v10)
                result = (uint64_t)memmove(v5 + 3, (const void *)result, 4 * v10);
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::tensor::PadOp::populateInherentAttrs(mlir::MLIRContext *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"nofold", 6, *a2);
  v6 = a2[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"static_high", 11, v6);
  v7 = a2[2];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"static_low", 10, v7);
  v8 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 3), 3);
  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v8);
}

BOOL mlir::tensor::PadOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  _BOOL8 result;

  v8 = mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (const void **)"nofold", (const char *)6, a3, a4))
  {
    v9 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v9, (const void **)"static_high", (const char *)0xB, a3, a4))
    {
      v10 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v10, (const void **)"static_low", (const char *)0xA, a3, a4))
      {
        return 1;
      }
    }
  }
  return result;
}

BOOL mlir::tensor::PadOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD *v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties>(a2);
  if (!mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3))
    return 0;
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) <= 5)
  {
    v17 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v17))
      return 0;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v17) >= 4)
    {
      v15 = "size mismatch for operand/result_segment_size";
      v16 = 259;
      (*(void (**)(_QWORD *__return_ptr, uint64_t, const char **))(*(_QWORD *)a1 + 16))(v18, a1, &v15);
      if (v18[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
      if (v25)
      {
        v4 = __p;
        if (__p)
        {
          v5 = v24;
          v6 = __p;
          if (v24 != __p)
          {
            do
              v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
            while (v5 != v4);
            v6 = __p;
          }
          v24 = v4;
          operator delete(v6);
        }
        v7 = v21;
        if (v21)
        {
          v8 = v22;
          v9 = v21;
          if (v22 != v21)
          {
            do
            {
              v11 = *--v8;
              v10 = v11;
              *v8 = 0;
              if (v11)
                MEMORY[0x20BD002D4](v10, 0x1000C8077774924);
            }
            while (v8 != v7);
            v9 = v21;
          }
          v22 = v7;
          operator delete(v9);
        }
        if (v19 != &v20)
          free(v19);
      }
      return 0;
    }
    v12 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v17);
    if (v13)
      memmove(v3 + 3, v12, 4 * v13);
  }
  return mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3 + 2)&& ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) < 6|| mlir::DialectBytecodeReader::readSparseArray<int>(a1, (_DWORD *)v3 + 6, (const char *)3));
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new();
    *(_OWORD *)v3 = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_DWORD *)(v3 + 32) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::tensor::detail::PadOpGenericAdaptorBase::Properties]";
        v15 = 107;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[242];
    return a1[32];
  }
  return result;
}

uint64_t mlir::tensor::PadOp::writeProperties(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  mlir::MLIRContext *Context;
  uint64_t v6;
  uint64_t result;

  if (HIBYTE(*(_DWORD *)(*(_QWORD *)a1 + 44)))
    v4 = *(_QWORD *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1) + 64;
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)v4);
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2) <= 5)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)a1 + 24));
    v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 24, 3);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, v6);
  }
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, *(_QWORD *)(v4 + 8));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, *(_QWORD *)(v4 + 16));
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2);
  if (result >= 6)
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 24), 3);
  return result;
}

BOOL mlir::tensor::PadOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t ODSOperands;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  const void **v39[4];
  __int16 v40;
  _QWORD v41[3];
  void *v42;
  uint64_t v43;
  void *v44;
  _QWORD *v45;
  void *__p;
  _QWORD *v47;
  char v48;
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = (_QWORD *)v3[1];
  if (!v4)
  {
    v39[0] = (const void **)"requires attribute 'static_high'";
    v40 = 259;
    mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
    v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
    if (v41[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
    if (!v48)
      return v23;
    v24 = __p;
    if (__p)
    {
      v25 = v47;
      v26 = __p;
      if (v47 != __p)
      {
        do
          v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        v26 = __p;
      }
      v47 = v24;
      operator delete(v26);
    }
    v27 = v44;
    if (v44)
    {
      v28 = v45;
      v29 = v44;
      if (v45 == v44)
        goto LABEL_59;
      do
      {
        v31 = *--v28;
        v30 = v31;
        *v28 = 0;
        if (v31)
          MEMORY[0x20BD002D4](v30, 0x1000C8077774924);
      }
      while (v28 != v27);
LABEL_58:
      v29 = v44;
LABEL_59:
      v45 = v27;
      operator delete(v29);
    }
LABEL_60:
    if (v42 != &v43)
      free(v42);
    return v23;
  }
  v5 = (_QWORD *)v3[2];
  if (!v5)
  {
    v39[0] = (const void **)"requires attribute 'static_low'";
    v40 = 259;
    mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
    v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
    if (v41[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
    if (!v48)
      return v23;
    v32 = __p;
    if (__p)
    {
      v33 = v47;
      v34 = __p;
      if (v47 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v47 = v32;
      operator delete(v34);
    }
    v27 = v44;
    if (v44)
    {
      v35 = v45;
      v29 = v44;
      if (v45 == v44)
        goto LABEL_59;
      do
      {
        v37 = *--v35;
        v36 = v37;
        *v35 = 0;
        if (v37)
          MEMORY[0x20BD002D4](v36, 0x1000C8077774924);
      }
      while (v35 != v27);
      goto LABEL_58;
    }
    goto LABEL_60;
  }
  v6 = *v3;
  v41[0] = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v5, (const void **)"static_low", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0;
  v41[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v4, (const void **)"static_high", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0;
  v41[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v6, (const void **)"nofold", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0;
  v7 = *((unsigned int *)*this + 11);
  v8 = (uint64_t)&(*this)[2 * ((v7 >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v8 = 0;
  v9 = *(unsigned int *)(v8 + 24);
  if ((v7 & 0x800000) != 0)
  {
    v10 = (*this)[9];
    if ((_DWORD)v9)
      goto LABEL_13;
  }
  else
  {
    v10 = 0;
    if ((_DWORD)v9)
    {
LABEL_13:
      v11 = 0;
      v12 = v10 + 24;
      while (mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(*(_QWORD *)v12 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v11))
      {
        ++v11;
        v12 += 32;
        if (v9 == v11)
          goto LABEL_16;
      }
      return 0;
    }
  }
LABEL_16:
  ODSOperands = mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 1u);
  if (v14)
  {
    v15 = v14;
    v16 = ODSOperands + 24;
    while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v16 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v9))
    {
      LODWORD(v9) = v9 + 1;
      v16 += 32;
      if (!--v15)
        goto LABEL_20;
    }
    return 0;
  }
LABEL_20:
  v17 = mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 2u);
  if (v18)
  {
    v19 = v18;
    v20 = v17 + 24;
    while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v20 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v9))
    {
      LODWORD(v9) = v9 + 1;
      v20 += 32;
      if (!--v19)
        goto LABEL_24;
    }
    return 0;
  }
LABEL_24:
  v21 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v21, 0);
  if (!mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0))return 0;
  return mlir::scf::__mlir_ods_local_region_constraint_SCFOps1(*this, (((unint64_t)&(*this)[2* (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)+ 8]+ (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)*this + 10), (uint64_t)"region", 6, 0) != 0;
}

uint64_t mlir::tensor::PadOp::parse(uint64_t a1, uint64_t *a2)
{
  mlir::Region *v4;
  uint64_t v5;
  mlir::UnitAttr **v6;
  mlir::MLIRContext *v7;
  uint64_t UnitAttr;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  int v14;
  _DWORD *v15;
  mlir::IndexType **v16;
  mlir::MLIRContext *v17;
  uint64_t IndexType;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  mlir::Region *v25;
  uint64_t v27;
  _QWORD v28[2];
  mlir::Region *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32[2];
  uint64_t v33;
  void *v34;
  uint64_t v35;
  _BYTE v36[128];
  void *v37;
  uint64_t v38;
  _BYTE v39[128];
  _QWORD v40[4];
  uint64_t __src[4];
  __int16 v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  memset(v40, 0, 24);
  v32[0] = (uint64_t)v40;
  v32[1] = 1;
  v37 = v39;
  v38 = 0x400000000;
  v30 = 0;
  v31 = 0;
  v34 = v36;
  v35 = 0x400000000;
  v4 = (mlir::Region *)operator new();
  *(_QWORD *)v4 = v4;
  *((_QWORD *)v4 + 1) = v4;
  *((_QWORD *)v4 + 2) = 0;
  v28[1] = 1;
  v29 = v4;
  v33 = 0;
  v28[0] = &v33;
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v40, 1))
    goto LABEL_25;
  if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "nofold", 6))
  {
    v6 = (mlir::UnitAttr **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    UnitAttr = mlir::Builder::getUnitAttr(v6, v7);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties>(a2) = UnitAttr;
  }
  v42 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 368))(a1, "low", 3, __src))goto LABEL_25;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  __src[0] = 0;
  if (!mlir::parseDynamicIndexList(a1, (uint64_t)&v37, &v31, __src, 0, 2))
    goto LABEL_25;
  v9 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties>(a2);
  *(_QWORD *)(v9 + 16) = v31;
  v42 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 368))(a1, "high", 4, __src))goto LABEL_25;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  __src[0] = 0;
  if (!mlir::parseDynamicIndexList(a1, (uint64_t)&v34, &v30, __src, 0, 2))
    goto LABEL_25;
  v10 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties>(a2);
  *(_QWORD *)(v10 + 8) = v30;
  if (!(*(unsigned __int8 (**)(uint64_t, mlir::Region *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 744))(a1, v4, 0, 0, 0))goto LABEL_25;
  v11 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  mlir::impl::ensureRegionTerminator(v4, v11, *a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t))llvm::function_ref<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>::callback_fn<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>, (uint64_t)mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl<mlir::tensor::PadOp>::buildTerminator);
  v27 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
    goto LABEL_25;
  v12 = a2[1];
  __src[0] = a1;
  __src[1] = (uint64_t)&v27;
  __src[2] = (uint64_t)a2;
  if (!mlir::tensor::PadOp::verifyInherentAttrs(v12, (uint64_t)(a2 + 14), (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::PadOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))goto LABEL_25;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    goto LABEL_25;
  __src[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, __src))
    goto LABEL_25;
  v33 = __src[0];
  v42 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 368))(a1, "to", 2, __src))goto LABEL_25;
  v27 = 0;
  if (!mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, &v27))
    goto LABEL_25;
  __src[0] = v27;
  mlir::OperationState::addRegion((uint64_t)a2, (unint64_t)&v29);
  v13 = v38;
  v14 = v35;
  v15 = (_DWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties>(a2);
  v15[6] = 1;
  v15[7] = v13;
  v15[8] = v14;
  v16 = (mlir::IndexType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  IndexType = mlir::Builder::getIndexType(v16, v17);
  mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
  v19 = (uint64_t)(a2 + 2);
  if (!mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v32, v28, v5, v19))goto LABEL_25;
  if ((_DWORD)v38)
  {
    v20 = (char *)v37;
    v21 = 32 * v38;
    while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v20, IndexType, v19))
    {
      v20 += 32;
      v21 -= 32;
      if (!v21)
        goto LABEL_20;
    }
LABEL_25:
    v24 = 0;
LABEL_26:
    v25 = v29;
    v29 = 0;
    if (v25)
      goto LABEL_27;
    goto LABEL_28;
  }
LABEL_20:
  if ((_DWORD)v35)
  {
    v22 = (char *)v34;
    v23 = 32 * v35;
    v24 = 1;
    while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v22, IndexType, v19))
    {
      v22 += 32;
      v23 -= 32;
      if (!v23)
        goto LABEL_26;
    }
    goto LABEL_25;
  }
  v24 = 1;
  v25 = v29;
  v29 = 0;
  if (v25)
  {
LABEL_27:
    mlir::Region::~Region(v25);
    MEMORY[0x20BD002F8]();
  }
LABEL_28:
  if (v34 != v36)
    free(v34);
  if (v37 != v39)
    free(v37);
  return v24;
}

void mlir::tensor::PadOp::print(mlir::tensor::PadOp *this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  llvm::raw_ostream *v6;
  _BYTE *v7;
  llvm::raw_ostream *v8;
  uint64_t v9;
  llvm::raw_ostream *v10;
  _BYTE *v11;
  llvm::raw_ostream *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  llvm::raw_ostream *v24;
  _BYTE *v25;
  llvm::raw_ostream *v26;
  _DWORD *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  llvm::raw_ostream *v38;
  _BYTE *v39;
  _QWORD *v40;
  uint64_t v41;
  ZinIrHalH13g **v42;
  mlir::Operation *v43;
  mlir::Operation *v44;
  _BOOL8 v45;
  _QWORD *v46;
  uint64_t v47;
  _QWORD *v48;
  mlir::Operation *v49;
  mlir::ArrayAttr *v50;
  uint64_t Value;
  uint64_t v52;
  llvm::raw_ostream *v53;
  _BYTE *v54;
  llvm::raw_ostream *v55;
  _BYTE *v56;
  llvm::raw_ostream *v57;
  _BYTE *v58;
  llvm::raw_ostream *v59;
  _BYTE *v60;
  llvm::raw_ostream *v61;
  _WORD *v62;
  llvm::raw_ostream *v63;
  _BYTE *v64;
  uint64_t v65;
  uint64_t NextResultAtOffset;
  unint64_t v67;
  void *AttrDictionary;
  uint64_t v69;
  _QWORD v70[4];
  unint64_t v71[2];
  unint64_t v72[3];

  v72[2] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 24));
  if (*(_QWORD *)(*(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64))
  {
    v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v7 = (_BYTE *)*((_QWORD *)v6 + 4);
    if ((unint64_t)v7 >= *((_QWORD *)v6 + 3))
    {
      llvm::raw_ostream::write(v6, 32);
    }
    else
    {
      *((_QWORD *)v6 + 4) = v7 + 1;
      *v7 = 32;
    }
    v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v9 = *((_QWORD *)v8 + 4);
    if ((unint64_t)(*((_QWORD *)v8 + 3) - v9) > 5)
    {
      *(_WORD *)(v9 + 4) = 25708;
      *(_DWORD *)v9 = 1868984174;
      *((_QWORD *)v8 + 4) += 6;
    }
    else
    {
      llvm::raw_ostream::write(v8, "nofold", 6uLL);
    }
  }
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (_BYTE *)*((_QWORD *)v10 + 4);
  if ((unint64_t)v11 >= *((_QWORD *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }
  else
  {
    *((_QWORD *)v10 + 4) = v11 + 1;
    *v11 = 32;
  }
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = *((_QWORD *)v12 + 4);
  if ((unint64_t)(*((_QWORD *)v12 + 3) - v13) > 2)
  {
    *(_BYTE *)(v13 + 2) = 119;
    *(_WORD *)v13 = 28524;
    *((_QWORD *)v12 + 4) += 3;
  }
  else
  {
    llvm::raw_ostream::write(v12, "low", 3uLL);
  }
  v14 = *(_QWORD *)this;
  v15 = *(unsigned int *)(*(_QWORD *)this + 44);
  v16 = *(_QWORD *)this + 16 * ((v15 >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v16 = 0;
  v17 = *(unsigned int *)(v16 + 24);
  if ((v15 & 0x800000) != 0)
    v18 = *(_QWORD *)(v14 + 72);
  else
    v18 = 0;
  v19 = v18 + 32 * v17;
  v20 = (*(_DWORD *)(v16 + 28) + v17) - v17;
  AttrDictionary = *(void **)(v16 + 16);
  v21 = (unint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&AttrDictionary);
  v23 = v22;
  mlir::ValueRange::ValueRange(v72, 0, 0);
  mlir::printDynamicIndexList((uint64_t)a2, v14, v19, v20, v21, v23, v72[0], v72[1], 0, 0, 2);
  v24 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v25 = (_BYTE *)*((_QWORD *)v24 + 4);
  if ((unint64_t)v25 >= *((_QWORD *)v24 + 3))
  {
    llvm::raw_ostream::write(v24, 32);
  }
  else
  {
    *((_QWORD *)v24 + 4) = v25 + 1;
    *v25 = 32;
  }
  v26 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v27 = (_DWORD *)*((_QWORD *)v26 + 4);
  if (*((_QWORD *)v26 + 3) - (_QWORD)v27 > 3uLL)
  {
    *v27 = 1751607656;
    *((_QWORD *)v26 + 4) += 4;
  }
  else
  {
    llvm::raw_ostream::write(v26, "high", 4uLL);
  }
  v28 = *(_QWORD *)this;
  v29 = *(unsigned int *)(*(_QWORD *)this + 44);
  v30 = *(_QWORD *)this + 16 * ((v29 >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v30 = 0;
  if ((v29 & 0x800000) != 0)
    v31 = *(_QWORD *)(v28 + 72);
  else
    v31 = 0;
  v32 = (*(_DWORD *)(v30 + 28) + *(_DWORD *)(v30 + 24));
  v33 = v31 + 32 * v32;
  v34 = (*(_DWORD *)(v30 + 32) + v32) - v32;
  AttrDictionary = *(void **)(v30 + 8);
  v35 = (unint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&AttrDictionary);
  v37 = v36;
  mlir::ValueRange::ValueRange(v71, 0, 0);
  mlir::printDynamicIndexList((uint64_t)a2, v28, v33, v34, v35, v37, v71[0], v71[1], 0, 0, 2);
  v38 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v39 = (_BYTE *)*((_QWORD *)v38 + 4);
  if ((unint64_t)v39 >= *((_QWORD *)v38 + 3))
  {
    llvm::raw_ostream::write(v38, 32);
  }
  else
  {
    *((_QWORD *)v38 + 4) = v39 + 1;
    *v39 = 32;
  }
  v40 = (_QWORD *)(((*(_QWORD *)this
                   + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(*(_QWORD *)this + 40));
  v45 = (_QWORD *)*v40 == v40
     || ((v41 = v40[1]) != 0 ? (v42 = (ZinIrHalH13g **)(v41 - 8)) : (v42 = 0),
         (mlir::Block::getTerminator(v42), !v43)
      || (v44 = v43,
          AttrDictionary = (void *)mlir::Operation::getAttrDictionary(v43),
          mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&AttrDictionary))
      || (*((_BYTE *)v44 + 46) & 0x80) != 0 && *((_DWORD *)v44 + 17))
     || *((_DWORD *)v44 + 9) != 0;
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t, uint64_t, _BOOL8, _QWORD))(*(_QWORD *)a2 + 224))(a2, ((*(_QWORD *)this+ 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(*(_QWORD *)this + 40), 1, v45, 0);
  AttrDictionary = v70;
  v70[0] = "operandSegmentSizes";
  v70[1] = 19;
  v70[2] = "nofold";
  v70[3] = 6;
  v69 = 0x200000002;
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&AttrDictionary, v70, 3uLL, 16);
  v46 = (char *)AttrDictionary + 16 * v69;
  *v46 = "static_low";
  v46[1] = 10;
  v47 = (v69 + 1);
  LODWORD(v69) = v47;
  if (v47 >= HIDWORD(v69))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&AttrDictionary, v70, v47 + 1, 16);
    LODWORD(v47) = v69;
  }
  v48 = (char *)AttrDictionary + 16 * v47;
  *v48 = "static_high";
  v48[1] = 11;
  LODWORD(v69) = v69 + 1;
  mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)this + 24));
  v49 = *(mlir::Operation **)this;
  if (*(_BYTE *)(*(_QWORD *)this + 47))
  {
    v67 = mlir::Operation::getAttrDictionary(v49);
    v50 = (mlir::ArrayAttr *)&v67;
  }
  else
  {
    v50 = (mlir::Operation *)((char *)v49 + 56);
  }
  Value = mlir::ArrayAttr::getValue(v50);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v52, AttrDictionary, v69);
  v53 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v54 = (_BYTE *)*((_QWORD *)v53 + 4);
  if ((unint64_t)v54 >= *((_QWORD *)v53 + 3))
  {
    llvm::raw_ostream::write(v53, 32);
  }
  else
  {
    *((_QWORD *)v53 + 4) = v54 + 1;
    *v54 = 32;
  }
  v55 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v56 = (_BYTE *)*((_QWORD *)v55 + 4);
  if (*((_BYTE **)v55 + 3) == v56)
  {
    llvm::raw_ostream::write(v55, ":", 1uLL);
  }
  else
  {
    *v56 = 58;
    ++*((_QWORD *)v55 + 4);
  }
  v57 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v58 = (_BYTE *)*((_QWORD *)v57 + 4);
  if ((unint64_t)v58 >= *((_QWORD *)v57 + 3))
  {
    llvm::raw_ostream::write(v57, 32);
  }
  else
  {
    *((_QWORD *)v57 + 4) = v58 + 1;
    *v58 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v59 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v60 = (_BYTE *)*((_QWORD *)v59 + 4);
  if ((unint64_t)v60 >= *((_QWORD *)v59 + 3))
  {
    llvm::raw_ostream::write(v59, 32);
  }
  else
  {
    *((_QWORD *)v59 + 4) = v60 + 1;
    *v60 = 32;
  }
  v61 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v62 = (_WORD *)*((_QWORD *)v61 + 4);
  if (*((_QWORD *)v61 + 3) - (_QWORD)v62 > 1uLL)
  {
    *v62 = 28532;
    *((_QWORD *)v61 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v61, "to", 2uLL);
  }
  v63 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v64 = (_BYTE *)*((_QWORD *)v63 + 4);
  if ((unint64_t)v64 >= *((_QWORD *)v63 + 3))
  {
    llvm::raw_ostream::write(v63, 32);
  }
  else
  {
    *((_QWORD *)v63 + 4) = v64 + 1;
    *v64 = 32;
  }
  if (*(_DWORD *)(*(_QWORD *)this + 36))
    v65 = *(_QWORD *)this - 16;
  else
    v65 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v65, 0);
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
  if (AttrDictionary != v70)
    free(AttrDictionary);
}

uint64_t mlir::tensor::ParallelInsertSliceOp::getDest(mlir::tensor::ParallelInsertSliceOp *this)
{
  uint64_t v1;

  if (*(_BYTE *)(*(_QWORD *)this + 47))
    v1 = *(_QWORD *)this + 80;
  else
    v1 = 0;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 32 * *(unsigned int *)(v1 + 24) + 24);
}

uint64_t mlir::tensor::ParallelInsertSliceOp::getInherentAttr(mlir::MLIRContext *a1, uint64_t *a2, char *__s1, size_t __n)
{
  uint64_t result;

  result = 0;
  switch(__n)
  {
    case 0xCuLL:
      if (memcmp(__s1, "static_sizes", __n))
        goto LABEL_11;
      return a2[1];
    case 0xDuLL:
    case 0xFuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      goto LABEL_11;
    case 0xEuLL:
      if (*(_QWORD *)__s1 == 0x6F5F636974617473 && *(_QWORD *)(__s1 + 6) == 0x7374657366666F5FLL)
      {
        result = *a2;
      }
      else if (!memcmp(__s1, "static_strides", __n))
      {
        result = a2[2];
      }
      else
      {
LABEL_11:
        result = 0;
      }
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n))
        goto LABEL_11;
      goto LABEL_13;
    case 0x15uLL:
      if (memcmp(__s1, "operand_segment_sizes", __n))
        goto LABEL_11;
LABEL_13:
      result = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 3), 5);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::tensor::ParallelInsertSliceOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, _QWORD *a4)
{
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;

  v5 = (_QWORD *)result;
  switch(a3)
  {
    case 0xCuLL:
      result = memcmp(__s1, "static_sizes", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
          if ((_DWORD)result)
            v10 = a4;
          else
            v10 = 0;
          v5[1] = v10;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0xEuLL:
      if (*(_QWORD *)__s1 == 0x6F5F636974617473 && *(_QWORD *)(__s1 + 6) == 0x7374657366666F5FLL)
      {
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
          if ((_DWORD)result)
            v11 = a4;
          else
            v11 = 0;
          *v5 = v11;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      else
      {
        result = memcmp(__s1, "static_strides", a3);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
            if ((_DWORD)result)
              v7 = a4;
            else
              v7 = 0;
            v5[2] = v7;
          }
          else
          {
            v5[2] = 0;
          }
        }
      }
      break;
    case 0x13uLL:
      result = memcmp(__s1, "operandSegmentSizes", a3);
      if (!(_DWORD)result)
        goto LABEL_17;
      break;
    case 0x15uLL:
      result = memcmp(__s1, "operand_segment_sizes", a3);
      if (!(_DWORD)result)
      {
LABEL_17:
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          v8 = (_DWORD)result ? a4 : 0;
          v12 = v8;
          if ((_DWORD)result)
          {
            result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v12);
            if (result == 5)
            {
              result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v12);
              if (v9)
                result = (uint64_t)memmove(v5 + 3, (const void *)result, 4 * v9);
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::tensor::ParallelInsertSliceOp::readProperties(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD *v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v3 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties>(a2);
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) <= 5)
  {
    v17 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v17))
      return 0;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v17) >= 6)
    {
      v15 = "size mismatch for operand/result_segment_size";
      v16 = 259;
      (*(void (**)(_QWORD *__return_ptr, uint64_t, const char **))(*(_QWORD *)a1 + 16))(v18, a1, &v15);
      if (v18[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
      if (v25)
      {
        v4 = __p;
        if (__p)
        {
          v5 = v24;
          v6 = __p;
          if (v24 != __p)
          {
            do
              v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
            while (v5 != v4);
            v6 = __p;
          }
          v24 = v4;
          operator delete(v6);
        }
        v7 = v21;
        if (v21)
        {
          v8 = v22;
          v9 = v21;
          if (v22 != v21)
          {
            do
            {
              v11 = *--v8;
              v10 = v11;
              *v8 = 0;
              if (v11)
                MEMORY[0x20BD002D4](v10, 0x1000C8077774924);
            }
            while (v8 != v7);
            v9 = v21;
          }
          v22 = v7;
          operator delete(v9);
        }
        if (v19 != &v20)
          free(v19);
      }
      return 0;
    }
    v12 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v17);
    if (v13)
      memmove(v3 + 3, v12, 4 * v13);
  }
  return mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3)&& mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3 + 2)&& ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) < 6|| mlir::DialectBytecodeReader::readSparseArray<int>(a1, (_DWORD *)v3 + 6, (const char *)5));
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  uint64_t *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_OWORD *)operator new();
    *v3 = 0u;
    v3[1] = 0u;
    *(_OWORD *)((char *)v3 + 28) = 0u;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptor"
              "Base::Properties]";
        v15 = 123;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[244];
    return a1[32];
  }
  return result;
}

uint64_t mlir::tensor::ParallelInsertSliceOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t ODSOperands;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  _QWORD *v45;
  void *v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  const void **v51[4];
  __int16 v52;
  _QWORD v53[3];
  void *v54;
  uint64_t v55;
  void *v56;
  _QWORD *v57;
  void *__p;
  _QWORD *v59;
  char v60;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_QWORD **)v3;
  if (*(_QWORD *)v3)
  {
    v5 = *(_QWORD **)(v3 + 8);
    if (v5)
    {
      v6 = *(_QWORD **)(v3 + 16);
      if (v6)
      {
        v53[0] = v2;
        if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v4, (const void **)"static_offsets", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v53))return 0;
        v53[0] = *this;
        if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v5, (const void **)"static_sizes", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v53))return 0;
        v53[0] = *this;
        if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v6, (const void **)"static_strides", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v53))return 0;
        v7 = *((unsigned int *)*this + 11);
        v8 = (uint64_t)&(*this)[2 * ((v7 >> 23) & 1) + 8];
        if (!HIBYTE(*((_DWORD *)*this + 11)))
          v8 = 0;
        v9 = *(unsigned int *)(v8 + 24);
        if ((v7 & 0x800000) != 0)
        {
          v10 = (*this)[9];
          if ((_DWORD)v9)
            goto LABEL_14;
        }
        else
        {
          v10 = 0;
          if ((_DWORD)v9)
          {
LABEL_14:
            v11 = 0;
            v12 = v10 + 24;
            while (mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(*(_QWORD *)v12 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v11))
            {
              ++v11;
              v12 += 32;
              if (v9 == v11)
                goto LABEL_17;
            }
            return 0;
          }
        }
LABEL_17:
        ODSOperands = mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 1u);
        if (v14)
        {
          v15 = v14;
          v16 = ODSOperands + 24;
          while (mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(*(_QWORD *)v16 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v9))
          {
            LODWORD(v9) = v9 + 1;
            v16 += 32;
            if (!--v15)
              goto LABEL_21;
          }
        }
        else
        {
LABEL_21:
          v17 = mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 2u);
          if (v18)
          {
            v19 = v18;
            v20 = v17 + 24;
            while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v20 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v9))
            {
              LODWORD(v9) = v9 + 1;
              v20 += 32;
              if (!--v19)
                goto LABEL_25;
            }
          }
          else
          {
LABEL_25:
            v21 = mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 3u);
            if (v22)
            {
              v23 = v22;
              v24 = v21 + 24;
              while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v24 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v9))
              {
                LODWORD(v9) = v9 + 1;
                v24 += 32;
                if (!--v23)
                  goto LABEL_29;
              }
            }
            else
            {
LABEL_29:
              v25 = mlir::memref::ReinterpretCastOp::getODSOperands((mlir::memref::ReinterpretCastOp *)this, 4u);
              if (!v26)
                return 1;
              v27 = v26;
              v28 = v25 + 24;
              v29 = 1;
              while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v28 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v9))
              {
                LODWORD(v9) = v9 + 1;
                v28 += 32;
                if (!--v27)
                  return v29;
              }
            }
          }
        }
        return 0;
      }
      v51[0] = (const void **)"requires attribute 'static_strides'";
      v52 = 259;
      mlir::OpState::emitOpError(this, v51, (uint64_t)v53);
      v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v53);
      if (v53[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v53);
      if (v60)
      {
        v44 = __p;
        if (__p)
        {
          v45 = v59;
          v46 = __p;
          if (v59 != __p)
          {
            do
              v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
            while (v45 != v44);
            v46 = __p;
          }
          v59 = v44;
          operator delete(v46);
        }
        v33 = v56;
        if (!v56)
          goto LABEL_79;
        v47 = v57;
        v35 = v56;
        if (v57 == v56)
        {
LABEL_78:
          v57 = v33;
          operator delete(v35);
LABEL_79:
          if (v54 != &v55)
            free(v54);
          return v29;
        }
        do
        {
          v49 = *--v47;
          v48 = v49;
          *v47 = 0;
          if (v49)
            MEMORY[0x20BD002D4](v48, 0x1000C8077774924);
        }
        while (v47 != v33);
LABEL_77:
        v35 = v56;
        goto LABEL_78;
      }
    }
    else
    {
      v51[0] = (const void **)"requires attribute 'static_sizes'";
      v52 = 259;
      mlir::OpState::emitOpError(this, v51, (uint64_t)v53);
      v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v53);
      if (v53[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v53);
      if (v60)
      {
        v38 = __p;
        if (__p)
        {
          v39 = v59;
          v40 = __p;
          if (v59 != __p)
          {
            do
              v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
            while (v39 != v38);
            v40 = __p;
          }
          v59 = v38;
          operator delete(v40);
        }
        v33 = v56;
        if (!v56)
          goto LABEL_79;
        v41 = v57;
        v35 = v56;
        if (v57 == v56)
          goto LABEL_78;
        do
        {
          v43 = *--v41;
          v42 = v43;
          *v41 = 0;
          if (v43)
            MEMORY[0x20BD002D4](v42, 0x1000C8077774924);
        }
        while (v41 != v33);
        goto LABEL_77;
      }
    }
  }
  else
  {
    v51[0] = (const void **)"requires attribute 'static_offsets'";
    v52 = 259;
    mlir::OpState::emitOpError(this, v51, (uint64_t)v53);
    v29 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v53);
    if (v53[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v53);
    if (v60)
    {
      v30 = __p;
      if (__p)
      {
        v31 = v59;
        v32 = __p;
        if (v59 != __p)
        {
          do
            v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
          while (v31 != v30);
          v32 = __p;
        }
        v59 = v30;
        operator delete(v32);
      }
      v33 = v56;
      if (!v56)
        goto LABEL_79;
      v34 = v57;
      v35 = v56;
      if (v57 == v56)
        goto LABEL_78;
      do
      {
        v37 = *--v34;
        v36 = v37;
        *v34 = 0;
        if (v37)
          MEMORY[0x20BD002D4](v36, 0x1000C8077774924);
      }
      while (v34 != v33);
      goto LABEL_77;
    }
  }
  return v29;
}

uint64_t mlir::tensor::ParallelInsertSliceOp::parse(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  mlir::IndexType **v14;
  mlir::MLIRContext *v15;
  uint64_t IndexType;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v27;
  _QWORD v28[2];
  _QWORD v29[2];
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33[2];
  uint64_t v34[2];
  uint64_t v35[4];
  __int16 v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  _BYTE v41[128];
  void *v42;
  uint64_t v43;
  _BYTE v44[128];
  void *v45;
  uint64_t v46;
  _BYTE v47[128];
  _QWORD v48[4];
  _QWORD v49[6];

  v49[4] = *MEMORY[0x24BDAC8D0];
  memset(v49, 0, 24);
  v34[0] = (uint64_t)v49;
  v34[1] = 1;
  memset(v48, 0, 24);
  v33[0] = (uint64_t)v48;
  v33[1] = 1;
  v45 = v47;
  v46 = 0x400000000;
  v31 = 0;
  v32 = 0;
  v42 = v44;
  v43 = 0x400000000;
  v38 = 0;
  v39 = v41;
  v40 = 0x400000000;
  v29[1] = 1;
  v30 = 0;
  v28[1] = 1;
  v29[0] = &v38;
  v37 = 0;
  v28[0] = &v37;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v49, 1))
    goto LABEL_28;
  v36 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 368))(a1, "into", 4, v35))goto LABEL_28;
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v48, 1))
    goto LABEL_28;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v35[0] = 0;
  if (!mlir::parseDynamicIndexList(a1, (uint64_t)&v45, &v32, v35, 0, 2))
    goto LABEL_28;
  v6 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties>(a2);
  *v6 = v32;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v35[0] = 0;
  if (!mlir::parseDynamicIndexList(a1, (uint64_t)&v42, &v31, v35, 0, 2))
    goto LABEL_28;
  v7 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties>(a2);
  *(_QWORD *)(v7 + 8) = v31;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v35[0] = 0;
  if (!mlir::parseDynamicIndexList(a1, (uint64_t)&v39, &v30, v35, 0, 2))
    goto LABEL_28;
  v8 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties>(a2);
  *(_QWORD *)(v8 + 16) = v30;
  v27 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
    goto LABEL_28;
  v9 = a2[1];
  v35[0] = a1;
  v35[1] = (uint64_t)&v27;
  v35[2] = (uint64_t)a2;
  if (!mlir::memref::ReinterpretCastOp::verifyInherentAttrs(v9, (uint64_t)(a2 + 14), (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::ParallelInsertSliceOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v35))goto LABEL_28;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    goto LABEL_28;
  v35[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, v35))
    goto LABEL_28;
  v38 = v35[0];
  v36 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 368))(a1, "into", 4, v35))goto LABEL_28;
  v35[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, v35))
    goto LABEL_28;
  v37 = v35[0];
  v10 = v46;
  v11 = v43;
  v12 = v40;
  v13 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties>(a2);
  *(_QWORD *)(v13 + 24) = 0x100000001;
  *(_DWORD *)(v13 + 32) = v10;
  *(_DWORD *)(v13 + 36) = v11;
  *(_DWORD *)(v13 + 40) = v12;
  v14 = (mlir::IndexType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  IndexType = mlir::Builder::getIndexType(v14, v15);
  v17 = (uint64_t)(a2 + 2);
  if (!mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v34, v29, v4, v17)|| !mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v33, v28, v5, v17))
  {
    goto LABEL_28;
  }
  if ((_DWORD)v46)
  {
    v18 = (char *)v45;
    v19 = 32 * v46;
    while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v18, IndexType, v17))
    {
      v18 += 32;
      v19 -= 32;
      if (!v19)
        goto LABEL_19;
    }
LABEL_28:
    v24 = 0;
LABEL_29:
    v25 = v39;
    if (v39 != v41)
      goto LABEL_30;
    goto LABEL_31;
  }
LABEL_19:
  if ((_DWORD)v43)
  {
    v20 = (char *)v42;
    v21 = 32 * v43;
    while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v20, IndexType, v17))
    {
      v20 += 32;
      v21 -= 32;
      if (!v21)
        goto LABEL_23;
    }
    goto LABEL_28;
  }
LABEL_23:
  if ((_DWORD)v40)
  {
    v22 = (char *)v39;
    v23 = 32 * v40;
    v24 = 1;
    while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v22, IndexType, v17))
    {
      v22 += 32;
      v23 -= 32;
      if (!v23)
        goto LABEL_29;
    }
    goto LABEL_28;
  }
  v24 = 1;
  v25 = v39;
  if (v39 != v41)
LABEL_30:
    free(v25);
LABEL_31:
  if (v42 != v44)
    free(v42);
  if (v45 != v47)
    free(v45);
  return v24;
}

uint64_t mlir::tensor::detail::RankOpGenericAdaptorBase::RankOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "tensor.rank", 11, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::tensor::RankOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::tensor::__mlir_ods_local_type_constraint_TensorOps0(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))return 0;
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::memref::__mlir_ods_local_type_constraint_MemRefOps9(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

BOOL mlir::tensor::RankOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  mlir::IndexType **v5;
  mlir::MLIRContext *v6;
  uint64_t IndexType;
  uint64_t v8;
  uint64_t v10;
  _QWORD v11[2];
  uint64_t v12[2];
  uint64_t v13;
  _QWORD v14[5];

  v14[4] = *MEMORY[0x24BDAC8D0];
  memset(v14, 0, 24);
  v12[0] = (uint64_t)v14;
  v12[1] = 1;
  v13 = 0;
  v11[0] = &v13;
  v11[1] = 1;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v14, 1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v10 = 0;
  if (!mlir::AsmParser::parseType<mlir::TensorType>(a1, &v10))
    return 0;
  v13 = v10;
  v5 = (mlir::IndexType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  IndexType = mlir::Builder::getIndexType(v5, v6);
  v8 = *(unsigned int *)(a2 + 72);
  if (v8 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v8 + 1, 8);
    LODWORD(v8) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v8) = IndexType;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v12, v11, v4, a2 + 16) != 0;
}

uint64_t mlir::tensor::detail::ReshapeOpGenericAdaptorBase::ReshapeOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  v5 = a2[11];
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "tensor.reshape", 14, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::tensor::ReshapeOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  const void **v3;
  const void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const void ***v8;
  char *v9;
  char *v10;
  __int128 v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  const void ***v22;
  char *v23;
  char *v24;
  __int128 v25;
  char v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t NextResultAtOffset;
  unint64_t v38;
  unint64_t v39;
  BOOL v40;
  unint64_t v41;
  BOOL v42;
  unint64_t v43;
  int64_t v44;
  int64_t v45;
  int64_t v46;
  int64_t v47;
  const void **v48;
  uint64_t v49;
  __int16 v50;
  uint64_t OperandRange;
  const void **v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD v55[3];
  void *v56;
  unsigned int v57;
  unsigned int v58;
  _BYTE v59[96];
  void *v60;
  _QWORD *v61;
  void *__p;
  _QWORD *v63;
  char v64;
  uint64_t v65;

  v65 = *MEMORY[0x24BDAC8D0];
  if (!mlir::tensor::__mlir_ods_local_type_constraint_TensorOps0(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))return 0;
  v2 = *this;
  v3 = (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  v4 = *v3;
  if (*((_UNKNOWN **)*v3 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    goto LABEL_34;
  v55[0] = *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  v55[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v4 + 8);
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v55))
    goto LABEL_34;
  v5 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v3 + 8);
  v48 = v3;
  v49 = v5;
  mlir::ShapedType::getShape((mlir::ShapedType *)&v48);
  if (v6 != 1
    || (v7 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v3 + 8),
        v52 = v3,
        v53 = v7,
        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v52),
        !mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange))
    && *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) != &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
  {
LABEL_34:
    v50 = 261;
    v48 = (const void **)"operand";
    v49 = 7;
    mlir::Operation::emitOpError(v2, &v48, (uint64_t)v55);
    if (v55[0])
    {
      LODWORD(v52) = 3;
      v53 = (uint64_t)" #";
      v54 = 2;
      v8 = &v52;
      v9 = (char *)v56;
      if (v57 >= v58)
      {
        v38 = v57 + 1;
        if (v56 <= &v52 && (char *)v56 + 24 * v57 > (char *)&v52)
        {
          v44 = (char *)&v52 - (_BYTE *)v56;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
          v9 = (char *)v56;
          v8 = (const void ***)((char *)v56 + v44);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
          v8 = &v52;
          v9 = (char *)v56;
        }
      }
      v10 = &v9[24 * v57];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = v8[2];
      *(_OWORD *)v10 = v11;
      v12 = ++v57;
      if (v55[0])
      {
        LODWORD(v52) = 5;
        v53 = 1;
        v13 = &v52;
        v14 = (char *)v56;
        if (v12 >= v58)
        {
          v39 = v12 + 1;
          v40 = (char *)v56 + 24 * v12 > (char *)&v52;
          if (v56 <= &v52 && v40)
          {
            v45 = (char *)&v52 - (_BYTE *)v56;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v39, 24);
            v14 = (char *)v56;
            v13 = (const void ***)((char *)v56 + v45);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v39, 24);
            v13 = &v52;
            v14 = (char *)v56;
          }
        }
        v15 = &v14[24 * v57];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = v13[2];
        *(_OWORD *)v15 = v16;
        v17 = ++v57;
        if (v55[0])
        {
          LODWORD(v52) = 3;
          v53 = (uint64_t)" must be 1D tensor of signless integer or index values, but got ";
          v54 = 64;
          v18 = &v52;
          v19 = (char *)v56;
          if (v17 >= v58)
          {
            v41 = v17 + 1;
            v42 = (char *)v56 + 24 * v17 > (char *)&v52;
            if (v56 <= &v52 && v42)
            {
              v46 = (char *)&v52 - (_BYTE *)v56;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v41, 24);
              v19 = (char *)v56;
              v18 = (const void ***)((char *)v56 + v46);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v41, 24);
              v18 = &v52;
              v19 = (char *)v56;
            }
          }
          v20 = &v19[24 * v57];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = v18[2];
          *(_OWORD *)v20 = v21;
          ++v57;
          if (v55[0])
          {
            v22 = &v52;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v52, (uint64_t)v3);
            v23 = (char *)v56;
            if (v57 >= v58)
            {
              v43 = v57 + 1;
              if (v56 <= &v52 && (char *)v56 + 24 * v57 > (char *)&v52)
              {
                v47 = (char *)&v52 - (_BYTE *)v56;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v43, 24);
                v23 = (char *)v56;
                v22 = (const void ***)((char *)v56 + v47);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v43, 24);
                v22 = &v52;
                v23 = (char *)v56;
              }
            }
            v24 = &v23[24 * v57];
            v25 = *(_OWORD *)v22;
            *((_QWORD *)v24 + 2) = v22[2];
            *(_OWORD *)v24 = v25;
            ++v57;
          }
        }
      }
    }
    v26 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v55);
    if (v55[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v55);
    if (v64)
    {
      v27 = __p;
      if (__p)
      {
        v28 = v63;
        v29 = __p;
        if (v63 != __p)
        {
          do
            v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
          while (v28 != v27);
          v29 = __p;
        }
        v63 = v27;
        operator delete(v29);
      }
      v30 = v60;
      if (v60)
      {
        v31 = v61;
        v32 = v60;
        if (v61 != v60)
        {
          do
          {
            v34 = *--v31;
            v33 = v34;
            *v31 = 0;
            if (v34)
              MEMORY[0x20BD002D4](v33, 0x1000C8077774924);
          }
          while (v31 != v30);
          v32 = v60;
        }
        v61 = v30;
        operator delete(v32);
      }
      if (v56 != v59)
        free(v56);
    }
    if (!v26)
      return 0;
  }
  if (*((_DWORD *)*this + 9))
    v35 = (uint64_t)(*this - 2);
  else
    v35 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v35, 0);
  return mlir::tensor::__mlir_ods_local_type_constraint_TensorOps0(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

BOOL mlir::tensor::ReshapeOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  void *Results;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v9[2];
  uint64_t v10;
  _QWORD v11[2];
  _QWORD v12[2];
  _QWORD v13[2];
  _QWORD v14[4];
  _QWORD v15[5];

  v15[4] = *MEMORY[0x24BDAC8D0];
  memset(v15, 0, 24);
  v13[0] = v15;
  v13[1] = 1;
  memset(v14, 0, 24);
  v12[0] = v14;
  v12[1] = 1;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v15, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 264))(a1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v14, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 280))(a1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v10 = 0;
  if (!mlir::AsmParser::parseType<mlir::FunctionType>(a1, &v10))
    return 0;
  v11[0] = mlir::FunctionType::getInputs((mlir::FunctionType *)&v10);
  v11[1] = v4;
  Results = (void *)mlir::FunctionType::getResults((mlir::FunctionType *)&v10);
  mlir::OperationState::addTypes(a2, Results, v6);
  v9[0] = v13;
  v9[1] = v12;
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  return mlir::OpAsmParser::resolveOperands<llvm::detail::concat_range<mlir::OpAsmParser::UnresolvedOperand const,llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &>,llvm::ArrayRef<mlir::Type> &>(a1, v9, v11, v7, a2 + 16) != 0;
}

uint64_t mlir::tensor::ScatterOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  char *v13;
  char *v14;
  __int128 v15;
  int *v16;
  char *v17;
  char *v18;
  __int128 v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  char *v39;
  char *v40;
  __int128 v41;
  _QWORD *v42;
  _QWORD *v43;
  void *v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  int *v48;
  char *v49;
  char *v50;
  __int128 v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD *v56;
  _QWORD *v57;
  void *v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  int64_t v69;
  int64_t v70;
  int64_t v71;
  int64_t v72;
  int64_t v73;
  int64_t v74;
  uint64_t v75;
  int v76;
  const char *v77;
  uint64_t v78;
  _QWORD v79[3];
  void *v80;
  unsigned int v81;
  unsigned int v82;
  _BYTE v83[96];
  void *v84;
  _QWORD *v85;
  void *__p;
  _QWORD *v87;
  char v88;
  uint64_t v89;

  v89 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v77 = "expected DictionaryAttr to set properties";
      v78 = 41;
      v28 = &v76;
      v29 = (char *)v80;
      if (v81 >= v82)
      {
        v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v69 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          v29 = (char *)v80;
          v28 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          v28 = &v76;
          v29 = (char *)v80;
        }
      }
      v30 = &v29[24 * v81];
      v31 = *(_OWORD *)v28;
      *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
      *(_OWORD *)v30 = v31;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
    if (!v88)
      return 0;
    v32 = __p;
    if (__p)
    {
      v33 = v87;
      v34 = __p;
      if (v87 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v87 = v32;
      operator delete(v34);
    }
    v23 = v84;
    if (!v84)
      goto LABEL_79;
    v35 = v85;
    v25 = v84;
    if (v85 == v84)
      goto LABEL_78;
    do
    {
      v37 = *--v35;
      v36 = v37;
      *v35 = 0;
      if (v37)
        MEMORY[0x20BD002D4](v36, 0x1000C8077774924);
    }
    while (v35 != v23);
    goto LABEL_77;
  }
  v8 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v75, "scatter_dims", 0xCuLL);
  if (!v8)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v77 = "expected key entry for scatter_dims in DictionaryAttr to set Properties.";
      v78 = 72;
      v38 = &v76;
      v39 = (char *)v80;
      if (v81 >= v82)
      {
        v64 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v70 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
          v39 = (char *)v80;
          v38 = (int *)((char *)v80 + v70);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
          v38 = &v76;
          v39 = (char *)v80;
        }
      }
      v40 = &v39[24 * v81];
      v41 = *(_OWORD *)v38;
      *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
      *(_OWORD *)v40 = v41;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
    if (!v88)
      return 0;
    v42 = __p;
    if (__p)
    {
      v43 = v87;
      v44 = __p;
      if (v87 != __p)
      {
        do
          v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
        while (v43 != v42);
        v44 = __p;
      }
      v87 = v42;
      operator delete(v44);
    }
    v23 = v84;
    if (!v84)
      goto LABEL_79;
    v45 = v85;
    v25 = v84;
    if (v85 == v84)
      goto LABEL_78;
    do
    {
      v47 = *--v45;
      v46 = v47;
      *v45 = 0;
      if (v47)
        MEMORY[0x20BD002D4](v46, 0x1000C8077774924);
    }
    while (v45 != v23);
    goto LABEL_77;
  }
  v9 = (uint64_t)v8;
  if (!mlir::detail::DenseArrayAttrImpl<long long>::classof(v8))
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v78 = 57;
      v48 = &v76;
      v49 = (char *)v80;
      if (v81 >= v82)
      {
        v65 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v71 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
          v49 = (char *)v80;
          v48 = (int *)((char *)v80 + v71);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
          v48 = &v76;
          v49 = (char *)v80;
        }
      }
      v50 = &v49[24 * v81];
      v51 = *(_OWORD *)v48;
      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
      *(_OWORD *)v50 = v51;
      ++v81;
      if (v79[0])
      {
        v52 = &v76;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
        v53 = (char *)v80;
        if (v81 >= v82)
        {
          v66 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            v72 = (char *)&v76 - (_BYTE *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
            v53 = (char *)v80;
            v52 = (int *)((char *)v80 + v72);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
            v52 = &v76;
            v53 = (char *)v80;
          }
        }
        v54 = &v53[24 * v81];
        v55 = *(_OWORD *)v52;
        *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
        *(_OWORD *)v54 = v55;
        ++v81;
        if (v79[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88)
      return 0;
    v56 = __p;
    if (__p)
    {
      v57 = v87;
      v58 = __p;
      if (v87 != __p)
      {
        do
          v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        v58 = __p;
      }
      v87 = v56;
      operator delete(v58);
    }
    v23 = v84;
    if (!v84)
      goto LABEL_79;
    v59 = v85;
    v25 = v84;
    if (v85 == v84)
      goto LABEL_78;
    do
    {
      v61 = *--v59;
      v60 = v61;
      *v59 = 0;
      if (v61)
        MEMORY[0x20BD002D4](v60, 0x1000C8077774924);
    }
    while (v59 != v23);
    goto LABEL_77;
  }
  *a1 = v9;
  v10 = mlir::DictionaryAttr::get((uint64_t)&v75, "unique", 6uLL);
  if (!v10)
    return 1;
  v11 = v10;
  if (*(_UNKNOWN **)(*(_QWORD *)v10 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    a1[1] = v10;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    v76 = 3;
    v78 = 51;
    v12 = &v76;
    v13 = (char *)v80;
    if (v81 >= v82)
    {
      v67 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        v73 = (char *)&v76 - (_BYTE *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
        v13 = (char *)v80;
        v12 = (int *)((char *)v80 + v73);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
        v12 = &v76;
        v13 = (char *)v80;
      }
    }
    v14 = &v13[24 * v81];
    v15 = *(_OWORD *)v12;
    *((_QWORD *)v14 + 2) = *((_QWORD *)v12 + 2);
    *(_OWORD *)v14 = v15;
    ++v81;
    if (v79[0])
    {
      v16 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v11);
      v17 = (char *)v80;
      if (v81 >= v82)
      {
        v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v74 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          v17 = (char *)v80;
          v16 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          v16 = &v76;
          v17 = (char *)v80;
        }
      }
      v18 = &v17[24 * v81];
      v19 = *(_OWORD *)v16;
      *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
      *(_OWORD *)v18 = v19;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
  }
  if (v88)
  {
    v20 = __p;
    if (__p)
    {
      v21 = v87;
      v22 = __p;
      if (v87 != __p)
      {
        do
          v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
        while (v21 != v20);
        v22 = __p;
      }
      v87 = v20;
      operator delete(v22);
    }
    v23 = v84;
    if (!v84)
      goto LABEL_79;
    v24 = v85;
    v25 = v84;
    if (v85 == v84)
    {
LABEL_78:
      v85 = v23;
      operator delete(v25);
LABEL_79:
      if (v80 != v83)
        free(v80);
      return 0;
    }
    do
    {
      v27 = *--v24;
      v26 = v27;
      *v24 = 0;
      if (v27)
        MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
    }
    while (v24 != v23);
LABEL_77:
    v25 = v84;
    goto LABEL_78;
  }
  return 0;
}

uint64_t mlir::tensor::ScatterOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  mlir::MLIRContext *v10;
  uint64_t DictionaryAttr;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t *v17;
  mlir::DictionaryAttr *v18;
  void *v19;
  uint64_t v20;
  _QWORD v21[7];

  v21[6] = *MEMORY[0x24BDAC8D0];
  v18 = a1;
  v19 = v21;
  v20 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"scatter_dims", 12, *a2);
    v5 = v4;
    v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      v6 = v20;
    }
    v7 = (uint64_t *)((char *)v19 + 16 * v6);
    *v7 = NamedAttr;
    v7[1] = v5;
    v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      v10 = (mlir::MLIRContext *)v19;
      if (v8)
        goto LABEL_6;
LABEL_13:
      DictionaryAttr = 0;
      if (v10 == (mlir::MLIRContext *)v21)
        return DictionaryAttr;
      goto LABEL_7;
    }
  }
  else
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_5;
  }
  v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"unique", 6, v9);
  v15 = v14;
  v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    v16 = v20;
  }
  v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *v17 = v13;
  v17[1] = v15;
  v8 = v20 + 1;
  LODWORD(v20) = v8;
  v10 = (mlir::MLIRContext *)v19;
  if (!v8)
    goto LABEL_13;
LABEL_6:
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  v10 = (mlir::MLIRContext *)v19;
  if (v19 != v21)
LABEL_7:
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::tensor::ScatterOp::getInherentAttr(int a1, _QWORD *a2, _QWORD *__s1, size_t __n)
{
  if (__n == 6)
  {
    if (memcmp(__s1, "unique", 6uLL))
      return 0;
    return a2[1];
  }
  else
  {
    if (__n != 12)
      return 0;
    if (*__s1 != 0x5F72657474616373 || *((_DWORD *)__s1 + 2) != 1936550244)
      return 0;
    return *a2;
  }
}

uint64_t mlir::tensor::ScatterOp::setInherentAttr(uint64_t result, _QWORD *__s1, uint64_t a3, _QWORD *a4)
{
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;

  v5 = (_QWORD *)result;
  if (a3 == 6)
  {
    result = memcmp(__s1, "unique", 6uLL);
    if (!(_DWORD)result)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
          v7 = a4;
        else
          v7 = 0;
        v5[1] = v7;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (a3 == 12 && *__s1 == 0x5F72657474616373 && *((_DWORD *)__s1 + 2) == 1936550244)
  {
    if (a4)
    {
      result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
      if ((_DWORD)result)
        v8 = a4;
      else
        v8 = 0;
      *v5 = v8;
    }
    else
    {
      *(_QWORD *)result = 0;
    }
  }
  return result;
}

void mlir::tensor::ScatterOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"scatter_dims", 12, *a2);
  v5 = a2[1];
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"unique", 6, v5);
}

BOOL mlir::tensor::ScatterOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  _BOOL8 result;

  v8 = (_QWORD *)mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v8, (const void **)"scatter_dims", (const char *)0xC, a3, a4))
  {
    v9 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v9, (const void **)"unique", (const char *)6, a3, a4))
    {
      return 1;
    }
  }
  return result;
}

BOOL mlir::tensor::ScatterOp::readProperties(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;

  v3 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ScatterOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ScatterOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  uint64_t *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::ScatterOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ScatterOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::ScatterOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ScatterOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::tensor::detail::ScatterOpGenericAdaptorBase::Properties]";
        v15 = 111;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::tensor::detail::ScatterOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v5[246];
    return a1[32];
  }
  return result;
}

BOOL mlir::tensor::ScatterOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t NextResultAtOffset;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  const void **v18;
  __int16 v19;
  _QWORD v20[3];
  void *v21;
  uint64_t v22;
  void *v23;
  _QWORD *v24;
  void *__p;
  _QWORD *v26;
  char v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_QWORD **)v3;
  if (*(_QWORD *)v3)
  {
    v5 = *(_QWORD *)(v3 + 8);
    v20[0] = v2;
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v4, (const void **)"scatter_dims", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20))return 0;
    v20[0] = *this;
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"unique", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20)|| !mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))
    {
      return 0;
    }
    if (!mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))return 0;
    if (mlir::tensor::__mlir_ods_local_type_constraint_TensorOps8(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 2u))
    {
      if (*((_DWORD *)*this + 9))
        v6 = (uint64_t)(*this - 2);
      else
        v6 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
      return mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v18 = (const void **)"requires attribute 'scatter_dims'";
    v19 = 259;
    mlir::OpState::emitOpError(this, &v18, (uint64_t)v20);
    v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v20);
    if (v20[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v20);
    if (v27)
    {
      v9 = __p;
      if (__p)
      {
        v10 = v26;
        v11 = __p;
        if (v26 != __p)
        {
          do
            v10 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v10 - 1);
          while (v10 != v9);
          v11 = __p;
        }
        v26 = v9;
        operator delete(v11);
      }
      v12 = v23;
      if (v23)
      {
        v13 = v24;
        v14 = v23;
        if (v24 != v23)
        {
          do
          {
            v16 = *--v13;
            v15 = v16;
            *v13 = 0;
            if (v16)
              MEMORY[0x20BD002D4](v15, 0x1000C8077774924);
          }
          while (v13 != v12);
          v14 = v23;
        }
        v24 = v12;
        operator delete(v14);
      }
      if (v21 != &v22)
        free(v21);
    }
  }
  return v8;
}

BOOL mlir::tensor::ScatterOp::parse(uint64_t *a1, _QWORD *a2)
{
  _QWORD *v4;
  mlir::UnitAttr **v5;
  mlir::MLIRContext *v6;
  uint64_t UnitAttr;
  uint64_t v8;
  uint64_t v9;
  void *Results;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t Inputs;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[2];
  _QWORD v19[2];
  _QWORD v20[2];
  uint64_t *v21;
  uint64_t *v22;
  _QWORD *v23;
  __int16 v24;
  _QWORD v25[4];
  _QWORD v26[4];
  _QWORD v27[5];

  v27[4] = *MEMORY[0x24BDAC8D0];
  memset(v27, 0, 24);
  v20[0] = v27;
  v20[1] = 1;
  memset(v26, 0, 24);
  v19[0] = v26;
  v19[1] = 1;
  memset(v25, 0, 24);
  v18[0] = v25;
  v18[1] = 1;
  v16 = 0;
  v17 = 0;
  Inputs = 0;
  (*(void (**)(uint64_t *))(*a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t *, _QWORD *, uint64_t))(*a1 + 672))(a1, v27, 1))
    return 0;
  v24 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t *, const char *, uint64_t, uint64_t **))(*a1 + 368))(a1, "into", 4, &v21))return 0;
  (*(void (**)(uint64_t *))(*a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t *, _QWORD *, uint64_t))(*a1 + 672))(a1, v26, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t *))(*a1 + 296))(a1))
    return 0;
  (*(void (**)(uint64_t *))(*a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t *, _QWORD *, uint64_t))(*a1 + 672))(a1, v25, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t *))(*a1 + 312))(a1))
    return 0;
  v24 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t *, const char *, uint64_t, uint64_t **))(*a1 + 368))(a1, "scatter_dims", 12, &v21)|| !(*(unsigned __int8 (**)(uint64_t *))(*a1 + 264))(a1)|| !mlir::AsmParser::parseCustomAttributeWithFallback<mlir::detail::DenseArrayAttrImpl<long long>>((uint64_t)a1, &v17, 0))
  {
    return 0;
  }
  if (v17)
  {
    v4 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ScatterOpGenericAdaptorBase::Properties>(a2);
    *v4 = v17;
  }
  if (!(*(unsigned __int8 (**)(uint64_t *))(*a1 + 280))(a1))
    return 0;
  if ((*(unsigned __int8 (**)(uint64_t *, const char *, uint64_t))(*a1 + 376))(a1, "unique", 6))
  {
    v5 = (mlir::UnitAttr **)(*(uint64_t (**)(uint64_t *))(*a1 + 32))(a1);
    UnitAttr = mlir::Builder::getUnitAttr(v5, v6);
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ScatterOpGenericAdaptorBase::Properties>(a2)
              + 8) = UnitAttr;
  }
  v14 = (*(uint64_t (**)(uint64_t *))(*a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t *, _QWORD *))(*a1 + 456))(a1, a2 + 14))
    return 0;
  v8 = a2[1];
  v21 = a1;
  v22 = &v14;
  v23 = a2;
  if (!mlir::tensor::ScatterOp::verifyInherentAttrs(v8, (uint64_t)(a2 + 14), (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::ScatterOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v21))return 0;
  if (!(*(unsigned __int8 (**)(uint64_t *))(*a1 + 104))(a1))
    return 0;
  v14 = 0;
  if (!mlir::AsmParser::parseType<mlir::FunctionType>((uint64_t)a1, &v14))
    return 0;
  Inputs = mlir::FunctionType::getInputs((mlir::FunctionType *)&v14);
  v16 = v9;
  Results = (void *)mlir::FunctionType::getResults((mlir::FunctionType *)&v14);
  mlir::OperationState::addTypes((uint64_t)a2, Results, v11);
  v21 = v20;
  v22 = v19;
  v23 = v18;
  v12 = (*(uint64_t (**)(uint64_t *))(*a1 + 16))(a1);
  return mlir::OpAsmParser::resolveOperands<llvm::detail::concat_range<mlir::OpAsmParser::UnresolvedOperand const,llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &>,llvm::ArrayRef<mlir::Type> &>((uint64_t)a1, &v21, &Inputs, v12, (uint64_t)(a2 + 2)) != 0;
}

uint64_t mlir::OpAsmParser::resolveOperands<llvm::detail::concat_range<mlir::OpAsmParser::UnresolvedOperand const,llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &>,llvm::ArrayRef<mlir::Type> &>(uint64_t a1, uint64_t **a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  BOOL v15;
  uint64_t v16;
  BOOL v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  BOOL v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  char *v38;
  char *v39;
  char *v40;
  __int128 v41;
  uint64_t v42;
  char *v43;
  char *v44;
  char *v45;
  __int128 v46;
  uint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  __int128 v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v61;
  unint64_t v62;
  BOOL v63;
  unint64_t v64;
  BOOL v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  _QWORD v70[4];
  __int16 v71;
  uint64_t v72;
  const char *v73;
  uint64_t v74;
  _QWORD v75[3];
  void *v76;
  unsigned int v77;
  unsigned int v78;
  _BYTE v79[96];
  void *v80;
  _QWORD *v81;
  void *__p;
  _QWORD *v83;
  char v84;
  uint64_t v85;

  v85 = *MEMORY[0x24BDAC8D0];
  v6 = a2[1];
  v7 = a2[2];
  v9 = **a2;
  v8 = (*a2)[1];
  v11 = *v6;
  v10 = v6[1];
  v13 = *v7;
  v12 = v7[1];
  v75[0] = v9;
  v70[0] = v11;
  v72 = v13;
  v14 = v8 == 0;
  v15 = v10 == 0;
  v16 = v8 | v10 | v12;
  v17 = v16 == 0;
  if (v16)
  {
    v19 = 0;
    v20 = v9 + 32 * v8;
    v21 = v13;
    v22 = v11;
    v23 = v9;
    v24 = v11 + 32 * v10;
    v25 = v13 + 32 * v12;
    while (v23 == v20)
    {
      if (v22 != v24)
      {
        v26 = v70;
        v23 = v22;
        goto LABEL_11;
      }
      v27 = v13 + 32 * v12;
      v22 = v24;
      v23 = v20;
      if (v21 != v25)
      {
        v26 = &v72;
        v23 = v21;
        goto LABEL_11;
      }
LABEL_12:
      ++v19;
      v29 = v23 == v20 && v22 == v24 && v27 == v25;
      v21 = v27;
      if (v29)
      {
        v18 = (const char *)a3[1];
        if (v18 != v19)
          goto LABEL_45;
        v30 = (_QWORD *)*a3;
        v75[0] = v9;
        v70[0] = v11;
        v72 = v13;
        if (!v17)
        {
          while (2)
          {
            if (!v9 || (v31 = v9, v14))
            {
              if (v13 == v25)
                v32 = 0;
              else
                v32 = v13;
              if (v11 != 0 && !v15)
                v31 = v11;
              else
                v31 = v32;
            }
            if (!(*(unsigned __int8 (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 696))(a1, v31, *v30, a5))return 0;
            if (v14)
              v33 = v11;
            else
              v33 = v9;
            v34 = v75;
            if (v14)
              v34 = v70;
            if (v14 && v15)
            {
              v35 = v25;
              if (v13 != v25)
              {
                v34 = &v72;
                goto LABEL_40;
              }
            }
            else
            {
              v13 = v33;
LABEL_40:
              *v34 = v13 + 32;
              v9 = v75[0];
              v11 = v70[0];
              v35 = v72;
            }
            ++v30;
            v15 = v11 == v24;
            v13 = v35;
            v14 = v9 == v20;
            if (v9 == v20)
            {
              v13 = v35;
              if (v11 == v24)
              {
                v13 = v35;
                if (v35 == v25)
                  return 1;
              }
            }
            continue;
          }
        }
        return 1;
      }
    }
    v26 = v75;
LABEL_11:
    *v26 = v23 + 32;
    v23 = v75[0];
    v22 = v70[0];
    v27 = v72;
    goto LABEL_12;
  }
  v18 = (const char *)a3[1];
  if (!v18)
    return 1;
  v19 = 0;
LABEL_45:
  v37 = v18;
  v71 = 257;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v75, a1, a4, v70);
  if (v75[0])
  {
    LODWORD(v72) = 5;
    v73 = v19;
    v38 = (char *)&v72;
    v39 = (char *)v76;
    if (v77 >= v78)
    {
      v61 = v77 + 1;
      if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
      {
        v66 = (char *)&v72 - (_BYTE *)v76;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v61, 24);
        v39 = (char *)v76;
        v38 = (char *)v76 + v66;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v61, 24);
        v38 = (char *)&v72;
        v39 = (char *)v76;
      }
    }
    v40 = &v39[24 * v77];
    v41 = *(_OWORD *)v38;
    *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
    *(_OWORD *)v40 = v41;
    v42 = ++v77;
    if (v75[0])
    {
      LODWORD(v72) = 3;
      v73 = " operands present, but expected ";
      v74 = 32;
      v43 = (char *)&v72;
      v44 = (char *)v76;
      if (v42 >= v78)
      {
        v62 = v42 + 1;
        v63 = (char *)v76 + 24 * v42 > (char *)&v72;
        if (v76 <= &v72 && v63)
        {
          v67 = (char *)&v72 - (_BYTE *)v76;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v62, 24);
          v44 = (char *)v76;
          v43 = (char *)v76 + v67;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v62, 24);
          v43 = (char *)&v72;
          v44 = (char *)v76;
        }
      }
      v45 = &v44[24 * v77];
      v46 = *(_OWORD *)v43;
      *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
      *(_OWORD *)v45 = v46;
      v47 = ++v77;
      if (v75[0])
      {
        LODWORD(v72) = 5;
        v73 = v37;
        v48 = (char *)&v72;
        v49 = (char *)v76;
        if (v47 >= v78)
        {
          v64 = v47 + 1;
          v65 = (char *)v76 + 24 * v47 > (char *)&v72;
          if (v76 <= &v72 && v65)
          {
            v68 = (char *)&v72 - (_BYTE *)v76;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v64, 24);
            v49 = (char *)v76;
            v48 = (char *)v76 + v68;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v64, 24);
            v48 = (char *)&v72;
            v49 = (char *)v76;
          }
        }
        v50 = &v49[24 * v77];
        v51 = *(_OWORD *)v48;
        *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
        *(_OWORD *)v50 = v51;
        ++v77;
      }
    }
  }
  v36 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v75);
  if (v75[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v75);
  if (v84)
  {
    v52 = __p;
    if (__p)
    {
      v53 = v83;
      v54 = __p;
      if (v83 != __p)
      {
        do
          v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
        while (v53 != v52);
        v54 = __p;
      }
      v83 = v52;
      operator delete(v54);
    }
    v55 = v80;
    if (v80)
    {
      v56 = v81;
      v57 = v80;
      if (v81 != v80)
      {
        do
        {
          v59 = *--v56;
          v58 = v59;
          *v56 = 0;
          if (v59)
            MEMORY[0x20BD002D4](v58, 0x1000C8077774924);
        }
        while (v56 != v55);
        v57 = v80;
      }
      v81 = v55;
      operator delete(v57);
    }
    if (v76 != v79)
      free(v76);
  }
  return v36;
}

void mlir::tensor::ScatterOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  llvm::raw_ostream *v6;
  _BYTE *v7;
  llvm::raw_ostream *v8;
  _DWORD *v9;
  llvm::raw_ostream *v10;
  _BYTE *v11;
  llvm::raw_ostream *v12;
  _BYTE *v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  llvm::raw_ostream *v16;
  _BYTE *v17;
  llvm::raw_ostream *v18;
  uint64_t v19;
  llvm::raw_ostream *v20;
  _BYTE *v21;
  _QWORD *v22;
  uint64_t v23;
  llvm::raw_ostream *v24;
  _BYTE *v25;
  unint64_t v26;
  llvm::raw_ostream *v27;
  _BYTE *v28;
  llvm::raw_ostream *v29;
  uint64_t v30;
  mlir::Operation *v31;
  mlir::ArrayAttr *v32;
  uint64_t Value;
  uint64_t v34;
  llvm::raw_ostream *v35;
  _BYTE *v36;
  llvm::raw_ostream *v37;
  _BYTE *v38;
  llvm::raw_ostream *v39;
  _BYTE *v40;
  mlir::Operation *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46[4];
  uint64_t v47[4];
  uint64_t v48[2];
  void *v49;
  uint64_t v50;
  _QWORD v51[5];

  v51[4] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 24));
  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v7 = (_BYTE *)*((_QWORD *)v6 + 4);
  if ((unint64_t)v7 >= *((_QWORD *)v6 + 3))
  {
    llvm::raw_ostream::write(v6, 32);
  }
  else
  {
    *((_QWORD *)v6 + 4) = v7 + 1;
    *v7 = 32;
  }
  v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v9 = (_DWORD *)*((_QWORD *)v8 + 4);
  if (*((_QWORD *)v8 + 3) - (_QWORD)v9 > 3uLL)
  {
    *v9 = 1869901417;
    *((_QWORD *)v8 + 4) += 4;
  }
  else
  {
    llvm::raw_ostream::write(v8, "into", 4uLL);
  }
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (_BYTE *)*((_QWORD *)v10 + 4);
  if ((unint64_t)v11 >= *((_QWORD *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }
  else
  {
    *((_QWORD *)v10 + 4) = v11 + 1;
    *v11 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 56));
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)v12 + 4);
  if (*((_BYTE **)v12 + 3) == v13)
  {
    llvm::raw_ostream::write(v12, "[", 1uLL);
  }
  else
  {
    *v13 = 91;
    ++*((_QWORD *)v12 + 4);
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 88));
  v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)v14 + 4);
  if (*((_BYTE **)v14 + 3) == v15)
  {
    llvm::raw_ostream::write(v14, "]", 1uLL);
  }
  else
  {
    *v15 = 93;
    ++*((_QWORD *)v14 + 4);
  }
  v16 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v17 = (_BYTE *)*((_QWORD *)v16 + 4);
  if ((unint64_t)v17 >= *((_QWORD *)v16 + 3))
  {
    llvm::raw_ostream::write(v16, 32);
  }
  else
  {
    *((_QWORD *)v16 + 4) = v17 + 1;
    *v17 = 32;
  }
  v18 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v19 = *((_QWORD *)v18 + 4);
  if ((unint64_t)(*((_QWORD *)v18 + 3) - v19) > 0xB)
  {
    *(_DWORD *)(v19 + 8) = 1936550244;
    *(_QWORD *)v19 = *(_QWORD *)"scatter_dims";
    *((_QWORD *)v18 + 4) += 12;
  }
  else
  {
    llvm::raw_ostream::write(v18, "scatter_dims", 0xCuLL);
  }
  v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v21 = (_BYTE *)*((_QWORD *)v20 + 4);
  if (*((_BYTE **)v20 + 3) == v21)
  {
    llvm::raw_ostream::write(v20, "(", 1uLL);
  }
  else
  {
    *v21 = 40;
    ++*((_QWORD *)v20 + 4);
  }
  v49 = (void *)*((_QWORD *)*this + 2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8);
  if (!(*(unsigned __int8 (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 104))(a2))
  {
    v22 = (_QWORD *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v23 = (*(uint64_t (**)(_QWORD *))(*v22 + 80))(v22) + v22[4] - v22[2];
    mlir::detail::DenseArrayAttrImpl<long long>::print((llvm::raw_ostream *)&v49, (uint64_t)a2);
    if (v23 == (*(uint64_t (**)(_QWORD *))(*v22 + 80))(v22) + v22[4] - v22[2])
      (*(void (**)(mlir::OpAsmPrinter *, void *))(*(_QWORD *)a2 + 40))(a2, v49);
  }
  v24 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v25 = (_BYTE *)*((_QWORD *)v24 + 4);
  if (*((_BYTE **)v24 + 3) == v25)
  {
    llvm::raw_ostream::write(v24, ")", 1uLL);
  }
  else
  {
    *v25 = 41;
    ++*((_QWORD *)v24 + 4);
  }
  v26 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v26 = 0;
  if (*(_QWORD *)(v26 + 8))
  {
    v27 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v28 = (_BYTE *)*((_QWORD *)v27 + 4);
    if ((unint64_t)v28 >= *((_QWORD *)v27 + 3))
    {
      llvm::raw_ostream::write(v27, 32);
    }
    else
    {
      *((_QWORD *)v27 + 4) = v28 + 1;
      *v28 = 32;
    }
    v29 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v30 = *((_QWORD *)v29 + 4);
    if ((unint64_t)(*((_QWORD *)v29 + 3) - v30) > 5)
    {
      *(_WORD *)(v30 + 4) = 25973;
      *(_DWORD *)v30 = 1902734965;
      *((_QWORD *)v29 + 4) += 6;
    }
    else
    {
      llvm::raw_ostream::write(v29, "unique", 6uLL);
    }
  }
  v49 = v51;
  v51[0] = "scatter_dims";
  v51[1] = 12;
  v51[2] = "unique";
  v51[3] = 6;
  v50 = 0x200000002;
  mlir::Attribute::getContext((mlir::Operation *)((char *)*this + 24));
  v31 = *this;
  if (*((_BYTE *)*this + 47))
  {
    v47[0] = mlir::Operation::getAttrDictionary(v31);
    v32 = (mlir::ArrayAttr *)v47;
  }
  else
  {
    v32 = (mlir::Operation *)((char *)v31 + 56);
  }
  Value = mlir::ArrayAttr::getValue(v32);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v34, v49, v50);
  v35 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v36 = (_BYTE *)*((_QWORD *)v35 + 4);
  if ((unint64_t)v36 >= *((_QWORD *)v35 + 3))
  {
    llvm::raw_ostream::write(v35, 32);
  }
  else
  {
    *((_QWORD *)v35 + 4) = v36 + 1;
    *v36 = 32;
  }
  v37 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v38 = (_BYTE *)*((_QWORD *)v37 + 4);
  if (*((_BYTE **)v37 + 3) == v38)
  {
    llvm::raw_ostream::write(v37, ":", 1uLL);
  }
  else
  {
    *v38 = 58;
    ++*((_QWORD *)v37 + 4);
  }
  v39 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v40 = (_BYTE *)*((_QWORD *)v39 + 4);
  if ((unint64_t)v40 >= *((_QWORD *)v39 + 3))
  {
    llvm::raw_ostream::write(v39, 32);
  }
  else
  {
    *((_QWORD *)v39 + 4) = v40 + 1;
    *v40 = 32;
  }
  v41 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    v42 = *((_QWORD *)v41 + 9);
    v43 = *((unsigned int *)v41 + 17);
  }
  else
  {
    v42 = 0;
    v43 = 0;
  }
  v46[0] = v42;
  v46[1] = v43;
  mlir::OperandRange::getTypes(v46, v47);
  v44 = *((unsigned int *)*this + 9);
  v45 = (uint64_t)*this - 16;
  if (!(_DWORD)v44)
    v45 = 0;
  v48[0] = v45;
  v48[1] = v44;
  mlir::OperandRange::getTypes(v48, v46);
  mlir::AsmPrinter::printFunctionalType<mlir::ValueTypeRange<mlir::OperandRange>,mlir::ValueTypeRange<mlir::ResultRange>>((uint64_t)a2, v47, v46);
  if (v49 != v51)
    free(v49);
}

uint64_t mlir::tensor::detail::SplatOpGenericAdaptorBase::SplatOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "tensor.splat", 12, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::tensor::SplatOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  void *v3;
  BOOL v4;
  BOOL v5;
  BOOL v6;
  BOOL v7;
  BOOL v8;
  BOOL v9;
  BOOL v10;
  BOOL v11;
  BOOL v12;
  BOOL v13;
  BOOL v14;
  uint64_t v16;
  uint64_t NextResultAtOffset;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  char *v34;
  char *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  char *v39;
  char *v40;
  __int128 v41;
  int *v42;
  char *v43;
  char *v44;
  __int128 v45;
  char v46;
  _QWORD *v47;
  _QWORD *v48;
  void *v49;
  _QWORD *v50;
  _QWORD *v51;
  void *v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v56;
  unint64_t v57;
  BOOL v58;
  unint64_t v59;
  BOOL v60;
  unint64_t v61;
  int64_t v62;
  int64_t v63;
  int64_t v64;
  int64_t v65;
  const void **v66[4];
  __int16 v67;
  unint64_t v68;
  int v69;
  const char *v70;
  uint64_t v71;
  _QWORD v72[3];
  void *v73;
  unsigned int v74;
  unsigned int v75;
  _BYTE v76[96];
  void *v77;
  _QWORD *v78;
  void *__p;
  _QWORD *v80;
  char v81;
  uint64_t v82;

  v82 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v68 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!mlir::Type::isSignlessInteger((mlir::Type *)&v68))
  {
    v3 = *(void **)(*(_QWORD *)v68 + 136);
    v4 = v3 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id
      || v3 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id;
    v5 = v4 || v3 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id;
    v6 = v5 || v3 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id;
    v7 = v6 || v3 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id;
    v8 = v7 || v3 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id;
    v9 = v8 || v3 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id;
    v10 = v9 || v3 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id;
    v11 = v10 || v3 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id;
    v12 = v11 || v3 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id;
    v13 = v12 || v3 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id;
    v14 = v13 || v3 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id;
    if (!v14 && v3 != &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
    {
      v67 = 261;
      v66[0] = (const void **)"operand";
      v66[1] = (const void **)7;
      mlir::Operation::emitOpError(v2, v66, (uint64_t)v72);
      if (v72[0])
      {
        v69 = 3;
        v70 = " #";
        v71 = 2;
        v28 = &v69;
        v29 = (char *)v73;
        if (v74 >= v75)
        {
          v56 = v74 + 1;
          if (v73 <= &v69 && (char *)v73 + 24 * v74 > (char *)&v69)
          {
            v62 = (char *)&v69 - (_BYTE *)v73;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v56, 24);
            v29 = (char *)v73;
            v28 = (int *)((char *)v73 + v62);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v56, 24);
            v28 = &v69;
            v29 = (char *)v73;
          }
        }
        v30 = &v29[24 * v74];
        v31 = *(_OWORD *)v28;
        *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
        *(_OWORD *)v30 = v31;
        v32 = ++v74;
        if (v72[0])
        {
          v69 = 5;
          v70 = 0;
          v33 = &v69;
          v34 = (char *)v73;
          if (v32 >= v75)
          {
            v57 = v32 + 1;
            v58 = (char *)v73 + 24 * v32 > (char *)&v69;
            if (v73 <= &v69 && v58)
            {
              v63 = (char *)&v69 - (_BYTE *)v73;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v57, 24);
              v34 = (char *)v73;
              v33 = (int *)((char *)v73 + v63);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v57, 24);
              v33 = &v69;
              v34 = (char *)v73;
            }
          }
          v35 = &v34[24 * v74];
          v36 = *(_OWORD *)v33;
          *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
          *(_OWORD *)v35 = v36;
          v37 = ++v74;
          if (v72[0])
          {
            v69 = 3;
            v70 = " must be integer/index/float type, but got ";
            v71 = 43;
            v38 = &v69;
            v39 = (char *)v73;
            if (v37 >= v75)
            {
              v59 = v37 + 1;
              v60 = (char *)v73 + 24 * v37 > (char *)&v69;
              if (v73 <= &v69 && v60)
              {
                v64 = (char *)&v69 - (_BYTE *)v73;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v59, 24);
                v39 = (char *)v73;
                v38 = (int *)((char *)v73 + v64);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v59, 24);
                v38 = &v69;
                v39 = (char *)v73;
              }
            }
            v40 = &v39[24 * v74];
            v41 = *(_OWORD *)v38;
            *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
            *(_OWORD *)v40 = v41;
            ++v74;
            if (v72[0])
            {
              v42 = &v69;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v69, v68);
              v43 = (char *)v73;
              if (v74 >= v75)
              {
                v61 = v74 + 1;
                if (v73 <= &v69 && (char *)v73 + 24 * v74 > (char *)&v69)
                {
                  v65 = (char *)&v69 - (_BYTE *)v73;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v61, 24);
                  v43 = (char *)v73;
                  v42 = (int *)((char *)v73 + v65);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v61, 24);
                  v42 = &v69;
                  v43 = (char *)v73;
                }
              }
              v44 = &v43[24 * v74];
              v45 = *(_OWORD *)v42;
              *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
              *(_OWORD *)v44 = v45;
              ++v74;
            }
          }
        }
      }
      v46 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v72);
      if (v72[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v72);
      if (v81)
      {
        v47 = __p;
        if (__p)
        {
          v48 = v80;
          v49 = __p;
          if (v80 != __p)
          {
            do
              v48 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v48 - 1);
            while (v48 != v47);
            v49 = __p;
          }
          v80 = v47;
          operator delete(v49);
        }
        v50 = v77;
        if (v77)
        {
          v51 = v78;
          v52 = v77;
          if (v78 != v77)
          {
            do
            {
              v54 = *--v51;
              v53 = v54;
              *v51 = 0;
              if (v54)
                MEMORY[0x20BD002D4](v53, 0x1000C8077774924);
            }
            while (v51 != v50);
            v52 = v77;
          }
          v78 = v50;
          operator delete(v52);
        }
        if (v73 != v76)
          free(v73);
      }
      if (!v46)
        return 0;
    }
  }
  v16 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 0);
  if (!mlir::tensor::__mlir_ods_local_type_constraint_TensorOps7(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0))return 0;
  if (*((_DWORD *)*this + 9))
    v18 = (uint64_t)(*this - 2);
  else
    v18 = 0;
  v72[0] = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v18, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (mlir::TensorType::getElementType((mlir::TensorType *)v72) == (*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
    return 1;
  v66[0] = (const void **)"failed to verify that operand type matches element type of result";
  v67 = 259;
  mlir::OpState::emitOpError(this, v66, (uint64_t)v72);
  v19 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v72);
  if (v72[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v72);
  if (v81)
  {
    v20 = __p;
    if (__p)
    {
      v21 = v80;
      v22 = __p;
      if (v80 != __p)
      {
        do
          v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
        while (v21 != v20);
        v22 = __p;
      }
      v80 = v20;
      operator delete(v22);
    }
    v23 = v77;
    if (v77)
    {
      v24 = v78;
      v25 = v77;
      if (v78 != v77)
      {
        do
        {
          v27 = *--v24;
          v26 = v27;
          *v24 = 0;
          if (v27)
            MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
        }
        while (v24 != v23);
        v25 = v77;
      }
      v78 = v23;
      operator delete(v25);
    }
    if (v73 != v76)
      free(v73);
  }
  return v19;
}

BOOL mlir::tensor::SplatOp::parse(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  _QWORD *Shape;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t ElementType;
  uint64_t v12;
  uint64_t v14;
  int *v15;
  char *v16;
  char *v17;
  __int128 v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  _QWORD v35[4];
  __int16 v36;
  int v37;
  const char *v38;
  uint64_t v39;
  _QWORD v40[3];
  void *v41;
  unsigned int v42;
  unsigned int v43;
  _BYTE v44[96];
  void *v45;
  _QWORD *v46;
  void *__p;
  _QWORD *v48;
  char v49;
  _QWORD v50[5];

  v50[4] = *MEMORY[0x24BDAC8D0];
  memset(v50, 0, 24);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v50, 1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v40[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, v40))
    return 0;
  v4 = (_QWORD *)v40[0];
  if (*(_UNKNOWN **)(*(_QWORD *)v40[0] + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v5 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v40[0] + 8);
    v40[0] = v4;
    v40[1] = v5;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v40))
    {
      Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)v40);
      if (!v7)
      {
LABEL_11:
        v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v4 + 8);
        v35[0] = v4;
        v35[1] = v9;
        mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v35);
        v10 = *(unsigned int *)(a2 + 72);
        if (v10 >= *(_DWORD *)(a2 + 76))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v10 + 1, 8);
          LODWORD(v10) = *(_DWORD *)(a2 + 72);
        }
        *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v10) = v4;
        ++*(_DWORD *)(a2 + 72);
        v40[0] = v4;
        ElementType = mlir::TensorType::getElementType((mlir::TensorType *)v40);
        return (*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v50, ElementType, a2 + 16) != 0;
      }
      v8 = 8 * v7;
      while (*Shape != 0x8000000000000000)
      {
        ++Shape;
        v8 -= 8;
        if (!v8)
          goto LABEL_11;
      }
    }
  }
  v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v36 = 257;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v40, a1, v14, v35);
  if (v40[0])
  {
    v37 = 3;
    v38 = "'aggregate' must be statically shaped tensor of any type values, but got ";
    v39 = 73;
    v15 = &v37;
    v16 = (char *)v41;
    if (v42 >= v43)
    {
      v31 = v42 + 1;
      if (v41 <= &v37 && (char *)v41 + 24 * v42 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v41;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v31, 24);
        v16 = (char *)v41;
        v15 = (int *)((char *)v41 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v31, 24);
        v15 = &v37;
        v16 = (char *)v41;
      }
    }
    v17 = &v16[24 * v42];
    v18 = *(_OWORD *)v15;
    *((_QWORD *)v17 + 2) = *((_QWORD *)v15 + 2);
    *(_OWORD *)v17 = v18;
    ++v42;
    if (v40[0])
    {
      v19 = &v37;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v37, (uint64_t)v4);
      v20 = (char *)v41;
      if (v42 >= v43)
      {
        v32 = v42 + 1;
        if (v41 <= &v37 && (char *)v41 + 24 * v42 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v41;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
          v20 = (char *)v41;
          v19 = (int *)((char *)v41 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
          v19 = &v37;
          v20 = (char *)v41;
        }
      }
      v21 = &v20[24 * v42];
      v22 = *(_OWORD *)v19;
      *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
      *(_OWORD *)v21 = v22;
      ++v42;
    }
  }
  v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v40);
  if (v40[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v40);
  if (v49)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v48;
      v25 = __p;
      if (v48 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v48 = v23;
      operator delete(v25);
    }
    v26 = v45;
    if (v45)
    {
      v27 = v46;
      v28 = v45;
      if (v46 != v45)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v45;
      }
      v46 = v26;
      operator delete(v28);
    }
    if (v41 != v44)
      free(v41);
  }
  return v12;
}

void mlir::tensor::SplatOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  mlir::Operation *v6;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v9;
  llvm::raw_ostream *v10;
  _BYTE *v11;
  llvm::raw_ostream *v12;
  _BYTE *v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t NextResultAtOffset;
  unint64_t AttrDictionary;
  void *v19;
  uint64_t v20;
  _QWORD v21[5];

  v21[4] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 24));
  v19 = v21;
  v20 = 0x200000000;
  v6 = *this;
  if (*((_BYTE *)*this + 47))
  {
    AttrDictionary = mlir::Operation::getAttrDictionary(v6);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::Operation *)((char *)v6 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v9, v19, v20);
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (_BYTE *)*((_QWORD *)v10 + 4);
  if ((unint64_t)v11 >= *((_QWORD *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }
  else
  {
    *((_QWORD *)v10 + 4) = v11 + 1;
    *v11 = 32;
  }
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)v12 + 4);
  if (*((_BYTE **)v12 + 3) == v13)
  {
    llvm::raw_ostream::write(v12, ":", 1uLL);
  }
  else
  {
    *v13 = 58;
    ++*((_QWORD *)v12 + 4);
  }
  v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)v14 + 4);
  if ((unint64_t)v15 >= *((_QWORD *)v14 + 3))
  {
    llvm::raw_ostream::write(v14, 32);
  }
  else
  {
    *((_QWORD *)v14 + 4) = v15 + 1;
    *v15 = 32;
  }
  if (*((_DWORD *)*this + 9))
    v16 = (uint64_t)*this - 16;
  else
    v16 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 0);
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v19 != v21)
    free(v19);
}

uint64_t mlir::tensor::detail::UnPackOpGenericAdaptorBase::UnPackOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  uint64_t Context;
  unint64_t v11[3];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v5;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(v5 + 16);
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 48) = *(_OWORD *)v11;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "tensor.unpack", 13, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::tensor::UnPackOp::getODSOperands(mlir::tensor::UnPackOp *this, unsigned int a2)
{
  int v2;
  unsigned int v3;
  int32x4_t v4;
  int32x4_t v5;
  uint32x4_t v6;
  int32x4_t v7;
  int32x4_t v8;
  unsigned int v9;
  int32x4_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;

  if (a2)
  {
    if (a2 >= 8)
    {
      v4 = (int32x4_t)xmmword_207A8E9A0;
      v3 = a2 & 0xFFFFFFF8;
      v5 = 0uLL;
      v6.i64[0] = 0x100000001;
      v6.i64[1] = 0x100000001;
      v7.i64[0] = 0x300000003;
      v7.i64[1] = 0x300000003;
      v8.i64[0] = 0x800000008;
      v8.i64[1] = 0x800000008;
      v9 = a2 & 0xFFFFFFF8;
      v10 = 0uLL;
      do
      {
        v5 = vsubq_s32(v5, (int32x4_t)vcgtq_u32((uint32x4_t)v4, v6));
        v10 = vsubq_s32(v10, (int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32((int32x4_t)(*(_OWORD *)&v4 & __PAIR128__(0xFFFFFFFEFFFFFFFELL, 0xFFFFFFFEFFFFFFFELL)), v7)));
        v4 = vaddq_s32(v4, v8);
        v9 -= 8;
      }
      while (v9);
      v2 = vaddvq_s32(vaddq_s32(v10, v5));
      if (v3 == a2)
        goto LABEL_11;
    }
    else
    {
      v2 = 0;
      v3 = 0;
    }
    do
    {
      if (v3 > 1)
        ++v2;
      ++v3;
    }
    while (a2 != v3);
  }
  else
  {
    v2 = 0;
  }
LABEL_11:
  v11 = *(_QWORD *)this;
  if ((*(_BYTE *)(*(_QWORD *)this + 46) & 0x80) != 0)
  {
    v12 = *(_DWORD *)(v11 + 68);
    v13 = *(_QWORD *)(v11 + 72);
  }
  else
  {
    v12 = 0;
    v13 = 0;
  }
  return v13 + 32 * (a2 + (v12 - 3) * v2);
}

uint64_t mlir::tensor::UnPackOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  int *v15;
  char *v16;
  char *v17;
  __int128 v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  int *v27;
  char *v28;
  char *v29;
  __int128 v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  int *v37;
  char *v38;
  char *v39;
  __int128 v40;
  int *v41;
  char *v42;
  char *v43;
  __int128 v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  _QWORD *v48;
  uint64_t v49;
  uint64_t v50;
  int *v51;
  char *v52;
  char *v53;
  __int128 v54;
  int *v55;
  char *v56;
  char *v57;
  __int128 v58;
  _QWORD *v59;
  _QWORD *v60;
  void *v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  int *v65;
  char *v66;
  char *v67;
  __int128 v68;
  _QWORD *v69;
  _QWORD *v70;
  void *v71;
  _QWORD *v72;
  uint64_t v73;
  uint64_t v74;
  int *v75;
  char *v76;
  char *v77;
  __int128 v78;
  int *v79;
  char *v80;
  char *v81;
  __int128 v82;
  _QWORD *v83;
  _QWORD *v84;
  void *v85;
  _QWORD *v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  int64_t v98;
  int64_t v99;
  int64_t v100;
  int64_t v101;
  int64_t v102;
  int64_t v103;
  int64_t v104;
  int64_t v105;
  int64_t v106;
  uint64_t v107;
  int v108;
  const char *v109;
  uint64_t v110;
  _QWORD v111[3];
  void *v112;
  unsigned int v113;
  unsigned int v114;
  _BYTE v115[96];
  void *v116;
  _QWORD *v117;
  void *__p;
  _QWORD *v119;
  char v120;
  uint64_t v121;

  v121 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v107 = v6;
  if (!v6)
  {
    a3(v111, a4);
    if (v111[0])
    {
      v108 = 3;
      v109 = "expected DictionaryAttr to set properties";
      v110 = 41;
      v15 = &v108;
      v16 = (char *)v112;
      if (v113 >= v114)
      {
        v89 = v113 + 1;
        if (v112 <= &v108 && (char *)v112 + 24 * v113 > (char *)&v108)
        {
          v98 = (char *)&v108 - (_BYTE *)v112;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v89, 24);
          v16 = (char *)v112;
          v15 = (int *)((char *)v112 + v98);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v89, 24);
          v15 = &v108;
          v16 = (char *)v112;
        }
      }
      v17 = &v16[24 * v113];
      v18 = *(_OWORD *)v15;
      *((_QWORD *)v17 + 2) = *((_QWORD *)v15 + 2);
      *(_OWORD *)v17 = v18;
      ++v113;
      if (v111[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v111);
    }
    if (!v120)
      return 0;
    v19 = __p;
    if (__p)
    {
      v20 = v119;
      v21 = __p;
      if (v119 != __p)
      {
        do
          v20 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v20 - 1);
        while (v20 != v19);
        v21 = __p;
      }
      v119 = v19;
      operator delete(v21);
    }
    v22 = v116;
    if (!v116)
      goto LABEL_117;
    v23 = v117;
    v24 = v116;
    if (v117 == v116)
      goto LABEL_116;
    do
    {
      v26 = *--v23;
      v25 = v26;
      *v23 = 0;
      if (v26)
        MEMORY[0x20BD002D4](v25, 0x1000C8077774924);
    }
    while (v23 != v22);
    goto LABEL_115;
  }
  v8 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v107, "inner_dims_pos", 0xEuLL);
  if (!v8)
  {
    a3(v111, a4);
    if (v111[0])
    {
      v108 = 3;
      v109 = "expected key entry for inner_dims_pos in DictionaryAttr to set Properties.";
      v110 = 74;
      v27 = &v108;
      v28 = (char *)v112;
      if (v113 >= v114)
      {
        v90 = v113 + 1;
        if (v112 <= &v108 && (char *)v112 + 24 * v113 > (char *)&v108)
        {
          v99 = (char *)&v108 - (_BYTE *)v112;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v90, 24);
          v28 = (char *)v112;
          v27 = (int *)((char *)v112 + v99);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v90, 24);
          v27 = &v108;
          v28 = (char *)v112;
        }
      }
      v29 = &v28[24 * v113];
      v30 = *(_OWORD *)v27;
      *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
      *(_OWORD *)v29 = v30;
      ++v113;
      if (v111[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v111);
    }
    if (!v120)
      return 0;
    v31 = __p;
    if (__p)
    {
      v32 = v119;
      v33 = __p;
      if (v119 != __p)
      {
        do
          v32 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v32 - 1);
        while (v32 != v31);
        v33 = __p;
      }
      v119 = v31;
      operator delete(v33);
    }
    v22 = v116;
    if (!v116)
      goto LABEL_117;
    v34 = v117;
    v24 = v116;
    if (v117 == v116)
      goto LABEL_116;
    do
    {
      v36 = *--v34;
      v35 = v36;
      *v34 = 0;
      if (v36)
        MEMORY[0x20BD002D4](v35, 0x1000C8077774924);
    }
    while (v34 != v22);
    goto LABEL_115;
  }
  v9 = (uint64_t)v8;
  if (!mlir::detail::DenseArrayAttrImpl<long long>::classof(v8))
  {
    a3(v111, a4);
    if (v111[0])
    {
      v108 = 3;
      v110 = 59;
      v37 = &v108;
      v38 = (char *)v112;
      if (v113 >= v114)
      {
        v91 = v113 + 1;
        if (v112 <= &v108 && (char *)v112 + 24 * v113 > (char *)&v108)
        {
          v100 = (char *)&v108 - (_BYTE *)v112;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v91, 24);
          v38 = (char *)v112;
          v37 = (int *)((char *)v112 + v100);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v91, 24);
          v37 = &v108;
          v38 = (char *)v112;
        }
      }
      v39 = &v38[24 * v113];
      v40 = *(_OWORD *)v37;
      *((_QWORD *)v39 + 2) = *((_QWORD *)v37 + 2);
      *(_OWORD *)v39 = v40;
      ++v113;
      if (v111[0])
      {
        v41 = &v108;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v108, v9);
        v42 = (char *)v112;
        if (v113 >= v114)
        {
          v92 = v113 + 1;
          if (v112 <= &v108 && (char *)v112 + 24 * v113 > (char *)&v108)
          {
            v101 = (char *)&v108 - (_BYTE *)v112;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v92, 24);
            v42 = (char *)v112;
            v41 = (int *)((char *)v112 + v101);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v92, 24);
            v41 = &v108;
            v42 = (char *)v112;
          }
        }
        v43 = &v42[24 * v113];
        v44 = *(_OWORD *)v41;
        *((_QWORD *)v43 + 2) = *((_QWORD *)v41 + 2);
        *(_OWORD *)v43 = v44;
        ++v113;
        if (v111[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v111);
      }
    }
    if (!v120)
      return 0;
    v45 = __p;
    if (__p)
    {
      v46 = v119;
      v47 = __p;
      if (v119 != __p)
      {
        do
          v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
        while (v46 != v45);
        v47 = __p;
      }
      v119 = v45;
      operator delete(v47);
    }
    v22 = v116;
    if (!v116)
      goto LABEL_117;
    v48 = v117;
    v24 = v116;
    if (v117 == v116)
      goto LABEL_116;
    do
    {
      v50 = *--v48;
      v49 = v50;
      *v48 = 0;
      if (v50)
        MEMORY[0x20BD002D4](v49, 0x1000C8077774924);
    }
    while (v48 != v22);
    goto LABEL_115;
  }
  *a1 = v9;
  v10 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v107, "outer_dims_perm", 0xFuLL);
  if (v10)
  {
    v11 = (uint64_t)v10;
    if (!mlir::detail::DenseArrayAttrImpl<long long>::classof(v10))
    {
      a3(v111, a4);
      if (v111[0])
      {
        v108 = 3;
        v110 = 60;
        v51 = &v108;
        v52 = (char *)v112;
        if (v113 >= v114)
        {
          v93 = v113 + 1;
          if (v112 <= &v108 && (char *)v112 + 24 * v113 > (char *)&v108)
          {
            v102 = (char *)&v108 - (_BYTE *)v112;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v93, 24);
            v52 = (char *)v112;
            v51 = (int *)((char *)v112 + v102);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v93, 24);
            v51 = &v108;
            v52 = (char *)v112;
          }
        }
        v53 = &v52[24 * v113];
        v54 = *(_OWORD *)v51;
        *((_QWORD *)v53 + 2) = *((_QWORD *)v51 + 2);
        *(_OWORD *)v53 = v54;
        ++v113;
        if (v111[0])
        {
          v55 = &v108;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v108, v11);
          v56 = (char *)v112;
          if (v113 >= v114)
          {
            v96 = v113 + 1;
            if (v112 <= &v108 && (char *)v112 + 24 * v113 > (char *)&v108)
            {
              v105 = (char *)&v108 - (_BYTE *)v112;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v96, 24);
              v56 = (char *)v112;
              v55 = (int *)((char *)v112 + v105);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v96, 24);
              v55 = &v108;
              v56 = (char *)v112;
            }
          }
          v57 = &v56[24 * v113];
          v58 = *(_OWORD *)v55;
          *((_QWORD *)v57 + 2) = *((_QWORD *)v55 + 2);
          *(_OWORD *)v57 = v58;
          ++v113;
          if (v111[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v111);
        }
      }
      if (!v120)
        return 0;
      v59 = __p;
      if (__p)
      {
        v60 = v119;
        v61 = __p;
        if (v119 != __p)
        {
          do
            v60 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v60 - 1);
          while (v60 != v59);
          v61 = __p;
        }
        v119 = v59;
        operator delete(v61);
      }
      v22 = v116;
      if (!v116)
        goto LABEL_117;
      v62 = v117;
      v24 = v116;
      if (v117 == v116)
        goto LABEL_116;
      do
      {
        v64 = *--v62;
        v63 = v64;
        *v62 = 0;
        if (v64)
          MEMORY[0x20BD002D4](v63, 0x1000C8077774924);
      }
      while (v62 != v22);
      goto LABEL_115;
    }
    a1[1] = v11;
  }
  v12 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v107, "static_inner_tiles", 0x12uLL);
  if (!v12)
  {
    a3(v111, a4);
    if (v111[0])
    {
      v108 = 3;
      v109 = "expected key entry for static_inner_tiles in DictionaryAttr to set Properties.";
      v110 = 78;
      v65 = &v108;
      v66 = (char *)v112;
      if (v113 >= v114)
      {
        v94 = v113 + 1;
        if (v112 <= &v108 && (char *)v112 + 24 * v113 > (char *)&v108)
        {
          v103 = (char *)&v108 - (_BYTE *)v112;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v94, 24);
          v66 = (char *)v112;
          v65 = (int *)((char *)v112 + v103);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v94, 24);
          v65 = &v108;
          v66 = (char *)v112;
        }
      }
      v67 = &v66[24 * v113];
      v68 = *(_OWORD *)v65;
      *((_QWORD *)v67 + 2) = *((_QWORD *)v65 + 2);
      *(_OWORD *)v67 = v68;
      ++v113;
      if (v111[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v111);
    }
    if (!v120)
      return 0;
    v69 = __p;
    if (__p)
    {
      v70 = v119;
      v71 = __p;
      if (v119 != __p)
      {
        do
          v70 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v70 - 1);
        while (v70 != v69);
        v71 = __p;
      }
      v119 = v69;
      operator delete(v71);
    }
    v22 = v116;
    if (!v116)
      goto LABEL_117;
    v72 = v117;
    v24 = v116;
    if (v117 == v116)
      goto LABEL_116;
    do
    {
      v74 = *--v72;
      v73 = v74;
      *v72 = 0;
      if (v74)
        MEMORY[0x20BD002D4](v73, 0x1000C8077774924);
    }
    while (v72 != v22);
    goto LABEL_115;
  }
  v13 = (uint64_t)v12;
  if (mlir::detail::DenseArrayAttrImpl<long long>::classof(v12))
  {
    a1[2] = v13;
    return 1;
  }
  a3(v111, a4);
  if (v111[0])
  {
    v108 = 3;
    v110 = 63;
    v75 = &v108;
    v76 = (char *)v112;
    if (v113 >= v114)
    {
      v95 = v113 + 1;
      if (v112 <= &v108 && (char *)v112 + 24 * v113 > (char *)&v108)
      {
        v104 = (char *)&v108 - (_BYTE *)v112;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v95, 24);
        v76 = (char *)v112;
        v75 = (int *)((char *)v112 + v104);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v95, 24);
        v75 = &v108;
        v76 = (char *)v112;
      }
    }
    v77 = &v76[24 * v113];
    v78 = *(_OWORD *)v75;
    *((_QWORD *)v77 + 2) = *((_QWORD *)v75 + 2);
    *(_OWORD *)v77 = v78;
    ++v113;
    if (v111[0])
    {
      v79 = &v108;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v108, v13);
      v80 = (char *)v112;
      if (v113 >= v114)
      {
        v97 = v113 + 1;
        if (v112 <= &v108 && (char *)v112 + 24 * v113 > (char *)&v108)
        {
          v106 = (char *)&v108 - (_BYTE *)v112;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v97, 24);
          v80 = (char *)v112;
          v79 = (int *)((char *)v112 + v106);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v97, 24);
          v79 = &v108;
          v80 = (char *)v112;
        }
      }
      v81 = &v80[24 * v113];
      v82 = *(_OWORD *)v79;
      *((_QWORD *)v81 + 2) = *((_QWORD *)v79 + 2);
      *(_OWORD *)v81 = v82;
      ++v113;
      if (v111[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v111);
    }
  }
  if (v120)
  {
    v83 = __p;
    if (__p)
    {
      v84 = v119;
      v85 = __p;
      if (v119 != __p)
      {
        do
          v84 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v84 - 1);
        while (v84 != v83);
        v85 = __p;
      }
      v119 = v83;
      operator delete(v85);
    }
    v22 = v116;
    if (!v116)
      goto LABEL_117;
    v86 = v117;
    v24 = v116;
    if (v117 == v116)
    {
LABEL_116:
      v117 = v22;
      operator delete(v24);
LABEL_117:
      if (v112 != v115)
        free(v112);
      return 0;
    }
    do
    {
      v88 = *--v86;
      v87 = v88;
      *v86 = 0;
      if (v88)
        MEMORY[0x20BD002D4](v87, 0x1000C8077774924);
    }
    while (v86 != v22);
LABEL_115:
    v24 = v116;
    goto LABEL_116;
  }
  return 0;
}

uint64_t mlir::tensor::UnPackOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  void *v21;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v24;
  void *v25;
  uint64_t v26;
  _QWORD v27[7];

  v27[6] = *MEMORY[0x24BDAC8D0];
  v24 = a1;
  v25 = v27;
  v26 = 0x300000000;
  if (!*a2)
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_10;
    goto LABEL_7;
  }
  NamedAttr = mlir::Builder::getNamedAttr(&v24, (uint64_t)"inner_dims_pos", 14, *a2);
  v5 = v4;
  v6 = v26;
  if (v26 >= HIDWORD(v26))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
    v6 = v26;
  }
  v7 = (uint64_t *)((char *)v25 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = v26 + 1;
  LODWORD(v26) = v26 + 1;
  v9 = a2[1];
  if (v9)
  {
LABEL_7:
    v10 = mlir::Builder::getNamedAttr(&v24, (uint64_t)"outer_dims_perm", 15, v9);
    v12 = v11;
    v13 = v26;
    if (v26 >= HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
      v13 = v26;
    }
    v14 = (uint64_t *)((char *)v25 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    v8 = v26 + 1;
    LODWORD(v26) = v26 + 1;
  }
LABEL_10:
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v24, (uint64_t)"static_inner_tiles", 18, v15);
    v18 = v17;
    v19 = v26;
    if (v26 >= HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
      v19 = v26;
    }
    v20 = (uint64_t *)((char *)v25 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    v8 = v26 + 1;
    LODWORD(v26) = v26 + 1;
  }
  v21 = v25;
  if (!v8)
  {
    DictionaryAttr = 0;
    if (v25 == v27)
      return DictionaryAttr;
    goto LABEL_16;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v24, (mlir::MLIRContext *)v25, v8);
  v21 = v25;
  if (v25 != v27)
LABEL_16:
    free(v21);
  return DictionaryAttr;
}

uint64_t mlir::tensor::UnPackOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  if (__n == 18)
  {
    if (!memcmp(__s1, "static_inner_tiles", 0x12uLL))
      return a2[2];
    return 0;
  }
  if (__n == 15)
  {
    if (!memcmp(__s1, "outer_dims_perm", 0xFuLL))
      return a2[1];
    return 0;
  }
  if (__n != 14)
    return 0;
  if (*(_QWORD *)__s1 != 0x69645F72656E6E69 || *(_QWORD *)(__s1 + 6) != 0x736F705F736D6964)
    return 0;
  return *a2;
}

uint64_t mlir::tensor::UnPackOp::setInherentAttr(uint64_t result, char *__s1, uint64_t a3, _QWORD *a4)
{
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;

  v5 = (_QWORD *)result;
  if (a3 == 18)
  {
    result = memcmp(__s1, "static_inner_tiles", 0x12uLL);
    if (!(_DWORD)result)
    {
      if (a4)
      {
        result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
        if ((_DWORD)result)
          v7 = a4;
        else
          v7 = 0;
        v5[2] = v7;
      }
      else
      {
        v5[2] = 0;
      }
    }
  }
  else if (a3 == 15)
  {
    result = memcmp(__s1, "outer_dims_perm", 0xFuLL);
    if (!(_DWORD)result)
    {
      if (a4)
      {
        result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
        if ((_DWORD)result)
          v8 = a4;
        else
          v8 = 0;
        v5[1] = v8;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (a3 == 14 && *(_QWORD *)__s1 == 0x69645F72656E6E69 && *(_QWORD *)(__s1 + 6) == 0x736F705F736D6964)
  {
    if (a4)
    {
      result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
      if ((_DWORD)result)
        v9 = a4;
      else
        v9 = 0;
      *v5 = v9;
    }
    else
    {
      *(_QWORD *)result = 0;
    }
  }
  return result;
}

void mlir::tensor::UnPackOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"inner_dims_pos", 14, *a2);
  v5 = a2[1];
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"outer_dims_perm", 15, v5);
  v6 = a2[2];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"static_inner_tiles", 18, v6);
}

BOOL mlir::tensor::UnPackOp::readProperties(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;

  v3 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::UnPackOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3 + 2) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::tensor::detail::UnPackOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  uint64_t *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::UnPackOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::UnPackOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::UnPackOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::UnPackOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::tensor::detail::UnPackOpGenericAdaptorBase::Properties]";
        v15 = 110;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::tensor::detail::UnPackOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[248];
    return a1[32];
  }
  return result;
}

uint64_t mlir::tensor::UnPackOp::writeProperties(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;

  if (HIBYTE(*(_DWORD *)(*(_QWORD *)a1 + 44)))
    v3 = (_QWORD *)(*(_QWORD *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1) + 64);
  else
    v3 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, *v3);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, v3[1]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, v3[2]);
}

uint64_t mlir::tensor::UnPackOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  unsigned int v7;
  uint64_t ODSOperands;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t NextResultAtOffset;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  const void **v37[4];
  __int16 v38;
  _QWORD v39[3];
  void *v40;
  uint64_t v41;
  void *v42;
  _QWORD *v43;
  void *__p;
  _QWORD *v45;
  char v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_QWORD **)v3;
  if (!*(_QWORD *)v3)
  {
    v37[0] = (const void **)"requires attribute 'inner_dims_pos'";
    v38 = 259;
    mlir::OpState::emitOpError(this, v37, (uint64_t)v39);
    v19 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v39);
    if (v39[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v39);
    if (!v46)
      return v19;
    v22 = __p;
    if (__p)
    {
      v23 = v45;
      v24 = __p;
      if (v45 != __p)
      {
        do
          v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        v24 = __p;
      }
      v45 = v22;
      operator delete(v24);
    }
    v25 = v42;
    if (v42)
    {
      v26 = v43;
      v27 = v42;
      if (v43 == v42)
        goto LABEL_58;
      do
      {
        v29 = *--v26;
        v28 = v29;
        *v26 = 0;
        if (v29)
          MEMORY[0x20BD002D4](v28, 0x1000C8077774924);
      }
      while (v26 != v25);
LABEL_57:
      v27 = v42;
LABEL_58:
      v43 = v25;
      operator delete(v27);
    }
LABEL_59:
    if (v40 != &v41)
      free(v40);
    return v19;
  }
  v5 = *(_QWORD **)(v3 + 16);
  if (!v5)
  {
    v37[0] = (const void **)"requires attribute 'static_inner_tiles'";
    v38 = 259;
    mlir::OpState::emitOpError(this, v37, (uint64_t)v39);
    v19 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v39);
    if (v39[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v39);
    if (!v46)
      return v19;
    v30 = __p;
    if (__p)
    {
      v31 = v45;
      v32 = __p;
      if (v45 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v45 = v30;
      operator delete(v32);
    }
    v25 = v42;
    if (v42)
    {
      v33 = v43;
      v27 = v42;
      if (v43 == v42)
        goto LABEL_58;
      do
      {
        v35 = *--v33;
        v34 = v35;
        *v33 = 0;
        if (v35)
          MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
      }
      while (v33 != v25);
      goto LABEL_57;
    }
    goto LABEL_59;
  }
  v6 = *(_QWORD **)(v3 + 8);
  v39[0] = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v6, (const void **)"outer_dims_perm", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v39))return 0;
  v39[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v4, (const void **)"inner_dims_pos", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v39))return 0;
  v39[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v5, (const void **)"static_inner_tiles", (const char *)0x12, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v39)|| !mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))
  {
    return 0;
  }
  v7 = 1;
  ODSOperands = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 1u);
  if (v9)
  {
    v10 = v9;
    v11 = 0;
    v12 = ODSOperands + 24;
    while (mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(*(_QWORD *)v12 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, (int)v11 + 1))
    {
      ++v11;
      v12 += 32;
      if (v10 == v11)
      {
        v7 = v11 + 1;
        goto LABEL_15;
      }
    }
    return 0;
  }
LABEL_15:
  v13 = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 2u);
  if (v14)
  {
    v15 = v14;
    v16 = v13 + 24;
    while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v16 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v7))
    {
      ++v7;
      v16 += 32;
      if (!--v15)
        goto LABEL_19;
    }
    return 0;
  }
LABEL_19:
  v17 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v17, 0);
  if (!mlir::tensor::__mlir_ods_local_type_constraint_TensorOps1(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0))return 0;
  v19 = 1;
  v20 = *(_QWORD *)(*(_QWORD *)(mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 1u) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*((_DWORD *)*this + 9))
    v21 = (uint64_t)(*this - 2);
  else
    v21 = 0;
  if (v20 != (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v21, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    v37[0] = (const void **)"failed to verify that result type matches type of dest";
    v38 = 259;
    mlir::OpState::emitOpError(this, v37, (uint64_t)v39);
    v19 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v39);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v39);
  }
  return v19;
}

uint64_t mlir::tensor::UnPackOp::getCanonicalizationPatterns(uint64_t *a1)
{
  __int16 v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t result;
  _QWORD *v6;
  _QWORD *v7;
  __int16 v8;
  _QWORD *v9;

  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  v2 = v8;
  v3 = *a1;
  v4 = (_QWORD *)operator new();
  result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"tensor.unpack", 13, v2, v3, 0, 0);
  *v4 = &off_24C05E280;
  v4[12] = mlir::tensor::UnPackOp::canonicalize;
  v9 = v4;
  v6 = (_QWORD *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    v9 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::tensor::UnPackOp::parse(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  mlir::IndexType **v17;
  mlir::MLIRContext *v18;
  uint64_t v19;
  _QWORD *v20;
  _BYTE *v21;
  uint64_t v22;
  uint64_t IndexType;
  _QWORD v25[4];
  __int16 v26;
  uint64_t v27;
  _QWORD v28[2];
  _QWORD v29[2];
  uint64_t v30[2];
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34[2];
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  __int16 v38;
  uint64_t __src;
  uint64_t v40;
  _QWORD v41[4];
  _BYTE *v42;
  uint64_t v43;
  _BYTE v44[128];
  _QWORD v45[5];

  v45[4] = *MEMORY[0x24BDAC8D0];
  memset(v45, 0, 24);
  v34[0] = (uint64_t)v45;
  v34[1] = 1;
  v32 = 0;
  v33 = 0;
  v42 = v44;
  v43 = 0x400000000;
  v30[1] = 1;
  v31 = 0;
  memset(v41, 0, 24);
  v29[1] = 1;
  v30[0] = (uint64_t)v41;
  __src = 0;
  v40 = 0;
  v28[1] = 1;
  v29[0] = &v40;
  v28[0] = &__src;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v45, 1))
    goto LABEL_33;
  if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "outer_dims_perm", 15))
  {
    if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1)
      || !mlir::AsmParser::parseCustomAttributeWithFallback<mlir::detail::DenseArrayAttrImpl<long long>>(a1, &v33, 0))
    {
      goto LABEL_33;
    }
    if (v33)
    {
      v5 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::UnPackOpGenericAdaptorBase::Properties>(a2);
      *(_QWORD *)(v5 + 8) = v33;
    }
  }
  v38 = 257;
  if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 368))(a1, "inner_dims_pos", 14, &v35)&& (*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1)&& mlir::AsmParser::parseCustomAttributeWithFallback<mlir::detail::DenseArrayAttrImpl<long long>>(a1, &v32, 0))
  {
    if (v32)
    {
      v6 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::UnPackOpGenericAdaptorBase::Properties>(a2);
      *v6 = v32;
    }
    v38 = 257;
    if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 368))(a1, "inner_tiles", 11, &v35))
    {
      if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1))
      {
        (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
        v35 = 0;
        if (mlir::parseDynamicIndexList(a1, (uint64_t)&v42, &v31, &v35, 0, 2))
        {
          v7 = mlir::OperationState::getOrAddProperties<mlir::tensor::detail::UnPackOpGenericAdaptorBase::Properties>(a2);
          *(_QWORD *)(v7 + 16) = v31;
          v38 = 257;
          if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 368))(a1, "into", 4, &v35))
          {
            v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
            if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v41, 1))
            {
              v25[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
              if ((*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
              {
                v9 = a2[1];
                v35 = a1;
                v36 = v25;
                v37 = a2;
                if (mlir::tensor::PackOp::verifyInherentAttrs(v9, (uint64_t)(a2 + 14), (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::UnPackOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v35))
                {
                  if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
                  {
                    v35 = 0;
                    if (mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, &v35))
                    {
                      v40 = v35;
                      if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1))
                      {
                        v35 = 0;
                        if (mlir::AsmParser::parseType<mlir::RankedTensorType>(a1, &v35))
                        {
                          v10 = v35;
                          __src = v35;
                          v27 = v35;
                          if (*(_UNKNOWN **)(*(_QWORD *)v35 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
                          {
                            v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
                            v26 = 257;
                            (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(&v35, a1, v11, v25);
                            v12 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)&v35, "'dest' must be ranked tensor of any type values, but got ");
                            v13 = mlir::InFlightDiagnostic::append<mlir::Type &>(v12, &v27);
                            v14 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v13);
                            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v35);
                            v15 = v42;
                            if (v42 == v44)
                              return v14;
                            goto LABEL_35;
                          }
                          v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v35 + 8);
                          v35 = v10;
                          v36 = (_QWORD *)v16;
                          mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v35);
                          v17 = (mlir::IndexType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
                          IndexType = mlir::Builder::getIndexType(v17, v18);
                          mlir::OperationState::addTypes((uint64_t)a2, &__src, 1);
                          v19 = v4;
                          v20 = a2 + 2;
                          if (mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v34, v29, v19, (uint64_t)(a2 + 2)))
                          {
                            if (mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v30, v28, v8, (uint64_t)(a2 + 2)))
                            {
                              if (!(_DWORD)v43)
                              {
                                v14 = 1;
                                v15 = v42;
                                if (v42 == v44)
                                  return v14;
                                goto LABEL_35;
                              }
                              v21 = v42;
                              v22 = 32 * v43;
                              v14 = 1;
                              while ((*(unsigned __int8 (**)(uint64_t, _BYTE *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 696))(a1, v21, IndexType, v20))
                              {
                                v21 += 32;
                                v22 -= 32;
                                if (!v22)
                                  goto LABEL_34;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_33:
  v14 = 0;
LABEL_34:
  v15 = v42;
  if (v42 != v44)
LABEL_35:
    free(v15);
  return v14;
}

void mlir::tensor::UnPackOp::print(mlir::tensor::UnPackOp *this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unint64_t v6;
  llvm::raw_ostream *v7;
  _BYTE *v8;
  llvm::raw_ostream *v9;
  void *v10;
  llvm::raw_ostream *v11;
  _BYTE *v12;
  llvm::raw_ostream *v13;
  _BYTE *v14;
  llvm::raw_ostream *v15;
  _BYTE *v16;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  llvm::raw_ostream *v20;
  _BYTE *v21;
  llvm::raw_ostream *v22;
  void *v23;
  llvm::raw_ostream *v24;
  _BYTE *v25;
  llvm::raw_ostream *v26;
  _BYTE *v27;
  llvm::raw_ostream *v28;
  _BYTE *v29;
  _QWORD *v30;
  uint64_t v31;
  llvm::raw_ostream *v32;
  _BYTE *v33;
  llvm::raw_ostream *v34;
  uint64_t v35;
  llvm::raw_ostream *v36;
  _BYTE *v37;
  llvm::raw_ostream *v38;
  _BYTE *v39;
  llvm::raw_ostream *v40;
  _BYTE *v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  llvm::raw_ostream *v51;
  _BYTE *v52;
  llvm::raw_ostream *v53;
  _DWORD *v54;
  llvm::raw_ostream *v55;
  _BYTE *v56;
  _QWORD *v57;
  unint64_t v58;
  uint64_t v59;
  mlir::Operation *v60;
  mlir::ArrayAttr *p_Context;
  unsigned int v62;
  _QWORD *v63;
  uint64_t Value;
  uint64_t v65;
  llvm::raw_ostream *v66;
  _BYTE *v67;
  llvm::raw_ostream *v68;
  _BYTE *v69;
  llvm::raw_ostream *v70;
  _BYTE *v71;
  llvm::raw_ostream *v72;
  _BYTE *v73;
  llvm::raw_ostream *v74;
  _WORD *v75;
  llvm::raw_ostream *v76;
  _BYTE *v77;
  mlir::MLIRContext *Context;
  void *v79;
  uint64_t v80;
  _QWORD v81[4];
  unint64_t v82[3];

  v82[2] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 24));
  v6 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v6 = 0;
  if (*(_QWORD *)(v6 + 8))
  {
    v7 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v8 = (_BYTE *)*((_QWORD *)v7 + 4);
    if ((unint64_t)v8 >= *((_QWORD *)v7 + 3))
    {
      llvm::raw_ostream::write(v7, 32);
    }
    else
    {
      *((_QWORD *)v7 + 4) = v8 + 1;
      *v8 = 32;
    }
    v9 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v10 = (void *)*((_QWORD *)v9 + 4);
    if (*((_QWORD *)v9 + 3) - (_QWORD)v10 > 0xEuLL)
    {
      qmemcpy(v10, "outer_dims_perm", 15);
      *((_QWORD *)v9 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(v9, "outer_dims_perm", 0xFuLL);
    }
    v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v12 = (_BYTE *)*((_QWORD *)v11 + 4);
    if ((unint64_t)v12 >= *((_QWORD *)v11 + 3))
    {
      llvm::raw_ostream::write(v11, 32);
    }
    else
    {
      *((_QWORD *)v11 + 4) = v12 + 1;
      *v12 = 32;
    }
    v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v14 = (_BYTE *)*((_QWORD *)v13 + 4);
    if (*((_BYTE **)v13 + 3) == v14)
    {
      llvm::raw_ostream::write(v13, "=", 1uLL);
    }
    else
    {
      *v14 = 61;
      ++*((_QWORD *)v13 + 4);
    }
    v15 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v16 = (_BYTE *)*((_QWORD *)v15 + 4);
    if ((unint64_t)v16 >= *((_QWORD *)v15 + 3))
    {
      llvm::raw_ostream::write(v15, 32);
    }
    else
    {
      *((_QWORD *)v15 + 4) = v16 + 1;
      *v16 = 32;
    }
    v17 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
    if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
      v17 = 0;
    v79 = *(void **)(v17 + 8);
    if (!(*(unsigned __int8 (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 104))(a2))
    {
      v18 = (_QWORD *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
      v19 = (*(uint64_t (**)(_QWORD *))(*v18 + 80))(v18) + v18[4] - v18[2];
      mlir::detail::DenseArrayAttrImpl<long long>::print((llvm::raw_ostream *)&v79, (uint64_t)a2);
      if (v19 == (*(uint64_t (**)(_QWORD *))(*v18 + 80))(v18) + v18[4] - v18[2])
        (*(void (**)(mlir::OpAsmPrinter *, void *))(*(_QWORD *)a2 + 40))(a2, v79);
    }
  }
  v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v21 = (_BYTE *)*((_QWORD *)v20 + 4);
  if ((unint64_t)v21 >= *((_QWORD *)v20 + 3))
  {
    llvm::raw_ostream::write(v20, 32);
  }
  else
  {
    *((_QWORD *)v20 + 4) = v21 + 1;
    *v21 = 32;
  }
  v22 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v23 = (void *)*((_QWORD *)v22 + 4);
  if (*((_QWORD *)v22 + 3) - (_QWORD)v23 > 0xDuLL)
  {
    qmemcpy(v23, "inner_dims_pos", 14);
    *((_QWORD *)v22 + 4) += 14;
  }
  else
  {
    llvm::raw_ostream::write(v22, "inner_dims_pos", 0xEuLL);
  }
  v24 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v25 = (_BYTE *)*((_QWORD *)v24 + 4);
  if ((unint64_t)v25 >= *((_QWORD *)v24 + 3))
  {
    llvm::raw_ostream::write(v24, 32);
  }
  else
  {
    *((_QWORD *)v24 + 4) = v25 + 1;
    *v25 = 32;
  }
  v26 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v27 = (_BYTE *)*((_QWORD *)v26 + 4);
  if (*((_BYTE **)v26 + 3) == v27)
  {
    llvm::raw_ostream::write(v26, "=", 1uLL);
  }
  else
  {
    *v27 = 61;
    ++*((_QWORD *)v26 + 4);
  }
  v28 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v29 = (_BYTE *)*((_QWORD *)v28 + 4);
  if ((unint64_t)v29 >= *((_QWORD *)v28 + 3))
  {
    llvm::raw_ostream::write(v28, 32);
  }
  else
  {
    *((_QWORD *)v28 + 4) = v29 + 1;
    *v29 = 32;
  }
  v79 = *(void **)(*(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64);
  if (!(*(unsigned __int8 (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 104))(a2))
  {
    v30 = (_QWORD *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v31 = (*(uint64_t (**)(_QWORD *))(*v30 + 80))(v30) + v30[4] - v30[2];
    mlir::detail::DenseArrayAttrImpl<long long>::print((llvm::raw_ostream *)&v79, (uint64_t)a2);
    if (v31 == (*(uint64_t (**)(_QWORD *))(*v30 + 80))(v30) + v30[4] - v30[2])
      (*(void (**)(mlir::OpAsmPrinter *, void *))(*(_QWORD *)a2 + 40))(a2, v79);
  }
  v32 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v33 = (_BYTE *)*((_QWORD *)v32 + 4);
  if ((unint64_t)v33 >= *((_QWORD *)v32 + 3))
  {
    llvm::raw_ostream::write(v32, 32);
  }
  else
  {
    *((_QWORD *)v32 + 4) = v33 + 1;
    *v33 = 32;
  }
  v34 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v35 = *((_QWORD *)v34 + 4);
  if ((unint64_t)(*((_QWORD *)v34 + 3) - v35) > 0xA)
  {
    *(_DWORD *)(v35 + 7) = 1936026729;
    *(_QWORD *)v35 = *(_QWORD *)"inner_tiles";
    *((_QWORD *)v34 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v34, "inner_tiles", 0xBuLL);
  }
  v36 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v37 = (_BYTE *)*((_QWORD *)v36 + 4);
  if ((unint64_t)v37 >= *((_QWORD *)v36 + 3))
  {
    llvm::raw_ostream::write(v36, 32);
  }
  else
  {
    *((_QWORD *)v36 + 4) = v37 + 1;
    *v37 = 32;
  }
  v38 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v39 = (_BYTE *)*((_QWORD *)v38 + 4);
  if (*((_BYTE **)v38 + 3) == v39)
  {
    llvm::raw_ostream::write(v38, "=", 1uLL);
  }
  else
  {
    *v39 = 61;
    ++*((_QWORD *)v38 + 4);
  }
  v40 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v41 = (_BYTE *)*((_QWORD *)v40 + 4);
  if ((unint64_t)v41 >= *((_QWORD *)v40 + 3))
  {
    llvm::raw_ostream::write(v40, 32);
  }
  else
  {
    *((_QWORD *)v40 + 4) = v41 + 1;
    *v41 = 32;
  }
  v42 = *(_QWORD *)this;
  v43 = *(unsigned int *)(*(_QWORD *)this + 44);
  if ((v43 & 0x800000) != 0)
  {
    v44 = *(_QWORD *)(v42 + 72);
    v45 = *(unsigned int *)(v42 + 68) - 2;
  }
  else
  {
    v44 = 0;
    v45 = -2;
  }
  v46 = v44 + 64;
  if (HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v47 = v42 + 16 * ((v43 >> 23) & 1) + 64;
  else
    v47 = 0;
  v79 = *(void **)(v47 + 16);
  v48 = (unint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v79);
  v50 = v49;
  mlir::ValueRange::ValueRange(v82, 0, 0);
  mlir::printDynamicIndexList((uint64_t)a2, v42, v46, v45, v48, v50, v82[0], v82[1], 0, 0, 2);
  v51 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v52 = (_BYTE *)*((_QWORD *)v51 + 4);
  if ((unint64_t)v52 >= *((_QWORD *)v51 + 3))
  {
    llvm::raw_ostream::write(v51, 32);
  }
  else
  {
    *((_QWORD *)v51 + 4) = v52 + 1;
    *v52 = 32;
  }
  v53 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v54 = (_DWORD *)*((_QWORD *)v53 + 4);
  if (*((_QWORD *)v53 + 3) - (_QWORD)v54 > 3uLL)
  {
    *v54 = 1869901417;
    *((_QWORD *)v53 + 4) += 4;
  }
  else
  {
    llvm::raw_ostream::write(v53, "into", 4uLL);
  }
  v55 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v56 = (_BYTE *)*((_QWORD *)v55 + 4);
  if ((unint64_t)v56 >= *((_QWORD *)v55 + 3))
  {
    llvm::raw_ostream::write(v55, 32);
  }
  else
  {
    *((_QWORD *)v55 + 4) = v56 + 1;
    *v56 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 56));
  v79 = v81;
  v81[0] = "outer_dims_perm";
  v81[1] = 15;
  v81[2] = "inner_dims_pos";
  v81[3] = 14;
  v80 = 0x200000002;
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v79, v81, 3uLL, 16);
  v57 = (char *)v79 + 16 * v80;
  *v57 = "static_inner_tiles";
  v57[1] = 18;
  LODWORD(v80) = v80 + 1;
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)this + 24));
  v58 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v58 = 0;
  v59 = *(_QWORD *)(v58 + 8);
  if (v59 && v59 == mlir::Builder::getDenseI64ArrayAttr(&Context, 0, 0))
  {
    v62 = v80;
    if (v80 >= HIDWORD(v80))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v79, v81, v80 + 1, 16);
      v62 = v80;
    }
    v63 = (char *)v79 + 16 * v62;
    *v63 = "outer_dims_perm";
    v63[1] = 15;
    LODWORD(v80) = v80 + 1;
    v60 = *(mlir::Operation **)this;
    if (!*(_BYTE *)(*(_QWORD *)this + 47))
      goto LABEL_79;
  }
  else
  {
    v60 = *(mlir::Operation **)this;
    if (!*(_BYTE *)(*(_QWORD *)this + 47))
    {
LABEL_79:
      p_Context = (mlir::Operation *)((char *)v60 + 56);
      goto LABEL_84;
    }
  }
  Context = (mlir::MLIRContext *)mlir::Operation::getAttrDictionary(v60);
  p_Context = (mlir::ArrayAttr *)&Context;
LABEL_84:
  Value = mlir::ArrayAttr::getValue(p_Context);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v65, v79, v80);
  v66 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v67 = (_BYTE *)*((_QWORD *)v66 + 4);
  if ((unint64_t)v67 >= *((_QWORD *)v66 + 3))
  {
    llvm::raw_ostream::write(v66, 32);
  }
  else
  {
    *((_QWORD *)v66 + 4) = v67 + 1;
    *v67 = 32;
  }
  v68 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v69 = (_BYTE *)*((_QWORD *)v68 + 4);
  if (*((_BYTE **)v68 + 3) == v69)
  {
    llvm::raw_ostream::write(v68, ":", 1uLL);
  }
  else
  {
    *v69 = 58;
    ++*((_QWORD *)v68 + 4);
  }
  v70 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v71 = (_BYTE *)*((_QWORD *)v70 + 4);
  if ((unint64_t)v71 >= *((_QWORD *)v70 + 3))
  {
    llvm::raw_ostream::write(v70, 32);
  }
  else
  {
    *((_QWORD *)v70 + 4) = v71 + 1;
    *v71 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v72 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v73 = (_BYTE *)*((_QWORD *)v72 + 4);
  if ((unint64_t)v73 >= *((_QWORD *)v72 + 3))
  {
    llvm::raw_ostream::write(v72, 32);
  }
  else
  {
    *((_QWORD *)v72 + 4) = v73 + 1;
    *v73 = 32;
  }
  v74 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v75 = (_WORD *)*((_QWORD *)v74 + 4);
  if (*((_QWORD *)v74 + 3) - (_QWORD)v75 > 1uLL)
  {
    *v75 = 15917;
    *((_QWORD *)v74 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v74, "->", 2uLL);
  }
  v76 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v77 = (_BYTE *)*((_QWORD *)v76 + 4);
  if ((unint64_t)v77 >= *((_QWORD *)v76 + 3))
  {
    llvm::raw_ostream::write(v76, 32);
  }
  else
  {
    *((_QWORD *)v76 + 4) = v77 + 1;
    *v77 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v79 != v81)
    free(v79);
}

BOOL mlir::tensor::YieldOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v7[2];
  uint64_t v8[2];
  uint64_t v9;
  _QWORD v10[5];

  v10[4] = *MEMORY[0x24BDAC8D0];
  memset(v10, 0, 24);
  v8[0] = (uint64_t)v10;
  v8[1] = 1;
  v9 = 0;
  v7[0] = &v9;
  v7[1] = 1;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v10, 1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v6 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 504))(a1, &v6))
    return 0;
  v9 = v6;
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v8, v7, v4, a2 + 16) != 0;
}

BOOL llvm::function_ref<BOOL ()(mlir::OpFoldResult,mlir::OpFoldResult)>::callback_fn<foldExtractAfterInsertSlice(mlir::tensor::ExtractSliceOp)::$_0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a2 == a3;
}

BOOL llvm::function_ref<BOOL ()(mlir::OpFoldResult,mlir::OpFoldResult)>::callback_fn<foldInsertAfterInsertSlice(mlir::tensor::InsertSliceOp)::$_0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a2 == a3;
}

BOOL llvm::function_ref<BOOL ()(mlir::OpFoldResult,mlir::OpFoldResult)>::callback_fn<foldInsertAfterExtractSlice(mlir::tensor::InsertSliceOp)::$_0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a2 == a3;
}

uint64_t mlir::OpInterface<mlir::ParallelCombiningOpInterface,mlir::detail::ParallelCombiningOpInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  BOOL v3;
  uint64_t v4;
  unint64_t v6;
  uint64_t result;
  unsigned __int8 v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  const char *v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  unint64_t v31;

  v1 = *(_QWORD *)(a1 + 48);
  v2 = *(void **)(v1 + 16);
  v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
    v4 = 0;
  else
    v4 = *(_QWORD *)(a1 + 48);
  if (v3)
  {
    v30 = *(const char **)(v1 + 8);
    result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v30);
    if (result)
    {
      if ((v8 & 1) == 0)
      {
        v12 = result;
        result = v12;
        if (v13)
        {
          v30 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ParallelCombiningOpInterface]";
          v31 = 84;
          v14 = llvm::StringRef::find((uint64_t *)&v30, "DesiredTypeName = ", 0x12uLL, 0);
          if (v31 >= v14)
            v15 = v14;
          else
            v15 = v31;
          v16 = &v30[v15];
          v17 = v31 - v15;
          if (v31 - v15 >= 0x12)
            v18 = 18;
          else
            v18 = v31 - v15;
          v19 = v17 - v18;
          if (v19 >= v19 - 1)
            v20 = v19 - 1;
          else
            v20 = v19;
          mlir::detail::TypeIDResolver<mlir::ParallelCombiningOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v16[v18], v20);
          result = v12;
        }
      }
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)result + 104))(result, mlir::detail::TypeIDResolver<mlir::ParallelCombiningOpInterface,void>::resolveTypeID(void)::id, v1);
    }
  }
  else
  {
    v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    result = mlir::detail::InterfaceMap::lookup<mlir::ParallelCombiningOpInterface>(v6 + 32);
    if (!result)
    {
      v9 = *(_QWORD *)(v6 + 24);
      v10 = *(_QWORD *)(a1 + 48);
      if ((v11 & 1) == 0)
      {
        v29 = *(_QWORD *)(a1 + 48);
        v10 = v29;
        if (v21)
        {
          v30 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ParallelCombiningOpInterface]";
          v31 = 84;
          v22 = llvm::StringRef::find((uint64_t *)&v30, "DesiredTypeName = ", 0x12uLL, 0);
          if (v31 >= v22)
            v23 = v22;
          else
            v23 = v31;
          v24 = &v30[v23];
          v25 = v31 - v23;
          if (v31 - v23 >= 0x12)
            v26 = 18;
          else
            v26 = v31 - v23;
          v27 = v25 - v26;
          if (v27 >= v27 - 1)
            v28 = v27 - 1;
          else
            v28 = v27;
          mlir::detail::TypeIDResolver<mlir::ParallelCombiningOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v24[v26], v28);
          v10 = v29;
        }
      }
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 104))(v9, mlir::detail::TypeIDResolver<mlir::ParallelCombiningOpInterface,void>::resolveTypeID(void)::id, v10);
    }
  }
  return result;
}

uint64_t mlir::detail::InterfaceMap::lookup<mlir::ParallelCombiningOpInterface>(uint64_t a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  _QWORD *v9;
  unint64_t v10;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  unint64_t v23;

  v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v21 = a1;
    v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v13 = v12;
    a1 = v21;
    if (v13)
    {
      v22 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ParallelCombiningOpInterface]";
      v23 = 84;
      v14 = llvm::StringRef::find((uint64_t *)&v22, "DesiredTypeName = ", 0x12uLL, 0);
      if (v23 >= v14)
        v15 = v14;
      else
        v15 = v23;
      v16 = &v22[v15];
      v17 = v23 - v15;
      if (v23 - v15 >= 0x12)
        v18 = 18;
      else
        v18 = v23 - v15;
      v19 = v17 - v18;
      if (v19 >= v19 - 1)
        v20 = v19 - 1;
      else
        v20 = v19;
      mlir::detail::TypeIDResolver<mlir::ParallelCombiningOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v16[v18], v20);
      v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      a1 = v21;
    }
  }
  v3 = *(unsigned int *)(a1 + 8);
  if (!(_DWORD)v3)
    return 0;
  v4 = v2[140];
  v5 = *(_QWORD **)a1;
  v6 = *(_QWORD *)a1 + 16 * v3;
  do
  {
    v7 = v3 >> 1;
    v8 = &v5[2 * (v3 >> 1)];
    v10 = *v8;
    v9 = v8 + 2;
    v3 += ~(v3 >> 1);
    if (v10 < v4)
      v5 = v9;
    else
      v3 = v7;
  }
  while (v3);
  if (v5 != (_QWORD *)v6 && *v5 == v4)
    return v5[1];
  else
    return 0;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::__mlir_ods_local_attr_constraint_TensorOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void mlir::OpBuilder::createOrFold<mlir::tensor::DimOp,mlir::Value &,long long &>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, mlir::MLIRContext **a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  uint64_t v13;
  ZinIrHalH13g *v14;
  const mlir::OperationState *v15;
  ZinIrHalH13g *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  mlir::MLIRContext *v25[4];
  __int16 v26;
  uint64_t v27[39];

  v27[38] = *MEMORY[0x24BDAC8D0];
  v22 = a3;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.dim", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    v26 = 1283;
    v25[2] = (mlir::MLIRContext *)"tensor.dim";
    v25[3] = (mlir::MLIRContext *)10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+((uint64_t *)v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v27, a3, v11);
  v13 = *a4;
  v25[0] = *a5;
  v14 = mlir::OpBuilder::create<mlir::arith::ConstantIndexOp,long long>((mlir::IndexType **)a1, v27[0], v25);
  mlir::tensor::DimOp::build((mlir::IndexType **)a1, (uint64_t)v27, v13, (uint64_t)v14 - 16);
  v16 = (ZinIrHalH13g *)mlir::Operation::create((mlir::Operation *)v27, v15);
  v17 = *(_QWORD *)(a1 + 16);
  if (v17)
  {
    v18 = *(uint64_t **)(a1 + 24);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v17 + 32, (uint64_t)v16);
    ZinIrHalH13g::~ZinIrHalH13g(v16);
    v19 = *v18;
    *v20 = *v18;
    v20[1] = (uint64_t)v18;
    *(_QWORD *)(v19 + 8) = v20;
    *v18 = (uint64_t)v20;
    ZinIrHalH13g::~ZinIrHalH13g(v16);
  }
  if (mlir::OpBuilder::tryFold((_QWORD *)a1, (uint64_t)v16, a2))
  {
    mlir::Operation::erase(v16);
  }
  else
  {
    v21 = *(_QWORD *)(a1 + 8);
    if (v21)
      (*(void (**)(uint64_t, ZinIrHalH13g *))(*(_QWORD *)v21 + 16))(v21, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
}

uint64_t mlir::OpInterface<mlir::DestinationStyleOpInterface,mlir::detail::DestinationStyleOpInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  BOOL v3;
  uint64_t v4;
  unint64_t v6;
  uint64_t result;
  unsigned __int8 v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  const char *v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  unint64_t v31;

  v1 = *(_QWORD *)(a1 + 48);
  v2 = *(void **)(v1 + 16);
  v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
    v4 = 0;
  else
    v4 = *(_QWORD *)(a1 + 48);
  if (v3)
  {
    v30 = *(const char **)(v1 + 8);
    result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v30);
    if (result)
    {
      if ((v8 & 1) == 0)
      {
        v12 = result;
        result = v12;
        if (v13)
        {
          v30 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DestinationStyleOpInterface]";
          v31 = 83;
          v14 = llvm::StringRef::find((uint64_t *)&v30, "DesiredTypeName = ", 0x12uLL, 0);
          if (v31 >= v14)
            v15 = v14;
          else
            v15 = v31;
          v16 = &v30[v15];
          v17 = v31 - v15;
          if (v31 - v15 >= 0x12)
            v18 = 18;
          else
            v18 = v31 - v15;
          v19 = v17 - v18;
          if (v19 >= v19 - 1)
            v20 = v19 - 1;
          else
            v20 = v19;
          mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v16[v18], v20);
          result = v12;
        }
      }
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)result + 104))(result, mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface,void>::resolveTypeID(void)::id, v1);
    }
  }
  else
  {
    v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    result = mlir::detail::InterfaceMap::lookup<mlir::DestinationStyleOpInterface>(v6 + 32);
    if (!result)
    {
      v9 = *(_QWORD *)(v6 + 24);
      v10 = *(_QWORD *)(a1 + 48);
      if ((v11 & 1) == 0)
      {
        v29 = *(_QWORD *)(a1 + 48);
        v10 = v29;
        if (v21)
        {
          v30 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DestinationStyleOpInterface]";
          v31 = 83;
          v22 = llvm::StringRef::find((uint64_t *)&v30, "DesiredTypeName = ", 0x12uLL, 0);
          if (v31 >= v22)
            v23 = v22;
          else
            v23 = v31;
          v24 = &v30[v23];
          v25 = v31 - v23;
          if (v31 - v23 >= 0x12)
            v26 = 18;
          else
            v26 = v31 - v23;
          v27 = v25 - v26;
          if (v27 >= v27 - 1)
            v28 = v27 - 1;
          else
            v28 = v27;
          mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v24[v26], v28);
          v10 = v29;
        }
      }
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 104))(v9, mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface,void>::resolveTypeID(void)::id, v10);
    }
  }
  return result;
}

uint64_t mlir::detail::InterfaceMap::lookup<mlir::DestinationStyleOpInterface>(uint64_t a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  _QWORD *v9;
  unint64_t v10;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  unint64_t v23;

  v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v21 = a1;
    v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v13 = v12;
    a1 = v21;
    if (v13)
    {
      v22 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DestinationStyleOpInterface]";
      v23 = 83;
      v14 = llvm::StringRef::find((uint64_t *)&v22, "DesiredTypeName = ", 0x12uLL, 0);
      if (v23 >= v14)
        v15 = v14;
      else
        v15 = v23;
      v16 = &v22[v15];
      v17 = v23 - v15;
      if (v23 - v15 >= 0x12)
        v18 = 18;
      else
        v18 = v23 - v15;
      v19 = v17 - v18;
      if (v19 >= v19 - 1)
        v20 = v19 - 1;
      else
        v20 = v19;
      mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v16[v18], v20);
      v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      a1 = v21;
    }
  }
  v3 = *(unsigned int *)(a1 + 8);
  if (!(_DWORD)v3)
    return 0;
  v4 = v2[124];
  v5 = *(_QWORD **)a1;
  v6 = *(_QWORD *)a1 + 16 * v3;
  do
  {
    v7 = v3 >> 1;
    v8 = &v5[2 * (v3 >> 1)];
    v10 = *v8;
    v9 = v8 + 2;
    v3 += ~(v3 >> 1);
    if (v10 < v4)
      v5 = v9;
    else
      v3 = v7;
  }
  while (v3);
  if (v5 != (_QWORD *)v6 && *v5 == v4)
    return v5[1];
  else
    return 0;
}

void `anonymous namespace'::ChainedTensorBitcast::~ChainedTensorBitcast(_anonymous_namespace_::ChainedTensorBitcast *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::BitcastOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::BitcastOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::BitcastOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t `anonymous namespace'::ChainedTensorBitcast::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  unint64_t v6;
  ZinIrHalH13g *v7;
  uint64_t v8;
  unint64_t v9;

  v9 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v9);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::BitcastOp,void>::id)
    {
      v6 = *(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
      v8 = *(_QWORD *)(*(_QWORD *)(result + 72) + 24);
      v9 = v6;
      v7 = mlir::OpBuilder::create<mlir::tensor::BitcastOp,mlir::TensorType &,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v9, &v8);
      (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, a2, v7);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::BitcastOp,mlir::TensorType &,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  unsigned int v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[8];
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  _QWORD v25[29];

  v25[28] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.bitcast", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"tensor.bitcast";
    v19[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  v11 = *a3;
  v19[0] = *a4;
  mlir::OperationState::addOperands((uint64_t)v21, (uint64_t)v19, 1);
  v12 = v23;
  if (v23 >= v24)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v22, v25, v23 + 1, 8);
    v12 = v23;
  }
  *(_QWORD *)(v22 + 8 * v12) = v11;
  ++v23;
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::BitcastOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void `anonymous namespace'::ChainedTensorCast::~ChainedTensorCast(_anonymous_namespace_::ChainedTensorCast *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::CastOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::CastOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::CastOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t `anonymous namespace'::ChainedTensorCast::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  ZinIrHalH13g *v11;
  uint64_t v12;
  unint64_t v13;

  v13 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v13);
  if (result)
  {
    v6 = result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id)
    {
      v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
      v8 = *(_QWORD *)(result - 8) & 0xFFFFFFFFFFFFFFF8;
      v13 = *(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
      v9 = v13;
      v10 = joinShapes(v7, v8);
      result = joinShapes(v10, v9);
      if (result)
      {
        if (result == joinShapes(v7, v9))
        {
          v12 = *(_QWORD *)(*(_QWORD *)(v6 + 72) + 24);
          v11 = mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::TensorType &,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v13, &v12);
          (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, a2, v11);
          return 1;
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t joinShapes(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int64_t v3;
  int64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t Value;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unsigned int v14;
  void *v15;
  uint64_t v16;
  uint64_t ElementType;
  void *v18;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  _QWORD v24[5];

  v2 = a2;
  v24[4] = *MEMORY[0x24BDAC8D0];
  v20 = a2;
  v21 = a1;
  if (!mlir::TensorType::hasRank((mlir::TensorType *)&v21))
    return v2;
  if (!mlir::TensorType::hasRank((mlir::TensorType *)&v20))
    return v21;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v21);
  v4 = v3;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v20);
  if (v4 != v5)
    return 0;
  v22 = v24;
  v23 = 0x400000000;
  if ((unint64_t)v4 >= 5)
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v22, v24, v4, 8);
  if (v4 < 1)
  {
    v14 = v23;
LABEL_21:
    v15 = v22;
    v16 = v14;
    ElementType = mlir::TensorType::getElementType((mlir::TensorType *)&v21);
    v2 = mlir::RankedTensorType::get((uint64_t)v15, v16, ElementType, 0);
    v18 = v22;
    if (v22 != v24)
      goto LABEL_22;
    return v2;
  }
  v6 = 0;
  while (1)
  {
    v7 = 8 * v6;
    v8 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v21) + v7);
    v9 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v20) + v7);
    if (v8 == 0x8000000000000000)
      goto LABEL_13;
    Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v21);
    if (v9 != 0x8000000000000000)
      break;
    v12 = v23;
    v13 = HIDWORD(v23);
    v9 = *(_QWORD *)(Value + 8 * v6);
LABEL_14:
    if (v12 >= v13)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v22, v24, v12 + 1, 8);
      v12 = v23;
    }
    *((_QWORD *)v22 + v12) = v9;
    v14 = v23 + 1;
    LODWORD(v23) = v23 + 1;
    if (v4 == ++v6)
      goto LABEL_21;
  }
  v11 = *(_QWORD *)(Value + 8 * v6);
  if (v11 == *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v20) + 8 * v6))
  {
    v9 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v21) + 8 * v6);
LABEL_13:
    v12 = v23;
    v13 = HIDWORD(v23);
    goto LABEL_14;
  }
  v2 = 0;
  v18 = v22;
  if (v22 == v24)
    return v2;
LABEL_22:
  free(v18);
  return v2;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::TensorType &,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  unsigned int v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[8];
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  _QWORD v25[29];

  v25[28] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.cast", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"tensor.cast";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  v11 = *a3;
  v19[0] = *a4;
  mlir::OperationState::addOperands((uint64_t)v21, (uint64_t)v19, 1);
  v12 = v23;
  if (v23 >= v24)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v22, v25, v23 + 1, 8);
    v12 = v23;
  }
  *(_QWORD *)(v22 + 8 * v12) = v11;
  ++v23;
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void `anonymous namespace'::TensorCastExtractSlice::~TensorCastExtractSlice(_anonymous_namespace_::TensorCastExtractSlice *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::TensorCastExtractSlice::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::IndexType **a3)
{
  uint64_t DefiningOp;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  const void *Value;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  uint64_t result;
  unint64_t v15;
  char *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t i;
  _DWORD *v25;
  int v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  int v30;
  unsigned int v31;
  mlir::MLIRContext *v32;
  uint64_t IndexAttr;
  ZinIrHalH13g *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  void *v38[2];
  uint64_t v39;
  void *v40[2];
  uint64_t v41;
  char v42[8];
  llvm *v43;
  unsigned int v44;
  char v45;
  _QWORD *v46;
  unsigned int v47;
  _QWORD v48[6];

  v48[4] = *MEMORY[0x24BDAC8D0];
  v46 = *(_QWORD **)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v46);
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::ExtractSliceOp,void>::id)
      v6 = DefiningOp;
    else
      v6 = 0;
  }
  else
  {
    v6 = 0;
  }
  v37 = v6;
  v7 = *(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(_QWORD *)v7 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v8 = *(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
  else
    v8 = 0;
  v36 = v8;
  if (!v8
    || !a2
    || !v6
    || !mlir::tensor::preservesStaticInformation(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, v7))
  {
    return 0;
  }
  Value = (const void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v36);
  v11 = v10;
  v46 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v12 = (const void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v46);
  if (v11 != v13 || (result = memcmp(Value, v12, 8 * v11), (_DWORD)result))
  {
    mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedSizes((mlir::memref::ReinterpretCastOp *)&v37, (uint64_t)&v46);
    v15 = v37 + 16 * (((unint64_t)*(unsigned int *)(v37 + 44) >> 23) & 1) + 64;
    if (!HIBYTE(*(_DWORD *)(v37 + 44)))
      v15 = 0;
    v40[0] = *(void **)(v15 + 8);
    v16 = (char *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v40);
    v18 = v17;
    if (*(_DWORD *)(v37 + 36))
      v19 = v37 - 16;
    else
      v19 = 0;
    v40[0] = (void *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v19, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    v20 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v40);
    mlir::computeRankReductionMask(v16, v18, v20, v21, (uint64_t)v42);
    v22 = v47;
    if (v47)
    {
      v23 = 0;
      for (i = 0; i != v22; ++i)
      {
        if (!v45)
          goto LABEL_35;
        if ((v42[0] & 1) != 0)
        {
          v25 = &v43;
          v26 = 3;
          v27 = (37 * i) & 3;
          v28 = *((_DWORD *)&v43 + v27);
          if (v28 != (_DWORD)i)
            goto LABEL_31;
        }
        else
        {
          if (!v44)
            goto LABEL_35;
          v25 = v43;
          v26 = v44 - 1;
          v27 = (v44 - 1) & (37 * i);
          v28 = *((_DWORD *)v43 + v27);
          if (v28 != (_DWORD)i)
          {
LABEL_31:
            v30 = 1;
            while (v28 != -1)
            {
              v31 = v27 + v30++;
              v27 = v31 & v26;
              v28 = v25[v27];
              if (v28 == (_DWORD)i)
                goto LABEL_25;
            }
LABEL_35:
            v29 = v23 + 1;
            v32 = *(mlir::MLIRContext **)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v36) + 8 * v23);
            if (v32 != (mlir::MLIRContext *)0x8000000000000000)
            {
              IndexAttr = mlir::Builder::getIndexAttr(a3 + 1, v32);
              v46[i] = IndexAttr & 0xFFFFFFFFFFFFFFFBLL;
            }
            goto LABEL_26;
          }
        }
LABEL_25:
        v29 = v23;
LABEL_26:
        v23 = v29;
      }
    }
    v35 = *(_QWORD *)(*(_QWORD *)(v37 + 72) + 24);
    mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedOffsets((mlir::memref::ReinterpretCastOp *)&v37, (uint64_t)v40);
    mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedStrides((mlir::memref::ReinterpretCastOp *)&v37, (uint64_t)v38);
    v34 = mlir::OpBuilder::create<mlir::tensor::ExtractSliceOp,mlir::RankedTensorType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,4u>,llvm::SmallVector<mlir::OpFoldResult,4u>&,llvm::SmallVector<mlir::OpFoldResult,4u>>(a3 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v36, &v35, (uint64_t)v40, (uint64_t)&v46, (uint64_t)v38);
    (*((void (**)(mlir::IndexType **, uint64_t, ZinIrHalH13g *))*a3 + 4))(a3, a2, v34);
    if (v38[0] != &v39)
      free(v38[0]);
    if (v40[0] != &v41)
      free(v40[0]);
    if (v45 && (v42[0] & 1) == 0)
      llvm::deallocate_buffer(v43, (void *)(4 * v44));
    if (v46 != v48)
      free(v46);
    return 1;
  }
  return result;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::ExtractSliceOp,mlir::RankedTensorType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,4u>,llvm::SmallVector<mlir::OpFoldResult,4u>&,llvm::SmallVector<mlir::OpFoldResult,4u>>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t *Context;
  uint64_t v15;
  char v16;
  ZinIrHalH13g *v17;
  ZinIrHalH13g *v18;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x24BDAC8D0];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.extract_slice", (const unsigned __int8 *)0x14, Context);
  if (!v16)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"tensor.extract_slice";
    v23[3] = 20;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::tensor::ExtractSliceOp::build(a1, (uint64_t)v25, *a3, *a4, *(uint64_t **)a5, *(unsigned int *)(a5 + 8), *(uint64_t **)a6, *(unsigned int *)(a6 + 8), *(uint64_t **)a7, *(unsigned int *)(a7 + 8), 0, 0);
  v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((_QWORD *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::ExtractSliceOp,void>::id)
    v18 = v17;
  else
    v18 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

void `anonymous namespace'::DimOfCastOp::~DimOfCastOp(_anonymous_namespace_::DimOfCastOp *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::DimOfCastOp::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::IndexType **a3)
{
  uint64_t result;
  uint64_t v6;
  ZinIrHalH13g *v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v9);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id)
    {
      v6 = *(_QWORD *)(*(_QWORD *)(result + 72) + 24);
      v8 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56);
      v9 = v6;
      v7 = mlir::OpBuilder::create<mlir::tensor::DimOp,mlir::Value &,mlir::detail::TypedValue<mlir::IndexType>>(a3 + 1, *(_QWORD *)(a2 + 24), &v9, &v8);
      (*((void (**)(mlir::IndexType **, uint64_t, ZinIrHalH13g *))*a3 + 4))(a3, a2, v7);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void `anonymous namespace'::DimOfDestStyleOp::~DimOfDestStyleOp(_anonymous_namespace_::DimOfDestStyleOp *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::DimOfDestStyleOp::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17[2];
  void *v18;
  _QWORD v19[4];

  v19[3] = *MEMORY[0x24BDAC8D0];
  v16 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v16);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (!mlir::OpInterface<mlir::DestinationStyleOpInterface,mlir::detail::DestinationStyleOpInterfaceInterfaceTraits>::getInterfaceFor(DefiningOp))
    {
      v14 = 0;
      v15 = 0;
      return 0;
    }
    DefiningOp = mlir::OpInterface<mlir::DestinationStyleOpInterface,mlir::detail::DestinationStyleOpInterfaceInterfaceTraits>::getInterfaceFor(v6);
  }
  v14 = v6;
  v15 = DefiningOp;
  if (!v6)
    return 0;
  if (v16 && (*(_QWORD *)(v16 + 8) & 7) == 6)
    v7 = *(_DWORD *)(v16 + 16) + 6;
  else
    v7 = *(_QWORD *)(v16 + 8) & 7;
  mlir::DestinationStyleOpInterface::getDpsInitsMutable(v17, (mlir::DestinationStyleOpInterface *)&v14);
  v8 = mlir::MutableOperandRange::operator[](v17, v7);
  if (v18 != v19)
    free(v18);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 72))(a3, a2);
  v9 = *(uint64_t **)(a2 + 72);
  v10 = *(uint64_t **)(v8 + 24);
  v11 = (uint64_t *)v9[1];
  if (v11)
  {
    *v11 = *v9;
    if (*v9)
      *(_QWORD *)(*v9 + 8) = v9[1];
  }
  v9[3] = (uint64_t)v10;
  v9[1] = (uint64_t)v10;
  v12 = *v10;
  *v9 = *v10;
  if (v12)
    *(_QWORD *)(v12 + 8) = v9;
  *v10 = (uint64_t)v9;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 80))(a3, a2);
  return 1;
}

void `anonymous namespace'::FoldEmptyTensorWithCastOp::~FoldEmptyTensorWithCastOp(_anonymous_namespace_::FoldEmptyTensorWithCastOp *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::FoldEmptyTensorWithCastOp::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::IndexType **a3)
{
  uint64_t DefiningOp;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  mlir::MLIRContext **Value;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  mlir::MLIRContext *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  ZinIrHalH13g *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24[4];
  __int16 v25;
  uint64_t *v26;
  void *v27;
  uint64_t v28;
  _BYTE v29[48];
  void *v30;
  unsigned int v31;
  _QWORD v32[8];

  v32[6] = *MEMORY[0x24BDAC8D0];
  if (!a2)
    return 0;
  if (!mlir::tensor::preservesStaticInformation(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, *(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8))return 0;
  v30 = *(void **)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v30);
  if (!DefiningOp)
    return 0;
  v6 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
  v7 = v6 == &mlir::detail::TypeIDResolver<mlir::tensor::EmptyOp,void>::id ? DefiningOp : 0;
  v23 = v7;
  if (v6 != &mlir::detail::TypeIDResolver<mlir::tensor::EmptyOp,void>::id)
    return 0;
  v22 = *(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
  Value = (mlir::MLIRContext **)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v22);
  v12 = v11;
  mlir::tensor::EmptyOp::getMixedSizes((mlir::tensor::EmptyOp *)&v23, (uint64_t)&v30);
  v27 = v29;
  v28 = 0x600000000;
  v13 = v31;
  if (v31 >= 7)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v27, v29, v31, 8);
    v13 = v31;
  }
  if (!v12 || !v13)
  {
LABEL_31:
    v24[0] = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v22);
    v21 = mlir::OpBuilder::create<mlir::tensor::EmptyOp,llvm::SmallVector<mlir::OpFoldResult,6u> &,mlir::Type>((mlir::OpBuilder *)(a3 + 1), *(_QWORD *)(a2 + 24), (uint64_t)&v27, v24);
    (*((void (**)(mlir::IndexType **, uint64_t, ZinIrHalH13g *))*a3 + 4))(a3, a2, v21);
    v8 = 1;
    goto LABEL_32;
  }
  v14 = (unint64_t *)v30;
  v15 = 8 * v13 - 8;
  v16 = 8 * v12 - 8;
  while (1)
  {
    v17 = *Value;
    v18 = (*v14 & 4) != 0 ? 0 : *v14 & 0xFFFFFFFFFFFFFFF8;
    if (v18)
      break;
    if (v17 == (mlir::MLIRContext *)0x8000000000000000)
    {
      v19 = v28;
      v18 = *v14;
      if (v28 < (unint64_t)HIDWORD(v28))
        goto LABEL_22;
    }
    else
    {
      v18 = mlir::Builder::getIndexAttr(a3 + 1, *Value) & 0xFFFFFFFFFFFFFFFBLL;
      v19 = v28;
      if (v28 < (unint64_t)HIDWORD(v28))
      {
LABEL_22:
        *((_QWORD *)v27 + v19) = v18;
        LODWORD(v28) = v28 + 1;
        if (!v16)
          goto LABEL_31;
        goto LABEL_23;
      }
    }
LABEL_27:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v27, v29, v19 + 1, 8);
    *((_QWORD *)v27 + v28) = v18;
    LODWORD(v28) = v28 + 1;
    if (!v16)
      goto LABEL_31;
LABEL_23:
    ++Value;
    ++v14;
    v20 = v15;
    v15 -= 8;
    v16 -= 8;
    if (!v20)
      goto LABEL_31;
  }
  if (v17 != (mlir::MLIRContext *)0x8000000000000000)
  {
    v24[0] = v18;
    if (v17 == (mlir::MLIRContext *)mlir::IntegerAttr::getInt((mlir::IntegerAttr *)v24))
    {
      v19 = v28;
      if (v28 < (unint64_t)HIDWORD(v28))
        goto LABEL_22;
      goto LABEL_27;
    }
  }
  v24[0] = (uint64_t)"mismatch in static value of shape of empty tensor result and cast result";
  v25 = 259;
  v26 = v24;
  v8 = (uint64_t)a3[2];
  if (v8)
  {
    if (mlir::RewriterBase::Listener::classof(v8))
      v8 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(_QWORD *)v8 + 64))(v8, *(_QWORD *)(v7 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::tensor::EmptyOp &>(mlir::tensor::EmptyOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v26);
    else
      v8 = 0;
  }
LABEL_32:
  if (v27 != v29)
    free(v27);
  if (v30 != v32)
    free(v30);
  return v8;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::tensor::EmptyOp &>(mlir::tensor::EmptyOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

void `anonymous namespace'::FoldEmptyTensorWithDimOp::~FoldEmptyTensorWithDimOp(_anonymous_namespace_::FoldEmptyTensorWithDimOp *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::FoldEmptyTensorWithDimOp::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int ConstantIntValue;
  char v6;
  char v7;
  uint64_t DefiningOp;
  void *v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v20;

  ConstantIntValue = mlir::getConstantIntValue(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 56) | 4);
  v7 = v6;
  v20 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v20);
  if (!DefiningOp)
    return 0;
  v9 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
  v10 = v9 == &mlir::detail::TypeIDResolver<mlir::tensor::EmptyOp,void>::id ? DefiningOp : 0;
  if (v9 != &mlir::detail::TypeIDResolver<mlir::tensor::EmptyOp,void>::id || v7 == 0)
    return 0;
  v12 = *(_DWORD *)(v10 + 36) ? v10 - 16 : 0;
  v20 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v12, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v20) + 8 * ConstantIntValue) != 0x8000000000000000)
    return 0;
  v13 = ConstantIntValue;
  if (ConstantIntValue)
  {
    v14 = 0;
    LODWORD(v15) = 0;
    v16 = 8 * v13;
    do
    {
      if (*(_DWORD *)(v10 + 36))
        v17 = v10 - 16;
      else
        v17 = 0;
      v20 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v17, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
      if (*(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v20) + v14) == 0x8000000000000000)
        v15 = (v15 + 1);
      else
        v15 = v15;
      v14 += 8;
    }
    while (v16 != v14);
  }
  else
  {
    v15 = 0;
  }
  v20 = *(_QWORD *)(*(_QWORD *)(v10 + 72) + 32 * v15 + 24);
  v18 = 1;
  (*(void (**)(uint64_t, uint64_t, unint64_t *, uint64_t))(*(_QWORD *)a3 + 24))(a3, a2, &v20, 1);
  return v18;
}

void `anonymous namespace'::ReplaceEmptyTensorStaticShapeDims::~ReplaceEmptyTensorStaticShapeDims(_anonymous_namespace_::ReplaceEmptyTensorStaticShapeDims *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::EmptyOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::EmptyOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::EmptyOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t `anonymous namespace'::ReplaceEmptyTensorStaticShapeDims::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _BYTE *Value;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t ConstantIntValue;
  char v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t RHS;
  uint64_t v31;
  uint64_t Values;
  uint64_t v33;
  ZinIrHalH13g *v34;
  uint64_t v35;
  void *v36;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  void *v41;
  uint64_t v42;
  _BYTE v43[48];
  void *v44;
  uint64_t v45;
  _QWORD v46[8];

  v46[6] = *MEMORY[0x24BDAC8D0];
  v5 = a2 - 16;
  if (*(_DWORD *)(a2 + 36))
    v6 = a2 - 16;
  else
    v6 = 0;
  v41 = (void *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  Value = (_BYTE *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v41);
  if (*(_DWORD *)(a2 + 36))
    v8 = v5;
  else
    v8 = 0;
  v40 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  v9 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v40);
  v11 = (_BYTE *)(v9 + 8 * v10);
  v44 = v46;
  v45 = 0x600000000;
  v12 = v11 - Value;
  if ((unint64_t)(v11 - Value) >= 0x31)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v46, v12 >> 3, 8);
    v13 = v45;
    if (v11 == Value)
      goto LABEL_12;
    goto LABEL_11;
  }
  v13 = 0;
  if (v11 != Value)
  {
LABEL_11:
    memcpy((char *)v44 + 8 * v13, Value, v11 - Value);
    v13 = v45;
  }
LABEL_12:
  LODWORD(v45) = v13 + ((unint64_t)v12 >> 3);
  v41 = v43;
  v42 = 0x600000000;
  if (*(_DWORD *)(a2 + 36))
    v14 = v5;
  else
    v14 = 0;
  v40 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v40);
  if (v15 < 1)
    goto LABEL_44;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  do
  {
    if (*(_DWORD *)(a2 + 36))
      v22 = v5;
    else
      v22 = 0;
    v40 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v22, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    if (*(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v40) + 8 * v18) == 0x8000000000000000)
    {
      v19 = (v16 + 1);
      v23 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 32 * v16 + 24);
      ConstantIntValue = mlir::getConstantIntValue(v23 | 4);
      if (v25)
      {
        if ((ConstantIntValue & 0x8000000000000000) != 0)
          goto LABEL_44;
        *((_QWORD *)v44 + v18) = ConstantIntValue;
        v17 = 1;
      }
      else
      {
        v26 = v42;
        if (v42 >= (unint64_t)HIDWORD(v42))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v43, v42 + 1, 8);
          v26 = v42;
        }
        *((_QWORD *)v41 + v26) = v23;
        LODWORD(v42) = v42 + 1;
      }
    }
    else
    {
      v19 = v16;
    }
    ++v18;
    if (*(_DWORD *)(a2 + 36))
      v20 = v5;
    else
      v20 = 0;
    v40 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v20, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v40);
    v16 = v19;
  }
  while (v18 < v21);
  if ((v17 & 1) != 0)
  {
    v27 = v44;
    v28 = v45;
    if (*(_DWORD *)(a2 + 36))
      v29 = v5;
    else
      v29 = 0;
    v39 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v29, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v39);
    if (*(_DWORD *)(a2 + 36))
      v31 = v5;
    else
      v31 = 0;
    v38 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v31, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v38);
    v40 = mlir::RankedTensorType::get((uint64_t)v27, v28, RHS, Values);
    v39 = (unint64_t)mlir::OpBuilder::create<mlir::tensor::EmptyOp,mlir::RankedTensorType &,llvm::SmallVector<mlir::Value,6u> &>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v40, (uint64_t)&v41);
    if (*(_DWORD *)(a2 + 36))
      v33 = v5;
    else
      v33 = 0;
    v38 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v33, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v34 = mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::RankedTensorType,mlir::tensor::EmptyOp &>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v38, &v39);
    (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, a2, v34);
    v35 = 1;
    v36 = v41;
    if (v41 == v43)
      goto LABEL_46;
  }
  else
  {
LABEL_44:
    v35 = 0;
    v36 = v41;
    if (v41 == v43)
      goto LABEL_46;
  }
  free(v36);
LABEL_46:
  if (v44 != v46)
    free(v44);
  return v35;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::EmptyOp,mlir::RankedTensorType &,llvm::SmallVector<mlir::Value,6u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  unsigned int v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  _QWORD v22[8];
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  _QWORD v26[29];

  v26[28] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.empty", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"tensor.empty";
    v19[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v22);
    llvm::report_fatal_error((llvm::Twine *)v22, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v9);
  v11 = *a3;
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::OperationState::addOperands((uint64_t)v22, v21[0], v21[1]);
  v12 = v24;
  if (v24 >= v25)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v23, v26, v24 + 1, 8);
    v12 = v24;
  }
  *(_QWORD *)(v23 + 8 * v12) = v11;
  ++v24;
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::EmptyOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v14;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::RankedTensorType,mlir::tensor::EmptyOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  unsigned int v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[8];
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  _QWORD v25[29];

  v25[28] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.cast", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"tensor.cast";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  v11 = *a3;
  v19[0] = *a4 - 16;
  mlir::OperationState::addOperands((uint64_t)v21, (uint64_t)v19, 1);
  v12 = v23;
  if (v23 >= v24)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v22, v25, v23 + 1, 8);
    v12 = v23;
  }
  *(_QWORD *)(v22 + 8 * v12) = v11;
  ++v23;
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void `anonymous namespace'::ExtractFromTensorCast::~ExtractFromTensorCast(_anonymous_namespace_::ExtractFromTensorCast *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::ExtractOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::ExtractOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::ExtractOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t `anonymous namespace'::ExtractFromTensorCast::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  ZinIrHalH13g *v8;
  _QWORD v9[2];
  uint64_t v10;

  v9[0] = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)v9);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8)
                        + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      {
        v10 = *(_QWORD *)(*(_QWORD *)(result + 72) + 24);
        if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
        {
          v6 = *(_QWORD *)(a2 + 72);
          v7 = *(unsigned int *)(a2 + 68) - 1;
        }
        else
        {
          v6 = 0;
          v7 = -1;
        }
        v9[0] = v6 + 32;
        v9[1] = v7;
        v8 = mlir::OpBuilder::create<mlir::tensor::ExtractOp,mlir::detail::TypedValue<mlir::TensorType>,mlir::OperandRange>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), &v10, (uint64_t)v9);
        (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, a2, v8);
        return 1;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void `anonymous namespace'::ExtractElementFromIndexCast::~ExtractElementFromIndexCast(_anonymous_namespace_::ExtractElementFromIndexCast *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::ExtractElementFromIndexCast::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t result;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t Input;
  uint64_t v11;
  uint64_t v12;
  ZinIrHalH13g *v13;
  uint64_t v14[2];
  uint64_t v15;
  ZinIrHalH13g *v16;
  uint64_t ElementTypeOrSelf;
  uint64_t v18;

  v5 = *(_QWORD *)(a2 + 24);
  v14[0] = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)v14);
  if (result)
  {
    v7 = *(void **)(*(_QWORD *)(result + 48) + 16);
    v8 = v7 == &mlir::detail::TypeIDResolver<mlir::arith::IndexCastOp,void>::id;
    if (v7 == &mlir::detail::TypeIDResolver<mlir::arith::IndexCastOp,void>::id)
      v9 = result;
    else
      v9 = 0;
    v18 = v9;
    if (v8)
    {
      Input = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v18);
      ElementTypeOrSelf = mlir::getElementTypeOrSelf(Input);
      v15 = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v18);
      if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
      {
        v11 = *(_QWORD *)(a2 + 72);
        v12 = *(unsigned int *)(a2 + 68) - 1;
      }
      else
      {
        v11 = 0;
        v12 = -1;
      }
      v14[0] = v11 + 32;
      v14[1] = v12;
      v16 = mlir::OpBuilder::create<mlir::tensor::ExtractOp,mlir::Type &,mlir::Value,mlir::OperandRange>((mlir::OpBuilder *)(a3 + 8), v5, &ElementTypeOrSelf, &v15, (uint64_t)v14);
      v14[0] = *(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
      v13 = mlir::OpBuilder::create<mlir::arith::IndexCastOp,mlir::Type,mlir::tensor::ExtractOp &>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), v14, &v16);
      (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, a2, v13);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::ExtractOp,mlir::Type &,mlir::Value,mlir::OperandRange>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  ZinIrHalH13g *v18;
  ZinIrHalH13g *v19;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  uint64_t v24[4];
  __int16 v25;
  unint64_t v26[2];
  _QWORD v27[8];
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  _QWORD v31[29];

  v31[28] = *MEMORY[0x24BDAC8D0];
  v21 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.extract", (const unsigned __int8 *)0xE, Context);
  if (!v12)
  {
    v25 = 1283;
    v24[2] = (uint64_t)"tensor.extract";
    v24[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v23 = 259;
    llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v27, a2, v11);
  v13 = *a3;
  v14 = *a4;
  mlir::ValueRange::ValueRange(v26, *(_QWORD *)a5, *(_QWORD *)(a5 + 8));
  v15 = v26[0];
  v16 = v26[1];
  v24[0] = v14;
  mlir::OperationState::addOperands((uint64_t)v27, (uint64_t)v24, 1);
  mlir::OperationState::addOperands((uint64_t)v27, v15, v16);
  v17 = v29;
  if (v29 >= v30)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v28, v31, v29 + 1, 8);
    v17 = v29;
  }
  *(_QWORD *)(v28 + 8 * v17) = v13;
  ++v29;
  v18 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v27);
  if (*(_UNKNOWN **)(*((_QWORD *)v18 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::ExtractOp,void>::id)
    v19 = v18;
  else
    v19 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  return v19;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::arith::IndexCastOp,mlir::Type,mlir::tensor::ExtractOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  ZinIrHalH13g *v11;
  ZinIrHalH13g *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x24BDAC8D0];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"arith.index_cast", (const unsigned __int8 *)0x10, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"arith.index_cast";
    v17[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4 - 16);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::IndexCastOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void `anonymous namespace'::ExtractFromTensorGenerate::~ExtractFromTensorGenerate(_anonymous_namespace_::ExtractFromTensorGenerate *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::ExtractFromTensorGenerate::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  uint64_t DefiningOp;
  mlir::Operation *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  _QWORD *v20;
  BOOL v22;
  ZinIrHalH13g **v23;
  ZinIrHalH13g *v24;
  ZinIrHalH13g *i;
  mlir::Operation *v26;
  uint64_t v27;
  _QWORD *v28;
  llvm *v30[2];
  unsigned int v31;
  llvm *v32;
  uint64_t v33;
  int v34;
  llvm *v35;
  uint64_t v36;
  unsigned int v37;
  _QWORD *v38;
  _QWORD *v39;

  v30[0] = *(llvm **)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v30);
  v7 = DefiningOp;
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::GenerateOp,void>::id
      && mlir::wouldOpBeTriviallyDead((void ***)DefiningOp, v6))
    {
      v31 = 0;
      v30[0] = 0;
      v30[1] = 0;
      v34 = 0;
      v32 = 0;
      v33 = 0;
      v37 = 0;
      v35 = 0;
      v36 = 0;
      v8 = *(_QWORD *)(((v7
                       + 16 * (((unint64_t)*(unsigned int *)(v7 + 44) >> 23) & 1)
                       + (((unint64_t)*(unsigned int *)(v7 + 44) >> 21) & 0x7F8)
                       + 71) & 0xFFFFFFFFFFFFFFF8)
                     + 32 * *(unsigned int *)(v7 + 40)
                     + 8);
      if (v8)
        v9 = v8 - 8;
      else
        v9 = 0;
      v11 = *(unint64_t **)(v9 + 48);
      v10 = *(unint64_t **)(v9 + 56);
      if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
      {
        v12 = *(_QWORD *)(a2 + 72);
        v13 = *(unsigned int *)(a2 + 68) - 1;
        if (v10 == v11 || *(_DWORD *)(a2 + 68) == 1)
          goto LABEL_20;
      }
      else
      {
        v12 = 0;
        v13 = -1;
        if (v10 == v11)
          goto LABEL_20;
      }
      v15 = v13 - 1;
      v16 = (uint64_t *)(v12 + 56);
      v17 = 8 * (v10 - v11) - 8;
      do
      {
        v18 = *v16;
        v38 = (_QWORD *)*v11;
        v39 = 0;
        v19 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)v30, (unint64_t *)&v38, &v39);
        v20 = v39;
        if ((v19 & 1) == 0)
        {
          v20 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v30, (uint64_t)&v38, (unint64_t *)&v38, v39);
          *v20 = v38;
          v20[1] = 0;
        }
        v20[1] = v18;
        v22 = v15-- != 0;
        if (!v17)
          break;
        ++v11;
        v16 += 4;
        v17 -= 8;
      }
      while (v22);
LABEL_20:
      v23 = (ZinIrHalH13g **)(v9 + 32);
      v24 = *(ZinIrHalH13g **)(v9 + 40);
      if (v24 != (ZinIrHalH13g *)(v9 + 32))
      {
        for (i = *v23; v24 != i; v24 = (ZinIrHalH13g *)*((_QWORD *)v24 + 1))
        {
          ZinIrHalH13g::~ZinIrHalH13g(v24);
          mlir::OpBuilder::clone(a3 + 1, v26, (mlir::IRMapping *)v30);
        }
      }
      mlir::Block::getTerminator((ZinIrHalH13g **)v9);
      v28 = *(_QWORD **)(*(_QWORD *)(v27 + 72) + 24);
      v38 = v28;
      v39 = 0;
      if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)v30, (unint64_t *)&v38, &v39))
      {
        if (v39 != (_QWORD *)v30[0] + 2 * v31)
          v28 = (_QWORD *)v39[1];
      }
      v39 = v28;
      ((void (*)(uint64_t **, uint64_t, _QWORD **, uint64_t))(*a3)[3])(a3, a2, &v39, 1);
      llvm::deallocate_buffer(v35, (void *)(16 * v37));
    }
    return 0;
  }
  return v7;
}

void `anonymous namespace'::StaticTensorGenerate::~StaticTensorGenerate(_anonymous_namespace_::StaticTensorGenerate *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::GenerateOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::GenerateOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::GenerateOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t `anonymous namespace'::StaticTensorGenerate::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _QWORD *Value;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t RHS;
  unint64_t v18;
  ZinIrHalH13g *v19;
  uint64_t v20;
  ZinIrHalH13g *v21;
  unint64_t v22;
  void *v23;
  uint64_t v24;
  _BYTE v25[48];
  void *v26;
  uint64_t v27;
  _QWORD v28[7];

  v28[6] = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 36))
    v5 = a2 - 16;
  else
    v5 = 0;
  v22 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (mlir::TensorType::hasRank((mlir::TensorType *)&v22))
  {
    Value = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v22);
    if (!v7)
      return 0;
    v8 = 8 * v7;
    while (*Value != 0x8000000000000000)
    {
      ++Value;
      v8 -= 8;
      if (!v8)
        return 0;
    }
  }
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
  {
    v10 = *(unsigned int *)(a2 + 68);
    v11 = *(_QWORD *)(a2 + 72);
  }
  else
  {
    v11 = 0;
    v10 = 0;
  }
  v26 = v28;
  v27 = 0x600000000;
  v23 = v25;
  v24 = 0x600000000;
  operandsAndShape(v22, v11, v10, (uint64_t)&v26, (uint64_t)&v23);
  v12 = v23;
  v13 = v24;
  if ((_DWORD)v24)
  {
    v14 = 0;
    while (*(_QWORD *)((char *)v23 + v14) < 0x8000000000000001)
    {
      v14 += 8;
      if (8 * v24 == v14)
        goto LABEL_16;
    }
LABEL_18:
    v9 = 0;
    if (v23 == v25)
      goto LABEL_20;
    goto LABEL_19;
  }
LABEL_16:
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
  {
    if (*(_DWORD *)(a2 + 68) == (unint64_t)v27)
      goto LABEL_18;
  }
  else if (!(_DWORD)v27)
  {
    goto LABEL_18;
  }
  v16 = *(_QWORD *)(a2 + 24);
  RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v22);
  v20 = mlir::RankedTensorType::get((uint64_t)v12, v13, RHS, 0);
  v21 = mlir::OpBuilder::create<mlir::tensor::GenerateOp,mlir::RankedTensorType,llvm::SmallVector<mlir::Value,6u> &>((mlir::OpBuilder *)(a3 + 8), v16, &v20, (uint64_t)&v26);
  v18 = (((unint64_t)v21
        + 16 * (((unint64_t)*((unsigned int *)v21 + 11) >> 23) & 1)
        + (((unint64_t)*((unsigned int *)v21 + 11) >> 21) & 0x7F8)
        + 71) & 0xFFFFFFFFFFFFFFF8)
      + 32 * *((unsigned int *)v21 + 10);
  (**(void (***)(uint64_t, unint64_t, unint64_t, _QWORD))a3)(a3, ((a2+ 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(a2 + 40), v18, *(_QWORD *)(v18 + 8));
  v19 = mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::RankedTensorType,mlir::tensor::EmptyOp &>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v22, &v21);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, a2, v19);
  v9 = 1;
  v12 = v23;
  if (v23 != v25)
LABEL_19:
    free(v12);
LABEL_20:
  if (v26 != v28)
    free(v26);
  return v9;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::GenerateOp,mlir::RankedTensorType,llvm::SmallVector<mlir::Value,6u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  unsigned int v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  _QWORD v22[8];
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  _QWORD v26[29];

  v26[28] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.generate", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"tensor.generate";
    v19[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v22);
    llvm::report_fatal_error((llvm::Twine *)v22, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v9);
  v11 = *a3;
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::OperationState::addOperands((uint64_t)v22, v21[0], v21[1]);
  mlir::OperationState::addRegion((mlir::OperationState *)v22);
  v12 = v24;
  if (v24 >= v25)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v23, v26, v24 + 1, 8);
    v12 = v24;
  }
  *(_QWORD *)(v23 + 8 * v12) = v11;
  ++v24;
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::GenerateOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v14;
}

uint64_t llvm::function_ref<mlir::LogicalResult ()(llvm::Twine const&)>::callback_fn<mlir::LogicalResult mlir::verifyReshapeLikeShapes<mlir::tensor::ExpandShapeOp>(mlir::tensor::ExpandShapeOp,mlir::ShapedType,mlir::ShapedType,BOOL)::{lambda(llvm::Twine const&)#1}>(uint64_t ***a1, const void ***a2)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[3];
  void *v13;
  uint64_t v14;
  void *v15;
  _QWORD *v16;
  void *__p;
  _QWORD *v18;
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  mlir::Operation::emitOpError(**a1, a2, (uint64_t)v12);
  v2 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v12);
  if (v12[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v12);
  if (v19)
  {
    v3 = __p;
    if (__p)
    {
      v4 = v18;
      v5 = __p;
      if (v18 != __p)
      {
        do
          v4 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v4 - 1);
        while (v4 != v3);
        v5 = __p;
      }
      v18 = v3;
      operator delete(v5);
    }
    v6 = v15;
    if (v15)
    {
      v7 = v16;
      v8 = v15;
      if (v16 != v15)
      {
        do
        {
          v10 = *--v7;
          v9 = v10;
          *v7 = 0;
          if (v10)
            MEMORY[0x20BD002D4](v9, 0x1000C8077774924);
        }
        while (v7 != v6);
        v8 = v15;
      }
      v16 = v6;
      operator delete(v8);
    }
    if (v13 != &v14)
      free(v13);
  }
  return v2;
}

uint64_t llvm::function_ref<mlir::LogicalResult ()(llvm::Twine const&)>::callback_fn<mlir::LogicalResult mlir::verifyReshapeLikeShapes<mlir::tensor::CollapseShapeOp>(mlir::tensor::CollapseShapeOp,mlir::ShapedType,mlir::ShapedType,BOOL)::{lambda(llvm::Twine const&)#1}>(uint64_t ***a1, const void ***a2)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[3];
  void *v13;
  uint64_t v14;
  void *v15;
  _QWORD *v16;
  void *__p;
  _QWORD *v18;
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  mlir::Operation::emitOpError(**a1, a2, (uint64_t)v12);
  v2 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v12);
  if (v12[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v12);
  if (v19)
  {
    v3 = __p;
    if (__p)
    {
      v4 = v18;
      v5 = __p;
      if (v18 != __p)
      {
        do
          v4 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v4 - 1);
        while (v4 != v3);
        v5 = __p;
      }
      v18 = v3;
      operator delete(v5);
    }
    v6 = v15;
    if (v15)
    {
      v7 = v16;
      v8 = v15;
      if (v16 != v15)
      {
        do
        {
          v10 = *--v7;
          v9 = v10;
          *v7 = 0;
          if (v10)
            MEMORY[0x20BD002D4](v9, 0x1000C8077774924);
        }
        while (v7 != v6);
        v8 = v15;
      }
      v16 = v6;
      operator delete(v8);
    }
    if (v13 != &v14)
      free(v13);
  }
  return v2;
}

void mlir::RewritePatternSet::addImpl<mlir::ComposeReassociativeReshapeOps<mlir::tensor::ExpandShapeOp>,mlir::MLIRContext *&>(_QWORD *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  const char *v18;
  unint64_t v19;
  uint64_t v20;
  const char *v21;
  unint64_t v22;
  uint64_t v23;
  const char *v24;
  unint64_t v25;

  v8 = operator new();
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v24, 1);
  mlir::Pattern::Pattern(v8 + 8, (uint64_t)"tensor.expand_shape", 19, (__int16)v24, v9, 0, 0);
  *(_QWORD *)v8 = &unk_24C04FC58;
  v23 = v8;
  if (*(_QWORD *)(v8 + 72))
  {
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
      goto LABEL_3;
  }
  else
  {
    v24 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ComposeReassociativeReshapeOps<mlir::tensor::ExpandShapeOp>]";
    v25 = 115;
    v16 = llvm::StringRef::find((uint64_t *)&v24, "DesiredTypeName = ", 0x12uLL, 0);
    if (v25 >= v16)
      v17 = v16;
    else
      v17 = v25;
    v18 = &v24[v17];
    v19 = v25 - v17;
    if (v25 - v17 >= 0x12)
      v20 = 18;
    else
      v20 = v25 - v17;
    v21 = &v18[v20];
    v22 = v19 - v20;
    if (v22 >= v22 - 1)
      --v22;
    *(_QWORD *)(v8 + 64) = v21;
    *(_QWORD *)(v8 + 72) = v22;
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
    {
LABEL_3:
      if (!a3)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod(v8 + 80, (void *)(v8 + 96), v12, 16);
  LODWORD(v11) = *(_DWORD *)(v8 + 88);
  if (a3)
  {
LABEL_4:
    memcpy((void *)(*(_QWORD *)(v8 + 80) + 16 * v11), a2, v10);
    LODWORD(v11) = *(_DWORD *)(v8 + 88);
  }
LABEL_5:
  *(_DWORD *)(v8 + 88) = v11 + (v10 >> 4);
  v13 = (uint64_t *)a1[2];
  if ((unint64_t)v13 >= a1[3])
  {
    v14 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, &v23);
    v15 = v23;
    a1[2] = v14;
    v23 = 0;
    if (v15)
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  }
  else
  {
    *v13 = v8;
    a1[2] = v13 + 1;
  }
}

void mlir::RewritePatternSet::addImpl<mlir::ComposeExpandOfCollapseOp<mlir::tensor::ExpandShapeOp,mlir::tensor::CollapseShapeOp>,mlir::MLIRContext *&>(_QWORD *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  const char *v18;
  unint64_t v19;
  uint64_t v20;
  const char *v21;
  unint64_t v22;
  uint64_t v23;
  const char *v24;
  unint64_t v25;

  v8 = operator new();
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v24, 1);
  mlir::Pattern::Pattern(v8 + 8, (uint64_t)"tensor.expand_shape", 19, (__int16)v24, v9, 0, 0);
  *(_QWORD *)v8 = &unk_24C04F990;
  v23 = v8;
  if (*(_QWORD *)(v8 + 72))
  {
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
      goto LABEL_3;
  }
  else
  {
    v24 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ComposeExpandOfCollapseOp<mlir::tensor::ExpandShapeOp, "
          "mlir::tensor::CollapseShapeOp>]";
    v25 = 141;
    v16 = llvm::StringRef::find((uint64_t *)&v24, "DesiredTypeName = ", 0x12uLL, 0);
    if (v25 >= v16)
      v17 = v16;
    else
      v17 = v25;
    v18 = &v24[v17];
    v19 = v25 - v17;
    if (v25 - v17 >= 0x12)
      v20 = 18;
    else
      v20 = v25 - v17;
    v21 = &v18[v20];
    v22 = v19 - v20;
    if (v22 >= v22 - 1)
      --v22;
    *(_QWORD *)(v8 + 64) = v21;
    *(_QWORD *)(v8 + 72) = v22;
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
    {
LABEL_3:
      if (!a3)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod(v8 + 80, (void *)(v8 + 96), v12, 16);
  LODWORD(v11) = *(_DWORD *)(v8 + 88);
  if (a3)
  {
LABEL_4:
    memcpy((void *)(*(_QWORD *)(v8 + 80) + 16 * v11), a2, v10);
    LODWORD(v11) = *(_DWORD *)(v8 + 88);
  }
LABEL_5:
  *(_DWORD *)(v8 + 88) = v11 + (v10 >> 4);
  v13 = (uint64_t *)a1[2];
  if ((unint64_t)v13 >= a1[3])
  {
    v14 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, &v23);
    v15 = v23;
    a1[2] = v14;
    v23 = 0;
    if (v15)
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  }
  else
  {
    *v13 = v8;
    a1[2] = v13 + 1;
  }
}

_QWORD *mlir::ComposeReassociativeReshapeOps<mlir::tensor::ExpandShapeOp>::~ComposeReassociativeReshapeOps(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::ComposeReassociativeReshapeOps<mlir::tensor::ExpandShapeOp>::~ComposeReassociativeReshapeOps(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::ExpandShapeOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::ExpandShapeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::ExpandShapeOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::ComposeReassociativeReshapeOps<mlir::tensor::ExpandShapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t NextResultAtOffset;
  void *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  ZinIrHalH13g *v24;
  char *v25;
  uint64_t v26;
  char *v27;
  uint64_t v28[2];
  uint64_t v29;
  uint64_t v30;
  void *v31;
  unsigned int v32;
  uint64_t v33;
  void *v34;
  unsigned int v35;
  uint64_t v36;
  char *v37;
  unsigned int v38;
  uint64_t v39;
  char v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v30 = a2;
  v34 = *(void **)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v34);
  if (result)
  {
    v6 = result;
    v7 = *(void **)(*(_QWORD *)(result + 48) + 16);
    v8 = v7 == &mlir::detail::TypeIDResolver<mlir::tensor::ExpandShapeOp,void>::id;
    if (v7 == &mlir::detail::TypeIDResolver<mlir::tensor::ExpandShapeOp,void>::id)
      v9 = result;
    else
      v9 = 0;
    v29 = v9;
    if (!v8)
      return 0;
    v10 = *(_DWORD *)(a2 + 36) ? a2 - 16 : 0;
    v11 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    v12 = v11 ? mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v11 + 8) : 0;
    v28[0] = (uint64_t)v11;
    v28[1] = v12;
    if ((mlir::hasNonIdentityLayout(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0
      || (mlir::hasNonIdentityLayout(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0)
    {
      return 0;
    }
    v13 = *(_DWORD *)(a2 + 36) ? a2 - 16 : 0;
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v13, 0);
    if ((mlir::hasNonIdentityLayout(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0)
      return 0;
    mlir::memref::CollapseShapeOp::getReassociationIndices((mlir::memref::CollapseShapeOp *)&v29, (uint64_t)&v34);
    v15 = v34;
    v16 = v35;
    mlir::memref::CollapseShapeOp::getReassociationIndices((mlir::memref::CollapseShapeOp *)&v30, (uint64_t)&v31);
    mlir::composeReassociationIndices((uint64_t)v15, v16, (uint64_t)v31, v32, (uint64_t)&v37);
    v17 = (char *)v31;
    if (v32)
    {
      v18 = 32 * v32;
      do
      {
        v19 = *(char **)&v17[v18 - 32];
        if (&v17[v18 - 16] != v19)
          free(v19);
        v18 -= 32;
      }
      while (v18);
      v17 = (char *)v31;
    }
    if (v17 != (char *)&v33)
      free(v17);
    v20 = (char *)v34;
    if (v35)
    {
      v21 = 32 * v35;
      do
      {
        v22 = *(char **)&v20[v21 - 32];
        if (&v20[v21 - 16] != v22)
          free(v22);
        v21 -= 32;
      }
      while (v21);
      v20 = (char *)v34;
    }
    if (v20 != (char *)&v36)
      free(v20);
    if (!v40)
    {
      return 0;
    }
    else
    {
      v23 = v30;
      v34 = *(void **)(*(_QWORD *)(v29 + 72) + 24);
      v24 = mlir::OpBuilder::create<mlir::tensor::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(a3 + 1, *(_QWORD *)(v30 + 24), v28, (uint64_t *)&v34, (uint64_t)&v37);
      (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a3 + 32))(a3, v23, v24);
      if (v40)
      {
        v25 = v37;
        if (v38)
        {
          v26 = 32 * v38;
          do
          {
            v27 = *(char **)&v25[v26 - 32];
            if (&v25[v26 - 16] != v27)
              free(v27);
            v26 -= 32;
          }
          while (v26);
          v25 = v37;
        }
        if (v25 != (char *)&v39)
          free(v25);
      }
      return 1;
    }
  }
  return result;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  uint64_t ReassociationIndicesAttribute;
  mlir::StringAttr *v19;
  uint64_t v20;
  ZinIrHalH13g *v21;
  ZinIrHalH13g *v22;
  uint64_t v24;
  uint64_t v25[4];
  __int16 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29[4];
  __int16 v30;
  _QWORD v31[14];
  uint64_t v32;
  unint64_t v33[3];

  v33[2] = *MEMORY[0x24BDAC8D0];
  v24 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.expand_shape", (const unsigned __int8 *)0x13, Context);
  if (!v12)
  {
    v30 = 1283;
    v29[2] = (uint64_t)"tensor.expand_shape";
    v29[3] = 19;
                      "een added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-de"
                      "pendent-whats-up-with-dialects-management";
    v26 = 259;
    llvm::operator+(v29, v25, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v31, a2, v11);
  v13 = *a3;
  v14 = *a4;
  v15 = *(_QWORD *)a5;
  v16 = *(unsigned int *)(a5 + 8);
  v27 = v14;
  v28 = v13;
  v17 = mlir::ValueRange::ValueRange(v33, (uint64_t)&v28, 1uLL);
  mlir::arith::CmpIOp::build((uint64_t)v17, (uint64_t)v31, v33[0], v33[1], (uint64_t)&v27, 1, 0, 0);
  ReassociationIndicesAttribute = mlir::getReassociationIndicesAttribute(a1, v15, v16);
  v19 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)v31);
  v30 = 261;
  v29[0] = (uint64_t)"reassociation";
  v29[1] = 13;
  v20 = mlir::StringAttr::get(v19, (mlir::MLIRContext *)v29);
  ZinMirCacheTensors::ZinMirCacheTensors(v25, v20, ReassociationIndicesAttribute);
  mlir::NamedAttrList::push_back((uint64_t)&v32, v25[0], v25[1]);
  v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v31);
  if (*(_UNKNOWN **)(*((_QWORD *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::ExpandShapeOp,void>::id)
    v22 = v21;
  else
    v22 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v31);
  return v22;
}

_QWORD *mlir::ComposeExpandOfCollapseOp<mlir::tensor::ExpandShapeOp,mlir::tensor::CollapseShapeOp>::~ComposeExpandOfCollapseOp(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::ComposeExpandOfCollapseOp<mlir::tensor::ExpandShapeOp,mlir::tensor::CollapseShapeOp>::~ComposeExpandOfCollapseOp(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::ComposeExpandOfCollapseOp<mlir::tensor::ExpandShapeOp,mlir::tensor::CollapseShapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t DefiningOp;
  uint64_t v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t NextResultAtOffset;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t **v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  ZinIrHalH13g *v31;
  uint64_t v32;
  void *v34;
  uint64_t v35;
  uint64_t **v36;
  uint64_t v37;
  uint64_t Shape;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char *v43;
  uint64_t v44;
  char *v45;
  uint64_t **v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  uint64_t v50[2];
  _QWORD v51[2];
  uint64_t v52;
  uint64_t v53;
  char *v54[6];
  char v55;
  void *v56;
  unsigned int v57;
  uint64_t v58;
  uint64_t **v59;
  unsigned int v60;
  _QWORD v61[17];

  v61[16] = *MEMORY[0x24BDAC8D0];
  v53 = a2;
  v59 = *(uint64_t ***)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v59);
  if (!DefiningOp)
    return 0;
  v6 = DefiningOp;
  v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
  v8 = v7 == &mlir::detail::TypeIDResolver<mlir::tensor::CollapseShapeOp,void>::id;
  v9 = v7 == &mlir::detail::TypeIDResolver<mlir::tensor::CollapseShapeOp,void>::id ? DefiningOp : 0;
  v52 = v9;
  if (!v8)
    return 0;
  v10 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v11 = v10 ? mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v10 + 8) : 0;
  v51[0] = v10;
  v51[1] = v11;
  v12 = *(_DWORD *)(a2 + 36) ? a2 - 16 : 0;
  v13 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v12, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v14 = v13 ? mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v13 + 8) : 0;
  v50[0] = (uint64_t)v13;
  v50[1] = v14;
  if ((mlir::hasNonIdentityLayout(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0
    || (mlir::hasNonIdentityLayout(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0)
  {
    return 0;
  }
  v15 = *(_DWORD *)(v6 + 36) ? v6 - 16 : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v15, 0);
  if ((mlir::hasNonIdentityLayout(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0)
    return 0;
  mlir::ShapedType::getShape((mlir::ShapedType *)v51);
  v18 = v17;
  mlir::ShapedType::getShape((mlir::ShapedType *)v50);
  if (v51[0] == v50[0])
    return 0;
  v20 = v19;
  mlir::memref::CollapseShapeOp::getReassociationIndices((mlir::memref::CollapseShapeOp *)&v52, (uint64_t)&v59);
  mlir::memref::CollapseShapeOp::getReassociationIndices((mlir::memref::CollapseShapeOp *)&v53, (uint64_t)&v56);
  if (v18 <= v20)
  {
    v34 = v56;
    v35 = v57;
    v36 = v59;
    v37 = v60;
    Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v50);
    v40 = v39;
    v41 = mlir::ShapedType::getShape((mlir::ShapedType *)v51);
    mlir::ComposeExpandOfCollapseOp<mlir::memref::ExpandShapeOp,mlir::memref::CollapseShapeOp>::findCollapsingReassociation((unint64_t)v34, v35, v36, v37, Shape, v40, (uint64_t)v54, v41, v42);
    if (v55)
    {
      v30 = v53;
      v49 = *(_QWORD *)(*(_QWORD *)(v52 + 72) + 24);
      v31 = mlir::OpBuilder::create<mlir::tensor::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(a3 + 1, *(_QWORD *)(v53 + 24), v50, &v49, (uint64_t)v54);
      goto LABEL_30;
    }
LABEL_31:
    v32 = 0;
    goto LABEL_32;
  }
  v21 = (unint64_t)v59;
  v22 = v60;
  v23 = (uint64_t **)v56;
  v24 = v57;
  v25 = mlir::ShapedType::getShape((mlir::ShapedType *)v51);
  v27 = v26;
  v28 = mlir::ShapedType::getShape((mlir::ShapedType *)v50);
  mlir::ComposeExpandOfCollapseOp<mlir::memref::ExpandShapeOp,mlir::memref::CollapseShapeOp>::findCollapsingReassociation(v21, v22, v23, v24, v25, v27, (uint64_t)v54, v28, v29);
  if (!v55)
    goto LABEL_31;
  v30 = v53;
  v49 = *(_QWORD *)(*(_QWORD *)(v52 + 72) + 24);
  v31 = mlir::OpBuilder::create<mlir::tensor::CollapseShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(a3 + 1, *(_QWORD *)(v53 + 24), v50, &v49, (uint64_t)v54);
LABEL_30:
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a3 + 32))(a3, v30, v31);
  v32 = 1;
LABEL_32:
  std::optional<llvm::SmallVector<llvm::SmallVector<long long,2u>,1u>>::~optional(v54);
  v43 = (char *)v56;
  if (v57)
  {
    v44 = 32 * v57;
    do
    {
      v45 = *(char **)&v43[v44 - 32];
      if (&v43[v44 - 16] != v45)
        free(v45);
      v44 -= 32;
    }
    while (v44);
    v43 = (char *)v56;
  }
  if (v43 != (char *)&v58)
    free(v43);
  v46 = v59;
  if (v60)
  {
    v47 = 4 * v60;
    do
    {
      v48 = (char *)v46[v47 - 4];
      if (&v46[v47 - 2] != (uint64_t **)v48)
        free(v48);
      v47 -= 4;
    }
    while (v47 * 8);
    v46 = v59;
  }
  if (v46 != v61)
    free(v46);
  return v32;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::CollapseShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  uint64_t ReassociationIndicesAttribute;
  mlir::StringAttr *v19;
  uint64_t v20;
  ZinIrHalH13g *v21;
  ZinIrHalH13g *v22;
  uint64_t v24;
  uint64_t v25[4];
  __int16 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29[4];
  __int16 v30;
  _QWORD v31[14];
  uint64_t v32;
  unint64_t v33[3];

  v33[2] = *MEMORY[0x24BDAC8D0];
  v24 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.collapse_shape", (const unsigned __int8 *)0x15, Context);
  if (!v12)
  {
    v30 = 1283;
    v29[2] = (uint64_t)"tensor.collapse_shape";
    v29[3] = 21;
                      "een added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-de"
                      "pendent-whats-up-with-dialects-management";
    v26 = 259;
    llvm::operator+(v29, v25, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v31, a2, v11);
  v13 = *a3;
  v14 = *a4;
  v15 = *(_QWORD *)a5;
  v16 = *(unsigned int *)(a5 + 8);
  v27 = v14;
  v28 = v13;
  v17 = mlir::ValueRange::ValueRange(v33, (uint64_t)&v28, 1uLL);
  mlir::arith::CmpIOp::build((uint64_t)v17, (uint64_t)v31, v33[0], v33[1], (uint64_t)&v27, 1, 0, 0);
  ReassociationIndicesAttribute = mlir::getReassociationIndicesAttribute(a1, v15, v16);
  v19 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)v31);
  v30 = 261;
  v29[0] = (uint64_t)"reassociation";
  v29[1] = 13;
  v20 = mlir::StringAttr::get(v19, (mlir::MLIRContext *)v29);
  ZinMirCacheTensors::ZinMirCacheTensors(v25, v20, ReassociationIndicesAttribute);
  mlir::NamedAttrList::push_back((uint64_t)&v32, v25[0], v25[1]);
  v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v31);
  if (*(_UNKNOWN **)(*((_QWORD *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CollapseShapeOp,void>::id)
    v22 = v21;
  else
    v22 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v31);
  return v22;
}

_QWORD *`anonymous namespace'::FoldReshapeWithConstant<mlir::tensor::ExpandShapeOp>::~FoldReshapeWithConstant(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void `anonymous namespace'::FoldReshapeWithConstant<mlir::tensor::ExpandShapeOp>::~FoldReshapeWithConstant(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::FoldReshapeWithConstant<mlir::tensor::ExpandShapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t DefiningOp;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  unint64_t v10;
  unint64_t v11;
  char v12;
  char v13;
  uint64_t result;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t RawStringData;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  ZinIrHalH13g *v23;
  unint64_t v24;
  uint64_t v25;
  void *v26[2];
  _QWORD v27[2];

  v27[1] = *MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  v24 = 0;
  v25 = v5;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v25);
  if (!DefiningOp)
    return 0;
  v7 = DefiningOp;
  if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
    return 0;
  v26[0] = v27;
  v26[1] = (void *)0x100000000;
  mlir::Operation::fold(v7, 0, 0, (uint64_t)v26);
  v8 = *(_QWORD *)v26[0];
  v9 = mlir::DenseElementsAttr::classof(*(_QWORD *)v26[0] & 0xFFFFFFFFFFFFFFF8);
  v10 = 0;
  v11 = v8 & 0xFFFFFFFFFFFFFFF8;
  v12 = (v8 & 0xFFFFFFFFFFFFFFF8) == 0 || !v9;
  if ((v12 & 1) == 0)
  {
    v24 = v11;
    v10 = v11;
  }
  if (v26[0] != v27)
    free(v26[0]);
  v13 = v10 ? v12 : 1;
  if ((v13 & 1) != 0)
    return 0;
  result = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v24);
  if ((_DWORD)result)
  {
    if (*(_DWORD *)(a2 + 36))
      v15 = a2 - 16;
    else
      v15 = 0;
    v16 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v15, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v16)
      v17 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v16 + 8);
    else
      v17 = 0;
    RawStringData = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&v24);
    v26[0] = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v16, v17, RawStringData, v19, v20, v21, v22);
    v23 = mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::DenseElementsAttr &>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (_QWORD **)v26);
    (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, a2, v23);
    return 1;
  }
  return result;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::DenseElementsAttr &>(mlir::OpBuilder *a1, uint64_t a2, _QWORD **a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  _QWORD *v9;
  uint64_t v10;
  ZinIrHalH13g *v11;
  ZinIrHalH13g *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x24BDAC8D0];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"arith.constant", (const unsigned __int8 *)0xE, Context);
  if (!v8)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"arith.constant";
    v17[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v7);
  v9 = *a3;
  if (v9)
    v10 = *(_QWORD *)(mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v9 + 8) + 24);
  else
    v10 = 0;
  mlir::arith::ConstantOp::build((uint64_t)a1, (uint64_t)v19, (uint64_t)v9, v10);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::ConstantOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

_QWORD *`anonymous namespace'::FoldReshapeWithSplat<mlir::tensor::ExpandShapeOp>::~FoldReshapeWithSplat(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void `anonymous namespace'::FoldReshapeWithSplat<mlir::tensor::ExpandShapeOp>::~FoldReshapeWithSplat(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::FoldReshapeWithSplat<mlir::tensor::ExpandShapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  ZinIrHalH13g *v9;
  uint64_t v10;
  unint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (result)
  {
    v6 = result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::SplatOp,void>::id)
    {
      if (*(_DWORD *)(a2 + 36))
        v7 = a2 - 16;
      else
        v7 = 0;
      v8 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
      v10 = *(_QWORD *)(*(_QWORD *)(v6 + 72) + 24);
      v11 = v8;
      v9 = mlir::OpBuilder::create<mlir::tensor::SplatOp,mlir::RankedTensorType,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v11, &v10);
      (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, a2, v9);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::SplatOp,mlir::RankedTensorType,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  unsigned int v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[8];
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  _QWORD v25[29];

  v25[28] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.splat", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"tensor.splat";
    v19[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  v11 = *a3;
  v19[0] = *a4;
  mlir::OperationState::addOperands((uint64_t)v21, (uint64_t)v19, 1);
  v12 = v23;
  if (v23 >= v24)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v22, v25, v23 + 1, 8);
    v12 = v23;
  }
  *(_QWORD *)(v22 + 8 * v12) = v11;
  ++v23;
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::SplatOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

_QWORD *`anonymous namespace'::FoldReshapeWithFromElements<mlir::tensor::ExpandShapeOp>::~FoldReshapeWithFromElements(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void `anonymous namespace'::FoldReshapeWithFromElements<mlir::tensor::ExpandShapeOp>::~FoldReshapeWithFromElements(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::FoldReshapeWithFromElements<mlir::tensor::ExpandShapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  void *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *Shape;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  ZinIrHalH13g *v15;
  _QWORD v16[2];
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;

  v18 = *(_QWORD **)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v18);
  if (result)
  {
    v6 = *(void **)(*(_QWORD *)(result + 48) + 16);
    if (v6 == &mlir::detail::TypeIDResolver<mlir::tensor::FromElementsOp,void>::id)
      v7 = result;
    else
      v7 = 0;
    if (v6 != &mlir::detail::TypeIDResolver<mlir::tensor::FromElementsOp,void>::id)
      return 0;
    v8 = (_QWORD *)(*(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
    if (v8)
    {
      v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v8 + 8);
      v18 = v8;
      v19 = v9;
      result = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v18);
      if (!(_DWORD)result)
        return result;
    }
    else
    {
      v18 = 0;
      v19 = 0;
      result = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v18);
      if (!(_DWORD)result)
        return result;
    }
    Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v18);
    if (v11)
    {
      v12 = 8 * v11;
      while (*Shape != 0x8000000000000000)
      {
        ++Shape;
        v12 -= 8;
        if (!v12)
          goto LABEL_16;
      }
      return 0;
    }
    else
    {
LABEL_16:
      v17 = *(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
      if ((*(_BYTE *)(v7 + 46) & 0x80) != 0)
      {
        v13 = *(unsigned int *)(v7 + 68);
        v14 = *(_QWORD *)(v7 + 72);
      }
      else
      {
        v14 = 0;
        v13 = 0;
      }
      v16[0] = v14;
      v16[1] = v13;
      v15 = mlir::OpBuilder::create<mlir::tensor::FromElementsOp,mlir::RankedTensorType,mlir::OperandRange>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v17, (uint64_t)v16);
      (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, a2, v15);
      return 1;
    }
  }
  return result;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::FromElementsOp,mlir::RankedTensorType,mlir::OperandRange>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  unsigned int v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  _QWORD v22[8];
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  _QWORD v26[29];

  v26[28] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.from_elements", (const unsigned __int8 *)0x14, Context);
  if (!v10)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"tensor.from_elements";
    v19[3] = 20;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v22);
    llvm::report_fatal_error((llvm::Twine *)v22, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v9);
  v11 = *a3;
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(_QWORD *)(a4 + 8));
  mlir::OperationState::addOperands((uint64_t)v22, v21[0], v21[1]);
  v12 = v24;
  if (v24 >= v25)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v23, v26, v24 + 1, 8);
    v12 = v24;
  }
  *(_QWORD *)(v23 + 8 * v12) = v11;
  ++v24;
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::FromElementsOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v14;
}

void `anonymous namespace'::FoldDimOfExpandShape::~FoldDimOfExpandShape(_anonymous_namespace_::FoldDimOfExpandShape *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::FoldDimOfExpandShape::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::IndexType **a3)
{
  uint64_t result;
  uint64_t v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  unint64_t ConstantIntValue;
  char v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  unsigned int v16;
  unsigned int v18;
  _QWORD *v19;
  uint64_t v20;
  char *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  mlir::MLIRContext *Context;
  mlir::MLIRContext *v28;
  ZinIrHalH13g *v29;
  uint64_t v30;
  mlir::MLIRContext **AffineSymbolExpr;
  uint64_t CorrespondingSourceDim;
  unint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  _QWORD v40[3];

  v40[2] = *MEMORY[0x24BDAC8D0];
  v35 = *(void **)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v35);
  if (!result)
    return result;
  v6 = result;
  v7 = *(void **)(*(_QWORD *)(result + 48) + 16);
  v8 = v7 == &mlir::detail::TypeIDResolver<mlir::tensor::ExpandShapeOp,void>::id;
  if (v7 == &mlir::detail::TypeIDResolver<mlir::tensor::ExpandShapeOp,void>::id)
    v9 = result;
  else
    v9 = 0;
  v34 = v9;
  if (!v8)
    return 0;
  ConstantIntValue = mlir::getConstantIntValue(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 56) | 4);
  if (!v11)
    return 0;
  v12 = ConstantIntValue;
  v13 = *(_DWORD *)(v6 + 36) ? v6 - 16 : 0;
  v33 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v13, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v33) + 8 * v12) != 0x8000000000000000)
    return 0;
  CorrespondingSourceDim = mlir::tensor::ExpandShapeOp::getCorrespondingSourceDim((mlir::tensor::ExpandShapeOp *)&v34, v12);
  mlir::memref::CollapseShapeOp::getReassociationIndices((mlir::memref::CollapseShapeOp *)&v34, (uint64_t)&v35);
  v14 = (char *)v35;
  v15 = (char *)v35 + 32 * CorrespondingSourceDim;
  v38 = v40;
  v39 = 0x200000000;
  v16 = *((_DWORD *)v15 + 2);
  if (&v38 != (_QWORD **)v15 && v16 != 0)
  {
    if (v16 < 3)
    {
      v19 = v40;
      v18 = *((_DWORD *)v15 + 2);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v40, *((unsigned int *)v15 + 2), 8);
      v18 = *((_DWORD *)v15 + 2);
      if (!v18)
      {
LABEL_22:
        LODWORD(v39) = v16;
        v14 = (char *)v35;
        goto LABEL_23;
      }
      v19 = v38;
    }
    memcpy(v19, *(const void **)v15, 8 * v18);
    goto LABEL_22;
  }
LABEL_23:
  if (v36)
  {
    v20 = 32 * v36;
    do
    {
      v21 = *(char **)&v14[v20 - 32];
      if (&v14[v20 - 16] != v21)
        free(v21);
      v20 -= 32;
    }
    while (v20);
    v14 = (char *)v35;
  }
  if (v14 != (char *)&v37)
    free(v14);
  if ((_DWORD)v39)
  {
    v22 = v38;
    v23 = 8 * v39;
    v24 = 1;
    do
    {
      if (*v22 != v12)
      {
        v25 = *v22;
        v24 *= *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v33) + 8 * v25);
      }
      ++v22;
      v23 -= 8;
    }
    while (v23);
  }
  else
  {
    v24 = 1;
  }
  v26 = *(_QWORD *)(a2 + 24);
  AffineSymbolExpr = *(mlir::MLIRContext ***)(*(_QWORD *)(v34 + 72) + 24);
  v35 = (char *)mlir::OpBuilder::create<mlir::tensor::DimOp,mlir::detail::TypedValue<mlir::RankedTensorType>,long long &>(a3 + 1, v26, (uint64_t *)&AffineSymbolExpr, (mlir::MLIRContext **)&CorrespondingSourceDim)- 16;
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  AffineSymbolExpr = (mlir::MLIRContext **)mlir::getAffineSymbolExpr(0, Context, v28);
  v30 = mlir::AffineExpr::floorDiv(&AffineSymbolExpr, v24);
  v29 = mlir::OpBuilder::create<mlir::affine::AffineApplyOp,mlir::AffineExpr,mlir::Value &>(a3 + 1, *(_QWORD *)(a2 + 24), (mlir::AffineExpr *)&v30, (uint64_t)&v35);
  (*((void (**)(mlir::IndexType **, uint64_t, ZinIrHalH13g *))*a3 + 4))(a3, a2, v29);
  if (v38 != v40)
    free(v38);
  return 1;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::DimOp,mlir::detail::TypedValue<mlir::RankedTensorType>,long long &>(mlir::IndexType **a1, uint64_t a2, uint64_t *a3, mlir::MLIRContext **a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  ZinIrHalH13g *v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  mlir::MLIRContext *v19[4];
  __int16 v20;
  uint64_t v21[39];

  v21[38] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.dim", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    v20 = 1283;
    v19[2] = (mlir::MLIRContext *)"tensor.dim";
    v19[3] = (mlir::MLIRContext *)10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+((uint64_t *)v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  v11 = *a3;
  v19[0] = *a4;
  v12 = mlir::OpBuilder::create<mlir::arith::ConstantIndexOp,long long>(a1, v21[0], v19);
  mlir::tensor::DimOp::build(a1, (uint64_t)v21, v11, (uint64_t)v12 - 16);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::DimOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::affine::AffineApplyOp,mlir::AffineExpr,mlir::Value &>(mlir::IndexType **a1, uint64_t a2, mlir::AffineExpr *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  ZinIrHalH13g *v11;
  ZinIrHalH13g *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x24BDAC8D0];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"affine.apply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"affine.apply";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::affine::AffineApplyOp::build(a1, (uint64_t)v19, a3, (mlir::AffineExpr *)1, a4, 1);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::affine::AffineApplyOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void `anonymous namespace'::FoldDimOfCollapseShape::~FoldDimOfCollapseShape(_anonymous_namespace_::FoldDimOfCollapseShape *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::FoldDimOfCollapseShape::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::IndexType **a3)
{
  uint64_t result;
  void *v6;
  BOOL v7;
  uint64_t v8;
  unint64_t ConstantIntValue;
  char v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  unsigned int v15;
  unsigned int v17;
  _QWORD *v18;
  uint64_t v19;
  char *v20;
  mlir *v21;
  mlir::MLIRContext **v22;
  uint64_t v23;
  uint64_t v24;
  mlir::MLIRContext *v25;
  ZinIrHalH13g *v26;
  uint64_t v27;
  uint64_t AffineSymbolExpr;
  uint64_t v29;
  unint64_t v30;
  ZinIrHalH13g *v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  _BYTE v38[48];
  void *v39;
  uint64_t v40;
  _BYTE v41[128];
  _QWORD *v42;
  uint64_t v43;
  _QWORD v44[4];

  v44[2] = *MEMORY[0x24BDAC8D0];
  v39 = *(void **)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v39);
  if (!result)
    return result;
  v6 = *(void **)(*(_QWORD *)(result + 48) + 16);
  v7 = v6 == &mlir::detail::TypeIDResolver<mlir::tensor::CollapseShapeOp,void>::id;
  if (v6 == &mlir::detail::TypeIDResolver<mlir::tensor::CollapseShapeOp,void>::id)
    v8 = result;
  else
    v8 = 0;
  v35 = v8;
  if (!v7)
    return 0;
  ConstantIntValue = mlir::getConstantIntValue(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 56) | 4);
  if (!v10)
    return 0;
  v11 = ConstantIntValue;
  v12 = *(_DWORD *)(v35 + 36) ? v35 - 16 : 0;
  v34 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v12, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v34) + 8 * v11) != 0x8000000000000000)
    return 0;
  mlir::memref::CollapseShapeOp::getReassociationIndices((mlir::memref::CollapseShapeOp *)&v35, (uint64_t)&v39);
  v13 = (char *)v39;
  v14 = (char *)v39 + 32 * v11;
  v42 = v44;
  v43 = 0x200000000;
  v15 = *((_DWORD *)v14 + 2);
  if (&v42 != (_QWORD **)v14 && v15 != 0)
  {
    if (v15 < 3)
    {
      v18 = v44;
      v17 = *((_DWORD *)v14 + 2);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v42, v44, *((unsigned int *)v14 + 2), 8);
      v17 = *((_DWORD *)v14 + 2);
      if (!v17)
      {
LABEL_22:
        LODWORD(v43) = v15;
        v13 = (char *)v39;
        goto LABEL_23;
      }
      v18 = v42;
    }
    memcpy(v18, *(const void **)v14, 8 * v17);
    goto LABEL_22;
  }
LABEL_23:
  if ((_DWORD)v40)
  {
    v19 = 32 * v40;
    do
    {
      v20 = *(char **)&v13[v19 - 32];
      if (&v13[v19 - 16] != v20)
        free(v20);
      v19 -= 32;
    }
    while (v19);
    v13 = (char *)v39;
  }
  if (v13 != v41)
    free(v13);
  v39 = v41;
  v40 = 0x600000000;
  v36 = v38;
  v37 = 0x600000000;
  v33 = 0;
  if ((_DWORD)v43)
  {
    v21 = 0;
    v22 = (mlir::MLIRContext **)v42;
    v23 = 8 * v43;
    do
    {
      v24 = *(_QWORD *)(a2 + 24);
      v32 = *(_QWORD *)(*(_QWORD *)(v35 + 72) + 24);
      v26 = mlir::OpBuilder::create<mlir::tensor::DimOp,mlir::detail::TypedValue<mlir::RankedTensorType>,long long &>(a3 + 1, v24, &v32, v22);
      v27 = v40;
      if (v40 >= (unint64_t)HIDWORD(v40))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v41, v40 + 1, 8);
        v27 = v40;
      }
      *((_QWORD *)v39 + v27) = (char *)v26 - 16;
      LODWORD(v40) = v40 + 1;
      AffineSymbolExpr = mlir::Builder::getAffineSymbolExpr(a3 + 1, v21, v25);
      v29 = v37;
      if (v37 >= (unint64_t)HIDWORD(v37))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v36, v38, v37 + 1, 8);
        v29 = v37;
      }
      *((_QWORD *)v36 + v29) = AffineSymbolExpr;
      LODWORD(v37) = v37 + 1;
      v30 = *((_QWORD *)v36 + v37 - 1);
      if (v33)
        v30 = mlir::AffineExpr::operator*(&v33, v30);
      v33 = v30;
      v21 = (mlir *)((_DWORD)v21 + 1);
      ++v22;
      v23 -= 8;
    }
    while (v23);
  }
  v31 = mlir::OpBuilder::create<mlir::affine::AffineApplyOp,mlir::AffineExpr &,llvm::SmallVector<mlir::Value,6u> &>(a3 + 1, *(_QWORD *)(a2 + 24), (mlir::AffineExpr *)&v33, (uint64_t)&v39);
  (*((void (**)(mlir::IndexType **, uint64_t, ZinIrHalH13g *))*a3 + 4))(a3, a2, v31);
  if (v36 != v38)
    free(v36);
  if (v39 != v41)
    free(v39);
  if (v42 != v44)
    free(v42);
  return 1;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::affine::AffineApplyOp,mlir::AffineExpr &,llvm::SmallVector<mlir::Value,6u> &>(mlir::IndexType **a1, uint64_t a2, mlir::AffineExpr *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  ZinIrHalH13g *v11;
  ZinIrHalH13g *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x24BDAC8D0];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"affine.apply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"affine.apply";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::affine::AffineApplyOp::build(a1, (uint64_t)v20, a3, (mlir::AffineExpr *)1, v19[0], v19[1]);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::affine::AffineApplyOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

void mlir::RewritePatternSet::addImpl<mlir::ComposeReassociativeReshapeOps<mlir::tensor::CollapseShapeOp>,mlir::MLIRContext *&>(_QWORD *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  const char *v18;
  unint64_t v19;
  uint64_t v20;
  const char *v21;
  unint64_t v22;
  uint64_t v23;
  const char *v24;
  unint64_t v25;

  v8 = operator new();
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v24, 1);
  mlir::Pattern::Pattern(v8 + 8, (uint64_t)"tensor.collapse_shape", 21, (__int16)v24, v9, 0, 0);
  *(_QWORD *)v8 = &unk_24C04FCB0;
  v23 = v8;
  if (*(_QWORD *)(v8 + 72))
  {
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
      goto LABEL_3;
  }
  else
  {
    v24 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ComposeReassociativeReshapeOps<mlir::tensor::CollapseShapeOp>]";
    v25 = 117;
    v16 = llvm::StringRef::find((uint64_t *)&v24, "DesiredTypeName = ", 0x12uLL, 0);
    if (v25 >= v16)
      v17 = v16;
    else
      v17 = v25;
    v18 = &v24[v17];
    v19 = v25 - v17;
    if (v25 - v17 >= 0x12)
      v20 = 18;
    else
      v20 = v25 - v17;
    v21 = &v18[v20];
    v22 = v19 - v20;
    if (v22 >= v22 - 1)
      --v22;
    *(_QWORD *)(v8 + 64) = v21;
    *(_QWORD *)(v8 + 72) = v22;
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
    {
LABEL_3:
      if (!a3)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod(v8 + 80, (void *)(v8 + 96), v12, 16);
  LODWORD(v11) = *(_DWORD *)(v8 + 88);
  if (a3)
  {
LABEL_4:
    memcpy((void *)(*(_QWORD *)(v8 + 80) + 16 * v11), a2, v10);
    LODWORD(v11) = *(_DWORD *)(v8 + 88);
  }
LABEL_5:
  *(_DWORD *)(v8 + 88) = v11 + (v10 >> 4);
  v13 = (uint64_t *)a1[2];
  if ((unint64_t)v13 >= a1[3])
  {
    v14 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, &v23);
    v15 = v23;
    a1[2] = v14;
    v23 = 0;
    if (v15)
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  }
  else
  {
    *v13 = v8;
    a1[2] = v13 + 1;
  }
}

void mlir::RewritePatternSet::addImpl<mlir::ComposeCollapseOfExpandOp<mlir::tensor::CollapseShapeOp,mlir::tensor::ExpandShapeOp,mlir::tensor::CastOp>,mlir::MLIRContext *&>(_QWORD *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  const char *v18;
  unint64_t v19;
  uint64_t v20;
  const char *v21;
  unint64_t v22;
  uint64_t v23;
  const char *v24;
  unint64_t v25;

  v8 = operator new();
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v24, 1);
  mlir::Pattern::Pattern(v8 + 8, (uint64_t)"tensor.collapse_shape", 21, (__int16)v24, v9, 0, 0);
  *(_QWORD *)v8 = &unk_24C04F8E0;
  v23 = v8;
  if (*(_QWORD *)(v8 + 72))
  {
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
      goto LABEL_3;
  }
  else
  {
    v24 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ComposeCollapseOfExpandOp<mlir::tensor::CollapseShapeOp"
          ", mlir::tensor::ExpandShapeOp, mlir::tensor::CastOp>]";
    v25 = 163;
    v16 = llvm::StringRef::find((uint64_t *)&v24, "DesiredTypeName = ", 0x12uLL, 0);
    if (v25 >= v16)
      v17 = v16;
    else
      v17 = v25;
    v18 = &v24[v17];
    v19 = v25 - v17;
    if (v25 - v17 >= 0x12)
      v20 = 18;
    else
      v20 = v25 - v17;
    v21 = &v18[v20];
    v22 = v19 - v20;
    if (v22 >= v22 - 1)
      --v22;
    *(_QWORD *)(v8 + 64) = v21;
    *(_QWORD *)(v8 + 72) = v22;
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
    {
LABEL_3:
      if (!a3)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod(v8 + 80, (void *)(v8 + 96), v12, 16);
  LODWORD(v11) = *(_DWORD *)(v8 + 88);
  if (a3)
  {
LABEL_4:
    memcpy((void *)(*(_QWORD *)(v8 + 80) + 16 * v11), a2, v10);
    LODWORD(v11) = *(_DWORD *)(v8 + 88);
  }
LABEL_5:
  *(_DWORD *)(v8 + 88) = v11 + (v10 >> 4);
  v13 = (uint64_t *)a1[2];
  if ((unint64_t)v13 >= a1[3])
  {
    v14 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, &v23);
    v15 = v23;
    a1[2] = v14;
    v23 = 0;
    if (v15)
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  }
  else
  {
    *v13 = v8;
    a1[2] = v13 + 1;
  }
}

_QWORD *mlir::ComposeReassociativeReshapeOps<mlir::tensor::CollapseShapeOp>::~ComposeReassociativeReshapeOps(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::ComposeReassociativeReshapeOps<mlir::tensor::CollapseShapeOp>::~ComposeReassociativeReshapeOps(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::CollapseShapeOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::CollapseShapeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::CollapseShapeOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::ComposeReassociativeReshapeOps<mlir::tensor::CollapseShapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t NextResultAtOffset;
  void *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  ZinIrHalH13g *v24;
  char *v25;
  uint64_t v26;
  char *v27;
  uint64_t v28[2];
  uint64_t v29;
  uint64_t v30;
  void *v31;
  unsigned int v32;
  uint64_t v33;
  void *v34;
  unsigned int v35;
  uint64_t v36;
  char *v37;
  unsigned int v38;
  uint64_t v39;
  char v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v30 = a2;
  v34 = *(void **)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v34);
  if (result)
  {
    v6 = result;
    v7 = *(void **)(*(_QWORD *)(result + 48) + 16);
    v8 = v7 == &mlir::detail::TypeIDResolver<mlir::tensor::CollapseShapeOp,void>::id;
    if (v7 == &mlir::detail::TypeIDResolver<mlir::tensor::CollapseShapeOp,void>::id)
      v9 = result;
    else
      v9 = 0;
    v29 = v9;
    if (!v8)
      return 0;
    v10 = *(_DWORD *)(a2 + 36) ? a2 - 16 : 0;
    v11 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    v12 = v11 ? mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v11 + 8) : 0;
    v28[0] = (uint64_t)v11;
    v28[1] = v12;
    if ((mlir::hasNonIdentityLayout(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0
      || (mlir::hasNonIdentityLayout(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0)
    {
      return 0;
    }
    v13 = *(_DWORD *)(a2 + 36) ? a2 - 16 : 0;
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v13, 0);
    if ((mlir::hasNonIdentityLayout(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0)
      return 0;
    mlir::memref::CollapseShapeOp::getReassociationIndices((mlir::memref::CollapseShapeOp *)&v29, (uint64_t)&v34);
    v15 = v34;
    v16 = v35;
    mlir::memref::CollapseShapeOp::getReassociationIndices((mlir::memref::CollapseShapeOp *)&v30, (uint64_t)&v31);
    mlir::composeReassociationIndices((uint64_t)v15, v16, (uint64_t)v31, v32, (uint64_t)&v37);
    v17 = (char *)v31;
    if (v32)
    {
      v18 = 32 * v32;
      do
      {
        v19 = *(char **)&v17[v18 - 32];
        if (&v17[v18 - 16] != v19)
          free(v19);
        v18 -= 32;
      }
      while (v18);
      v17 = (char *)v31;
    }
    if (v17 != (char *)&v33)
      free(v17);
    v20 = (char *)v34;
    if (v35)
    {
      v21 = 32 * v35;
      do
      {
        v22 = *(char **)&v20[v21 - 32];
        if (&v20[v21 - 16] != v22)
          free(v22);
        v21 -= 32;
      }
      while (v21);
      v20 = (char *)v34;
    }
    if (v20 != (char *)&v36)
      free(v20);
    if (!v40)
    {
      return 0;
    }
    else
    {
      v23 = v30;
      v34 = *(void **)(*(_QWORD *)(v29 + 72) + 24);
      v24 = mlir::OpBuilder::create<mlir::tensor::CollapseShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(a3 + 1, *(_QWORD *)(v30 + 24), v28, (uint64_t *)&v34, (uint64_t)&v37);
      (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a3 + 32))(a3, v23, v24);
      if (v40)
      {
        v25 = v37;
        if (v38)
        {
          v26 = 32 * v38;
          do
          {
            v27 = *(char **)&v25[v26 - 32];
            if (&v25[v26 - 16] != v27)
              free(v27);
            v26 -= 32;
          }
          while (v26);
          v25 = v37;
        }
        if (v25 != (char *)&v39)
          free(v25);
      }
      return 1;
    }
  }
  return result;
}

_QWORD *mlir::ComposeCollapseOfExpandOp<mlir::tensor::CollapseShapeOp,mlir::tensor::ExpandShapeOp,mlir::tensor::CastOp>::~ComposeCollapseOfExpandOp(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::ComposeCollapseOfExpandOp<mlir::tensor::CollapseShapeOp,mlir::tensor::ExpandShapeOp,mlir::tensor::CastOp>::~ComposeCollapseOfExpandOp(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::ComposeCollapseOfExpandOp<mlir::tensor::CollapseShapeOp,mlir::tensor::ExpandShapeOp,mlir::tensor::CastOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t DefiningOp;
  void *v6;
  BOOL v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t NextResultAtOffset;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v22;
  char *v23;
  char *v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  void *v29;
  uint64_t v30;
  ZinIrHalH13g *v31;
  uint64_t v32;
  mlir::OpBuilder *v33;
  ZinIrHalH13g *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  char *v38;
  uint64_t v39;
  char *v40;
  char *v41;
  uint64_t v42;
  char *v43;
  uint64_t v44[2];
  _QWORD v45[2];
  uint64_t v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  _BYTE v50[16];
  void *v51;
  uint64_t v52;
  _BYTE v53[128];
  void *v54;
  uint64_t v55;
  _BYTE v56[128];
  char *v57;
  uint64_t v58;
  _QWORD v59[18];

  v4 = a2;
  v59[16] = *MEMORY[0x24BDAC8D0];
  v47 = a2;
  v57 = *(char **)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v57);
  if (!DefiningOp)
    return 0;
  v6 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
  v7 = v6 == &mlir::detail::TypeIDResolver<mlir::tensor::ExpandShapeOp,void>::id;
  v8 = v6 == &mlir::detail::TypeIDResolver<mlir::tensor::ExpandShapeOp,void>::id ? DefiningOp : 0;
  v46 = v8;
  if (!v7)
    return 0;
  v9 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v9)
  {
    v10 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v9 + 8);
    v4 = v47;
  }
  else
  {
    v10 = 0;
  }
  v45[0] = v9;
  v45[1] = v10;
  v11 = *(_DWORD *)(v4 + 36) ? v4 - 16 : 0;
  v12 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v13 = v12 ? mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v12 + 8) : 0;
  v44[0] = (uint64_t)v12;
  v44[1] = v13;
  if ((mlir::hasNonIdentityLayout(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v47 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0
    || (mlir::hasNonIdentityLayout(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v46 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0)
  {
    return 0;
  }
  v14 = *(_DWORD *)(v46 + 36) ? v46 - 16 : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v14, 0);
  if ((mlir::hasNonIdentityLayout(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0)
    return 0;
  mlir::ShapedType::getShape((mlir::ShapedType *)v45);
  v17 = v16;
  mlir::ShapedType::getShape((mlir::ShapedType *)v44);
  if (v45[0] == v44[0])
    return 0;
  v19 = v18;
  v57 = (char *)v59;
  v58 = 0x400000000;
  v54 = v56;
  v55 = 0x400000000;
  if (v17 <= v18)
  {
    mlir::memref::CollapseShapeOp::getReassociationIndices((mlir::memref::CollapseShapeOp *)&v47, (uint64_t)&v51);
    llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=((uint64_t)&v57, (uint64_t)&v51);
    llvm::SmallVector<llvm::SmallVector<long long,2u>,4u>::~SmallVector((char **)&v51);
    mlir::memref::CollapseShapeOp::getReassociationIndices((mlir::memref::CollapseShapeOp *)&v46, (uint64_t)&v51);
  }
  else
  {
    mlir::memref::CollapseShapeOp::getReassociationIndices((mlir::memref::CollapseShapeOp *)&v46, (uint64_t)&v51);
    llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=((uint64_t)&v57, (uint64_t)&v51);
    llvm::SmallVector<llvm::SmallVector<long long,2u>,4u>::~SmallVector((char **)&v51);
    mlir::memref::CollapseShapeOp::getReassociationIndices((mlir::memref::CollapseShapeOp *)&v47, (uint64_t)&v51);
  }
  llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=((uint64_t)&v54, (uint64_t)&v51);
  llvm::SmallVector<llvm::SmallVector<long long,2u>,4u>::~SmallVector((char **)&v51);
  v51 = v53;
  v52 = 0x400000000;
  if (!(_DWORD)v55)
    goto LABEL_43;
  v22 = 0;
  v23 = (char *)v54;
  v24 = (char *)v54 + 32 * v55;
  do
  {
    v25 = 0;
    v48 = v50;
    v49 = 0x200000000;
    v26 = 32 * v22;
    while (1)
    {
      if (v22 >= v58)
      {
LABEL_36:
        llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::push_back((uint64_t)&v51, (unint64_t)&v48);
        v28 = 1;
        v29 = v48;
        if (v48 == v50)
          goto LABEL_38;
LABEL_37:
        free(v29);
        goto LABEL_38;
      }
      v27 = *(_QWORD *)(*(_QWORD *)&v57[v26] + 8 * *(unsigned int *)&v57[v26 + 8] - 8);
      if (v27 > *(_QWORD *)(*(_QWORD *)v23 + 8 * *((unsigned int *)v23 + 2) - 8))
        break;
      if (v25 >= HIDWORD(v49))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v50, v25 + 1, 8);
        v25 = v49;
      }
      *((_QWORD *)v48 + v25) = v22;
      v25 = v49 + 1;
      LODWORD(v49) = v49 + 1;
      v26 += 32;
      ++v22;
      if (v27 == *(_QWORD *)(*(_QWORD *)v23 + 8 * *((unsigned int *)v23 + 2) - 8))
        goto LABEL_36;
    }
    v28 = 0;
    v29 = v48;
    if (v48 != v50)
      goto LABEL_37;
LABEL_38:
    if ((v28 & 1) == 0)
    {
      v20 = 0;
      goto LABEL_51;
    }
    v23 += 32;
  }
  while (v23 != v24);
LABEL_43:
  if (v17 <= v19)
  {
    v32 = v47;
    v33 = (mlir::OpBuilder *)(a3 + 1);
    v48 = *(void **)(*(_QWORD *)(v46 + 72) + 24);
    if (v17 >= v19)
      v34 = mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::TensorType &,mlir::Value>(v33, *(_QWORD *)(v47 + 24), v44, (uint64_t *)&v48);
    else
      v34 = mlir::OpBuilder::create<mlir::tensor::ExpandShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>((uint64_t *)v33, *(_QWORD *)(v47 + 24), v44, (uint64_t *)&v48, (uint64_t)&v51);
    (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a3 + 32))(a3, v32, v34);
  }
  else
  {
    v30 = v47;
    v48 = *(void **)(*(_QWORD *)(v46 + 72) + 24);
    v31 = mlir::OpBuilder::create<mlir::tensor::CollapseShapeOp,mlir::ShapedType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<llvm::SmallVector<long long,2u>,1u> &>(a3 + 1, *(_QWORD *)(v47 + 24), v44, (uint64_t *)&v48, (uint64_t)&v51);
    (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a3 + 32))(a3, v30, v31);
  }
  v20 = 1;
LABEL_51:
  v35 = (char *)v51;
  if ((_DWORD)v52)
  {
    v36 = 32 * v52;
    do
    {
      v37 = *(char **)&v35[v36 - 32];
      if (&v35[v36 - 16] != v37)
        free(v37);
      v36 -= 32;
    }
    while (v36);
    v35 = (char *)v51;
  }
  if (v35 != v53)
    free(v35);
  v38 = (char *)v54;
  if ((_DWORD)v55)
  {
    v39 = 32 * v55;
    do
    {
      v40 = *(char **)&v38[v39 - 32];
      if (&v38[v39 - 16] != v40)
        free(v40);
      v39 -= 32;
    }
    while (v39);
    v38 = (char *)v54;
  }
  if (v38 != v56)
    free(v38);
  v41 = v57;
  if ((_DWORD)v58)
  {
    v42 = 32 * v58;
    do
    {
      v43 = *(char **)&v41[v42 - 32];
      if (&v41[v42 - 16] != v43)
        free(v43);
      v42 -= 32;
    }
    while (v42);
    v41 = v57;
  }
  if (v41 != (char *)v59)
    free(v41);
  return v20;
}

_QWORD *`anonymous namespace'::FoldReshapeWithConstant<mlir::tensor::CollapseShapeOp>::~FoldReshapeWithConstant(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void `anonymous namespace'::FoldReshapeWithConstant<mlir::tensor::CollapseShapeOp>::~FoldReshapeWithConstant(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::FoldReshapeWithConstant<mlir::tensor::CollapseShapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t DefiningOp;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  unint64_t v10;
  unint64_t v11;
  char v12;
  char v13;
  uint64_t result;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t RawStringData;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  ZinIrHalH13g *v23;
  unint64_t v24;
  uint64_t v25;
  void *v26[2];
  _QWORD v27[2];

  v27[1] = *MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  v24 = 0;
  v25 = v5;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v25);
  if (!DefiningOp)
    return 0;
  v7 = DefiningOp;
  if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
    return 0;
  v26[0] = v27;
  v26[1] = (void *)0x100000000;
  mlir::Operation::fold(v7, 0, 0, (uint64_t)v26);
  v8 = *(_QWORD *)v26[0];
  v9 = mlir::DenseElementsAttr::classof(*(_QWORD *)v26[0] & 0xFFFFFFFFFFFFFFF8);
  v10 = 0;
  v11 = v8 & 0xFFFFFFFFFFFFFFF8;
  v12 = (v8 & 0xFFFFFFFFFFFFFFF8) == 0 || !v9;
  if ((v12 & 1) == 0)
  {
    v24 = v11;
    v10 = v11;
  }
  if (v26[0] != v27)
    free(v26[0]);
  v13 = v10 ? v12 : 1;
  if ((v13 & 1) != 0)
    return 0;
  result = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v24);
  if ((_DWORD)result)
  {
    if (*(_DWORD *)(a2 + 36))
      v15 = a2 - 16;
    else
      v15 = 0;
    v16 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v15, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v16)
      v17 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v16 + 8);
    else
      v17 = 0;
    RawStringData = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&v24);
    v26[0] = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v16, v17, RawStringData, v19, v20, v21, v22);
    v23 = mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::DenseElementsAttr &>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (_QWORD **)v26);
    (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, a2, v23);
    return 1;
  }
  return result;
}

_QWORD *`anonymous namespace'::FoldReshapeWithSplat<mlir::tensor::CollapseShapeOp>::~FoldReshapeWithSplat(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void `anonymous namespace'::FoldReshapeWithSplat<mlir::tensor::CollapseShapeOp>::~FoldReshapeWithSplat(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::FoldReshapeWithSplat<mlir::tensor::CollapseShapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  ZinIrHalH13g *v9;
  uint64_t v10;
  unint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (result)
  {
    v6 = result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::SplatOp,void>::id)
    {
      if (*(_DWORD *)(a2 + 36))
        v7 = a2 - 16;
      else
        v7 = 0;
      v8 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
      v10 = *(_QWORD *)(*(_QWORD *)(v6 + 72) + 24);
      v11 = v8;
      v9 = mlir::OpBuilder::create<mlir::tensor::SplatOp,mlir::RankedTensorType,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v11, &v10);
      (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, a2, v9);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_QWORD *`anonymous namespace'::FoldReshapeWithFromElements<mlir::tensor::CollapseShapeOp>::~FoldReshapeWithFromElements(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void `anonymous namespace'::FoldReshapeWithFromElements<mlir::tensor::CollapseShapeOp>::~FoldReshapeWithFromElements(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::FoldReshapeWithFromElements<mlir::tensor::CollapseShapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  void *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *Shape;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  ZinIrHalH13g *v15;
  _QWORD v16[2];
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;

  v18 = *(_QWORD **)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v18);
  if (result)
  {
    v6 = *(void **)(*(_QWORD *)(result + 48) + 16);
    if (v6 == &mlir::detail::TypeIDResolver<mlir::tensor::FromElementsOp,void>::id)
      v7 = result;
    else
      v7 = 0;
    if (v6 != &mlir::detail::TypeIDResolver<mlir::tensor::FromElementsOp,void>::id)
      return 0;
    v8 = (_QWORD *)(*(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
    if (v8)
    {
      v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v8 + 8);
      v18 = v8;
      v19 = v9;
      result = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v18);
      if (!(_DWORD)result)
        return result;
    }
    else
    {
      v18 = 0;
      v19 = 0;
      result = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v18);
      if (!(_DWORD)result)
        return result;
    }
    Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v18);
    if (v11)
    {
      v12 = 8 * v11;
      while (*Shape != 0x8000000000000000)
      {
        ++Shape;
        v12 -= 8;
        if (!v12)
          goto LABEL_16;
      }
      return 0;
    }
    else
    {
LABEL_16:
      v17 = *(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
      if ((*(_BYTE *)(v7 + 46) & 0x80) != 0)
      {
        v13 = *(unsigned int *)(v7 + 68);
        v14 = *(_QWORD *)(v7 + 72);
      }
      else
      {
        v14 = 0;
        v13 = 0;
      }
      v16[0] = v14;
      v16[1] = v13;
      v15 = mlir::OpBuilder::create<mlir::tensor::FromElementsOp,mlir::RankedTensorType,mlir::OperandRange>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v17, (uint64_t)v16);
      (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, a2, v15);
      return 1;
    }
  }
  return result;
}

void `anonymous namespace'::FoldCollapseOfCastOp::~FoldCollapseOfCastOp(_anonymous_namespace_::FoldCollapseOfCastOp *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::FoldCollapseOfCastOp::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  uint64_t v5;
  uint64_t result;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  char *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  ZinIrHalH13g *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void *v25;
  unsigned int v26;
  uint64_t v27;
  void *v28;
  unsigned int v29;
  _QWORD v30[17];

  v30[16] = *MEMORY[0x24BDAC8D0];
  v24 = a2;
  v28 = *(void **)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v28);
  if (!DefiningOp)
    return 0;
  v5 = DefiningOp;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id)
    return 0;
  result = mlir::tensor::preservesStaticInformation(*(_QWORD *)(DefiningOp - 8) & 0xFFFFFFFFFFFFFFF8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if ((_DWORD)result)
  {
    v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
    mlir::tensor::CollapseShapeOp::getReassociationExprs((mlir::tensor::CollapseShapeOp *)&v24, &v28);
    mlir::getSymbolLessAffineMaps((uint64_t)v28, v29, (uint64_t)&v25);
    v8 = (char *)v28;
    if (v29)
    {
      v9 = 32 * v29;
      do
      {
        v10 = *(char **)&v8[v9 - 32];
        if (&v8[v9 - 16] != v10)
          free(v10);
        v9 -= 32;
      }
      while (v9);
      v8 = (char *)v28;
    }
    if (v8 != (char *)v30)
      free(v8);
    v11 = (void *)mlir::tensor::CollapseShapeOp::inferCollapsedType(v7, (uint64_t *)v25, v26);
    v28 = v11;
    if (v25 != &v27)
      free(v25);
    if (*(_DWORD *)(v24 + 36))
      v12 = v24 - 16;
    else
      v12 = 0;
    if (v11 == (void *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v12, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      v17 = v24;
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 72))(a3, v24);
      v18 = *(uint64_t **)(v24 + 72);
      v19 = *(uint64_t **)(*(_QWORD *)(v5 + 72) + 24);
      v20 = (uint64_t *)v18[1];
      if (v20)
      {
        *v20 = *v18;
        if (*v18)
          *(_QWORD *)(*v18 + 8) = v18[1];
      }
      v18[3] = (uint64_t)v19;
      v18[1] = (uint64_t)v19;
      v21 = *v19;
      *v18 = *v19;
      if (v21)
        *(_QWORD *)(v21 + 8) = v18;
      *v19 = (uint64_t)v18;
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 80))(a3, v17);
    }
    else
    {
      v13 = *(_QWORD *)(v24 + 24);
      v23 = *(_QWORD *)(*(_QWORD *)(v5 + 72) + 24);
      v22 = *(_QWORD *)(v24 + 16 * (((unint64_t)*(unsigned int *)(v24 + 44) >> 23) & 1) + 64);
      v25 = mlir::OpBuilder::create<mlir::tensor::CollapseShapeOp,mlir::RankedTensorType &,mlir::detail::TypedValue<mlir::TensorType>,mlir::ArrayAttr>((mlir::OpBuilder *)(a3 + 8), v13, (uint64_t *)&v28, (uint64_t *)&v23, &v22);
      v14 = v24;
      if (*(_DWORD *)(v24 + 36))
        v15 = v24 - 16;
      else
        v15 = 0;
      v23 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v15, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
      v16 = mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::RankedTensorType,mlir::tensor::EmptyOp &>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(v14 + 24), (uint64_t *)&v23, &v25);
      (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, v14, v16);
    }
    return 1;
  }
  return result;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::CollapseShapeOp,mlir::RankedTensorType &,mlir::detail::TypedValue<mlir::TensorType>,mlir::ArrayAttr>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  ZinIrHalH13g *v16;
  ZinIrHalH13g *v17;
  uint64_t v19;
  const char *v20;
  __int16 v21;
  uint64_t v22[4];
  __int16 v23;
  _QWORD v24[8];
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  _QWORD v28[29];

  v28[28] = *MEMORY[0x24BDAC8D0];
  v19 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v19);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.collapse_shape", (const unsigned __int8 *)0x15, Context);
  if (!v12)
  {
    v23 = 1283;
    v22[2] = (uint64_t)"tensor.collapse_shape";
    v22[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v21 = 259;
    llvm::operator+(v22, (uint64_t *)&v20, (uint64_t)v24);
    llvm::report_fatal_error((llvm::Twine *)v24, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v11);
  v13 = *a3;
  v14 = *a5;
  v22[0] = *a4;
  mlir::OperationState::addOperands((uint64_t)v24, (uint64_t)v22, 1);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::Properties>(v24) = v14;
  v15 = v26;
  if (v26 >= v27)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v26 + 1, 8);
    v15 = v26;
  }
  *(_QWORD *)(v25 + 8 * v15) = v13;
  ++v26;
  v16 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (*(_UNKNOWN **)(*((_QWORD *)v16 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CollapseShapeOp,void>::id)
    v17 = v16;
  else
    v17 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v17;
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::ExtractSliceOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::ExtractSliceOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::ExtractSliceOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

void mlir::RewritePatternSet::addImpl<mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp,SliceReturnTypeCanonicalizer,SliceCanonicalizer>,mlir::MLIRContext *&>(_QWORD *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  unint64_t v18;
  unint64_t v19;
  const char *v20;
  unint64_t v21;
  uint64_t v22;
  const char *v23;
  unint64_t v24;
  uint64_t v25;
  const char *v26;
  unint64_t v27;

  v8 = operator new();
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v26, 1);
  mlir::Pattern::Pattern(v8 + 8, (uint64_t)"tensor.extract_slice", 20, (__int16)v26, v9, 0, 0);
  *(_QWORD *)v8 = &unk_24C050738;
  v25 = v8;
  if (*(_QWORD *)(v8 + 72))
  {
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
      goto LABEL_3;
  }
  else
  {
    v26 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir:"
          ":tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer>]";
    v27 = 185;
    v18 = llvm::StringRef::find((uint64_t *)&v26, "DesiredTypeName = ", 0x12uLL, 0);
    if (v27 >= v18)
      v19 = v18;
    else
      v19 = v27;
    v20 = &v26[v19];
    v21 = v27 - v19;
    if (v27 - v19 >= 0x12)
      v22 = 18;
    else
      v22 = v27 - v19;
    v23 = &v20[v22];
    v24 = v21 - v22;
    if (v24 >= v24 - 1)
      --v24;
    *(_QWORD *)(v8 + 64) = v23;
    *(_QWORD *)(v8 + 72) = v24;
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
    {
LABEL_3:
      if (!a3)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod(v8 + 80, (void *)(v8 + 96), v12, 16);
  LODWORD(v11) = *(_DWORD *)(v8 + 88);
  if (a3)
  {
LABEL_4:
    memcpy((void *)(*(_QWORD *)(v8 + 80) + 16 * v11), a2, v10);
    LODWORD(v11) = *(_DWORD *)(v8 + 88);
  }
LABEL_5:
  *(_DWORD *)(v8 + 88) = v11 + (v10 >> 4);
  v13 = (uint64_t *)a1[2];
  if ((unint64_t)v13 >= a1[3])
  {
    v14 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, &v25);
    v15 = v25;
    a1[2] = v14;
    v25 = 0;
    if (v15)
    {
      v16 = *(void **)(v15 + 80);
      if (v16 != (void *)(v15 + 96))
        free(v16);
      v17 = *(void **)(v15 + 32);
      if (v17 != (void *)(v15 + 48))
        free(v17);
      MEMORY[0x20BD002F8](v15, 0x10D1C403AF06869);
    }
  }
  else
  {
    *v13 = v8;
    a1[2] = v13 + 1;
  }
}

_QWORD *mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp,SliceReturnTypeCanonicalizer,SliceCanonicalizer>::~OpWithOffsetSizesAndStridesConstantArgumentFolder(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp,SliceReturnTypeCanonicalizer,SliceCanonicalizer>::~OpWithOffsetSizesAndStridesConstantArgumentFolder(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp,SliceReturnTypeCanonicalizer,SliceCanonicalizer>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  _BYTE *v5;
  unsigned int v6;
  int v7;
  _BYTE *v8;
  unsigned int v9;
  int v10;
  _BYTE *v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  ZinIrHalH13g *v24;
  uint64_t v25;
  void *v26;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  _BYTE v32[32];
  void *__dst;
  uint64_t v34;
  _BYTE v35[48];
  void *__src;
  uint64_t v37;
  _BYTE v38[48];
  _QWORD *v39;
  uint64_t v40;
  _QWORD v41[8];

  v41[6] = *MEMORY[0x24BDAC8D0];
  v29 = a2;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedOffsets((mlir::memref::ReinterpretCastOp *)&v29, (uint64_t)&__src);
  v39 = v41;
  v40 = 0x600000000;
  v4 = v37;
  v5 = __src;
  if ((_DWORD)v37)
  {
    if (__src == v38)
    {
      v6 = v37;
      if (v37 < 7
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v41, v37, 8),
            v6 = v37,
            v5 = __src,
            (_DWORD)v37))
      {
        memcpy(v39, v5, 8 * v6);
        v5 = __src;
      }
      LODWORD(v40) = v4;
    }
    else
    {
      v39 = __src;
      v40 = v37;
      __src = v38;
      HIDWORD(v37) = 0;
      v5 = v38;
    }
    LODWORD(v37) = 0;
  }
  if (v5 != v38)
    free(v5);
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedSizes((mlir::memref::ReinterpretCastOp *)&v29, (uint64_t)&__dst);
  __src = v38;
  v37 = 0x600000000;
  v7 = v34;
  v8 = __dst;
  if ((_DWORD)v34)
  {
    if (__dst == v35)
    {
      v9 = v34;
      if (v34 < 7
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v38, v34, 8),
            v9 = v34,
            v8 = __dst,
            (_DWORD)v34))
      {
        memcpy(__src, v8, 8 * v9);
        v8 = __dst;
      }
      LODWORD(v37) = v7;
    }
    else
    {
      __src = __dst;
      v37 = v34;
      __dst = v35;
      HIDWORD(v34) = 0;
      v8 = v35;
    }
    LODWORD(v34) = 0;
  }
  if (v8 != v35)
    free(v8);
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedStrides((mlir::memref::ReinterpretCastOp *)&v29, (uint64_t)&v30);
  __dst = v35;
  v34 = 0x600000000;
  v10 = v31;
  v11 = v30;
  if ((_DWORD)v31)
  {
    if (v30 == v32)
    {
      v12 = v31;
      if (v31 < 7
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v35, v31, 8),
            v12 = v31,
            v11 = v30,
            (_DWORD)v31))
      {
        memcpy(__dst, v11, 8 * v12);
        v11 = v30;
      }
      LODWORD(v34) = v10;
    }
    else
    {
      __dst = v30;
      v34 = v31;
      v30 = v32;
      HIDWORD(v31) = 0;
      v11 = v32;
    }
    LODWORD(v31) = 0;
  }
  if (v11 != v32)
    free(v11);
  if (mlir::foldDynamicIndexList((uint64_t)&v39, 1)
    || mlir::foldDynamicIndexList((uint64_t)&__src, 1)
    || mlir::foldDynamicIndexList((uint64_t)&__dst, 0))
  {
    v13 = a3;
    v14 = v29;
    v15 = v39;
    v16 = v40;
    v17 = (uint64_t *)__src;
    v18 = v37;
    v19 = (uint64_t *)__dst;
    v20 = v34;
    if (*(_DWORD *)(v29 + 36))
      v21 = v29 - 16;
    else
      v21 = 0;
    v30 = (void *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v21, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v30);
    v30 = (void *)mlir::tensor::ExtractSliceOp::inferCanonicalRankReducedResultType(v22, (void *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v14 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), v15, v16, v17, v18, v19, v20);
    if (v30)
    {
      v23 = *(_QWORD *)(v29 + 24);
      v28 = *(_QWORD *)(*(_QWORD *)(v29 + 72) + 24);
      v24 = mlir::OpBuilder::create<mlir::tensor::ExtractSliceOp,mlir::RankedTensorType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,4u>,llvm::SmallVector<mlir::OpFoldResult,4u>&,llvm::SmallVector<mlir::OpFoldResult,4u>>((mlir::MLIRContext **)(v13 + 8), v23, (uint64_t *)&v30, &v28, (uint64_t)&v39, (uint64_t)&__src, (uint64_t)&__dst);
      SliceCanonicalizer::operator()((uint64_t)&v28, v13, v29, (uint64_t)v24);
      v25 = 1;
    }
    else
    {
      v25 = 0;
    }
    v26 = __dst;
    if (__dst != v35)
      goto LABEL_41;
  }
  else
  {
    v25 = 0;
    v26 = __dst;
    if (__dst != v35)
LABEL_41:
      free(v26);
  }
  if (__src != v38)
    free(__src);
  if (v39 != v41)
    free(v39);
  return v25;
}

uint64_t SliceCanonicalizer::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v12;
  uint64_t NextResultAtOffset;

  if (*(_DWORD *)(a4 + 36))
    v6 = a4 - 16;
  else
    v6 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
  if (*(_DWORD *)(a3 + 36))
    v8 = a3 - 16;
  else
    v8 = 0;
  v7 = *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
  if (v7 != (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(_QWORD *)(a3 + 24);
    if (*(_DWORD *)(a3 + 36))
      v10 = a3 - 16;
    else
      v10 = 0;
    v12 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    NextResultAtOffset = (uint64_t)mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::TensorType &,mlir::Value>((mlir::OpBuilder *)(a2 + 8), v9, (uint64_t *)&v12, &NextResultAtOffset)- 16;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(_QWORD *)a2 + 24))(a2, a3, &NextResultAtOffset, 1);
}

void `anonymous namespace'::ExtractSliceOpCastFolder::~ExtractSliceOpCastFolder(_anonymous_namespace_::ExtractSliceOpCastFolder *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::ExtractSliceOpCastFolder::matchAndRewrite(uint64_t DefiningOp, uint64_t a2, mlir::MLIRContext **a3)
{
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  mlir::Operation *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  unsigned int *v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  ZinIrHalH13g *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v35;
  uint64_t v36[2];
  uint64_t v37[2];
  uint64_t v38[2];
  _QWORD v39[2];
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;

  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
  {
    v5 = *(unsigned int *)(a2 + 68);
    if ((_DWORD)v5)
    {
      v6 = (unint64_t *)(*(_QWORD *)(a2 + 72) + 24);
      do
      {
        v7 = *v6;
        ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)DefiningOp);
        v42 = v7;
        DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v42);
        if (DefiningOp)
        {
          DefiningOp = mlir::arith::ConstantIndexOp::classof(DefiningOp, v8);
          if ((DefiningOp & 1) != 0)
            return 0;
        }
        v6 += 4;
      }
      while (--v5);
    }
  }
  v42 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  v9 = mlir::Value::getDefiningOp((mlir::Value *)&v42);
  if (!v9)
    return 0;
  v10 = v9;
  if (*(_UNKNOWN **)(*(_QWORD *)(v9 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id
    || !mlir::tensor::preservesStaticInformation(*(_QWORD *)(v9 - 8) & 0xFFFFFFFFFFFFFFF8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    return 0;
  }
  v11 = *(_QWORD *)(a2 + 24);
  if (*(_DWORD *)(a2 + 36))
    v12 = a2 - 16;
  else
    v12 = 0;
  v13 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v12, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  v44 = *(_QWORD *)(*(_QWORD *)(v10 + 72) + 24);
  v45 = v13;
  v14 = *(unsigned int *)(a2 + 44);
  v15 = a2 + 64;
  v16 = (uint64_t *)(a2 + 64 + 16 * ((v14 >> 23) & 1));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v17 = (unsigned int *)(a2 + 64 + 16 * ((v14 >> 23) & 1));
  else
    v17 = 0;
  v18 = v17[6];
  v19 = v17[7];
  if ((v14 & 0x800000) != 0)
  {
    v20 = v19 + v18;
    v42 = *(_QWORD *)(a2 + 72) + 32 * v18;
    v43 = v20 - v18;
    v21 = v17[8] + v20;
    v40 = *(_QWORD *)(a2 + 72) + 32 * v20;
    v41 = v21 - v20;
    v22 = *(_QWORD *)(a2 + 72);
  }
  else
  {
    v22 = 0;
    v35 = v19 + v18;
    v42 = 32 * v18;
    v43 = v35 - v18;
    v21 = v17[8] + v35;
    v40 = 32 * v35;
    v41 = v21 - v35;
  }
  v23 = v17[9] + v21 - v21;
  v39[0] = v22 + 32 * v21;
  v39[1] = v23;
  v38[0] = *v16;
  v38[0] = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v38);
  v38[1] = v24;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v25 = v15 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1);
  else
    v25 = 0;
  v37[0] = *(_QWORD *)(v25 + 8);
  v37[0] = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v37);
  v37[1] = v26;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v27 = v15 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1);
  else
    v27 = 0;
  v36[0] = *(_QWORD *)(v27 + 16);
  v36[0] = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v36);
  v36[1] = v28;
  v29 = mlir::OpBuilder::create<mlir::tensor::ExtractSliceOp,mlir::RankedTensorType,mlir::detail::TypedValue<mlir::TensorType>,mlir::OperandRange,mlir::OperandRange,mlir::OperandRange,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>>(a3 + 1, v11, (uint64_t *)&v45, &v44, (uint64_t)&v42, (uint64_t)&v40, (uint64_t)v39, v38, v37, v36);
  v46 = (uint64_t)v29 - 16;
  v30 = *((_QWORD *)v29 - 1) & 0xFFFFFFFFFFFFFFF8;
  if (*(_DWORD *)(a2 + 36))
    v31 = a2 - 16;
  else
    v31 = 0;
  if (v30 != (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v31, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    if (*(_DWORD *)(a2 + 36))
      v32 = a2 - 16;
    else
      v32 = 0;
    v42 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v32, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v46 = (uint64_t)mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::TensorType &,mlir::Value>((mlir::OpBuilder *)(a3 + 1), v11, (uint64_t *)&v42, &v46)- 16;
  }
  v33 = 1;
  (*((void (**)(mlir::MLIRContext **, uint64_t, uint64_t *, uint64_t))*a3 + 3))(a3, a2, &v46, 1);
  return v33;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::ExtractSliceOp,mlir::RankedTensorType,mlir::detail::TypedValue<mlir::TensorType>,mlir::OperandRange,mlir::OperandRange,mlir::OperandRange,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, uint64_t *a9, uint64_t *a10)
{
  uint64_t *Context;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  ZinIrHalH13g *v23;
  ZinIrHalH13g *v24;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29[4];
  __int16 v30;
  unint64_t v31[2];
  unint64_t v32[2];
  unint64_t v33[2];
  _QWORD v34[40];

  v34[38] = *MEMORY[0x24BDAC8D0];
  v26 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.extract_slice", (const unsigned __int8 *)0x14, Context);
  if (!v20)
  {
    v30 = 1283;
    v29[2] = (uint64_t)"tensor.extract_slice";
    v29[3] = 20;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v34);
    llvm::report_fatal_error((llvm::Twine *)v34, 1);
  }
  mlir::OperationState::OperationState(v34, a2, v19);
  v21 = *a3;
  v22 = *a4;
  mlir::ValueRange::ValueRange(v33, *(_QWORD *)a5, *(_QWORD *)(a5 + 8));
  mlir::ValueRange::ValueRange(v32, *(_QWORD *)a6, *(_QWORD *)(a6 + 8));
  mlir::ValueRange::ValueRange(v31, *(_QWORD *)a7, *(_QWORD *)(a7 + 8));
  mlir::tensor::ExtractSliceOp::build(a1, (uint64_t)v34, v21, v22, v33[0], v33[1], v32[0], v32[1], v31[0], v31[1], *a8, a8[1], *a9, a9[1], *a10, a10[1]);
  v23 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v34);
  if (*(_UNKNOWN **)(*((_QWORD *)v23 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::ExtractSliceOp,void>::id)
    v24 = v23;
  else
    v24 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v34);
  return v24;
}

_QWORD *`anonymous namespace'::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp>::~InsertSliceOpConstantArgumentFolder(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void `anonymous namespace'::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp>::~InsertSliceOpConstantArgumentFolder(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::InsertSliceOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::InsertSliceOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::InsertSliceOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t `anonymous namespace'::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  _BYTE *v5;
  unsigned int v6;
  int v7;
  _BYTE *v8;
  unsigned int v9;
  int v10;
  _BYTE *v11;
  unsigned int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t NextResultAtOffset;
  _OWORD *v17;
  uint64_t v18;
  uint64_t v19;
  ZinIrHalH13g *v20;
  uint64_t v21;
  void *v22;
  __int128 v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  _BYTE v30[32];
  void *__dst;
  uint64_t v32;
  _BYTE v33[48];
  void *__src;
  uint64_t v35;
  _BYTE v36[48];
  _QWORD *v37;
  uint64_t v38;
  _QWORD v39[7];

  v39[6] = *MEMORY[0x24BDAC8D0];
  v27 = a2;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedOffsets((mlir::memref::ReinterpretCastOp *)&v27, (uint64_t)&__src);
  v37 = v39;
  v38 = 0x600000000;
  v4 = v35;
  v5 = __src;
  if ((_DWORD)v35)
  {
    if (__src == v36)
    {
      v6 = v35;
      if (v35 < 7
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v35, 8),
            v6 = v35,
            v5 = __src,
            (_DWORD)v35))
      {
        memcpy(v37, v5, 8 * v6);
        v5 = __src;
      }
      LODWORD(v38) = v4;
    }
    else
    {
      v37 = __src;
      v38 = v35;
      __src = v36;
      HIDWORD(v35) = 0;
      v5 = v36;
    }
    LODWORD(v35) = 0;
  }
  if (v5 != v36)
    free(v5);
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedSizes((mlir::memref::ReinterpretCastOp *)&v27, (uint64_t)&__dst);
  __src = v36;
  v35 = 0x600000000;
  v7 = v32;
  v8 = __dst;
  if ((_DWORD)v32)
  {
    if (__dst == v33)
    {
      v9 = v32;
      if (v32 < 7
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v36, v32, 8),
            v9 = v32,
            v8 = __dst,
            (_DWORD)v32))
      {
        memcpy(__src, v8, 8 * v9);
        v8 = __dst;
      }
      LODWORD(v35) = v7;
    }
    else
    {
      __src = __dst;
      v35 = v32;
      __dst = v33;
      HIDWORD(v32) = 0;
      v8 = v33;
    }
    LODWORD(v32) = 0;
  }
  if (v8 != v33)
    free(v8);
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedStrides((mlir::memref::ReinterpretCastOp *)&v27, (uint64_t)&v28);
  __dst = v33;
  v32 = 0x600000000;
  v10 = v29;
  v11 = v28;
  if ((_DWORD)v29)
  {
    if (v28 == v30)
    {
      v12 = v29;
      if (v29 < 7
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v33, v29, 8),
            v12 = v29,
            v11 = v28,
            (_DWORD)v29))
      {
        memcpy(__dst, v11, 8 * v12);
        v11 = v28;
      }
      LODWORD(v32) = v10;
    }
    else
    {
      __dst = v28;
      v32 = v29;
      v28 = v30;
      HIDWORD(v29) = 0;
      v11 = v30;
    }
    LODWORD(v29) = 0;
  }
  if (v11 != v30)
    free(v11);
  if (mlir::foldDynamicIndexList((uint64_t)&v37, 1)
    || mlir::foldDynamicIndexList((uint64_t)&__src, 1)
    || mlir::foldDynamicIndexList((uint64_t)&__dst, 0))
  {
    v26 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v27 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v26);
    v14 = v13;
    if (*(_DWORD *)(v27 + 36))
      v15 = v27 - 16;
    else
      v15 = 0;
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v15, 0);
    v28 = (void *)mlir::tensor::ExtractSliceOp::inferCanonicalRankReducedResultType(v14, (void *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), v37, v38, (uint64_t *)__src, v35, (uint64_t *)__dst, v32);
    v26 = *(_QWORD *)(*(_QWORD *)(v27 + 72) + 24);
    if (v28 != (void *)(*(_QWORD *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      v17 = (_OWORD *)(a3 + 24);
      v24 = *(_OWORD *)(a3 + 24);
      v26 = (unint64_t)mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::TensorType &,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(v27 + 24), (uint64_t *)&v28, (uint64_t *)&v26)- 16;
      if ((_QWORD)v24)
      {
        *v17 = v24;
      }
      else
      {
        *(_QWORD *)v17 = 0;
        *(_QWORD *)(a3 + 32) = 0;
      }
    }
    v18 = v27;
    if (*(_BYTE *)(v27 + 47))
      v19 = v27 + 80;
    else
      v19 = 0;
    v25 = *(_QWORD *)(*(_QWORD *)(v27 + 72) + 32 * *(unsigned int *)(v19 + 24) + 24);
    v20 = mlir::OpBuilder::create<mlir::tensor::InsertSliceOp,mlir::Value &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>((mlir::MLIRContext **)(a3 + 8), *(_QWORD *)(v27 + 24), (uint64_t *)&v26, &v25, (uint64_t)&v37, (uint64_t)&__src, (uint64_t)&__dst);
    (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, v18, v20);
    v21 = 1;
    v22 = __dst;
    if (__dst != v33)
      goto LABEL_45;
  }
  else
  {
    v21 = 0;
    v22 = __dst;
    if (__dst != v33)
LABEL_45:
      free(v22);
  }
  if (__src != v36)
    free(__src);
  if (v37 != v39)
    free(v37);
  return v21;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::InsertSliceOp,mlir::Value &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t *Context;
  uint64_t v15;
  char v16;
  ZinIrHalH13g *v17;
  ZinIrHalH13g *v18;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x24BDAC8D0];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.insert_slice", (const unsigned __int8 *)0x13, Context);
  if (!v16)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"tensor.insert_slice";
    v23[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::tensor::InsertSliceOp::build(a1, (uint64_t)v25, *a3, *a4, *(uint64_t **)a5, *(unsigned int *)(a5 + 8), *(uint64_t **)a6, *(unsigned int *)(a6 + 8), *(uint64_t **)a7, *(unsigned int *)(a7 + 8), 0, 0);
  v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((_QWORD *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::InsertSliceOp,void>::id)
    v18 = v17;
  else
    v18 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

_QWORD *`anonymous namespace'::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp>::~InsertSliceOpCastFolder(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void `anonymous namespace'::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp>::~InsertSliceOpCastFolder(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp>::matchAndRewrite(uint64_t DefiningOp, uint64_t a2, mlir::MLIRContext **a3)
{
  uint64_t v5;
  void **v6;
  void *v7;
  mlir::Operation *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t RHS;
  _QWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  ZinIrHalH13g *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46[2];
  void *v47[2];
  uint64_t v48;
  void *v49[2];
  uint64_t v50;
  void *v51[2];
  _QWORD v52[5];

  v52[4] = *MEMORY[0x24BDAC8D0];
  v45 = a2;
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
  {
    v5 = *(unsigned int *)(a2 + 68);
    if ((_DWORD)v5)
    {
      v6 = (void **)(*(_QWORD *)(a2 + 72) + 24);
      do
      {
        v7 = *v6;
        ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)DefiningOp);
        v51[0] = v7;
        DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v51);
        if (DefiningOp)
        {
          DefiningOp = mlir::arith::ConstantIndexOp::classof(DefiningOp, v8);
          if ((DefiningOp & 1) != 0)
            return 0;
        }
        v6 += 4;
      }
      while (--v5);
    }
  }
  v51[0] = *(void **)(*(_QWORD *)(a2 + 72) + 24);
  v9 = mlir::Value::getDefiningOp((mlir::Value *)v51);
  if (v9
    && (v10 = v9,
        *(_UNKNOWN **)(*(_QWORD *)(v9 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id)
    && mlir::tensor::preservesStaticInformation(*(_QWORD *)(v9 - 8) & 0xFFFFFFFFFFFFFFF8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    v11 = 0;
    v12 = *(_QWORD *)(*(_QWORD *)(v10 + 72) + 24) & 0xFFFFFFFFFFFFFF00;
    v13 = *(_QWORD *)(*(_QWORD *)(v10 + 72) + 24);
  }
  else
  {
    v13 = 0;
    v12 = 0;
    v11 = 1;
  }
  v14 = v12 | v13;
  if (*(_BYTE *)(a2 + 47))
    v15 = a2 + 80;
  else
    v15 = 0;
  v51[0] = *(void **)(*(_QWORD *)(a2 + 72) + 32 * *(unsigned int *)(v15 + 24) + 24);
  v16 = mlir::Value::getDefiningOp((mlir::Value *)v51);
  if (v16
    && (v17 = v16,
        *(_UNKNOWN **)(*(_QWORD *)(v16 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id)
    && (mlir::tensor::preservesStaticInformation(*(_QWORD *)(v16 - 8) & 0xFFFFFFFFFFFFFFF8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v16 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0)
  {
    v18 = *(_QWORD *)(*(_QWORD *)(v17 + 72) + 24);
    if (v11)
      v14 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
    v44 = v14;
  }
  else
  {
    if ((v11 & 1) != 0)
      return 0;
    v44 = v14;
    if (*(_BYTE *)(a2 + 47))
      v20 = a2 + 80;
    else
      v20 = 0;
    v18 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 32 * *(unsigned int *)(v20 + 24) + 24);
  }
  result = 0;
  v43 = v18;
  if (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v14 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v21 = (_QWORD *)(*(_QWORD *)(v14 + 8) & 0xFFFFFFFFFFFFFFF8);
  else
    v21 = 0;
  v22 = *(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(_QWORD *)v22 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v23 = (void *)v22;
  else
    v23 = 0;
  if (v21 && v23)
  {
    v24 = a2 + 64;
    v51[0] = *(void **)(a2 + 64 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1));
    mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v51);
    if (HIBYTE(*(_DWORD *)(a2 + 44)))
      v25 = v24 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1);
    else
      v25 = 0;
    v51[0] = *(void **)(v25 + 8);
    v26 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v51);
    v28 = v27;
    if (HIBYTE(*(_DWORD *)(a2 + 44)))
      v29 = v24 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1);
    else
      v29 = 0;
    v51[0] = *(void **)(v29 + 16);
    mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v51);
    v51[0] = v23;
    RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)v51);
    v31 = (_QWORD *)mlir::RankedTensorType::get(v26, v28, RHS, 0);
    v32 = v31;
    if (v31)
      v33 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v31 + 8);
    else
      v33 = 0;
    mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
    if (mlir::isRankReducedType(v32, v33, v21))
    {
      return 0;
    }
    else
    {
      v34 = *(_QWORD *)(a2 + 24);
      mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedOffsets((mlir::memref::ReinterpretCastOp *)&v45, (uint64_t)v51);
      mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedSizes((mlir::memref::ReinterpretCastOp *)&v45, (uint64_t)v49);
      mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedStrides((mlir::memref::ReinterpretCastOp *)&v45, (uint64_t)v47);
      v35 = mlir::OpBuilder::create<mlir::tensor::InsertSliceOp,mlir::Value &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(a3 + 1, v34, &v44, &v43, (uint64_t)v51, (uint64_t)v49, (uint64_t)v47);
      if (v47[0] != &v48)
        free(v47[0]);
      if (v49[0] != &v50)
        free(v49[0]);
      if (v51[0] != v52)
        free(v51[0]);
      if (*(_DWORD *)(v45 + 36))
        v37 = v45 - 16;
      else
        v37 = 0;
      v36 = *(_QWORD *)(v43 + 8) & 0xFFFFFFFFFFFFFFF8;
      if (v36 != (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v37, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
      {
        v38 = *(_QWORD *)(v45 + 24);
        if (*(_DWORD *)(v45 + 36))
          v39 = v45 - 16;
        else
          v39 = 0;
        v51[0] = (void *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v39, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
        v49[0] = (char *)v35 - 16;
        v35 = mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::TensorType &,mlir::Value>((mlir::OpBuilder *)(a3 + 1), v38, (uint64_t *)v51, (uint64_t *)v49);
      }
      v40 = v45;
      v41 = *((unsigned int *)v35 + 9);
      if ((_DWORD)v41)
        v42 = (uint64_t)v35 - 16;
      else
        v42 = 0;
      mlir::ValueRange::ValueRange(v46, v42, v41);
      (*((void (**)(mlir::MLIRContext **, uint64_t, unint64_t, unint64_t))*a3 + 3))(a3, v40, v46[0], v46[1]);
      return 1;
    }
  }
  return result;
}

_QWORD *`anonymous namespace'::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp>::~InsertSliceOpSourceCastInserter(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void `anonymous namespace'::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp>::~InsertSliceOpSourceCastInserter(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *Value;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  uint64_t v18;
  unint64_t ConstantIntValue;
  char v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t RHS;
  uint64_t v25;
  _OWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  ZinIrHalH13g *v30;
  void *v31;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  void *v39[2];
  uint64_t v40;
  void *v41[2];
  uint64_t v42;
  unint64_t v43[2];
  unint64_t v44[2];
  void *v45[2];
  _BYTE v46[32];
  _QWORD *v47;
  uint64_t v48;
  _QWORD v49[7];

  v49[6] = *MEMORY[0x24BDAC8D0];
  v37 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v38 = a2;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v37);
  v6 = v5;
  if (*(_DWORD *)(a2 + 36))
    v7 = a2 - 16;
  else
    v7 = 0;
  v47 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v47);
  if (v6 != v8)
    return 0;
  Value = (_BYTE *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v37);
  v10 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v37);
  v12 = (_BYTE *)(v10 + 8 * v11);
  v47 = v49;
  v48 = 0x600000000;
  v13 = v12 - Value;
  if ((unint64_t)(v12 - Value) >= 0x31)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v49, v13 >> 3, 8);
    v14 = v48;
    if (v12 == Value)
      goto LABEL_11;
    goto LABEL_10;
  }
  v14 = 0;
  if (v12 != Value)
  {
LABEL_10:
    memcpy(&v47[v14], Value, v12 - Value);
    v14 = v48;
  }
LABEL_11:
  LODWORD(v48) = v14 + ((unint64_t)v13 >> 3);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v37);
  if (v16 >= 1)
  {
    for (i = 0; i < v18; ++i)
    {
      mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedSizes((mlir::memref::ReinterpretCastOp *)&v38, (uint64_t)v45);
      ConstantIntValue = mlir::getConstantIntValue(*((_QWORD *)v45[0] + i));
      v21 = v20;
      if (v45[0] != v46)
        free(v45[0]);
      if (v21)
      {
        if ((ConstantIntValue & 0x8000000000000000) != 0)
          goto LABEL_34;
        v47[i] = ConstantIntValue;
      }
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v37);
    }
  }
  v22 = (uint64_t)v47;
  v23 = v48;
  RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v37);
  v25 = mlir::RankedTensorType::get(v22, v23, RHS, 0);
  v36 = v25;
  if (v37 != v25)
  {
    if (mlir::tensor::preservesStaticInformation(v37, v25))
    {
      mlir::ValueRange::ValueRange(v44, (uint64_t)&v37, 1uLL);
      mlir::ValueRange::ValueRange(v43, (uint64_t)&v36, 1uLL);
      if (mlir::tensor::CastOp::areCastCompatible(v44[0], v44[1], v43[0], v43[1]))
      {
        v26 = (_OWORD *)(a3 + 24);
        v33 = *(_OWORD *)(a3 + 24);
        v27 = *(_QWORD *)(v38 + 24);
        v45[0] = *(void **)(*(_QWORD *)(v38 + 72) + 24);
        v35 = (uint64_t)mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::TensorType &,mlir::Value>((mlir::OpBuilder *)(a3 + 8), v27, &v36, (uint64_t *)v45)- 16;
        v28 = v38;
        if (*(_BYTE *)(v38 + 47))
          v29 = v38 + 80;
        else
          v29 = 0;
        v34 = *(_QWORD *)(*(_QWORD *)(v38 + 72) + 32 * *(unsigned int *)(v29 + 24) + 24);
        mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedOffsets((mlir::memref::ReinterpretCastOp *)&v38, (uint64_t)v45);
        mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedSizes((mlir::memref::ReinterpretCastOp *)&v38, (uint64_t)v41);
        mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedStrides((mlir::memref::ReinterpretCastOp *)&v38, (uint64_t)v39);
        v30 = mlir::OpBuilder::create<mlir::tensor::InsertSliceOp,mlir::Value &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>((mlir::MLIRContext **)(a3 + 8), *(_QWORD *)(v28 + 24), &v35, &v34, (uint64_t)v45, (uint64_t)v41, (uint64_t)v39);
        (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, v28, v30);
        if (v39[0] != &v40)
          free(v39[0]);
        if (v41[0] != &v42)
          free(v41[0]);
        if (v45[0] != v46)
          free(v45[0]);
        if ((_QWORD)v33)
        {
          *v26 = v33;
          v15 = 1;
          v31 = v47;
          if (v47 == v49)
            return v15;
        }
        else
        {
          *(_QWORD *)v26 = 0;
          *(_QWORD *)(a3 + 32) = 0;
          v15 = 1;
          v31 = v47;
          if (v47 == v49)
            return v15;
        }
        goto LABEL_35;
      }
    }
  }
LABEL_34:
  v15 = 0;
  v31 = v47;
  if (v47 != v49)
LABEL_35:
    free(v31);
  return v15;
}

void `anonymous namespace'::FoldStaticZeroPadding::~FoldStaticZeroPadding(_anonymous_namespace_::FoldStaticZeroPadding *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::PadOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::PadOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::PadOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t `anonymous namespace'::FoldStaticZeroPadding::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t ConstantIntValue;
  char v8;
  BOOL v9;
  int v10;
  BOOL v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char v16;
  BOOL v17;
  int v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v22;
  ZinIrHalH13g *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  unsigned int v27;
  _QWORD v28[7];

  v28[6] = *MEMORY[0x24BDAC8D0];
  v25 = a2;
  mlir::tensor::PadOp::getMixedLowPad((mlir::tensor::PadOp *)&v25, (uint64_t)&v26);
  v4 = (uint64_t *)v26;
  if (v27)
  {
    v5 = 8 * v27 - 8;
    do
    {
      v6 = *v4++;
      ConstantIntValue = mlir::getConstantIntValue(v6);
      if (v8)
        v9 = ConstantIntValue == 0;
      else
        v9 = 0;
      v10 = v9;
      v11 = v10 != 1 || v5 == 0;
      v5 -= 8;
    }
    while (!v11);
    v4 = (uint64_t *)v26;
    if (v26 != v28)
      goto LABEL_15;
  }
  else
  {
    v10 = 1;
    if (v26 != v28)
LABEL_15:
      free(v4);
  }
  if (!v10)
    return 0;
  mlir::tensor::PadOp::getMixedHighPad((mlir::tensor::PadOp *)&v25, (uint64_t)&v26);
  v12 = (uint64_t *)v26;
  if (!v27)
  {
    v18 = 1;
    if (v26 == v28)
      goto LABEL_32;
    goto LABEL_31;
  }
  v13 = 8 * v27 - 8;
  do
  {
    v14 = *v12++;
    v15 = mlir::getConstantIntValue(v14);
    if (v16)
      v17 = v15 == 0;
    else
      v17 = 0;
    v18 = v17;
    v19 = v18 != 1 || v13 == 0;
    v13 -= 8;
  }
  while (!v19);
  v12 = (uint64_t *)v26;
  if (v26 != v28)
LABEL_31:
    free(v12);
LABEL_32:
  if (!v18)
    return 0;
  v20 = v25;
  if (*(_QWORD *)(v25 + 16 * (((unint64_t)*(unsigned int *)(v25 + 44) >> 23) & 1) + 64))
    return 0;
  if (*(_DWORD *)(v25 + 36))
    v22 = v25 - 16;
  else
    v22 = 0;
  v26 = (void *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v22, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v24 = *(_QWORD *)(*(_QWORD *)(v25 + 72) + 24);
  v23 = mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::TensorType &,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(v20 + 24), (uint64_t *)&v26, &v24);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, v20, v23);
  return 1;
}

uint64_t mlir::tensor::PadOp::hasZeroLowPad(mlir::tensor::PadOp *this)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t ConstantIntValue;
  char v5;
  BOOL v6;
  uint64_t v7;
  BOOL v8;
  void *v10;
  unsigned int v11;
  _QWORD v12[7];

  v12[6] = *MEMORY[0x24BDAC8D0];
  mlir::tensor::PadOp::getMixedLowPad(this, (uint64_t)&v10);
  v1 = (uint64_t *)v10;
  if (!v11)
  {
    v7 = 1;
    if (v10 == v12)
      return v7;
    goto LABEL_15;
  }
  v2 = 8 * v11 - 8;
  do
  {
    v3 = *v1++;
    ConstantIntValue = mlir::getConstantIntValue(v3);
    if (v5)
      v6 = ConstantIntValue == 0;
    else
      v6 = 0;
    v7 = v6;
    v8 = (_DWORD)v7 != 1 || v2 == 0;
    v2 -= 8;
  }
  while (!v8);
  v1 = (uint64_t *)v10;
  if (v10 != v12)
LABEL_15:
    free(v1);
  return v7;
}

void `anonymous namespace'::FoldSourceTensorCast::~FoldSourceTensorCast(_anonymous_namespace_::FoldSourceTensorCast *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::FoldSourceTensorCast::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  uint64_t DefiningOp;
  uint64_t v6;
  uint64_t result;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t Value;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  unsigned int *v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  ZinIrHalH13g *v37;
  mlir::Region *v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  ZinIrHalH13g *v42;
  uint64_t *v43;
  uint64_t *v44;
  uint64_t *v45;
  uint64_t v46;
  BOOL v47;
  _QWORD v48[2];
  uint64_t v49;
  uint64_t v50;
  uint64_t v51[2];
  uint64_t v52[2];
  uint64_t v53;
  ZinIrHalH13g *v54;
  uint64_t v55;
  llvm *v56[2];
  int v57;
  llvm *v58;
  uint64_t v59;
  int v60;
  llvm *v61;
  uint64_t v62;
  unsigned int v63;
  uint64_t v64;

  v64 = *MEMORY[0x24BDAC8D0];
  v56[0] = *(llvm **)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v56);
  if (!DefiningOp)
    return 0;
  v6 = DefiningOp;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id)
    return 0;
  result = mlir::tensor::preservesStaticInformation(*(_QWORD *)(DefiningOp - 8) & 0xFFFFFFFFFFFFFFF8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if ((_DWORD)result)
  {
    v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
    v9 = a2 + 64;
    if (HIBYTE(*(_DWORD *)(a2 + 44)))
      v10 = a2 + 64 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1);
    else
      v10 = 0;
    v56[0] = *(llvm **)(v10 + 16);
    v11 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v56);
    v13 = v12;
    if (HIBYTE(*(_DWORD *)(a2 + 44)))
      v14 = v9 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1);
    else
      v14 = 0;
    v56[0] = *(llvm **)(v14 + 8);
    v15 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v56);
    v17 = v16;
    if (*(_DWORD *)(a2 + 36))
      v18 = a2 - 16;
    else
      v18 = 0;
    v56[0] = (llvm *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v18, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v56);
    v21 = mlir::tensor::PadOp::inferResultType(v8, v11, v13, v15, v17, Value, v20);
    v55 = v21;
    if (*(_DWORD *)(a2 + 36))
      v22 = a2 - 16;
    else
      v22 = 0;
    if (v21 != (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v22, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      v23 = *(_QWORD *)(a2 + 24);
      v24 = *(unsigned __int8 *)(a2 + 47);
      v53 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
      if (v24)
        v25 = a2 + 80;
      else
        v25 = 0;
      v56[0] = *(llvm **)(v25 + 16);
      v52[0] = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v56);
      v52[1] = v26;
      if (HIBYTE(*(_DWORD *)(a2 + 44)))
        v27 = v9 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1);
      else
        v27 = 0;
      v56[0] = *(llvm **)(v27 + 8);
      v51[0] = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v56);
      v51[1] = v28;
      v29 = *(unsigned int *)(a2 + 44);
      v30 = (_QWORD *)(v9 + 16 * ((v29 >> 23) & 1));
      if (HIBYTE(*(_DWORD *)(a2 + 44)))
        v31 = (unsigned int *)(v9 + 16 * ((v29 >> 23) & 1));
      else
        v31 = 0;
      v33 = v31[6];
      v32 = v31[7];
      if ((v29 & 0x800000) != 0)
      {
        v34 = v32 + v33;
        v49 = *(_QWORD *)(a2 + 72) + 32 * v33;
        v50 = v34 - v33;
        v35 = *(_QWORD *)(a2 + 72);
      }
      else
      {
        v35 = 0;
        v34 = v32 + v33;
        v49 = 32 * v33;
        v50 = v34 - v33;
      }
      v36 = v31[8] + v34 - v34;
      v48[0] = v35 + 32 * v34;
      v48[1] = v36;
      v47 = *v30 != 0;
      mlir::getPrunedAttributeList((_BYTE *)a2, (uint64_t)&mlir::tensor::PadOp::getAttributeNames(void)::attrNames, 4, (uint64_t)v56);
      v37 = mlir::OpBuilder::create<mlir::tensor::PadOp,mlir::RankedTensorType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>,mlir::OperandRange,mlir::OperandRange,BOOL,llvm::SmallVector<mlir::NamedAttribute,3u>>(a3 + 1, v23, &v55, &v53, v52, v51, (uint64_t)&v49, (uint64_t)v48, (char *)&v47, (uint64_t)v56);
      v54 = v37;
      if ((int *)v56[0] != &v57)
        free(v56[0]);
      v60 = 0;
      v61 = 0;
      v62 = 0;
      v63 = 0;
      v38 = (mlir::Region *)(((v9
                             + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                             + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                             + 7) & 0xFFFFFFFFFFFFFFF8)
                           + 32 * *(unsigned int *)(a2 + 40));
      v40 = *((unsigned int *)v37 + 10);
      v39 = *((unsigned int *)v37 + 11);
      v56[0] = 0;
      v56[1] = 0;
      v57 = 0;
      v58 = 0;
      v59 = 0;
      mlir::Region::cloneInto(v38, (mlir::Region *)((((unint64_t)v37 + 16 * ((v39 >> 23) & 1) + ((v39 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * v40), (mlir::IRMapping *)v56);
      if (*(_DWORD *)(a2 + 36))
        v41 = a2 - 16;
      else
        v41 = 0;
      v52[0] = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v41, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
      v42 = mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::RankedTensorType,mlir::tensor::EmptyOp &>((mlir::OpBuilder *)(a3 + 1), *(_QWORD *)(a2 + 24), v52, &v54);
      (*((void (**)(mlir::MLIRContext **, uint64_t, ZinIrHalH13g *))*a3 + 4))(a3, a2, v42);
      llvm::deallocate_buffer(v61, (void *)(16 * v63));
    }
    (*((void (**)(mlir::MLIRContext **, uint64_t))*a3 + 9))(a3, a2);
    v43 = *(uint64_t **)(a2 + 72);
    v44 = *(uint64_t **)(*(_QWORD *)(v6 + 72) + 24);
    v45 = (uint64_t *)v43[1];
    if (v45)
    {
      *v45 = *v43;
      if (*v43)
        *(_QWORD *)(*v43 + 8) = v43[1];
    }
    v43[3] = (uint64_t)v44;
    v43[1] = (uint64_t)v44;
    v46 = *v44;
    *v43 = *v44;
    if (v46)
      *(_QWORD *)(v46 + 8) = v43;
    *v44 = (uint64_t)v43;
    (*((void (**)(mlir::MLIRContext **, uint64_t))*a3 + 10))(a3, a2);
    return 1;
  }
  return result;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::PadOp,mlir::RankedTensorType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>,mlir::OperandRange,mlir::OperandRange,BOOL,llvm::SmallVector<mlir::NamedAttribute,3u>>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t a7, uint64_t a8, char *a9, uint64_t a10)
{
  uint64_t *Context;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  ZinIrHalH13g *v26;
  ZinIrHalH13g *v27;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  __int16 v32;
  uint64_t v33[4];
  __int16 v34;
  unint64_t v35[2];
  unint64_t v36[2];
  _QWORD v37[40];

  v37[38] = *MEMORY[0x24BDAC8D0];
  v30 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v30);
  v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.pad", (const unsigned __int8 *)0xA, Context);
  if (!v20)
  {
    v34 = 1283;
    v33[2] = (uint64_t)"tensor.pad";
    v33[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v32 = 259;
    llvm::operator+(v33, (uint64_t *)&v31, (uint64_t)v37);
    llvm::report_fatal_error((llvm::Twine *)v37, 1);
  }
  mlir::OperationState::OperationState(v37, a2, v19);
  v29 = *a3;
  v21 = *a4;
  v23 = *a5;
  v22 = a5[1];
  v25 = *a6;
  v24 = a6[1];
  mlir::ValueRange::ValueRange(v36, *(_QWORD *)a7, *(_QWORD *)(a7 + 8));
  mlir::ValueRange::ValueRange(v35, *(_QWORD *)a8, *(_QWORD *)(a8 + 8));
  mlir::tensor::PadOp::build(a1, (uint64_t)v37, v29, v21, v23, v22, v25, v24, v36[0], v36[1], v35[0], v35[1], *a9, *(void **)a10, *(unsigned int *)(a10 + 8));
  v26 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v37);
  if (*(_UNKNOWN **)(*((_QWORD *)v26 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::PadOp,void>::id)
    v27 = v26;
  else
    v27 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v37);
  return v27;
}

void `anonymous namespace'::FoldTargetTensorCast::~FoldTargetTensorCast(_anonymous_namespace_::FoldTargetTensorCast *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::FoldTargetTensorCast::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  void *v5;
  uint64_t v6;
  _QWORD *NextResultAtOffset;
  uint64_t v8;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  _QWORD *v29;
  unsigned int *v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  ZinIrHalH13g *v36;
  uint64_t v37;
  uint64_t v38;
  BOOL v39;
  _QWORD v40[2];
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  _OWORD v45[2];
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  void *v49[2];
  __int128 v50;
  uint64_t v51;
  uint64_t v52[7];

  v52[6] = *MEMORY[0x24BDAC8D0];
  v5 = (void *)(a2 - 16);
  if (*(_DWORD *)(a2 + 36))
    v6 = a2 - 16;
  else
    v6 = 0;
  NextResultAtOffset = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
  if (!*NextResultAtOffset || *(_QWORD *)*NextResultAtOffset)
    return 0;
  v10 = (void *)*(unsigned int *)(a2 + 36);
  if ((_DWORD)v10)
    v11 = v5;
  else
    v11 = 0;
  v49[0] = v11;
  v49[1] = v10;
  mlir::ResultRange::use_begin((uint64_t *)v49, (uint64_t *)v45);
  v12 = *(unsigned int *)(a2 + 36);
  if ((_DWORD)v12)
    v13 = (uint64_t)v5;
  else
    v13 = 0;
  v47 = v13;
  v48 = v12;
  mlir::ResultRange::use_end(&v47, v52);
  v8 = 0;
  v51 = v46;
  *(_OWORD *)v49 = v45[0];
  v50 = v45[1];
  v14 = *(_QWORD *)(v46 + 16);
  if (v14
    && *(_UNKNOWN **)(*(_QWORD *)(v14 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id)
  {
    if (*(_DWORD *)(a2 + 36))
      v15 = (uint64_t)v5;
    else
      v15 = 0;
    v16 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v15, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    if (*(_DWORD *)(v14 + 36))
      v17 = v14 - 16;
    else
      v17 = 0;
    v18 = mlir::detail::OpResultImpl::getNextResultAtOffset(v17, 0);
    if (!mlir::tensor::preservesStaticInformation(v16, *(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8))
      return 0;
    v19 = *(_QWORD *)(a2 + 24);
    if (*(_DWORD *)(v14 + 36))
      v20 = v14 - 16;
    else
      v20 = 0;
    v21 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v20, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v22 = *(unsigned __int8 *)(a2 + 47);
    v23 = a2 + 64;
    v43 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
    v44 = v21;
    if (v22)
      v24 = a2 + 80;
    else
      v24 = 0;
    v49[0] = *(void **)(v24 + 16);
    *(_QWORD *)&v45[0] = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v49);
    *((_QWORD *)&v45[0] + 1) = v25;
    if (HIBYTE(*(_DWORD *)(a2 + 44)))
      v26 = v23 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1);
    else
      v26 = 0;
    v49[0] = *(void **)(v26 + 8);
    v47 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v49);
    v48 = v27;
    v28 = *(unsigned int *)(a2 + 44);
    v29 = (_QWORD *)(v23 + 16 * ((v28 >> 23) & 1));
    if (HIBYTE(*(_DWORD *)(a2 + 44)))
      v30 = (unsigned int *)(v23 + 16 * ((v28 >> 23) & 1));
    else
      v30 = 0;
    v32 = v30[6];
    v31 = v30[7];
    if ((v28 & 0x800000) != 0)
    {
      v33 = v31 + v32;
      v41 = *(_QWORD *)(a2 + 72) + 32 * v32;
      v42 = v33 - v32;
      v34 = *(_QWORD *)(a2 + 72);
    }
    else
    {
      v34 = 0;
      v33 = v31 + v32;
      v41 = 32 * v32;
      v42 = v33 - v32;
    }
    v35 = v30[8] + v33 - v33;
    v40[0] = v34 + 32 * v33;
    v40[1] = v35;
    v39 = *v29 != 0;
    mlir::getPrunedAttributeList((_BYTE *)a2, (uint64_t)&mlir::tensor::PadOp::getAttributeNames(void)::attrNames, 4, (uint64_t)v49);
    v36 = mlir::OpBuilder::create<mlir::tensor::PadOp,mlir::RankedTensorType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>,mlir::OperandRange,mlir::OperandRange,BOOL,llvm::SmallVector<mlir::NamedAttribute,3u>>(a3 + 1, v19, (uint64_t *)&v44, &v43, (uint64_t *)v45, &v47, (uint64_t)&v41, (uint64_t)v40, (char *)&v39, (uint64_t)v49);
    if (v49[0] != &v50)
      free(v49[0]);
    mlir::Region::takeBody((mlir::Region *)((((unint64_t)v36+ 16 * (((unint64_t)*((unsigned int *)v36 + 11) >> 23) & 1)+ (((unint64_t)*((unsigned int *)v36 + 11) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)v36 + 10)), (mlir::Region *)(((v23+ 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(a2 + 40)));
    if (*((_DWORD *)v36 + 9))
      v37 = (uint64_t)v36 - 16;
    else
      v37 = 0;
    v49[0] = (void *)mlir::detail::OpResultImpl::getNextResultAtOffset(v37, 0);
    v8 = 1;
    (*((void (**)(mlir::MLIRContext **, uint64_t, void **, uint64_t))*a3 + 3))(a3, a2, v49, 1);
    if (*((_DWORD *)v36 + 9))
      v38 = (uint64_t)v36 - 16;
    else
      v38 = 0;
    v49[0] = (void *)mlir::detail::OpResultImpl::getNextResultAtOffset(v38, 0);
    (*((void (**)(mlir::MLIRContext **, uint64_t, void **, uint64_t))*a3 + 3))(a3, v14, v49, 1);
  }
  return v8;
}

void `anonymous namespace'::FoldOrthogonalPaddings::~FoldOrthogonalPaddings(_anonymous_namespace_::FoldOrthogonalPaddings *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::FoldOrthogonalPaddings::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  void *v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  void *v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  BOOL v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t ConstantIntValue;
  char v25;
  BOOL v26;
  int v27;
  BOOL v28;
  _BYTE *v29;
  uint64_t ConstantPaddingValue;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  unint64_t *v35;
  uint64_t i;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  char v40;
  BOOL v41;
  unint64_t v42;
  char v43;
  BOOL v44;
  uint64_t v45;
  unint64_t *v46;
  uint64_t j;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  char v51;
  BOOL v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  ZinIrHalH13g *v56;
  uint64_t v57;
  _BYTE *v58;
  uint64_t v59;
  ZinIrHalH13g *v60;
  unint64_t v61;
  _BYTE *v62;
  uint64_t v63;
  mlir::IndexType **v64;
  BOOL v65;
  uint64_t NextResultAtOffset;
  unint64_t v67;
  void **v68;
  void **v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  _BYTE *v75;
  void *v76[2];
  uint64_t v77;
  void *v78[2];
  _BYTE v79[48];
  _BYTE *v80;
  unsigned int v81;
  _BYTE v82[48];
  char **v83;
  uint64_t v84;
  _BYTE v85[48];
  char *v86;
  unsigned int v87;
  _BYTE v88[16];
  __int16 v89;
  uint64_t v90;

  v90 = *MEMORY[0x24BDAC8D0];
  v75 = (_BYTE *)a2;
  v86 = *(char **)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v86);
  if (!DefiningOp)
    return 0;
  v5 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
  v6 = v5 == &mlir::detail::TypeIDResolver<mlir::tensor::ExtractSliceOp,void>::id;
  v7 = v5 == &mlir::detail::TypeIDResolver<mlir::tensor::ExtractSliceOp,void>::id ? DefiningOp : 0;
  v74 = v7;
  if (!v6)
    return 0;
  v86 = *(char **)(*(_QWORD *)(DefiningOp + 72) + 24);
  v10 = mlir::Value::getDefiningOp((mlir::Value *)&v86);
  if (!v10)
    return 0;
  v11 = *(void **)(*(_QWORD *)(v10 + 48) + 16);
  v12 = v11 == &mlir::detail::TypeIDResolver<mlir::tensor::PadOp,void>::id;
  v13 = v11 == &mlir::detail::TypeIDResolver<mlir::tensor::PadOp,void>::id ? v10 : 0;
  v73 = v13;
  if (!v12)
    return 0;
  if (*(_QWORD *)(v10 + 16 * (((unint64_t)*(unsigned int *)(v10 + 44) >> 23) & 1) + 64))
    return 0;
  v86 = *(char **)(*(_QWORD *)(v10 + 72) + 24);
  v14 = mlir::Value::getDefiningOp((mlir::Value *)&v86);
  if (!v14)
    return 0;
  v15 = *(void **)(*(_QWORD *)(v14 + 48) + 16);
  v16 = v15 == &mlir::detail::TypeIDResolver<mlir::tensor::ExtractSliceOp,void>::id;
  v17 = v15 == &mlir::detail::TypeIDResolver<mlir::tensor::ExtractSliceOp,void>::id ? v14 : 0;
  v72 = v17;
  if (!v16)
    return 0;
  v86 = (char *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v75 + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v86);
  v19 = v18;
  v86 = (char *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v72 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v86);
  if (v20 != v19)
  {
    v86 = "cannot fold rank-reducing chain";
    v89 = 259;
    v29 = v75;
    v83 = &v86;
    v8 = *(_QWORD *)(a3 + 16);
    if (!v8)
      return v8;
LABEL_52:
    if (mlir::RewriterBase::Listener::classof(v8))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), char ***))(*(_QWORD *)v8 + 64))(v8, *((_QWORD *)v29 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::tensor::PadOp &>(mlir::tensor::PadOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v83);
    return 0;
  }
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedStrides((mlir::memref::ReinterpretCastOp *)&v74, (uint64_t)&v86);
  v21 = (uint64_t *)v86;
  if (v87)
  {
    v22 = 8 * v87 - 8;
    do
    {
      v23 = *v21++;
      ConstantIntValue = mlir::getConstantIntValue(v23);
      if (v25)
        v26 = ConstantIntValue == 1;
      else
        v26 = 0;
      v27 = v26;
      v28 = v27 != 1 || v22 == 0;
      v22 -= 8;
    }
    while (!v28);
    v21 = (uint64_t *)v86;
  }
  else
  {
    v27 = 1;
  }
  if (v21 != (uint64_t *)v88)
    free(v21);
  if (!v27
    || (mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::ExtractSliceOp>::hasUnitStride((mlir::memref::ReinterpretCastOp *)&v72) & 1) == 0)
  {
    v86 = "cannot fold non-unit stride ExtractSliceOps";
    v89 = 259;
    v29 = v75;
    v83 = &v86;
    v8 = *(_QWORD *)(a3 + 16);
    if (!v8)
      return v8;
    goto LABEL_52;
  }
  if (!mlir::tensor::PadOp::hasZeroLowPad((mlir::tensor::PadOp *)&v75)
    || (mlir::tensor::PadOp::hasZeroLowPad((mlir::tensor::PadOp *)&v73) & 1) == 0)
  {
    v33 = "cannot fold PadOps with low padding";
    return mlir::RewriterBase::notifyMatchFailure<mlir::tensor::PadOp &>(a3, (uint64_t *)&v75, v33);
  }
  v70 = 0;
  v71 = 0;
  ConstantPaddingValue = mlir::tensor::PadOp::getConstantPaddingValue((mlir::tensor::PadOp *)&v75);
  v31 = mlir::tensor::PadOp::getConstantPaddingValue((mlir::tensor::PadOp *)&v73);
  if (!ConstantPaddingValue
    || (v32 = v31) == 0
    || (v86 = (char *)&v71,
        !mlir::matchPattern<mlir::detail::constant_op_binder<mlir::Attribute>>(ConstantPaddingValue, (unint64_t **)&v86))|| (v83 = (char **)&v70, !mlir::matchPattern<mlir::detail::constant_op_binder<mlir::Attribute>>(v32, (unint64_t **)&v83))|| v71 != v70)
  {
    v33 = "cannot fold PadOps with different padding values";
    return mlir::RewriterBase::notifyMatchFailure<mlir::tensor::PadOp &>(a3, (uint64_t *)&v75, v33);
  }
  mlir::tensor::PadOp::getPaddedDims((mlir::tensor::PadOp *)&v75, (unint64_t *)&v69);
  mlir::tensor::PadOp::getPaddedDims((mlir::tensor::PadOp *)&v73, (unint64_t *)&v68);
  if (llvm::SmallBitVector::anyCommon((llvm::SmallBitVector *)&v69, (const llvm::SmallBitVector *)&v68))
  {
    v8 = mlir::RewriterBase::notifyMatchFailure<mlir::tensor::PadOp &>(a3, (uint64_t *)&v75, "cannot fold PadOps with common padding dimensions");
  }
  else
  {
    v64 = (mlir::IndexType **)(a3 + 8);
    v83 = (char **)(mlir::Builder::getIndexAttr((mlir::IndexType **)(a3 + 8), 0) & 0xFFFFFFFFFFFFFFFBLL);
    llvm::SmallVector<mlir::OpFoldResult,6u>::SmallVector(&v86, v19, (unint64_t *)&v83);
    if (v87)
    {
      v34 = 0;
      v35 = (unint64_t *)v86;
      for (i = 8 * v87; i; i -= 8)
      {
        mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedOffsets((mlir::memref::ReinterpretCastOp *)&v74, (uint64_t)&v83);
        v37 = (uint64_t)v83[v34];
        if (v83 != (char **)v85)
          free(v83);
        mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedOffsets((mlir::memref::ReinterpretCastOp *)&v72, (uint64_t)&v83);
        v38 = (uint64_t)v83[v34];
        if (v83 != (char **)v85)
          free(v83);
        if (!llvm::SmallBitVector::test((llvm::SmallBitVector *)&v69, v34)
          && ((v39 = mlir::getConstantIntValue(v37), v40) ? (v41 = v39 == 0) : (v41 = 0), v41))
        {
          v37 = v38;
        }
        else if (llvm::SmallBitVector::test((llvm::SmallBitVector *)&v68, v34)
               || ((v42 = mlir::getConstantIntValue(v38), v43) ? (v44 = v42 == 0) : (v44 = 0), !v44))
        {
          v8 = mlir::RewriterBase::notifyMatchFailure<mlir::tensor::PadOp &>(a3, (uint64_t *)&v75, "cannot find zero-offset and zero-padding pair");
          goto LABEL_123;
        }
        v35[v34++] = v37;
      }
    }
    mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedSizes((mlir::memref::ReinterpretCastOp *)&v74, (uint64_t)&v80);
    v83 = (char **)v85;
    v84 = 0x600000000;
    if (v81)
      llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)&v83, (uint64_t)&v80);
    if (v80 != v82)
      free(v80);
    if ((_DWORD)v84)
    {
      v45 = 0;
      v46 = (unint64_t *)v83;
      for (j = 8 * v84; j; j -= 8)
      {
        if (llvm::SmallBitVector::test((llvm::SmallBitVector *)&v68, v45))
        {
          mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedSizes((mlir::memref::ReinterpretCastOp *)&v74, (uint64_t)&v80);
          v48 = *(_QWORD *)&v80[8 * v45];
          if (v80 != v82)
            free(v80);
          v80 = (_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v74 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
          v49 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v80) + 8 * v45);
          v50 = mlir::getConstantIntValue(v48);
          if (v51)
            v52 = v50 == v49;
          else
            v52 = 0;
          if (!v52)
          {
            v8 = mlir::RewriterBase::notifyMatchFailure<mlir::tensor::PadOp &>(a3, (uint64_t *)&v75, "cannot fold since the inner ExtractSliceOp size does not match the size of the outer padding");
            goto LABEL_121;
          }
          mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedSizes((mlir::memref::ReinterpretCastOp *)&v72, (uint64_t)&v80);
          v46[v45] = *(_QWORD *)&v80[8 * v45];
          if (v80 != v82)
            free(v80);
        }
        ++v45;
      }
    }
    v78[0] = (void *)(mlir::Builder::getIndexAttr(v64, 0) & 0xFFFFFFFFFFFFFFFBLL);
    llvm::SmallVector<mlir::OpFoldResult,6u>::SmallVector(&v80, v19, (unint64_t *)v78);
    if (v81)
    {
      v53 = 0;
      v54 = 8 * v81;
      do
      {
        if (llvm::SmallBitVector::test((llvm::SmallBitVector *)&v69, v53))
        {
          mlir::tensor::PadOp::getMixedHighPad((mlir::tensor::PadOp *)&v75, (uint64_t)v78);
          *(_QWORD *)&v80[8 * v53] = *((_QWORD *)v78[0] + v53);
          if (v78[0] != v79)
            free(v78[0]);
        }
        if (llvm::SmallBitVector::test((llvm::SmallBitVector *)&v68, v53))
        {
          mlir::tensor::PadOp::getMixedHighPad((mlir::tensor::PadOp *)&v73, (uint64_t)v78);
          *(_QWORD *)&v80[8 * v53] = *((_QWORD *)v78[0] + v53);
          if (v78[0] != v79)
            free(v78[0]);
        }
        ++v53;
        v54 -= 8;
      }
      while (v54);
    }
    v55 = *((_QWORD *)v75 + 3);
    v76[0] = *(void **)(*(_QWORD *)(v72 + 72) + 24);
    mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedStrides((mlir::memref::ReinterpretCastOp *)&v74, (uint64_t)v78);
    v56 = mlir::OpBuilder::create<mlir::tensor::ExtractSliceOp,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,4u>>(v64, v55, (uint64_t *)v76, (uint64_t)&v86, (uint64_t)&v83, (uint64_t)v78);
    if (v78[0] != v79)
      free(v78[0]);
    v57 = *((_QWORD *)v75 + 3);
    if (*((_DWORD *)v75 + 9))
      v58 = v75 - 16;
    else
      v58 = 0;
    v67 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v58, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    if (*((_DWORD *)v56 + 9))
      v59 = (uint64_t)v56 - 16;
    else
      v59 = 0;
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v59, 0);
    mlir::tensor::PadOp::getMixedLowPad((mlir::tensor::PadOp *)&v75, (uint64_t)v78);
    v65 = *(_QWORD *)&v75[16 * (((unint64_t)*((unsigned int *)v75 + 11) >> 23) & 1) + 64] != 0;
    mlir::getPrunedAttributeList(v75, (uint64_t)&mlir::tensor::PadOp::getAttributeNames(void)::attrNames, 4, (uint64_t)v76);
    v60 = mlir::OpBuilder::create<mlir::tensor::PadOp,mlir::RankedTensorType,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,6u>,llvm::SmallVector<mlir::OpFoldResult,6u>&,BOOL,llvm::SmallVector<mlir::NamedAttribute,3u>>(v64, v57, (uint64_t *)&v67, &NextResultAtOffset, (uint64_t)v78, (uint64_t)&v80, (char *)&v65, (uint64_t)v76);
    if (v76[0] != &v77)
      free(v76[0]);
    if (v78[0] != v79)
      free(v78[0]);
    v61 = (((unint64_t)v60
          + 16 * (((unint64_t)*((unsigned int *)v60 + 11) >> 23) & 1)
          + (((unint64_t)*((unsigned int *)v60 + 11) >> 21) & 0x7F8)
          + 71) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *((unsigned int *)v60 + 10);
    (**(void (***)(uint64_t, unint64_t, unint64_t, _QWORD))a3)(a3, ((unint64_t)&v75[16 * (((unint64_t)*((unsigned int *)v75 + 11) >> 23) & 1)+ 71+ (((unint64_t)*((unsigned int *)v75 + 11) >> 21) & 0x7F8)] & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)v75 + 10), v61, *(_QWORD *)(v61 + 8));
    v62 = v75;
    if (*((_DWORD *)v60 + 9))
      v63 = (uint64_t)v60 - 16;
    else
      v63 = 0;
    v78[0] = (void *)mlir::detail::OpResultImpl::getNextResultAtOffset(v63, 0);
    (*(void (**)(uint64_t, _BYTE *, void **, uint64_t))(*(_QWORD *)a3 + 24))(a3, v62, v78, 1);
    if (v80 != v82)
      free(v80);
    v8 = 1;
LABEL_121:
    if (v83 != (char **)v85)
      free(v83);
LABEL_123:
    if (v86 != v88)
      free(v86);
  }
  llvm::SmallBitVector::~SmallBitVector(&v68);
  llvm::SmallBitVector::~SmallBitVector(&v69);
  return v8;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::tensor::PadOp &>(uint64_t a1, uint64_t *a2, _BYTE *a3)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  _BYTE *v7;
  char v8;
  char v9;
  _QWORD *v10;

  v3 = 1;
  v9 = 1;
  if (*a3)
  {
    v7 = a3;
    v3 = 3;
  }
  v8 = v3;
  v4 = *a2;
  v10 = &v7;
  v5 = *(_QWORD *)(a1 + 16);
  if (!v5)
    return 0;
  result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v5 + 64))(v5, *(_QWORD *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::tensor::PadOp &>(mlir::tensor::PadOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  return result;
}

uint64_t mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::ExtractSliceOp>::hasUnitStride(mlir::memref::ReinterpretCastOp *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t ConstantIntValue;
  char v5;
  BOOL v6;
  uint64_t v7;
  BOOL v8;
  void *v10;
  unsigned int v11;
  _QWORD v12[5];

  v12[4] = *MEMORY[0x24BDAC8D0];
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::memref::ReinterpretCastOp>::getMixedStrides(a1, (uint64_t)&v10);
  v1 = (uint64_t *)v10;
  if (!v11)
  {
    v7 = 1;
    if (v10 == v12)
      return v7;
    goto LABEL_15;
  }
  v2 = 8 * v11 - 8;
  do
  {
    v3 = *v1++;
    ConstantIntValue = mlir::getConstantIntValue(v3);
    if (v5)
      v6 = ConstantIntValue == 1;
    else
      v6 = 0;
    v7 = v6;
    v8 = (_DWORD)v7 != 1 || v2 == 0;
    v2 -= 8;
  }
  while (!v8);
  v1 = (uint64_t *)v10;
  if (v10 != v12)
LABEL_15:
    free(v1);
  return v7;
}

uint64_t mlir::matchPattern<mlir::detail::constant_op_binder<mlir::Attribute>>(uint64_t a1, unint64_t **a2)
{
  BOOL v2;
  uint64_t DefiningOp;
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v9;
  void *v10[2];
  _QWORD v11[2];

  v11[1] = *MEMORY[0x24BDAC8D0];
  v9 = a1;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v9);
  v5 = DefiningOp;
  if (DefiningOp)
  {
    if (mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
    {
      v10[0] = v11;
      v10[1] = (void *)0x100000000;
      mlir::Operation::fold(v5, 0, 0, (uint64_t)v10);
      v6 = v10[0];
      v7 = *(_QWORD *)v10[0] & 0xFFFFFFFFFFFFFFF8;
      v2 = v7 != 0;
      if (v7 && *a2)
      {
        **a2 = v7;
        v6 = v10[0];
      }
      if (v6 != v11)
        free(v6);
    }
    else
    {
      v2 = 0;
    }
  }
  return (v5 != 0) & v2;
}

BOOL llvm::SmallBitVector::anyCommon(llvm::SmallBitVector *this, const llvm::SmallBitVector *a2)
{
  unint64_t v2;
  unint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BOOL8 result;
  BOOL v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  unsigned int v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v2 = *(_QWORD *)this;
  v3 = *(_QWORD *)a2;
  if ((*(_QWORD *)this & 1) != 0)
  {
    v15 = v2 >> 58;
    if ((v3 & 1) != 0)
      return (~((-1 << v15) | (-1 << (v3 >> 58))) & ((v2 & v3) >> 1)) != 0;
  }
  else
  {
    if ((v3 & 1) == 0)
    {
      v4 = *(_DWORD *)(v2 + 8);
      LODWORD(v5) = *(_DWORD *)(v3 + 8);
      if (v5 >= v4)
        v5 = v4;
      else
        v5 = v5;
      if ((_DWORD)v5)
      {
        v6 = *(uint64_t **)v2;
        v7 = *(uint64_t **)v3;
        v8 = v5 - 1;
        do
        {
          v10 = *v6++;
          v9 = v10;
          v11 = *v7++;
          v12 = v11 & v9;
          result = v12 != 0;
          if (v12)
            v14 = 1;
          else
            v14 = v8 == 0;
          --v8;
        }
        while (!v14);
        return result;
      }
      return 0;
    }
    v15 = *(unsigned int *)(v2 + 64);
  }
  if ((v3 & 1) != 0)
  {
    if (v3 >> 58 < v15)
      v15 = v3 >> 58;
    if (!(_DWORD)v15)
      return 0;
  }
  else
  {
    if (*(unsigned int *)(v3 + 64) < v15)
      v15 = *(unsigned int *)(v3 + 64);
    if (!(_DWORD)v15)
      return 0;
  }
  v16 = (v3 >> 1) & ~(-1 << (v3 >> 58));
  if ((v2 & 1) != 0)
  {
    v20 = (v2 >> 1) & ~(-1 << (v2 >> 58));
    if ((v3 & 1) != 0)
    {
      v23 = 0;
      do
      {
        result = (v16 & (1 << v23)) != 0 && (v20 & (1 << v23)) != 0;
        if (result)
          break;
        v14 = v15 - 1 == v23++;
      }
      while (!v14);
    }
    else
    {
      v21 = 0;
      while (((v20 >> v21) & 1) == 0 || ((*(_QWORD *)(*(_QWORD *)v3 + 8 * (v21 >> 6)) >> v21) & 1) == 0)
      {
        if (v15 == ++v21)
          return 0;
      }
      return 1;
    }
  }
  else
  {
    v17 = *(uint64_t **)v2;
    if ((v3 & 1) != 0)
    {
      v22 = 0;
      while ((((unint64_t)v17[v22 >> 6] >> v22) & 1) == 0 || ((v16 >> v22) & 1) == 0)
      {
        if (v15 == ++v22)
          return 0;
      }
      return 1;
    }
    else
    {
      v18 = 0;
      while (1)
      {
        v19 = v18 >> 6;
        if ((v17[v19] & (1 << v18)) != 0 && (*(_QWORD *)(*(_QWORD *)v3 + 8 * v19) & (1 << v18)) != 0)
          break;
        if ((_DWORD)v15 == ++v18)
          return 0;
      }
      return 1;
    }
  }
  return result;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::ExtractSliceOp,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,4u>>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  ZinIrHalH13g *v15;
  ZinIrHalH13g *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x24BDAC8D0];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.extract_slice", (const unsigned __int8 *)0x14, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"tensor.extract_slice";
    v21[3] = 20;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::tensor::ExtractSliceOp::build(a1, (uint64_t)v23, 0, *a3, *(uint64_t **)a4, *(unsigned int *)(a4 + 8), *(uint64_t **)a5, *(unsigned int *)(a5 + 8), *(uint64_t **)a6, *(unsigned int *)(a6 + 8), 0, 0);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::ExtractSliceOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::PadOp,mlir::RankedTensorType,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,6u>,llvm::SmallVector<mlir::OpFoldResult,6u>&,BOOL,llvm::SmallVector<mlir::NamedAttribute,3u>>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6, char *a7, uint64_t a8)
{
  uint64_t *Context;
  uint64_t v17;
  char v18;
  ZinIrHalH13g *v19;
  ZinIrHalH13g *v20;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  _QWORD v27[39];

  v27[38] = *MEMORY[0x24BDAC8D0];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.pad", (const unsigned __int8 *)0xA, Context);
  if (!v18)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"tensor.pad";
    v25[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v27, a2, v17);
  mlir::tensor::PadOp::build(a1, (uint64_t)v27, *a3, *a4, *(uint64_t **)a5, *(unsigned int *)(a5 + 8), *(uint64_t **)a6, *(unsigned int *)(a6 + 8), *a7, *(void **)a8, *(unsigned int *)(a8 + 8));
  v19 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v27);
  if (*(_UNKNOWN **)(*((_QWORD *)v19 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::PadOp,void>::id)
    v20 = v19;
  else
    v20 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  return v20;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::tensor::PadOp &>(mlir::tensor::PadOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

void `anonymous namespace'::FoldStaticPadding::~FoldStaticPadding(_anonymous_namespace_::FoldStaticPadding *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::FoldStaticPadding::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  _QWORD *Value;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  void **v19;
  void *v20;
  uint64_t DefiningOp;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  BOOL v25;
  BOOL v26;
  BOOL v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  _DWORD *v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void **v37;
  uint64_t v38;
  void **v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  BOOL v44;
  BOOL v45;
  BOOL v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  const void *v52;
  uint64_t v53;
  size_t v54;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  const void *v58;
  uint64_t v59;
  size_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  void **v65;
  int v66;
  int v67;
  _QWORD *v68;
  _QWORD *v69;
  void **v70;
  _QWORD *v71;
  uint64_t i;
  uint64_t v73;
  void *v74;
  unsigned int v75;
  unint64_t *v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  size_t v80;
  uint64_t v81;
  unsigned int v82;
  unsigned int v83;
  uint64_t v84;
  void **v85;
  int *v86;
  uint64_t v87;
  uint64_t v88;
  BOOL v89;
  BOOL v90;
  void *v91;
  void **v92;
  void **v93;
  uint64_t v94;
  uint64_t RHS;
  mlir::MLIRContext **v96;
  uint64_t v97;
  unint64_t v98;
  _QWORD *v99;
  uint64_t v100;
  uint64_t v101;
  int v102;
  uint64_t v103;
  uint64_t v104;
  ZinIrHalH13g *v105;
  mlir::Region *v106;
  unint64_t v107;
  uint64_t v108;
  ZinIrHalH13g *v109;
  mlir::MLIRContext **v110;
  unint64_t *__src;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  BOOL v115;
  _QWORD v116[2];
  _QWORD v117[2];
  ZinIrHalH13g *v118;
  uint64_t v119;
  uint64_t v120[2];
  uint64_t v121[2];
  unint64_t v122;
  uint64_t v123;
  uint64_t v124;
  void *__s1;
  uint64_t v126;
  int v127;
  uint64_t v128;
  uint64_t v129;
  int v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  void **v134;
  uint64_t v135;
  _BYTE v136[48];
  void **v137;
  uint64_t v138;
  _BYTE v139[48];
  void *v140;
  uint64_t v141;
  _BYTE v142[48];
  void *v143;
  uint64_t v144;
  _BYTE v145[48];
  _QWORD *v146;
  uint64_t v147;
  _QWORD v148[8];

  v148[6] = *MEMORY[0x24BDAC8D0];
  v123 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  v124 = a2;
  if (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v123 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    return 0;
  __s1 = (void *)(*(_QWORD *)(v123 + 8) & 0xFFFFFFFFFFFFFFF8);
  Value = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&__s1);
  v114 = v7;
  v8 = *(_DWORD *)(a2 + 36) ? a2 - 16 : 0;
  v122 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!v122)
    return 0;
  v110 = a3;
  __src = (unint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v122);
  v112 = v9;
  v146 = v148;
  v147 = 0x600000000;
  v10 = *(unsigned int *)(a2 + 44);
  v11 = a2 + 64;
  v12 = (v10 >> 23) & 1;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v13 = a2 + 64 + 16 * v12;
  else
    v13 = 0;
  v14 = *(_DWORD *)(v13 + 28);
  if ((v10 & 0x800000) != 0)
  {
    v15 = *(_QWORD *)(a2 + 72);
    v16 = "IrConstData_dummyI6e4m3_tENS_9allocatorIS3_EEEE";
    v113 = a2 + 64;
    if (v14)
    {
LABEL_12:
      v17 = *(unsigned int *)(v13 + 24);
      v18 = (v14 + v17) - v17;
      v19 = (void **)(v15 + 32 * v17 + 24);
      while (1)
      {
        v20 = *v19;
        LODWORD(v144) = 1;
        v143 = 0;
        BYTE4(v144) = 0;
        v137 = &v143;
        v140 = v20;
        DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v140);
        if (!DefiningOp)
          goto LABEL_37;
        v22 = DefiningOp;
        if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
          goto LABEL_37;
        __s1 = &v127;
        v126 = 0x100000000;
        mlir::Operation::fold(v22, 0, 0, (uint64_t)&__s1);
        v23 = *(_QWORD *)__s1;
        if (__s1 != &v127)
          free(__s1);
        if ((v23 & 0xFFFFFFFFFFFFFFF8) != 0
          && ((v24 = *(void **)(*(_QWORD *)(*(_QWORD *)(v22 - 8) & 0xFFFFFFFFFFFFFFF8) + 136),
               v24 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
            ? (v25 = v24 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
            : (v25 = 1),
              !v25 ? (v26 = v24 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id) : (v26 = 1),
              !v26 ? (v27 = v24 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) : (v27 = 1),
              v27
           && (mlir::detail::constant_int_value_binder::match((uint64_t *)&v137, v23 & 0xFFFFFFFFFFFFFFF8) & 1) != 0))
        {
          if (BYTE4(v144))
          {
            if (v144 >= 0x41)
              v28 = (uint64_t *)v143;
            else
              v28 = (uint64_t *)&v143;
            v29 = *v28;
            v30 = v147;
            if (v147 < (unint64_t)HIDWORD(v147))
              goto LABEL_38;
LABEL_36:
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v146, v148, v30 + 1, 8);
            v30 = v147;
            goto LABEL_38;
          }
          if (v144 > 0x40)
          {
            v29 = *(_QWORD *)v143;
            v30 = v147;
            if (v147 >= (unint64_t)HIDWORD(v147))
              goto LABEL_36;
          }
          else
          {
            v29 = (uint64_t)((_QWORD)v143 << -(char)v144) >> -(char)v144;
            v30 = v147;
            if (v147 >= (unint64_t)HIDWORD(v147))
              goto LABEL_36;
          }
        }
        else
        {
LABEL_37:
          v30 = v147;
          v29 = 0x8000000000000000;
          if (v147 >= (unint64_t)HIDWORD(v147))
            goto LABEL_36;
        }
LABEL_38:
        v146[v30] = v29;
        LODWORD(v147) = v147 + 1;
        if (v144 >= 0x41 && v143)
          MEMORY[0x20BD002D4](v143, 0x1000C8000313F17);
        v19 += 4;
        if (!--v18)
        {
          v10 = *(unsigned int *)(a2 + 44);
          v12 = (v10 >> 23) & 1;
          v31 = v10 & 0x800000;
          v11 = v113;
          v16 = "NSt3__120__shared_ptr_emplaceI20ZinIrConstData_dummyI6e4m3_tENS_9allocatorIS3_EEEE" + 35;
          goto LABEL_49;
        }
      }
    }
  }
  else
  {
    v15 = 0;
    v16 = "IrConstData_dummyI6e4m3_tENS_9allocatorIS3_EEEE";
    v113 = a2 + 64;
    if (v14)
      goto LABEL_12;
  }
  v31 = v10 & 0x800000;
LABEL_49:
  v143 = v145;
  v144 = 0x600000000;
  if (BYTE3(v10))
    v32 = (_DWORD *)(v11 + 16 * v12);
  else
    v32 = 0;
  v33 = v32[8];
  if (v31)
  {
    v34 = *(_QWORD *)(a2 + 72);
    if (!v33)
      goto LABEL_89;
    goto LABEL_54;
  }
  v34 = 0;
  if (v33)
  {
LABEL_54:
    v35 = (v32[7] + v32[6]);
    v36 = (v33 + v35) - v35;
    v37 = (void **)(v34 + 32 * v35 + 24);
    v38 = *((_QWORD *)v16 + 92);
    while (1)
    {
      v39 = (void **)*v37;
      LODWORD(v141) = 1;
      v140 = 0;
      BYTE4(v141) = 0;
      v134 = &v140;
      v137 = v39;
      v40 = mlir::Value::getDefiningOp((mlir::Value *)&v137);
      if (!v40)
        goto LABEL_79;
      v41 = v40;
      if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(v40 + 48)))
        goto LABEL_79;
      __s1 = &v127;
      v126 = v38;
      mlir::Operation::fold(v41, 0, 0, (uint64_t)&__s1);
      v42 = *(_QWORD *)__s1;
      if (__s1 != &v127)
        free(__s1);
      if ((v42 & 0xFFFFFFFFFFFFFFF8) != 0
        && ((v43 = *(void **)(*(_QWORD *)(*(_QWORD *)(v41 - 8) & 0xFFFFFFFFFFFFFFF8) + 136),
             v43 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
          ? (v44 = v43 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
          : (v44 = 1),
            !v44 ? (v45 = v43 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id) : (v45 = 1),
            !v45 ? (v46 = v43 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) : (v46 = 1),
            v46
         && (mlir::detail::constant_int_value_binder::match((uint64_t *)&v134, v42 & 0xFFFFFFFFFFFFFFF8) & 1) != 0))
      {
        if (BYTE4(v141))
        {
          if (v141 >= 0x41)
            v47 = (uint64_t *)v140;
          else
            v47 = (uint64_t *)&v140;
          v48 = *v47;
          v49 = v144;
          if (v144 < (unint64_t)HIDWORD(v144))
            goto LABEL_80;
LABEL_78:
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v143, v145, v49 + 1, 8);
          v49 = v144;
          goto LABEL_80;
        }
        if (v141 > 0x40)
        {
          v48 = *(_QWORD *)v140;
          v49 = v144;
          if (v144 >= (unint64_t)HIDWORD(v144))
            goto LABEL_78;
        }
        else
        {
          v48 = (uint64_t)((_QWORD)v140 << -(char)v141) >> -(char)v141;
          v49 = v144;
          if (v144 >= (unint64_t)HIDWORD(v144))
            goto LABEL_78;
        }
      }
      else
      {
LABEL_79:
        v49 = v144;
        v48 = 0x8000000000000000;
        if (v144 >= (unint64_t)HIDWORD(v144))
          goto LABEL_78;
      }
LABEL_80:
      *((_QWORD *)v143 + v49) = v48;
      LODWORD(v144) = v144 + 1;
      if (v141 >= 0x41 && v140)
        MEMORY[0x20BD002D4](v140, 0x1000C8000313F17);
      v37 += 4;
      if (!--v36)
      {
        v10 = *(unsigned int *)(a2 + 44);
        v12 = (v10 >> 23) & 1;
        v11 = v113;
        break;
      }
    }
  }
LABEL_89:
  v50 = v11 + 16 * v12;
  if (!BYTE3(v10))
    v50 = 0;
  __s1 = *(void **)(v50 + 16);
  v52 = (const void *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&__s1);
  v53 = v51;
  v140 = v142;
  v141 = 0x600000000;
  v54 = 8 * v51;
  if ((unint64_t)(8 * v51) < 0x31)
  {
    v55 = 0;
    if (!v51)
      goto LABEL_96;
    goto LABEL_95;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v142, (8 * v51) >> 3, 8);
  v55 = v141;
  if (v53)
  {
LABEL_95:
    memcpy((char *)v140 + 8 * v55, v52, v54);
    v55 = v141;
  }
LABEL_96:
  LODWORD(v141) = v55 + (v54 >> 3);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v56 = v11 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1);
  else
    v56 = 0;
  __s1 = *(void **)(v56 + 8);
  v58 = (const void *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&__s1);
  v59 = v57;
  v137 = (void **)v139;
  v138 = 0x600000000;
  v60 = 8 * v57;
  if ((unint64_t)(8 * v57) >= 0x31)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v137, v139, (8 * v57) >> 3, 8);
    v61 = v138;
    if (!v59)
      goto LABEL_104;
    goto LABEL_103;
  }
  v61 = 0;
  if (v57)
  {
LABEL_103:
    memcpy(&v137[v61], v58, v60);
    v61 = v138;
  }
LABEL_104:
  v62 = v61 + (v60 >> 3);
  LODWORD(v138) = v62;
  v63 = v114;
  if (v114 != v112 || v114 != v141 || v114 != v62)
    goto LABEL_145;
  v64 = v140;
  v65 = v137;
  if (v114)
  {
    v66 = 0;
    v67 = 0;
    v68 = v146;
    v69 = v143;
    v70 = v137;
    v71 = v140;
    for (i = v114; i; --i)
    {
      if (*v71 == 0x8000000000000000)
      {
        v73 = v68[v66++];
        *v71 = v73;
        if (*v70 == (void *)0x8000000000000000)
          goto LABEL_114;
      }
      else if (*v70 == (void *)0x8000000000000000)
      {
LABEL_114:
        v74 = (void *)v69[v67++];
        *v70 = v74;
      }
      ++v71;
      ++v70;
    }
  }
  v121[0] = (uint64_t)v64;
  v121[1] = v114;
  v120[0] = (uint64_t)v65;
  v120[1] = v114;
  v134 = (void **)v136;
  v135 = 0x600000000;
  if (v114)
  {
    v75 = 0;
    v76 = __src;
    v77 = v114;
    do
    {
      v79 = *v76++;
      v78 = v79;
      if (v79 == 0x8000000000000000)
      {
        v78 = 0x8000000000000000;
        if (*v64 != 0x8000000000000000 && *v65 != (void *)0x8000000000000000)
        {
          if (*Value == 0x8000000000000000)
            v78 = 0x8000000000000000;
          else
            v78 = (unint64_t)*v65 + *v64 + *Value;
        }
      }
      if (v75 >= HIDWORD(v135))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v134, v136, v75 + 1, 8);
        v63 = v114;
        v75 = v135;
      }
      v134[v75] = (void *)v78;
      v75 = v135 + 1;
      LODWORD(v135) = v135 + 1;
      ++v64;
      ++v65;
      ++Value;
      --v77;
    }
    while (v77);
  }
  __s1 = &v127;
  v126 = 0x600000000;
  v80 = 8 * v63;
  if ((unint64_t)(8 * v63) >= 0x31)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__s1, &v127, (8 * v63) >> 3, 8);
    v81 = v113;
    v82 = v126;
    if (!v114)
      goto LABEL_131;
    goto LABEL_130;
  }
  v82 = 0;
  v81 = v113;
  if (v63)
  {
LABEL_130:
    memcpy((char *)__s1 + 8 * v82, __src, v80);
    v82 = v126;
  }
LABEL_131:
  v83 = v82 + (v80 >> 3);
  LODWORD(v126) = v83;
  v84 = v135;
  v85 = v134;
  if (v83 != (_DWORD)v135 || (v86 = (int *)__s1, memcmp(__s1, v134, 8 * v83)))
  {
    if ((_DWORD)v84)
    {
      v87 = 8 * v84 - 8;
      do
      {
        v88 = (uint64_t)*v85++;
        v89 = v88 == 0x8000000000000000;
        v90 = v88 != 0x8000000000000000 || v87 == 0;
        v87 -= 8;
      }
      while (!v90);
      v91 = __s1;
      if (__s1 != &v127)
        goto LABEL_141;
    }
    else
    {
      v89 = 1;
      v91 = __s1;
      if (__s1 != &v127)
LABEL_141:
        free(v91);
    }
    if (!v89)
    {
      v93 = v134;
      v94 = v135;
      __s1 = (void *)(*(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
      RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&__s1);
      v119 = mlir::RankedTensorType::get((uint64_t)v93, v94, RHS, 0);
      v96 = v110 + 1;
      v97 = *(_QWORD *)(a2 + 24);
      v98 = *(unsigned int *)(a2 + 44);
      v99 = (_QWORD *)(v81 + 16 * ((v98 >> 23) & 1));
      if (HIBYTE(*(_DWORD *)(a2 + 44)))
        v100 = v81 + 16 * ((v98 >> 23) & 1);
      else
        v100 = 0;
      v101 = *(unsigned int *)(v100 + 24);
      v102 = *(_DWORD *)(v100 + 28);
      if ((v98 & 0x800000) != 0)
        v103 = *(_QWORD *)(a2 + 72);
      else
        v103 = 0;
      v117[0] = v103 + 32 * v101;
      v117[1] = (v102 + v101) - v101;
      v116[0] = mlir::memref::ReinterpretCastOp::getSizes((mlir::memref::ReinterpretCastOp *)&v124);
      v116[1] = v104;
      v115 = *v99 != 0;
      mlir::getPrunedAttributeList((_BYTE *)a2, (uint64_t)&mlir::tensor::PadOp::getAttributeNames(void)::attrNames, 4, (uint64_t)&__s1);
      v105 = mlir::OpBuilder::create<mlir::tensor::PadOp,mlir::RankedTensorType &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>,mlir::OperandRange,mlir::OperandRange,BOOL,llvm::SmallVector<mlir::NamedAttribute,3u>>(v96, v97, &v119, &v123, v121, v120, (uint64_t)v117, (uint64_t)v116, (char *)&v115, (uint64_t)&__s1);
      v118 = v105;
      if (__s1 != &v127)
        free(__s1);
      v130 = 0;
      v131 = 0;
      v132 = 0;
      v133 = 0;
      v106 = (mlir::Region *)(((v81
                              + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                              + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                              + 7) & 0xFFFFFFFFFFFFFFF8)
                            + 32 * *(unsigned int *)(a2 + 40));
      v108 = *((unsigned int *)v105 + 10);
      v107 = *((unsigned int *)v105 + 11);
      __s1 = 0;
      v126 = 0;
      v127 = 0;
      v128 = 0;
      v129 = 0;
      mlir::Region::cloneInto(v106, (mlir::Region *)((((unint64_t)v105 + 16 * ((v107 >> 23) & 1) + ((v107 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * v108), (mlir::IRMapping *)&__s1);
      v109 = mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::RankedTensorType,mlir::tensor::EmptyOp &>((mlir::OpBuilder *)v96, *(_QWORD *)(a2 + 24), (uint64_t *)&v122, &v118);
      (*((void (**)(mlir::MLIRContext **, uint64_t, ZinIrHalH13g *))*v110 + 4))(v110, a2, v109);
      mlir::IRMapping::~IRMapping((llvm **)&__s1);
    }
    goto LABEL_143;
  }
  if (v86 != &v127)
  {
    free(v86);
    v92 = v134;
    if (v134 == (void **)v136)
      goto LABEL_145;
    goto LABEL_144;
  }
LABEL_143:
  v92 = v134;
  if (v134 != (void **)v136)
LABEL_144:
    free(v92);
LABEL_145:
  if (v137 != (void **)v139)
    free(v137);
  if (v140 != v142)
    free(v140);
  if (v143 != v145)
    free(v143);
  if (v146 != v148)
    free(v146);
  return 0;
}

_QWORD *`anonymous namespace'::InsertSliceOpConstantArgumentFolder<mlir::tensor::ParallelInsertSliceOp>::~InsertSliceOpConstantArgumentFolder(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void `anonymous namespace'::InsertSliceOpConstantArgumentFolder<mlir::tensor::ParallelInsertSliceOp>::~InsertSliceOpConstantArgumentFolder(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::ParallelInsertSliceOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::ParallelInsertSliceOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::ParallelInsertSliceOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t `anonymous namespace'::InsertSliceOpConstantArgumentFolder<mlir::tensor::ParallelInsertSliceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  _BYTE *v5;
  unsigned int v6;
  int v7;
  _BYTE *v8;
  unsigned int v9;
  int v10;
  _BYTE *v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  _OWORD *v15;
  mlir::Block *ParentOp;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  ZinIrHalH13g *v21;
  uint64_t v22;
  void *v23;
  __int128 v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  _BYTE v31[32];
  void *__dst;
  uint64_t v33;
  _BYTE v34[48];
  void *__src;
  uint64_t v36;
  _BYTE v37[48];
  _QWORD *v38;
  uint64_t v39;
  _QWORD v40[7];

  v40[6] = *MEMORY[0x24BDAC8D0];
  v28 = a2;
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedOffsets((mlir::memref::ReinterpretCastOp *)&v28, (uint64_t)&__src);
  v38 = v40;
  v39 = 0x600000000;
  v4 = v36;
  v5 = __src;
  if ((_DWORD)v36)
  {
    if (__src == v37)
    {
      v6 = v36;
      if (v36 < 7
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v40, v36, 8),
            v6 = v36,
            v5 = __src,
            (_DWORD)v36))
      {
        memcpy(v38, v5, 8 * v6);
        v5 = __src;
      }
      LODWORD(v39) = v4;
    }
    else
    {
      v38 = __src;
      v39 = v36;
      __src = v37;
      HIDWORD(v36) = 0;
      v5 = v37;
    }
    LODWORD(v36) = 0;
  }
  if (v5 != v37)
    free(v5);
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedSizes((mlir::memref::ReinterpretCastOp *)&v28, (uint64_t)&__dst);
  __src = v37;
  v36 = 0x600000000;
  v7 = v33;
  v8 = __dst;
  if ((_DWORD)v33)
  {
    if (__dst == v34)
    {
      v9 = v33;
      if (v33 < 7
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v37, v33, 8),
            v9 = v33,
            v8 = __dst,
            (_DWORD)v33))
      {
        memcpy(__src, v8, 8 * v9);
        v8 = __dst;
      }
      LODWORD(v36) = v7;
    }
    else
    {
      __src = __dst;
      v36 = v33;
      __dst = v34;
      HIDWORD(v33) = 0;
      v8 = v34;
    }
    LODWORD(v33) = 0;
  }
  if (v8 != v34)
    free(v8);
  mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedStrides((mlir::memref::ReinterpretCastOp *)&v28, (uint64_t)&v29);
  __dst = v34;
  v33 = 0x600000000;
  v10 = v30;
  v11 = v29;
  if ((_DWORD)v30)
  {
    if (v29 == v31)
    {
      v12 = v30;
      if (v30 < 7
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v34, v30, 8),
            v12 = v30,
            v11 = v29,
            (_DWORD)v30))
      {
        memcpy(__dst, v11, 8 * v12);
        v11 = v29;
      }
      LODWORD(v33) = v10;
    }
    else
    {
      __dst = v29;
      v33 = v30;
      v29 = v31;
      HIDWORD(v30) = 0;
      v11 = v31;
    }
    LODWORD(v30) = 0;
  }
  if (v11 != v31)
    free(v11);
  if (mlir::foldDynamicIndexList((uint64_t)&v38, 1)
    || mlir::foldDynamicIndexList((uint64_t)&__src, 1)
    || mlir::foldDynamicIndexList((uint64_t)&__dst, 0))
  {
    v27 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v28 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v27);
    if (*(_BYTE *)(v28 + 47))
      v14 = v28 + 80;
    else
      v14 = 0;
    v29 = (void *)mlir::tensor::ExtractSliceOp::inferCanonicalRankReducedResultType(v13, (void *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v28 + 72) + 32 * *(unsigned int *)(v14 + 24) + 24)+ 8) & 0xFFFFFFFFFFFFFFF8), v38, v39, (uint64_t *)__src, v36, (uint64_t *)__dst, v33);
    v27 = *(_QWORD *)(*(_QWORD *)(v28 + 72) + 24);
    if (v29 != (void *)(*(_QWORD *)(v27 + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      v15 = (_OWORD *)(a3 + 24);
      v25 = *(_OWORD *)(a3 + 24);
      ParentOp = *(mlir::Block **)(v28 + 16);
      if (ParentOp)
        ParentOp = (mlir::Block *)mlir::Block::getParentOp(ParentOp);
      v17 = *((_QWORD *)ParentOp + 2);
      ZinIrHalH13g::~ZinIrHalH13g(ParentOp);
      *(_QWORD *)(a3 + 24) = v17;
      *(_QWORD *)(a3 + 32) = v18;
      v27 = (unint64_t)mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::TensorType &,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(v28 + 24), (uint64_t *)&v29, (uint64_t *)&v27)- 16;
      if ((_QWORD)v25)
      {
        *v15 = v25;
      }
      else
      {
        *(_QWORD *)v15 = 0;
        *(_QWORD *)(a3 + 32) = 0;
      }
    }
    v19 = v28;
    if (*(_BYTE *)(v28 + 47))
      v20 = v28 + 80;
    else
      v20 = 0;
    v26 = *(_QWORD *)(*(_QWORD *)(v28 + 72) + 32 * *(unsigned int *)(v20 + 24) + 24);
    v21 = mlir::OpBuilder::create<mlir::tensor::ParallelInsertSliceOp,mlir::Value &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>((mlir::MLIRContext **)(a3 + 8), *(_QWORD *)(v28 + 24), (uint64_t *)&v27, &v26, (uint64_t)&v38, (uint64_t)&__src, (uint64_t)&__dst);
    (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, v19, v21);
    v22 = 1;
    v23 = __dst;
    if (__dst != v34)
      goto LABEL_47;
  }
  else
  {
    v22 = 0;
    v23 = __dst;
    if (__dst != v34)
LABEL_47:
      free(v23);
  }
  if (__src != v37)
    free(__src);
  if (v38 != v40)
    free(v38);
  return v22;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::ParallelInsertSliceOp,mlir::Value &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t *Context;
  uint64_t v15;
  char v16;
  ZinIrHalH13g *v17;
  ZinIrHalH13g *v18;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x24BDAC8D0];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.parallel_insert_slice", (const unsigned __int8 *)0x1C, Context);
  if (!v16)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"tensor.parallel_insert_slice";
    v23[3] = 28;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::tensor::ParallelInsertSliceOp::build(a1, (uint64_t)v25, *a3, *a4, *(uint64_t **)a5, *(unsigned int *)(a5 + 8), *(uint64_t **)a6, *(unsigned int *)(a6 + 8), *(uint64_t **)a7, *(unsigned int *)(a7 + 8), 0, 0);
  v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((_QWORD *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::ParallelInsertSliceOp,void>::id)
    v18 = v17;
  else
    v18 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

_QWORD *`anonymous namespace'::InsertSliceOpCastFolder<mlir::tensor::ParallelInsertSliceOp>::~InsertSliceOpCastFolder(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void `anonymous namespace'::InsertSliceOpCastFolder<mlir::tensor::ParallelInsertSliceOp>::~InsertSliceOpCastFolder(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::InsertSliceOpCastFolder<mlir::tensor::ParallelInsertSliceOp>::matchAndRewrite(uint64_t DefiningOp, uint64_t a2, mlir::MLIRContext **a3)
{
  uint64_t v5;
  void **v6;
  void *v7;
  mlir::Operation *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t RHS;
  _QWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  ZinIrHalH13g *v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42[2];
  void *v43[2];
  uint64_t v44;
  void *v45[2];
  uint64_t v46;
  void *v47[2];
  _QWORD v48[5];

  v48[4] = *MEMORY[0x24BDAC8D0];
  v41 = a2;
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
  {
    v5 = *(unsigned int *)(a2 + 68);
    if ((_DWORD)v5)
    {
      v6 = (void **)(*(_QWORD *)(a2 + 72) + 24);
      do
      {
        v7 = *v6;
        ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)DefiningOp);
        v47[0] = v7;
        DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v47);
        if (DefiningOp)
        {
          DefiningOp = mlir::arith::ConstantIndexOp::classof(DefiningOp, v8);
          if ((DefiningOp & 1) != 0)
            return 0;
        }
        v6 += 4;
      }
      while (--v5);
    }
  }
  v47[0] = *(void **)(*(_QWORD *)(a2 + 72) + 24);
  v9 = mlir::Value::getDefiningOp((mlir::Value *)v47);
  if (v9
    && (v10 = v9,
        *(_UNKNOWN **)(*(_QWORD *)(v9 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id)
    && mlir::tensor::preservesStaticInformation(*(_QWORD *)(v9 - 8) & 0xFFFFFFFFFFFFFFF8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    v11 = 0;
    v12 = *(_QWORD *)(*(_QWORD *)(v10 + 72) + 24) & 0xFFFFFFFFFFFFFF00;
    v13 = *(_QWORD *)(*(_QWORD *)(v10 + 72) + 24);
  }
  else
  {
    v13 = 0;
    v12 = 0;
    v11 = 1;
  }
  v14 = v12 | v13;
  if (*(_BYTE *)(a2 + 47))
    v15 = a2 + 80;
  else
    v15 = 0;
  v47[0] = *(void **)(*(_QWORD *)(a2 + 72) + 32 * *(unsigned int *)(v15 + 24) + 24);
  v16 = mlir::Value::getDefiningOp((mlir::Value *)v47);
  if (v16
    && (v17 = v16,
        *(_UNKNOWN **)(*(_QWORD *)(v16 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id)
    && (mlir::tensor::preservesStaticInformation(*(_QWORD *)(v16 - 8) & 0xFFFFFFFFFFFFFFF8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v16 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0)
  {
    v18 = *(_QWORD *)(*(_QWORD *)(v17 + 72) + 24);
    if (v11)
      v14 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
    v40 = v14;
  }
  else
  {
    if ((v11 & 1) != 0)
      return 0;
    v40 = v14;
    if (*(_BYTE *)(a2 + 47))
      v20 = a2 + 80;
    else
      v20 = 0;
    v18 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 32 * *(unsigned int *)(v20 + 24) + 24);
  }
  result = 0;
  v39 = v18;
  if (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v14 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v21 = (_QWORD *)(*(_QWORD *)(v14 + 8) & 0xFFFFFFFFFFFFFFF8);
  else
    v21 = 0;
  v22 = *(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(_QWORD *)v22 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v23 = (void *)v22;
  else
    v23 = 0;
  if (v21 && v23)
  {
    v24 = a2 + 64;
    v47[0] = *(void **)(a2 + 64 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1));
    mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v47);
    if (HIBYTE(*(_DWORD *)(a2 + 44)))
      v25 = v24 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1);
    else
      v25 = 0;
    v47[0] = *(void **)(v25 + 8);
    v26 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v47);
    v28 = v27;
    if (HIBYTE(*(_DWORD *)(a2 + 44)))
      v29 = v24 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1);
    else
      v29 = 0;
    v47[0] = *(void **)(v29 + 16);
    mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v47);
    v47[0] = v23;
    RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)v47);
    v31 = (_QWORD *)mlir::RankedTensorType::get(v26, v28, RHS, 0);
    v32 = v31;
    if (v31)
      v33 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v31 + 8);
    else
      v33 = 0;
    mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
    if (mlir::isRankReducedType(v32, v33, v21))
    {
      return 0;
    }
    else
    {
      v34 = *(_QWORD *)(a2 + 24);
      mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedOffsets((mlir::memref::ReinterpretCastOp *)&v41, (uint64_t)v47);
      mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedSizes((mlir::memref::ReinterpretCastOp *)&v41, (uint64_t)v45);
      mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedStrides((mlir::memref::ReinterpretCastOp *)&v41, (uint64_t)v43);
      v35 = mlir::OpBuilder::create<mlir::tensor::ParallelInsertSliceOp,mlir::Value &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>(a3 + 1, v34, &v40, &v39, (uint64_t)v47, (uint64_t)v45, (uint64_t)v43);
      if (v43[0] != &v44)
        free(v43[0]);
      if (v45[0] != &v46)
        free(v45[0]);
      if (v47[0] != v48)
        free(v47[0]);
      v36 = v41;
      v37 = *((unsigned int *)v35 + 9);
      if ((_DWORD)v37)
        v38 = (uint64_t)v35 - 16;
      else
        v38 = 0;
      mlir::ValueRange::ValueRange(v42, v38, v37);
      (*((void (**)(mlir::MLIRContext **, uint64_t, unint64_t, unint64_t))*a3 + 3))(a3, v36, v42[0], v42[1]);
      return 1;
    }
  }
  return result;
}

_QWORD *`anonymous namespace'::InsertSliceOpSourceCastInserter<mlir::tensor::ParallelInsertSliceOp>::~InsertSliceOpSourceCastInserter(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void `anonymous namespace'::InsertSliceOpSourceCastInserter<mlir::tensor::ParallelInsertSliceOp>::~InsertSliceOpSourceCastInserter(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::InsertSliceOpSourceCastInserter<mlir::tensor::ParallelInsertSliceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *Value;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  uint64_t v18;
  unint64_t ConstantIntValue;
  char v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t RHS;
  uint64_t v25;
  _OWORD *v26;
  mlir::Block *ParentOp;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  ZinIrHalH13g *v33;
  void *v34;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  void *v42[2];
  uint64_t v43;
  void *v44[2];
  uint64_t v45;
  unint64_t v46[2];
  unint64_t v47[2];
  void *v48[2];
  _BYTE v49[32];
  _QWORD *v50;
  uint64_t v51;
  _QWORD v52[7];

  v52[6] = *MEMORY[0x24BDAC8D0];
  v40 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v41 = a2;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v40);
  v6 = v5;
  if (*(_BYTE *)(a2 + 47))
    v7 = a2 + 80;
  else
    v7 = 0;
  v50 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 32 * *(unsigned int *)(v7 + 24) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v50);
  if (v6 != v8)
    return 0;
  Value = (_BYTE *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v40);
  v10 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v40);
  v12 = (_BYTE *)(v10 + 8 * v11);
  v50 = v52;
  v51 = 0x600000000;
  v13 = v12 - Value;
  if ((unint64_t)(v12 - Value) >= 0x31)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v52, v13 >> 3, 8);
    v14 = v51;
    if (v12 == Value)
      goto LABEL_11;
    goto LABEL_10;
  }
  v14 = 0;
  if (v12 != Value)
  {
LABEL_10:
    memcpy(&v50[v14], Value, v12 - Value);
    v14 = v51;
  }
LABEL_11:
  LODWORD(v51) = v14 + ((unint64_t)v13 >> 3);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v40);
  if (v16 >= 1)
  {
    for (i = 0; i < v18; ++i)
    {
      mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedSizes((mlir::memref::ReinterpretCastOp *)&v41, (uint64_t)v48);
      ConstantIntValue = mlir::getConstantIntValue(*((_QWORD *)v48[0] + i));
      v21 = v20;
      if (v48[0] != v49)
        free(v48[0]);
      if (v21)
      {
        if ((ConstantIntValue & 0x8000000000000000) != 0)
          goto LABEL_36;
        v50[i] = ConstantIntValue;
      }
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v40);
    }
  }
  v22 = (uint64_t)v50;
  v23 = v51;
  RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v40);
  v25 = mlir::RankedTensorType::get(v22, v23, RHS, 0);
  v39 = v25;
  if (v40 != v25)
  {
    if (mlir::tensor::preservesStaticInformation(v40, v25))
    {
      mlir::ValueRange::ValueRange(v47, (uint64_t)&v40, 1uLL);
      mlir::ValueRange::ValueRange(v46, (uint64_t)&v39, 1uLL);
      if (mlir::tensor::CastOp::areCastCompatible(v47[0], v47[1], v46[0], v46[1]))
      {
        v26 = (_OWORD *)(a3 + 24);
        v36 = *(_OWORD *)(a3 + 24);
        ParentOp = *(mlir::Block **)(v41 + 16);
        if (ParentOp)
          ParentOp = (mlir::Block *)mlir::Block::getParentOp(ParentOp);
        v28 = *((_QWORD *)ParentOp + 2);
        ZinIrHalH13g::~ZinIrHalH13g(ParentOp);
        *(_QWORD *)(a3 + 24) = v28;
        *(_QWORD *)(a3 + 32) = v29;
        v30 = *(_QWORD *)(v41 + 24);
        v48[0] = *(void **)(*(_QWORD *)(v41 + 72) + 24);
        v38 = (uint64_t)mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::TensorType &,mlir::Value>((mlir::OpBuilder *)(a3 + 8), v30, &v39, (uint64_t *)v48)- 16;
        v31 = v41;
        if (*(_BYTE *)(v41 + 47))
          v32 = v41 + 80;
        else
          v32 = 0;
        v37 = *(_QWORD *)(*(_QWORD *)(v41 + 72) + 32 * *(unsigned int *)(v32 + 24) + 24);
        mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedOffsets((mlir::memref::ReinterpretCastOp *)&v41, (uint64_t)v48);
        mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedSizes((mlir::memref::ReinterpretCastOp *)&v41, (uint64_t)v44);
        mlir::detail::OffsetSizeAndStrideOpInterfaceTrait<mlir::tensor::InsertSliceOp>::getMixedStrides((mlir::memref::ReinterpretCastOp *)&v41, (uint64_t)v42);
        v33 = mlir::OpBuilder::create<mlir::tensor::ParallelInsertSliceOp,mlir::Value &,mlir::detail::TypedValue<mlir::RankedTensorType>,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &>((mlir::MLIRContext **)(a3 + 8), *(_QWORD *)(v31 + 24), &v38, &v37, (uint64_t)v48, (uint64_t)v44, (uint64_t)v42);
        (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, v31, v33);
        if (v42[0] != &v43)
          free(v42[0]);
        if (v44[0] != &v45)
          free(v44[0]);
        if (v48[0] != v49)
          free(v48[0]);
        if ((_QWORD)v36)
        {
          *v26 = v36;
          v15 = 1;
          v34 = v50;
          if (v50 == v52)
            return v15;
        }
        else
        {
          *(_QWORD *)v26 = 0;
          *(_QWORD *)(a3 + 32) = 0;
          v15 = 1;
          v34 = v50;
          if (v50 == v52)
            return v15;
        }
        goto LABEL_37;
      }
    }
  }
LABEL_36:
  v15 = 0;
  v34 = v50;
  if (v50 != v52)
LABEL_37:
    free(v34);
  return v15;
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::PackOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::PackOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::PackOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t llvm::all_of<llvm::detail::zippy<llvm::detail::zip_shortest,llvm::ArrayRef<long long>,llvm::SmallVector<mlir::OpFoldResult,6u> &>,mlir::LogicalResult commonVerifierPackAndUnPackOp<mlir::tensor::PackOp>(mlir::tensor::PackOp)::{lambda(std::tuple<long long,mlir::OpFoldResult>)#1}>(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  uint64_t result;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t ConstantIntValue;
  char v12;
  uint64_t v14;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(unsigned int *)(v2 + 8);
  if (v1)
    v4 = (_DWORD)v3 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    v6 = *(uint64_t **)a1;
    v7 = *(uint64_t **)v2;
    v8 = 8 * v3 - 8;
    v9 = 8 * v1 - 8;
    while (1)
    {
      v10 = *v6;
      ConstantIntValue = mlir::getConstantIntValue(*v7);
      if (v12)
      {
        if (v10 != 0x8000000000000000 && v10 != ConstantIntValue)
          return 0;
      }
      else if (v10 != 0x8000000000000000)
      {
        return 0;
      }
      result = 1;
      if (v9)
      {
        ++v6;
        ++v7;
        v14 = v8;
        v8 -= 8;
        v9 -= 8;
        if (v14)
          continue;
      }
      return result;
    }
  }
  return 1;
}

void mlir::RewritePatternSet::addImpl<FoldTensorCastProducerOp,mlir::MLIRContext *>(_QWORD *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  const char *v18;
  unint64_t v19;
  uint64_t v20;
  const char *v21;
  unint64_t v22;
  uint64_t v23;
  const char *v24;
  unint64_t v25;

  v8 = operator new();
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v24, 1);
  mlir::OpInterfaceRewritePattern<mlir::DestinationStyleOpInterface>::OpInterfaceRewritePattern((_QWORD *)v8, v9, (__int16)v24);
  *(_QWORD *)v8 = &unk_24C022AA8;
  v23 = v8;
  if (*(_QWORD *)(v8 + 72))
  {
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
      goto LABEL_3;
  }
  else
  {
    v24 = "StringRef llvm::getTypeName() [DesiredTypeName = FoldTensorCastProducerOp]";
    v25 = 74;
    v16 = llvm::StringRef::find((uint64_t *)&v24, "DesiredTypeName = ", 0x12uLL, 0);
    if (v25 >= v16)
      v17 = v16;
    else
      v17 = v25;
    v18 = &v24[v17];
    v19 = v25 - v17;
    if (v25 - v17 >= 0x12)
      v20 = 18;
    else
      v20 = v25 - v17;
    v21 = &v18[v20];
    v22 = v19 - v20;
    if (v22 >= v22 - 1)
      --v22;
    *(_QWORD *)(v8 + 64) = v21;
    *(_QWORD *)(v8 + 72) = v22;
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
    {
LABEL_3:
      if (!a3)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod(v8 + 80, (void *)(v8 + 96), v12, 16);
  LODWORD(v11) = *(_DWORD *)(v8 + 88);
  if (a3)
  {
LABEL_4:
    memcpy((void *)(*(_QWORD *)(v8 + 80) + 16 * v11), a2, v10);
    LODWORD(v11) = *(_DWORD *)(v8 + 88);
  }
LABEL_5:
  *(_DWORD *)(v8 + 88) = v11 + (v10 >> 4);
  v13 = (uint64_t *)a1[2];
  if ((unint64_t)v13 >= a1[3])
  {
    v14 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, &v23);
    v15 = v23;
    a1[2] = v14;
    v23 = 0;
    if (v15)
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  }
  else
  {
    *v13 = v8;
    a1[2] = v13 + 1;
  }
}

_QWORD *mlir::OpInterfaceRewritePattern<mlir::DestinationStyleOpInterface>::OpInterfaceRewritePattern(_QWORD *a1, uint64_t a2, __int16 a3)
{
  uint64_t v3;
  unsigned __int8 v5;
  uint64_t *v6;
  int v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  __int16 v16;
  const char *v18;
  unint64_t v19;

  v3 = a2;
  v6 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v5 & 1) == 0)
  {
    v16 = a3;
    v6 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    a3 = v16;
    v3 = a2;
    if (v8)
    {
      v18 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DestinationStyleOpInterface]";
      v19 = 83;
      v9 = llvm::StringRef::find((uint64_t *)&v18, "DesiredTypeName = ", 0x12uLL, 0);
      if (v19 >= v9)
        v10 = v9;
      else
        v10 = v19;
      v11 = &v18[v10];
      v12 = v19 - v10;
      if (v19 - v10 >= 0x12)
        v13 = 18;
      else
        v13 = v19 - v10;
      v14 = v12 - v13;
      if (v14 >= v14 - 1)
        v15 = v14 - 1;
      else
        v15 = v14;
      mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v11[v13], v15);
      v6 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      a3 = v16;
      v3 = a2;
    }
  }
  mlir::Pattern::Pattern((uint64_t)(a1 + 1), v6[124], a3, v3, 0, 0);
  *a1 = &unk_24C04FAE0;
  return a1;
}

void FoldTensorCastProducerOp::~FoldTensorCastProducerOp(FoldTensorCastProducerOp *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::DestinationStyleOpInterface>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t InterfaceFor;

  if (a2)
    InterfaceFor = mlir::OpInterface<mlir::DestinationStyleOpInterface,mlir::detail::DestinationStyleOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
  else
    InterfaceFor = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, a2, InterfaceFor, a3);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::DestinationStyleOpInterface>::match(uint64_t a1, uint64_t a2)
{
  uint64_t InterfaceFor;

  if (a2)
    InterfaceFor = mlir::OpInterface<mlir::DestinationStyleOpInterface,mlir::detail::DestinationStyleOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
  else
    InterfaceFor = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 56))(a1, a2, InterfaceFor);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::DestinationStyleOpInterface>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t InterfaceFor;

  if (a2)
    InterfaceFor = mlir::OpInterface<mlir::DestinationStyleOpInterface,mlir::detail::DestinationStyleOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
  else
    InterfaceFor = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 64))(a1, a2, InterfaceFor, a3);
}

uint64_t FoldTensorCastProducerOp::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t DefiningOp;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int OperandNumber;
  unsigned int BeginOperandIndex;
  unint64_t v28;
  uint64_t v29;
  int v30;
  _QWORD v31[2];
  uint64_t v32;
  uint64_t v33;
  unint64_t v34[2];
  unint64_t v35[2];
  void *v36;
  uint64_t v37;
  _BYTE v38[32];
  void *v39;
  uint64_t v40;
  _BYTE v41[32];
  uint64_t v42;
  _QWORD *v43;
  _QWORD v44[5];

  v44[3] = *MEMORY[0x24BDAC8D0];
  v31[0] = a2;
  v31[1] = a3;
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::tensor::InsertSliceOp,void>::id
    && !mlir::OpInterface<mlir::LoopLikeOpInterface,mlir::detail::LoopLikeOpInterfaceInterfaceTraits>::getInterfaceFor(a2)
    && (*(_BYTE *)(a2 + 46) & 0x80) != 0)
  {
    v7 = *(unsigned int *)(a2 + 68);
    if ((_DWORD)v7)
    {
      v8 = *(_QWORD *)(a2 + 72);
      v9 = 32 * v7;
      v10 = v8 + 24;
      do
      {
        if ((~*(_DWORD *)(*(_QWORD *)v10 + 8) & 7) != 0)
        {
          v42 = *(_QWORD *)v10;
          DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v42);
          if (DefiningOp)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id
              && (mlir::tensor::preservesStaticInformation(*(_QWORD *)(DefiningOp - 8) & 0xFFFFFFFFFFFFFFF8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) != 0)
            {
              v39 = v41;
              v40 = 0x400000000;
              v12 = v31[0];
              v13 = *(unsigned int *)(v31[0] + 36);
              if (v13 >= 5)
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v41, v13, 8);
                v12 = v31[0];
              }
              v36 = v38;
              v37 = 0x400000000;
              if ((*(_BYTE *)(v12 + 46) & 0x80) != 0)
              {
                v14 = *(unsigned int *)(v12 + 68);
                if (v14 < 5
                  || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v36, v38, v14, 8),
                      v12 = v31[0],
                      (*(_BYTE *)(v31[0] + 46) & 0x80) != 0))
                {
                  v15 = *(unsigned int *)(v12 + 68);
                  if ((_DWORD)v15)
                  {
                    v16 = 32 * v15;
                    v17 = (uint64_t *)(*(_QWORD *)(v12 + 72) + 24);
                    do
                    {
                      v42 = *v17;
                      v18 = mlir::Value::getDefiningOp((mlir::Value *)&v42);
                      if (v18
                        && (v19 = v18,
                            *(_UNKNOWN **)(*(_QWORD *)(v18 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id))
                      {
                        v30 = mlir::tensor::preservesStaticInformation(*(_QWORD *)(v18 - 8) & 0xFFFFFFFFFFFFFFF8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v18 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
                        v20 = v17;
                        if (v30)
                          v20 = (uint64_t *)(*(_QWORD *)(v19 + 72) + 24);
                      }
                      else
                      {
                        v20 = v17;
                      }
                      v21 = *v20;
                      v22 = v37;
                      if (v37 >= (unint64_t)HIDWORD(v37))
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v36, v38, v37 + 1, 8);
                        v22 = v37;
                      }
                      *((_QWORD *)v36 + v22) = v21;
                      LODWORD(v37) = v37 + 1;
                      mlir::DestinationStyleOpInterface::getDpsInitsMutable(&v42, (mlir::DestinationStyleOpInterface *)v31);
                      v23 = mlir::MutableOperandRange::operator mlir::OperandRange((unsigned int *)&v42);
                      v25 = v24;
                      if (v43 != v44)
                        free(v43);
                      v32 = v23;
                      v33 = v25;
                      if (v25)
                      {
                        OperandNumber = mlir::OpOperand::getOperandNumber((unint64_t)(v17 - 3));
                        if (OperandNumber >= mlir::OperandRange::getBeginOperandIndex((mlir::OperandRange *)&v32))
                        {
                          BeginOperandIndex = mlir::OperandRange::getBeginOperandIndex((mlir::OperandRange *)&v32);
                          if (v33 + (unint64_t)BeginOperandIndex > OperandNumber)
                          {
                            v28 = *(_QWORD *)(*((_QWORD *)v36 + v37 - 1) + 8) & 0xFFFFFFFFFFFFFFF8;
                            if (*(_UNKNOWN **)(*(_QWORD *)v28 + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
                            {
                              v29 = v40;
                              if (v40 >= (unint64_t)HIDWORD(v40))
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v41, v40 + 1, 8);
                                v29 = v40;
                              }
                              *((_QWORD *)v39 + v29) = v28;
                              LODWORD(v40) = v40 + 1;
                            }
                          }
                        }
                      }
                      v17 += 4;
                      v16 -= 32;
                    }
                    while (v16);
                    v12 = v31[0];
                  }
                }
              }
              mlir::ValueRange::ValueRange(v35, (uint64_t)v39, v40);
              mlir::ValueRange::ValueRange(v34, (uint64_t)v36, v37);
              mlir::clone((mlir::OpBuilder *)(a4 + 8), v12, v35[0], v35[1], v34[0], v34[1]);
            }
          }
        }
        v10 += 32;
        v9 -= 32;
      }
      while (v9);
    }
  }
  return 0;
}

_QWORD *mlir::OpInterfaceRewritePattern<mlir::DestinationStyleOpInterface>::~OpInterfaceRewritePattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::OpInterfaceRewritePattern<mlir::DestinationStyleOpInterface>::~OpInterfaceRewritePattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::DestinationStyleOpInterface>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1))
    return 0;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, a2, a3, a4);
  return 1;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::CollapseShapeOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::ExpandShapeOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::ExtractSliceOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::GatherOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::GatherOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::GatherOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::GatherOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

BOOL _ZN4llvm12function_refIFN4mlir11ParseResultERNS1_9AttributeENS1_4TypeEEE11callback_fnIZNS1_9AsmParser32parseCustomAttributeWithFallbackINS1_6detail18DenseArrayAttrImplIxEEEENSt3__19enable_ifIXsr23detect_has_parse_methodIT_EE5valueES2_E4typeERSG_S5_EUlS4_S5_E_EES2_lS4_S5_(mlir::AsmParser **a1, uint64_t *a2)
{
  uint64_t v3;

  v3 = mlir::detail::DenseArrayAttrImpl<long long>::parse(*a1);
  *a2 = v3;
  return v3 != 0;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::GatherOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

uint64_t mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl<mlir::tensor::GenerateOp>::buildTerminator(uint64_t a1, uint64_t a2)
{
  const mlir::OperationState *v2;
  uint64_t v3;
  _QWORD v5[39];

  v5[38] = *MEMORY[0x24BDAC8D0];
  mlir::OperationState::OperationState(v5, a2, (uint64_t)"tensor.yield", 12);
  v3 = mlir::Operation::create((mlir::Operation *)v5, v2);
  mlir::OperationState::~OperationState((mlir::OperationState *)v5);
  return v3;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a2 + 28) = *(_OWORD *)(a3 + 28);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::InsertSliceOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::PackOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PackOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::PackOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PackOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

_QWORD *mlir::RewritePatternSet::add<mlir::tensor::PackOp>(mlir::LogicalResult (*)(mlir::tensor::PackOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::RewritePatternSet::add<mlir::tensor::PackOp>(mlir::LogicalResult (*)(mlir::tensor::PackOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RewritePatternSet::add<mlir::tensor::PackOp>(mlir::LogicalResult (*)(mlir::tensor::PackOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::PackOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::PadOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

uint64_t mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl<mlir::tensor::PadOp>::buildTerminator(uint64_t a1, uint64_t a2)
{
  const mlir::OperationState *v2;
  uint64_t v3;
  _QWORD v5[39];

  v5[38] = *MEMORY[0x24BDAC8D0];
  mlir::OperationState::OperationState(v5, a2, (uint64_t)"tensor.yield", 12);
  v3 = mlir::Operation::create((mlir::Operation *)v5, v2);
  mlir::OperationState::~OperationState((mlir::OperationState *)v5);
  return v3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::PadOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ParallelInsertSliceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a2 + 28) = *(_OWORD *)(a3 + 28);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::ParallelInsertSliceOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::ScatterOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ScatterOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::ScatterOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::ScatterOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::ScatterOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::UnPackOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::UnPackOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::tensor::detail::UnPackOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::tensor::detail::UnPackOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  return result;
}

_QWORD *mlir::RewritePatternSet::add<mlir::tensor::UnPackOp>(mlir::LogicalResult (*)(mlir::tensor::UnPackOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::RewritePatternSet::add<mlir::tensor::UnPackOp>(mlir::LogicalResult (*)(mlir::tensor::UnPackOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::UnPackOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::UnPackOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::UnPackOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::RewritePatternSet::add<mlir::tensor::UnPackOp>(mlir::LogicalResult (*)(mlir::tensor::UnPackOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::tensor::UnPackOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

double mlir::createCanonicalizerPass@<D0>(_QWORD *a1@<X8>)
{
  _QWORD *v3;
  double result;

  v3 = (_QWORD *)operator new();
  bzero(v3, 0x7D8uLL);
  *v3 = &off_24C028710;
  *((_WORD *)v3 + 972) = 256;
  *(_QWORD *)&result = 10;
  *((_OWORD *)v3 + 122) = xmmword_207AB54F0;
  v3[246] = 0;
  *((_DWORD *)v3 + 494) = 0;
  v3[248] = 0;
  v3[250] = 0;
  v3[249] = 0;
  *a1 = v3;
  return result;
}

uint64_t mlir::impl::CanonicalizerBase<`anonymous namespace'::Canonicalizer>::CanonicalizerBase(uint64_t a1)
{
  _QWORD *v2;
  int v4;
  int *v5;
  __n128 v6;

  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  v2 = (_QWORD *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = a1 + 200;
  *(_QWORD *)(a1 + 192) = 0x400000000;
  *(_QWORD *)(a1 + 232) = a1 + 248;
  *(_QWORD *)(a1 + 240) = 0x400000000;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0x1000000000;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_QWORD *)(a1 + 336) = 0;
  *(_QWORD *)a1 = off_24C051910;
  v6.n128_u64[0] = (unint64_t)"Seed the worklist in general top-down order";
  v6.n128_u64[1] = 43;
  LOBYTE(v4) = 1;
  v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 344), (_QWORD *)(a1 + 152), (uint64_t)"top-down", 8, &v6, (_BYTE **)&v5);
  *(_QWORD *)(a1 + 344) = &off_24C0509D0;
  *(_QWORD *)(a1 + 536) = &unk_24C050A50;
  v6.n128_u64[0] = (unint64_t)"Perform control flow optimizations to the region tree";
  v6.n128_u64[1] = 53;
  LOBYTE(v4) = 1;
  v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 552), v2, (uint64_t)"region-simplify", 15, &v6, (_BYTE **)&v5);
  *(_QWORD *)(a1 + 552) = &off_24C0509D0;
  *(_QWORD *)(a1 + 744) = &unk_24C050A50;
  v6.n128_u64[0] = (unint64_t)"Max. iterations between applying patterns / simplifying regions";
  v6.n128_u64[1] = 63;
  v4 = 10;
  v5 = &v4;
  mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((_QWORD *)(a1 + 760), v2, (uint64_t)"max-iterations", 14, &v6, &v5);
  *(_QWORD *)(a1 + 760) = off_24C050B50;
  *(_QWORD *)(a1 + 960) = &unk_24C050BD0;
  v6.n128_u64[0] = (unint64_t)"Max. number of pattern rewrites within an iteration";
  v6.n128_u64[1] = 51;
  v4 = -1;
  v5 = &v4;
  mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((_QWORD *)(a1 + 976), v2, (uint64_t)"max-num-rewrites", 16, &v6, &v5);
  *(_QWORD *)(a1 + 976) = off_24C050B50;
  *(_QWORD *)(a1 + 1176) = &unk_24C050BD0;
  v6.n128_u64[0] = (unint64_t)"Test only: Fail pass on non-convergence to detect cyclic pattern";
  v6.n128_u64[1] = 64;
  LOBYTE(v4) = 0;
  v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 1192), v2, (uint64_t)"test-convergence", 16, &v6, (_BYTE **)&v5);
  *(_QWORD *)(a1 + 1192) = &off_24C0509D0;
  *(_QWORD *)(a1 + 1384) = &unk_24C050A50;
  v6.n128_u64[0] = (unint64_t)"Labels of patterns that should be filtered out during application";
  v6.n128_u64[1] = 65;
  mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::ListOption<llvm::cl::desc>(a1 + 1400, v2, (uint64_t)"disable-patterns", 16, &v6);
  *(_QWORD *)(a1 + 1400) = &unk_24C050790;
  *(_QWORD *)(a1 + 1648) = &unk_24C050810;
  v6.n128_u64[0] = (unint64_t)"Labels of patterns that should be used during application, all other patterns are filtered out";
  v6.n128_u64[1] = 94;
  mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::ListOption<llvm::cl::desc>(a1 + 1672, v2, (uint64_t)"enable-patterns", 15, &v6);
  *(_QWORD *)(a1 + 1672) = &unk_24C050790;
  *(_QWORD *)(a1 + 1920) = &unk_24C050810;
  return a1;
}

void `anonymous namespace'::Canonicalizer::~Canonicalizer(_anonymous_namespace_::Canonicalizer *this)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  _anonymous_namespace_::Canonicalizer *v5;
  uint64_t v6;
  void *v7;
  char *v8;
  _anonymous_namespace_::Canonicalizer *v9;
  uint64_t v10;
  void *v11;
  char *v12;
  _anonymous_namespace_::Canonicalizer *v13;
  uint64_t v14;
  void *v15;
  char *v16;
  _anonymous_namespace_::Canonicalizer *v17;
  uint64_t v18;
  void *v19;
  char *v20;
  _anonymous_namespace_::Canonicalizer *v21;
  uint64_t v22;
  void *v23;
  char *v24;

  *(_QWORD *)this = &off_24C028710;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 250);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  *(_QWORD *)this = off_24C051910;
  llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::~list((_QWORD *)this + 209);
  llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::~list((_QWORD *)this + 175);
  *((_QWORD *)this + 149) = &unk_24C02DF38;
  v5 = (_anonymous_namespace_::Canonicalizer *)*((_QWORD *)this + 172);
  if (v5 == (_anonymous_namespace_::Canonicalizer *)((char *)this + 1352))
  {
    v6 = 4;
    v5 = (_anonymous_namespace_::Canonicalizer *)((char *)this + 1352);
  }
  else
  {
    if (!v5)
      goto LABEL_11;
    v6 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v5 + 8 * v6))();
LABEL_11:
  *((_QWORD *)this + 149) = &unk_24C02E140;
  v7 = (void *)*((_QWORD *)this + 161);
  if (v7 != *((void **)this + 160))
    free(v7);
  v8 = (char *)*((_QWORD *)this + 157);
  if (v8 != (char *)this + 1272)
    free(v8);
  *((_QWORD *)this + 122) = off_24C02E070;
  v9 = (_anonymous_namespace_::Canonicalizer *)*((_QWORD *)this + 146);
  if (v9 == (_anonymous_namespace_::Canonicalizer *)((char *)this + 1144))
  {
    v10 = 4;
    v9 = (_anonymous_namespace_::Canonicalizer *)((char *)this + 1144);
  }
  else
  {
    if (!v9)
      goto LABEL_20;
    v10 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v9 + 8 * v10))();
LABEL_20:
  *((_QWORD *)this + 122) = &unk_24C02E140;
  v11 = (void *)*((_QWORD *)this + 134);
  if (v11 != *((void **)this + 133))
    free(v11);
  v12 = (char *)*((_QWORD *)this + 130);
  if (v12 != (char *)this + 1056)
    free(v12);
  *((_QWORD *)this + 95) = off_24C02E070;
  v13 = (_anonymous_namespace_::Canonicalizer *)*((_QWORD *)this + 119);
  if (v13 == (_anonymous_namespace_::Canonicalizer *)((char *)this + 928))
  {
    v14 = 4;
    v13 = (_anonymous_namespace_::Canonicalizer *)((char *)this + 928);
  }
  else
  {
    if (!v13)
      goto LABEL_29;
    v14 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v13 + 8 * v14))();
LABEL_29:
  *((_QWORD *)this + 95) = &unk_24C02E140;
  v15 = (void *)*((_QWORD *)this + 107);
  if (v15 != *((void **)this + 106))
    free(v15);
  v16 = (char *)*((_QWORD *)this + 103);
  if (v16 != (char *)this + 840)
    free(v16);
  *((_QWORD *)this + 69) = &unk_24C02DF38;
  v17 = (_anonymous_namespace_::Canonicalizer *)*((_QWORD *)this + 92);
  if (v17 == (_anonymous_namespace_::Canonicalizer *)((char *)this + 712))
  {
    v18 = 4;
    v17 = (_anonymous_namespace_::Canonicalizer *)((char *)this + 712);
  }
  else
  {
    if (!v17)
      goto LABEL_38;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_38:
  *((_QWORD *)this + 69) = &unk_24C02E140;
  v19 = (void *)*((_QWORD *)this + 81);
  if (v19 != *((void **)this + 80))
    free(v19);
  v20 = (char *)*((_QWORD *)this + 77);
  if (v20 != (char *)this + 632)
    free(v20);
  *((_QWORD *)this + 43) = &unk_24C02DF38;
  v21 = (_anonymous_namespace_::Canonicalizer *)*((_QWORD *)this + 66);
  if (v21 == (_anonymous_namespace_::Canonicalizer *)((char *)this + 504))
  {
    v22 = 4;
    v21 = (_anonymous_namespace_::Canonicalizer *)((char *)this + 504);
  }
  else
  {
    if (!v21)
      goto LABEL_47;
    v22 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v21 + 8 * v22))();
LABEL_47:
  *((_QWORD *)this + 43) = &unk_24C02E140;
  v23 = (void *)*((_QWORD *)this + 55);
  if (v23 != *((void **)this + 54))
    free(v23);
  v24 = (char *)*((_QWORD *)this + 51);
  if (v24 != (char *)this + 424)
    free(v24);
  mlir::Pass::~Pass(this);
}

{
  JUMPOUT(0x20BD002F8);
}

const char *mlir::impl::CanonicalizerBase<`anonymous namespace'::Canonicalizer>::getName()
{
  return "Canonicalizer";
}

const char *mlir::impl::CanonicalizerBase<`anonymous namespace'::Canonicalizer>::getArgument()
{
  return "canonicalize";
}

const char *mlir::impl::CanonicalizerBase<`anonymous namespace'::Canonicalizer>::getDescription()
{
  return "Canonicalize operations";
}

__n128 `anonymous namespace'::Canonicalizer::runOnOperation(_anonymous_namespace_::Canonicalizer *this)
{
  unint64_t v1;
  const mlir::FrozenRewritePatternSet *v2;
  __n128 result;
  unint64_t v4;
  mlir::Region **v5;
  __int128 v6;
  __int128 v7;
  __int128 v8[3];
  BOOL v9;

  v1 = *((_QWORD *)this + 5) & 0xFFFFFFFFFFFFFFF8;
  v2 = (const mlir::FrozenRewritePatternSet *)*((_QWORD *)this + 249);
  v6 = *(_OWORD *)((char *)this + 1944);
  v7 = *(_OWORD *)((char *)this + 1960);
  result = *(__n128 *)((char *)this + 1976);
  v4 = *(unsigned int *)(v1 + 44);
  if ((v4 & 0x7FFFFF) != 0)
  {
    v5 = (mlir::Region **)(((v1 + 16 * ((v4 >> 23) & 1) + ((v4 >> 21) & 0x7F8) + 64) & 0xFFFFFFFFFFFFFFF8)
                         + 32 * *(unsigned int *)(v1 + 40));
    v9 = 0;
    v8[0] = v6;
    v8[1] = v7;
    v8[2] = (__int128)result;
    mlir::applyPatternsAndFoldGreedily(v5, v2, v8, &v9);
  }
  return result;
}

void `anonymous namespace'::Canonicalizer::initialize(_anonymous_namespace_::Canonicalizer *this, mlir::MLIRContext *a2)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t RegisteredOperations;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  mlir::MLIRContext *v18;
  void *__p[2];
  __int128 v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD v23[8];
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  *((_BYTE *)this + 1944) = *((_BYTE *)this + 472);
  *((_BYTE *)this + 1945) = *((_BYTE *)this + 680);
  *((_QWORD *)this + 244) = *((_QWORD *)this + 111);
  *((_QWORD *)this + 245) = *((_QWORD *)this + 138);
  v18 = a2;
  *(_OWORD *)__p = 0u;
  v20 = 0u;
  v21 = v23;
  v22 = 0x600000000;
  v23[6] = 0;
  v23[7] = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0x2800000000;
  v28 = 0;
  v29 = 0;
  v30 = 0x2800000000;
  mlir::MLIRContext::getLoadedDialects(a2, (uint64_t)&v16);
  v4 = v16;
  v5 = v17;
  if (v16 != v17)
  {
    do
    {
      v6 = *v4++;
      (*(void (**)(uint64_t, mlir::MLIRContext **))(*(_QWORD *)v6 + 16))(v6, &v18);
    }
    while (v4 != v5);
    v4 = v16;
  }
  if (v4)
  {
    v17 = v4;
    operator delete(v4);
  }
  RegisteredOperations = mlir::MLIRContext::getRegisteredOperations(a2);
  if (v8)
  {
    v9 = (uint64_t *)RegisteredOperations;
    v10 = 8 * v8;
    do
    {
      v11 = *v9++;
      (*(void (**)(uint64_t, mlir::MLIRContext **, mlir::MLIRContext *))(*(_QWORD *)v11 + 24))(v11, &v18, a2);
      v10 -= 8;
    }
    while (v10);
  }
  v12 = operator new(0x28uLL);
  v12[2] = 0;
  *v12 = &unk_24C05C7C8;
  v12[1] = 0;
  *((_QWORD *)this + 249) = mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(v12 + 3, &v18, *((_QWORD *)this + 191), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 192) - *((_QWORD *)this + 191)) >> 3), *((_QWORD *)this + 225), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 226) - *((_QWORD *)this + 225)) >> 3));
  v13 = (std::__shared_weak_count *)*((_QWORD *)this + 250);
  *((_QWORD *)this + 250) = v12;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  mlir::PDLPatternModule::~PDLPatternModule((mlir::PDLPatternModule *)((char *)&v20 + 8));
}

uint64_t mlir::impl::CanonicalizerBase<`anonymous namespace'::Canonicalizer>::clonePass@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  __int128 v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  int v11;
  int *v12;
  __n128 v13;

  v4 = operator new();
  v5 = *(_QWORD *)(a1 + 8);
  *(_OWORD *)(v4 + 16) = *(_OWORD *)(a1 + 16);
  *(_QWORD *)(v4 + 32) = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v4 + 40) = 0;
  *(_BYTE *)(v4 + 120) = 0;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_OWORD *)(v4 + 160) = 0u;
  *(_QWORD *)(v4 + 176) = 0;
  *(_QWORD *)(v4 + 184) = v4 + 200;
  *(_QWORD *)(v4 + 192) = 0x400000000;
  *(_QWORD *)(v4 + 232) = v4 + 248;
  *(_QWORD *)(v4 + 240) = 0x400000000;
  *(_QWORD *)(v4 + 280) = 0;
  *(_QWORD *)(v4 + 288) = 0;
  *(_DWORD *)(v4 + 296) = 0;
  *(_DWORD *)(v4 + 300) = 16;
  *(_OWORD *)(v4 + 304) = 0u;
  *(_OWORD *)(v4 + 320) = 0u;
  *(_QWORD *)(v4 + 336) = 0;
  *(_QWORD *)v4 = off_24C051910;
  *(_QWORD *)(v4 + 8) = v5;
  v13.n128_u64[0] = (unint64_t)"Seed the worklist in general top-down order";
  v13.n128_u64[1] = 43;
  LOBYTE(v11) = 1;
  v12 = &v11;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(v4 + 344), (_QWORD *)(v4 + 152), (uint64_t)"top-down", 8, &v13, (_BYTE **)&v12);
  *(_QWORD *)(v4 + 344) = &off_24C0509D0;
  *(_QWORD *)(v4 + 536) = &unk_24C050A50;
  v13.n128_u64[0] = (unint64_t)"Perform control flow optimizations to the region tree";
  v13.n128_u64[1] = 53;
  LOBYTE(v11) = 1;
  v12 = &v11;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(v4 + 552), (_QWORD *)(v4 + 152), (uint64_t)"region-simplify", 15, &v13, (_BYTE **)&v12);
  *(_QWORD *)(v4 + 552) = &off_24C0509D0;
  *(_QWORD *)(v4 + 744) = &unk_24C050A50;
  v13.n128_u64[0] = (unint64_t)"Max. iterations between applying patterns / simplifying regions";
  v13.n128_u64[1] = 63;
  v11 = 10;
  v12 = &v11;
  mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((_QWORD *)(v4 + 760), (_QWORD *)(v4 + 152), (uint64_t)"max-iterations", 14, &v13, &v12);
  *(_QWORD *)(v4 + 760) = off_24C050B50;
  *(_QWORD *)(v4 + 960) = &unk_24C050BD0;
  v13.n128_u64[0] = (unint64_t)"Max. number of pattern rewrites within an iteration";
  v13.n128_u64[1] = 51;
  v11 = -1;
  v12 = &v11;
  mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((_QWORD *)(v4 + 976), (_QWORD *)(v4 + 152), (uint64_t)"max-num-rewrites", 16, &v13, &v12);
  *(_QWORD *)(v4 + 976) = off_24C050B50;
  *(_QWORD *)(v4 + 1176) = &unk_24C050BD0;
  v13.n128_u64[0] = (unint64_t)"Test only: Fail pass on non-convergence to detect cyclic pattern";
  v13.n128_u64[1] = 64;
  LOBYTE(v11) = 0;
  v12 = &v11;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(v4 + 1192), (_QWORD *)(v4 + 152), (uint64_t)"test-convergence", 16, &v13, (_BYTE **)&v12);
  *(_QWORD *)(v4 + 1192) = &off_24C0509D0;
  *(_QWORD *)(v4 + 1384) = &unk_24C050A50;
  v13.n128_u64[0] = (unint64_t)"Labels of patterns that should be filtered out during application";
  v13.n128_u64[1] = 65;
  mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::ListOption<llvm::cl::desc>(v4 + 1400, (_QWORD *)(v4 + 152), (uint64_t)"disable-patterns", 16, &v13);
  *(_QWORD *)(v4 + 1400) = &unk_24C050790;
  *(_QWORD *)(v4 + 1648) = &unk_24C050810;
  v13.n128_u64[0] = (unint64_t)"Labels of patterns that should be used during application, all other patterns are filtered out";
  v13.n128_u64[1] = 94;
  result = mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::ListOption<llvm::cl::desc>(v4 + 1672, (_QWORD *)(v4 + 152), (uint64_t)"enable-patterns", 15, &v13);
  *(_QWORD *)(v4 + 1672) = &unk_24C050790;
  *(_QWORD *)(v4 + 1920) = &unk_24C050810;
  *(_QWORD *)v4 = &off_24C028710;
  v7 = *(_OWORD *)(a1 + 1960);
  *(_OWORD *)(v4 + 1944) = *(_OWORD *)(a1 + 1944);
  *(_OWORD *)(v4 + 1960) = v7;
  *(_OWORD *)(v4 + 1976) = *(_OWORD *)(a1 + 1976);
  *(_QWORD *)(v4 + 1992) = *(_QWORD *)(a1 + 1992);
  v8 = *(_QWORD *)(a1 + 2000);
  *(_QWORD *)(v4 + 2000) = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  *a2 = v4;
  return result;
}

uint64_t mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::ListOption<llvm::cl::desc>(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, _OWORD *a5)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t *v19;
  char *v20;
  char *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t *v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  const void *v31;
  _QWORD v32[2];

  v32[0] = a3;
  v32[1] = a4;
  v31 = a2;
  v7 = llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::list<llvm::StringRef,llvm::cl::sub,llvm::cl::desc>(a1, (uint64_t)v32, &v31, a5);
  *(_QWORD *)(v7 + 248) = &unk_24C051C20;
  v8 = v7 + 248;
  *(_BYTE *)(v7 + 256) = 0;
  *(_QWORD *)v7 = &unk_24C051BA0;
  *(_QWORD *)(v7 + 264) = &unk_24C02E1F8;
  v10 = (uint64_t *)a2[21];
  v9 = a2[22];
  v11 = v10;
  if ((unint64_t)v10 < v9)
  {
    *v10 = v8;
    v12 = (uint64_t)(v10 + 1);
    goto LABEL_23;
  }
  v13 = (char *)a2[20];
  v14 = ((char *)v10 - v13) >> 3;
  v15 = v14 + 1;
  if ((unint64_t)(v14 + 1) >> 61)
    abort();
  v16 = v9 - (_QWORD)v13;
  if (v16 >> 2 > v15)
    v15 = v16 >> 2;
  if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
    v17 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v17 = v15;
  if (v17)
  {
    if (v17 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v18 = (char *)operator new(8 * v17);
    v19 = (uint64_t *)&v18[8 * v14];
    v20 = &v18[8 * v17];
    *v19 = v8;
    v12 = (uint64_t)(v19 + 1);
    v21 = (char *)((char *)v10 - v13);
    if (v10 == (uint64_t *)v13)
      goto LABEL_21;
    goto LABEL_14;
  }
  v18 = 0;
  v19 = (uint64_t *)(8 * v14);
  v20 = 0;
  *(_QWORD *)(8 * v14) = v8;
  v12 = 8 * v14 + 8;
  v21 = (char *)((char *)v10 - v13);
  if (v10 != (uint64_t *)v13)
  {
LABEL_14:
    v22 = (unint64_t)(v21 - 8);
    if (v22 < 0x58)
      goto LABEL_28;
    if ((unint64_t)(v13 - v18) < 0x20)
      goto LABEL_28;
    v23 = (v22 >> 3) + 1;
    v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
    v11 = &v10[v24 / 0xFFFFFFFFFFFFFFF8];
    v19 = (uint64_t *)((char *)v19 - v24);
    v25 = &v18[8 * v14 - 16];
    v26 = v10 - 2;
    v27 = v23 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v28 = *(_OWORD *)v26;
      *((_OWORD *)v25 - 1) = *((_OWORD *)v26 - 1);
      *(_OWORD *)v25 = v28;
      v25 -= 32;
      v26 -= 4;
      v27 -= 4;
    }
    while (v27);
    if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_28:
      do
      {
        v29 = *--v11;
        *--v19 = v29;
      }
      while (v11 != (uint64_t *)v13);
    }
    v11 = (uint64_t *)a2[20];
  }
LABEL_21:
  a2[20] = v19;
  a2[21] = v12;
  a2[22] = v20;
  if (v11)
    operator delete(v11);
LABEL_23:
  a2[21] = v12;
  return a1;
}

uint64_t llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::list<llvm::StringRef,llvm::cl::sub,llvm::cl::desc>(uint64_t a1, uint64_t a2, const void **a3, _OWORD *a4)
{
  __int16 v8;
  void *v9;
  uint64_t v10;
  llvm::SmallPtrSetImplBase *v11;
  _QWORD *GeneralCategory;
  uint64_t v13;
  const void *v14;
  uint64_t v15;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;

  *(_QWORD *)a1 = &unk_24C02E140;
  *(_WORD *)(a1 + 8) = 0;
  v8 = *(_WORD *)(a1 + 10);
  v9 = (void *)(a1 + 80);
  *(_QWORD *)(a1 + 64) = a1 + 80;
  v10 = a1 + 64;
  *(_WORD *)(a1 + 10) = v8 & 0x8000 | 1;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(_QWORD *)(a1 + 88) = a1 + 120;
  v11 = (llvm::SmallPtrSetImplBase *)(a1 + 88);
  *(_QWORD *)(a1 + 72) = 0x100000000;
  *(_QWORD *)(a1 + 96) = a1 + 120;
  *(_QWORD *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  v13 = *(unsigned int *)(a1 + 72);
  if (v13 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v10, v9, v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a1 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v13) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_BYTE *)(a1 + 176) = 0;
  *(_QWORD *)a1 = &off_24C02E0D8;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = &unk_24C02E1F8;
  *(_QWORD *)(a1 + 216) = &off_24C0536F0;
  *(_QWORD *)(a1 + 240) = a1 + 216;
  llvm::cl::Option::setArgStr(a1, *(int8x16_t **)a2, *(const unsigned __int8 **)(a2 + 8));
  v14 = *a3;
  v15 = *(_QWORD *)(a1 + 96);
  if (v15 != *(_QWORD *)(a1 + 88))
  {
LABEL_4:
    llvm::SmallPtrSetImplBase::insert_imp_big(v11, v14);
    goto LABEL_5;
  }
  v17 = *(unsigned int *)(a1 + 108);
  if (!(_DWORD)v17)
  {
LABEL_14:
    if (v17 < *(_DWORD *)(a1 + 104))
    {
      *(_DWORD *)(a1 + 108) = v17 + 1;
      *(_QWORD *)(v15 + 8 * v17) = v14;
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  v18 = 0;
  v19 = 8 * v17;
  v20 = *(_QWORD **)(a1 + 96);
  while ((const void *)*v20 != v14)
  {
    if (*v20 == -2)
      v18 = v20;
    ++v20;
    v19 -= 8;
    if (!v19)
    {
      if (!v18)
        goto LABEL_14;
      *v18 = v14;
      --*(_DWORD *)(a1 + 112);
      break;
    }
  }
LABEL_5:
  *(_OWORD *)(a1 + 32) = *a4;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void std::__shared_ptr_emplace<mlir::FrozenRewritePatternSet>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C05C7C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<mlir::FrozenRewritePatternSet>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C05C7C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

void std::__shared_ptr_emplace<mlir::FrozenRewritePatternSet>::__on_zero_shared(uint64_t a1)
{
  mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)(a1 + 24));
}

void `anonymous namespace'::CSEDriver::simplify(_anonymous_namespace_::CSEDriver *this, mlir::Operation *a2, BOOL *a3)
{
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  _QWORD v11[5];
  _QWORD v12[6];
  _QWORD v13[2];
  llvm *v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  memset(v11, 0, 24);
  v11[3] = v12;
  v11[4] = 0x400000000;
  v12[4] = v13;
  v12[5] = 0;
  v13[0] = 0;
  v13[1] = 1;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v5 = *((unsigned int *)a2 + 11);
  if ((v5 & 0x7FFFFF) != 0)
  {
    v6 = (_QWORD *)((((unint64_t)a2 + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)a2 + 10));
    v7 = 24 * (v5 & 0x7FFFFF);
    do
    {
      v6 += 3;
      v7 -= 24;
    }
    while (v7);
  }
  v8 = (uint64_t *)*((_QWORD *)this + 1);
  v9 = (uint64_t *)*((_QWORD *)this + 2);
  while (v8 != v9)
  {
    v10 = *v8++;
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)this + 40))(*(_QWORD *)this, v10);
  }
  if (a3)
    *a3 = *((_QWORD *)this + 1) != *((_QWORD *)this + 2);
  llvm::deallocate_buffer(v14, (void *)(16 * v16));
}

void sub_20754DF28(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, int a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, int a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36)
{
  llvm **v36;
  uint64_t v37;
  llvm **v38;
  int v39;
  uint64_t v40;
  int v41;

  if (v39)
    llvm::deallocate_buffer(*v38, (void *)0x1000);
  if (v41)
    llvm::deallocate_buffer(*(llvm **)v40, *(void **)(v40 + 8));
  if (v40 != v37)
    free((void *)v40);
  if (v38 != v36)
    free(v38);
}

uint64_t mlir::createCSEPass@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v3;
  uint64_t result;

  v3 = operator new();
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_OWORD *)(v3 + 96) = 0u;
  *(_OWORD *)(v3 + 112) = 0u;
  *(_OWORD *)(v3 + 128) = 0u;
  *(_OWORD *)(v3 + 192) = 0u;
  *(_OWORD *)(v3 + 208) = 0u;
  *(_OWORD *)(v3 + 224) = 0u;
  *(_OWORD *)(v3 + 240) = 0u;
  *(_OWORD *)(v3 + 256) = 0u;
  *(_OWORD *)(v3 + 272) = 0u;
  *(_OWORD *)(v3 + 288) = 0u;
  *(_OWORD *)(v3 + 304) = 0u;
  *(_BYTE *)(v3 + 120) = 0;
  *(_OWORD *)(v3 + 128) = 0u;
  *(_OWORD *)(v3 + 144) = 0u;
  *(_OWORD *)(v3 + 144) = 0u;
  *(_OWORD *)(v3 + 160) = 0u;
  *(_OWORD *)(v3 + 160) = 0u;
  *(_OWORD *)(v3 + 176) = 0u;
  *(_QWORD *)(v3 + 176) = 0;
  *(_QWORD *)(v3 + 184) = v3 + 200;
  *(_DWORD *)(v3 + 196) = 4;
  *(_QWORD *)(v3 + 232) = v3 + 248;
  *(_DWORD *)(v3 + 244) = 4;
  *(_QWORD *)(v3 + 280) = 0;
  *(_QWORD *)(v3 + 288) = 0;
  *(_QWORD *)(v3 + 296) = 0x1000000000;
  *(_OWORD *)(v3 + 304) = 0u;
  *(_OWORD *)(v3 + 320) = 0u;
  *(_OWORD *)(v3 + 320) = 0u;
  *(_OWORD *)(v3 + 336) = 0u;
  *(_QWORD *)(v3 + 336) = 0;
  *(_QWORD *)v3 = off_24C051980;
  mlir::Pass::Statistic::Statistic((mlir::Pass::Statistic *)(v3 + 344), (mlir::Pass *)v3, "num-cse'd", "Number of operations CSE'd");
  result = mlir::Pass::Statistic::Statistic((mlir::Pass::Statistic *)(v3 + 345), (mlir::Pass *)v3, "num-dce'd", "Number of operations DCE'd");
  *(_QWORD *)v3 = &off_24C02B1C0;
  *a1 = v3;
  return result;
}

void `anonymous namespace'::CSEDriver::simplifyRegion(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t DominanceInfo;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int32x2_t **v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int32x2_t **v23;
  uint64_t v24;
  int32x2_t **v25;
  int32x2_t **v26;
  uint64_t v27;
  uint64_t v28;
  void **v29;
  void **v30;
  unint64_t v31;
  void *v32;
  void *v33;
  void *v34;
  int32x2_t **v35;
  void *__p[2];
  __int128 v37;
  __int128 v38;

  if ((_QWORD *)*a3 != a3)
  {
    DominanceInfo = mlir::detail::DominanceInfoBase<false>::getDominanceInfo(*(_QWORD *)(a1 + 32), a3, 0);
    if ((_QWORD *)*a3 != a3 && (v7 = a3[1], *(_QWORD **)(v7 + 8) == a3))
    {
      v34 = (void *)a2[16];
      __p[0] = a2;
      __p[1] = v34;
      a2[16] = __p;
      *(_QWORD *)&v37 = 0;
    }
    else if ((DominanceInfo & 4) != 0)
    {
      v37 = 0u;
      v38 = 0u;
      *(_OWORD *)__p = 0u;
      v8 = *(_QWORD *)((mlir::detail::DominanceInfoBase<false>::getDominanceInfo(*(_QWORD *)(a1 + 32), a3, 1) & 0xFFFFFFFFFFFFFFF8)
                     + 48);
      v9 = operator new();
      v10 = a2[16];
      *(_QWORD *)v9 = a2;
      *(_QWORD *)(v9 + 8) = v10;
      a2[16] = v9;
      *(_QWORD *)(v9 + 16) = 0;
      *(_QWORD *)(v9 + 24) = v8;
      *(_QWORD *)(v9 + 32) = *(_QWORD *)(v8 + 24);
      *(_BYTE *)(v9 + 40) = 0;
      v35 = (int32x2_t **)v9;
      if (v35)
      {
        MEMORY[0x20BD002F8](v11, 0x10E0C4097FA51B3);
      }
      v12 = *((_QWORD *)&v38 + 1);
      while (v12)
      {
        --v12;
        v13 = __p[1];
        v14 = v38 + v12;
        v15 = (unint64_t)(v38 + v12) >> 9;
        v16 = *((_QWORD *)__p[1] + v15);
        v17 = (v38 + v12) & 0x1FF;
        v18 = *(_QWORD *)(v16 + 8 * v17);
        if (*(_BYTE *)(v18 + 40))
        {
          v19 = *(uint64_t **)(v18 + 32);
          if (v19 == (uint64_t *)(*(_QWORD *)(*(_QWORD *)(v18 + 24) + 24)
                                + 8 * *(unsigned int *)(*(_QWORD *)(v18 + 24) + 32)))
            goto LABEL_16;
        }
        else
        {
          *(_BYTE *)(v18 + 40) = 1;
          v18 = *(_QWORD *)(v16 + 8 * v17);
          v19 = *(uint64_t **)(v18 + 32);
          if (v19 == (uint64_t *)(*(_QWORD *)(*(_QWORD *)(v18 + 24) + 24)
                                + 8 * *(unsigned int *)(*(_QWORD *)(v18 + 24) + 32)))
          {
LABEL_16:
            v24 = v13[v15];
            v25 = *(int32x2_t ***)(v24 + 8 * v17);
            *(_QWORD *)(v24 + 8 * v17) = 0;
            if (v25)
            {
              MEMORY[0x20BD002F8](v26, 0x10E0C4097FA51B3);
            }
            v27 = v37;
            v28 = (((_QWORD)v37 - (_QWORD)v13) << 6) - 1;
            *((_QWORD *)&v38 + 1) = v12;
            if ((_QWORD *)v37 == v13)
              v28 = 0;
            if ((unint64_t)(v28 - v14) >= 0x400)
            {
              operator delete(*(void **)(v37 - 8));
              *(_QWORD *)&v37 = v27 - 8;
            }
            continue;
          }
        }
        *(_QWORD *)(v18 + 32) = v19 + 1;
        v20 = *v19;
        v21 = operator new();
        v22 = a2[16];
        *(_QWORD *)v21 = a2;
        *(_QWORD *)(v21 + 8) = v22;
        a2[16] = v21;
        *(_QWORD *)(v21 + 16) = 0;
        *(_QWORD *)(v21 + 24) = v20;
        *(_QWORD *)(v21 + 32) = *(_QWORD *)(v20 + 24);
        *(_BYTE *)(v21 + 40) = 0;
        v35 = (int32x2_t **)v21;
        if (v35)
        {
          MEMORY[0x20BD002F8](v23, 0x10E0C4097FA51B3);
        }
        v12 = *((_QWORD *)&v38 + 1);
      }
      v29 = (void **)__p[1];
      v30 = (void **)v37;
      v31 = v37 - (unint64_t)__p[1];
      if ((unint64_t)v37 - (unint64_t)__p[1] >= 0x11)
      {
        do
        {
          v32 = *v29++;
          operator delete(v32);
          v31 -= 8;
        }
        while (v31 > 0x10);
      }
      while (v29 != v30)
      {
        v33 = *v29++;
        operator delete(v33);
      }
      if (__p[0])
        operator delete(__p[0]);
    }
  }
}

void `anonymous namespace'::CSEDriver::simplifyBlock(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  ZinIrHalH13g *v5;
  ZinIrHalH13g *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  llvm *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  mlir::Operation *v19;
  mlir::Operation *v20;
  unint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t InterfaceFor;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  char *v35;
  uint64_t *v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  char *v41;
  uint64_t *v42;
  uint64_t v43;
  __int128 v44;
  uint64_t v45;
  _BOOL4 v46;
  void *v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD *v55;
  ZinIrHalH13g *v56;
  mlir *v57;
  mlir *v58;
  int v59;
  uint64_t v60;
  int v61;
  unsigned int v62;
  uint64_t *v63;
  void *v64;
  BOOL v65;
  uint64_t *v66;
  BOOL v67;
  mlir *v68;
  _QWORD *v69;
  uint64_t **v70;
  uint64_t v71;
  uint64_t v72;
  unsigned __int8 v73;
  int v74;
  unint64_t v75;
  unint64_t v76;
  const char *v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  ZinIrHalH13g *v82;
  mlir *v83;
  uint64_t *v84;
  uint64_t *v85;
  int v86;
  BOOL v87;
  unsigned int v88;
  uint64_t *v89;
  int v90;
  _QWORD *v91;
  unsigned int v92;
  _QWORD *v93;
  unint64_t v94;
  _QWORD *v95;
  unint64_t v96;
  uint64_t v97;
  _QWORD *v98;
  _QWORD *v99;
  uint64_t *v100;
  uint64_t v101;
  uint64_t v102;
  ZinIrHalH13g *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  const char *v109;
  unint64_t v110;
  void *v111;
  uint64_t v112;
  _QWORD v113[3];
  uint64_t v114;
  char v115;
  void *v116;
  uint64_t v117;
  _QWORD v118[2];
  llvm *v119;
  uint64_t v120;
  unsigned int v121;
  uint64_t v122;
  uint64_t v123;

  v123 = *MEMORY[0x24BDAC8D0];
  v5 = (ZinIrHalH13g *)(a3 + 32);
  v6 = *(ZinIrHalH13g **)(a3 + 40);
  if (v6 != (ZinIrHalH13g *)(a3 + 32))
  {
    v101 = a1 + 40;
    v102 = a2 + 104;
    v104 = (ZinIrHalH13g *)(a3 + 32);
    while (1)
    {
      ZinIrHalH13g::~ZinIrHalH13g(v6);
      v10 = v9;
      if ((*(_DWORD *)(v9 + 44) & 0x7FFFFF) != 0)
      {
        if (mlir::OperationName::mightHaveTrait<mlir::OpTrait::IsIsolatedFromAbove>((void ***)(v9 + 48)))
        {
          v111 = 0;
          v112 = 0;
          v113[0] = 0;
          v113[1] = &v114;
          v113[2] = 0x400000000;
          v117 = 0;
          v118[0] = 0;
          v116 = v118;
          v118[1] = 1;
          v119 = 0;
          v120 = 0;
          v121 = 0;
          v122 = 0;
          v11 = *(unsigned int *)(v10 + 44);
          if ((v11 & 0x7FFFFF) != 0)
          {
            v12 = ((v10 + 16 * ((v11 >> 23) & 1) + ((v11 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                + 32 * *(unsigned int *)(v10 + 40);
            v13 = 24 * (v11 & 0x7FFFFF);
            do
            {
              v12 += 24;
              v13 -= 24;
            }
            while (v13);
            v14 = v119;
            v15 = v121;
          }
          else
          {
            v15 = 0;
            v14 = 0;
          }
          llvm::deallocate_buffer(v14, (void *)(16 * v15));
        }
        v16 = *(unsigned int *)(v10 + 44);
        if ((v16 & 0x7FFFFF) != 0)
        {
          v17 = ((v10 + 16 * ((v16 >> 23) & 1) + ((v16 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
              + 32 * *(unsigned int *)(v10 + 40);
          v18 = 24 * (v16 & 0x7FFFFF);
          do
          {
            v17 += 24;
            v18 -= 24;
          }
          while (v18);
        }
      }
      v107 = v10;
      if ((mlir::OperationName::hasTrait<mlir::OpTrait::IsTerminator>((_QWORD *)(v10 + 48)) & 1) != 0)
        goto LABEL_5;
      if (mlir::isOpTriviallyDead((void ***)v10, v19))
      {
        v22 = *(uint64_t **)(a1 + 16);
        v21 = *(_QWORD *)(a1 + 24);
        if ((unint64_t)v22 < v21)
        {
          *v22 = v10;
          v23 = (uint64_t)(v22 + 1);
LABEL_53:
          *(_QWORD *)(a1 + 16) = v23;
          ++*(_QWORD *)(a1 + 72);
          goto LABEL_5;
        }
        v30 = *(char **)(a1 + 8);
        v31 = ((char *)v22 - v30) >> 3;
        v32 = v31 + 1;
        if ((unint64_t)(v31 + 1) >> 61)
          abort();
        v33 = v21 - (_QWORD)v30;
        if (v33 >> 2 > v32)
          v32 = v33 >> 2;
        if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
          v34 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v34 = v32;
        if (v34)
        {
          if (v34 >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v35 = (char *)operator new(8 * v34);
          v36 = (uint64_t *)&v35[8 * v31];
          *v36 = v10;
          v23 = (uint64_t)(v36 + 1);
          if (v22 == (uint64_t *)v30)
            goto LABEL_51;
LABEL_44:
          v37 = (char *)(v22 - 1) - v30;
          if (v37 < 0x58)
            goto LABEL_144;
          if ((unint64_t)(v30 - v35) < 0x20)
            goto LABEL_144;
          v38 = (v37 >> 3) + 1;
          v39 = 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
          v40 = &v22[v39 / 0xFFFFFFFFFFFFFFF8];
          v36 = (uint64_t *)((char *)v36 - v39);
          v41 = &v35[8 * v31 - 16];
          v42 = v22 - 2;
          v43 = v38 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v44 = *(_OWORD *)v42;
            *((_OWORD *)v41 - 1) = *((_OWORD *)v42 - 1);
            *(_OWORD *)v41 = v44;
            v41 -= 32;
            v42 -= 4;
            v43 -= 4;
          }
          while (v43);
          v22 = v40;
          if (v38 != (v38 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_144:
            do
            {
              v45 = *--v22;
              *--v36 = v45;
            }
            while (v22 != (uint64_t *)v30);
          }
          v22 = *(uint64_t **)(a1 + 8);
        }
        else
        {
          v35 = 0;
          v36 = (uint64_t *)(8 * v31);
          *(_QWORD *)(8 * v31) = v10;
          v23 = 8 * v31 + 8;
          if (v22 != (uint64_t *)v30)
            goto LABEL_44;
        }
LABEL_51:
        *(_QWORD *)(a1 + 8) = v36;
        *(_QWORD *)(a1 + 16) = v23;
        *(_QWORD *)(a1 + 24) = &v35[8 * v34];
        v5 = v104;
        if (v22)
          operator delete(v22);
        goto LABEL_53;
      }
      v24 = *(unsigned int *)(v10 + 44);
      v25 = v24 & 0x7FFFFF;
      if ((v24 & 0x7FFFFF) != 0)
      {
        v26 = (_QWORD *)(((v10 + 16 * ((v24 >> 23) & 1) + ((v24 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                       + 32 * *(unsigned int *)(v10 + 40));
        v27 = 24 * v25;
        do
        {
          if (v26 != (_QWORD *)*v26)
          {
            v28 = v26[1];
            if (v26 == (_QWORD *)v28 || v26 != *(_QWORD **)(v28 + 8))
              goto LABEL_5;
          }
          v26 += 3;
          v27 -= 24;
        }
        while (v27);
      }
      if ((mlir::isMemoryEffectFree((mlir *)v10, v20) & 1) != 0)
      {
        if (!v8)
          goto LABEL_63;
        ++*(_QWORD *)(a1 + 64);
        goto LABEL_5;
      }
      if (!mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor(v10))
      {
        v105 = 0;
        v106 = 0;
        goto LABEL_5;
      }
      if (!v10)
      {
        v105 = 0;
        v106 = 0;
        goto LABEL_5;
      }
      InterfaceFor = mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor(v10);
      v105 = v10;
      v106 = InterfaceFor;
      v111 = v113;
      v112 = 0x400000000;
      mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v105, (uint64_t)&v111);
      if ((_DWORD)v112)
        break;
      v46 = 0;
      v47 = v111;
      if (v111 != v113)
        goto LABEL_59;
LABEL_60:
      if (!v46)
        goto LABEL_5;
      if (!v48)
        goto LABEL_63;
      v49 = (void *)v48;
      v50 = *(_QWORD *)(v48 + 16);
      if (v50 != *(_QWORD *)(v10 + 16))
        goto LABEL_63;
      v108 = v48;
      v56 = *(ZinIrHalH13g **)(v48 + 8);
      if (v56 == (ZinIrHalH13g *)(v50 + 32))
      {
        v58 = 0;
        v111 = v49;
        v112 = 0;
        v59 = *(_DWORD *)(a1 + 56);
        if (v59)
        {
LABEL_68:
          v60 = *(_QWORD *)(a1 + 40);
          v61 = v59 - 1;
          v62 = v61 & ((v49 >> 4) ^ (v49 >> 9));
          v63 = (uint64_t *)(v60 + 24 * v62);
          v64 = (void *)*v63;
          if ((void *)*v63 == v49)
          {
LABEL_69:
            v100 = v63;
            if (v58)
              v65 = v58 == (mlir *)v10;
            else
              v65 = 1;
            if (!v65)
              goto LABEL_81;
LABEL_74:
            v100[1] = v10;
            v100[2] = 0;
            goto LABEL_5;
          }
          v85 = 0;
          v86 = 1;
          while (v64 != (void *)-4096)
          {
            if (v85)
              v87 = 0;
            else
              v87 = v64 == (void *)-8192;
            if (v87)
              v85 = v63;
            v88 = v62 + v86++;
            v62 = v88 & v61;
            v63 = (uint64_t *)(v60 + 24 * v62);
            v64 = (void *)*v63;
            if ((void *)*v63 == v49)
              goto LABEL_69;
          }
          if (v85)
            v89 = v85;
          else
            v89 = v63;
          v66 = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,std::pair<mlir::Operation *,mlir::MemoryEffects::Effect *>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::pair<mlir::Operation *,mlir::MemoryEffects::Effect *>>>,mlir::Operation *,std::pair<mlir::Operation *,mlir::MemoryEffects::Effect *>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::pair<mlir::Operation *,mlir::MemoryEffects::Effect *>>>::InsertIntoBucket<mlir::Operation * const&,std::pair<mlir::Operation *,decltype(nullptr)>>(v101, v89, &v108, (uint64_t *)&v111);
          if (v66[2])
            goto LABEL_63;
          goto LABEL_77;
        }
      }
      else
      {
        ZinIrHalH13g::~ZinIrHalH13g(v56);
        v58 = v57;
        v111 = v49;
        v112 = 0;
        v59 = *(_DWORD *)(a1 + 56);
        if (v59)
          goto LABEL_68;
      }
      v66 = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,std::pair<mlir::Operation *,mlir::MemoryEffects::Effect *>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::pair<mlir::Operation *,mlir::MemoryEffects::Effect *>>>,mlir::Operation *,std::pair<mlir::Operation *,mlir::MemoryEffects::Effect *>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::pair<mlir::Operation *,mlir::MemoryEffects::Effect *>>>::InsertIntoBucket<mlir::Operation * const&,std::pair<mlir::Operation *,decltype(nullptr)>>(v101, 0, &v108, (uint64_t *)&v111);
      if (v66[2])
        goto LABEL_63;
LABEL_77:
      v100 = v66;
      v58 = (mlir *)v66[1];
      if (v58)
        v67 = v58 == (mlir *)v10;
      else
        v67 = 1;
      if (v67)
        goto LABEL_74;
LABEL_81:
      while (1)
      {
        v68 = v58;
        mlir::getEffectsRecursively(v58, (uint64_t)&v111);
        v69 = &unk_25451A000;
        if (!v115)
          break;
        if ((_DWORD)v112)
        {
          v70 = (uint64_t **)v111;
          v71 = 40 * v112;
          do
          {
            v72 = **v70;
            if ((v73 & 1) == 0)
            {
              v69 = (_QWORD *)&unk_25451A000;
              if (v74)
              {
                v109 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffects::Write]";
                v110 = 76;
                v75 = llvm::StringRef::find((uint64_t *)&v109, "DesiredTypeName = ", 0x12uLL, 0);
                if (v110 >= v75)
                  v76 = v75;
                else
                  v76 = v110;
                v77 = &v109[v76];
                v78 = v110 - v76;
                v79 = 18;
                if (v78 < 0x12)
                  v79 = v78;
                v80 = v78 - v79;
                if (v80 >= v80 - 1)
                  v81 = v80 - 1;
                else
                  v81 = v80;
                mlir::detail::TypeIDResolver<mlir::MemoryEffects::Write,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v77[v79], v81);
                v69 = (_QWORD *)&unk_25451A000;
              }
            }
            if (v72 == v69[407])
              goto LABEL_107;
            v70 += 5;
            v71 -= 40;
          }
          while (v71);
        }
        v82 = (ZinIrHalH13g *)*((_QWORD *)v68 + 1);
        if (v82 == (ZinIrHalH13g *)(*((_QWORD *)v68 + 2) + 32))
        {
          v58 = 0;
          if (v115)
          {
LABEL_102:
            if (v111 != v113)
              free(v111);
          }
        }
        else
        {
          ZinIrHalH13g::~ZinIrHalH13g(v82);
          v58 = v83;
          if (v115)
            goto LABEL_102;
        }
        if (!v58 || v58 == (mlir *)v10)
          goto LABEL_74;
      }
LABEL_107:
      v84 = mlir::SideEffects::Effect::Base<mlir::MemoryEffects::Write,mlir::MemoryEffects::Effect>::get();
      v100[1] = (uint64_t)v68;
      v100[2] = (uint64_t)v84;
      if (v115 && v111 != v113)
        free(v111);
      v10 = v107;
LABEL_63:
      v51 = *(_QWORD *)(a2 + 128);
      v53 = *(_QWORD *)(v51 + 16);
      v54 = *v52;
      v55 = llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>,llvm::ScopedHashTableVal<mlir::Operation *,mlir::Operation *>,32ul,8ul>::Allocate<llvm::ScopedHashTableVal<mlir::Operation *,mlir::Operation *>>(a2);
      v55[2] = v10;
      v55[3] = v10;
      *v55 = v53;
      v55[1] = v54;
      *v52 = (uint64_t)v55;
      *(_QWORD *)(v51 + 16) = v55;
LABEL_5:
      v6 = (ZinIrHalH13g *)*((_QWORD *)v6 + 1);
      if (v6 == v5)
        goto LABEL_125;
    }
    v46 = llvm::all_of<llvm::SmallVector<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>,4u> &,BOOL mlir::MemoryEffectOpInterface::onlyHasEffect<mlir::MemoryEffects::Read>(void)::{lambda(llvm::SmallVector<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>,4u> & const&)#1}>((uint64_t)&v111);
    v47 = v111;
    if (v111 == v113)
      goto LABEL_60;
LABEL_59:
    free(v47);
    goto LABEL_60;
  }
LABEL_125:
  v90 = *(_DWORD *)(a1 + 48);
  if (v90 || *(_DWORD *)(a1 + 52))
  {
    v91 = (_QWORD *)(a1 + 40);
    v92 = *(_DWORD *)(a1 + 56);
    if (v92 > 4 * v90 && v92 >= 0x41)
    {
      llvm::DenseMap<mlir::Operation *,std::pair<mlir::Operation *,mlir::MemoryEffects::Effect *>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::pair<mlir::Operation *,mlir::MemoryEffects::Effect *>>>::shrink_and_clear((uint64_t)v91);
      return;
    }
    if (!v92)
      goto LABEL_138;
    v93 = (_QWORD *)*v91;
    v94 = 24 * v92 - 24;
    if (v94 >= 0x18)
    {
      v96 = v94 / 0x18 + 1;
      v95 = &v93[3 * (v96 & 0x1FFFFFFFFFFFFFFELL)];
      v97 = v96 & 0x1FFFFFFFFFFFFFFELL;
      v98 = (_QWORD *)*v91;
      do
      {
        *v98 = -4096;
        v98[3] = -4096;
        v98 += 6;
        v97 -= 2;
      }
      while (v97);
      if (v96 == (v96 & 0x1FFFFFFFFFFFFFFELL))
        goto LABEL_138;
    }
    else
    {
      v95 = (_QWORD *)*v91;
    }
    v99 = &v93[3 * v92];
    do
    {
      *v95 = -4096;
      v95 += 3;
    }
    while (v95 != v99);
LABEL_138:
    *(_QWORD *)(a1 + 48) = 0;
  }
}

int32x2_t **llvm::ScopedHashTableScope<mlir::Operation *,mlir::Operation *,`anonymous namespace'::SimpleOperationInfo,llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>,llvm::ScopedHashTableVal<mlir::Operation *,mlir::Operation *>,32ul,8ul>>::~ScopedHashTableScope(int32x2_t **a1)
{
  int32x2_t *v2;
  int32x2_t *v3;
  int32x2_t *v4;
  uint64_t *v5;
  __int32 v6;
  int32x2_t v7;
  __int32 v8;
  unsigned int v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned int v14;

  v2 = *a1;
  (*a1)[16] = (int32x2_t)a1[1];
  v3 = a1[2];
  if (v3)
  {
    do
    {
      v5 = (uint64_t *)&v3[2];
      if (v3[1])
      {
      }
      else
      {
        v6 = v2[15].i32[0];
        if (v6)
        {
          v7 = v2[13];
          v8 = v6 - 1;
          v9 = (v6 - 1) & mlir::OperationEquivalence::computeHash(*v5, (uint64_t (*)(uint64_t, _QWORD))llvm::function_ref<llvm::hash_code ()(mlir::Value)>::callback_fn<llvm::hash_code ()(mlir::Value)>, (uint64_t)mlir::OperationEquivalence::directHashValue, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<llvm::hash_code ()(mlir::Value)>::callback_fn<llvm::hash_code ()(mlir::Value)>, (uint64_t)mlir::OperationEquivalence::ignoreHashValue, 1);
          v10 = (uint64_t *)(*(_QWORD *)&v7 + 16 * v9);
          v11 = *v5;
          v12 = *v10;
          if (*v5 == *v10)
          {
LABEL_16:
            *v10 = -8192;
            v2[14] = vadd_s32(v2[14], (int32x2_t)0x1FFFFFFFFLL);
          }
          else
          {
            v13 = 1;
            while (1)
            {
              if (v12 != -4096 && v12 != -8192 && v11 != -8192 && v11 != -4096)
                mlir::OperationEquivalence::isEquivalentTo(v11, v12, 1);
              if (v12 == -4096)
                break;
              v14 = v9 + v13++;
              v9 = v14 & v8;
              v10 = (uint64_t *)(*(_QWORD *)&v7 + 16 * (v14 & v8));
              v11 = *v5;
              v12 = *v10;
              if (*v5 == *v10)
                goto LABEL_16;
            }
          }
        }
      }
      v4 = (int32x2_t *)*v3;
      a1[2] = (int32x2_t *)*v3;
      v2 = *a1;
      *v3 = **a1;
      *v2 = (int32x2_t)v3;
      v3 = v4;
    }
    while (v4);
  }
  return a1;
}

void std::deque<std::unique_ptr<`anonymous namespace'::CSEDriver::CFGStackNode>>::emplace_back<std::unique_ptr<`anonymous namespace'::CSEDriver::CFGStackNode>>(uint64_t a1, uint64_t *a2)
{
  uint64_t *v2;
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  BOOL v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  int64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  void *v25;
  void *v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  char *v30;
  char *v31;
  void *v32;
  void *v33;
  unint64_t v34;
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  BOOL v44;
  int64_t v45;
  unint64_t v46;
  char *v47;
  char *v48;
  unint64_t v49;
  char *v50;
  char *v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  char *v59;
  int64_t v60;
  unint64_t v61;
  char *v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  __int128 *v66;
  char *v67;
  uint64_t v68;
  __int128 v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  char *v74;
  char *v75;
  char *v76;
  char *v77;
  char *v78;
  unint64_t v79;
  uint64_t v80;
  __int128 *v81;
  _OWORD *v82;
  uint64_t v83;
  __int128 v84;
  uint64_t v85;
  char *v86;
  char *v87;
  uint64_t v88;
  char *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  char *v94;
  int64_t v95;
  char *v96;
  uint64_t v97;
  uint64_t v98;
  __int128 *v99;
  _OWORD *v100;
  uint64_t v101;
  __int128 v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v108;
  unint64_t v109;
  uint64_t v110;
  char *v111;
  char *v112;
  int64_t v113;
  unint64_t v114;
  char *v115;
  char *v116;
  uint64_t v117;
  uint64_t v118;
  char *v119;
  __int128 *v120;
  _OWORD *v121;
  uint64_t v122;
  __int128 v123;
  uint64_t v124;

  v2 = a2;
  v4 = *(char **)(a1 + 16);
  v5 = *(char **)(a1 + 8);
  v6 = v4 - v5;
  if (v4 == v5)
    v7 = 0;
  else
    v7 = ((v4 - v5) << 6) - 1;
  v8 = *(_QWORD *)(a1 + 32);
  if (v7 != *(_QWORD *)(a1 + 40) + v8)
    goto LABEL_96;
  v9 = v8 >= 0x200;
  v10 = v8 - 512;
  if (v9)
  {
    *(_QWORD *)(a1 + 32) = v10;
    v11 = v5 + 8;
    v12 = *(_QWORD *)v5;
    *(_QWORD *)(a1 + 8) = v5 + 8;
    if (v4 != *(char **)(a1 + 24))
    {
LABEL_94:
      *(_QWORD *)v4 = v12;
      goto LABEL_95;
    }
    v13 = *(char **)a1;
    if ((unint64_t)v11 > *(_QWORD *)a1)
    {
      v14 = (uint64_t)&v11[-*(_QWORD *)a1] >> 3;
      if (v14 >= -1)
        v15 = v14 + 1;
      else
        v15 = v14 + 2;
      v16 = v15 >> 1;
      v17 = -v16;
      v18 = &v11[-8 * v16];
      v19 = v4 - v11;
      if (v4 != v11)
      {
        memmove(&v11[-8 * v16], v11, v4 - v11);
        v4 = *(char **)(a1 + 8);
      }
      v20 = &v4[8 * v17];
      v4 = &v18[v19];
      *(_QWORD *)(a1 + 8) = v20;
      *(_QWORD *)(a1 + 16) = &v18[v19];
      goto LABEL_94;
    }
    v39 = (v4 - v13) >> 2;
    if (v4 == v13)
      v39 = 1;
    if (v39 >> 61)
      goto LABEL_110;
    v40 = v39 >> 2;
    v41 = 8 * v39;
    v42 = (char *)operator new(8 * v39);
    v43 = &v42[8 * v40];
    v45 = v4 - v11;
    v44 = v4 == v11;
    v4 = v43;
    if (!v44)
    {
      v4 = &v43[v45 & 0xFFFFFFFFFFFFFFF8];
      v46 = v45 - 8;
      if ((unint64_t)(v45 - 8) < 0x38)
      {
        v47 = &v42[8 * v40];
        do
        {
LABEL_91:
          v103 = *(_QWORD *)v11;
          v11 += 8;
          *(_QWORD *)v47 = v103;
          v47 += 8;
        }
        while (v47 != v4);
        goto LABEL_92;
      }
      v96 = &v42[8 * v40];
      v47 = v96;
      if ((unint64_t)(v96 - v11) < 0x20)
        goto LABEL_91;
      v97 = (v46 >> 3) + 1;
      v98 = 8 * (v97 & 0x3FFFFFFFFFFFFFFCLL);
      v47 = &v43[v98];
      v11 += v98;
      v99 = (__int128 *)(v5 + 24);
      v100 = v96 + 16;
      v101 = v97 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v102 = *v99;
        *(v100 - 1) = *(v99 - 1);
        *v100 = v102;
        v99 += 2;
        v100 += 2;
        v101 -= 4;
      }
      while (v101);
      if (v97 != (v97 & 0x3FFFFFFFFFFFFFFCLL))
        goto LABEL_91;
    }
LABEL_92:
    *(_QWORD *)a1 = v42;
    *(_QWORD *)(a1 + 8) = v43;
    *(_QWORD *)(a1 + 16) = v4;
    *(_QWORD *)(a1 + 24) = &v42[v41];
    if (v13)
    {
      operator delete(v13);
      v4 = *(char **)(a1 + 16);
    }
    goto LABEL_94;
  }
  v21 = v6 >> 3;
  v22 = *(char **)a1;
  v23 = *(char **)(a1 + 24);
  v24 = (uint64_t)&v23[-*(_QWORD *)a1];
  if (v6 >> 3 < (unint64_t)(v24 >> 3))
  {
    v25 = operator new(0x1000uLL);
    v26 = v25;
    if (v23 != v4)
    {
      *(_QWORD *)v4 = v25;
LABEL_95:
      *(_QWORD *)(a1 + 16) += 8;
      goto LABEL_96;
    }
    if (v5 == v22)
    {
      v71 = (v23 - v5) >> 2;
      if (v4 == v5)
        v71 = 1;
      if (v71 >> 61)
        goto LABEL_110;
      v72 = (v71 + 3) >> 2;
      v73 = 8 * v71;
      v74 = (char *)operator new(8 * v71);
      v48 = &v74[8 * v72];
      v75 = v48;
      if (v4 != v5)
      {
        v75 = &v48[8 * v21];
        v76 = &v74[8 * v72];
        v77 = v5;
        if ((unint64_t)(v6 - 8) < 0x38)
          goto LABEL_113;
        v78 = &v74[8 * v72];
        v76 = v78;
        v77 = v5;
        if ((unint64_t)(v78 - v5) < 0x20)
          goto LABEL_113;
        v79 = ((unint64_t)(v6 - 8) >> 3) + 1;
        v80 = 8 * (v79 & 0x3FFFFFFFFFFFFFFCLL);
        v76 = &v48[v80];
        v77 = &v5[v80];
        v81 = (__int128 *)(v5 + 16);
        v82 = v78 + 16;
        v83 = v79 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v84 = *v81;
          *(v82 - 1) = *(v81 - 1);
          *v82 = v84;
          v81 += 2;
          v82 += 2;
          v83 -= 4;
        }
        while (v83);
        if (v79 != (v79 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_113:
          do
          {
            v85 = *(_QWORD *)v77;
            v77 += 8;
            *(_QWORD *)v76 = v85;
            v76 += 8;
          }
          while (v76 != v75);
        }
      }
      *(_QWORD *)a1 = v74;
      *(_QWORD *)(a1 + 8) = v48;
      *(_QWORD *)(a1 + 16) = v75;
      *(_QWORD *)(a1 + 24) = &v74[v73];
      if (v5)
      {
        operator delete(v5);
        v48 = *(char **)(a1 + 8);
      }
    }
    else
    {
      v48 = v5;
    }
    *((_QWORD *)v48 - 1) = v26;
    v86 = *(char **)(a1 + 8);
    v87 = *(char **)(a1 + 16);
    *(_QWORD *)(a1 + 8) = v86 - 8;
    v88 = *((_QWORD *)v86 - 1);
    *(_QWORD *)(a1 + 8) = v86;
    if (v87 != *(char **)(a1 + 24))
    {
LABEL_79:
      *(_QWORD *)v87 = v88;
      goto LABEL_95;
    }
    v89 = *(char **)a1;
    if ((unint64_t)v86 > *(_QWORD *)a1)
    {
      v90 = (uint64_t)&v86[-*(_QWORD *)a1] >> 3;
      if (v90 >= -1)
        v91 = v90 + 1;
      else
        v91 = v90 + 2;
      v92 = v91 >> 1;
      v93 = -v92;
      v94 = &v86[-8 * v92];
      v95 = v87 - v86;
      if (v87 != v86)
      {
        memmove(&v86[-8 * v92], v86, v87 - v86);
        v86 = *(char **)(a1 + 8);
      }
      *(_QWORD *)(a1 + 8) = &v86[8 * v93];
      *(_QWORD *)(a1 + 16) = &v94[v95];
      *(_QWORD *)&v94[v95] = v88;
      goto LABEL_95;
    }
    v108 = (v87 - v89) >> 2;
    if (v87 == v89)
      v108 = 1;
    if (!(v108 >> 61))
    {
      v109 = v108 >> 2;
      v110 = 8 * v108;
      v111 = (char *)operator new(8 * v108);
      v112 = &v111[8 * v109];
      v113 = v87 - v86;
      v44 = v87 == v86;
      v87 = v112;
      if (v44)
        goto LABEL_108;
      v87 = &v112[v113 & 0xFFFFFFFFFFFFFFF8];
      v114 = v113 - 8;
      if ((unint64_t)(v113 - 8) >= 0x38)
      {
        v116 = &v111[8 * v109];
        v115 = v116;
        if ((unint64_t)(v116 - v86) >= 0x20)
        {
          v117 = (v114 >> 3) + 1;
          v118 = 8 * (v117 & 0x3FFFFFFFFFFFFFFCLL);
          v115 = &v112[v118];
          v119 = &v86[v118];
          v120 = (__int128 *)(v86 + 16);
          v121 = v116 + 16;
          v122 = v117 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v123 = *v120;
            *(v121 - 1) = *(v120 - 1);
            *v121 = v123;
            v120 += 2;
            v121 += 2;
            v122 -= 4;
          }
          while (v122);
          v86 = v119;
          if (v117 == (v117 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_108:
            *(_QWORD *)a1 = v111;
            *(_QWORD *)(a1 + 8) = v112;
            *(_QWORD *)(a1 + 16) = v87;
            *(_QWORD *)(a1 + 24) = &v111[v110];
            if (v89)
            {
              operator delete(v89);
              v87 = *(char **)(a1 + 16);
            }
            goto LABEL_79;
          }
        }
      }
      else
      {
        v115 = &v111[8 * v109];
      }
      do
      {
        v124 = *(_QWORD *)v86;
        v86 += 8;
        *(_QWORD *)v115 = v124;
        v115 += 8;
      }
      while (v115 != v87);
      goto LABEL_108;
    }
LABEL_110:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  v27 = v24 >> 2;
  if (v23 == v22)
    v28 = 1;
  else
    v28 = v27;
  if (v28 >> 61)
    goto LABEL_110;
  v29 = (char *)operator new(8 * v28);
  v30 = &v29[8 * v21];
  v31 = &v29[8 * v28];
  v32 = operator new(0x1000uLL);
  v33 = v32;
  if (v21 == v28)
  {
    if (v6 < 1)
    {
      if (v4 == v5)
        v49 = 1;
      else
        v49 = v6 >> 2;
      if (v49 >> 61)
        goto LABEL_110;
      v50 = (char *)operator new(8 * v49);
      v30 = &v50[8 * (v49 >> 2)];
      v31 = &v50[8 * v49];
      operator delete(v29);
      v51 = *(char **)(a1 + 8);
      v4 = *(char **)(a1 + 16);
      v29 = v50;
      *(_QWORD *)v30 = v33;
      v35 = v30 + 8;
      if (v4 != v51)
      {
        while (1)
        {
LABEL_47:
          if (v30 == v29)
          {
            if (v35 >= v31)
            {
              v56 = (v31 - v30) >> 2;
              if (v31 == v30)
                v56 = 1;
              if (v56 >> 61)
                goto LABEL_110;
              v57 = (v56 + 3) >> 2;
              v58 = 8 * v56;
              v59 = (char *)operator new(8 * v56);
              v29 = v59;
              v52 = &v59[8 * v57];
              v37 = v52;
              v60 = v35 - v30;
              if (v35 != v30)
              {
                v37 = &v52[v60 & 0xFFFFFFFFFFFFFFF8];
                v61 = v60 - 8;
                v62 = &v59[8 * v57];
                v63 = v30;
                if (v61 < 0x38)
                  goto LABEL_114;
                v62 = &v59[8 * v57];
                v63 = v30;
                if ((unint64_t)(v62 - v30) < 0x20)
                  goto LABEL_114;
                v64 = (v61 >> 3) + 1;
                v65 = 8 * (v64 & 0x3FFFFFFFFFFFFFFCLL);
                v62 = &v52[v65];
                v63 = &v30[v65];
                v66 = (__int128 *)(v30 + 16);
                v67 = &v59[8 * v57 + 16];
                v68 = v64 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  v69 = *v66;
                  *((_OWORD *)v67 - 1) = *(v66 - 1);
                  *(_OWORD *)v67 = v69;
                  v66 += 2;
                  v67 += 32;
                  v68 -= 4;
                }
                while (v68);
                if (v64 != (v64 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_114:
                  do
                  {
                    v70 = *(_QWORD *)v63;
                    v63 += 8;
                    *(_QWORD *)v62 = v70;
                    v62 += 8;
                  }
                  while (v62 != v37);
                }
              }
              v31 = &v59[v58];
              operator delete(v30);
            }
            else
            {
              v54 = (v31 - v35) >> 3;
              if (v54 >= -1)
                v55 = v54 + 1;
              else
                v55 = v54 + 2;
              v37 = &v35[8 * (v55 >> 1)];
              v52 = &v30[8 * (v55 >> 1)];
              if (v35 == v30)
              {
                v29 = v35;
              }
              else
              {
                memmove(&v30[8 * (v55 >> 1)], v30, v35 - v30);
                v29 = v30;
              }
            }
          }
          else
          {
            v52 = v30;
            v37 = v35;
          }
          v53 = *((_QWORD *)v4 - 1);
          v4 -= 8;
          *((_QWORD *)v52 - 1) = v53;
          v36 = v52 - 8;
          v35 = v37;
          v30 = v36;
          if (v4 == *(char **)(a1 + 8))
            goto LABEL_29;
        }
      }
      goto LABEL_28;
    }
    v34 = v21 + 2;
    if (v21 >= -1)
      v34 = v21 + 1;
    v30 -= 8 * (v34 >> 1);
  }
  *(_QWORD *)v30 = v32;
  v35 = v30 + 8;
  if (v4 != v5)
    goto LABEL_47;
LABEL_28:
  v36 = v30;
  v37 = v35;
LABEL_29:
  v38 = *(char **)a1;
  *(_QWORD *)a1 = v29;
  *(_QWORD *)(a1 + 8) = v36;
  *(_QWORD *)(a1 + 16) = v37;
  *(_QWORD *)(a1 + 24) = v31;
  v2 = a2;
  if (v38)
    operator delete(v38);
LABEL_96:
  v104 = *(_QWORD *)(a1 + 40);
  v105 = v104 + *(_QWORD *)(a1 + 32);
  v106 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + ((v105 >> 6) & 0x3FFFFFFFFFFFFF8));
  v107 = *v2;
  *v2 = 0;
  *(_QWORD *)(v106 + 8 * (v105 & 0x1FF)) = v107;
  *(_QWORD *)(a1 + 40) = v104 + 1;
}

uint64_t mlir::OperationName::mightHaveTrait<mlir::OpTrait::IsIsolatedFromAbove>(void ***a1)
{
  unsigned __int8 v1;
  void **v2;
  int v4;
  unint64_t v5;
  unint64_t v6;
  const char *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  void ***v12;
  const char *v13;
  unint64_t v14;

  if ((v1 & 1) == 0)
  {
    v12 = a1;
    a1 = v12;
    if (v4)
    {
      v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsIsolatedFromAbove<Empty>]";
      v14 = 91;
      v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5)
        v6 = v5;
      else
        v6 = v14;
      v7 = &v13[v6];
      v8 = v14 - v6;
      if (v14 - v6 >= 0x12)
        v9 = 18;
      else
        v9 = v14 - v6;
      v10 = v8 - v9;
      if (v10 >= v10 - 1)
        v11 = v10 - 1;
      else
        v11 = v10;
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      a1 = v12;
    }
  }
  v2 = *a1;
  if (v2[2] == &mlir::detail::TypeIDResolver<void,void>::id)
    return 1;
  else
    return (*((uint64_t (**)(void **, uint64_t))*v2 + 4))(v2, mlir::detail::TypeIDResolver<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>,void>::resolveTypeID(void)::id);
}

uint64_t llvm::ScopedHashTable<mlir::Operation *,mlir::Operation *,`anonymous namespace'::SimpleOperationInfo,llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>,llvm::ScopedHashTableVal<mlir::Operation *,mlir::Operation *>,32ul,8ul>>::lookup(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;

  v3 = *(_DWORD *)(a1 + 120);
  if (v3)
  {
    v5 = *(_QWORD *)(a1 + 104);
    v6 = v3 - 1;
    LODWORD(v7) = v6 & mlir::OperationEquivalence::computeHash(a2, (uint64_t (*)(uint64_t, _QWORD))llvm::function_ref<llvm::hash_code ()(mlir::Value)>::callback_fn<llvm::hash_code ()(mlir::Value)>, (uint64_t)mlir::OperationEquivalence::directHashValue, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<llvm::hash_code ()(mlir::Value)>::callback_fn<llvm::hash_code ()(mlir::Value)>, (uint64_t)mlir::OperationEquivalence::ignoreHashValue, 1);
    v8 = (uint64_t *)(v5 + 16 * v7);
    v9 = *v8;
    if (*v8 == a2)
      goto LABEL_15;
    if ((a2 | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
      v10 = 1;
      while (v9 != -4096)
      {
        v11 = v7 + v10++;
        v7 = v11 & v6;
        v9 = *(_QWORD *)(v5 + 16 * v7);
        if (v9 == a2)
        {
          v8 = (uint64_t *)(v5 + 16 * v7);
          goto LABEL_15;
        }
      }
    }
    else
    {
      v12 = 1;
      while (1)
      {
        if ((v9 | 0x1000) != 0xFFFFFFFFFFFFF000)
          mlir::OperationEquivalence::isEquivalentTo(a2, v9, 1);
        if (v9 == -4096)
          break;
        v13 = v7 + v12++;
        LODWORD(v7) = v13 & v6;
        v8 = (uint64_t *)(v5 + 16 * (v13 & v6));
        v9 = *v8;
        if (*v8 == a2)
          goto LABEL_15;
      }
    }
  }
  v8 = (uint64_t *)(*(_QWORD *)(a1 + 104) + 16 * *(unsigned int *)(a1 + 120));
LABEL_15:
  if (v8 == (uint64_t *)(*(_QWORD *)(a1 + 104) + 16 * *(unsigned int *)(a1 + 120)))
    return 0;
  else
    return *(_QWORD *)(v8[1] + 24);
}

void `anonymous namespace'::CSEDriver::replaceUsesAndDelete(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  char *v24;
  int v26;
  mlir::detail::OpResultImpl *v27;
  uint64_t i;
  _QWORD *v29;
  int v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  int v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t **v53;
  uint64_t *v54;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *NextResultAtOffset;
  unint64_t v60;
  char *v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  char *v66;
  char *v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  char *v72;
  char *v73;
  uint64_t v74;
  __int128 v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  char *v81;
  char *v82;
  uint64_t v83;
  __int128 v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v88;
  mlir::detail::OpResultImpl *v89;
  uint64_t v90;
  uint64_t v93;
  unint64_t v94[2];
  unint64_t v95;
  uint64_t v96;
  unint64_t v97[2];
  unint64_t v98[2];
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  uint64_t v103;

  v5 = a3;
  v6 = a1;
  v103 = *MEMORY[0x24BDAC8D0];
  if (a5)
  {
    v7 = *(_QWORD *)(*a1 + 16);
    if (v7 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(*a1 + 16)))
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 40))(v7, v5, a4);
    v8 = *v6;
    v9 = *(unsigned int *)(v5 + 36);
    if ((_DWORD)v9)
      v10 = v5 - 16;
    else
      v10 = 0;
    mlir::ValueRange::ValueRange(v98, v10, v9);
    v11 = *(unsigned int *)(a4 + 36);
    if ((_DWORD)v11)
      v12 = a4 - 16;
    else
      v12 = 0;
    mlir::ValueRange::ValueRange(v97, v12, v11);
    mlir::RewriterBase::replaceAllUsesWith(v8, v98[0], v98[1], v97[0], v97[1]);
    v14 = (char *)v6[2];
    v13 = v6[3];
    if ((unint64_t)v14 >= v13)
    {
      v15 = (char *)v6[1];
      v16 = (v14 - v15) >> 3;
      v17 = v16 + 1;
      if (!((unint64_t)(v16 + 1) >> 61))
      {
        v18 = v13 - (_QWORD)v15;
        if (v18 >> 2 > v17)
          v17 = v18 >> 2;
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
          v19 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v19 = v17;
        if (!v19)
        {
          v20 = 0;
          v21 = (char *)(8 * v16);
          v22 = 0;
          *(_QWORD *)(8 * v16) = v5;
          v23 = 8 * v16 + 8;
          v24 = (char *)(v14 - v15);
          if (v14 == v15)
            goto LABEL_104;
LABEL_89:
          v68 = (unint64_t)(v24 - 8);
          if (v68 < 0x58)
            goto LABEL_115;
          if ((unint64_t)(v15 - v20) < 0x20)
            goto LABEL_115;
          v69 = (v68 >> 3) + 1;
          v70 = 8 * (v69 & 0x3FFFFFFFFFFFFFFCLL);
          v71 = &v14[-v70];
          v21 -= v70;
          v72 = &v20[8 * v16 - 16];
          v73 = v14 - 16;
          v74 = v69 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v75 = *(_OWORD *)v73;
            *((_OWORD *)v72 - 1) = *((_OWORD *)v73 - 1);
            *(_OWORD *)v72 = v75;
            v72 -= 32;
            v73 -= 32;
            v74 -= 4;
          }
          while (v74);
          v14 = v71;
          if (v69 != (v69 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_115:
            do
            {
              v76 = *((_QWORD *)v14 - 1);
              v14 -= 8;
              *((_QWORD *)v21 - 1) = v76;
              v21 -= 8;
            }
            while (v14 != v15);
          }
LABEL_103:
          v14 = (char *)v6[1];
          goto LABEL_104;
        }
        if (!(v19 >> 61))
        {
          v20 = (char *)operator new(8 * v19);
          v21 = &v20[8 * v16];
          v22 = &v20[8 * v19];
          *(_QWORD *)v21 = v5;
          v23 = (uint64_t)(v21 + 8);
          v24 = (char *)(v14 - v15);
          if (v14 == v15)
            goto LABEL_104;
          goto LABEL_89;
        }
LABEL_112:
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      goto LABEL_111;
    }
    goto LABEL_77;
  }
  v93 = a2;
  v88 = *(_QWORD *)(*a1 + 16);
  if (v88 && mlir::RewriterBase::Listener::classof(v88))
  {
    v26 = *(_DWORD *)(a3 + 36);
    v27 = (mlir::detail::OpResultImpl *)(a3 - 16);
    if (!v26)
      v27 = 0;
    v89 = v27;
    v90 = *(unsigned int *)(a3 + 36);
    if (v26)
    {
      for (i = 0; i != v90; ++i)
      {
        v29 = *(_QWORD **)mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v89, i);
        v30 = *(_DWORD *)(a2 + 120);
        if (v29)
          v31 = v30 == 0;
        else
          v31 = 1;
        if (!v31)
        {
          if (!v30)
            goto LABEL_47;
LABEL_35:
          v32 = v29[2];
          v33 = *(_QWORD *)(a2 + 104);
          v34 = v30 - 1;
          v35 = v34 & mlir::OperationEquivalence::computeHash(v32, (uint64_t (*)(uint64_t, _QWORD))llvm::function_ref<llvm::hash_code ()(mlir::Value)>::callback_fn<llvm::hash_code ()(mlir::Value)>, (uint64_t)mlir::OperationEquivalence::directHashValue, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<llvm::hash_code ()(mlir::Value)>::callback_fn<llvm::hash_code ()(mlir::Value)>, (uint64_t)mlir::OperationEquivalence::ignoreHashValue, 1);
          v36 = *(_QWORD *)(v33 + 16 * v35);
          if (v36 == v32)
            continue;
          if ((v32 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            v37 = 1;
            do
            {
              if (v36 == -4096)
                goto LABEL_47;
              v38 = v35 + v37++;
              v35 = v38 & v34;
              v36 = *(_QWORD *)(v33 + 16 * (v38 & v34));
            }
            while (v36 != v32);
            continue;
          }
          v39 = 1;
          while (1)
          {
            if ((v36 | 0x1000) != 0xFFFFFFFFFFFFF000)
              mlir::OperationEquivalence::isEquivalentTo(v32, v36, 1);
            if (v36 == -4096)
              break;
            v40 = v35 + v39++;
            v35 = v40 & v34;
            v36 = *(_QWORD *)(v33 + 16 * (v40 & v34));
            if (v36 == v32)
              goto LABEL_29;
          }
LABEL_47:
          while (1)
          {
            v29 = (_QWORD *)*v29;
            if (!v29)
              break;
            v30 = *(_DWORD *)(a2 + 120);
            if (v30)
              goto LABEL_35;
          }
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v88 + 40))(v88, a3, a4);
LABEL_29:
        ;
      }
    }
  }
  v41 = *a1;
  v42 = *(unsigned int *)(a3 + 36);
  if ((_DWORD)v42)
    v43 = a3 - 16;
  else
    v43 = 0;
  mlir::ValueRange::ValueRange(&v95, v43, v42);
  v44 = *(unsigned int *)(a4 + 36);
  if ((_DWORD)v44)
    v45 = a4 - 16;
  else
    v45 = 0;
  mlir::ValueRange::ValueRange(v94, v45, v44);
  v46 = v95;
  v47 = v96;
  v48 = v94[0];
  v49 = v94[1];
  v99 = v95;
  v100 = 0;
  v101 = v94[0];
  v102 = 0;
  if (v96)
  {
    v50 = 0;
    v51 = 0;
    do
    {
      if (v101 == v48 && v51 == v49)
        break;
      v53 = (uint64_t **)mlir::ValueRange::dereference_iterator(&v99, v50);
      v54 = (uint64_t *)mlir::ValueRange::dereference_iterator(&v101, v102);
      v50 = v100 + 1;
      v51 = v102 + 1;
      ++v100;
      ++v102;
    }
    while (v99 != v46 || v50 != v47);
  }
  v5 = a3;
  v56 = *(unsigned int *)(a3 + 36);
  if ((_DWORD)v56)
    v57 = a3 - 16;
  else
    v57 = 0;
  v6 = a1;
  if (!(_DWORD)v56)
  {
LABEL_76:
    v14 = (char *)a1[2];
    v60 = a1[3];
    if ((unint64_t)v14 >= v60)
    {
      v61 = (char *)a1[1];
      v62 = (v14 - v61) >> 3;
      v63 = v62 + 1;
      if (!((unint64_t)(v62 + 1) >> 61))
      {
        v64 = v60 - (_QWORD)v61;
        if (v64 >> 2 > v63)
          v63 = v64 >> 2;
        if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF8)
          v65 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v65 = v63;
        if (v65)
        {
          if (v65 >> 61)
            goto LABEL_112;
          v66 = (char *)operator new(8 * v65);
          v21 = &v66[8 * v62];
          v22 = &v66[8 * v65];
          *(_QWORD *)v21 = a3;
          v23 = (uint64_t)(v21 + 8);
          v67 = (char *)(v14 - v61);
          if (v14 == v61)
          {
LABEL_104:
            v6[1] = (uint64_t)v21;
            v6[2] = v23;
            v6[3] = (uint64_t)v22;
            if (v14)
              operator delete(v14);
            goto LABEL_106;
          }
        }
        else
        {
          v66 = 0;
          v21 = (char *)(8 * v62);
          v22 = 0;
          *(_QWORD *)(8 * v62) = a3;
          v23 = 8 * v62 + 8;
          v67 = (char *)(v14 - v61);
          if (v14 == v61)
            goto LABEL_104;
        }
        v77 = (unint64_t)(v67 - 8);
        if (v77 < 0x58)
          goto LABEL_116;
        if ((unint64_t)(v61 - v66) < 0x20)
          goto LABEL_116;
        v78 = (v77 >> 3) + 1;
        v79 = 8 * (v78 & 0x3FFFFFFFFFFFFFFCLL);
        v80 = &v14[-v79];
        v21 -= v79;
        v81 = &v66[8 * v62 - 16];
        v82 = v14 - 16;
        v83 = v78 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v84 = *(_OWORD *)v82;
          *((_OWORD *)v81 - 1) = *((_OWORD *)v82 - 1);
          *(_OWORD *)v81 = v84;
          v81 -= 32;
          v82 -= 32;
          v83 -= 4;
        }
        while (v83);
        v14 = v80;
        if (v78 != (v78 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_116:
          do
          {
            v85 = *((_QWORD *)v14 - 1);
            v14 -= 8;
            *((_QWORD *)v21 - 1) = v85;
            v21 -= 8;
          }
          while (v14 != v61);
        }
        goto LABEL_103;
      }
LABEL_111:
      abort();
    }
LABEL_77:
    *(_QWORD *)v14 = v5;
    v23 = (uint64_t)(v14 + 8);
LABEL_106:
    v6[2] = v23;
    goto LABEL_107;
  }
  if (!*(_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(a3 - 16, 0))
  {
    v58 = 1;
    while (v56 != v58)
    {
      NextResultAtOffset = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v57, v58++);
      if (*NextResultAtOffset)
        goto LABEL_107;
    }
    goto LABEL_76;
  }
LABEL_107:
  if (*(_UNKNOWN **)(**(_QWORD **)(a4 + 24) + 136) == &mlir::detail::TypeIDResolver<mlir::UnknownLoc,void>::id)
  {
    v86 = *(_QWORD *)(v5 + 24);
    if (*(_UNKNOWN **)(*(_QWORD *)v86 + 136) != &mlir::detail::TypeIDResolver<mlir::UnknownLoc,void>::id)
      *(_QWORD *)(a4 + 24) = v86;
  }
  ++v6[8];
}

BOOL llvm::all_of<llvm::SmallVector<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>,4u> &,BOOL mlir::MemoryEffectOpInterface::onlyHasEffect<mlir::MemoryEffects::Read>(void)::{lambda(llvm::SmallVector<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>,4u> & const&)#1}>(uint64_t a1)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t **v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  uint64_t v8;
  _BOOL8 result;
  BOOL v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  const char *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t **v22;
  const char *v23;
  unint64_t v24;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 1;
  v2 = 40 * v1;
  v3 = *(uint64_t ***)a1;
  v4 = v2 - 40;
  v5 = &unk_25451A000;
  do
  {
    v6 = **v3;
    if ((v7 & 1) == 0)
    {
      v21 = v4;
      v22 = v3;
      v20 = **v3;
      v6 = v20;
      v4 = v21;
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v22;
      if (v11)
      {
        v23 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffects::Read]";
        v24 = 75;
        v12 = llvm::StringRef::find((uint64_t *)&v23, "DesiredTypeName = ", 0x12uLL, 0);
        if (v24 >= v12)
          v13 = v12;
        else
          v13 = v24;
        v14 = &v23[v13];
        v15 = v24 - v13;
        v16 = 18;
        if (v15 < 0x12)
          v16 = v15;
        v17 = (uint64_t)&v14[v16];
        v18 = v15 - v16;
        if (v18 >= v18 - 1)
          v19 = v18 - 1;
        else
          v19 = v18;
        mlir::detail::TypeIDResolver<mlir::MemoryEffects::Read,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v17, v19);
        v6 = v20;
        v4 = v21;
        v5 = (_QWORD *)&unk_25451A000;
        v3 = v22;
      }
    }
    v8 = v5[398];
    result = v6 == v8;
    v10 = v6 != v8 || v4 == 0;
    v4 -= 40;
    v3 += 5;
  }
  while (!v10);
  return result;
}

unint64_t mlir::OperationEquivalence::directHashValue(unint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  unint64_t v3;
  unint64_t v4;
  int v6;
  int v7;
  unint64_t v8;
  unint64_t v9;

  v2 = &unk_254519000;
  if ((v1 & 1) == 0)
  {
    v9 = a1;
    v2 = &unk_254519000;
    v7 = v6;
    a1 = v9;
    if (v7)
    {
      v8 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v8 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v8;
      v2 = (_QWORD *)&unk_254519000;
      a1 = v9;
    }
  }
  v3 = 0x9DDFEA08EB382D69 * ((v2[373] + 8 * a1) ^ HIDWORD(a1));
  v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a1) ^ (v3 >> 47) ^ v3);
  return 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
}

uint64_t mlir::OperationEquivalence::ignoreHashValue()
{
  return 0;
}

uint64_t llvm::function_ref<llvm::hash_code ()(mlir::Value)>::callback_fn<llvm::hash_code ()(mlir::Value)>(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t *llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,std::pair<mlir::Operation *,mlir::MemoryEffects::Effect *>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::pair<mlir::Operation *,mlir::MemoryEffects::Effect *>>>,mlir::Operation *,std::pair<mlir::Operation *,mlir::MemoryEffects::Effect *>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::pair<mlir::Operation *,mlir::MemoryEffects::Effect *>>>::InsertIntoBucket<mlir::Operation * const&,std::pair<mlir::Operation *,decltype(nullptr)>>(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t *v15;
  int v16;
  BOOL v17;
  unsigned int v18;

  v8 = *(_DWORD *)(a1 + 8);
  v9 = *(_DWORD *)(a1 + 16);
  if (4 * v8 + 4 >= 3 * v9)
  {
    v9 *= 2;
  }
  else if (v9 + ~v8 - *(_DWORD *)(a1 + 12) > v9 >> 3)
  {
LABEL_3:
    v10 = *a2;
    goto LABEL_4;
  }
  llvm::DenseMap<mlir::Operation *,mlir::ValueRange,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::ValueRange>>::grow(a1, v9);
  v10 = *a3;
  v12 = *(_DWORD *)(a1 + 16) - 1;
  v13 = ((*a3 >> 4) ^ (*a3 >> 9)) & v12;
  a2 = (uint64_t *)(*(_QWORD *)a1 + 24 * v13);
  v14 = *a2;
  if (*a3 != *a2)
  {
    v15 = 0;
    v16 = 1;
    while (v14 != -4096)
    {
      if (v15)
        v17 = 0;
      else
        v17 = v14 == -8192;
      if (v17)
        v15 = a2;
      v18 = v13 + v16++;
      v13 = v18 & v12;
      a2 = (uint64_t *)(*(_QWORD *)a1 + 24 * (v18 & v12));
      v14 = *a2;
      if (v10 == *a2)
        goto LABEL_4;
    }
    if (v15)
      a2 = v15;
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v10 != -4096)
    --*(_DWORD *)(a1 + 12);
  *a2 = *a3;
  a2[1] = *a4;
  a2[2] = 0;
  return a2;
}

BOOL llvm::function_ref<BOOL ()(mlir::OpOperand &)>::callback_fn<`anonymous namespace'::CSEDriver::replaceUsesAndDelete(llvm::ScopedHashTable<mlir::Operation *,mlir::Operation *,`anonymous namespace'::SimpleOperationInfo,llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>,llvm::ScopedHashTableVal<mlir::Operation *,mlir::Operation *>,32ul,8ul>> &,mlir::Operation *,mlir::Operation *,BOOL)::$_0>(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  _BOOL8 result;
  unsigned int v10;
  int v11;
  unsigned int v12;

  v2 = *(_DWORD *)(*(_QWORD *)a1 + 120);
  if (!v2)
    return 1;
  v3 = *(_QWORD *)(a2 + 16);
  v4 = *(_QWORD *)(*(_QWORD *)a1 + 104);
  v5 = v2 - 1;
  v6 = v5 & mlir::OperationEquivalence::computeHash(v3, (uint64_t (*)(uint64_t, _QWORD))llvm::function_ref<llvm::hash_code ()(mlir::Value)>::callback_fn<llvm::hash_code ()(mlir::Value)>, (uint64_t)mlir::OperationEquivalence::directHashValue, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<llvm::hash_code ()(mlir::Value)>::callback_fn<llvm::hash_code ()(mlir::Value)>, (uint64_t)mlir::OperationEquivalence::ignoreHashValue, 1);
  v7 = *(_QWORD *)(v4 + 16 * v6);
  if (v7 == v3)
    return 0;
  if ((v3 | 0x1000) == 0xFFFFFFFFFFFFF000)
  {
    v8 = 1;
    do
    {
      result = v7 == -4096;
      if (v7 == -4096)
        break;
      result = 0;
      v10 = v6 + v8++;
      v6 = v10 & v5;
      v7 = *(_QWORD *)(v4 + 16 * (v10 & v5));
    }
    while (v7 != v3);
  }
  else
  {
    v11 = 1;
    while (1)
    {
      if ((v7 | 0x1000) != 0xFFFFFFFFFFFFF000)
        mlir::OperationEquivalence::isEquivalentTo(v3, v7, 1);
      if (v7 == -4096)
        break;
      result = 0;
      v12 = v6 + v11++;
      v6 = v12 & v5;
      v7 = *(_QWORD *)(v4 + 16 * (v12 & v5));
      if (v7 == v3)
        return result;
    }
    return 1;
  }
  return result;
}

uint64_t *llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,llvm::ScopedHashTableVal<mlir::Operation *,mlir::Operation *> *,`anonymous namespace'::SimpleOperationInfo,llvm::detail::DenseMapPair<mlir::Operation *,llvm::ScopedHashTableVal<mlir::Operation *,mlir::Operation *> *>>,mlir::Operation *,llvm::ScopedHashTableVal<mlir::Operation *,mlir::Operation *> *,`anonymous namespace'::SimpleOperationInfo,llvm::detail::DenseMapPair<mlir::Operation *,llvm::ScopedHashTableVal<mlir::Operation *,mlir::Operation *> *>>::operator[](uint64_t a1, uint64_t *a2)
{
  int v4;
  llvm *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v12;
  BOOL v13;
  unsigned int v14;
  unsigned int v15;
  BOOL v16;
  int v17;
  uint64_t v18;
  int v20;
  llvm *v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  unsigned int v25;
  _QWORD *buffer;
  _QWORD *v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t *v34;
  uint64_t *v35;
  BOOL v36;
  uint64_t *v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  llvm *v44;
  int v45;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  _QWORD *v49;
  uint64_t v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  uint64_t *v54;
  int v55;
  BOOL v56;
  unsigned int v57;
  uint64_t v58;
  llvm *v59;

  v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    v5 = *(llvm **)a1;
    v6 = v4 - 1;
    v7 = (v4 - 1) & mlir::OperationEquivalence::computeHash(*a2, (uint64_t (*)(uint64_t, _QWORD))llvm::function_ref<llvm::hash_code ()(mlir::Value)>::callback_fn<llvm::hash_code ()(mlir::Value)>, (uint64_t)mlir::OperationEquivalence::directHashValue, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<llvm::hash_code ()(mlir::Value)>::callback_fn<llvm::hash_code ()(mlir::Value)>, (uint64_t)mlir::OperationEquivalence::ignoreHashValue, 1);
    v8 = (uint64_t *)((char *)v5 + 16 * v7);
    v9 = *a2;
    v10 = *v8;
    if (*a2 == *v8)
      return v8 + 1;
    v11 = 0;
    v12 = 1;
    while (1)
    {
      if (v10 != -4096 && v10 != -8192 && v9 != -8192 && v9 != -4096)
        mlir::OperationEquivalence::isEquivalentTo(v9, v10, 1);
      if (v10 == -4096)
        break;
      if (v11)
        v13 = 0;
      else
        v13 = v10 == -8192;
      if (v13)
        v11 = v8;
      v14 = v7 + v12++;
      v7 = v14 & v6;
      v8 = (uint64_t *)((char *)v5 + 16 * (v14 & v6));
      v9 = *a2;
      v10 = *v8;
      if (*a2 == *v8)
        return v8 + 1;
    }
    if (v11)
      v8 = v11;
    v15 = *(_DWORD *)(a1 + 16);
    v20 = *(_DWORD *)(a1 + 8);
    if (4 * v20 + 4 < 3 * v15)
    {
      v16 = v15 + ~v20 - *(_DWORD *)(a1 + 12) > v15 >> 3;
      v17 = *(_DWORD *)(a1 + 16);
      if (v16)
        goto LABEL_20;
      goto LABEL_29;
    }
  }
  else
  {
    v15 = 0;
  }
  v17 = 2 * v15;
LABEL_29:
  v21 = *(llvm **)a1;
  v22 = (v17 - 1) | ((unint64_t)(v17 - 1) >> 1);
  v23 = v22 | (v22 >> 2) | ((v22 | (v22 >> 2)) >> 4);
  v24 = ((v23 | (v23 >> 8)) >> 16) | v23 | (v23 >> 8);
  if ((v24 + 1) > 0x40)
    v25 = v24 + 1;
  else
    v25 = 64;
  *(_DWORD *)(a1 + 16) = v25;
  buffer = llvm::allocate_buffer(16 * v25, (std::align_val_t)8uLL);
  v27 = buffer;
  *(_QWORD *)a1 = buffer;
  v59 = v21;
  if (v21)
  {
    v58 = v15;
    *(_QWORD *)(a1 + 8) = 0;
    v28 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v28)
    {
      v29 = buffer;
      if (((v28 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
        goto LABEL_38;
      v30 = ((v28 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
      v29 = &buffer[2 * (v30 & 0x1FFFFFFFFFFFFFFELL)];
      v31 = buffer + 2;
      v32 = v30 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(v31 - 2) = -4096;
        *v31 = -4096;
        v31 += 4;
        v32 -= 2;
      }
      while (v32);
      if (v30 != (v30 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_38:
        v33 = &buffer[2 * v28];
        do
        {
          *v29 = -4096;
          v29 += 2;
        }
        while (v29 != v33);
      }
    }
    if (v15)
    {
      v34 = (uint64_t *)v21;
      v35 = (uint64_t *)((char *)v21 + 16 * v15);
      do
      {
        if ((*v34 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v44 = *(llvm **)a1;
          v45 = *(_DWORD *)(a1 + 16) - 1;
          v40 = v45 & mlir::OperationEquivalence::computeHash(*v34, (uint64_t (*)(uint64_t, _QWORD))llvm::function_ref<llvm::hash_code ()(mlir::Value)>::callback_fn<llvm::hash_code ()(mlir::Value)>, (uint64_t)mlir::OperationEquivalence::directHashValue, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<llvm::hash_code ()(mlir::Value)>::callback_fn<llvm::hash_code ()(mlir::Value)>, (uint64_t)mlir::OperationEquivalence::ignoreHashValue, 1);
          v41 = (uint64_t *)((char *)v44 + 16 * v40);
          v42 = *v34;
          v43 = *v41;
          if (*v34 != *v41)
          {
            v37 = 0;
            v39 = 1;
            while (1)
            {
              if (v43 != -4096 && v43 != -8192 && v42 != -8192 && v42 != -4096)
                mlir::OperationEquivalence::isEquivalentTo(v42, v43, 1);
              if (v43 == -4096)
                break;
              if (v37)
                v36 = 0;
              else
                v36 = v43 == -8192;
              if (v36)
                v37 = v41;
              v38 = v40 + v39++;
              v40 = v38 & v45;
              v41 = (uint64_t *)((char *)v44 + 16 * (v38 & v45));
              v42 = *v34;
              v43 = *v41;
              if (*v34 == *v41)
                goto LABEL_61;
            }
            if (v37)
              v41 = v37;
          }
LABEL_61:
          *v41 = *v34;
          v41[1] = v34[1];
          ++*(_DWORD *)(a1 + 8);
        }
        v34 += 2;
      }
      while (v34 != v35);
    }
    llvm::deallocate_buffer(v59, (void *)(16 * v58));
  }
  *(_QWORD *)(a1 + 8) = 0;
  v46 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v46)
  {
    v47 = buffer;
    if (((v46 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
      goto LABEL_90;
    v48 = ((v46 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    v47 = &buffer[2 * (v48 & 0x1FFFFFFFFFFFFFFELL)];
    v49 = buffer + 2;
    v50 = v48 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v49 - 2) = -4096;
      *v49 = -4096;
      v49 += 4;
      v50 -= 2;
    }
    while (v50);
    if (v48 != (v48 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_90:
      do
      {
        *v47 = -4096;
        v47 += 2;
      }
      while (v47 != &buffer[2 * v46]);
    }
  }
  v51 = v46 - 1;
  v52 = (v46 - 1) & mlir::OperationEquivalence::computeHash(*a2, (uint64_t (*)(uint64_t, _QWORD))llvm::function_ref<llvm::hash_code ()(mlir::Value)>::callback_fn<llvm::hash_code ()(mlir::Value)>, (uint64_t)mlir::OperationEquivalence::directHashValue, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<llvm::hash_code ()(mlir::Value)>::callback_fn<llvm::hash_code ()(mlir::Value)>, (uint64_t)mlir::OperationEquivalence::ignoreHashValue, 1);
  v8 = &v27[2 * v52];
  v18 = *a2;
  v53 = *v8;
  if (*a2 == *v8)
    goto LABEL_21;
  v54 = 0;
  v55 = 1;
  while (1)
  {
    if (v53 != -4096 && v53 != -8192 && v18 != -8192 && v18 != -4096)
      mlir::OperationEquivalence::isEquivalentTo(v18, v53, 1);
    if (v53 == -4096)
      break;
    if (v54)
      v56 = 0;
    else
      v56 = v53 == -8192;
    if (v56)
      v54 = v8;
    v57 = v52 + v55++;
    v52 = v57 & v51;
    v8 = &v27[2 * (v57 & v51)];
    v18 = *a2;
    v53 = *v8;
    if (*a2 == *v8)
      goto LABEL_21;
  }
  if (v54)
    v8 = v54;
LABEL_20:
  v18 = *v8;
LABEL_21:
  ++*(_DWORD *)(a1 + 8);
  if (v18 != -4096)
    --*(_DWORD *)(a1 + 12);
  *v8 = *a2;
  v8[1] = 0;
  return v8 + 1;
}

_QWORD *llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>,llvm::ScopedHashTableVal<mlir::Operation *,mlir::Operation *>,32ul,8ul>::Allocate<llvm::ScopedHashTableVal<mlir::Operation *,mlir::Operation *>>(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;
  BOOL v4;
  unsigned int v5;
  uint64_t v6;
  char *buffer;
  uint64_t v8;
  char *v9;
  char *v10;

  result = *(_QWORD **)a1;
  if (result)
  {
    *(_QWORD *)a1 = *result;
  }
  else
  {
    *(_QWORD *)(a1 + 88) += 32;
    v3 = *(_QWORD *)(a1 + 8);
    if (v3)
      v4 = ((v3 + 7) & 0xFFFFFFFFFFFFFFF8) - v3 + 32 > *(_QWORD *)(a1 + 16) - v3;
    else
      v4 = 1;
    if (v4)
    {
      v5 = *(_DWORD *)(a1 + 32) >> 7;
      if (v5 >= 0x1E)
        LOBYTE(v5) = 30;
      v6 = 4096 << v5;
      buffer = (char *)llvm::allocate_buffer(4096 << v5, (std::align_val_t)8uLL);
      v8 = *(unsigned int *)(a1 + 32);
      if (v8 >= *(_DWORD *)(a1 + 36))
      {
        v10 = buffer;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (void *)(a1 + 40), v8 + 1, 8);
        buffer = v10;
        LODWORD(v8) = *(_DWORD *)(a1 + 32);
      }
      *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v8) = buffer;
      ++*(_DWORD *)(a1 + 32);
      v9 = &buffer[v6];
      result = (_QWORD *)((unint64_t)(buffer + 7) & 0xFFFFFFFFFFFFFFF8);
      *(_QWORD *)(a1 + 8) = result + 4;
      *(_QWORD *)(a1 + 16) = v9;
    }
    else
    {
      result = (_QWORD *)((v3 + 7) & 0xFFFFFFFFFFFFFFF8);
      *(_QWORD *)(a1 + 8) = result + 4;
    }
  }
  return result;
}

uint64_t llvm::DenseMap<mlir::Operation *,std::pair<mlir::Operation *,mlir::MemoryEffects::Effect *>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::pair<mlir::Operation *,mlir::MemoryEffects::Effect *>>>::shrink_and_clear(uint64_t result)
{
  uint64_t v1;
  int v2;
  int v3;
  int v4;
  llvm *v5;
  unint64_t v6;
  llvm *v7;
  unint64_t v8;
  uint64_t v9;
  llvm *v10;
  llvm *v11;

  v1 = *(unsigned int *)(result + 16);
  v2 = *(_DWORD *)(result + 8);
  v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64)
    v3 = 64;
  if (v2)
    v4 = v3;
  else
    v4 = 0;
  if (v4 != (_DWORD)v1)
    llvm::deallocate_buffer(*(llvm **)result, (void *)(24 * v1));
  *(_QWORD *)(result + 8) = 0;
  if ((_DWORD)v1)
  {
    v5 = *(llvm **)result;
    v6 = 24 * v1 - 24;
    if (v6 < 0x18)
    {
      v7 = *(llvm **)result;
LABEL_14:
      v11 = (llvm *)((char *)v5 + 24 * v1);
      do
      {
        *(_QWORD *)v7 = -4096;
        v7 = (llvm *)((char *)v7 + 24);
      }
      while (v7 != v11);
      return result;
    }
    v8 = v6 / 0x18 + 1;
    v7 = (llvm *)((char *)v5 + 24 * (v8 & 0x1FFFFFFFFFFFFFFELL));
    v9 = v8 & 0x1FFFFFFFFFFFFFFELL;
    v10 = *(llvm **)result;
    do
    {
      *(_QWORD *)v10 = -4096;
      *((_QWORD *)v10 + 3) = -4096;
      v10 = (llvm *)((char *)v10 + 48);
      v9 -= 2;
    }
    while (v9);
    if (v8 != (v8 & 0x1FFFFFFFFFFFFFFELL))
      goto LABEL_14;
  }
  return result;
}

void `anonymous namespace'::CSE::~CSE(_anonymous_namespace_::CSE *this)
{
  mlir::Pass::~Pass(this);
  JUMPOUT(0x20BD002F8);
}

const char *mlir::impl::CSEBase<`anonymous namespace'::CSE>::getName()
{
  return "CSE";
}

const char *mlir::impl::CSEBase<`anonymous namespace'::CSE>::getArgument()
{
  return "cse";
}

const char *mlir::impl::CSEBase<`anonymous namespace'::CSE>::getDescription()
{
  return "Eliminate common sub-expressions";
}

void `anonymous namespace'::CSE::runOnOperation(_anonymous_namespace_::CSE *this)
{
  uint64_t Context;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  mlir::Operation *v7;
  BOOL v8;
  _QWORD v9[7];
  int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[5];

  Context = mlir::Attribute::getContext((mlir::Attribute *)((*((_QWORD *)this + 5) & 0xFFFFFFFFFFFFFFF8) + 24));
  memset(&v13[2], 0, 24);
  v13[0] = off_24C02E6B8;
  v13[1] = Context;
  v3 = *((_QWORD *)this + 6);
  v9[0] = v3;
  v4 = *(_QWORD *)(v3 + 72);
  v5 = v4 & 0xFFFFFFFFFFFFFFF8;
  if ((v4 & 4) == 0 && v5)
  {
    do
    {
      v6 = *(_QWORD *)(v5 + 72);
      v5 = v6 & 0xFFFFFFFFFFFFFFF8;
    }
    while ((v6 & 4) == 0 && v5);
  }
  v9[0] = v13;
  memset(&v9[1], 0, 24);
  v9[5] = 0;
  v9[6] = 0;
  v9[4] = mlir::detail::AnalysisMap::getAnalysisImpl<mlir::DominanceInfo,mlir::Operation *>(v3 + 24, (std::recursive_mutex **)v5);
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v7 = (mlir::Operation *)(*((_QWORD *)this + 5) & 0xFFFFFFFFFFFFFFF8);
  v8 = 0;
}

void sub_207550B54(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, __int16 a10, char a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, llvm *a18, uint64_t a19, unsigned int a20,int a21,int a22,int a23,int a24)
{
  const void **v24;
  const void **v25;

  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)(v24 + 43));
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)((char *)v24 + 345));
  v25 = v24 + 7;
  if (a12)
  {
    mlir::detail::PreservedAnalyses::preserve<mlir::DominanceInfo>(v25);
    mlir::detail::PreservedAnalyses::preserve<mlir::PostDominanceInfo>(v25);
  }
  else
  {
    mlir::detail::PreservedAnalyses::preserveAll(v25);
  }
  llvm::deallocate_buffer(a18, (void *)(24 * a20));
}

void sub_207550BAC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  uint64_t v28;
  void *v29;

  if (v29)
    operator delete(v29);
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)(v28 - 56));
}

uint64_t mlir::impl::CSEBase<`anonymous namespace'::CSE>::clonePass@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v4 = operator new();
  v5 = *(_QWORD *)(a1 + 8);
  *(_OWORD *)(v4 + 16) = *(_OWORD *)(a1 + 16);
  *(_QWORD *)(v4 + 32) = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v4 + 40) = 0;
  *(_BYTE *)(v4 + 120) = 0;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_OWORD *)(v4 + 160) = 0u;
  *(_QWORD *)(v4 + 176) = 0;
  *(_QWORD *)(v4 + 184) = v4 + 200;
  *(_QWORD *)(v4 + 192) = 0x400000000;
  *(_QWORD *)(v4 + 232) = v4 + 248;
  *(_QWORD *)(v4 + 240) = 0x400000000;
  *(_QWORD *)(v4 + 280) = 0;
  *(_QWORD *)(v4 + 288) = 0;
  *(_DWORD *)(v4 + 296) = 0;
  *(_DWORD *)(v4 + 300) = 16;
  *(_OWORD *)(v4 + 304) = 0u;
  *(_OWORD *)(v4 + 320) = 0u;
  *(_QWORD *)(v4 + 336) = 0;
  *(_QWORD *)v4 = off_24C051980;
  *(_QWORD *)(v4 + 8) = v5;
  mlir::Pass::Statistic::Statistic((mlir::Pass::Statistic *)(v4 + 344), (mlir::Pass *)v4, "num-cse'd", "Number of operations CSE'd");
  result = mlir::Pass::Statistic::Statistic((mlir::Pass::Statistic *)(v4 + 345), (mlir::Pass *)v4, "num-dce'd", "Number of operations DCE'd");
  *(_QWORD *)v4 = &off_24C02B1C0;
  *a2 = v4;
  return result;
}

uint64_t mlir::detail::AnalysisMap::getAnalysisImpl<mlir::DominanceInfo,mlir::Operation *>(uint64_t a1, std::recursive_mutex **a2)
{
  unsigned __int8 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;
  int v12;
  unsigned int *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  const char *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  BOOL v24;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  const char *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v43;
  unint64_t v44;
  const char *v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  const char *v50;
  unint64_t v51;

  if ((v4 & 1) == 0
  {
    v50 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DominanceInfo]";
    v51 = 69;
    v43 = llvm::StringRef::find((uint64_t *)&v50, "DesiredTypeName = ", 0x12uLL, 0);
    if (v51 >= v43)
      v44 = v43;
    else
      v44 = v51;
    v45 = &v50[v44];
    v46 = v51 - v44;
    if (v51 - v44 >= 0x12)
      v47 = 18;
    else
      v47 = v51 - v44;
    v48 = v46 - v47;
    if (v48 >= v48 - 1)
      v49 = v48 - 1;
    else
      v49 = v48;
    mlir::detail::TypeIDResolver<mlir::DominanceInfo,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v45[v47], v49);
  }
  v5 = mlir::detail::TypeIDResolver<mlir::DominanceInfo,void>::resolveTypeID(void)::id;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v7)
  {
    LODWORD(v8) = (v7 - 1) & ((mlir::detail::TypeIDResolver<mlir::DominanceInfo,void>::resolveTypeID(void)::id >> 4) ^ (mlir::detail::TypeIDResolver<mlir::DominanceInfo,void>::resolveTypeID(void)::id >> 9));
    v9 = (_QWORD *)(v6 + 16 * v8);
    v10 = *v9;
    if (mlir::detail::TypeIDResolver<mlir::DominanceInfo,void>::resolveTypeID(void)::id == *v9)
      goto LABEL_9;
    v11 = 1;
    while (v10 != -4096)
    {
      v12 = v8 + v11++;
      v8 = v12 & (v7 - 1);
      v10 = *(_QWORD *)(v6 + 16 * v8);
      if (mlir::detail::TypeIDResolver<mlir::DominanceInfo,void>::resolveTypeID(void)::id == v10)
      {
        v9 = (_QWORD *)(v6 + 16 * v8);
        goto LABEL_9;
      }
    }
  }
  v9 = (_QWORD *)(v6 + 16 * v7);
LABEL_9:
  if (v9 == (_QWORD *)(v6 + 16 * v7))
    v13 = (unsigned int *)(a1 + 40);
  else
    v13 = (unsigned int *)(v9 + 1);
  v14 = *v13;
  if (*(_DWORD *)(a1 + 40) == (_DWORD)v14)
  {
    if (a2)
    {
      v50 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DominanceInfo]";
      v51 = 69;
      v15 = llvm::StringRef::find((uint64_t *)&v50, "DesiredTypeName = ", 0x12uLL, 0);
      if (v51 >= v15)
        v16 = v15;
      else
        v16 = v51;
      v17 = &v50[v16];
      v18 = v51 - v16;
      if (v51 - v16 >= 0x12)
        v19 = 18;
      else
        v19 = v51 - v16;
      v20 = (uint64_t)&v17[v19];
      v21 = v18 - v19;
      if (v21 >= v21 - 1)
        v22 = v21 - 1;
      else
        v22 = v21;
      if (v22 >= 6)
      {
        if (*(_DWORD *)v20 == 1919511661 && *(_WORD *)(v20 + 4) == 14906)
        {
          v20 += 6;
          v22 -= 6;
        }
        else if (v22 >= 0x17)
        {
          v24 = *(_QWORD *)v20 == 0x6F6D796E6F6E6128 && *(_QWORD *)(v20 + 8) == 0x73656D616E207375;
          if (v24 && *(_QWORD *)(v20 + 15) == 0x3A3A296563617073)
          {
            v20 += 23;
            v22 -= 23;
          }
        }
      }
      mlir::PassInstrumentor::runBeforeAnalysis(a2, v20, v22, v5, *(_QWORD *)a1);
    }
    v28 = operator new();
    *(_QWORD *)(v28 + 8) = 0;
    *(_QWORD *)(v28 + 16) = 0;
    *(_QWORD *)v28 = &unk_24C052070;
    *(_DWORD *)(v28 + 24) = 0;
    v50 = (const char *)v5;
    v51 = v28;
    v27 = llvm::MapVector<mlir::TypeID,std::unique_ptr<mlir::detail::AnalysisConcept>,llvm::DenseMap<mlir::TypeID,unsigned int,llvm::DenseMapInfo<mlir::TypeID,void>,llvm::detail::DenseMapPair<mlir::TypeID,unsigned int>>,llvm::SmallVector<std::pair<mlir::TypeID,std::unique_ptr<mlir::detail::AnalysisConcept>>,0u>>::try_emplace<std::unique_ptr<mlir::detail::AnalysisConcept>>(a1 + 8, (double *)&v50, (uint64_t *)&v51);
    v29 = v51;
    v51 = 0;
    if (v29)
      (*(void (**)(uint64_t))(*(_QWORD *)v29 + 8))(v29);
    if (a2)
    {
      v50 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DominanceInfo]";
      v51 = 69;
      v30 = llvm::StringRef::find((uint64_t *)&v50, "DesiredTypeName = ", 0x12uLL, 0);
      if (v51 >= v30)
        v31 = v30;
      else
        v31 = v51;
      v32 = &v50[v31];
      v33 = v51 - v31;
      if (v51 - v31 >= 0x12)
        v34 = 18;
      else
        v34 = v51 - v31;
      v35 = (uint64_t)&v32[v34];
      v36 = v33 - v34;
      if (v36 >= v36 - 1)
        v37 = v36 - 1;
      else
        v37 = v36;
      if (v37 >= 6)
      {
        if (*(_DWORD *)v35 == 1919511661 && *(_WORD *)(v35 + 4) == 14906)
        {
          v35 += 6;
          v37 -= 6;
        }
        else if (v37 >= 0x17
               && *(_QWORD *)v35 == 0x6F6D796E6F6E6128
               && *(_QWORD *)(v35 + 8) == 0x73656D616E207375
               && *(_QWORD *)(v35 + 15) == 0x3A3A296563617073)
        {
          v35 += 23;
          v37 -= 23;
        }
      }
      mlir::PassInstrumentor::runAfterAnalysis(a2, v35, v37, v5, *(_QWORD *)a1);
    }
  }
  else
  {
    v27 = *(_QWORD *)(a1 + 32) + 16 * v14;
  }
  return *(_QWORD *)(v27 + 8) + 8;
}

uint64_t llvm::MapVector<mlir::TypeID,std::unique_ptr<mlir::detail::AnalysisConcept>,llvm::DenseMap<mlir::TypeID,unsigned int,llvm::DenseMapInfo<mlir::TypeID,void>,llvm::detail::DenseMapPair<mlir::TypeID,unsigned int>>,llvm::SmallVector<std::pair<mlir::TypeID,std::unique_ptr<mlir::detail::AnalysisConcept>>,0u>>::try_emplace<std::unique_ptr<mlir::detail::AnalysisConcept>>(uint64_t a1, double *a2, uint64_t *a3)
{
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  _QWORD *v16;
  uint64_t v17;
  unsigned int v18;
  double *v19;
  _QWORD *v20;
  int v21;
  BOOL v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  double *v31;
  uint64_t v32;
  char *v33;
  unint64_t v34;
  double *v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  double *v44;
  const double *v45;
  const double *v46;
  uint64_t v47;
  int v48;
  BOOL v49;
  unsigned int v50;
  char **v51;
  unint64_t v52;
  float64x2x2_t v53;

  v6 = *(_QWORD *)a2;
  v7 = *(_DWORD *)(a1 + 16);
  if (!v7)
    goto LABEL_25;
  v8 = *(_QWORD *)a1;
  v9 = ((v6 >> 4) ^ (v6 >> 9)) & (v7 - 1);
  v10 = (_QWORD *)(*(_QWORD *)a1 + 16 * v9);
  v11 = *v10;
  if (*v10 == v6)
    return *(_QWORD *)(a1 + 24) + 16 * *(unsigned int *)(v8 + 16 * v9 + 8);
  v20 = 0;
  v21 = 1;
  while (v11 != -4096)
  {
    if (v20)
      v22 = 0;
    else
      v22 = v11 == -8192;
    if (v22)
      v20 = v10;
    v23 = v9 + v21++;
    v9 = v23 & (v7 - 1);
    v10 = (_QWORD *)(v8 + 16 * v9);
    v11 = *v10;
    if (*v10 == v6)
      return *(_QWORD *)(a1 + 24) + 16 * *(unsigned int *)(v8 + 16 * v9 + 8);
  }
  v24 = (uint64_t)(v20 ? v20 : v10);
  v25 = *(_DWORD *)(a1 + 8);
  if (4 * v25 + 4 < 3 * v7)
  {
    if (v7 + ~v25 - *(_DWORD *)(a1 + 12) > v7 >> 3)
    {
LABEL_6:
      v13 = *(_QWORD *)v24;
      goto LABEL_7;
    }
  }
  else
  {
LABEL_25:
    v7 *= 2;
  }
  llvm::DenseMap<void const*,unsigned int,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseMapPair<void const*,unsigned int>>::grow(a1, v7);
  v26 = *(_DWORD *)(a1 + 16) - 1;
  v27 = v26 & ((v6 >> 4) ^ (v6 >> 9));
  v24 = *(_QWORD *)a1 + 16 * v27;
  v28 = *(_QWORD *)v24;
  if (*(_QWORD *)v24 != v6)
  {
    v47 = 0;
    v48 = 1;
    while (v28 != -4096)
    {
      if (v47)
        v49 = 0;
      else
        v49 = v28 == -8192;
      if (v49)
        v47 = v24;
      v50 = v27 + v48++;
      v27 = v50 & v26;
      v24 = *(_QWORD *)a1 + 16 * (v50 & v26);
      v28 = *(_QWORD *)v24;
      v13 = v6;
      if (*(_QWORD *)v24 == v6)
        goto LABEL_7;
    }
    if (v47)
      v24 = v47;
    goto LABEL_6;
  }
  v13 = v6;
LABEL_7:
  ++*(_DWORD *)(a1 + 8);
  if (v13 != -4096)
    --*(_DWORD *)(a1 + 12);
  *(_QWORD *)v24 = v6;
  *(_DWORD *)(v24 + 8) = 0;
  v14 = *(unsigned int *)(a1 + 32);
  v15 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(v24 + 8) = v14;
  if (v14 >= v15)
  {
    v51 = (char **)(a1 + 24);
    v52 = 0;
    v19 = (double *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1 + 24, (void *)(a1 + 40), 0, 16, &v52);
    v29 = *(unsigned int *)(a1 + 32);
    v30 = 16 * v29;
    v31 = &v19[2 * v29];
    *v31 = *a2;
    v32 = *a3;
    *a3 = 0;
    *((_QWORD *)v31 + 1) = v32;
    v33 = *(char **)(a1 + 24);
    if (!(_DWORD)v29)
    {
LABEL_39:
      v40 = v52;
      if (v33 != (char *)(a1 + 40))
        free(v33);
      *(_QWORD *)(a1 + 24) = v19;
      v18 = *(_DWORD *)(a1 + 32) + 1;
      *(_DWORD *)(a1 + 32) = v18;
      *(_DWORD *)(a1 + 36) = v40;
      return (uint64_t)&v19[2 * v18 - 2];
    }
    v34 = (v29 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if (v34 >= 7 && (v19 >= (double *)&v33[v30] || v33 >= (char *)&v19[(unint64_t)v30 / 8]))
    {
      v41 = v34 + 1;
      v42 = (v34 + 1) & 0x1FFFFFFFFFFFFFFELL;
      v35 = &v19[2 * v42];
      v36 = &v33[16 * v42];
      v43 = v42;
      v44 = v19;
      v45 = *(const double **)(a1 + 24);
      v46 = v45;
      do
      {
        v53 = vld2q_f64(v46);
        v46 += 4;
        v45[1] = 0.0;
        v45[3] = 0.0;
        vst2q_f64(v44, v53);
        v44 += 4;
        v45 = v46;
        v43 -= 2;
      }
      while (v43);
      if (v41 == v42)
      {
LABEL_34:
        v38 = (uint64_t)(*v51 - 8);
        do
        {
          v39 = *(_QWORD *)(v38 + v30);
          *(_QWORD *)(v38 + v30) = 0;
          if (v39)
            (*(void (**)(uint64_t))(*(_QWORD *)v39 + 8))(v39);
          v30 -= 16;
        }
        while (v30);
        v33 = *v51;
        goto LABEL_39;
      }
    }
    else
    {
      v35 = v19;
      v36 = *(char **)(a1 + 24);
    }
    do
    {
      *v35 = *(double *)v36;
      v37 = *((_QWORD *)v36 + 1);
      *((_QWORD *)v36 + 1) = 0;
      *((_QWORD *)v35 + 1) = v37;
      v36 += 16;
      v35 += 2;
    }
    while (v36 != &v33[v30]);
    goto LABEL_34;
  }
  v16 = (_QWORD *)(*(_QWORD *)(a1 + 24) + 16 * v14);
  *v16 = *(_QWORD *)a2;
  v17 = *a3;
  *a3 = 0;
  v16[1] = v17;
  v18 = v14 + 1;
  *(_DWORD *)(a1 + 32) = v14 + 1;
  v19 = *(double **)(a1 + 24);
  return (uint64_t)&v19[2 * v18 - 2];
}

void mlir::detail::AnalysisModel<mlir::DominanceInfo>::~AnalysisModel(_QWORD *a1)
{
  *a1 = &unk_24C052070;
  mlir::detail::DominanceInfoBase<false>::~DominanceInfoBase((uint64_t)(a1 + 1));
}

{
  *a1 = &unk_24C052070;
  mlir::detail::DominanceInfoBase<false>::~DominanceInfoBase((uint64_t)(a1 + 1));
}

uint64_t sub_207551478()
{
  uint64_t v0;

  return v0;
}

void sub_2075514AC()
{
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::detail::AnalysisModel<mlir::DominanceInfo>::invalidate(uint64_t a1, llvm::SmallPtrSetImplBase *a2)
{
  _BOOL4 v3;

  v3 = mlir::detail::PreservedAnalyses::isPreserved<mlir::DominanceInfo>(a2);
  if (!v3)
    mlir::detail::PreservedAnalyses::unpreserve<mlir::DominanceInfo>(a2);
  return !v3;
}

const void **mlir::detail::PreservedAnalyses::unpreserve<mlir::DominanceInfo>(llvm::SmallPtrSetImplBase *this)
{
  unsigned __int8 v2;
  uint64_t v3;
  uint64_t v4;
  const void **result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  const char *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  const char *v20;
  unint64_t v21;

  if ((v2 & 1) == 0
  {
    v20 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DominanceInfo]";
    v21 = 69;
    v13 = llvm::StringRef::find((uint64_t *)&v20, "DesiredTypeName = ", 0x12uLL, 0);
    if (v21 >= v13)
      v14 = v13;
    else
      v14 = v21;
    v15 = &v20[v14];
    v16 = v21 - v14;
    if (v21 - v14 >= 0x12)
      v17 = 18;
    else
      v17 = v21 - v14;
    v18 = v16 - v17;
    if (v18 >= v18 - 1)
      v19 = v18 - 1;
    else
      v19 = v18;
    mlir::detail::TypeIDResolver<mlir::DominanceInfo,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v15[v17], v19);
  }
  v3 = mlir::detail::TypeIDResolver<mlir::DominanceInfo,void>::resolveTypeID(void)::id;
  v4 = *((_QWORD *)this + 1);
  if (v4 == *(_QWORD *)this)
  {
    v8 = *((unsigned int *)this + 5);
    result = (const void **)(v4 + 8 * v8);
    if ((_DWORD)v8)
    {
      v9 = 0;
      v10 = 8 * v8;
      while (*(_QWORD *)(v4 + v9) != mlir::detail::TypeIDResolver<mlir::DominanceInfo,void>::resolveTypeID(void)::id)
      {
        v9 += 8;
        if (v10 == v9)
          goto LABEL_13;
      }
      result = (const void **)(v4 + v9);
    }
LABEL_13:
    v6 = *((_QWORD *)this + 1);
  }
  else
  {
    result = llvm::SmallPtrSetImplBase::FindBucketFor(this, (const void *)mlir::detail::TypeIDResolver<mlir::DominanceInfo,void>::resolveTypeID(void)::id);
    v4 = *(_QWORD *)this;
    v6 = *((_QWORD *)this + 1);
    if (*result != (const void *)v3)
    {
      v7 = 16;
      if (v6 == v4)
        v7 = 20;
      result = (const void **)(v6 + 8 * *(unsigned int *)((char *)this + v7));
    }
  }
  v11 = v6 == v4;
  v12 = 16;
  if (v11)
    v12 = 20;
  if (result != (const void **)(v6 + 8 * *(unsigned int *)((char *)this + v12)))
  {
    *result = (const void *)-2;
    ++*((_DWORD *)this + 6);
  }
  return result;
}

BOOL mlir::detail::PreservedAnalyses::isPreserved<mlir::DominanceInfo>(llvm::SmallPtrSetImplBase *this)
{
  unsigned __int8 v2;
  uint64_t v3;
  uint64_t v4;
  const void **BucketFor;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  unint64_t v14;
  unint64_t v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  const char *v21;
  unint64_t v22;

  if ((v2 & 1) == 0
  {
    v21 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DominanceInfo]";
    v22 = 69;
    v14 = llvm::StringRef::find((uint64_t *)&v21, "DesiredTypeName = ", 0x12uLL, 0);
    if (v22 >= v14)
      v15 = v14;
    else
      v15 = v22;
    v16 = &v21[v15];
    v17 = v22 - v15;
    if (v22 - v15 >= 0x12)
      v18 = 18;
    else
      v18 = v22 - v15;
    v19 = v17 - v18;
    if (v19 >= v19 - 1)
      v20 = v19 - 1;
    else
      v20 = v19;
    mlir::detail::TypeIDResolver<mlir::DominanceInfo,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v16[v18], v20);
  }
  v3 = mlir::detail::TypeIDResolver<mlir::DominanceInfo,void>::resolveTypeID(void)::id;
  v4 = *((_QWORD *)this + 1);
  if (v4 == *(_QWORD *)this)
  {
    v8 = *((unsigned int *)this + 5);
    BucketFor = (const void **)(v4 + 8 * v8);
    if ((_DWORD)v8)
    {
      v9 = 0;
      v10 = 8 * v8;
      while (*(_QWORD *)(v4 + v9) != mlir::detail::TypeIDResolver<mlir::DominanceInfo,void>::resolveTypeID(void)::id)
      {
        v9 += 8;
        if (v10 == v9)
          goto LABEL_13;
      }
      BucketFor = (const void **)(v4 + v9);
    }
LABEL_13:
    v6 = *((_QWORD *)this + 1);
  }
  else
  {
    BucketFor = llvm::SmallPtrSetImplBase::FindBucketFor(this, (const void *)mlir::detail::TypeIDResolver<mlir::DominanceInfo,void>::resolveTypeID(void)::id);
    v4 = *(_QWORD *)this;
    v6 = *((_QWORD *)this + 1);
    if (*BucketFor != (const void *)v3)
    {
      v7 = 16;
      if (v6 == v4)
        v7 = 20;
      BucketFor = (const void **)(v6 + 8 * *(unsigned int *)((char *)this + v7));
    }
  }
  v11 = v6 == v4;
  v12 = 16;
  if (v11)
    v12 = 20;
  return BucketFor != (const void **)(v6 + 8 * *(unsigned int *)((char *)this + v12));
}

const void **mlir::detail::PreservedAnalyses::preserveAll(const void **this)
{
  unsigned __int8 v1;
  _QWORD *v2;
  const void *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  int v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  const char *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  const void **v18;
  const char *v19;
  unint64_t v20;

  v2 = &unk_25451B000;
  if ((v1 & 1) == 0)
  {
    v18 = this;
    v2 = (_QWORD *)&unk_25451B000;
    v10 = v9;
    this = v18;
    if (v10)
    {
      v19 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::detail::PreservedAnalyses::AllAnalysesType]";
      v20 = 98;
      v11 = llvm::StringRef::find((uint64_t *)&v19, "DesiredTypeName = ", 0x12uLL, 0);
      if (v20 >= v11)
        v12 = v11;
      else
        v12 = v20;
      v13 = &v19[v12];
      v14 = v20 - v12;
      if (v20 - v12 >= 0x12)
        v15 = 18;
      else
        v15 = v20 - v12;
      v16 = v14 - v15;
      if (v16 >= v16 - 1)
        v17 = v16 - 1;
      else
        v17 = v16;
      mlir::detail::TypeIDResolver<mlir::detail::PreservedAnalyses::AllAnalysesType,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v13[v15], v17);
      v2 = (_QWORD *)&unk_25451B000;
      this = v18;
    }
  }
  v3 = (const void *)v2[324];
  v4 = this[1];
  if (v4 != *this)
    return llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)this, v3);
  v5 = *((unsigned int *)this + 5);
  if (!(_DWORD)v5)
  {
LABEL_13:
    if (v5 < *((_DWORD *)this + 4))
    {
      *((_DWORD *)this + 5) = v5 + 1;
      v4[v5] = v3;
      return this;
    }
    return llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)this, v3);
  }
  v6 = 0;
  v7 = 8 * v5;
  v8 = this[1];
  while ((const void *)*v8 != v3)
  {
    if (*v8 == -2)
      v6 = v8;
    ++v8;
    v7 -= 8;
    if (!v7)
    {
      if (!v6)
        goto LABEL_13;
      *v6 = v3;
      --*((_DWORD *)this + 6);
      return this;
    }
  }
  return this;
}

const void **mlir::detail::PreservedAnalyses::preserve<mlir::DominanceInfo>(const void **result)
{
  unsigned __int8 v1;
  uint64_t *v2;
  const void *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  int v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  const char *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  const void **v18;
  const char *v19;
  unint64_t v20;

  v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v18 = result;
    v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v10 = v9;
    result = v18;
    if (v10)
    {
      v19 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DominanceInfo]";
      v20 = 69;
      v11 = llvm::StringRef::find((uint64_t *)&v19, "DesiredTypeName = ", 0x12uLL, 0);
      if (v20 >= v11)
        v12 = v11;
      else
        v12 = v20;
      v13 = &v19[v12];
      v14 = v20 - v12;
      if (v20 - v12 >= 0x12)
        v15 = 18;
      else
        v15 = v20 - v12;
      v16 = v14 - v15;
      if (v16 >= v16 - 1)
        v17 = v16 - 1;
      else
        v17 = v16;
      mlir::detail::TypeIDResolver<mlir::DominanceInfo,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v13[v15], v17);
      v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      result = v18;
    }
  }
  v3 = (const void *)v2[250];
  v4 = result[1];
  if (v4 != *result)
    return llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)result, v3);
  v5 = *((unsigned int *)result + 5);
  if (!(_DWORD)v5)
  {
LABEL_13:
    if (v5 < *((_DWORD *)result + 4))
    {
      *((_DWORD *)result + 5) = v5 + 1;
      v4[v5] = v3;
      return result;
    }
    return llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)result, v3);
  }
  v6 = 0;
  v7 = 8 * v5;
  v8 = result[1];
  while ((const void *)*v8 != v3)
  {
    if (*v8 == -2)
      v6 = v8;
    ++v8;
    v7 -= 8;
    if (!v7)
    {
      if (!v6)
        goto LABEL_13;
      *v6 = v3;
      --*((_DWORD *)result + 6);
      return result;
    }
  }
  return result;
}

const void **mlir::detail::PreservedAnalyses::preserve<mlir::PostDominanceInfo>(const void **result)
{
  unsigned __int8 v1;
  uint64_t *v2;
  const void *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  int v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  const char *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  const void **v18;
  const char *v19;
  unint64_t v20;

  v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v18 = result;
    v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v10 = v9;
    result = v18;
    if (v10)
    {
      v19 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::PostDominanceInfo]";
      v20 = 73;
      v11 = llvm::StringRef::find((uint64_t *)&v19, "DesiredTypeName = ", 0x12uLL, 0);
      if (v20 >= v11)
        v12 = v11;
      else
        v12 = v20;
      v13 = &v19[v12];
      v14 = v20 - v12;
      if (v20 - v12 >= 0x12)
        v15 = 18;
      else
        v15 = v20 - v12;
      v16 = v14 - v15;
      if (v16 >= v16 - 1)
        v17 = v16 - 1;
      else
        v17 = v16;
      mlir::detail::TypeIDResolver<mlir::PostDominanceInfo,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v13[v15], v17);
      v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      result = v18;
    }
  }
  v3 = (const void *)v2[252];
  v4 = result[1];
  if (v4 != *result)
    return llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)result, v3);
  v5 = *((unsigned int *)result + 5);
  if (!(_DWORD)v5)
  {
LABEL_13:
    if (v5 < *((_DWORD *)result + 4))
    {
      *((_DWORD *)result + 5) = v5 + 1;
      v4[v5] = v3;
      return result;
    }
    return llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)result, v3);
  }
  v6 = 0;
  v7 = 8 * v5;
  v8 = result[1];
  while ((const void *)*v8 != v3)
  {
    if (*v8 == -2)
      v6 = v8;
    ++v8;
    v7 -= 8;
    if (!v7)
    {
      if (!v6)
        goto LABEL_13;
      *v6 = v3;
      --*((_DWORD *)result + 6);
      return result;
    }
  }
  return result;
}

void `anonymous namespace'::OperationTransactionState::resetOperation(_anonymous_namespace_::OperationTransactionState *this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(*(_QWORD *)this + 24) = *((_QWORD *)this + 1);
  mlir::Operation::setAttrs(*(_QWORD *)this, *((_QWORD *)this + 2));
  v2 = *(uint64_t **)this;
  mlir::ValueRange::ValueRange((unint64_t *)&v7, *((_QWORD *)this + 3), *((unsigned int *)this + 8));
  mlir::Operation::setOperands(v2, v7, v8);
  v3 = *((unsigned int *)this + 28);
  if ((_DWORD)v3)
  {
    v4 = 0;
    v5 = *((_QWORD *)this + 13);
    v6 = 8 * v3;
    do
    {
      mlir::Operation::setSuccessor(*(mlir::Operation **)this, *(mlir::Block **)(v5 + 8 * v4), v4);
      ++v4;
      v6 -= 8;
    }
    while (v6);
  }
}

void mlir::detail::ConversionPatternRewriterImpl::undoBlockActions(mlir::detail::ConversionPatternRewriterImpl *this, unsigned int a2)
{
  unsigned int v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t **v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  ZinIrHalH13g *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t *v22;
  _QWORD *v23;
  ZinIrHalH13g *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t *v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  unint64_t Parent;
  uint64_t v40;
  uint64_t *v41;
  uint64_t *v42;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  ZinIrHalH13g *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  ZinIrHalH13g *v60;
  int v61;
  int v62;
  unsigned int *v63;
  uint64_t v64;
  ZinIrHalH13g *v65;
  uint64_t v66;
  _QWORD **v68;
  _QWORD *v69;
  _QWORD *v70;
  uint64_t *v71;
  uint64_t *v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t *v75;
  uint64_t *v76;
  uint64_t *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unsigned int v81;
  _QWORD *v82;
  unint64_t v83;
  char *v85;

  v2 = *((_DWORD *)this + 106);
  if (v2 != a2)
  {
    v82 = (_QWORD *)((char *)this + 416);
    v83 = a2;
    v4 = *((_QWORD *)this + 52);
    v5 = v4 + 40 * a2;
    v6 = v4 + 40 * v2;
    v85 = (char *)this + 104;
    v7 = v6;
    do
    {
      v15 = *(_DWORD *)(v7 - 40);
      v7 -= 40;
      switch(v15)
      {
        case 0:
          v16 = *(_QWORD *)(v6 - 32);
          v17 = v16 + 32;
          if (*(_QWORD *)(v16 + 32) != v16 + 32)
          {
            do
            {
              ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v16 + 40));
              v19 = (ZinIrHalH13g *)v18;
              llvm::ilist_traits<mlir::Operation>::removeNodeFromList(v17, v18);
              ZinIrHalH13g::~ZinIrHalH13g(v19);
              v21 = *v20;
              v22 = (uint64_t *)v20[1];
              *v22 = *v20;
              *(_QWORD *)(v21 + 8) = v22;
              *v20 = 0;
              v20[1] = 0;
            }
            while (*(_QWORD *)(v16 + 32) != v17);
            v16 = *(_QWORD *)(v6 - 32);
          }
          v23 = (_QWORD *)v16;
          goto LABEL_35;
        case 1:
          v8 = *(_QWORD *)(v6 - 24);
          v9 = *(_QWORD *)(v6 - 16);
          v10 = *(_QWORD *)(v6 - 32);
          if (v9)
            v11 = (uint64_t **)(v9 + 16);
          else
            v11 = (uint64_t **)(v8 + 8);
          v12 = *v11;
          llvm::ilist_traits<mlir::Block>::addNodeToList(v8, *(_QWORD *)(v6 - 32));
          v13 = *v12;
          *(_QWORD *)(v10 + 8) = *v12;
          *(_QWORD *)(v10 + 16) = v12;
          v14 = v10 + 8;
          *(_QWORD *)(v13 + 8) = v14;
          *v12 = v14;
          goto LABEL_7;
        case 2:
          v24 = *(ZinIrHalH13g **)(v6 - 16);
          if (v24)
          {
            v26 = *(_QWORD *)(v6 - 32);
            v25 = *(_QWORD *)(v6 - 24);
            v27 = *(uint64_t **)(v25 + 40);
            ZinIrHalH13g::~ZinIrHalH13g(v24);
            v29 = v28;
            ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v6 - 8));
            v31 = *(uint64_t **)(v30 + 8);
            v32 = v29 == v31 || v27 == v31;
            if (!v32)
            {
              llvm::ilist_traits<mlir::Operation>::transferNodesFromList(v25 + 32, v26 + 32, (uint64_t)v29, (uint64_t)v31);
              v33 = *v31;
              v34 = *v29;
              *(_QWORD *)(v34 + 8) = v31;
              *v31 = v34;
              v35 = *v27;
              *(_QWORD *)(v33 + 8) = v27;
              *v29 = v35;
              *(_QWORD *)(v35 + 8) = v29;
              *v27 = v33;
            }
          }
          goto LABEL_7;
        case 3:
          v37 = *(_QWORD *)(v6 - 24);
          v36 = *(_QWORD *)(v6 - 16);
          v38 = (uint64_t *)v37;
          if (v36)
            v38 = *(uint64_t **)(v36 + 16);
          Parent = mlir::Block::getParent(*(mlir::Block **)(v6 - 32));
          v40 = *(_QWORD *)(v6 - 32);
          if (v40)
            v41 = (uint64_t *)(v40 + 8);
          else
            v41 = 0;
          v42 = (uint64_t *)v41[1];
          if (v41 != v38 && v42 != v38)
          {
            llvm::ilist_traits<mlir::Block>::transferNodesFromList(v37, Parent, (uint64_t)v41, v41[1]);
            if (v42 != v41)
            {
              v44 = *v42;
              v45 = *v41;
              *(_QWORD *)(v45 + 8) = v42;
              *v42 = v45;
              v46 = *v38;
              *(_QWORD *)(v44 + 8) = v38;
              *v41 = v46;
              *(_QWORD *)(v46 + 8) = v41;
              *v38 = v44;
            }
          }
          goto LABEL_7;
        case 4:
          v47 = *(_QWORD *)(v6 - 32);
          v48 = (uint64_t *)(v47 + 32);
          if (*(_QWORD *)(v47 + 32) != v47 + 32)
          {
            v49 = *(_QWORD *)(v6 - 24);
            if (v49 != v47)
            {
              v50 = (uint64_t *)(v49 + 32);
              v51 = *(uint64_t **)(v47 + 40);
              llvm::ilist_traits<mlir::Operation>::transferNodesFromList(v49 + 32, (uint64_t)v48, (uint64_t)v51, (uint64_t)v48);
              if (v51 != v48)
              {
                v52 = *v48;
                v53 = *v51;
                *(_QWORD *)(v53 + 8) = v48;
                *v48 = v53;
                v54 = *v50;
                *(_QWORD *)(v52 + 8) = v50;
                *v51 = v54;
                *(_QWORD *)(v54 + 8) = v51;
                *v50 = v52;
              }
            }
          }
          v23 = *(_QWORD **)(v6 - 32);
LABEL_35:
          mlir::Block::dropAllDefinedValueUses(v23);
          mlir::Block::erase(*(mlir::Block **)(v6 - 32));
        case 5:
          v55 = *(ZinIrHalH13g **)(v6 - 32);
          v56 = *((_QWORD *)this + 9);
          v57 = *((unsigned int *)this + 22);
          if (!(_DWORD)v57)
            goto LABEL_42;
          LODWORD(v58) = ((v55 >> 4) ^ (v55 >> 9)) & (v57 - 1);
          v59 = (_QWORD *)(v56 + 16 * v58);
          v60 = (ZinIrHalH13g *)*v59;
          if ((ZinIrHalH13g *)*v59 == v55)
            goto LABEL_43;
          v61 = 1;
          break;
        default:
          goto LABEL_7;
      }
      while (v60 != (ZinIrHalH13g *)-4096)
      {
        v62 = v58 + v61++;
        v58 = v62 & (v57 - 1);
        v60 = *(ZinIrHalH13g **)(v56 + 16 * v58);
        if (v60 == v55)
        {
          v59 = (_QWORD *)(v56 + 16 * v58);
          goto LABEL_43;
        }
      }
LABEL_42:
      v59 = (_QWORD *)(v56 + 16 * v57);
LABEL_43:
      v32 = v59 == (_QWORD *)(v56 + 16 * v57);
      v63 = (unsigned int *)v85;
      if (!v32)
        v63 = (unsigned int *)(v59 + 1);
      v64 = *v63;
      if ((_DWORD)v64 != *((_DWORD *)this + 26))
      {
        v65 = *(ZinIrHalH13g **)(*((_QWORD *)this + 12) + (v64 << 6) + 8);
        v66 = ((*((_QWORD *)v55 + 7) - *((_QWORD *)v55 + 6)) >> 3) - 1;
        if ((int)v66 >= 0)
        {
          do
          {
            v68 = *(_QWORD ***)(*((_QWORD *)v55 + 6) + 8 * v66);
            while (1)
            {
              v69 = *v68;
              if (!*v68)
                break;
              v70 = (_QWORD *)v69[1];
              if (v70)
              {
                *v70 = *v69;
                if (*v69)
                  *(_QWORD *)(*v69 + 8) = v69[1];
              }
              *v69 = 0;
              v69[1] = 0;
              v69[3] = 0;
            }
          }
          while (v66-- > 0);
        }
        while (1)
        {
          v71 = *(uint64_t **)v55;
          if (!*(_QWORD *)v55)
            break;
          v72 = (uint64_t *)v71[1];
          if (v72)
          {
            *v72 = *v71;
            if (*v71)
              *(_QWORD *)(*v71 + 8) = v71[1];
          }
          v71[3] = (uint64_t)v65;
          ZinIrHalH13g::~ZinIrHalH13g(v65);
          v74 = *v73;
          *v71 = *v73;
          v71[1] = (uint64_t)v73;
          if (v74)
            *(_QWORD *)(v74 + 8) = v71;
          *v73 = (uint64_t)v71;
        }
        v75 = (uint64_t *)((char *)v55 + 32);
        if (*((ZinIrHalH13g **)v55 + 4) != (ZinIrHalH13g *)((char *)v55 + 32) && v65 != v55)
        {
          v76 = (uint64_t *)((char *)v65 + 32);
          v77 = (uint64_t *)*((_QWORD *)v55 + 5);
          llvm::ilist_traits<mlir::Operation>::transferNodesFromList((uint64_t)v65 + 32, (uint64_t)v55 + 32, (uint64_t)v77, (uint64_t)v55 + 32);
          if (v77 != v75)
          {
            v78 = *v75;
            v79 = *v77;
            *(_QWORD *)(v79 + 8) = v75;
            *v75 = v79;
            v80 = *v76;
            *(_QWORD *)(v78 + 8) = v76;
            *v77 = v80;
            *(_QWORD *)(v80 + 8) = v77;
            *v76 = v78;
          }
        }
        mlir::Block::moveBefore(v65, v55);
        mlir::Block::erase(v55);
      }
LABEL_7:
      v6 = v7;
    }
    while (v7 != v5);
    v81 = *((_DWORD *)this + 106);
    if (v81 != a2)
    {
      if (v81 <= a2)
      {
        if (*((_DWORD *)this + 107) < a2)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v82, (char *)this + 432, v83, 40);
          v81 = *((_DWORD *)this + 106);
        }
        if (v81 != a2)
          bzero((void *)(*v82 + 40 * v81), 40 * ((40 * (v83 - v81) - 40) / 0x28) + 40);
      }
      *((_DWORD *)this + 106) = a2;
    }
  }
}

void detachNestedAndErase(mlir::Operation *this)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t i;
  uint64_t v6;
  uint64_t v7;
  ZinIrHalH13g *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  char *v13;
  uint64_t j;
  _QWORD **NextResultAtOffset;
  _QWORD *v16;
  _QWORD *v17;

  v2 = *((unsigned int *)this + 11);
  if ((v2 & 0x7FFFFF) != 0)
  {
    v3 = (((unint64_t)this + 16 * ((v2 >> 23) & 1) + ((v2 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
    v4 = v3 + 24 * (v2 & 0x7FFFFF);
    do
    {
      for (i = *(_QWORD *)(v3 + 8); i != v3; i = *(_QWORD *)(i + 8))
      {
        if (i)
          v6 = i - 8;
        else
          v6 = 0;
        for (; *(_QWORD *)(v6 + 32) != v6 + 32; v9[1] = 0)
        {
          ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v6 + 40));
          v8 = (ZinIrHalH13g *)v7;
          llvm::ilist_traits<mlir::Operation>::removeNodeFromList(v6 + 32, v7);
          ZinIrHalH13g::~ZinIrHalH13g(v8);
          v10 = *v9;
          v11 = (uint64_t *)v9[1];
          *v11 = *v9;
          *(_QWORD *)(v10 + 8) = v11;
          *v9 = 0;
        }
        mlir::Block::dropAllDefinedValueUses((_QWORD *)v6);
      }
      v3 += 24;
    }
    while (v3 != v4);
  }
  v12 = *((unsigned int *)this + 9);
  if ((_DWORD)v12)
    v13 = (char *)this - 16;
  else
    v13 = 0;
  if ((_DWORD)v12)
  {
    for (j = 0; j != v12; ++j)
    {
      NextResultAtOffset = (_QWORD **)mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v13, j);
      while (1)
      {
        v16 = *NextResultAtOffset;
        if (!*NextResultAtOffset)
          break;
        v17 = (_QWORD *)v16[1];
        if (v17)
        {
          *v17 = *v16;
          if (*v16)
            *(_QWORD *)(*v16 + 8) = v16[1];
        }
        *v16 = 0;
        v16[1] = 0;
        v16[3] = 0;
      }
    }
  }
  mlir::Operation::erase(this);
}

void mlir::detail::ConversionPatternRewriterImpl::applyRewrites(mlir::detail::ConversionPatternRewriterImpl *this)
{
  uint64_t v2;
  mlir::Operation **v3;
  mlir::Operation *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t NextResultAtOffset;
  _QWORD **v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unsigned __int8 v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  int v22;
  int v23;
  int v24;
  unint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  unsigned __int8 v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  int v33;
  int v34;
  int v35;
  unint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t ***v41;
  uint64_t ***v42;
  uint64_t Owner;
  uint64_t *v44;
  uint64_t *v45;
  uint64_t **v46;
  uint64_t *v47;
  uint64_t *v48;
  uint64_t v49;
  unsigned int v50;
  mlir::Operation **v51;
  mlir::Operation **v52;
  mlir::Operation *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t i;
  _QWORD **v57;
  _QWORD *v58;
  _QWORD *v59;
  uint64_t v60;
  mlir::Operation **v61;
  mlir::Operation **v62;
  mlir::Operation *v63;
  unsigned int *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t j;
  _QWORD **v69;
  _QWORD *v70;
  _QWORD *v71;
  uint64_t v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  mlir::detail::OpResultImpl *v79;
  uint64_t v80;
  _QWORD *v81;
  _QWORD *v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  _QWORD *v86;
  unint64_t v87;
  unsigned __int8 v88;
  unint64_t v89;
  unint64_t v90;
  _QWORD *v91;
  _QWORD *v92;
  int v93;
  int v94;
  int v95;
  unint64_t v96;
  uint64_t v97;
  uint64_t v98;
  unint64_t v99;
  unint64_t v100;
  _QWORD *v101;
  unint64_t v102;
  unsigned __int8 v103;
  unint64_t v104;
  unint64_t v105;
  _QWORD *v106;
  _QWORD *v107;
  int v108;
  int v109;
  int v110;
  unint64_t v111;
  unint64_t v112;
  unsigned __int8 v113;
  unint64_t v114;
  unint64_t v115;
  _QWORD *v116;
  _QWORD *v117;
  int v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  int v122;
  unint64_t v123;
  _QWORD *v124;
  _QWORD *v125;
  uint64_t v126;
  _QWORD *v127;
  unsigned __int8 v128;
  unint64_t v129;
  unint64_t v130;
  _QWORD *v131;
  _QWORD *v132;
  int v133;
  int v134;
  uint64_t v135;
  int v136;
  unint64_t v137;
  _QWORD *v138;
  _QWORD *v139;
  uint64_t v140;
  uint64_t v141;
  mlir::Block **v142;
  uint64_t v143;
  _anonymous_namespace_::ArgConverter *v144;
  mlir::Operation **v145;
  uint64_t v146;
  uint64_t v147;
  mlir::Operation **v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  mlir::detail::OpResultImpl *v152;
  mlir::detail::OpResultImpl *v153;
  mlir::detail::OpResultImpl *v154;
  mlir::detail::OpResultImpl *v155;
  mlir::detail::OpResultImpl *v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  _QWORD v162[2];
  uint64_t v163;
  uint64_t v164;
  uint64_t **v165;

  v2 = *((unsigned int *)this + 90);
  if ((_DWORD)v2)
  {
    v3 = (mlir::Operation **)*((_QWORD *)this + 44);
    v144 = (mlir::detail::ConversionPatternRewriterImpl *)((char *)this + 72);
    v145 = &v3[2 * v2];
    while (1)
    {
      v4 = *v3;
      v5 = *((_DWORD *)*v3 + 9);
      v6 = (uint64_t)*v3 - 16;
      if (!v5)
        v6 = 0;
      v152 = (mlir::detail::OpResultImpl *)v6;
      v157 = *((unsigned int *)*v3 + 9);
      if (v5)
        break;
LABEL_60:
      if ((*((_DWORD *)v4 + 11) & 0x7FFFFF) != 0)
      v3 += 2;
      if (v3 == v145)
        goto LABEL_62;
    }
    v148 = v3;
    v7 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v152, v7);
      v9 = (_QWORD **)NextResultAtOffset;
      v10 = *(_QWORD *)this;
      LODWORD(v11) = *((_DWORD *)this + 4);
      v12 = *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
      if (v12)
      {
        v13 = 0;
        v14 = (_QWORD *)NextResultAtOffset;
        v15 = &unk_254519000;
        do
        {
          v16 = (unint64_t)v14;
          if ((v14[1] & 0xFFFFFFFFFFFFFFF8) == v12)
            v13 = (unint64_t)v14;
          if (!(_DWORD)v11)
            break;
          if ((v17 & 1) == 0)
          {
            v15 = &unk_254519000;
            if (v24)
            {
              v25 = llvm::hashing::detail::fixed_seed_override;
              if (!llvm::hashing::detail::fixed_seed_override)
                v25 = 0xFF51AFD7ED558CCDLL;
              llvm::hashing::detail::get_execution_seed(void)::seed = v25;
              v15 = (_QWORD *)&unk_254519000;
            }
          }
          v18 = 0x9DDFEA08EB382D69 * ((v15[373] + 8 * v16) ^ HIDWORD(v16));
          v19 = 0x9DDFEA08EB382D69 * (HIDWORD(v16) ^ (v18 >> 47) ^ v18);
          LODWORD(v19) = (-348639895 * ((v19 >> 47) ^ v19)) & (v11 - 1);
          v20 = (_QWORD *)(v10 + 16 * v19);
          v21 = (_QWORD *)*v20;
          if (v16 != *v20)
          {
            v22 = 1;
            while (v21 != (_QWORD *)-4096)
            {
              v23 = v19 + v22++;
              v19 = v23 & (v11 - 1);
              v21 = *(_QWORD **)(v10 + 16 * v19);
              if ((_QWORD *)v16 == v21)
              {
                v20 = (_QWORD *)(v10 + 16 * v19);
                v10 = *(_QWORD *)this;
                v11 = *((unsigned int *)this + 4);
                if (v20 != (_QWORD *)(*(_QWORD *)this + 16 * v11))
                  goto LABEL_17;
                goto LABEL_28;
              }
            }
            break;
          }
          v10 = *(_QWORD *)this;
          v11 = *((unsigned int *)this + 4);
          if (v20 == (_QWORD *)(*(_QWORD *)this + 16 * v11))
            break;
LABEL_17:
          v14 = (_QWORD *)v20[1];
        }
        while (v14);
LABEL_28:
        if (!v13)
          v13 = v16;
      }
      else
      {
        v26 = (_QWORD *)NextResultAtOffset;
        v27 = &unk_254519000;
        do
        {
          v13 = (unint64_t)v26;
          if (!(_DWORD)v11)
            break;
          if ((v28 & 1) == 0)
          {
            v27 = &unk_254519000;
            if (v35)
            {
              v36 = llvm::hashing::detail::fixed_seed_override;
              if (!llvm::hashing::detail::fixed_seed_override)
                v36 = 0xFF51AFD7ED558CCDLL;
              llvm::hashing::detail::get_execution_seed(void)::seed = v36;
              v27 = (_QWORD *)&unk_254519000;
            }
          }
          v29 = 0x9DDFEA08EB382D69 * ((v27[373] + 8 * v13) ^ HIDWORD(v13));
          v30 = 0x9DDFEA08EB382D69 * (HIDWORD(v13) ^ (v29 >> 47) ^ v29);
          LODWORD(v30) = (-348639895 * ((v30 >> 47) ^ v30)) & (v11 - 1);
          v31 = (_QWORD *)(v10 + 16 * v30);
          v32 = (_QWORD *)*v31;
          if (v13 != *v31)
          {
            v33 = 1;
            while (v32 != (_QWORD *)-4096)
            {
              v34 = v30 + v33++;
              v30 = v34 & (v11 - 1);
              v32 = *(_QWORD **)(v10 + 16 * v30);
              if ((_QWORD *)v13 == v32)
              {
                v31 = (_QWORD *)(v10 + 16 * v30);
                v10 = *(_QWORD *)this;
                v11 = *((unsigned int *)this + 4);
                if (v31 != (_QWORD *)(*(_QWORD *)this + 16 * v11))
                  goto LABEL_39;
                goto LABEL_30;
              }
            }
            break;
          }
          v10 = *(_QWORD *)this;
          v11 = *((unsigned int *)this + 4);
          if (v31 == (_QWORD *)(*(_QWORD *)this + 16 * v11))
            break;
LABEL_39:
          v26 = (_QWORD *)v31[1];
        }
        while (v26);
      }
LABEL_30:
      if ((_QWORD **)v13 == v9)
        goto LABEL_8;
      if (v12)
      {
        if ((*(_QWORD *)(v13 + 8) & 0xFFFFFFFFFFFFFFF8) == v12)
          goto LABEL_53;
      }
      else if (v13)
      {
LABEL_53:
        while (1)
        {
          v37 = *v9;
          if (!*v9)
            break;
          v38 = (_QWORD *)v37[1];
          if (v38)
          {
            *v38 = *v37;
            if (*v37)
              *(_QWORD *)(*v37 + 8) = v37[1];
          }
          v37[3] = v13;
          v37[1] = v13;
          v39 = *(_QWORD *)v13;
          *v37 = *(_QWORD *)v13;
          if (v39)
            *(_QWORD *)(v39 + 8) = v37;
          *(_QWORD *)v13 = v37;
        }
      }
LABEL_8:
      if (++v7 == v157)
      {
        v3 = v148;
        v4 = *v148;
        goto LABEL_60;
      }
    }
  }
LABEL_62:
  v40 = *((unsigned int *)this + 94);
  if ((_DWORD)v40)
  {
    v41 = (uint64_t ***)*((_QWORD *)this + 46);
    v42 = &v41[v40];
    do
    {
      v165 = *v41;
      if (v44)
      {
        v45 = v44;
        if ((~*((_DWORD *)v44 + 2) & 7) != 0)
        {
          v164 = 0;
          Owner = mlir::detail::OpResultImpl::getOwner((mlir::detail::OpResultImpl *)v44);
          v163 = *(_QWORD *)(Owner + 16);
          v164 = Owner;
          v162[0] = &v163;
          v162[1] = &v164;
          mlir::Value::replaceUsesWithIf(&v165, v45, (uint64_t (*)(uint64_t, uint64_t *))llvm::function_ref<BOOL ()(mlir::OpOperand &)>::callback_fn<mlir::detail::ConversionPatternRewriterImpl::applyRewrites(void)::$_0>, (uint64_t)v162);
        }
        else
        {
          v46 = v165;
          while (1)
          {
            v47 = *v46;
            if (!*v46)
              break;
            v48 = (uint64_t *)v47[1];
            if (v48)
            {
              *v48 = *v47;
              if (*v47)
                *(_QWORD *)(*v47 + 8) = v47[1];
            }
            v47[3] = (uint64_t)v44;
            v47[1] = (uint64_t)v44;
            v49 = *v44;
            *v47 = *v44;
            if (v49)
              *(_QWORD *)(v49 + 8) = v47;
            *v44 = (uint64_t)v47;
          }
        }
      }
      ++v41;
    }
    while (v41 != v42);
  }
  v50 = *((_DWORD *)this + 68);
  if (v50)
  {
    v51 = (mlir::Operation **)*((_QWORD *)this + 33);
    v52 = &v51[3 * v50];
    do
    {
      v53 = *v51;
      v54 = *((unsigned int *)*v51 + 9);
      if ((_DWORD)v54)
        v55 = (uint64_t)*v51 - 16;
      else
        v55 = 0;
      if ((_DWORD)v54)
      {
        for (i = 0; i != v54; ++i)
        {
          v57 = (_QWORD **)mlir::detail::OpResultImpl::getNextResultAtOffset(v55, i);
          while (1)
          {
            v58 = *v57;
            if (!*v57)
              break;
            v59 = (_QWORD *)v58[1];
            if (v59)
            {
              *v59 = *v58;
              if (*v58)
                *(_QWORD *)(*v58 + 8) = v58[1];
            }
            *v58 = 0;
            v58[1] = 0;
            v58[3] = 0;
          }
        }
        v53 = *v51;
      }
      mlir::Operation::erase(v53);
      v51 += 3;
    }
    while (v51 != v52);
  }
  v60 = *((unsigned int *)this + 90);
  if ((_DWORD)v60)
  {
    v61 = (mlir::Operation **)*((_QWORD *)this + 44);
    v62 = &v61[2 * v60];
    do
    {
      v64 = (unsigned int *)*(v62 - 2);
      v62 -= 2;
      v63 = (mlir::Operation *)v64;
      v65 = v64[9];
      v66 = (uint64_t)(v64 - 4);
      if ((_DWORD)v65)
        v67 = v66;
      else
        v67 = 0;
      if ((_DWORD)v65)
      {
        for (j = 0; j != v65; ++j)
        {
          v69 = (_QWORD **)mlir::detail::OpResultImpl::getNextResultAtOffset(v67, j);
          while (1)
          {
            v70 = *v69;
            if (!*v69)
              break;
            v71 = (_QWORD *)v70[1];
            if (v71)
            {
              *v71 = *v70;
              if (*v70)
                *(_QWORD *)(*v70 + 8) = v70[1];
            }
            *v70 = 0;
            v70[1] = 0;
            v70[3] = 0;
          }
        }
        v63 = *v62;
      }
      mlir::Operation::erase(v63);
    }
    while (v62 != v61);
  }
  v72 = *((unsigned int *)this + 26);
  v73 = &unk_254519000;
  if ((_DWORD)v72)
  {
    v74 = *((_QWORD *)this + 12);
    v75 = v74 + (v72 << 6);
    while (1)
    {
      v76 = *(_QWORD *)(v74 + 8);
      v77 = *(_QWORD *)(v76 + 56) - *(_QWORD *)(v76 + 48);
      if ((v77 & 0x7FFFFFFF8) != 0)
        break;
LABEL_110:
      v74 += 64;
      if (v74 == v75)
        goto LABEL_210;
    }
    v78 = 0;
    v79 = (mlir::detail::OpResultImpl *)(v77 >> 3);
    while (1)
    {
      v80 = *(_QWORD *)(v74 + 16) + 24 * v78;
      v81 = *(_QWORD **)(*(_QWORD *)(v76 + 48) + 8 * v78);
      if (*(_BYTE *)(v80 + 16))
      {
        if (*v81)
        {
          v82 = *(_QWORD **)(v80 + 8);
          v83 = *(_QWORD *)this;
          LODWORD(v84) = *((_DWORD *)this + 4);
          v85 = v81[1] & 0xFFFFFFFFFFFFFFF8;
          if (v85)
          {
            v86 = 0;
            do
            {
              v87 = (unint64_t)v82;
              if ((v82[1] & 0xFFFFFFFFFFFFFFF8) == v85)
                v86 = v82;
              if (!(_DWORD)v84)
                break;
              if ((v88 & 1) == 0)
              {
                v146 = v75;
                v149 = v74;
                v153 = v79;
                v158 = v76;
                v79 = v153;
                v76 = v158;
                v75 = v146;
                v74 = v149;
                v73 = &unk_254519000;
                if (v95)
                {
                  v96 = llvm::hashing::detail::fixed_seed_override;
                  if (!llvm::hashing::detail::fixed_seed_override)
                    v96 = 0xFF51AFD7ED558CCDLL;
                  llvm::hashing::detail::get_execution_seed(void)::seed = v96;
                  v79 = v153;
                  v76 = v158;
                  v75 = v146;
                  v74 = v149;
                  v73 = (_QWORD *)&unk_254519000;
                }
              }
              v89 = 0x9DDFEA08EB382D69 * ((v73[373] + 8 * v87) ^ HIDWORD(v87));
              v90 = 0x9DDFEA08EB382D69 * (HIDWORD(v87) ^ (v89 >> 47) ^ v89);
              LODWORD(v90) = (-348639895 * ((v90 >> 47) ^ v90)) & (v84 - 1);
              v91 = (_QWORD *)(v83 + 16 * v90);
              v92 = (_QWORD *)*v91;
              if (v87 != *v91)
              {
                v93 = 1;
                while (v92 != (_QWORD *)-4096)
                {
                  v94 = v90 + v93++;
                  v90 = v94 & (v84 - 1);
                  v92 = *(_QWORD **)(v83 + 16 * v90);
                  if ((_QWORD *)v87 == v92)
                  {
                    v91 = (_QWORD *)(v83 + 16 * v90);
                    v83 = *(_QWORD *)this;
                    v84 = *((unsigned int *)this + 4);
                    if (v91 != (_QWORD *)(*(_QWORD *)this + 16 * v84))
                      goto LABEL_124;
                    goto LABEL_154;
                  }
                }
                break;
              }
              v83 = *(_QWORD *)this;
              v84 = *((unsigned int *)this + 4);
              if (v91 == (_QWORD *)(*(_QWORD *)this + 16 * v84))
                break;
LABEL_124:
              v82 = (_QWORD *)v91[1];
            }
            while (v82);
LABEL_154:
            if (v86)
              v112 = (unint64_t)v86;
            else
              v112 = v87;
          }
          else
          {
            do
            {
              v112 = (unint64_t)v82;
              if (!(_DWORD)v84)
                break;
              if ((v113 & 1) == 0)
              {
                v120 = v74;
                v121 = v75;
                v155 = v79;
                v160 = v76;
                v79 = v155;
                v76 = v160;
                v75 = v121;
                v74 = v120;
                v73 = &unk_254519000;
                if (v122)
                {
                  v123 = llvm::hashing::detail::fixed_seed_override;
                  if (!llvm::hashing::detail::fixed_seed_override)
                    v123 = 0xFF51AFD7ED558CCDLL;
                  llvm::hashing::detail::get_execution_seed(void)::seed = v123;
                  v79 = v155;
                  v76 = v160;
                  v75 = v121;
                  v74 = v120;
                  v73 = (_QWORD *)&unk_254519000;
                }
              }
              v114 = 0x9DDFEA08EB382D69 * ((v73[373] + 8 * v112) ^ HIDWORD(v112));
              v115 = 0x9DDFEA08EB382D69 * (HIDWORD(v112) ^ (v114 >> 47) ^ v114);
              LODWORD(v115) = (-348639895 * ((v115 >> 47) ^ v115)) & (v84 - 1);
              v116 = (_QWORD *)(v83 + 16 * v115);
              v117 = (_QWORD *)*v116;
              if (v112 != *v116)
              {
                v118 = 1;
                while (v117 != (_QWORD *)-4096)
                {
                  v119 = v115 + v118++;
                  v115 = v119 & (v84 - 1);
                  v117 = *(_QWORD **)(v83 + 16 * v115);
                  if ((_QWORD *)v112 == v117)
                  {
                    v116 = (_QWORD *)(v83 + 16 * v115);
                    v83 = *(_QWORD *)this;
                    v84 = *((unsigned int *)this + 4);
                    if (v116 != (_QWORD *)(*(_QWORD *)this + 16 * v84))
                      goto LABEL_167;
                    goto LABEL_179;
                  }
                }
                break;
              }
              v83 = *(_QWORD *)this;
              v84 = *((unsigned int *)this + 4);
              if (v116 == (_QWORD *)(*(_QWORD *)this + 16 * v84))
                break;
LABEL_167:
              v82 = (_QWORD *)v116[1];
            }
            while (v82);
          }
LABEL_179:
          while (1)
          {
            v124 = (_QWORD *)*v81;
            if (!*v81)
              break;
            v125 = (_QWORD *)v124[1];
            if (v125)
            {
              *v125 = *v124;
              if (*v124)
                *(_QWORD *)(*v124 + 8) = v124[1];
            }
            v124[3] = v112;
            v124[1] = v112;
            v126 = *(_QWORD *)v112;
            *v124 = *(_QWORD *)v112;
            if (v126)
              *(_QWORD *)(v126 + 8) = v124;
            *(_QWORD *)v112 = v124;
          }
        }
        goto LABEL_113;
      }
      v97 = *(_QWORD *)this;
      LODWORD(v98) = *((_DWORD *)this + 4);
      v99 = v81[1] & 0xFFFFFFFFFFFFFFF8;
      if (v99)
      {
        v100 = 0;
        v101 = *(_QWORD **)(*(_QWORD *)(v76 + 48) + 8 * v78);
        do
        {
          v102 = (unint64_t)v101;
          if ((v101[1] & 0xFFFFFFFFFFFFFFF8) == v99)
            v100 = (unint64_t)v101;
          if (!(_DWORD)v98)
            break;
          if ((v103 & 1) == 0)
          {
            v147 = v75;
            v150 = v74;
            v154 = v79;
            v159 = v76;
            v79 = v154;
            v76 = v159;
            v75 = v147;
            v74 = v150;
            v73 = &unk_254519000;
            if (v110)
            {
              v111 = llvm::hashing::detail::fixed_seed_override;
              if (!llvm::hashing::detail::fixed_seed_override)
                v111 = 0xFF51AFD7ED558CCDLL;
              llvm::hashing::detail::get_execution_seed(void)::seed = v111;
              v79 = v154;
              v76 = v159;
              v75 = v147;
              v74 = v150;
              v73 = (_QWORD *)&unk_254519000;
            }
          }
          v104 = 0x9DDFEA08EB382D69 * ((v73[373] + 8 * v102) ^ HIDWORD(v102));
          v105 = 0x9DDFEA08EB382D69 * (HIDWORD(v102) ^ (v104 >> 47) ^ v104);
          LODWORD(v105) = (-348639895 * ((v105 >> 47) ^ v105)) & (v98 - 1);
          v106 = (_QWORD *)(v97 + 16 * v105);
          v107 = (_QWORD *)*v106;
          if (v102 != *v106)
          {
            v108 = 1;
            while (v107 != (_QWORD *)-4096)
            {
              v109 = v105 + v108++;
              v105 = v109 & (v98 - 1);
              v107 = *(_QWORD **)(v97 + 16 * v105);
              if ((_QWORD *)v102 == v107)
              {
                v106 = (_QWORD *)(v97 + 16 * v105);
                v97 = *(_QWORD *)this;
                v98 = *((unsigned int *)this + 4);
                if (v106 != (_QWORD *)(*(_QWORD *)this + 16 * v98))
                  goto LABEL_143;
                goto LABEL_157;
              }
            }
            break;
          }
          v97 = *(_QWORD *)this;
          v98 = *((unsigned int *)this + 4);
          if (v106 == (_QWORD *)(*(_QWORD *)this + 16 * v98))
            break;
LABEL_143:
          v101 = (_QWORD *)v106[1];
        }
        while (v101);
LABEL_157:
        if (!v100)
          v100 = v102;
      }
      else
      {
        v127 = *(_QWORD **)(*(_QWORD *)(v76 + 48) + 8 * v78);
        do
        {
          v100 = (unint64_t)v127;
          if (!(_DWORD)v98)
            break;
          if ((v128 & 1) == 0)
          {
            v151 = v74;
            v156 = v79;
            v135 = v75;
            v161 = v76;
            v79 = v156;
            v76 = v161;
            v75 = v135;
            v74 = v151;
            v73 = &unk_254519000;
            if (v136)
            {
              v137 = llvm::hashing::detail::fixed_seed_override;
              if (!llvm::hashing::detail::fixed_seed_override)
                v137 = 0xFF51AFD7ED558CCDLL;
              llvm::hashing::detail::get_execution_seed(void)::seed = v137;
              v79 = v156;
              v76 = v161;
              v75 = v135;
              v74 = v151;
              v73 = (_QWORD *)&unk_254519000;
            }
          }
          v129 = 0x9DDFEA08EB382D69 * ((v73[373] + 8 * v100) ^ HIDWORD(v100));
          v130 = 0x9DDFEA08EB382D69 * (HIDWORD(v100) ^ (v129 >> 47) ^ v129);
          LODWORD(v130) = (-348639895 * ((v130 >> 47) ^ v130)) & (v98 - 1);
          v131 = (_QWORD *)(v97 + 16 * v130);
          v132 = (_QWORD *)*v131;
          if (v100 != *v131)
          {
            v133 = 1;
            while (v132 != (_QWORD *)-4096)
            {
              v134 = v130 + v133++;
              v130 = v134 & (v98 - 1);
              v132 = *(_QWORD **)(v97 + 16 * v130);
              if ((_QWORD *)v100 == v132)
              {
                v131 = (_QWORD *)(v97 + 16 * v130);
                v97 = *(_QWORD *)this;
                v98 = *((unsigned int *)this + 4);
                if (v131 != (_QWORD *)(*(_QWORD *)this + 16 * v98))
                  goto LABEL_190;
                goto LABEL_159;
              }
            }
            break;
          }
          v97 = *(_QWORD *)this;
          v98 = *((unsigned int *)this + 4);
          if (v131 == (_QWORD *)(*(_QWORD *)this + 16 * v98))
            break;
LABEL_190:
          v127 = (_QWORD *)v131[1];
        }
        while (v127);
      }
LABEL_159:
      if ((_QWORD *)v100 == v81)
        goto LABEL_113;
      if (v99)
      {
        if ((*(_QWORD *)(v100 + 8) & 0xFFFFFFFFFFFFFFF8) == v99)
          goto LABEL_204;
      }
      else if (v100)
      {
LABEL_204:
        while (1)
        {
          v138 = (_QWORD *)*v81;
          if (!*v81)
            break;
          v139 = (_QWORD *)v138[1];
          if (v139)
          {
            *v139 = *v138;
            if (*v138)
              *(_QWORD *)(*v138 + 8) = v138[1];
          }
          v138[3] = v100;
          v138[1] = v100;
          v140 = *(_QWORD *)v100;
          *v138 = *(_QWORD *)v100;
          if (v140)
            *(_QWORD *)(v140 + 8) = v138;
          *(_QWORD *)v100 = v138;
        }
      }
LABEL_113:
      if ((mlir::detail::OpResultImpl *)++v78 == v79)
        goto LABEL_110;
    }
  }
LABEL_210:
  v141 = *((unsigned int *)this + 106);
  if ((_DWORD)v141)
  {
    v142 = (mlir::Block **)(*((_QWORD *)this + 52) + 8);
    v143 = 40 * v141;
    do
    {
      if (*((_DWORD *)v142 - 2) == 1 && *v142)
      {
        mlir::Block::~Block(*v142);
        MEMORY[0x20BD002F8]();
      }
      v142 += 5;
      v143 -= 40;
    }
    while (v143);
  }
}

unint64_t `anonymous namespace'::ConversionValueMapping::lookupOrNull(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v11;
  uint64_t v12;

  if (a3)
  {
    v6 = 0;
    v7 = a2;
    do
    {
      v8 = v7;
      if ((*(_QWORD *)(v7 + 8) & 0xFFFFFFFFFFFFFFF8) == a3)
        v6 = v7;
      v11 = v7;
      v12 = 0;
      if (!llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a1, &v11, &v12))break;
      if (v12 == *(_QWORD *)a1 + 16 * *(unsigned int *)(a1 + 16))
        break;
      v7 = *(_QWORD *)(v12 + 8);
    }
    while (v7);
    if (!v6)
      v6 = v8;
  }
  else
  {
    v9 = a2;
    do
    {
      v6 = v9;
      v11 = v9;
      v12 = 0;
      if (!llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a1, &v11, &v12))break;
      if (v12 == *(_QWORD *)a1 + 16 * *(unsigned int *)(a1 + 16))
        break;
      v9 = *(_QWORD *)(v12 + 8);
    }
    while (v9);
  }
  if (v6 == a2 || a3 && (*(_QWORD *)(v6 + 8) & 0xFFFFFFFFFFFFFFF8) != a3)
    return 0;
  return v6;
}

void `anonymous namespace'::ArgConverter::notifyOpRemoved(int32x2_t *this, mlir::Operation *a2)
{
  int32x2_t *v2;
  unint64_t v3;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  ZinIrHalH13g *i;
  mlir::Operation *v9;
  int32x2_t v10;
  uint64_t v11;
  uint64_t v12;
  int32x2_t *v13;
  int32x2_t v14;
  int v15;
  int v16;
  int32x2_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD ***v21;
  _QWORD ***v22;
  _QWORD **v23;
  _QWORD *v24;
  _QWORD *v25;
  unsigned int v26;
  uint64_t *v27;
  uint64_t v28;
  _QWORD *v29;
  int32x2_t v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  _QWORD *v36;
  _DWORD *v37;
  void **v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  int32x2_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  int v51;
  int v52;
  unint64_t v53;
  unint64_t v54;

  v2 = this + 4;
  if (this[4].i32[0])
  {
    v3 = *((unsigned int *)a2 + 11);
    if ((v3 & 0x7FFFFF) != 0)
    {
      v5 = (((unint64_t)a2 + 16 * ((v3 >> 23) & 1) + ((v3 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
         + 32 * *((unsigned int *)a2 + 10);
      v53 = v5 + 24 * (v3 & 0x7FFFFF);
      while (1)
      {
        v6 = *(_QWORD *)(v5 + 8);
        v54 = v5;
        if (v6 != v5)
          break;
LABEL_4:
        v5 += 24;
        if (v5 == v53)
          return;
      }
      while (1)
      {
        if (v6)
          v7 = v6 - 8;
        else
          v7 = 0;
        for (i = *(ZinIrHalH13g **)(v7 + 40); i != (ZinIrHalH13g *)(v7 + 32); i = (ZinIrHalH13g *)*((_QWORD *)i + 1))
        {
          ZinIrHalH13g::~ZinIrHalH13g(i);
          if ((*((_DWORD *)v9 + 11) & 0x7FFFFF) != 0)
        }
        v10 = *this;
        v11 = this[2].u32[0];
        if ((_DWORD)v11)
        {
          LODWORD(v12) = (v11 - 1) & ((v7 >> 4) ^ (v7 >> 9));
          v13 = (int32x2_t *)(*(_QWORD *)&v10 + 16 * v12);
          v14 = *v13;
          if (*v13 == v7)
            goto LABEL_23;
          v15 = 1;
          while (*(_QWORD *)&v14 != -4096)
          {
            v16 = v12 + v15++;
            v12 = v16 & (v11 - 1);
            v14 = *(int32x2_t *)(*(_QWORD *)&v10 + 16 * v12);
            if (*(_QWORD *)&v14 == v7)
            {
              v13 = (int32x2_t *)(*(_QWORD *)&v10 + 16 * v12);
              goto LABEL_23;
            }
          }
        }
        v13 = (int32x2_t *)(*(_QWORD *)&v10 + 16 * v11);
LABEL_23:
        if (v13 == (int32x2_t *)(*(_QWORD *)&v10 + 16 * v11))
          v17 = v2;
        else
          v17 = v13 + 1;
        v18 = v17->u32[0];
        if ((_DWORD)v18 == this[4].i32[0])
          goto LABEL_7;
        v19 = (_QWORD *)(*(_QWORD *)&this[3] + (v18 << 6));
        v20 = v19[1];
        v21 = *(_QWORD ****)(v20 + 48);
        v22 = *(_QWORD ****)(v20 + 56);
        if (v22 == v21)
        {
          if ((_DWORD)v11)
            goto LABEL_38;
        }
        else
        {
          do
          {
            v23 = *v21;
            while (1)
            {
              v24 = *v23;
              if (!*v23)
                break;
              v25 = (_QWORD *)v24[1];
              if (v25)
              {
                *v25 = *v24;
                if (*v24)
                  *(_QWORD *)(*v24 + 8) = v24[1];
              }
              *v24 = 0;
              v24[1] = 0;
              v24[3] = 0;
            }
            ++v21;
          }
          while (v21 != v22);
          v10 = *this;
          LODWORD(v11) = this[2].i32[0];
          if ((_DWORD)v11)
          {
LABEL_38:
            v26 = v11 - 1;
            LODWORD(v11) = ((*v19 >> 4) ^ (*v19 >> 9)) & (v11 - 1);
            v27 = (uint64_t *)(*(_QWORD *)&v10 + 16 * v11);
            v28 = *v27;
            if (*v19 == *v27)
            {
LABEL_39:
              *v27 = -8192;
              this[1] = vadd_s32(this[1], (int32x2_t)0x1FFFFFFFFLL);
            }
            else
            {
              v51 = 1;
              while (v28 != -4096)
              {
                v52 = v11 + v51++;
                v11 = v52 & v26;
                v28 = *(_QWORD *)(*(_QWORD *)&v10 + 16 * v11);
                if (*v19 == v28)
                {
                  v27 = (uint64_t *)(*(_QWORD *)&v10 + 16 * v11);
                  goto LABEL_39;
                }
              }
            }
          }
        }
        v29 = v19 + 8;
        v30 = this[3];
        v31 = this[4].u32[0];
        v32 = (_QWORD *)(*(_QWORD *)&v30 + (v31 << 6));
        if (v19 + 8 != v32)
        {
          v33 = v19;
          while (1)
          {
            *(_OWORD *)v33 = *((_OWORD *)v33 + 4);
            v35 = (_QWORD *)v33[10];
            if (v33 + 12 != v35)
            {
              v36 = (_QWORD *)v33[2];
              if (v33 + 4 != v36)
              {
                free(v36);
                v35 = (_QWORD *)v33[10];
              }
              v33[2] = v35;
              v37 = v29 + 3;
              v33[3] = v33[11];
              v33[10] = v33 + 12;
              *((_DWORD *)v33 + 23) = 0;
              goto LABEL_43;
            }
            v38 = (void **)(v33 + 2);
            v37 = v33 + 11;
            v39 = *((unsigned int *)v33 + 22);
            v40 = *((unsigned int *)v33 + 6);
            if (v40 >= v39)
            {
              if ((_DWORD)v39)
                memmove(*v38, v35, 24 * v39 - 7);
              goto LABEL_42;
            }
            if (*((_DWORD *)v33 + 7) >= v39)
            {
              if ((_DWORD)v40)
              {
                memmove(*v38, v35, 24 * v40 - 7);
                v41 = *v37;
                if (v40 != v41)
                  goto LABEL_58;
              }
              else
              {
                v40 = 0;
                LODWORD(v41) = *v37;
                if (*v37)
LABEL_58:
                  memcpy((void *)(v33[2] + 24 * v40), (const void *)(v33[10] + 24 * v40), 24 * v41 - 24 * v40);
              }
            }
            else
            {
              *((_DWORD *)v33 + 6) = 0;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v38, v33 + 4, v39, 24);
              v40 = 0;
              LODWORD(v41) = *v37;
              if (*v37)
                goto LABEL_58;
            }
LABEL_42:
            *((_DWORD *)v33 + 6) = v39;
LABEL_43:
            *v37 = 0;
            v33[7] = v33[15];
            v29 += 8;
            v34 = v33 + 16;
            v33 += 8;
            if (v34 == v32)
            {
              LODWORD(v31) = this[4].i32[0];
              v30 = this[3];
              v5 = v54;
              break;
            }
          }
        }
        v42 = (v31 - 1);
        v2->i32[0] = v42;
        v43 = *(_QWORD *)&v30 + (v42 << 6);
        v44 = *(void **)(v43 + 16);
        if (v44 != (void *)(v43 + 32))
        {
          free(v44);
          v30 = this[3];
          v42 = this[4].u32[0];
        }
        if ((_QWORD *)(*(_QWORD *)&v30 + (v42 << 6)) != v19 && this[1].i32[0])
        {
          v45 = this[2].u32[0];
          if ((_DWORD)v45)
          {
            v46 = 16 * v45;
            v47 = *this;
            while ((**(_QWORD **)&v47 | 0x1000) == 0xFFFFFFFFFFFFF000)
            {
              *(_QWORD *)&v47 += 16;
              v46 -= 16;
              if (!v46)
                goto LABEL_7;
            }
          }
          else
          {
            v47 = *this;
          }
          v48 = *(_QWORD *)this + 16 * v45;
          if (*(_QWORD *)&v47 != v48)
          {
            v49 = ((uint64_t)v19 - *(_QWORD *)&v30) >> 6;
LABEL_72:
            v50 = *(unsigned int *)(*(_QWORD *)&v47 + 8);
            if (v49 < v50)
              *(_DWORD *)(*(_QWORD *)&v47 + 8) = v50 - 1;
            while (1)
            {
              *(_QWORD *)&v47 += 16;
              if (*(_QWORD *)&v47 == v48)
                break;
              if ((**(_QWORD **)&v47 | 0x1000) != 0xFFFFFFFFFFFFF000)
              {
                if (*(_QWORD *)&v47 != v48)
                  goto LABEL_72;
                break;
              }
            }
          }
        }
LABEL_7:
        v6 = *(_QWORD *)(v6 + 8);
        if (v6 == v5)
          goto LABEL_4;
      }
    }
  }
}

uint64_t mlir::detail::ConversionPatternRewriterImpl::remapValues(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 a5, uint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  ZinIrHalH13g *v17;
  ZinIrHalH13g *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unsigned __int8 v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  int v28;
  int v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unsigned __int8 v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  int v39;
  int v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t Loc;
  mlir::Block *ParentBlock;
  uint64_t *v46;
  uint64_t v47;
  unint64_t v48;
  char v49;
  _QWORD *v50;
  unint64_t v51;
  uint64_t v52;
  void *v53;
  uint64_t v55;
  uint64_t v58;
  unint64_t v59;
  mlir::detail::OpResultImpl *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  _QWORD v66[3];

  v12 = a9;
  v66[1] = *MEMORY[0x24BDAC8D0];
  if (a8 > *(unsigned int *)(a9 + 12))
    llvm::SmallVectorBase<unsigned int>::grow_pod(a9, (void *)(a9 + 16), a8, 8);
  v64 = v66;
  v65 = 0x100000000;
  v61 = 0;
  v62 = a7;
  v63 = 0;
  if (!a8)
  {
LABEL_70:
    v52 = 1;
    v53 = v64;
    if (v64 != v66)
      goto LABEL_71;
    return v52;
  }
  v13 = 0;
  v55 = a5;
  while (1)
  {
    v14 = mlir::ValueRange::dereference_iterator(&v62, v13);
    v58 = v14;
    v15 = *(_QWORD *)(a1 + 1224);
    if (!v15)
    {
LABEL_27:
      v17 = 0;
      v18 = (ZinIrHalH13g *)v58;
LABEL_28:
      v31 = *(_QWORD *)a1;
      LODWORD(v32) = *(_DWORD *)(a1 + 16);
      while (1)
      {
        v33 = (unint64_t)v18;
        if (!(_DWORD)v32)
          goto LABEL_66;
        if ((v34 & 1) == 0
        {
          v41 = llvm::hashing::detail::fixed_seed_override;
          if (!llvm::hashing::detail::fixed_seed_override)
            v41 = 0xFF51AFD7ED558CCDLL;
          llvm::hashing::detail::get_execution_seed(void)::seed = v41;
        }
        v35 = 0x9DDFEA08EB382D69
            * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v33) ^ HIDWORD(v33));
        v36 = 0x9DDFEA08EB382D69 * (HIDWORD(v33) ^ (v35 >> 47) ^ v35);
        LODWORD(v36) = (-348639895 * ((v36 >> 47) ^ v36)) & (v32 - 1);
        v37 = (uint64_t *)(v31 + 16 * v36);
        v38 = *v37;
        if (v33 != *v37)
        {
          v39 = 1;
          while (v38 != -4096)
          {
            v40 = v36 + v39++;
            v36 = v40 & (v32 - 1);
            v38 = *(_QWORD *)(v31 + 16 * v36);
            if (v33 == v38)
            {
              v37 = (uint64_t *)(v31 + 16 * v36);
              v31 = *(_QWORD *)a1;
              v32 = *(unsigned int *)(a1 + 16);
              if (v37 != (uint64_t *)(*(_QWORD *)a1 + 16 * v32))
                goto LABEL_33;
              goto LABEL_66;
            }
          }
          goto LABEL_66;
        }
        v31 = *(_QWORD *)a1;
        v32 = *(unsigned int *)(a1 + 16);
        if (v37 == (uint64_t *)(*(_QWORD *)a1 + 16 * v32))
          goto LABEL_66;
LABEL_33:
        v18 = (ZinIrHalH13g *)v37[1];
        if (!v18)
          goto LABEL_49;
      }
    }
    v16 = (void *)(*(_QWORD *)(v14 + 8) & 0xFFFFFFFFFFFFFFF8);
    LODWORD(v65) = 0;
    if (!mlir::TypeConverter::convertType(v15, v16, (uint64_t)&v64))
      break;
    if ((_DWORD)v65 != 1)
      goto LABEL_27;
    v17 = (ZinIrHalH13g *)*v64;
    v18 = (ZinIrHalH13g *)v58;
    if (!*v64)
      goto LABEL_28;
    v19 = 0;
    v20 = *(_QWORD *)a1;
    LODWORD(v21) = *(_DWORD *)(a1 + 16);
    do
    {
      v22 = (unint64_t)v18;
      if (v17 == (ZinIrHalH13g *)(*((_QWORD *)v18 + 1) & 0xFFFFFFFFFFFFFFF8))
        v19 = (unint64_t)v18;
      if (!(_DWORD)v21)
        break;
      if ((v23 & 1) == 0
      {
        v30 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override)
          v30 = 0xFF51AFD7ED558CCDLL;
        llvm::hashing::detail::get_execution_seed(void)::seed = v30;
      }
      v24 = 0x9DDFEA08EB382D69
          * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v22) ^ HIDWORD(v22));
      v25 = 0x9DDFEA08EB382D69 * (HIDWORD(v22) ^ (v24 >> 47) ^ v24);
      LODWORD(v25) = (-348639895 * ((v25 >> 47) ^ v25)) & (v21 - 1);
      v26 = (uint64_t *)(v20 + 16 * v25);
      v27 = *v26;
      if (v22 != *v26)
      {
        v28 = 1;
        while (v27 != -4096)
        {
          v29 = v25 + v28++;
          v25 = v29 & (v21 - 1);
          v27 = *(_QWORD *)(v20 + 16 * v25);
          if (v22 == v27)
          {
            v26 = (uint64_t *)(v20 + 16 * v25);
            v20 = *(_QWORD *)a1;
            v21 = *(unsigned int *)(a1 + 16);
            if (v26 != (uint64_t *)(*(_QWORD *)a1 + 16 * v21))
              goto LABEL_16;
            goto LABEL_45;
          }
        }
        break;
      }
      v20 = *(_QWORD *)a1;
      v21 = *(unsigned int *)(a1 + 16);
      if (v26 == (uint64_t *)(*(_QWORD *)a1 + 16 * v21))
        break;
LABEL_16:
      v18 = (ZinIrHalH13g *)v26[1];
    }
    while (v18);
LABEL_45:
    if (v19)
      v33 = v19;
    else
      v33 = v22;
    v18 = v17;
    v12 = a9;
LABEL_49:
    if (v18)
    {
      v42 = *(_QWORD *)(a1 + 1224);
      if (v42 && v18 != (ZinIrHalH13g *)(*(_QWORD *)(v33 + 8) & 0xFFFFFFFFFFFFFFF8))
      {
        Loc = a4;
        if (!v55)
        {
          Loc = mlir::Value::getLoc((mlir::Value *)&v58);
          v42 = *(_QWORD *)(a1 + 1224);
        }
        v60 = (mlir::detail::OpResultImpl *)v33;
        ParentBlock = (mlir::Block *)mlir::Value::getParentBlock((mlir::Value *)&v60);
        v46 = (uint64_t *)((char *)ParentBlock + 40);
        if (v60 && (*((_QWORD *)v60 + 1) & 7) != 7)
          v46 = (uint64_t *)(mlir::detail::OpResultImpl::getOwner(v60) + 8);
        v47 = buildUnresolvedMaterialization(1u, ParentBlock, *v46, Loc, (uint64_t)&v60, 1, (uint64_t)v17, v17, v42, (uint64_t *)(a1 + 264));
        v12 = a9;
        do
        {
          v48 = v33;
          v59 = v33;
          v60 = 0;
          if (!llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a1, &v59, &v60))break;
          if (v60 == (mlir::detail::OpResultImpl *)(*(_QWORD *)a1 + 16 * *(unsigned int *)(a1 + 16)))
            break;
          v33 = *((_QWORD *)v60 + 1);
        }
        while (v33);
        v59 = v48;
        v60 = 0;
        v49 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a1, &v59, &v60);
        v50 = v60;
        if ((v49 & 1) == 0)
        {
          v50 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a1, (uint64_t)&v59, &v59, v60);
          *v50 = v59;
          v50[1] = 0;
        }
        v50[1] = v47;
        v33 = v47;
      }
    }
LABEL_66:
    v51 = *(unsigned int *)(v12 + 8);
    if (v51 >= *(unsigned int *)(v12 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v12, (void *)(a9 + 16), v51 + 1, 8);
      v51 = *(unsigned int *)(v12 + 8);
    }
    *(_QWORD *)(*(_QWORD *)v12 + 8 * v51) = v33;
    ++*(_DWORD *)(v12 + 8);
    v13 = v63 + 1;
    ++v61;
    ++v63;
    if (v62 == a7 && v13 == a8)
      goto LABEL_70;
  }
  if (v55)
  {
    v52 = 0;
    v53 = v64;
    if (v64 == v66)
      return v52;
  }
  else
  {
    mlir::Value::getLoc((mlir::Value *)&v58);
    v52 = 0;
    v53 = v64;
    if (v64 == v66)
      return v52;
  }
LABEL_71:
  free(v53);
  return v52;
}

BOOL mlir::TypeConverter::convertType(uint64_t a1, void *a2, uint64_t a3)
{
  pthread_rwlock_t **v5;
  mlir::MLIRContext *Context;
  int isMultithreadingEnabled;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void **v11;
  void *v12;
  int v13;
  int v14;
  void *v15;
  uint64_t v16;
  void *v17;
  int v18;
  _BOOL8 v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  void *v24;
  int v25;
  unsigned int v26;
  const void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int16 v34;
  char v35;
  mlir::MLIRContext *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  unsigned int v41;
  uint64_t v42;
  unsigned int v43;
  _QWORD *v44;
  void *v45;
  _QWORD *v46;
  int v47;
  BOOL v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  _QWORD *v53;
  void *v54;
  unsigned int v55;
  int v56;
  uint64_t v57;
  int v58;
  unsigned int v59;
  uint64_t *v60;
  void *v61;
  uint64_t *v62;
  int v63;
  BOOL v64;
  unsigned int v65;
  void *v66;
  void *v67;
  uint64_t *v68;
  _QWORD *v70;
  int v71;
  BOOL v72;
  unsigned int v73;
  _QWORD *v74;
  int v75;
  uint64_t v76;
  int v77;
  unsigned int v78;
  void *v79;
  _QWORD *v80;
  int v81;
  BOOL v82;
  unsigned int v83;
  _QWORD *v84;
  int v85;
  uint64_t v86;
  int v87;
  unsigned int v88;
  void *v89;
  _QWORD *v90;
  int v91;
  BOOL v92;
  unsigned int v93;
  void *v94;
  void *v95;
  uint64_t v96;
  _QWORD v97[3];

  v97[2] = *MEMORY[0x24BDAC8D0];
  v94 = a2;
  v5 = (pthread_rwlock_t **)(a1 + 520);
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v94);
  isMultithreadingEnabled = mlir::MLIRContext::isMultithreadingEnabled(Context);
  if (isMultithreadingEnabled)
    llvm::sys::RWMutexImpl::lock_shared(v5);
  v8 = *(_QWORD *)(a1 + 472);
  v9 = *(unsigned int *)(a1 + 488);
  if ((_DWORD)v9)
  {
    LODWORD(v10) = ((v94 >> 4) ^ (v94 >> 9)) & (v9 - 1);
    v11 = (void **)(v8 + 16 * v10);
    v12 = *v11;
    if (v94 == *v11)
      goto LABEL_10;
    v13 = 1;
    while (v12 != (void *)-4096)
    {
      v14 = v10 + v13++;
      v10 = v14 & (v9 - 1);
      v12 = *(void **)(v8 + 16 * v10);
      if (v94 == v12)
      {
        v11 = (void **)(v8 + 16 * v10);
        goto LABEL_10;
      }
    }
  }
  v11 = (void **)(v8 + 16 * v9);
LABEL_10:
  if (v11 != (void **)(v8 + 16 * v9))
  {
    v15 = v11[1];
    if (v15)
    {
      v16 = *(unsigned int *)(a3 + 8);
      if (v16 >= *(_DWORD *)(a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v16 + 1, 8);
        LODWORD(v16) = *(_DWORD *)(a3 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a3 + 8 * v16) = v15;
      ++*(_DWORD *)(a3 + 8);
      v17 = v11[1];
      v18 = 0;
      v19 = v17 != 0;
      if (!isMultithreadingEnabled)
        goto LABEL_32;
    }
    else
    {
      v18 = 0;
      v19 = 0;
      if (!isMultithreadingEnabled)
        goto LABEL_32;
    }
LABEL_31:
    llvm::sys::RWMutexImpl::unlock_shared(v5);
    goto LABEL_32;
  }
  v20 = *(_QWORD *)(a1 + 496);
  v21 = *(_DWORD *)(a1 + 512);
  if (v21)
  {
    v22 = ((v94 >> 4) ^ (v94 >> 9)) & (v21 - 1);
    v23 = v20 + 40 * v22;
    v24 = *(void **)v23;
    if (v94 == *(void **)v23)
      goto LABEL_25;
    v25 = 1;
    while (v24 != (void *)-4096)
    {
      v26 = v22 + v25++;
      v22 = v26 & (v21 - 1);
      v23 = v20 + 40 * v22;
      v24 = *(void **)v23;
      if (v94 == *(void **)v23)
        goto LABEL_25;
    }
  }
  v23 = v20 + 40 * v21;
LABEL_25:
  if (v23 == v20 + 40 * v21)
  {
    v18 = 1;
    v19 = 1;
    if (!isMultithreadingEnabled)
      goto LABEL_32;
    goto LABEL_31;
  }
  v27 = *(const void **)(v23 + 8);
  v28 = *(unsigned int *)(v23 + 16);
  v29 = *(unsigned int *)(a3 + 8);
  if (v29 + v28 > (unint64_t)*(unsigned int *)(a3 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v29 + v28, 8);
    LODWORD(v29) = *(_DWORD *)(a3 + 8);
  }
  if ((_DWORD)v28)
  {
    memcpy((void *)(*(_QWORD *)a3 + 8 * v29), v27, 8 * v28);
    LODWORD(v29) = *(_DWORD *)(a3 + 8);
  }
  v18 = 0;
  *(_DWORD *)(a3 + 8) = v29 + v28;
  v19 = 1;
  if (isMultithreadingEnabled)
    goto LABEL_31;
LABEL_32:
  if (!v18)
    return v19;
  v30 = *(unsigned int *)(a3 + 8);
  v31 = *(_QWORD *)(a1 + 8) + 32 * *(unsigned int *)(a1 + 16);
  v32 = -32 * *(unsigned int *)(a1 + 16);
  do
  {
    if (!v32)
      return 0;
    v95 = v94;
    v33 = *(_QWORD *)(v31 - 8);
    if (!v33)
      std::__throw_bad_function_call[abi:nn180100]();
    v31 -= 32;
    v34 = (*(uint64_t (**)(uint64_t, void **, uint64_t))(*(_QWORD *)v33 + 48))(v33, &v95, a3);
    v32 += 32;
  }
  while (v34 < 0x100u);
  v35 = v34;
  v36 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v94);
  v37 = mlir::MLIRContext::isMultithreadingEnabled(v36);
  if (v37)
    llvm::sys::RWMutexImpl::lock(v5);
  if (!v35)
  {
    v50 = *(_DWORD *)(a1 + 488);
    if (!v50)
      goto LABEL_107;
    v51 = *(_QWORD *)(a1 + 472);
    v52 = ((v94 >> 4) ^ (v94 >> 9)) & (v50 - 1);
    v53 = (_QWORD *)(v51 + 16 * v52);
    v54 = (void *)*v53;
    if (v94 == (void *)*v53)
    {
      v19 = 0;
      goto LABEL_91;
    }
    v70 = 0;
    v71 = 1;
    while (v54 != (void *)-4096)
    {
      v19 = 0;
      if (v70)
        v72 = 0;
      else
        v72 = v54 == (void *)-8192;
      if (v72)
        v70 = v53;
      v73 = v52 + v71++;
      v52 = v73 & (v50 - 1);
      v53 = (_QWORD *)(v51 + 16 * v52);
      v54 = (void *)*v53;
      if (v94 == (void *)*v53)
        goto LABEL_91;
    }
    v74 = v70 ? v70 : v53;
    v75 = *(_DWORD *)(a1 + 480);
    if (4 * v75 + 4 < 3 * v50)
    {
      if (v50 + ~v75 - *(_DWORD *)(a1 + 484) > v50 >> 3)
        goto LABEL_76;
    }
    else
    {
LABEL_107:
      v50 *= 2;
    }
    llvm::DenseMap<mlir::Block *,llvm::SMLoc,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,llvm::SMLoc>>::grow(a1 + 472, v50);
    v76 = *(_QWORD *)(a1 + 472);
    v66 = v94;
    v77 = *(_DWORD *)(a1 + 488) - 1;
    v78 = ((v94 >> 4) ^ (v94 >> 9)) & v77;
    v74 = (_QWORD *)(v76 + 16 * v78);
    v79 = (void *)*v74;
    if (v94 == (void *)*v74)
      goto LABEL_77;
    v80 = 0;
    v81 = 1;
    while (v79 != (void *)-4096)
    {
      if (v80)
        v82 = 0;
      else
        v82 = v79 == (void *)-8192;
      if (v82)
        v80 = v74;
      v83 = v78 + v81++;
      v78 = v83 & v77;
      v74 = (_QWORD *)(v76 + 16 * (v83 & v77));
      v79 = (void *)*v74;
      if (v94 == (void *)*v74)
        goto LABEL_77;
    }
    if (v80)
      v74 = v80;
LABEL_76:
    v66 = (void *)*v74;
LABEL_77:
    ++*(_DWORD *)(a1 + 480);
    if (v66 != (void *)-4096)
      --*(_DWORD *)(a1 + 484);
    v19 = 0;
    *v74 = v94;
    v74[1] = 0;
    goto LABEL_91;
  }
  v38 = *(unsigned int *)(a3 + 8);
  v39 = v38 - v30;
  v40 = (_QWORD *)(*(_QWORD *)a3 + 8 * v30);
  if (v38 - v30 != 1)
  {
    v95 = v97;
    v96 = 0x200000000;
    if ((unint64_t)(8 * v39) < 0x11)
    {
      v55 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v95, v97, v38 - v30, 8);
      v55 = v96;
    }
    if ((_DWORD)v38 != (_DWORD)v30)
    {
      memcpy((char *)v95 + 8 * v55, v40, 8 * v39);
      v55 = v96;
    }
    LODWORD(v96) = v55 + v39;
    v56 = *(_DWORD *)(a1 + 512);
    if (v56)
    {
      v57 = *(_QWORD *)(a1 + 496);
      v58 = v56 - 1;
      v59 = ((v94 >> 4) ^ (v94 >> 9)) & v58;
      v60 = (uint64_t *)(v57 + 40 * v59);
      v61 = (void *)*v60;
      if (v94 == (void *)*v60)
        goto LABEL_88;
      v62 = 0;
      v63 = 1;
      while (v61 != (void *)-4096)
      {
        if (v62)
          v64 = 0;
        else
          v64 = v61 == (void *)-8192;
        if (v64)
          v62 = v60;
        v65 = v59 + v63++;
        v59 = v65 & v58;
        v60 = (uint64_t *)(v57 + 40 * v59);
        v61 = (void *)*v60;
        if (v94 == (void *)*v60)
          goto LABEL_88;
      }
      if (v62)
        v68 = v62;
      else
        v68 = v60;
    }
    else
    {
      v68 = 0;
    }
    llvm::DenseMapBase<llvm::DenseMap<mlir::Type,llvm::SmallVector<mlir::Type,2u>,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,llvm::SmallVector<mlir::Type,2u>>>,mlir::Type,llvm::SmallVector<mlir::Type,2u>,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,llvm::SmallVector<mlir::Type,2u>>>::InsertIntoBucket<mlir::Type const&,llvm::SmallVector<mlir::Type,2u>>(a1 + 496, v68, (uint64_t *)&v94, (uint64_t)&v95);
LABEL_88:
    if (v95 != v97)
      free(v95);
    goto LABEL_90;
  }
  v41 = *(_DWORD *)(a1 + 488);
  if (!v41)
    goto LABEL_122;
  v42 = *(_QWORD *)(a1 + 472);
  v43 = ((v94 >> 4) ^ (v94 >> 9)) & (v41 - 1);
  v44 = (_QWORD *)(v42 + 16 * v43);
  v45 = (void *)*v44;
  if (v94 != (void *)*v44)
  {
    v46 = 0;
    v47 = 1;
    v19 = 1;
    while (v45 != (void *)-4096)
    {
      if (v46)
        v48 = 0;
      else
        v48 = v45 == (void *)-8192;
      if (v48)
        v46 = v44;
      v49 = v43 + v47++;
      v43 = v49 & (v41 - 1);
      v44 = (_QWORD *)(v42 + 16 * v43);
      v45 = (void *)*v44;
      if (v94 == (void *)*v44)
        goto LABEL_91;
    }
    if (v46)
      v84 = v46;
    else
      v84 = v44;
    v85 = *(_DWORD *)(a1 + 480);
    if (4 * v85 + 4 < 3 * v41)
    {
      if (v41 + ~v85 - *(_DWORD *)(a1 + 484) > v41 >> 3)
        goto LABEL_82;
      goto LABEL_123;
    }
LABEL_122:
    v41 *= 2;
LABEL_123:
    llvm::DenseMap<mlir::Block *,llvm::SMLoc,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,llvm::SMLoc>>::grow(a1 + 472, v41);
    v86 = *(_QWORD *)(a1 + 472);
    v67 = v94;
    v87 = *(_DWORD *)(a1 + 488) - 1;
    v88 = ((v94 >> 4) ^ (v94 >> 9)) & v87;
    v84 = (_QWORD *)(v86 + 16 * v88);
    v89 = (void *)*v84;
    if (v94 == (void *)*v84)
      goto LABEL_83;
    v90 = 0;
    v91 = 1;
    while (v89 != (void *)-4096)
    {
      if (v90)
        v92 = 0;
      else
        v92 = v89 == (void *)-8192;
      if (v92)
        v90 = v84;
      v93 = v88 + v91++;
      v88 = v93 & v87;
      v84 = (_QWORD *)(v86 + 16 * (v93 & v87));
      v89 = (void *)*v84;
      if (v94 == (void *)*v84)
        goto LABEL_83;
    }
    if (v90)
      v84 = v90;
LABEL_82:
    v67 = (void *)*v84;
LABEL_83:
    ++*(_DWORD *)(a1 + 480);
    if (v67 != (void *)-4096)
      --*(_DWORD *)(a1 + 484);
    *v84 = v94;
    v84[1] = *v40;
  }
LABEL_90:
  v19 = 1;
LABEL_91:
  if (v37)
    llvm::sys::RWMutexImpl::unlock_shared(v5);
  return v19;
}

mlir::Block *mlir::detail::ConversionPatternRewriterImpl::convertBlockSignature(uint64_t a1, mlir::Block *this, uint64_t a3, uint64_t a4)
{
  mlir::TypeConverter *v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  void **v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  mlir::Block **v18;
  mlir::Block *v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  int v24;
  unsigned int v25;
  mlir::Block *v26;
  uint64_t v28;
  unint64_t v29;
  BOOL v30;
  int v31;
  unsigned int v32;
  char *v33;
  void *v34[2];
  void *v35[3];
  void *v36;
  uint64_t v37;
  char v38;
  uint64_t v39;

  v4 = (mlir::TypeConverter *)a3;
  v39 = *MEMORY[0x24BDAC8D0];
  v7 = a1 + 72;
  v8 = a1 + 368;
  if (!a4)
  {
    v15 = *(_QWORD *)(a1 + 72);
    v16 = *(unsigned int *)(a1 + 88);
    if ((_DWORD)v16)
    {
      LODWORD(v17) = (v16 - 1) & ((this >> 4) ^ (this >> 9));
      v18 = (mlir::Block **)(v15 + 16 * v17);
      v19 = *v18;
      if (*v18 == this)
        goto LABEL_14;
      v20 = 1;
      while (v19 != (mlir::Block *)-4096)
      {
        v21 = v17 + v20++;
        v17 = v21 & (v16 - 1);
        v19 = *(mlir::Block **)(v15 + 16 * v17);
        if (v19 == this)
        {
          v18 = (mlir::Block **)(v15 + 16 * v17);
          goto LABEL_14;
        }
      }
    }
    v18 = (mlir::Block **)(v15 + 16 * v16);
LABEL_14:
    if (v18 == (mlir::Block **)(v15 + 16 * v16))
    {
      v22 = *(_DWORD *)(a1 + 128);
      if (v22)
      {
        v23 = *(_QWORD *)(a1 + 112);
        v24 = v22 - 1;
        v25 = v24 & ((this >> 4) ^ (this >> 9));
        v26 = *(mlir::Block **)(v23 + 8 * v25);
        if (v26 == this)
          return this;
        v31 = 1;
        while (v26 != (mlir::Block *)-4096)
        {
          v32 = v25 + v31++;
          v25 = v32 & v24;
          v26 = *(mlir::Block **)(v23 + 8 * v25);
          if (v26 == this)
            return this;
        }
      }
      if (mlir::Block::getParent(this))
      {
        if (!v4)
          return v4;
        mlir::TypeConverter::convertBlockSignature(v4, this, (uint64_t)v34);
        if (!v38)
          return 0;
        if (v38)
        {
          if (v36 != &v37)
            free(v36);
          if (v34[0] != v35)
            free(v34[0]);
        }
        goto LABEL_3;
      }
    }
    return this;
  }
LABEL_3:
  if (v4 && v4 != this)
  {
    LODWORD(v34[0]) = 5;
    v34[1] = v4;
    memset(v35, 0, sizeof(v35));
    v9 = *(unsigned int *)(a1 + 424);
    v10 = *(_QWORD *)(a1 + 416);
    v11 = v34;
    if (v9 >= *(_DWORD *)(a1 + 428))
    {
      v28 = a1 + 416;
      v29 = v9 + 1;
      v30 = v10 + 40 * v9 > (unint64_t)v34;
      if (v10 <= (unint64_t)v34 && v30)
      {
        v33 = (char *)v34 - v10;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v28, (void *)(a1 + 432), v29, 40);
        v10 = *(_QWORD *)(a1 + 416);
        v11 = (void **)&v33[v10];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v28, (void *)(a1 + 432), v29, 40);
        v10 = *(_QWORD *)(a1 + 416);
        v11 = v34;
      }
    }
    v12 = v10 + 40 * *(unsigned int *)(a1 + 424);
    v13 = *(_OWORD *)v11;
    v14 = *((_OWORD *)v11 + 1);
    *(_QWORD *)(v12 + 32) = v11[4];
    *(_OWORD *)v12 = v13;
    *(_OWORD *)(v12 + 16) = v14;
    ++*(_DWORD *)(a1 + 424);
  }
  return v4;
}

uint64_t `anonymous namespace'::ArgConverter::applySignatureConversion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  mlir::Block *v10;
  _QWORD *v12;
  uint64_t v14;
  mlir::MLIRContext *v15;
  ZinIrHalH13g *v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t UnknownLoc;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  int64x2_t v25;
  int64x2_t *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t *v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t *v45;
  char *v46;
  uint64_t *v47;
  char *v48;
  unint64_t v49;
  uint64_t v50;
  __int128 *v51;
  _OWORD *v52;
  uint64_t v53;
  __int128 v54;
  uint64_t v55;
  uint64_t v56;
  _BYTE *v57;
  _BYTE *v58;
  unint64_t v59;
  unint64_t v60;
  _BYTE *v61;
  uint64_t v62;
  _BYTE *v63;
  uint64_t v64;
  __int128 v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t *v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  char v77;
  _QWORD *v78;
  uint64_t v79;
  uint64_t *v80;
  uint64_t v81;
  void *v82;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  char v87;
  _QWORD *v88;
  unint64_t v89;
  char *v90;
  int v91;
  unint64_t Parent;
  uint64_t v93;
  uint64_t v94;
  int v95;
  int v96;
  unsigned int v97;
  uint64_t *v98;
  uint64_t v99;
  uint64_t *v100;
  int v101;
  BOOL v102;
  unsigned int v103;
  uint64_t *v104;
  uint64_t *v105;
  mlir::Operation *v106;
  mlir::Region *v107;
  uint64_t *v108;
  uint64_t *v109;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  char *v114;
  int v115;
  mlir::Block *v116;
  uint64_t v117;
  unsigned int v118;
  unsigned int v119;
  mlir::Block **v120;
  mlir::Block *v121;
  mlir::Block **v122;
  int v123;
  BOOL v124;
  unsigned int v125;
  mlir::Block *v126;
  uint64_t v127;
  char **v128;
  uint64_t v129;
  uint64_t v130;
  void *v131;
  void **v132;
  unint64_t v133;
  BOOL v134;
  uint64_t v135;
  _BYTE *v136;
  void *v137;
  void *v138;
  uint64_t v140;
  int v141;
  int v142;
  unsigned int v143;
  mlir::Block *v144;
  char *v145;
  char *v146;
  void *v147;
  void **v148;
  unint64_t v149;
  uint64_t v150;
  _BYTE *v151;
  char *v152;
  uint64_t v153;
  char *v154;
  _QWORD *v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  char *v160;
  int v161;
  uint64_t v162;
  int v163;
  BOOL v164;
  unsigned int v165;
  void *v166;
  __int128 v167;
  _QWORD *v168;
  mlir::Block *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  char *v173;
  uint64_t v174;
  uint64_t v176;
  unint64_t v178;
  uint64_t v179;
  unint64_t v180;
  unint64_t v181;
  unint64_t v182[2];
  uint64_t v183;
  void *__src;
  uint64_t v185;
  _BYTE v186[24];
  uint64_t v187;
  unint64_t v188[2];
  void *v189;
  uint64_t v190;
  _BYTE v191[32];
  int64x2_t *v192;
  uint64_t v193;
  _QWORD v194[6];
  __int128 v195;
  _BYTE *v196;
  uint64_t v197;
  _BYTE v198[24];
  uint64_t v199;
  uint64_t v200;

  v200 = *MEMORY[0x24BDAC8D0];
  v7 = *(_QWORD *)(a2 + 56) - *(_QWORD *)(a2 + 48);
  v8 = v7 >> 3;
  v9 = *(unsigned int *)(a4 + 152);
  if (!((v7 >> 3) | v9))
    return a2;
  v12 = (_QWORD *)a4;
  v14 = *(_QWORD *)(a4 + 144);
  v16 = (ZinIrHalH13g *)mlir::Block::splitBlock(a2, *(uint64_t **)(a2 + 40));
  while (1)
  {
    v17 = *(uint64_t **)a2;
    if (!*(_QWORD *)a2)
      break;
    v18 = (uint64_t *)v17[1];
    if (v18)
    {
      *v18 = *v17;
      if (*v17)
        *(_QWORD *)(*v17 + 8) = v17[1];
    }
    v17[3] = (uint64_t)v16;
    ZinIrHalH13g::~ZinIrHalH13g(v16);
    v17[1] = (uint64_t)v19;
    v20 = *v19;
    *v17 = *v19;
    if (v20)
      *(_QWORD *)(v20 + 8) = v17;
    *v19 = (uint64_t)v17;
  }
  v179 = a2;
  UnknownLoc = mlir::Builder::getUnknownLoc((mlir::UnknownLoc **)(*(_QWORD *)(a1 + 112) + 8), v15);
  v22 = UnknownLoc;
  v192 = (int64x2_t *)v194;
  v193 = 0x600000000;
  if (v9 < 7)
  {
    if ((_DWORD)v9)
    {
      v194[0] = UnknownLoc;
      if ((_DWORD)v9 != 1)
      {
        v194[1] = UnknownLoc;
        if ((_DWORD)v9 != 2)
        {
          v194[2] = UnknownLoc;
          if ((_DWORD)v9 != 3)
          {
            v194[3] = UnknownLoc;
            if ((_DWORD)v9 != 4)
            {
              v194[4] = UnknownLoc;
              if ((_DWORD)v9 != 5)
                v194[5] = UnknownLoc;
            }
          }
        }
      }
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v192, v194, v9, 8);
    v23 = (unint64_t *)v192 + (v9 & 0xFFFFFFFC);
    v24 = v9 & 3;
    v25 = vdupq_n_s64(v22);
    v26 = v192 + 1;
    v27 = v9 & 0xFFFFFFFC;
    do
    {
      v26[-1] = v25;
      *v26 = v25;
      v26 += 2;
      v27 -= 4;
    }
    while (v27);
    if ((v9 & 0xFFFFFFFC) != v9)
    {
      do
      {
        *v23++ = v22;
        --v24;
      }
      while (v24);
    }
  }
  LODWORD(v193) = v9;
  v28 = (v7 >> 3);
  if ((_DWORD)v8)
  {
    v29 = 0;
    do
    {
      v30 = *v12 + 32 * v29;
      if (*(_BYTE *)(v30 + 24))
        v31 = *(_QWORD *)(v30 + 16) == 0;
      else
        v31 = 0;
      if (v31)
      {
        v32 = *(_QWORD *)(v30 + 8);
        if (v32)
        {
          v33 = 0;
          v34 = *(_QWORD *)v30;
          v35 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v179 + 48) + 8 * v29) + 32);
          v36 = v34;
          do
            v192->i64[v33++ + v36] = v35;
          while (v32 > v33);
        }
      }
      ++v29;
    }
    while (v29 != v28);
  }
  mlir::ValueRange::ValueRange(v188, v14, v9);
  v37 = mlir::Block::addArguments(v16, v188[0], v188[1], (uint64_t)v192, v193);
  v38 = v37;
  v40 = v39;
  v41 = v191;
  v189 = v191;
  v190 = 0x400000000;
  v42 = (uint64_t)v40 - v37;
  if ((unint64_t)v40 - v37 >= 0x21)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v191, v42 >> 3, 8);
    v43 = v190;
    v41 = (char *)v189;
    v44 = v190;
    v45 = a5;
    if ((uint64_t *)v38 != v40)
      goto LABEL_38;
LABEL_41:
    v173 = v41;
    goto LABEL_48;
  }
  v43 = 0;
  v44 = 0;
  v45 = a5;
  if ((uint64_t *)v37 == v40)
    goto LABEL_41;
LABEL_38:
  v46 = &v41[8 * v43];
  if ((unint64_t)(v42 - 8) >= 0x38)
  {
    v48 = &v41[8 * v43];
    v47 = (uint64_t *)v38;
    if ((unint64_t)&v48[-v38] >= 0x20)
    {
      v49 = ((unint64_t)(v42 - 8) >> 3) + 1;
      v50 = 8 * (v49 & 0x3FFFFFFFFFFFFFFCLL);
      v46 += v50;
      v47 = (uint64_t *)(v38 + v50);
      v51 = (__int128 *)(v38 + 16);
      v52 = v48 + 16;
      v53 = v49 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v54 = *v51;
        *(v52 - 1) = *(v51 - 1);
        *v52 = v54;
        v51 += 2;
        v52 += 2;
        v53 -= 4;
      }
      while (v53);
      if (v49 == (v49 & 0x3FFFFFFFFFFFFFFCLL))
        goto LABEL_47;
    }
  }
  else
  {
    v47 = (uint64_t *)v38;
  }
  do
  {
    v55 = *v47++;
    *(_QWORD *)v46 = v55;
    v46 += 8;
  }
  while (v47 != v40);
LABEL_47:
  v173 = (char *)v189;
LABEL_48:
  LODWORD(v190) = v44 + ((unint64_t)v42 >> 3);
  v183 = v179;
  __src = v186;
  v185 = 0x100000000;
  v187 = a3;
  if (!(_DWORD)v8)
    goto LABEL_60;
  if ((_DWORD)v8 == 1)
  {
    v56 = 0;
    v57 = v186;
    if (!v28)
      goto LABEL_59;
LABEL_53:
    v58 = &v57[24 * v56];
    v59 = -24 * v56 + 24 * v28 - 24;
    if (v59 < 0x18)
      goto LABEL_57;
    v60 = v59 / 0x18 + 1;
    v58 += 24 * (v60 & 0x1FFFFFFFFFFFFFFELL);
    v61 = &v57[24 * v56 + 24];
    v62 = v60 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v61 - 24) = 0;
      *v61 = 0;
      *(v61 - 8) = 0;
      v61[16] = 0;
      v61 += 48;
      v62 -= 2;
    }
    while (v62);
    if (v60 != (v60 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_57:
      v63 = &v57[24 * v28];
      do
      {
        *v58 = 0;
        v58[16] = 0;
        v58 += 24;
      }
      while (v58 != v63);
    }
    goto LABEL_59;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v186, v28, 24);
  v56 = v185;
  v57 = __src;
  if (v185 != v28)
    goto LABEL_53;
LABEL_59:
  LODWORD(v185) = v8;
LABEL_60:
  v169 = v16;
  v172 = a1;
  v64 = *(_QWORD *)(a1 + 112);
  v65 = *(_OWORD *)(v64 + 24);
  v64 += 24;
  v167 = v65;
  v66 = *((_QWORD *)v16 + 5);
  *(_QWORD *)v64 = v16;
  *(_QWORD *)(v64 + 8) = v66;
  v168 = (_QWORD *)v64;
  if ((_DWORD)v8)
  {
    v67 = 0;
    v68 = 0;
    v69 = 0;
    v166 = (void *)(a6 + 16);
    v70 = 32 * v28;
    v171 = a6;
    v170 = v70;
    do
    {
      v72 = (uint64_t *)(*v12 + v69);
      if (*((_BYTE *)v72 + 24))
      {
        v73 = v12;
        v74 = v72[2];
        v75 = *(_QWORD *)(v179 + 48);
        v76 = *(_QWORD *)(v75 + v68);
        if (!v74)
        {
          v79 = *v72;
          v80 = (uint64_t *)&v173[8 * *v72];
          v178 = v72[1];
          v176 = *v72;
          if (v178 == 1)
          {
            if (a3)
            {
              v81 = *v80;
              v82 = (void *)(*(_QWORD *)(v76 + 8) & 0xFFFFFFFFFFFFFFF8);
              if ((void *)(*(_QWORD *)(*v80 + 8) & 0xFFFFFFFFFFFFFFF8) != v82)
              {
                v174 = (uint64_t)&v173[8 * v79];
                goto LABEL_75;
              }
              v45 = a5;
            }
            else
            {
              v81 = *v80;
            }
LABEL_88:
            v181 = v76;
            *(_QWORD *)&v195 = 0;
            v87 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>(v45, &v181, &v195);
            v88 = (_QWORD *)v195;
            if ((v87 & 1) == 0)
            {
              v88 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v45, (uint64_t)&v181, &v181, (_QWORD *)v195);
              *v88 = v181;
              v88[1] = 0;
            }
            v88[1] = v81;
            v89 = *(unsigned int *)(a6 + 8);
            if (v89 >= *(unsigned int *)(a6 + 12))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(a6, v166, v89 + 1, 8);
              v89 = *(unsigned int *)(a6 + 8);
            }
            *(_QWORD *)(*(_QWORD *)a6 + 8 * v89) = v76;
            ++*(_DWORD *)(a6 + 8);
            v90 = (char *)__src + v67;
            v91 = *((unsigned __int8 *)__src + v67 + 16);
            *(_DWORD *)v90 = v176;
            *((_DWORD *)v90 + 1) = v178;
            *((_QWORD *)v90 + 1) = v81;
            v12 = v73;
            if (!v91)
              v90[16] = 1;
            goto LABEL_65;
          }
          v174 = (uint64_t)&v173[8 * v79];
          v82 = (void *)(*(_QWORD *)(v76 + 8) & 0xFFFFFFFFFFFFFFF8);
LABEL_75:
          *(_QWORD *)&v195 = &v196;
          *((_QWORD *)&v195 + 1) = 0x100000000;
          if (mlir::TypeConverter::convertType(a3, v82, (uint64_t)&v195) && DWORD2(v195) == 1)
          {
            v84 = *(_QWORD *)v195;
            if ((_BYTE **)v195 != &v196)
              goto LABEL_82;
          }
          else
          {
            v84 = 0;
            if ((_BYTE **)v195 == &v196)
              goto LABEL_83;
LABEL_82:
            free((void *)v195);
          }
LABEL_83:
          if (!v84)
            v84 = (uint64_t)v82;
          v85 = *(_QWORD *)(v172 + 112);
          v86 = *(_QWORD *)(v76 + 32);
          mlir::ValueRange::ValueRange(v182, v174, v178);
          v81 = buildUnresolvedMaterialization(0, *(mlir::Block **)(v85 + 24), *(_QWORD *)(v85 + 32), v86, v182[0], v182[1], v84, (ZinIrHalH13g *)v82, a3, *(uint64_t **)(v172 + 120));
          a6 = v171;
          v45 = a5;
          v70 = v170;
          goto LABEL_88;
        }
        v181 = *(_QWORD *)(v75 + v68);
        *(_QWORD *)&v195 = 0;
        v77 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>(v45, &v181, &v195);
        v78 = (_QWORD *)v195;
        if ((v77 & 1) == 0)
        {
          v78 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v45, (uint64_t)&v181, &v181, (_QWORD *)v195);
          *v78 = v181;
          v78[1] = 0;
        }
        v78[1] = v74;
        v71 = *(unsigned int *)(a6 + 8);
        if (v71 >= *(unsigned int *)(a6 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a6, v166, v71 + 1, 8);
          v71 = *(unsigned int *)(a6 + 8);
        }
        *(_QWORD *)(*(_QWORD *)a6 + 8 * v71) = v76;
        ++*(_DWORD *)(a6 + 8);
        v12 = v73;
      }
LABEL_65:
      v69 += 32;
      v68 += 8;
      v67 += 24;
    }
    while (v70 != v69);
  }
  v10 = v169;
  Parent = mlir::Block::getParent(v169);
  v180 = Parent;
  v93 = v172;
  v94 = *(_QWORD *)(v172 + 64);
  v95 = *(_DWORD *)(v172 + 80);
  if (!v95)
  {
    v104 = 0;
LABEL_106:
    v98 = llvm::DenseMapBase<llvm::DenseMap<mlir::Region *,std::unique_ptr<mlir::Region>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::unique_ptr<mlir::Region>>>,mlir::Region *,std::unique_ptr<mlir::Region>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::unique_ptr<mlir::Region>>>::InsertIntoBucket<mlir::Region * const&>(v172 + 64, v104, (uint64_t *)&v180);
    goto LABEL_107;
  }
  v96 = v95 - 1;
  v97 = ((Parent >> 4) ^ (Parent >> 9)) & v96;
  v98 = (uint64_t *)(v94 + 16 * v97);
  v99 = *v98;
  if (Parent != *v98)
  {
    v100 = 0;
    v101 = 1;
    while (v99 != -4096)
    {
      if (v100)
        v102 = 0;
      else
        v102 = v99 == -8192;
      if (v102)
        v100 = v98;
      v103 = v97 + v101++;
      v97 = v103 & v96;
      v98 = (uint64_t *)(v94 + 16 * v97);
      v99 = *v98;
      if (Parent == *v98)
        goto LABEL_107;
    }
    if (v100)
      v104 = v100;
    else
      v104 = v98;
    goto LABEL_106;
  }
LABEL_107:
  v105 = (uint64_t *)v98[1];
  if (!v105)
  {
    v106 = *(mlir::Operation **)(v180 + 16);
    v105 = (uint64_t *)operator new();
    mlir::Region::Region(v105, v106);
    v107 = (mlir::Region *)v98[1];
    v98[1] = (uint64_t)v105;
    if (v107)
    {
      mlir::Region::~Region(v107);
      MEMORY[0x20BD002F8]();
      v105 = (uint64_t *)v98[1];
    }
  }
  v108 = (uint64_t *)(v183 + 8);
  v109 = *(uint64_t **)(v183 + 16);
  if (v105 != (uint64_t *)(v183 + 8) && v109 != v105)
  {
    llvm::ilist_traits<mlir::Block>::transferNodesFromList((uint64_t)v105, v180, v183 + 8, *(_QWORD *)(v183 + 16));
    if (v109 != v108)
    {
      v111 = *v109;
      v112 = *v108;
      *(_QWORD *)(v112 + 8) = v109;
      *v109 = v112;
      v113 = *v105;
      *(_QWORD *)(v111 + 8) = v105;
      *v108 = v113;
      *(_QWORD *)(v113 + 8) = v108;
      *v105 = v111;
    }
  }
  v114 = (char *)(v172 + 40);
  llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>,mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>::try_emplace<llvm::detail::DenseSetEmpty&>((int64x2_t *)(v172 + 40), &v183, (uint64_t)&v195);
  *(_QWORD *)&v195 = v169;
  *((_QWORD *)&v195 + 1) = v183;
  v196 = v198;
  v197 = 0x100000000;
  v115 = v185;
  v116 = v169;
  if (!(_DWORD)v185)
    goto LABEL_126;
  if (__src == v186)
  {
    if (v185 < 2)
    {
      v117 = v185;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v196, v198, v185, 24);
      v117 = v185;
      if (!(_DWORD)v185)
        goto LABEL_124;
    }
    memcpy(v196, __src, 24 * v117);
LABEL_124:
    LODWORD(v197) = v115;
    v116 = (mlir::Block *)v195;
    goto LABEL_125;
  }
  v196 = __src;
  v197 = v185;
  __src = v186;
  HIDWORD(v185) = 0;
  v116 = v169;
LABEL_125:
  LODWORD(v185) = 0;
LABEL_126:
  v199 = v187;
  v118 = *(_DWORD *)(v172 + 16);
  if (!v118)
    goto LABEL_176;
  v119 = (v118 - 1) & ((v116 >> 4) ^ (v116 >> 9));
  v120 = (mlir::Block **)(*(_QWORD *)v172 + 16 * v119);
  v121 = *v120;
  if (v116 == *v120)
    goto LABEL_157;
  v122 = 0;
  v123 = 1;
  while (v121 != (mlir::Block *)-4096)
  {
    if (v122)
      v124 = 0;
    else
      v124 = v121 == (mlir::Block *)-8192;
    if (v124)
      v122 = v120;
    v125 = v119 + v123++;
    v119 = v125 & (v118 - 1);
    v120 = (mlir::Block **)(*(_QWORD *)v172 + 16 * v119);
    v121 = *v120;
    if (v116 == *v120)
      goto LABEL_157;
  }
  v140 = (uint64_t)(v122 ? v122 : v120);
  v141 = *(_DWORD *)(v172 + 8);
  if (4 * v141 + 4 < 3 * v118)
  {
    if (v118 + ~v141 - *(_DWORD *)(v172 + 12) > v118 >> 3)
    {
LABEL_139:
      v126 = *(mlir::Block **)v140;
      goto LABEL_140;
    }
  }
  else
  {
LABEL_176:
    v118 *= 2;
  }
  llvm::DenseMap<void const*,unsigned int,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseMapPair<void const*,unsigned int>>::grow(v172, v118);
  v142 = *(_DWORD *)(v172 + 16) - 1;
  v143 = v142 & ((v116 >> 4) ^ (v116 >> 9));
  v140 = *(_QWORD *)v172 + 16 * v143;
  v144 = *(mlir::Block **)v140;
  if (v116 != *(mlir::Block **)v140)
  {
    v162 = 0;
    v163 = 1;
    while (v144 != (mlir::Block *)-4096)
    {
      if (v162)
        v164 = 0;
      else
        v164 = v144 == (mlir::Block *)-8192;
      if (v164)
        v162 = v140;
      v165 = v143 + v163++;
      v143 = v165 & v142;
      v140 = *(_QWORD *)v172 + 16 * (v165 & v142);
      v144 = *(mlir::Block **)v140;
      if (v116 == *(mlir::Block **)v140)
      {
        v126 = v116;
        v93 = v172;
        goto LABEL_140;
      }
    }
    if (v162)
      v140 = v162;
    v93 = v172;
    goto LABEL_139;
  }
  v126 = v116;
LABEL_140:
  ++*(_DWORD *)(v93 + 8);
  if (v126 != (mlir::Block *)-4096)
    --*(_DWORD *)(v93 + 12);
  *(_QWORD *)v140 = v116;
  *(_DWORD *)(v140 + 8) = 0;
  v127 = v93;
  v128 = (char **)(v93 + 24);
  v129 = *(unsigned int *)(v127 + 32);
  *(_DWORD *)(v140 + 8) = v129;
  if (v129 < *(_DWORD *)(v127 + 36))
  {
    v130 = (uint64_t)&(*v128)[64 * v129];
    *(_OWORD *)v130 = v195;
    v131 = (void *)(v130 + 32);
    *(_QWORD *)(v130 + 16) = v130 + 32;
    v132 = (void **)(v130 + 16);
    *(_QWORD *)(v130 + 24) = 0x100000000;
    v133 = v197;
    v134 = (_BYTE **)(v130 + 16) == &v196 || (_DWORD)v197 == 0;
    v10 = v169;
    if (v134)
      goto LABEL_156;
    if (v196 != v198)
    {
      *v132 = v196;
      *(_DWORD *)(v130 + 24) = v133;
      *(_DWORD *)(v130 + 28) = HIDWORD(v197);
      v196 = v198;
      HIDWORD(v197) = 0;
LABEL_155:
      LODWORD(v197) = 0;
LABEL_156:
      *(_QWORD *)(v130 + 56) = v199;
      ++*(_DWORD *)(v172 + 32);
LABEL_157:
      v137 = v196;
      if (v196 == v198)
        goto LABEL_159;
      goto LABEL_158;
    }
    if (v197 < 2)
    {
      v136 = v198;
      v135 = v197;
    }
    else
    {
      *(_DWORD *)(v130 + 24) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v130 + 16, (void *)(v130 + 32), v133, 24);
      v135 = v197;
      if (!(_DWORD)v197)
      {
LABEL_154:
        *(_DWORD *)(v130 + 24) = v133;
        goto LABEL_155;
      }
      v136 = v196;
      v131 = *v132;
    }
    memcpy(v131, v136, 24 * v135);
    goto LABEL_154;
  }
  v181 = 0;
  v145 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)v128, v114, 0, 64, &v181);
  v146 = &v145[64 * (unint64_t)*(unsigned int *)(v172 + 32)];
  *(_OWORD *)v146 = v195;
  v147 = v146 + 32;
  *((_QWORD *)v146 + 2) = v146 + 32;
  v148 = (void **)(v146 + 16);
  *((_QWORD *)v146 + 3) = 0x100000000;
  if (v146 + 16 != (char *)&v196)
  {
    v149 = v197;
    if ((_DWORD)v197)
    {
      if (v196 != v198)
      {
        *v148 = v196;
        *((_DWORD *)v146 + 6) = v149;
        *((_DWORD *)v146 + 7) = HIDWORD(v197);
        v196 = v198;
        HIDWORD(v197) = 0;
LABEL_189:
        LODWORD(v197) = 0;
        goto LABEL_190;
      }
      if (v197 < 2)
      {
        v151 = v198;
        v150 = v197;
      }
      else
      {
        *((_DWORD *)v146 + 6) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v146 + 16), v146 + 32, v149, 24);
        v150 = v197;
        if (!(_DWORD)v197)
        {
LABEL_188:
          *((_DWORD *)v146 + 6) = v149;
          goto LABEL_189;
        }
        v151 = v196;
        v147 = *v148;
      }
      memcpy(v147, v151, 24 * v150);
      goto LABEL_188;
    }
  }
LABEL_190:
  *((_QWORD *)v146 + 7) = v199;
  v152 = *(char **)(v172 + 24);
  v153 = *(unsigned int *)(v172 + 32);
  if ((_DWORD)v153)
  {
    v154 = &v152[64 * v153];
    v155 = v145 + 16;
    v156 = (uint64_t)(v152 + 16);
    do
    {
      v157 = v156 - 16;
      *((_OWORD *)v155 - 1) = *(_OWORD *)(v156 - 16);
      *v155 = v155 + 2;
      v155[1] = 0x100000000;
      if (*(_DWORD *)(v156 + 8))
      v155[5] = *(_QWORD *)(v156 + 40);
      v155 += 8;
      v156 += 64;
    }
    while ((char *)(v157 + 64) != v154);
    v152 = *(char **)(v172 + 24);
    v158 = *(unsigned int *)(v172 + 32);
    if ((_DWORD)v158)
    {
      v159 = v158 << 6;
      do
      {
        v160 = *(char **)&v152[v159 - 48];
        if (&v152[v159 - 32] != v160)
          free(v160);
        v159 -= 64;
      }
      while (v159);
      v152 = *v128;
    }
  }
  v161 = v181;
  if (v152 != v114)
    free(v152);
  *(_QWORD *)(v172 + 24) = v145;
  ++*(_DWORD *)(v172 + 32);
  *(_DWORD *)(v172 + 36) = v161;
  v10 = v169;
  v137 = v196;
  if (v196 != v198)
LABEL_158:
    free(v137);
LABEL_159:
  if (!(_QWORD)v167)
  {
    *v168 = 0;
    v168[1] = 0;
    v138 = __src;
    if (__src == v186)
      goto LABEL_162;
    goto LABEL_161;
  }
  *(_OWORD *)v168 = v167;
  v138 = __src;
  if (__src != v186)
LABEL_161:
    free(v138);
LABEL_162:
  if (v189 != v191)
    free(v189);
  if (v192 != (int64x2_t *)v194)
    free(v192);
  return (uint64_t)v10;
}

